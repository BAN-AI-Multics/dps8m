	COMPILATION LISTING OF SEGMENT dc_find
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1012.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-05-31,EJSharpe), approve(86-02-20,MCR7301),
       13*     audit(86-04-07,Swenson), install(86-04-23,MR12.0-1044):
       14*     fix bug where get_link_target would not update dir argument
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* The master module within directory control that finds directories or 
       19*directory entries, checks access, audits successful accesses and attempted
       20*access violations and produces correct user visible error codes.
       21*
       22*Produced out of what once was find_, find_entry, find_dirsegno,
       23*dir_control_error and parts of uid_path_util by Keith Loepere, June 1984.
       24*
       25*Modified throughout 1984 by Keith Loepere for successful access auditing,
       26*centralization of access decisions, etc.
       27*Modified 84-11-27 by EJ Sharpe to change access_audit_ arg list
       28*Modified 85-01-07 by Keith Loepere for obj_for_audit.
       29*Modified 85-02-19 by Keith Loepere so that append through links returns the
       30*   target path.
       31*Modified 85-02-25 by Keith Loepere to bring back existence entrypoint.
       32*Modified 85-04-01 by Keith Loepere for new access_audit_check_ep_ and fix
       33*     to truncating MSFs.
       34*Modified 85-04-08 by Keith Loepere to use fs_modes whenever possible,
       35*     which has the advantage of understanding priv init objects.
       36*Modified 85-05-08 by EJ Sharpe to add obj_delete_uid (non-privileged) and to
       37*     make uid path searches obey AIM rules for making dir names known
       38*Modified 85-05-15 by EJ Sharpe to change dir_write_raw_uid to mdir_set_quota_uid
       39**/
       40 
       41 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       42 
       43 dc_find: proc;
       44 	return;
       45 
       46 /* External */
       47 
       48 dcl  active_all_rings_data$maxlinks	fixed bin ext;
       49 dcl  dseg$			(0:4095) fixed bin (71) ext static;
       50 dcl  error_table_$bad_uidpath		fixed bin (35) ext;
       51 dcl  error_table_$badpath		fixed bin (35) ext;
       52 dcl  error_table_$dirseg		fixed bin (35) ext;
       53 dcl  error_table_$entlong		fixed bin (35) ext;
       54 dcl  error_table_$incorrect_access	fixed bin (35) ext;
       55 dcl  error_table_$link		fixed bin (35) ext;
       56 dcl  error_table_$moderr		fixed bin (35) ext;
       57 dcl  error_table_$mylock		fixed bin (35) ext;
       58 dcl  error_table_$no_dir		fixed bin (35) ext;
       59 dcl  error_table_$no_info		fixed bin (35) ext;
       60 dcl  error_table_$no_s_permission	fixed bin (35) ext;
       61 dcl  error_table_$namedup		fixed bin (35) ext;
       62 dcl  error_table_$noentry		fixed bin (35) ext;
       63 dcl  error_table_$not_link		fixed bin (35) ext;
       64 dcl  error_table_$notadir		fixed bin (35) ext;
       65 dcl  error_table_$oosw		fixed bin (35) ext;
       66 dcl  error_table_$root		fixed bin (35) ext;
       67 dcl  error_table_$seg_deleted		fixed bin (35) ext;
       68 dcl  error_table_$segknown		fixed bin (35) ext;
       69 dcl  error_table_$toomanylinks	fixed bin (35) ext;
       70 dcl  pds$access_authorization		bit (72) aligned ext;
       71 
       72 /* Entries */
       73 
       74 dcl  access_audit_check_ep_$self	entry (bit (36) aligned, bit (36) aligned, ptr) returns (bit (1));
       75 dcl  access_audit_check_ep_$user	entry (bit (36) aligned, bit (36) aligned, ptr, bit (72) aligned, bit (36) aligned) returns (bit (1));
       76 dcl  access_audit_$log_entry_ptr	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, fixed bin (18), char (*));
       77 dcl  access_audit_$log_entry_ptr_user	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, fixed bin (18), ptr, char (*));
       78 dcl  access_mode$effective		entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
       79 dcl  access_mode$raw		entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
       80 dcl  access_mode$user_effmode		entry (ptr, char (32) aligned, bit (72) aligned, fixed bin (3), bit (36) aligned, bit (36) aligned, fixed bin (35));
       81 dcl  aim_check_$greater_or_equal	entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       82 dcl  fs_modes$locked		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
       83 dcl  get_kstep			entry (fixed bin, ptr, fixed bin (35));
       84 dcl  hash$search			entry (ptr, ptr, ptr, fixed bin (35));
       85 dcl  level$get			entry () returns (fixed bin);
       86 dcl  lock$dir_lock_read		entry (ptr, fixed bin (35));
       87 dcl  lock$dir_lock_salvage		entry (ptr, bit (36) aligned, fixed bin (35));
       88 dcl  lock$dir_lock_write		entry (ptr, fixed bin (35));
       89 dcl  lock$dir_unlock		entry (ptr);
       90 dcl  makeknown_			entry (ptr, fixed bin (17), fixed bin (17), fixed bin (35));
       91 dcl  mlr_				entry (ptr, fixed bin (21), ptr, fixed bin (21));
       92 dcl  mrl_				entry (ptr, fixed bin (21), ptr, fixed bin (21));
       93 dcl  pathname_am$get_segno		entry (char (*) varying, fixed bin (17));
       94 dcl  pathname_am$set		entry (char (*) varying, fixed bin (17));
       95 dcl  read_allowed_			entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       96 dcl  sdw_util_$construct		entry (ptr, ptr);
       97 dcl  sdw_util_$dissect		entry (ptr, ptr);
       98 dcl  segno_usage$decrement		entry (fixed bin (17), fixed bin (35));
       99 dcl  sum$getbranch			entry (ptr, bit (36) aligned, ptr, fixed bin (35));
      100 dcl  sum$getbranch_root_my		entry (ptr, bit (36) aligned, ptr, fixed bin (35));
      101 dcl  update_kste_access		entry (ptr, ptr, bit (36) aligned);
      102 dcl  wired_utility_$grow_stack_frame	entry (fixed bin) returns (ptr);
      103 
      104 /* Misc */
      105 
      106 dcl  addcharno			builtin;
      107 dcl  addr				builtin;
      108 dcl  baseptr			builtin;
      109 dcl  binary			builtin;
      110 dcl  index			builtin;
      111 dcl  length			builtin;
      112 dcl  max				builtin;
      113 dcl  min				builtin;
      114 dcl  null				builtin;
      115 dcl  ptr				builtin;
      116 dcl  rel				builtin;
      117 dcl  reverse			builtin;
      118 dcl  rtrim			builtin;
      119 dcl  segno			builtin;
      120 dcl  size				builtin;
      121 dcl  string			builtin;
      122 dcl  substr			builtin;
      123 dcl  unspec			builtin;
      124 
      125 dcl  bad_dir_			condition;
      126 
      127 /* Parameters */
      128 
      129 dcl  a_audit_user_info_ptr		ptr parameter;
      130 dcl  a_bc				fixed bin (24) parameter;
      131 dcl  a_bc_delta			fixed bin (24) parameter;
      132 dcl  a_chase_sw			fixed bin (1) parameter;
      133 dcl  a_code			fixed bin (35) parameter;
      134 dcl  a_detailed_operation		fixed bin (18) uns parameter;
      135 dcl  a_dir_uid			bit (36) aligned parameter;
      136 dcl  a_dirname			char (168) unal parameter;
      137 dcl  a_dp				ptr parameter;
      138 dcl  a_entryname			char (32) unal parameter;
      139 dcl  a_ep				ptr parameter;
      140 dcl  a_exmode			bit (36) aligned parameter;
      141 dcl  a_kstep			ptr parameter;
      142 dcl  a_mode			bit (36) aligned parameter;
      143 dcl  a_pep			ptr parameter;
      144 dcl  a_ppep			ptr parameter;
      145 dcl  a_ringbr			(3) fixed bin (3) parameter;
      146 dcl  a_segptr			ptr parameter;
      147 dcl  a_unlocksw			bit (1) aligned parameter;
      148 dcl  a_uidpath			(0:15) bit (36) aligned parameter;
      149 
      150 /* Constants */
      151 
      152 dcl  FIND_ALL			bit (4) aligned init ("1111"b) static options (constant);
      153 dcl  FIND_DIR			bit (4) aligned init ("1000"b) static options (constant);
      154 dcl  FIND_DIR_OR_LINK		bit (4) aligned init ("1100"b) static options (constant);
      155 dcl  FIND_LINK			bit (4) aligned init ("0100"b) static options (constant);
      156 dcl  FIND_LINK_OR_NOTHING		bit (4) aligned init ("0110"b) static options (constant);
      157 dcl  FIND_NOTHING			bit (4) aligned init ("0010"b) static options (constant);
      158 dcl  FIND_OBJECT_OR_LINK		bit (4) aligned init ("1101"b) static options (constant);
      159 dcl  FIND_SEG			bit (4) aligned init ("0001"b) static options (constant);
      160 dcl  ME				char (7) init ("dc_find") static options (constant);
      161 dcl  READ_LOCK			bit (36) aligned init ("0"b) static options (constant);
      162 dcl  WRITE_LOCK			bit (36) aligned init ("1"b) static options (constant);
      163 
      164 /* Variables */
      165 
      166 dcl  access_checker			variable entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)); /* one of the access_mode$foo gets put here */
      167 dcl  change_bc			bit (1) aligned;
      168 dcl  chase_sw			fixed bin (1);
      169 dcl  code				fixed bin (35);
      170 dcl  dir_uid			bit (36) aligned;
      171 dcl  dirmode			bit (36) aligned;
      172 dcl  dirmode_raw			bit (1) aligned;
      173 dcl  dirname			char (168) var;
      174 dcl  entryname			char (32) aligned;
      175 dcl  exmode			bit (36) aligned;
      176 dcl  linkage_ring			fixed bin (3);
      177 dcl  lock_for_writing		bit (36) aligned;
      178 dcl  mode				bit (36) aligned;
      179 dcl  1 my_makeknown_info		aligned like makeknown_info;
      180 dcl  objmode			bit (36) aligned;
      181 dcl  pdp				ptr;
      182 dcl  pep				ptr;
      183 dcl  ppdp				ptr;
      184 dcl  ppep				ptr;
      185 dcl  ringbr			(3) fixed bin (3);
      186 dcl  1 sdwi			aligned like sdw_info;
      187 dcl  segptr			ptr;
      188 dcl  1 state			aligned,
      189        2 allow_searching_aim_isolated_dirs bit (1) aligned,
      190        2 allow_aim_isolated_final_dir	bit (1) aligned,
      191        2 dir_held			bit (1) aligned,
      192        2 dir_locked			bit (1) aligned,
      193        2 for_user			bit (1) aligned,	/* this is being done for someone else */
      194        2 parent_locked		bit (1) aligned,
      195        2 parent_parent_locked		bit (1) aligned,
      196        2 find_dir_has_work_area	bit (1) aligned,
      197        2 work_pathname_ptr		ptr,
      198        2 operation			bit (36) aligned,
      199        2 event_flags		bit (36) aligned,
      200        2 user			aligned like audit_user_info; /* user this is done for */
      201 dcl  uidpath			(0:15) bit (36) aligned;
      202 
      203 dir_for_append: entry (a_dirname, a_entryname, a_chase_sw, a_pep, a_dp, a_code);
      204 
      205 /* Used by append to find a pointer into a directory into which to append.  
      206*The dirname and entryname variables are updated to the target of the link if
      207*chase is specified.  The directory is returned locked. */
      208 
      209 	dirmode_raw = "0"b;
      210 	go to dir_for_append_join;
      211 
      212 dir_for_append_raw: entry (a_dirname, a_entryname, a_chase_sw, a_pep, a_dp, a_code);
      213 
      214 	dirmode_raw = "1"b;				/* admin_gate_ */
      215 
      216 dir_for_append_join:
      217 	call dir_name_setup;
      218 	dirmode = A_ACCESS;
      219 	state.operation = access_operations_$fs_obj_contents_mod; /* obj creation is audited by append */
      220 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CREATE_BRANCH;
      221 
      222 	entryname = a_entryname;
      223 	lock_for_writing = "1"b;
      224 	chase_sw = a_chase_sw;
      225 	a_pep, pep = null;
      226 
      227 	call find_$append;
      228 	if code ^= 0 then go to RETURN;
      229 
      230 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
      231 	if code = 0 then state.parent_locked = "1"b;
      232 	else if code = error_table_$root then code = 0;
      233 	else call fatal_error;
      234 	pdp = ptr (pep, 0);
      235 
      236 	if dirmode_raw then call access_mode$raw (pep, mode, exmode, code);
      237 	else call get_dir_mode$locked (dp, exmode, code);
      238 	if code ^= 0 then call fatal_error;
      239 	if (exmode & dirmode) ^= dirmode then do;
      240 	     call dir_control_error$append (pep, code);
      241 	     call fatal_error;
      242 	end;
      243 
      244 	call audit_success$msg (pep, entryname);
      245 
      246 	a_dirname = dirname;
      247 	a_entryname = entryname;
      248 	a_pep = pep;
      249 	a_dp = dp;
      250 	a_code = code;
      251 	return;
      252 
      253 dir_for_retrieve_append: entry (a_dirname, a_entryname, a_chase_sw, a_audit_user_info_ptr, a_pep, a_dp, a_code);
      254 
      255 /* Used by append to find a pointer into a directory into which to append.  
      256*The dirname and entryname variables are updated to the target of the link if
      257*chase is specified.  The directory is returned locked. */
      258 
      259 	call dir_name_setup;
      260 	state.operation = access_operations_$fs_obj_contents_mod; /* obj creation audited by append */
      261 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CREATE_BRANCH;
      262 
      263 	state.for_user = "1"b;
      264 	state.user = a_audit_user_info_ptr -> audit_user_info;
      265 
      266 	a_pep, pep = null;
      267 	entryname = a_entryname;
      268 	lock_for_writing = "1"b;
      269 	chase_sw = a_chase_sw;
      270 
      271 	call find_$append;
      272 	if code ^= 0 then go to RETURN;
      273 
      274 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
      275 	if code = 0 then state.parent_locked = "1"b;
      276 	else if code = error_table_$root then code = 0;
      277 	else call fatal_error;
      278 	pdp = ptr (pep, 0);
      279 
      280 	call access_mode$user_effmode (pep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
      281 	if code ^= 0 then call fatal_error;
      282 	if (exmode & A_ACCESS) ^= A_ACCESS then do;
      283 	     call dir_control_error$append (pep, code);
      284 	     call fatal_error;
      285 	end;
      286 
      287 	call audit_success$msg (pep, entryname);
      288 
      289 	a_dirname = dirname;
      290 	a_entryname = entryname;
      291 	a_pep = pep;
      292 	a_dp = dp;
      293 	a_code = code;
      294 	return;
      295 
      296 dir_initiate: entry (a_dirname, a_dp, a_code);
      297 
      298 /* Make the dir known (set_wdir, etc.). */
      299 
      300 	call dir_name_setup;
      301 	state.operation = access_operations_$fs_obj_initiate;
      302 	lock_for_writing = "0"b;
      303 
      304 	call find_locked_dir;
      305 	if code ^= 0 then go to RETURN;
      306 
      307 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
      308 	if code = 0 then state.parent_locked = "1"b;
      309 	else if code = error_table_$root then code = 0;
      310 	else call fatal_error;
      311 	pdp = ptr (pep, 0);
      312 
      313 	call get_dir_mode$locked (dp, exmode, code);	/* must have access to dir or parent */
      314 	if code ^= 0 then call fatal_error;
      315 	if exmode = "0"b then do;			/* check parent */
      316 	     if pdp ^= null then do;
      317 		call get_dir_mode (pdp, exmode, code);
      318 		if code ^= 0 then call fatal_error;
      319 	     end;
      320 	     if exmode = "0"b then do;
      321 		call dir_control_error$attributes (pep, code);
      322 		call fatal_error;
      323 	     end;
      324 	end;
      325 
      326 	call audit_success (pep);
      327 
      328 	if state.parent_locked then call lock$dir_unlock (pdp); /* done with parent */
      329 
      330 	a_dp = dp;
      331 	a_code = code;
      332 	return;
      333 
      334 dir_move_quota: entry (a_dirname, a_pep, a_dp, a_code);
      335 
      336 /* Used by quota moving.  Access checks are M on the target dir and M on the
      337*parent.  NOTE also that the final target is allowed to be upgraded. */
      338 
      339 	call dir_name_setup;
      340 	state.operation = access_operations_$fs_obj_contents_mod;
      341 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_MOVE_QUOTA;
      342 
      343 	a_pep, pep = null;
      344 	state.allow_aim_isolated_final_dir = "1"b;	/* This is the only known case where this is true. */
      345 	lock_for_writing = "1"b;
      346 
      347 	if dirname = ">" then do;
      348 	     code = error_table_$root;
      349 	     go to RETURN;
      350 	end;
      351 
      352 	call find_locked_dir;
      353 	if code ^= 0 then go to RETURN;
      354 
      355 	call sum$getbranch (dp, WRITE_LOCK, pep, code);
      356 	if code ^= 0 then call fatal_error;
      357 	pdp = ptr (pep, 0);
      358 	state.parent_locked = "1"b;
      359 
      360 	call get_dir_mode (pdp, exmode, code);
      361 	if code ^= 0 then call fatal_error;
      362 	if (exmode & M_ACCESS) ^= M_ACCESS | ^aim_check_$greater_or_equal (pep -> entry.access_class, dp -> dir.access_class) then do;
      363 						/* user not allowed to see dir for access or aim isolated */
      364 	     call dir_control_error$contents (pep, code);
      365 	     call fatal_error;
      366 	end;
      367 
      368 	call access_mode$raw (pep, mode, exmode, code);
      369 	if code ^= 0 then call fatal_error;
      370 	if (exmode & M_ACCESS) ^= M_ACCESS then do;
      371 	     call dir_control_error$contents (pep, code);
      372 	     call fatal_error;
      373 	end;
      374 
      375 	call audit_success (pep);
      376 
      377 	a_pep = pep;
      378 	a_dp = dp;
      379 	a_code = code;
      380 	return;
      381 
      382 dir_read: entry (a_dirname, a_dp, a_code);
      383 
      384 /* These return a pointer to a locked directory.  The use of these are for 
      385*cases in which the contents (name space, iacls) of a directory are desired.  
      386*The access requirements are effective s access on the dir for read, m for 
      387*write. */
      388 
      389 	lock_for_writing = "0"b;
      390 	dirmode = S_ACCESS;
      391 	call dir_name_setup;
      392 	state.operation = access_operations_$fs_obj_contents_read;
      393 	go to dir_join;
      394 
      395 dir_write: entry (a_dirname, a_detailed_operation, a_dp, a_code);
      396 
      397 	lock_for_writing = "1"b;
      398 	dirmode = M_ACCESS;
      399 	call dir_name_setup;
      400 	state.operation = access_operations_$fs_obj_contents_mod;
      401 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
      402 	go to dir_join;
      403 
      404 dir_read_priv: entry (a_dirname, a_dp, a_code);
      405 
      406 	lock_for_writing = "0"b;
      407 	dirmode = "0"b;
      408 	call dir_name_setup;
      409 	state.operation = access_operations_$fs_obj_contents_read;
      410 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      411 	go to dir_join;
      412 
      413 dir_write_priv: entry (a_dirname, a_detailed_operation, a_dp, a_code);
      414 
      415 	lock_for_writing = "1"b;
      416 	dirmode = "0"b;
      417 	call dir_name_setup;
      418 	state.operation = access_operations_$fs_obj_contents_mod;
      419 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
      420 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      421 
      422 dir_join:
      423 	call find_locked_dir;
      424 	if code ^= 0 then go to RETURN;
      425 
      426 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
      427 	if code = 0 then state.parent_locked = "1"b;
      428 	else if code = error_table_$root then code = 0;
      429 	else call fatal_error;
      430 	pdp = ptr (pep, 0);
      431 
      432 	if dirmode ^= "0"b then do;
      433 	     call get_dir_mode$locked (dp, exmode, code);
      434 	     if code ^= 0 then call fatal_error;
      435 	     if (exmode & dirmode) ^= dirmode then do;
      436 		call dir_control_error$contents (pep, code);
      437 		call fatal_error;
      438 	     end;
      439 	end;
      440 
      441 	call audit_success (pep);
      442 
      443 	if state.parent_locked then call lock$dir_unlock (pdp);
      444 
      445 	a_dp = dp;				/* Success! */
      446 	a_code = code;
      447 	return;
      448 
      449 dir_reclassify: entry (a_dirname, a_ppep, a_pep, a_dp, a_code);
      450 
      451 /* Return a pointer to a dir, its entry and its parent's parent's entry for the
      452*reclassify_node operation. */
      453 
      454 	call dir_name_setup;
      455 	state.operation = access_operations_$fs_obj_access_mod;
      456 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_RECLASSIFY_NODE;
      457 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      458 	a_pep, a_ppep, pep, ppep = null;
      459 	lock_for_writing = "1"b;
      460 
      461 	if dirname = ">" then do;
      462 	     code = error_table_$root;
      463 	     go to RETURN;
      464 	end;
      465 
      466 	call find_locked_dir;
      467 	if code ^= 0 then go to RETURN;
      468 
      469 	call sum$getbranch (dp, WRITE_LOCK, pep, code);
      470 	if code ^= 0 then call fatal_error;
      471 	pdp = ptr (pep, 0);
      472 	state.parent_locked = "1"b;
      473 
      474 	call access_mode$raw (pep, mode, exmode, code);	/* check raw mode on parent for reclassify */
      475 	if code ^= 0 then call fatal_error;
      476 	if (exmode & SM_ACCESS) ^= SM_ACCESS then do;
      477 	     call dir_control_error$contents (pep, code);
      478 	     call fatal_error;
      479 	end;
      480 
      481 	call sum$getbranch_root_my (pdp, READ_LOCK, ppep, code);
      482 	if code = 0 then state.parent_parent_locked = "1"b;
      483 	else if code = error_table_$root then code = 0;
      484 	else call fatal_error;
      485 	ppdp = ptr (ppep, 0);
      486 
      487 	call access_mode$raw (ppep, mode, exmode, code);
      488 	if code ^= 0 then call fatal_error;
      489 	if (exmode & M_ACCESS) ^= M_ACCESS then do;
      490 	     call dir_control_error$contents (pep, code);
      491 	     call fatal_error;
      492 	end;
      493 
      494 	call audit_success (pep);
      495 
      496 	a_ppep = ppep;
      497 	a_pep = pep;
      498 	a_dp = dp;
      499 	a_code = code;
      500 	return;
      501 
      502 dir_salvage: entry (a_dirname, a_dir_uid, a_dp, a_code);
      503 
      504 /* Entry used by the directory salvager.  It is like dir_write_priv except that
      505*it uses a special locking primitive. */
      506 
      507 	call dir_name_setup;
      508 	state.operation = access_operations_$fs_obj_contents_mod;
      509 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_DIR_SALVAGE;
      510 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      511 	a_dir_uid = "0"b;
      512 
      513 	call find_dir;
      514 	if code ^= 0 then go to RETURN;
      515 
      516 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
      517 	if code = 0 then state.parent_locked = "1"b;
      518 	else if code = error_table_$root then code = 0;
      519 	else call fatal_error;
      520 	pdp = ptr (pep, 0);
      521 
      522 	dir.modify = "0"b;
      523 
      524 	call lock$dir_lock_salvage (dp, dir_uid, code);
      525 	if code ^= 0 then call fatal_error;
      526 
      527 	call audit_success (pep);
      528 
      529 	if state.parent_locked then call lock$dir_unlock (pdp);
      530 
      531 	a_dir_uid = dir_uid;
      532 	a_dp = dp;				/* Success! */
      533 	a_code = code;
      534 	return;
      535 
      536 mdir_set_quota_uid: entry (a_uidpath, a_dirname, a_detailed_operation, a_pep, a_dp, a_code);
      537 
      538 /* Returns a pointer to a directory when given a uid path.  Access requirements
      539*are M on the dir. It is used by quota$mdir_set. */
      540 
      541 	unspec (state) = "0"b;
      542 	state.operation = access_operations_$fs_obj_contents_mod;
      543 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
      544 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      545 	state.allow_aim_isolated_final_dir = "1"b;
      546 
      547 	dirmode = M_ACCESS;
      548 	a_pep, pdp, pep, ep, a_dp, dp = null;
      549 	code = 0;
      550 	uidpath = a_uidpath;
      551 	lock_for_writing = "0"b;			/* parent dir is not beign modified */
      552 
      553 	call uid_path_util$find_dir;
      554 	if code = error_table_$root then a_dirname = dirname; /* Return name so far */
      555 	if code ^= 0 then go to RETURN;
      556 
      557 	call lock$dir_lock_write (dp, code);
      558 	if code ^= 0 then call fatal_error;
      559 	state.dir_locked = "1"b;
      560 
      561 	call sum$getbranch (dp, lock_for_writing, pep, code);
      562 	if code ^= 0 then call fatal_error;
      563 	pdp = ptr (pep, 0);
      564 	state.parent_locked = "1"b;
      565 
      566 	call access_mode$raw (pep, mode, exmode, code);
      567 	if code ^= 0 then call fatal_error;
      568 	if (exmode & dirmode) ^= dirmode then do;
      569 	     call dir_control_error$contents (pep, code);
      570 	     call fatal_error;
      571 	end;
      572 
      573 	call audit_success (pep);
      574 
      575 	a_dirname = dirname;
      576 	a_pep = pep;
      577 	a_dp = dp;
      578 	a_code = 0;
      579 	return;
      580 
      581 finished: entry (a_ep, a_unlocksw);
      582 
      583 /* Undoes the result of a previous dc_find (non-ptr) call.  It unlocks the dir 
      584*specified (if unlocksw is set) and dereferences the dir.  The proper 
      585*termination for a directory found through a _ptr entry is to call 
      586*lock$dir_unlock on it. */
      587 
      588 	ep = a_ep;
      589 	if ep ^= null then do;
      590 	     if a_unlocksw then call lock$dir_unlock (ptr (ep, 0));
      591 	     call segno_usage$decrement (segno (ep), (0));
      592 	end;
      593 	return;
      594 
      595 link_target: entry (a_dirname, a_entryname, a_code);
      596 
      597 /* Returns the path of the target of the (possible) link.  The user must have 
      598*non-null access to the target dir or non-null access to the target (if it 
      599*exists). */
      600 
      601 	unspec (state) = "0"b;
      602 	state.operation = access_operations_$fs_obj_prop_read;
      603 
      604 	code = 0;
      605 	dirname = rtrim (a_dirname);
      606 	entryname = a_entryname;
      607 	lock_for_writing = "0"b;
      608 
      609 	call find_$link_target;
      610 	if code ^= 0 then go to RETURN;
      611 
      612 	if ep ^= null then do;			/* a target exists */
      613 	     call get_dir_mode (dp, exmode, code);
      614 	     if code ^= 0 then call fatal_error;
      615 	     if exmode = N_ACCESS then do;		/* no dir access, check entry */
      616 		call access_mode$effective (ep, mode, exmode, code);
      617 		if code ^= 0 then call fatal_error;
      618 		if ep -> entry.dirsw then mode = exmode;
      619 		if mode = N_ACCESS then do;		/* null on both target dir and target */
      620 		     call dir_control_error$attributes (ep, code);
      621 		     call fatal_error;
      622 		end;
      623 	     end;
      624 
      625 	     call audit_success (ep);
      626 	end;
      627 	else do;
      628 	     state.operation = access_operations_$fs_obj_contents_read; /* reading names in dir */
      629 
      630 	     call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
      631 	     if code = 0 then state.parent_locked = "1"b;
      632 	     else if code = error_table_$root then code = 0;
      633 	     else call fatal_error;
      634 	     pdp = ptr (pep, 0);
      635 
      636 	     call get_dir_mode$locked (dp, exmode, code);
      637 	     if code ^= 0 then call fatal_error;
      638 	     if exmode = N_ACCESS then do;
      639 		code = error_table_$no_info;
      640 		call dir_control_error$name_non_existant (dp, code);
      641 		call fatal_error;
      642 	     end;
      643 
      644 	     call audit_success (pep);
      645 
      646 	     if state.parent_locked then call lock$dir_unlock (pdp);
      647 
      648 	     code = error_table_$noentry;		/* tell of non-existance */
      649 	end;
      650 
      651 	call lock$dir_unlock (dp);
      652 	call segno_usage$decrement (segno (dp), (0));	/* done with dir */
      653 
      654 	a_dirname = dirname;
      655 	a_entryname = entryname;
      656 	a_code = code;
      657 	return;
      658 
      659 obj_attributes_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
      660 
      661 /* Return a pointer to an entry in a locked directory.  These entries are used 
      662*when the attributes of an object (such as ring brackets) are desired that are
      663*accessible for either effective s access on the parent dir or non-null access 
      664*on the object (for read) or for m access on the parent dir or w/m access on 
      665*the object (for write). */
      666 
      667 	lock_for_writing = "0"b;
      668 	dirmode = S_ACCESS;
      669 	call obj_name_setup;
      670 	state.operation = access_operations_$fs_obj_prop_read;
      671 	go to obj_attributes_name_join;
      672 
      673 obj_attributes_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);
      674 
      675 	lock_for_writing = "1"b;
      676 	dirmode = M_ACCESS;
      677 	call obj_name_setup;
      678 	state.operation = access_operations_$fs_obj_attr_mod;
      679 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
      680 	go to obj_attributes_name_join;
      681 
      682 obj_terminate: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
      683 
      684 	lock_for_writing = "0"b;
      685 	dirmode = N_ACCESS;
      686 	call obj_name_setup;
      687 	state.operation = access_operations_$fs_obj_terminate;
      688 
      689 obj_attributes_name_join:
      690 	chase_sw = a_chase_sw;
      691 
      692 	call find_;
      693 	if code ^= 0 then go to RETURN;
      694 	go to obj_attributes_join;
      695 
      696 obj_existence_ptr: entry (a_segptr, a_ep, a_code);
      697 
      698 	lock_for_writing = "0"b;
      699 	dirmode = N_ACCESS;
      700 	call obj_ptr_setup;
      701 	state.operation = access_operations_$fs_obj_prop_read;
      702 	go to obj_attributes_ptr_join;
      703 
      704 obj_terminate_ptr: entry (a_segptr, a_ep, a_code);
      705 
      706 	lock_for_writing = "0"b;
      707 	dirmode = N_ACCESS;
      708 	call obj_ptr_setup;
      709 	state.operation = access_operations_$fs_obj_terminate;
      710 	go to obj_attributes_ptr_join;
      711 
      712 obj_attributes_read_ptr: entry (a_segptr, a_ep, a_code);
      713 
      714 	lock_for_writing = "0"b;
      715 	dirmode = S_ACCESS;
      716 	call obj_ptr_setup;
      717 	state.operation = access_operations_$fs_obj_prop_read;
      718 	go to obj_attributes_ptr_join;
      719 
      720 obj_attributes_write_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);
      721 
      722 	lock_for_writing = "1"b;
      723 	dirmode = M_ACCESS;
      724 	call obj_ptr_setup;
      725 	state.operation = access_operations_$fs_obj_attr_mod;
      726 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
      727 
      728 obj_attributes_ptr_join:
      729 	call find_segptr_branch;
      730 	if code ^= 0 then
      731 	     if code = error_table_$root & state.operation = access_operations_$fs_obj_terminate then go to obj_attribute_success;
      732 	     else go to SEGPTR_FAILURE;
      733 
      734 obj_attributes_join:
      735 	call get_dir_mode (dp, exmode, code);
      736 	if code ^= 0 then call fatal_error;
      737 	if (exmode & dirmode) = dirmode then
      738 	     if exmode = N_ACCESS then go to obj_attributes_check_target; /* dirmode of N_ACCESS can also bring us here */
      739 	     else ;
      740 	else do;					/* wrong parent access, check for access on target */
      741 obj_attributes_check_target:
      742 	     if ^ep -> entry.bs then go to obj_attributes_error; /* link */
      743 	     if state.dir_held then			/* path entry */
      744 		call access_mode$effective (ep, mode, exmode, code);
      745 	     else call fs_modes$locked (segptr, mode, exmode, ringbr, code);
      746 	     if code ^= 0 then call fatal_error;
      747 	     if dirmode = M_ACCESS then do;		/* we need m/w if we do not have m on parent */
      748 		if ep -> entry.dirsw then
      749 		     if (exmode & M_ACCESS) ^= M_ACCESS then go to obj_attributes_error;
      750 		     else ;
      751 		else if (mode & W_ACCESS) ^= W_ACCESS then go to obj_attributes_error;
      752 		else ;
      753 	     end;
      754 	     else do;				/* we'll allow since user has non-null on object */
      755 		if ep -> entry.dirsw then mode = exmode;
      756 		if mode = N_ACCESS then do;
      757 obj_attributes_error:    call dir_control_error$attributes (ep, code);
      758 		     call fatal_error;
      759 		end;
      760 		else ;
      761 	     end;
      762 	end;
      763 
      764 obj_attribute_success:
      765 	call audit_success (ep);
      766 
      767 	a_ep = ep;				/* Success! */
      768 	a_code = code;
      769 	return;
      770 
      771 obj_bc_delta_write: entry (a_dirname, a_entryname, a_bc_delta, a_ep, a_code);
      772 
      773 /* Return a pointer to a directory entry.  These entries are called when the
      774*caller wishes to change the bit_coount for an object.  The delta entries are 
      775*called when the bit_count is to added to/subtracted from; the non-delta when
      776*bc is to be set.  These entries have strange access requirements; w if a 
      777*segment; for a directory, m if lowering the bc, a if increasing. */
      778 
      779 	change_bc = "1"b;
      780 	go to obj_bc_name_join;
      781 
      782 obj_bc_write: entry (a_dirname, a_entryname, a_bc, a_ep, a_code);
      783 
      784 	change_bc = "0"b;
      785 
      786 obj_bc_name_join:
      787 	call obj_name_setup;
      788 	state.operation = access_operations_$fs_obj_contents_mod;
      789 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_BC_MOD;
      790 	lock_for_writing = "1"b;
      791 	chase_sw = DC_FIND_CHASE;
      792 
      793 	call find_;
      794 	if code ^= 0 then go to RETURN;
      795 
      796 	call access_mode$effective (ep, mode, exmode, code);
      797 	if code ^= 0 then call fatal_error;
      798 	go to obj_bc_join;
      799 
      800 obj_bc_delta_write_ptr: entry (a_segptr, a_bc_delta, a_ep, a_code);
      801 
      802 	change_bc = "1"b;
      803 	go to obj_bc_ptr_join;
      804 
      805 obj_bc_write_ptr: entry (a_segptr, a_bc, a_ep, a_code);
      806 
      807 	change_bc = "0"b;
      808 
      809 obj_bc_ptr_join:
      810 	lock_for_writing = "1"b;
      811 
      812 	call obj_ptr_setup;
      813 	state.operation = access_operations_$fs_obj_contents_mod;
      814 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_BC_MOD;
      815 
      816 	call find_segptr_branch;
      817 	if code ^= 0 then go to SEGPTR_FAILURE;
      818 
      819 	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
      820 	if code ^= 0 then call fatal_error;
      821 
      822 obj_bc_join:
      823 	if ep -> entry.dirsw then do;
      824 	     mode = exmode;
      825 	     if change_bc then
      826 		if a_bc_delta <= 0 then objmode = M_ACCESS; /* viewed as deleting components of msf */
      827 		else objmode = A_ACCESS;		/* adding components */
      828 	     else if ep -> entry.bc >= a_bc then objmode = M_ACCESS;
      829 	     else objmode = A_ACCESS;
      830 	end;
      831 	else objmode = W_ACCESS;
      832 	if (mode & objmode) ^= objmode then do;
      833 	     call dir_control_error$contents (ep, code);
      834 	     call fatal_error;
      835 	end;
      836 
      837 	call audit_success (ep);
      838 
      839 	a_ep = ep;
      840 	a_code = code;
      841 	return;
      842 
      843 obj_for_audit: entry (a_dirname, a_entryname, a_ep, a_code);
      844 
      845 /* Returns a pointer to an entry in a locked directory.  No access check or
      846*auditing are done, in as much as access_audit_ is calling us so that it can
      847*audit somthing about the path supplied. */
      848 
      849 	lock_for_writing = "0"b;
      850 	call obj_name_setup;
      851 	state.operation = access_operations_$fs_obj_prop_read; /* in case something goes wrong */
      852 	chase_sw = DC_FIND_NO_CHASE;
      853 
      854 	call find_;
      855 	if code ^= 0 then go to RETURN;
      856 
      857 	a_ep = ep;
      858 	a_code = code;
      859 	return;
      860 
      861 obj_initiate: entry (a_dirname, a_entryname, a_ep, a_code);
      862 
      863 /* Returns the entry pointer for the initiate function.  The access check is
      864*non-null on the object.  The _dp versions take a directory pointer instead
      865*of a directory name.  For these (used by fs_search), a simple dir look-up is
      866*done.  If the object found is a link, though, we must perform a normal
      867*branch lookup.  In this case, a_dp is set to null, warning the user that
      868*his dp is no longer good and that finished must be called.  The raw version
      869*only checks raw access on the target;  it also simulates dir priv by ignoring
      870*the upgradedness of directories when searching them.  The auth version uses 
      871*authorization access. */
      872 
      873 	call obj_name_setup;
      874 	state.operation = access_operations_$fs_obj_initiate;
      875 
      876 	access_checker = access_mode$effective;
      877 	go to initiate_name_join;
      878 
      879 obj_initiate_raw: entry (a_dirname, a_entryname, a_ep, a_code);
      880 
      881 	call obj_name_setup;
      882 	state.operation = access_operations_$fs_obj_initiate;
      883 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
      884 
      885 	state.allow_searching_aim_isolated_dirs = "1"b;
      886 	access_checker = access_mode$raw;
      887 
      888 initiate_name_join:
      889 	lock_for_writing = "0"b;
      890 	chase_sw = DC_FIND_CHASE;
      891 
      892 	call find_;
      893 	if code = 0 then ;
      894 	else if code = error_table_$root then do;
      895 	     dp, ep = null;
      896 	     code = 0;
      897 	end;
      898 	else go to RETURN;
      899 	go to initiate_join;
      900 
      901 obj_initiate_for_linker_dp: entry (a_dp, a_entryname, a_ep, a_code);
      902 
      903 /* NOTE: we have a contract that the only caller of this is initiate_seg_count,
      904*which in turn is only called by fs_search.  Since this is the case, we perform
      905*an optimization that throws away information (providing no security 
      906*violation).  For this entry, we merge the non-existance of the target with
      907*no_info access to the target and call the result no_info in both cases. */
      908 
      909 	unspec (state) = "0"b;
      910 	state.operation = access_operations_$fs_obj_initiate;
      911 
      912 	access_checker = access_mode$effective;
      913 
      914 	lock_for_writing = "0"b;
      915 	a_ep, ep = null;
      916 	dp = a_dp;
      917 	entryname = a_entryname;
      918 	code = 0;
      919 
      920 	call lock$dir_lock_read (dp, code);
      921 	if code ^= 0 then go to RETURN;
      922 	state.dir_locked = "1"b;
      923 
      924 	call find_entry (dp, entryname, FIND_ALL, ep, code);
      925 	if code ^= 0 then call fatal_error;
      926 	if ep = null then do;			/* no such name */
      927 	     code = error_table_$no_info;		/* don't bother distinguishing this from no_entry, fs_search doesn't care */
      928 	     call fatal_error;
      929 	end;
      930 
      931 	if ^ep -> entry.bs then do;			/* link */
      932 	     dirname = rtrim (substr (ep -> link.pathname, 1, ep -> link.pathname_size));
      933 	     entryname = "";
      934 	     call lock$dir_unlock (dp);
      935 	     state.dir_locked = "0"b;
      936 	     a_dp = null;				/* tell user his dp isn't good anymore; finished must be called */
      937 	     call find_$link_target;
      938 	     if code = 0 then do;
      939 		if ep = null then do;		/* no such target */
      940 		     code = error_table_$no_info;	/* don't bother distinguishing this from no_entry, fs_search doesn't care */
      941 		     call fatal_error;
      942 		end;
      943 	     end;
      944 	     else if code = error_table_$root then do;
      945 		dp, ep = null;
      946 		code = 0;
      947 	     end;
      948 	     else go to RETURN;
      949 	end;
      950 
      951 initiate_join:
      952 	call access_checker (ep, mode, exmode, code);
      953 	if code ^= 0 then call fatal_error;
      954 
      955 /* We allow initiating dirs only if the mode and exmode are non_null. */
      956 
      957 	if ep = null then				/* root */
      958 	     if exmode = "0"b then go to obj_initiate_error;
      959 	     else ;
      960 	else if ep -> entry.dirsw then
      961 	     if exmode = "0"b then go to obj_initiate_error;
      962 
      963 	if mode = "0"b then do;
      964 obj_initiate_error:
      965 	     if ep = null then code = error_table_$dirseg;/* not nice to ask for root */
      966 	     else if ep -> entry.dirsw then do;
      967 		call dir_control_error$contents_info (ep, code); /* asking for dir is not considered a real violation */
      968 		if code = error_table_$moderr then code = error_table_$dirseg;
      969 	     end;
      970 	     else call dir_control_error$contents (ep, code);
      971 	     call fatal_error;
      972 	end;
      973 
      974 	call audit_success (ep);
      975 
      976 	a_ep = ep;
      977 	a_code = code;
      978 	return;
      979 
      980 obj_linkage_ring_ptr: entry (a_segptr, a_code);
      981 
      982 /* Allows a user process to read the definitions for a lower ring gate by
      983*lowering the ring number in the supplied pointer from within the call bracket 
      984*into the read bracket. */
      985 
      986 	unspec (state) = "0"b;
      987 	state.operation = access_operations_$fs_obj_contents_read;
      988 
      989 	ep = null;
      990 	code = 0;
      991 	segptr = a_segptr;
      992 
      993 	lock_for_writing = "0"b;
      994 
      995 	call find_segptr_branch;
      996 	if code ^= 0 then go to SEGPTR_FAILURE;
      997 
      998 	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
      999 	if code ^= 0 then call fatal_error;
     1000 
     1001 	if (mode & E_ACCESS) ^= E_ACCESS then do;
     1002 	     call dir_control_error$attributes (ep, code);
     1003 	     call fatal_error;
     1004 	end;
     1005 
     1006 	call audit_success (ep);
     1007 
     1008 	call lock$dir_unlock (dp);
     1009 
     1010 	linkage_ring = min (level$get (), ringbr (2));	/* let read through call bracket */
     1011 
     1012 	addr (a_segptr) -> its_unsigned.ringno = linkage_ring;
     1013 	a_code = code;
     1014 	return;
     1015 
     1016 obj_modes_ptr: entry (a_segptr, a_mode, a_exmode, a_ringbr, a_code);
     1017 
     1018 /* Return the access modes the process has to the object, assuming it has some
     1019*access. */
     1020 
     1021 	unspec (state) = "0"b;
     1022 	state.operation = access_operations_$fs_obj_prop_read;
     1023 	ep = null;
     1024 	code = 0;
     1025 	segptr = a_segptr;
     1026 
     1027 	lock_for_writing = "0"b;
     1028 
     1029 	call sum$getbranch_root_my (segptr, lock_for_writing, ep, code);
     1030 	if code ^= 0 then
     1031 	     if code = error_table_$root then do;
     1032 		code = 0;
     1033 		ep = null;
     1034 	     end;
     1035 	     else go to SEGPTR_FAILURE;
     1036 	else do;
     1037 	     dp = ptr (ep, 0);
     1038 	     state.dir_locked = "1"b;
     1039 	end;
     1040 
     1041 	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
     1042 	if code ^= 0 then call fatal_error;
     1043 
     1044 	if ep = null then do;
     1045 	     mode = exmode;				/* root */
     1046 	     exmode = "0"b;
     1047 	end;
     1048 	else if ep -> entry.dirsw then do;
     1049 	     mode = exmode;				/* dir */
     1050 	     exmode = "0"b;
     1051 	end;
     1052 
     1053 	if mode = "0"b then do;			/* make sure user is allowed to see no access */
     1054 	     if ep = null then dirmode = "0"b;		/* root */
     1055 	     else do;
     1056 		call get_dir_mode (dp, dirmode, code);
     1057 		if code ^= 0 then call fatal_error;
     1058 	     end;
     1059 	     if (dirmode & S_ACCESS) ^= S_ACCESS then do;
     1060 		call dir_control_error$attributes (ep, code);
     1061 		call fatal_error;
     1062 	     end;
     1063 	end;
     1064 
     1065 	call audit_success (ep);
     1066 
     1067 	if ep -> entry.dirsw then code = error_table_$dirseg;
     1068 	if state.dir_locked then call lock$dir_unlock (dp);
     1069 
     1070 	a_mode = mode;
     1071 	a_exmode = exmode;
     1072 	a_ringbr = ringbr;
     1073 	a_code = code;
     1074 	return;
     1075 
     1076 obj_reclassify: entry (a_dirname, a_entryname, a_pep, a_ep, a_code);
     1077 
     1078 /* Return a pointer to a directory entry and its parent entry for the 
     1079*reclassify operation. */
     1080 
     1081 	call obj_name_setup;
     1082 	state.operation = access_operations_$fs_obj_access_mod;
     1083 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_RECLASSIFY;
     1084 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1085 
     1086 	lock_for_writing = "1"b;
     1087 	a_pep, pep = null;
     1088 	chase_sw = DC_FIND_NO_CHASE;
     1089 
     1090 	call find_;
     1091 	if code ^= 0 then go to RETURN;
     1092 
     1093 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
     1094 	if code = 0 then state.parent_locked = "1"b;
     1095 	else if code = error_table_$root then code = 0;	/* dep is null but access_mode understands this */
     1096 	else call fatal_error;
     1097 	pdp = ptr (pep, 0);
     1098 
     1099 	call access_mode$raw (pep, mode, exmode, code);	/* check raw mode on parent for reclassify */
     1100 	if code ^= 0 then call fatal_error;
     1101 	if (exmode & M_ACCESS) ^= M_ACCESS then do;
     1102 	     call dir_control_error$attributes (pep, code);
     1103 	     call fatal_error;
     1104 	end;
     1105 
     1106 	call audit_success (ep);
     1107 
     1108 	a_pep = pep;
     1109 	a_ep = ep;
     1110 	a_code = code;
     1111 	return;
     1112 
     1113 obj_status_attributes_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
     1114 
     1115 /* Same as obj_attributes_read except that it returns the code no_s_permission 
     1116*if this is the case.  It is used by the status_ and status_long functions. */
     1117 
     1118 	call obj_name_setup;
     1119 	state.operation = access_operations_$fs_obj_prop_read;
     1120 
     1121 	lock_for_writing = "0"b;
     1122 	dirmode = S_ACCESS;
     1123 	chase_sw = a_chase_sw;
     1124 
     1125 	call find_;
     1126 	if code ^= 0 then go to RETURN;
     1127 
     1128 	call get_dir_mode (dp, exmode, code);
     1129 	if code ^= 0 then call fatal_error;
     1130 	if (exmode & dirmode) ^= dirmode then do;
     1131 	     if ep -> entry.bs then do;
     1132 		call access_mode$effective (ep, mode, exmode, code); /* look for non-null on object */
     1133 		if code ^= 0 then call fatal_error;
     1134 		if ep -> entry.dirsw then mode = exmode;
     1135 		if mode = N_ACCESS then do;
     1136 		     call dir_control_error$attributes (ep, code); /* We have no access on object; check access on parent dir for error code. */
     1137 		     call fatal_error;
     1138 		end;
     1139 		else call dir_control_error$status (ep, code); /* audit partial lack of access, return ep anyway */
     1140 	     end;
     1141 	     else do;
     1142 		call dir_control_error$attributes (ep, code); /* link */
     1143 		call fatal_error;
     1144 	     end;
     1145 	end;
     1146 
     1147 	call audit_success (ep);
     1148 
     1149 	a_ep = ep;				/* Success! */
     1150 	a_code = code;
     1151 	return;
     1152 
     1153 obj_status_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
     1154 
     1155 /* Returns a pointer to an entry in a locked directory.  These entries are used
     1156*when the attributes of an object that are considered as belonging to the 
     1157*parent dir (acls, names) are desired.  The access requirements are effective s 
     1158*access on the dir for read, m for write. */
     1159 
     1160 	lock_for_writing = "0"b;
     1161 	dirmode = S_ACCESS;
     1162 	call obj_name_setup;
     1163 	state.operation = access_operations_$fs_obj_prop_read;
     1164 	go to obj_status_name_join;
     1165 
     1166 obj_status_read_priv: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
     1167 
     1168 	lock_for_writing = "0"b;
     1169 	dirmode = "0"b;
     1170 	call obj_name_setup;
     1171 	state.operation = access_operations_$fs_obj_prop_read;
     1172 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1173 	go to obj_status_name_join;
     1174 
     1175 obj_access_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);
     1176 
     1177 	lock_for_writing = "1"b;
     1178 	dirmode = M_ACCESS;
     1179 	call obj_name_setup;
     1180 	state.operation = access_operations_$fs_obj_access_mod;
     1181 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1182 	go to obj_status_name_join;
     1183 
     1184 obj_access_write_priv: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);
     1185 
     1186 	lock_for_writing = "1"b;
     1187 	dirmode = "0"b;
     1188 	call obj_name_setup;
     1189 	state.operation = access_operations_$fs_obj_access_mod;
     1190 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1191 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1192 	go to obj_status_name_join;
     1193 
     1194 obj_delete: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
     1195 
     1196 	lock_for_writing = "1"b;
     1197 	dirmode = M_ACCESS;
     1198 	call obj_name_setup;
     1199 	state.operation = access_operations_$fs_obj_delete;
     1200 	go to obj_status_name_join;
     1201 
     1202 obj_status_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);
     1203 
     1204 	lock_for_writing = "1"b;
     1205 	dirmode = M_ACCESS;
     1206 	call obj_name_setup;
     1207 	state.operation = access_operations_$fs_obj_status_mod;
     1208 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1209 	go to obj_status_name_join;
     1210 
     1211 obj_delete_priv: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);
     1212 
     1213 	lock_for_writing = "1"b;
     1214 	dirmode = "0"b;
     1215 	call obj_name_setup;
     1216 	state.operation = access_operations_$fs_obj_delete;
     1217 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1218 	go to obj_status_name_join;
     1219 
     1220 obj_status_write_priv: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);
     1221 
     1222 	lock_for_writing = "1"b;
     1223 	dirmode = "0"b;
     1224 	call obj_name_setup;
     1225 	state.operation = access_operations_$fs_obj_status_mod;
     1226 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1227 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1228 
     1229 obj_status_name_join:
     1230 	chase_sw = a_chase_sw;
     1231 
     1232 	call find_;
     1233 	if code ^= 0 then go to RETURN;
     1234 	go to obj_status_join;
     1235 
     1236 obj_status_read_ptr: entry (a_segptr, a_ep, a_code);
     1237 
     1238 	lock_for_writing = "0"b;
     1239 	dirmode = S_ACCESS;
     1240 	call obj_ptr_setup;
     1241 	state.operation = access_operations_$fs_obj_prop_read;
     1242 	go to obj_status_ptr_join;
     1243 
     1244 obj_status_read_priv_ptr: entry (a_segptr, a_ep, a_code);
     1245 
     1246 	lock_for_writing = "0"b;
     1247 	dirmode = "0"b;
     1248 	call obj_ptr_setup;
     1249 	state.operation = access_operations_$fs_obj_prop_read;
     1250 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1251 	go to obj_status_ptr_join;
     1252 
     1253 obj_delete_ptr: entry (a_segptr, a_ep, a_code);
     1254 
     1255 	lock_for_writing = "1"b;
     1256 	dirmode = M_ACCESS;
     1257 	call obj_ptr_setup;
     1258 	state.operation = access_operations_$fs_obj_delete;
     1259 	go to obj_status_ptr_join;
     1260 
     1261 obj_status_write_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);
     1262 
     1263 	lock_for_writing = "1"b;
     1264 	dirmode = M_ACCESS;
     1265 	call obj_ptr_setup;
     1266 	state.operation = access_operations_$fs_obj_status_mod;
     1267 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1268 	go to obj_status_ptr_join;
     1269 
     1270 obj_status_write_priv_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);
     1271 
     1272 	lock_for_writing = "1"b;
     1273 	dirmode = "0"b;
     1274 	call obj_ptr_setup;
     1275 	state.operation = access_operations_$fs_obj_status_mod;
     1276 	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
     1277 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1278 
     1279 obj_status_ptr_join:
     1280 	call find_segptr_branch;
     1281 	if code ^= 0 then go to SEGPTR_FAILURE;
     1282 
     1283 obj_status_join:
     1284 	if dirmode ^= "0"b then do;
     1285 	     call get_dir_mode (dp, exmode, code);
     1286 	     if code ^= 0 then call fatal_error;
     1287 	     if (exmode & dirmode) ^= dirmode then do;
     1288 		call dir_control_error$attributes (ep, code);
     1289 		call fatal_error;
     1290 	     end;
     1291 	end;
     1292 
     1293 	call audit_success (ep);
     1294 
     1295 	a_ep = ep;				/* Success! */
     1296 	a_code = code;
     1297 	return;
     1298 
     1299 obj_status_read_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);
     1300 
     1301 /* Like obj_status_read/write but are given a uid path. */
     1302 
     1303 
     1304 	lock_for_writing = "0"b;
     1305 	dirmode = S_ACCESS;
     1306 	unspec (state) = "0"b;
     1307 	state.operation = access_operations_$fs_obj_prop_read;
     1308 	go to obj_status_uid_join;
     1309 
     1310 obj_status_read_priv_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);
     1311 
     1312 	lock_for_writing = "0"b;
     1313 	dirmode = "0"b;
     1314 	unspec (state) = "0"b;
     1315 	state.operation = access_operations_$fs_obj_prop_read;
     1316 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1317 	go to obj_status_uid_join;
     1318 
     1319 obj_status_read_raw_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);
     1320 
     1321 	lock_for_writing = "0"b;
     1322 	dirmode = "0"b;
     1323 	unspec (state) = "0"b;
     1324 	state.operation = access_operations_$fs_obj_prop_read;
     1325 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1326 	state.allow_searching_aim_isolated_dirs = "1"b;
     1327 
     1328 
     1329 obj_status_uid_join:
     1330 	a_ep, ep = null;
     1331 	code = 0;
     1332 	uidpath = a_uidpath;
     1333 
     1334 	call uid_path_util$find_entry;
     1335 	if code = error_table_$root then do;
     1336 	     a_dirname = dirname;			/* Return name so far */
     1337 	     go to RETURN;
     1338 	end;
     1339 	if code = error_table_$bad_uidpath then do;
     1340 	     if addr (state.event_flags) -> audit_event_flags.priv_op then
     1341 		a_dirname = dirname;		/* Return name so far if allowed */
     1342 	     go to RETURN;
     1343 	end;
     1344 	if code ^= 0 then go to RETURN;
     1345 
     1346 	if dirmode ^= "0"b then do;			/* access required? */
     1347 	     /*** need to check access to object's parent */
     1348 	     call get_dir_mode (dp, exmode, code);
     1349 	     if code ^= 0 then call fatal_error;
     1350 	     if (exmode & dirmode) ^= dirmode then do;
     1351 		/*** not enough on parent, check entry (a dir itself) */
     1352 		call access_mode$effective (ep, mode, exmode, code);
     1353 		if code ^= 0 then call fatal_error;
     1354 		if exmode = "0"b then do;		/* any access would've been OK */
     1355 		     call dir_control_error$attributes (ep, code);
     1356 		     call fatal_error;
     1357 		end;
     1358 	     end;
     1359 	end;
     1360 
     1361 	call audit_success (ep);
     1362 
     1363 	a_dirname = dirname;
     1364 	a_entryname = entryname;
     1365 	a_ep = ep;
     1366 	a_code = code;
     1367 	return;
     1368 
     1369 obj_delete_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);
     1370 
     1371 	lock_for_writing = "1"b;
     1372 	dirmode = M_ACCESS;
     1373 	unspec (state) = "0"b;
     1374 	state.operation = access_operations_$fs_obj_delete;
     1375 	goto obj_delete_uid_join;
     1376 
     1377 obj_delete_priv_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);
     1378 
     1379 	lock_for_writing = "1"b;
     1380 	dirmode = "0"b;
     1381 	unspec (state) = "0"b;
     1382 	state.operation = access_operations_$fs_obj_delete;
     1383 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1384 
     1385 
     1386 obj_delete_uid_join:
     1387 	a_ep, ep = null;
     1388 	code = 0;
     1389 	uidpath = a_uidpath;
     1390 
     1391 	call uid_path_util$find_entry;
     1392 	if code = error_table_$root then do;
     1393 	     a_dirname = dirname;			/* Return name so far */
     1394 	     go to RETURN;
     1395 	end;
     1396 	if code = error_table_$bad_uidpath then do;
     1397 	     if addr (state.event_flags) -> audit_event_flags.priv_op then
     1398 		a_dirname = dirname;		/* Return name so far if allowed */
     1399 	     go to RETURN;
     1400 	end;
     1401 	if code ^= 0 then go to RETURN;
     1402 
     1403 	if dirmode ^= "0"b then do;
     1404 	     /*** need to check access to object's parent */
     1405 	     call get_dir_mode (dp, exmode, code);
     1406 	     if code ^= 0 then call fatal_error;
     1407 	     if (exmode & dirmode) ^= dirmode then do;
     1408 		call dir_control_error$attributes (ep, code);
     1409 		call fatal_error;
     1410 	     end;
     1411 	end;
     1412 
     1413 	call audit_success (ep);
     1414 
     1415 	a_dirname = dirname;
     1416 	a_entryname = entryname;
     1417 	a_ep = ep;
     1418 	a_code = code;
     1419 	return;
     1420 
     1421 obj_truncate: entry (a_dirname, a_entryname, a_ep, a_code);
     1422 
     1423 /* Returns a ptr to a directory entry when we want to truncate the object at 
     1424*hand.  Truncate has its own peculiarities in auditing.  The main access check 
     1425*is "w" on the target.  The raw entries ask for raw "w" on the target, as 
     1426*opposed to no requirement at all. */
     1427 
     1428 	call obj_name_setup;
     1429 	state.operation = access_operations_$fs_obj_contents_mod;
     1430 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;
     1431 
     1432 	lock_for_writing = "1"b;
     1433 	chase_sw = DC_FIND_CHASE;
     1434 
     1435 	call find_;
     1436 	if code ^= 0 then go to RETURN;
     1437 
     1438 	call access_mode$effective (ep, mode, exmode, code);
     1439 	if code ^= 0 then call fatal_error;
     1440 	go to obj_truncate_join;
     1441 
     1442 obj_truncate_ptr: entry (a_segptr, a_ep, a_code);
     1443 
     1444 	call obj_ptr_setup;
     1445 	state.operation = access_operations_$fs_obj_contents_mod;
     1446 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;
     1447 
     1448 	lock_for_writing = "1"b;
     1449 	call find_segptr_branch;
     1450 	if code ^= 0 then go to SEGPTR_FAILURE;
     1451 
     1452 	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
     1453 	if code ^= 0 then call fatal_error;
     1454 	go to obj_truncate_join;
     1455 
     1456 obj_truncate_raw_ptr: entry (a_segptr, a_ep, a_code);
     1457 
     1458 	call obj_ptr_setup;
     1459 	state.operation = access_operations_$fs_obj_contents_mod;
     1460 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;
     1461 	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
     1462 
     1463 	lock_for_writing = "1"b;
     1464 	call find_segptr_branch;
     1465 	if code ^= 0 then go to SEGPTR_FAILURE;
     1466 
     1467 	call access_mode$raw (ep, mode, exmode, code);
     1468 	if code ^= 0 then call fatal_error;
     1469 
     1470 obj_truncate_join:
     1471 	objmode = W_ACCESS;
     1472 	if (mode & objmode) ^= objmode then do;
     1473 	     if ep -> entry.copysw then call dir_control_error$contents_info (ep, code); /* don't audit; user can make a copy to truncate */
     1474 	     else call dir_control_error$contents (ep, code);
     1475 	     if ep -> entry.dirsw then		/* MSF? */
     1476 		if code = error_table_$moderr then code = error_table_$dirseg;
     1477 	     call fatal_error;
     1478 	end;
     1479 
     1480 	call audit_success (ep);
     1481 
     1482 	a_ep = ep;
     1483 	a_code = code;
     1484 	return;
     1485 
     1486 obj_volume_retrieve: entry (a_dirname, a_entryname, a_audit_user_info_ptr, a_ep, a_code);
     1487 
     1488 /* Follows the unique access checks pertenant to the volume retriever. */
     1489 
     1490 	call obj_name_setup;
     1491 	state.operation = access_operations_$fs_obj_contents_mod;
     1492 	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_VOLUME_RETRIEVE;
     1493 
     1494 	state.for_user = "1"b;
     1495 	state.user = a_audit_user_info_ptr -> audit_user_info;
     1496 
     1497 	lock_for_writing = "0"b;
     1498 	chase_sw = DC_FIND_NO_CHASE;
     1499 
     1500 	call find_;				/* modifying object contents, not entry */
     1501 	if code ^= 0 then go to RETURN;
     1502 
     1503 	call access_mode$user_effmode (ep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
     1504 	if code ^= 0 then call fatal_error;
     1505 	if ep -> entry.dirsw then do;
     1506 	     mode = exmode;
     1507 	     objmode = SM_ACCESS;
     1508 	end;
     1509 	else objmode = RW_ACCESS;
     1510 	if (mode & objmode) ^= objmode then do;		/* look at parent's mode */
     1511 	     call sum$getbranch (dp, READ_LOCK, pep, code);
     1512 	     if code ^= 0 then call fatal_error;
     1513 	     pdp = ptr (pep, 0);
     1514 	     state.parent_locked = "1"b;
     1515 
     1516 	     call access_mode$user_effmode (pep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
     1517 	     call lock$dir_unlock (pdp);		/* done with parent */
     1518 	     state.parent_locked = "0"b;
     1519 	     if code ^= 0 then call fatal_error;
     1520 	     if (exmode & SM_ACCESS) ^= SM_ACCESS then do;
     1521 		call dir_control_error$contents (ep, code);
     1522 		call fatal_error;
     1523 	     end;
     1524 	end;
     1525 
     1526 	call audit_success (ep);
     1527 
     1528 	a_ep = ep;
     1529 	a_code = code;
     1530 	return;
     1531 
     1532 seg_fault: entry (a_kstep, a_ep, a_code);
     1533 
     1534 /* Compute the sdw access fields and generate an error if the process has
     1535*null authorization access to the segment.  This is used by seg_fault.
     1536*The finding of the directory entry pointer is done in seg_fault so as to 
     1537*minimize the number of stack frames pushed when recursive seg faults are 
     1538*taken referencing the parent dir. */
     1539 
     1540 	unspec (state) = "0"b;
     1541 	state.operation = access_operations_$fs_obj_contents_read;
     1542 
     1543 	code = 0;
     1544 	kstep = a_kstep;
     1545 	ep = a_ep;
     1546 
     1547 	if ep = null then do;
     1548 	     code = error_table_$seg_deleted;
     1549 	     call dir_control_error$name_non_existant (ptr (kstep -> kste.entryp, 0), code);
     1550 	     go to RETURN;
     1551 	end;
     1552 
     1553 	if ep -> entry.dirsw then go to RETURN;		/* dir access is special cased in seg_fault */
     1554 
     1555 	if kstep -> kste.dtbm ^= ep -> entry.dtem then	/* entry change, recompute access */
     1556 	     call update_kste_access (kstep, ep, mode);
     1557 	else mode = kstep -> kste.access;		/* else kste mode is good (possibly from a previous fs_modes call) */
     1558 
     1559 	if mode = "0"b then do;
     1560 	     call dir_control_error$contents (ep, code);
     1561 	     go to RETURN;
     1562 	end;
     1563 
     1564 	call sdw_util_$dissect (addr (dseg$ (kstep -> kste.segno)), addr (sdwi)); /* Take it apart to set access */
     1565 
     1566 	if (mode & W_ACCESS) then do;
     1567 	     state.operation = access_operations_$fs_obj_contents_mod;
     1568 	     addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CONNECT;
     1569 	end;
     1570 
     1571 	if mode ^= string (sdwi.access) |
     1572 	     sdwi.r1 ^= ep -> entry.ring_brackets (1) |
     1573 	     sdwi.r2 ^= ep -> entry.ring_brackets (2) |
     1574 	     sdwi.r3 ^= ep -> entry.ring_brackets (3) then call audit_success (ep);
     1575 
     1576 	sdwi.r1 = ep -> entry.ring_brackets (1);	/* Rings and access mode from the branch */
     1577 	sdwi.r2 = ep -> entry.ring_brackets (2);
     1578 	sdwi.r3 = ep -> entry.ring_brackets (3);
     1579 
     1580 	string (sdwi.access) = substr (mode, 1, 4);
     1581 	if ^kstep -> kste.allow_write then sdwi.write = "0"b; /* Don't allow write access, no way */
     1582 
     1583 	call sdw_util_$construct (addr (dseg$ (kstep -> kste.segno)), addr (sdwi)); /* Put it back together */
     1584 
     1585 	a_code = code;
     1586 	return;
     1587 
     1588 dir_name_setup: proc;
     1589 
     1590 	unspec (state) = "0"b;
     1591 	a_dp, dp = null;
     1592 	code = 0;
     1593 	dirname = rtrim (a_dirname);
     1594 	return;
     1595      end;
     1596 
     1597 fatal_error: proc;
     1598 
     1599 	if state.parent_parent_locked then call lock$dir_unlock (ppdp);
     1600 	if state.parent_locked then call lock$dir_unlock (pdp);
     1601 	if state.dir_locked then call lock$dir_unlock (dp);
     1602 	if state.dir_held then call segno_usage$decrement (segno (dp), (0));
     1603 	go to RETURN;
     1604      end fatal_error;
     1605 
     1606 obj_name_setup: proc;
     1607 
     1608 	unspec (state) = "0"b;
     1609 	a_ep, ep = null;
     1610 	code = 0;
     1611 	dirname = rtrim (a_dirname);
     1612 	entryname = a_entryname;
     1613 	return;
     1614      end;
     1615 
     1616 obj_ptr_setup: proc;
     1617 
     1618 	unspec (state) = "0"b;
     1619 	a_ep, ep = null;
     1620 	code = 0;
     1621 	segptr = a_segptr;
     1622 	return;
     1623      end;
     1624 
     1625 SEGPTR_FAILURE:
     1626 	if code = error_table_$seg_deleted then do;
     1627 	     call get_kstep (segno (segptr), kstep, code);
     1628 	     if code = 0 then do;
     1629 		state.operation = access_operations_$fs_obj_contents_read; /* audit failure as attempt to read names */
     1630 		code = error_table_$seg_deleted;
     1631 		call dir_control_error$name_non_existant (ptr (kstep -> kste.entryp, 0), code);
     1632 	     end;
     1633 	end;
     1634 
     1635 RETURN:	a_code = code;
     1636 	return;
     1637 
     1638 audit_success$msg: proc (a_ep, a_message);
     1639 
     1640 dcl  a_ep				ptr parameter;
     1641 dcl  a_message			char (32) aligned parameter;
     1642 
     1643 dcl  audit			bit (1) aligned;
     1644 dcl  ep				ptr;
     1645 dcl  message			char (32);
     1646 
     1647 	addr (state.event_flags) -> audit_event_flags.grant = "1"b;
     1648 	message = a_message;
     1649 	go to check_audit;
     1650 
     1651 audit_success: entry (a_ep);
     1652 
     1653 	addr (state.event_flags) -> audit_event_flags.grant = "1"b;
     1654 
     1655 audit_failure: entry (a_ep);
     1656 
     1657 	message = "";
     1658 check_audit:
     1659 	ep = a_ep;
     1660 	if state.for_user then audit =
     1661 		access_audit_check_ep_$user (state.event_flags, state.operation, ep, state.user.authorization, state.user.audit_flags);
     1662 	else audit =
     1663 		access_audit_check_ep_$self (state.event_flags, state.operation, ep);
     1664 	if audit then
     1665 	     if state.for_user then
     1666 		call access_audit_$log_entry_ptr_user (ME, (state.ring), state.event_flags, state.operation, ep, code, null, 0, addr (state.user), message);
     1667 	     else call access_audit_$log_entry_ptr (ME, level$get (), state.event_flags, state.operation, ep, code, null, 0, message);
     1668 	return;
     1669      end;
     1670 
     1671 dir_control_error: proc;
     1672 
     1673 /* Original version written by Kobziar (July 74) */
     1674 
     1675 dcl  a_dp				ptr parameter;
     1676 dcl  a_ep				ptr parameter;
     1677 dcl  a_code			fixed bin (35) parameter;
     1678 
     1679 dcl  code				fixed bin (35);
     1680 dcl  dp				ptr;
     1681 dcl  ep				ptr;
     1682 dcl  exmode			bit (36) aligned;
     1683 dcl  info_only			bit (1) aligned;	/* TRUE iff info entry called */
     1684 dcl  locked			bit (1) aligned;
     1685 dcl  mode				bit (36) aligned;
     1686 dcl  original_code			fixed bin (35);
     1687 dcl  pep				ptr;
     1688 
     1689 dir_control_error$append: entry (a_ep, a_code);
     1690 
     1691 /* Used for appending into a dir.  The only access consideration is on the dir
     1692*itself, since asking to append inside a dir is like asking for the names of
     1693*objects in the dir; we can not let the user know of the existance of objects
     1694*in a dir to which he has no access. */
     1695 
     1696 	info_only = "0"b;
     1697 
     1698 	ep = a_ep;				/* entry for dir being appended into */
     1699 	if ep = null then code = error_table_$incorrect_access; /* something wrong here */
     1700 	else do;
     1701 	     call get_mode_on_entry (ep);
     1702 	     if (exmode ^= N_ACCESS) then code = error_table_$incorrect_access; /* user has some access on dir, 
     1703*						hence can know of no access (=> not namedup) */
     1704 	     else code = error_table_$no_info;		/* no access on dir */
     1705 	end;
     1706 	go to return_error_code;
     1707 
     1708 dir_control_error$attributes_info: entry (a_ep, a_code);
     1709 	info_only = "1"b;
     1710 	go to attributes_entry;
     1711 
     1712 dir_control_error$attributes: entry (a_ep, a_code);
     1713 	info_only = "0"b;
     1714 
     1715 /* These entries are called when we had insufficient access to examine/change 
     1716*the attributes of an object. */
     1717 
     1718 attributes_entry:
     1719 	ep = a_ep;				/* copy entry pointer */
     1720 	if ep = null then code = error_table_$incorrect_access; /* if entry is the root */
     1721 	else do;
     1722 
     1723 /* Check access on parent */
     1724 
     1725 	     dp = ptr (ep, 0);			/* get ptr to directory */
     1726 	     call get_mode_on_dir (dp);
     1727 	     if (exmode ^= N_ACCESS) then code = error_table_$incorrect_access; /* user has some access on parent but apparently not enough */
     1728 	     else do;
     1729 		if ep -> entry.bs = "1"b then do;
     1730 		     call get_mode_on_entry (ep);	/* access on entry allows user to see entry */
     1731 		     if code ^= 0 then go to return_error_code_no_audit;
     1732 
     1733 		     if ep -> entry.dirsw then mode = exmode; /* if a directory, look at the extended access */
     1734 
     1735 		     if mode ^= N_ACCESS then code = error_table_$incorrect_access; /* user has some access on object but not enough */
     1736 		     else code = error_table_$no_info;
     1737 		end;
     1738 		else code = error_table_$no_info;	/* link */
     1739 	     end;
     1740 	end;
     1741 	go to return_error_code;
     1742 
     1743 dir_control_error$contents_info: entry (a_ep, a_code);	/* Entry does not result in an auditing message */
     1744 	info_only = "1"b;
     1745 	go to contents_entry;
     1746 
     1747 dir_control_error$contents: entry (a_ep, a_code);
     1748 	info_only = "0"b;
     1749 
     1750 /* Entries called with an ep for an object whose contents in which we were
     1751*interested. */
     1752 
     1753 contents_entry:
     1754 	ep = a_ep;				/* copy entry pointer */
     1755 	if rel (ep) = "0"b then code = error_table_$no_info; /* argument should always point to a directory entry */
     1756 	else if ep = null then code = error_table_$moderr;/* if entry represents the root */
     1757 	else if ep -> entry.bs = "0"b then code = error_table_$no_info; /* if passed a pointer to a link entry */
     1758 	else do;
     1759 
     1760 /* check access of entry */
     1761 
     1762 	     call get_mode_on_entry (ep);
     1763 	     if code ^= 0 then go to return_error_code_no_audit;
     1764 
     1765 	     if ep -> entry.dirsw then mode = exmode;	/* if a directory, look at the extended access */
     1766 
     1767 	     if mode ^= N_ACCESS then code = error_table_$moderr; /* user has some access but not apparently what was needed */
     1768 	     else do;
     1769 
     1770 /* otherwise look at access on parent */
     1771 
     1772 		dp = ptr (ep, 0);			/* get ptr to directory */
     1773 		call get_mode_on_dir (dp);
     1774 		if (exmode ^= N_ACCESS) then code = error_table_$moderr; /* return moderr if user has non-null access on parent */
     1775 		else code = error_table_$no_info;	/* return no_info if user has null access on parent */
     1776 	     end;
     1777 	end;
     1778 	go to return_error_code;
     1779 
     1780 dir_control_error$name_existant: entry (a_ep, a_code);
     1781 
     1782 /* This entry is called when a user tries to look up a name which isn't what's
     1783*desired.  We have to see if the user is allowed to know this.  The argument is
     1784*an entry ptr to the entry of the wrong type.  If the user is allowed to see 
     1785*the name non-existance, we return the input code.  Otherwise, we return 
     1786*no_info.
     1787*
     1788*Audit when user couldn't see object.  One reason for this is because we
     1789*can't keep dirs from entering the address space and we want to audit attempts
     1790*to try directory names.  */
     1791 
     1792 	original_code = a_code;
     1793 	code = 0;					/* clear error code */
     1794 	ep = a_ep;
     1795 	dp = ptr (ep, 0);
     1796 	if ep = null then code = original_code;		/* root? */
     1797 	else do;
     1798 	     call get_mode_on_dir (dp);
     1799 	     if (exmode ^= N_ACCESS) then code = original_code; /* user has some access on dir */
     1800 	     else do;
     1801 		if ep -> entry.bs then do;		/* see if user has access (can see) object */
     1802 		     call get_mode_on_entry (ep);
     1803 		     if code ^= 0 then go to return_error_code_no_audit;
     1804 
     1805 		     if ep -> entry.dirsw then mode = exmode;
     1806 		     if (mode ^= N_ACCESS) then code = original_code;
     1807 		     else code = error_table_$no_info;
     1808 		end;
     1809 		else code = error_table_$no_info;
     1810 	     end;
     1811 	end;
     1812 	if code = error_table_$no_info then call audit_failure (ep);
     1813 	go to return_error_code_no_audit;
     1814 
     1815 dir_control_error$name_non_existant: entry (a_dp, a_code);
     1816 
     1817 /* This entry is called when a user tries to look up a name which isn't found.
     1818*We have to see if the user is allowed to know this.  The argument is a ptr
     1819*to a directory in which the name wasn't found.  If the user is allowed to see 
     1820*the name non-existance, we return the input code.  Otherwise, we return 
     1821*no_info.
     1822*
     1823*Audit when user couldn't see object.  One reason for this is because we
     1824*can't keep dirs from entering the address space and we want to audit attempts
     1825*to try directory names.  */
     1826 
     1827 	original_code = a_code;
     1828 	code = 0;					/* clear error code */
     1829 	dp = a_dp;
     1830 
     1831 	locked = "0"b;
     1832 	pep = null;
     1833 	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
     1834 	if code = 0 then locked = "1"b;
     1835 	else if code = error_table_$root | code = error_table_$mylock then ;
     1836 	else go to return_error_code_no_audit;
     1837 
     1838 	call get_mode_on_entry (pep);
     1839 	if (exmode ^= N_ACCESS) then code = original_code;/* user has some access on dir */
     1840 	else code = error_table_$no_info;
     1841 
     1842 	if code = error_table_$no_info then call audit_failure (pep);
     1843 
     1844 	if locked then call lock$dir_unlock (ptr (pep, 0));
     1845 	go to return_error_code_no_audit;
     1846 
     1847 dir_control_error$status: entry (a_ep, a_code);
     1848 
     1849 /* This entry is called when the user had non-null access on an object but did
     1850*not have s permission on the parent.  It is only called when this circumstance
     1851*causes us to return some, but not all, information the user requested.  In this
     1852*case, we know what error to flag.  We simply audit and return 
     1853*no_s_permission. */
     1854 
     1855 	info_only = "0"b;				/* For real */
     1856 	ep = a_ep;				/* copy argument */
     1857 	if ep = null then code = error_table_$incorrect_access; /* if entry is the root */
     1858 	else code = error_table_$no_s_permission;	/* branch - caller knows we have some access but not access on dir */
     1859 	go to return_error_code;
     1860 
     1861 return_error_code:
     1862 	if ^info_only then				/* If a real violation */
     1863 	     call audit_failure (ep);
     1864 
     1865 return_error_code_no_audit:
     1866 	a_code = code;
     1867 	return;
     1868 
     1869 get_mode_on_dir: proc (a_dp);
     1870 
     1871 dcl  a_dp				ptr parameter;
     1872 
     1873 dcl  dp				ptr;
     1874 dcl  locked			bit (1) aligned;
     1875 dcl  pdp				ptr;
     1876 dcl  pep				ptr;
     1877 
     1878 	     dp = a_dp;
     1879 	     if state.for_user then do;		/* need to get pep to figure out access */
     1880 		locked = "1"b;			/* set lock indicator on */
     1881 		call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* get pointer to parent directory */
     1882 		if code ^= 0 then			/* turn off lock indicator */
     1883 		     if code = error_table_$root | code = error_table_$mylock then do;
     1884 			locked = "0"b;		/* if already locked by us */
     1885 			code = 0;
     1886 		     end;
     1887 		     else go to return_error_code_no_audit;
     1888 
     1889 		pdp = ptr (pep, 0);			/* get pointer to parent of parent */
     1890 		call get_mode_on_entry (pep);		/* look at the access on parent directory */
     1891 		if locked then call lock$dir_unlock (pdp);
     1892 		if code ^= 0 then go to return_error_code_no_audit;
     1893 	     end;
     1894 	     else call get_dir_mode (dp, exmode, code);	/* easier to get mode for caller than someone else */
     1895 	     return;
     1896 	end get_mode_on_dir;
     1897 
     1898 get_mode_on_entry: proc (a_ep);
     1899 
     1900 dcl  a_ep				ptr parameter;
     1901 
     1902 dcl  ep				ptr;
     1903 
     1904 	     ep = a_ep;
     1905 	     if state.for_user then call access_mode$user_effmode (ep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
     1906 	     else call access_mode$effective (ep, mode, exmode, code); /* get mode and extended mode of entry */
     1907 	     return;
     1908 	end get_mode_on_entry;
     1909      end dir_control_error;
     1910 
     1911 find_: proc;
     1912 
     1913 /* Original version written by R. Bratt (October 1974). */
     1914 
     1915 /* This program returns a pointer to a directory entry in a specified 
     1916*directory.  It returns with the directory locked.  a_ep is non-null only for 
     1917*success; the code will be zero in this case.
     1918*
     1919*The append entries return a pointer to a locked directory in which and entry
     1920*is to be appended.  These entries basically just ensure that the named object
     1921*doesn't exist.
     1922**/
     1923 
     1924 dcl  find_type			bit (4) aligned;	/* type of object (or nothing) acceptable to find */
     1925 dcl  links			fixed bin;
     1926 
     1927 	code = 0;
     1928 	ep, dp = null ();
     1929 	call setup ();
     1930 
     1931 	if chase_sw = DC_FIND_NO_CHASE then do;
     1932 	     call find_locked_dir;
     1933 	     if code ^= 0 then call abort;
     1934 
     1935 	     call find_entry (dp, entryname, FIND_OBJECT_OR_LINK, ep, code);
     1936 	     if code ^= 0 then call abort;
     1937 	     return;
     1938 	end;
     1939 	else do;
     1940 	     find_type = FIND_OBJECT_OR_LINK;
     1941 	     call find_chasing_link;
     1942 	     do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
     1943 		call split_pathname ();
     1944 		call find_chasing_link;
     1945 	     end;
     1946 
     1947 	     if code = error_table_$link then code = error_table_$toomanylinks;
     1948 	     if code ^= 0 then call abort;
     1949 	     return;
     1950 	end;
     1951 
     1952 find_$append: entry;
     1953 
     1954 /* This entry checks that the pathname supplied does not exist. */
     1955 
     1956 	code = 0;
     1957 	dp = null ();
     1958 	call setup ();
     1959 
     1960 	if chase_sw = DC_FIND_NO_CHASE then do;
     1961 	     call find_locked_dir;
     1962 	     if code ^= 0 then call abort;
     1963 
     1964 	     call find_entry (dp, entryname, FIND_NOTHING, ep, code);
     1965 	     if code ^= 0 then call abort;
     1966 	     return;
     1967 	end;
     1968 	else do;
     1969 
     1970 /* This entry makes sure that the final target doesn't exist.  It returns
     1971*a pointer to the final target dir and the updated pathname of the link
     1972*target. */
     1973 
     1974 	     find_type = FIND_LINK_OR_NOTHING;
     1975 	     call find_chasing_link;
     1976 	     do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
     1977 		call split_pathname ();
     1978 		call find_chasing_link;
     1979 	     end;
     1980 
     1981 	     if code = error_table_$link then code = error_table_$toomanylinks;
     1982 	     if code ^= 0 then call abort;
     1983 	     return;
     1984 	end;
     1985 
     1986 find_$link_target: entry;
     1987 
     1988 /* This entry finds the target of the specified link, whether existant or not.
     1989*It returns this final path. */
     1990 
     1991 	code = 0;
     1992 	ep, dp = null ();
     1993 	call setup ();
     1994 
     1995 	find_type = FIND_ALL;
     1996 	call find_chasing_link;
     1997 	do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
     1998 	     call split_pathname ();
     1999 	     call find_chasing_link;
     2000 	end;
     2001 
     2002 	if code = error_table_$link then code = error_table_$toomanylinks;
     2003 	if code ^= 0 then call abort;
     2004 	return;
     2005 
     2006 find_chasing_link: proc;
     2007 
     2008 	     call find_locked_dir;
     2009 	     if code ^= 0 then call abort;
     2010 
     2011 	     call find_entry (dp, entryname, find_type, ep, code);
     2012 	     if code ^= 0 then call abort;
     2013 
     2014 	     if ep ^= null then
     2015 		if ^ep -> entry.bs then do;		/* link */
     2016 		     dirname = substr (ep -> link.pathname, 1, ep -> link.pathname_size);
     2017 		     code = error_table_$link;
     2018 		     call lock$dir_unlock (dp);
     2019 		     state.dir_locked = "0"b;
     2020 		     call segno_usage$decrement (segno (dp), (0));
     2021 		     state.dir_held = "0"b;
     2022 		end;
     2023 	     return;
     2024 	end find_chasing_link;
     2025 
     2026 setup:	proc;
     2027 	     if entryname = "" then call split_pathname ();
     2028 	     return;
     2029 	end setup;
     2030 
     2031 split_pathname: proc;
     2032 
     2033 dcl  ename_len			fixed bin (17);
     2034 dcl  path_len			fixed bin (17);
     2035 
     2036 	     if dirname = ">" then do;
     2037 		code = error_table_$root;
     2038 		call abort;
     2039 	     end;
     2040 	     ename_len = index (reverse (dirname), ">") - 1;
     2041 	     if ename_len < 1 then do;
     2042 		code = error_table_$badpath;
     2043 		call abort;
     2044 	     end;
     2045 	     if ename_len > 32 then do;
     2046 		code = error_table_$entlong;
     2047 		call abort;
     2048 	     end;
     2049 	     path_len = length (dirname) - ename_len - 1;
     2050 	     entryname = substr (dirname, path_len + 2, ename_len);
     2051 	     dirname = substr (dirname, 1, max (path_len, 1));
     2052 	     return;
     2053 	end split_pathname;
     2054 
     2055 abort:	proc;
     2056 
     2057 	     if state.dir_locked then do;
     2058 		call lock$dir_unlock (dp);
     2059 		state.dir_locked = "0"b;
     2060 	     end;
     2061 	     if state.dir_held then do;
     2062 		call segno_usage$decrement (segno (dp), (0));
     2063 		state.dir_held = "0"b;
     2064 	     end;
     2065 	     go to non_local_return;
     2066 	end abort;
     2067 
     2068 non_local_return:
     2069 	return;
     2070      end find_;
     2071 
     2072 find_dir: proc;
     2073 
     2074 /* Original version (find_dirsegno) written by R. Bratt (September 1974) */
     2075 
     2076 /* find_dir resolves a directory pathname into a directory pointer.
     2077*   It initiates any directories which are in the path but unknown to the 
     2078*   process.  On exit only the target directory is marked as in use.
     2079*
     2080*The operation of this program is as follows:
     2081*
     2082*We maintain the pathname of the directory we want to find (and initiate) in
     2083*substr (work_pathname.string, 1, work_pathname.parent_len + work_pathname.son_len).
     2084*
     2085*We start by walking up the hierarchy from the last directory in the path 
     2086*looking for one whose segno is known.  This will either be because we find it 
     2087*in the PAM, or because we hit the root (which can be implicitly made known).
     2088*The amount of the original pathname that we examing in this walk up is
     2089*substr (work_pathname.string, 1, work_pathname.parent_len).
     2090*
     2091*When we find this segno, we can walk back down the hierarchy, making each
     2092*subordinate directory known.  As we make a subordinate directory known, we free
     2093*up its parent.  Eventually we find what we want.
     2094*
     2095*If we encounter a link, we substitute the portion of the pathname that this 
     2096*link is with the target path of the link.  We then restart the search given
     2097*this new "expanded" pathname. */
     2098 
     2099 /* Based */
     2100 
     2101 dcl  parent_path			char (work_pathname.parent_len) aligned based (addr (work_pathname.string)); /* based form of working path */
     2102 dcl  parent_path_var		char (work_pathname.parent_len) aligned var based (addr (work_pathname.parent_len));
     2103 dcl  son_path			char (work_pathname.son_len) based (addcharno (addr (work_pathname.string), work_pathname.parent_len));
     2104 						/* This describes the characters after the parent path
     2105*					(path that has been found).  This describes ">" || entryname of the next
     2106*					dir (and any chars that follows). */
     2107 dcl  1 work_pathname		aligned based (state.work_pathname_ptr), /* work area for path expansion and name stripping (concealing) */
     2108        2 parent_len			fixed bin (21),	/* this field makes the characters that follow look like a var string 
     2109*- this is how many chars we are currently examining */
     2110        2 string			char (2048),	/* more than enough for... */
     2111        2 son_len			fixed bin (21);	/* number of chars in string following parent chars */
     2112 
     2113 /* Variables */
     2114 
     2115 dcl  authorization			bit (72) aligned;
     2116 dcl  entry			char (32) aligned;
     2117 dcl  entry_len			fixed bin (21);
     2118 dcl  ep				ptr;
     2119 dcl  new_son_ptr			ptr;		/* after relocation after link */
     2120 dcl  numlinks			fixed bin;
     2121 dcl  old_son_ptr			ptr;		/* to str of son */
     2122 dcl  segnum			fixed bin (17);	/* segno of directory currently held */
     2123 dcl  son_segnum			fixed bin (17);	/* new dir being made active */
     2124 dcl  sub_path_len			fixed bin (21);	/* after stripping an entryname */
     2125 
     2126 	code = 0;
     2127 
     2128 /* work_pathname is not kept as an automatic area to minimize stack frame
     2129*size during certain ptr based calls.  We grow the stack frame big 
     2130*enough for work_pathname only when we need to. */
     2131 
     2132 	if ^state.find_dir_has_work_area then do;
     2133 	     state.work_pathname_ptr = wired_utility_$grow_stack_frame (size (work_pathname));
     2134 	     state.find_dir_has_work_area = "1"b;
     2135 	end;
     2136 
     2137 	if state.for_user then authorization = state.user.authorization;
     2138 	else authorization = pds$access_authorization;
     2139 
     2140 	work_pathname.son_len = 0;
     2141 	work_pathname.parent_len = length (dirname);
     2142 	substr (work_pathname.string, 1, work_pathname.parent_len) = dirname;
     2143 
     2144 	unspec (my_makeknown_info) = "0"b;
     2145 	my_makeknown_info.activate, my_makeknown_info.dirsw, my_makeknown_info.allow_write = "1"b;
     2146 	numlinks = 0;
     2147 
     2148 Find_dir: call pathname_am$get_segno (parent_path_var, segnum);
     2149 	if segnum > -1 then do;			/* found in PAM */
     2150 
     2151 /* See if this dir (=> any dir in path) aim isolated.  Normally, we would say
     2152*that it couldn't be to have made it into the PAM on a previous pass.  But,
     2153*real or simulated dir priv in the past could have brought it into our space.
     2154*We don't want to allow accessing it any more unless privs are still on. */
     2155 
     2156 	     dp = baseptr (segnum);
     2157 	     state.dir_held = "1"b;
     2158 	     if /* tree */ ^read_allowed_ (authorization, dp -> dir.access_class) then
     2159 		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
     2160 		     if ^(state.allow_searching_aim_isolated_dirs | state.allow_aim_isolated_final_dir) then do;
     2161 			state.operation = access_operations_$fs_obj_contents_read;
     2162 			call sum$getbranch (dp, READ_LOCK, pep, code);
     2163 			if code ^= 0 then go to abort;
     2164 			pdp = ptr (pep, 0);
     2165 			call dir_control_error$attributes (pep, code);
     2166 			call lock$dir_unlock (pdp);
     2167 			go to abort;
     2168 		     end;
     2169 
     2170 	     go to find_dir_return;
     2171 	end;
     2172 
     2173 	if parent_path_var = ">" then do;
     2174 	     call activate_root;
     2175 	     dp = baseptr (segnum);
     2176 	     state.dir_held = "1"b;
     2177 	     go to find_dir_return;			/* Everyone can see root */
     2178 	end;
     2179 
     2180 /* We must split the pathname and start walking up the hierarchy, until we
     2181*find a PAM match or hit the root. */
     2182 
     2183 	do while (segnum < 0);			/* walk down until we find the segno for some dir in path */
     2184 
     2185 /* Adjust working_length to split off entryname */
     2186 
     2187 	     sub_path_len = work_pathname.parent_len - index (reverse (parent_path), ">");
     2188 	     if sub_path_len = 0 then ;		/* directory right off root */
     2189 	     else if sub_path_len >= work_pathname.parent_len - 1 then do;
     2190 		code = error_table_$badpath;		/* no ">" or last char is ">" */
     2191 		go to abort;
     2192 	     end;
     2193 	     work_pathname.son_len = work_pathname.son_len + (work_pathname.parent_len - sub_path_len); /* add last entryname found to son half of string */
     2194 	     work_pathname.parent_len = sub_path_len;
     2195 
     2196 /* Try to find dir */
     2197 
     2198 	     if work_pathname.parent_len = 0 then call activate_root; /* root */
     2199 	     else call pathname_am$get_segno (parent_path_var, segnum); /* marks segno as held if segno returned */
     2200 	end;
     2201 	dp = baseptr (segnum);
     2202 	state.dir_held = "1"b;
     2203 
     2204 /* Now we walk back down the hierarchy, finding the sub-ordinate dirs to the 
     2205*one found above. */
     2206 
     2207 	do while (work_pathname.son_len > 0);
     2208 	     entry_len = index (substr (son_path, 2), ">"); /* add the next entry back to the parent half of string */
     2209 	     if entry_len = 0 then entry_len = work_pathname.son_len - 1; /* last entryname in path */
     2210 	     else entry_len = entry_len - 1;		/* remove ">" */
     2211 	     if entry_len > 32 then do;
     2212 		code = error_table_$entlong;
     2213 		go to abort;
     2214 	     end;
     2215 	     entry = substr (son_path, 2, entry_len);
     2216 	     work_pathname.son_len = work_pathname.son_len - (entry_len + 1);
     2217 	     work_pathname.parent_len = work_pathname.parent_len + (entry_len + 1); /* add in entryname we're about to find */
     2218 
     2219 	     call lock$dir_lock_read (dp, code);
     2220 	     if code ^= 0 then go to abort;
     2221 	     state.dir_locked = "1"b;
     2222 
     2223 	     call find_entry (dp, entry, FIND_DIR_OR_LINK, ep, code);
     2224 	     if code ^= 0 then go to abort;
     2225 
     2226 	     if ^ep -> entry.bs then do;		/* link */
     2227 
     2228 /* We substitute the pathname resolved so far with the link pathname and start
     2229*all over. */
     2230 
     2231 		numlinks = numlinks + 1;
     2232 		if ep -> link.pathname_size + work_pathname.son_len > length (work_pathname.string) |
     2233 		     numlinks > active_all_rings_data$maxlinks then do;
     2234 		     code = error_table_$toomanylinks;
     2235 		     go to abort;
     2236 		end;
     2237 		old_son_ptr = addcharno (addr (work_pathname.string), work_pathname.parent_len); /* move son portion down */
     2238 		new_son_ptr = addr (work_pathname.string); /* avoid compiler bug */
     2239 		new_son_ptr = addcharno (new_son_ptr, ep -> link.pathname_size);
     2240 		if work_pathname.parent_len < ep -> link.pathname_size then
     2241 		     call mrl_ (old_son_ptr, work_pathname.son_len, new_son_ptr, work_pathname.son_len); /* moving to the right */
     2242 		else call mlr_ (old_son_ptr, work_pathname.son_len, new_son_ptr, work_pathname.son_len); /* moving to the left */
     2243 		substr (work_pathname.string, 1, ep -> link.pathname_size) = substr (ep -> link.pathname, 1, ep -> link.pathname_size); /* insert link as new parent */
     2244 		work_pathname.parent_len = work_pathname.son_len + ep -> link.pathname_size; /* make whole string parent, start over */
     2245 		work_pathname.son_len = 0;
     2246 		dirname = parent_path;		/* update dirname, disregard truncation */
     2247 		call lock$dir_unlock (dp);		/* release dir holding link */
     2248 		state.dir_locked = "0"b;
     2249 		call segno_usage$decrement (segnum, (0));
     2250 		state.dir_held = "0"b;
     2251 		go to Find_dir;			/* must start from scratch */
     2252 	     end;
     2253 
     2254 	     if /* tree */ ^read_allowed_ (authorization, ep -> entry.access_class) then /* dir aim protected */
     2255 		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
     2256 		     if ^state.allow_searching_aim_isolated_dirs then
     2257 			if ^(work_pathname.son_len = 0 & state.allow_aim_isolated_final_dir) then do;
     2258 			     state.operation = access_operations_$fs_obj_contents_read;
     2259 			     call dir_control_error$attributes (ep, code);
     2260 			     go to abort;
     2261 			end;
     2262 
     2263 	     my_makeknown_info.entryp = ep;
     2264 	     my_makeknown_info.uid = ep -> entry.uid;
     2265 	     call makeknown_ (addr (my_makeknown_info), son_segnum, (0), code);
     2266 	     if code ^= 0 then
     2267 		if code ^= error_table_$segknown then go to abort;
     2268 	     call lock$dir_unlock (dp);		/* dir is locked during makeknown_ activate call */
     2269 	     state.dir_locked = "0"b;
     2270 	     call segno_usage$decrement (segnum, (0));	/* parent will be held by son */
     2271 	     segnum = son_segnum;			/* makeknown made dir held */
     2272 	     dp = baseptr (segnum);
     2273 	     call pathname_am$set (parent_path_var, segnum); /* remember this after all we had to do to find it */
     2274 	end;
     2275 
     2276 find_dir_return:
     2277 	code = 0;
     2278 	return;
     2279 
     2280 abort:	if state.dir_locked then do;
     2281 	     call lock$dir_unlock (dp);
     2282 	     state.dir_locked = "0"b;
     2283 	end;
     2284 	if state.dir_held then do;
     2285 	     call segno_usage$decrement (segnum, (0));
     2286 	     state.dir_held = "0"b;
     2287 	end;
     2288 	return;
     2289 
     2290 activate_root: proc;
     2291 
     2292 	     my_makeknown_info.uid = "777777777777"b3;
     2293 	     my_makeknown_info.entryp = null;
     2294 	     call makeknown_ (addr (my_makeknown_info), segnum, (0), code); /* marks segno as held */
     2295 	     if code ^= 0 then
     2296 		if code ^= error_table_$segknown then go to abort;
     2297 	     return;
     2298 	end activate_root;
     2299      end find_dir;
     2300 
     2301 find_entry: proc (a_dp, a_ename, a_type, a_ep, a_code);
     2302 
     2303 /* Original version written by R. Bratt (September 1974) */
     2304 
     2305 /* find_entry provides entries for finding a directory entry of
     2306*   a certain type given the segment number of the parent directory and
     2307*   the name of the desired entry (and its desired type).  Code will be zero
     2308*   only if an object of the desired type was found.  ep will be non-null
     2309*   only if the found object is existant. */
     2310 
     2311 dcl  a_code			fixed bin (35) parameter;
     2312 dcl  a_dp				ptr parameter;
     2313 dcl  a_ename			char (32) aligned parameter;
     2314 dcl  a_ep				ptr parameter;
     2315 dcl  a_type			bit (4) aligned parameter;
     2316 
     2317 dcl  authorization			bit (72) aligned;
     2318 dcl  code				fixed bin (35);
     2319 dcl  dp				ptr;
     2320 dcl  ep				ptr;
     2321 dcl  type				bit (4) aligned;
     2322 
     2323 	a_code = 0;
     2324 	a_ep = null;
     2325 	dp = a_dp;
     2326 	type = a_type;
     2327 
     2328 	if state.for_user then authorization = state.user.authorization;
     2329 	else authorization = pds$access_authorization;
     2330 
     2331 	call hash$search (dp, addr (a_ename), ep, code);
     2332 	if code ^= 0 then do;
     2333 	     if code ^= error_table_$noentry then go to abort;
     2334 	     if (type & FIND_NOTHING) then do;
     2335 		code = 0;				/* user got what he wanted */
     2336 		return;
     2337 	     end;
     2338 	     if (type & FIND_SEG) then code = error_table_$noentry; /* if we'd accept a seg, we'd accept anything */
     2339 	     else if (type & FIND_DIR) then code = error_table_$no_dir; /* only a dir or link will do */
     2340 	     else code = error_table_$not_link;		/* only link would do */
     2341 	     state.operation = access_operations_$fs_obj_contents_read; /* audit failure as attempt to read names */
     2342 	     call dir_control_error$name_non_existant (dp, code);
     2343 	     go to abort;
     2344 	end;
     2345 
     2346 /* Found name; make some checks on what's found */
     2347 
     2348 	if ep -> entry.bs then do;
     2349 	     if (ep -> entry.dirsw & (ep -> entry.type ^= DIR_TYPE))
     2350 		| (^ep -> entry.dirsw & (ep -> entry.type ^= SEG_TYPE))
     2351 		| ep -> entry.owner ^= dp -> dir.uid then signal bad_dir_;
     2352 	     if ep -> entry.security_oosw & ^addr (authorization) -> privileges.soos then do;
     2353 		state.operation = access_operations_$fs_obj_prop_read;
     2354 		call dir_control_error$attributes_info (ep, code);
     2355 		if code = error_table_$incorrect_access then code = error_table_$oosw;
     2356 		go to abort;
     2357 	     end;
     2358 	     if /* tree */ ep -> entry.dirsw then
     2359 		if (type & FIND_DIR) = "0"b then
     2360 		     if (type & FIND_NOTHING) then code = error_table_$namedup;
     2361 		     else if (type & FIND_SEG) then code = error_table_$dirseg;
     2362 			else code = error_table_$not_link; /* only choice left */
     2363 		else ;
     2364 	     else if (type & FIND_SEG) = "0"b then
     2365 		     if (type & FIND_NOTHING) then code = error_table_$namedup;
     2366 		     else if (type & FIND_DIR) then code = error_table_$notadir;
     2367 			else code = error_table_$not_link; /* only choice left */
     2368 		else ;
     2369 	end;
     2370 	else do;					/* link */
     2371 	     if ep -> link.type ^= LINK_TYPE | ep -> link.owner ^= dp -> dir.uid then signal bad_dir_;
     2372 	     if (type & FIND_LINK) = "0"b then
     2373 		if (type & FIND_NOTHING) then code = error_table_$namedup;
     2374 		else code = error_table_$link;
     2375 	end;
     2376 	if code ^= 0 then do;
     2377 	     state.operation = access_operations_$fs_obj_prop_read; /* audit failure as attempt to read names */
     2378 	     call dir_control_error$name_existant (ep, code);
     2379 	     go to abort;
     2380 	end;
     2381 
     2382 	a_ep = ep;
     2383 	return;
     2384 
     2385 abort:	a_code = code;
     2386 	return;
     2387      end find_entry;
     2388 
     2389 find_locked_dir: proc;
     2390 
     2391 	call find_dir;				/* this makes dir_held */
     2392 	if code ^= 0 then return;
     2393 
     2394 	if lock_for_writing then call lock$dir_lock_write (dp, code);
     2395 	else call lock$dir_lock_read (dp, code);
     2396 	if code ^= 0 then do;
     2397 	     call segno_usage$decrement (segno (dp), (0));
     2398 	     state.dir_held = "0"b;
     2399 	     return;
     2400 	end;
     2401 	state.dir_locked = "1"b;
     2402 	return;
     2403      end;
     2404 
     2405 find_segptr_branch: proc;
     2406 
     2407 	call sum$getbranch (segptr, lock_for_writing, ep, code);
     2408 	if code ^= 0 then return;
     2409 	dp = ptr (ep, 0);
     2410 	state.dir_locked = "1"b;
     2411 	return;
     2412      end;
     2413 
     2414 get_dir_mode: proc (a_segptr, a_mode, a_code);
     2415 
     2416 /* Find the effective access to the dir, ignoring everything else. */
     2417 
     2418 dcl  a_code			fixed bin (35) parameter;
     2419 dcl  a_mode			bit (36) aligned parameter;
     2420 dcl  a_segptr			ptr parameter;
     2421 
     2422 dcl  code				fixed bin (35);
     2423 dcl  dp				ptr;
     2424 dcl  ep				ptr;
     2425 dcl  kstep			ptr;
     2426 dcl  lock_sw			bit (1) aligned;
     2427 dcl  mode				bit (36) aligned;
     2428 dcl  need_to_lock			bit (1) aligned;
     2429 dcl  rb				(3) fixed bin (3);
     2430 dcl  ring				fixed bin (3);
     2431 dcl  segptr			ptr;
     2432 
     2433 	need_to_lock = "1"b;
     2434 	go to join;
     2435 
     2436 get_dir_mode$locked: entry (a_segptr, a_mode, a_code);
     2437 
     2438 /* Entry to use when parent directory of object that segptr indicates is 
     2439*locked. */
     2440 
     2441 	need_to_lock = "0"b;
     2442 
     2443 join:	a_mode = "0"b;
     2444 	segptr = a_segptr;
     2445 
     2446 	mode = N_ACCESS;
     2447 	call get_kstep (segno (segptr), kstep, code);	/* get kst entry ptr for this seg */
     2448 	if code ^= 0 then go to abort;
     2449 
     2450 	if kstep -> kste.uid = (36)"1"b then do;	/* special case the root */
     2451 	     lock_sw = "0"b;
     2452 	     dp, ep = null;				/* get access to root */
     2453 	     if kstep -> kste.dtbm = (36)"1"b then call update_kste_access (kstep, ep, mode);
     2454 	     mode = kstep -> kste.extended_access;	/* pick up directory access */
     2455 	     rb (1), rb (2), rb (3) = 7;
     2456 	end;
     2457 	else do;
     2458 	     lock_sw = "0"b;
     2459 
     2460 /* lock parent and  get pointer to entry */
     2461 	     if need_to_lock then do;
     2462 		call sum$getbranch_root_my (segptr, READ_LOCK, ep, code);
     2463 		if code = 0 then lock_sw = "1"b;
     2464 		else if code = error_table_$mylock then code = 0;
     2465 		else go to abort;
     2466 	     end;
     2467 	     else ep = kstep -> kste.entryp;		/* kste entryp good if dir locked */
     2468 
     2469 	     dp = ptr (ep, 0);			/* get pointer to parent directory */
     2470 	     if kstep -> kste.dtbm ^= ep -> entry.dtem then call update_kste_access (kstep, ep, mode);
     2471 	     mode = kstep -> kste.extended_access;
     2472 	     rb (*) = binary (kstep -> kste.ex_rb (*), 3);/* factor in extended ring brackets */
     2473 	     ring = level$get ();
     2474 	     if ring <= rb (1) then ;
     2475 	     else if ring <= rb (2) then mode = mode & S_ACCESS;
     2476 	     else mode = N_ACCESS;
     2477 	end;
     2478 
     2479 	if lock_sw then call lock$dir_unlock (dp);
     2480 	a_mode = mode;
     2481 
     2482 abort:	a_code = code;
     2483 	return;
     2484      end get_dir_mode;
     2485 
     2486 uid_path_util: proc;
     2487 
     2488 /* Original version written March 1975 by Larry Johnson */
     2489 
     2490 /* Variables */
     2491 
     2492 dcl  authorization			bit (72) aligned;
     2493 dcl  current_depth			fixed bin;
     2494 dcl  entrysw			bit (1) aligned;
     2495 dcl  max_depth			fixed bin;
     2496 dcl  segnum			fixed bin;
     2497 dcl  son_segnum			fixed bin;
     2498 
     2499 uid_path_util$find_entry: entry;
     2500 	entrysw = "1"b;
     2501 	go to join;
     2502 
     2503 uid_path_util$find_dir: entry;
     2504 	entrysw = "0"b;
     2505 
     2506 join:	ep, dp = null;
     2507 	dirname = "";
     2508 	entryname = "";
     2509 	code = 0;
     2510 
     2511 	if state.for_user then authorization = state.user.authorization;
     2512 	else authorization = pds$access_authorization;
     2513 
     2514 	if uidpath (0) ^= "777777777777"b3 then do;	/* All paths must start with root */
     2515 	     code = error_table_$bad_uidpath;
     2516 	     go to RETURN;
     2517 	end;
     2518 	do max_depth = 1 to 15 while (uidpath (max_depth));
     2519 	end;
     2520 	max_depth = max_depth - 1;
     2521 	if max_depth = 0 then do;
     2522 	     code = error_table_$root;
     2523 	     dirname = ">";
     2524 	     go to RETURN;
     2525 	end;
     2526 
     2527 	unspec (my_makeknown_info) = "0"b;
     2528 	my_makeknown_info.dirsw, my_makeknown_info.allow_write,
     2529 	     my_makeknown_info.priv_init, my_makeknown_info.activate = "1"b;
     2530 
     2531 	my_makeknown_info.entryp = null;		/* Start with root */
     2532 	my_makeknown_info.uid = "777777777777"b3;
     2533 	call makeknown_ (addr (my_makeknown_info), segnum, (0), code);
     2534 	if code ^= 0 then
     2535 	     if code ^= error_table_$segknown then go to abort;
     2536 	state.dir_held = "1"b;
     2537 	dp = baseptr (segnum);
     2538 
     2539 	if entrysw then max_depth = max_depth - 1;
     2540 	if max_depth = 0 then dirname = ">";
     2541 	else dirname = "";
     2542 	do current_depth = 1 to max_depth;		/* Step down path */
     2543 	     call find_uid (uidpath (current_depth), READ_LOCK);
     2544 
     2545 	     dirname = dirname || ">";
     2546 	     dirname = dirname || rtrim (entryname);
     2547 
     2548 	     if /* tree */ ^read_allowed_ (authorization, ep -> entry.access_class) then /* dir aim protected */
     2549 		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
     2550 		     if ^state.allow_searching_aim_isolated_dirs then
     2551 			if ^(current_depth = max_depth & state.allow_aim_isolated_final_dir) then do;
     2552 			     state.operation = access_operations_$fs_obj_contents_read;
     2553 			     call dir_control_error$attributes (ep, code);
     2554 			     go to abort;
     2555 			end;
     2556 
     2557 	     my_makeknown_info.uid = uidpath (current_depth);
     2558 	     my_makeknown_info.entryp = ep;
     2559 	     call makeknown_ (addr (my_makeknown_info), son_segnum, (0), code);
     2560 	     if code ^= 0 then
     2561 		if code ^= error_table_$segknown then go to abort;
     2562 	     call lock$dir_unlock (dp);		/* dir is kept locked during makeknown_ activate call */
     2563 	     state.dir_locked = "0"b;
     2564 	     call segno_usage$decrement (segnum, (0));	/* son will hold parent */
     2565 	     segnum = son_segnum;
     2566 	     dp = baseptr (segnum);
     2567 	end;
     2568 
     2569 	if entrysw then call find_uid (uidpath (max_depth + 1), lock_for_writing);
     2570 
     2571 	code = 0;
     2572 	return;
     2573 
     2574 abort:	if state.dir_locked then do;
     2575 	     call lock$dir_unlock (dp);
     2576 	     state.dir_locked = "0"b;
     2577 	end;
     2578 	if state.dir_held then do;
     2579 	     call segno_usage$decrement (segno (dp), (0));
     2580 	     state.dir_held = "0"b;
     2581 	end;
     2582 RETURN:	return;
     2583 
     2584 find_uid: proc (a_uid, a_typelock);
     2585 
     2586 dcl  a_typelock			bit (36) aligned parameter;
     2587 dcl  a_uid			bit (36) aligned parameter;
     2588 
     2589 dcl  ecount			fixed bin;
     2590 dcl  nnp				ptr;
     2591 dcl  num_entries_in_dir		fixed bin;
     2592 dcl  uid				bit (36) aligned;
     2593 
     2594 	     uid = a_uid;
     2595 
     2596 	     if a_typelock then call lock$dir_lock_write (dp, code);
     2597 	     else call lock$dir_lock_read (dp, code);
     2598 	     if code ^= 0 then go to abort;
     2599 	     state.dir_locked = "1"b;
     2600 
     2601 	     num_entries_in_dir = dp -> dir.seg_count + dp -> dir.dir_count + dp -> dir.lcount;
     2602 	     ecount = 0;
     2603 	     do ep = ptr (dp, dp -> dir.entryfrp) repeat (ptr (dp, ep -> entry.efrp)) while (rel (ep));
     2604 		ecount = ecount + 1;
     2605 		if ecount > num_entries_in_dir then signal bad_dir_;
     2606 		if ep -> entry.bs then
     2607 		     if ep -> entry.owner ^= dp -> dir.uid then signal bad_dir_;
     2608 		     else if ep -> entry.type ^= SEG_TYPE & ep -> entry.type ^= DIR_TYPE then signal bad_dir_;
     2609 		     else ;
     2610 		else if ep -> link.owner ^= dp -> dir.uid then signal bad_dir_;
     2611 		else if ep -> link.type ^= LINK_TYPE then signal bad_dir_;
     2612 		if ep -> entry.uid = uid then
     2613 		     if ep -> entry.bs & ep -> entry.dirsw then do; /* Must be dir branch */
     2614 			nnp = addr (ep -> entry.primary_name);
     2615 			if nnp -> names.owner ^= ep -> entry.uid
     2616 			     | nnp -> names.type ^= NAME_TYPE
     2617 			     | nnp -> names.entry_rp ^= rel (ep) then signal bad_dir_;
     2618 			entryname = nnp -> names.name;
     2619 			return;
     2620 		     end;
     2621 		     else go to not_found;
     2622 	     end;
     2623 
     2624 not_found:     code = error_table_$bad_uidpath;
     2625 	     go to abort;
     2626 	end find_uid;
     2627      end uid_path_util;
     2628  /* begin include file - access_audit_encoded_op.incl.pl1 */
  1     2 
  1     3 dcl 1 encoded_access_op	aligned based,
  1     4       2 audit_type	unal,
  1     5         3 object_type	fixed bin (4) uns unal,
  1     6         3 access_type	fixed bin (2) uns unal,
  1     7       2 operation_index	fixed bin (12) uns unal,
  1     8       2 detailed_operation	fixed bin (18) uns unal;
  1     9 
  1    10 /* object_type = Seg, Dir, Rcp, Admin, Special, Other
  1    11*   access_type = None, Modify_Acl, Modify, Read
  1    12*   operation_index is the index of this code in
  1    13*     access_operations_$oper_codes and the index of
  1    14*     the text descriptor in access_operations_$text_offest_table
  1    15*     (see access_operations_.incl.pl1)
  1    16*   detailed_operation is additional info inserted by the
  1    17*     caller of the subsystem performing the operation
  1    18**/
  1    19 
  1    20 /* end include file - access_audit_encoded_op.incl.pl1 */
     2628 
     2629  /* begin include file - access_audit_eventflags.incl.pl1 */
  2     2 /* NOTE: This include file has an ALM counterpart made with cif.
  2     3*Keep it up to date. */
  2     4 
  2     5 dcl 1 audit_event_flags	based aligned,
  2     6       2 special_op	bit (1) unal,  /* special sys operation */
  2     7       2 grant	bit (1) unal,  /* operation was successful */
  2     8       2 admin_op	bit (1) unal,  /* administrative operation */
  2     9       2 priv_op	bit (1) unal,  /* privileged operation */
  2    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  2    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  2    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  2    13       2 pad	bit (29) unal;
  2    14 
  2    15 /* end include file - access_audit_eventflags.incl.pl1 */
     2629 
     2630  /* begin include file - access_audit_user_info.incl.pl1 */
  3     2 
  3     3 /* 85-01-21 EJ Sharpe - changed (min max)_auth to auth range */
  3     4 /* 85-01-07 EJ Sharpe - added min_authorization */
  3     5 /* 84-10-09 EJ Sharpe - created */
  3     6 
  3     7 /* The structure defined here is passed to the access_audit_
  3     8*entrypoints which deal with proxy users:
  3     9**/
  3    10 
  3    11 dcl audit_user_info_ptr	pointer;
  3    12 
  3    13 dcl 1 audit_user_info  based (audit_user_info_ptr) aligned,
  3    14       2 version		char (8),
  3    15       2 user_id		char (32),
  3    16       2 ring		fixed bin (3) uns unal,
  3    17       2 pad		bit (33) unal,
  3    18       2 process_id		bit (36) aligned,
  3    19       2 authorization	bit (72) aligned,
  3    20       2 authorization_range	(2) bit (72) aligned,
  3    21       2 audit_flags		bit (36) aligned;
  3    22 
  3    23 dcl audit_user_info_version_1	char (8) init ("adtusrv1")
  3    24 	internal static options (constant);
  3    25 
  3    26 /* end include file - access_audit_user_info.incl.pl1 */
     2630 
     2631  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  4     2*
  4     3*   Values for the "access mode" argument so often used in hardcore
  4     4*   James R. Davis 26 Jan 81  MCR 4844
  4     5*   Added constants for SM access 4/28/82 Jay Pattin
  4     6*   Added text strings 03/19/85 Chris Jones
  4     7**/
  4     8 
  4     9 
  4    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  4    11 dcl	(
  4    12 	N_ACCESS		   init ("000"b),
  4    13 	R_ACCESS		   init ("100"b),
  4    14 	E_ACCESS		   init ("010"b),
  4    15 	W_ACCESS		   init ("001"b),
  4    16 	RE_ACCESS		   init ("110"b),
  4    17 	REW_ACCESS	   init ("111"b),
  4    18 	RW_ACCESS		   init ("101"b),
  4    19 	S_ACCESS		   init ("100"b),
  4    20 	M_ACCESS		   init ("010"b),
  4    21 	A_ACCESS		   init ("001"b),
  4    22 	SA_ACCESS		   init ("101"b),
  4    23 	SM_ACCESS		   init ("110"b),
  4    24 	SMA_ACCESS	   init ("111"b)
  4    25 	)		   bit (3) internal static options (constant);
  4    26 
  4    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  4    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  4    29 
  4    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  4    31 			   static options (constant);
  4    32 
  4    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  4    34 			   static options (constant);
  4    35 
  4    36 dcl	(
  4    37 	N_ACCESS_BIN	   init (00000b),
  4    38 	R_ACCESS_BIN	   init (01000b),
  4    39 	E_ACCESS_BIN	   init (00100b),
  4    40 	W_ACCESS_BIN	   init (00010b),
  4    41 	RW_ACCESS_BIN	   init (01010b),
  4    42 	RE_ACCESS_BIN	   init (01100b),
  4    43 	REW_ACCESS_BIN	   init (01110b),
  4    44 	S_ACCESS_BIN	   init (01000b),
  4    45 	M_ACCESS_BIN	   init (00010b),
  4    46 	A_ACCESS_BIN	   init (00001b),
  4    47 	SA_ACCESS_BIN	   init (01001b),
  4    48 	SM_ACCESS_BIN	   init (01010b),
  4    49 	SMA_ACCESS_BIN	   init (01011b)
  4    50 	)		   fixed bin (5) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     2631 
     2632  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  5     2 
  5     3 /* Created 740723 by PG */
  5     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  5     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  5     6 
  5     7 /* This structure defines the components of both an access
  5     8*   class and an access authorization as interpreted by the
  5     9*   Access Isolation Mechanism. */
  5    10 
  5    11 
  5    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  5    13        2 categories bit (36),				/* access categories */
  5    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  5    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  5    16         (3 ipc,					/* interprocess communication privilege */
  5    17          3 dir,					/* directory privilege */
  5    18          3 seg,					/* segment privilege */
  5    19          3 soos,					/* security out-of-service privilege */
  5    20          3 ring1,					/* ring 1 access privilege */
  5    21          3 rcp,					/* RCP resource access privilege */
  5    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  5    23          3 pad bit (11);
  5    24 
  5    25 
  5    26 /* END INCLUDE FILE aim_template.incl.pl1 */
     2632 
     2633  /* BEGIN include file dc_find_dcls.incl.pl1 */
  6     2 
  6     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  6     4 /* Added a few more, October 1984. */
  6     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  6     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  6     7 
  6     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  6     9 
  6    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  6    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  6    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  6    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  6    14 
  6    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  6    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  6    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  6    18 
  6    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  6    20 
  6    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  6    22 
  6    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  6    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  6    25 
  6    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  6    27 
  6    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  6    29 
  6    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  6    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  6    32 
  6    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  6    34 
  6    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  6    36 
  6    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  6    38 
  6    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  6    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  6    41 
  6    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  6    44 
  6    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  6    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  6    47 
  6    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  6    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  6    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  6    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  6    52 
  6    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  6    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  6    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  6    58 
  6    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  6    60 
  6    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  6    62 
  6    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  6    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  6    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  6    66 
  6    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  6    68 
  6    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  6    70 
  6    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  6    72 
  6    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    74 
  6    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  6    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  6    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  6    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  6    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  6    82 
  6    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  6    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  6    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  6    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  6    87 
  6    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  6    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  6    90 
  6    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  6    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  6    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  6    94 
  6    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  6    96 
  6    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  6    98 
  6    99 /* END include file dc_find_dcls.incl.pl1 */
     2633 
     2634  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  7     2 
  7     3 
  7     4 /* Template for an entry. Length = 38 words */
  7     5 
  7     6 dcl  ep ptr;
  7     7 
  7     8 dcl 1 entry based (ep) aligned,
  7     9 
  7    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  7    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  7    12 
  7    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  7    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  7    15 
  7    16     2 uid bit (36),					/* unique id of entry */
  7    17 
  7    18     2 dtem bit (36),				/* date-time entry modified */
  7    19 
  7    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  7    21     2 pad0 bit (17),
  7    22     2 nnames fixed bin (17),				/* number of names for this entry */
  7    23 
  7    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  7    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  7    26 
  7    27     2 author,					/* user who created branch */
  7    28       3 pers_rp bit (18),				/* name of user who created branch */
  7    29       3 proj_rp bit (18),				/* project of user who created branch */
  7    30 
  7    31       3 tag char (1),				/* tag of user who created branch */
  7    32       3 pad1 char (3),
  7    33 
  7    34     2 primary_name bit (504),				/* first name on name list */
  7    35 
  7    36     2 dtd bit (36),					/* date time dumped */
  7    37 
  7    38     2 pad2 bit (36),
  7    39 
  7    40 
  7    41 /* the declarations below are for branch only */
  7    42 
  7    43 
  7    44     2 pvid bit (36),				/* physical volume id */
  7    45 
  7    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  7    47     2 pad3 bit (18),
  7    48 
  7    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  7    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  7    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  7    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  7    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  7    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  7    55     2 audit_flag bit (1),				/* segment must be audited for security */
  7    56     2 security_oosw bit (1),				/* security out of service switch */
  7    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  7    58     2 master_dir bit (1),				/* TRUE for master directory */
  7    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  7    60     2 pad4 bit (11),
  7    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  7    62 
  7    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  7    64 
  7    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  7    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  7    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  7    68 
  7    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  7    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  7    71 
  7    72     2 bc_author,					/* user who last set the bit count */
  7    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  7    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  7    75 
  7    76       3 tag char (1),				/* tag of user who set the bit count */
  7    77       3 pad5 bit (2),
  7    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  7    79 
  7    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  7    81 
  7    82     2 pad6 bit (36),
  7    83 
  7    84     2 checksum bit (36),				/* checksum from dtd */
  7    85 
  7    86     2 owner bit (36);				/* uid of containing directory */
  7    87 
  7    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
     2634 
     2635  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  8     2 /* Modified 8/74 for NSS */
  8     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  8     4 /* Modified 3/82 BIM for change pclock */
  8     5 /* format: style3 */
  8     6 
  8     7 /* Template for the directory header. Length = 64 words. */
  8     8 
  8     9 dcl  dp ptr;
  8    10 
  8    11 dcl 1 dir based (dp) aligned,
  8    12 
  8    13    2 modify bit (36),				/* Process ID of last modifier */
  8    14    2 type bit (18) unaligned,			/* type of object = dir header */
  8    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  8    16     2 dtc (3),					/* date-time checked by salvager array */
  8    17       3 date bit (36),				/* the date */
  8    18       3 error bit (36),				/* what errors were discovered */
  8    19 
  8    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  8    21 
  8    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  8    23 
  8    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  8    25 
  8    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  8    27 
  8    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  8    29     2 version_number fixed bin (17),			/* version number of header */
  8    30 
  8    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  8    32     2 pad2 bit (18),
  8    33 
  8    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  8    35     2 pad3 bit (18),
  8    36 
  8    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  8    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  8    39 
  8    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  8    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  8    42 
  8    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  8    44     2 dir_count fixed bin (17),			/* number of directory branches */
  8    45 
  8    46     2 lcount fixed bin (17),				/* number of links */
  8    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  8    48 
  8    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  8    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  8    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  8    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  8    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  8    54     2 pad4 bit (14),
  8    55 
  8    56     2 iacl_count (0:7),
  8    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  8    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  8    59 
  8    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  8    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  8    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  8    63 
  8    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  8    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  8    66 
  8    67     2 htsize fixed bin (17),				/* size of hash table */
  8    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  8    69 
  8    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  8    71     2 pad6 fixed bin (17),
  8    72 
  8    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  8    74     2 pad7 bit (18)) unaligned,
  8    75 
  8    76     2 dts bit (36),					/* date-time directory last salvaged */
  8    77 
  8    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  8    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  8    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  8    81     2 checksum bit (36),				/* checksummed from uid on */
  8    82     2 owner bit (36);				/* uid of parent dir */
  8    83 
  8    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  8    85 
  8    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
     2635 
     2636  /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  9     2 
  9     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  9     4 
  9     5 
  9     6 dcl 1 link based (ep) aligned,
  9     7 
  9     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  9     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  9    10 
  9    11     2 type bit (18),				/* type = dir link */
  9    12     2 size fixed bin (17),				/* size of link in words */
  9    13 
  9    14     2 uid bit (36),					/* unique id of entry */
  9    15 
  9    16     2 dtem bit (36),				/* date-time entry modified */
  9    17 
  9    18     2 bs bit (1),					/* entry switch = 1 if entry */
  9    19     2 pad0 bit (17),
  9    20     2 nnames fixed bin (17),				/* number of names for this entry */
  9    21 
  9    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  9    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  9    24 
  9    25     2 author,					/* user who created entry */
  9    26       3 pers_rp bit (18),				/* name of user who created entry */
  9    27       3 proj_rp bit (18),				/* project of user who created entry */
  9    28 
  9    29       3 tag char (1),				/* tag of user who created entry */
  9    30       3 pad1 char (3),
  9    31 
  9    32     2 primary_name bit (504),				/* first name on name list */
  9    33 
  9    34     2 dtd bit (36),					/* date time dumped */
  9    35 
  9    36     2 pad2 bit (36),
  9    37 
  9    38 
  9    39 /* the declarations below are only applicable to links */
  9    40 
  9    41     2 pad3 bit (18),
  9    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  9    43 
  9    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  9    45 
  9    46     2 checksum bit (36),				/* checksum from uid */
  9    47 
  9    48     2 owner bit (36);				/* uid of containing directory */
  9    49 
  9    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
     2636 
     2637  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
 10     2 
 10     3 /* Template for names of branches or links. Length = 14 words. */
 10     4 
 10     5 dcl np ptr;
 10     6 
 10     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
 10     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
 10     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
 10    10 
 10    11     2 type bit (18) unaligned,			/* type = dir name */
 10    12     2 size fixed bin (17) unaligned,			/* size of dir name */
 10    13 
 10    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
 10    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
 10    16 
 10    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
 10    18     2 pad3 bit (18) unal,
 10    19 
 10    20     2 name char(32) aligned,
 10    21 
 10    22     2 checksum bit (36),				/* checksum from entry_rp */
 10    23 
 10    24     2 owner bit (36);				/* uid of entry */
 10    25 
 10    26 
 10    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
     2637 
     2638  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
 11     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
 11     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
 11     8*                                                   END HISTORY COMMENTS */
 11     9 
 11    10 
 11    11 /* The possible events within the file system; access codes and
 11    12*   detailed operation codes.  October 1984, Keith Loepere. */
 11    13 
 11    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
 11    15 
 11    16 /* Major file system operations. */
 11    17 
 11    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
 11    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
 11    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
 11    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
 11    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
 11    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
 11    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
 11    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
 11    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
 11    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
 11    28 
 11    29 /* Detailed operations. */
 11    30 
 11    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
 11    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
 11    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
 11    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
 11    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
 11    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
 11    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
 11    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
 11    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
 11    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
 11    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
 11    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
 11    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
 11    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
 11    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
 11    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
 11    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
 11    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
 11    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
 11    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
 11    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
 11    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
 11    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
 11    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
 11    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
 11    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
 11    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
 11    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
 11    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
 11    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
 11    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
 11    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
 11    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
 11    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
 11    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
 11    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
 11    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
 11    68 
 11    69 /* END include file fs_obj_access_codes.incl.pl1 */
     2638 
     2639  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
 12     2 
 12     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
 12     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
 12     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
 12     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
 12     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
 12     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
 12     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
 12    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
 12    11 
 12    12 dcl  access_name_type fixed bin static options (constant) init (1);
 12    13 dcl  acle_type fixed bin static options (constant) init (2);
 12    14 dcl  dir_header_type fixed bin static options (constant) init (3);
 12    15 dcl  dir_type fixed bin static options (constant) init (4);
 12    16 dcl  link_type fixed bin static options (constant) init (5);
 12    17 dcl  name_type fixed bin static options (constant) init (6);
 12    18 dcl  seg_type fixed bin static options (constant) init (7);
 12    19 dcl  hash_table_type fixed bin static options (constant) init (11);
 12    20 
 12    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
     2639 
     2640  /* BEGIN INCLUDE FILE its.incl.pl1
 13     2*   modified 27 July 79 by JRDavis to add its_unsigned
 13     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 13     4 
 13     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 13     6     2 pad1 bit (3) unaligned,
 13     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 13     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 13     9     2 pad2 bit (9) unaligned,
 13    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 13    11 
 13    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 13    13     2 pad3 bit (3) unaligned,
 13    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 13    15     2 pad4 bit (3) unaligned,
 13    16     2 mod bit (6) unaligned;				/* further modification */
 13    17 
 13    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 13    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 13    20     2 pad1 bit (27) unaligned,
 13    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 13    22 
 13    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 13    24     2 pad2 bit (3) unaligned,
 13    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 13    26     2 pad3 bit (3) unaligned,
 13    27     2 mod bit (6) unaligned;				/* further modification */
 13    28 
 13    29 
 13    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 13    31     2 pad1 bit (3) unaligned,
 13    32     2 segno fixed bin (15) unsigned unaligned,
 13    33     2 ringno fixed bin (3) unsigned unaligned,
 13    34     2 pad2 bit (9) unaligned,
 13    35     2 its_mod bit (6) unaligned,
 13    36 
 13    37     2 offset fixed bin (18) unsigned unaligned,
 13    38     2 pad3 bit (3) unaligned,
 13    39     2 bit_offset fixed bin (6) unsigned unaligned,
 13    40     2 pad4 bit (3) unaligned,
 13    41     2 mod bit (6) unaligned;
 13    42 
 13    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 13    44     2 pr_no fixed bin (3) unsigned unaligned,
 13    45     2 pad1 bit (27) unaligned,
 13    46     2 itp_mod bit (6) unaligned,
 13    47 
 13    48     2 offset fixed bin (18) unsigned unaligned,
 13    49     2 pad2 bit (3) unaligned,
 13    50     2 bit_offset fixed bin (6) unsigned unaligned,
 13    51     2 pad3 bit (3) unaligned,
 13    52     2 mod bit (6) unaligned;
 13    53 
 13    54 
 13    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 13    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 13    57 
 13    58 /* END INCLUDE FILE   its.incl.pl1 */
     2640 
     2641  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
 14     2 
 14     3 /*
 14     4*Modified March 1976 by R. Bratt 
 14     5*Modified November 1984 to remove hdr, Keith Loepere. */
 14     6 
 14     7 
 14     8 /****^  HISTORY COMMENTS:
 14     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
 14    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
 14    11*     Add warning on use of kste.entryp.
 14    12*                                                   END HISTORY COMMENTS */
 14    13 
 14    14 
 14    15 dcl  pds$kstp ext ptr,
 14    16     (kstp, kstep) ptr;
 14    17 
 14    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
 14    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
 14    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
 14    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
 14    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
 14    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
 14    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
 14    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
 14    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
 14    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
 14    28     2 template bit (1) unaligned,			/* this is a template kst if set */
 14    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
 14    30     2 unused_2 bit (9) unaligned,
 14    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
 14    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
 14    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
 14    34     2 end_of_kst bit (36);
 14    35 
 14    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
 14    37     2 fp bit (18) unaligned,				/* forward rel pointer */
 14    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
 14    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
 14    40     2 entryp ptr unaligned,				/* branch pointer */
 14    41 						/* See WARNING below for requirements to use entryp. */
 14    42     2 uid bit (36) aligned,				/* unique identifier */
 14    43     2 access_information unaligned,
 14    44       3 dtbm bit (36),				/* date time branch modified */
 14    45       3 extended_access bit (33),			/* extended access from the branch */
 14    46       3 access bit (3),				/* rew */
 14    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
 14    48     2 pad1 bit (3) unaligned,
 14    49     2 flags unaligned,
 14    50       3 dirsw bit (1),				/* directory switch */
 14    51       3 allow_write bit (1),				/* set if initiated with write permission */
 14    52       3 priv_init bit (1),				/* privileged initiation */
 14    53       3 tms bit (1),				/* transparent modification switch */
 14    54       3 tus bit (1),				/* transparent usage switch */
 14    55       3 tpd bit (1),				/* transparent paging device switch */
 14    56       3 audit bit (1),				/* audit switch */
 14    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
 14    58       3 pad bit (3),
 14    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
 14    60 
 14    61 
 14    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    63 /*							       */
 14    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
 14    65 /* entry associated with the kst entry, you must first validate its value    */
 14    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
 14    67 /* the containing directory.  The containing directory must remain locked    */
 14    68 /* during the entire period when kste.entryp and the directory entry are     */
 14    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
 14    70 /* longer be used to get a pointer to the entry within the unlocked	       */
 14    71 /* directory since the dir entry could have been moved within the directory  */
 14    72 /* by another processor.					       */
 14    73 /*							       */
 14    74 /* If you only need a pointer to the directory containing the associated     */
 14    75 /* dir entry (but not to the dir entry itself), you can use:	       */
 14    76 /*    pointer (kste.entryp, 0)				       */
 14    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
 14    78 /*							       */
 14    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    80 
 14    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
     2641 
     2642  /*  BEGIN INCLUDE FILE - - - makeknown_info.incl.pl1 - - - last modified March 1975 by R. Bratt - - - */
 15     2 /* Modified October 1984 for explicit activate flag and to remove 
 15     3*   detectable flag, Keith Loepere. */
 15     4 
 15     5 dcl  makeknown_infop ptr;
 15     6 
 15     7 dcl 1 makeknown_info aligned based (makeknown_infop),
 15     8     2 uid bit (36) aligned,
 15     9     2 entryp ptr unaligned,
 15    10     2 flags unaligned,
 15    11       3 dirsw bit (1),
 15    12       3 rsw bit (1),
 15    13       3 allow_write bit (1),
 15    14       3 priv_init bit (1),
 15    15       3 audit bit (1),
 15    16       3 activate bit (1);			/* Use only for directory initiation within directory control */
 15    17 
 15    18 /*   END INCLUDE FILE makeknown_info.incl.pl1 - - - - - - - - - - - - - - - - - - - - - - - - - - - */
     2642 
     2643  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
 16     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 16     3 
 16     4 dcl  sdw_info_ptr pointer;
 16     5 
 16     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
 16     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
 16     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
 16     9 
 16    10     2 access unaligned,				/* REWP */
 16    11       3 read bit (1) unaligned,
 16    12       3 execute bit (1) unaligned,
 16    13       3 write bit (1) unaligned,
 16    14       3 privileged bit (1) unaligned,
 16    15 
 16    16     2 pad1 bit (32) unaligned,
 16    17 
 16    18     2 rings unaligned,				/* Ring brackets */
 16    19       3 r1 bit (3) unaligned,
 16    20       3 r2 bit (3) unaligned,
 16    21       3 r3 bit (3) unaligned,
 16    22 
 16    23     2 pad2 bit (27) unaligned,
 16    24 
 16    25     2 flags aligned,
 16    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
 16    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
 16    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
 16    29       3 pad3 bit (33) unaligned,
 16    30 
 16    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
 16    32 
 16    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
     2643 
     2644      end dc_find;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0809.9  dc_find.pl1                       >spec>install>1112>dc_find.pl1
2628         1    01/30/85  1523.9  access_audit_encoded_op.incl.pl1  >ldd>include>access_audit_encoded_op.incl.pl1
2629         2    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
2630         3    02/12/85  1429.5  access_audit_user_info.incl.pl1   >ldd>include>access_audit_user_info.incl.pl1
2631         4    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
2632         5    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
2633         6    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
2634         7    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
2635         8    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
2636         9    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
2637        10    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
2638        11    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
2639        12    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
2640        13    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
2641        14    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
2642        15    01/30/85  1523.9  makeknown_info.incl.pl1           >ldd>include>makeknown_info.incl.pl1
2643        16    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 218 282 282
                                                                                  827 829
DC_FIND_CHASE                          constant        fixed bin(1,0)           initial dcl 6-10 ref 791 890 1433
DC_FIND_NO_CHASE                       constant        fixed bin(1,0)           initial dcl 6-11 ref 852 1088 1498 1931 1960
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 12-6 ref 2349 2608
E_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 1001 1001
FIND_ALL                        000005 constant        bit(4)                   initial dcl 152 set ref 924* 1995
FIND_DIR                               constant        bit(4)                   initial dcl 153 ref 2339 2358 2366
FIND_DIR_OR_LINK                000004 constant        bit(4)                   initial dcl 154 set ref 2223*
FIND_LINK                              constant        bit(4)                   initial dcl 155 ref 2372
FIND_LINK_OR_NOTHING                   constant        bit(4)                   initial dcl 156 ref 1974
FIND_NOTHING                    000003 constant        bit(4)                   initial dcl 157 set ref 1964* 2334 2358 2364 2372
FIND_OBJECT_OR_LINK             000002 constant        bit(4)                   initial dcl 158 set ref 1935* 1940
FIND_SEG                               constant        bit(4)                   initial dcl 159 ref 2338 2361 2364
FS_OBJ_BC_MOD                          constant        fixed bin(18,0)          initial unsigned dcl 11-32 ref 789 814
FS_OBJ_CONNECT                         constant        fixed bin(18,0)          initial unsigned dcl 11-31 ref 1568
FS_OBJ_CREATE_BRANCH                   constant        fixed bin(18,0)          initial unsigned dcl 11-66 ref 220 261
FS_OBJ_DIR_SALVAGE                     constant        fixed bin(18,0)          initial unsigned dcl 11-56 ref 509
FS_OBJ_MOVE_QUOTA                      constant        fixed bin(18,0)          initial unsigned dcl 11-54 ref 341
FS_OBJ_RECLASSIFY                      constant        fixed bin(18,0)          initial unsigned dcl 11-60 ref 1083
FS_OBJ_RECLASSIFY_NODE                 constant        fixed bin(18,0)          initial unsigned dcl 11-61 ref 456
FS_OBJ_TRUNCATE                        constant        fixed bin(18,0)          initial unsigned dcl 11-33 ref 1430 1446 1460
FS_OBJ_VOLUME_RETRIEVE                 constant        fixed bin(18,0)          initial unsigned dcl 11-64 ref 1492
LINK_TYPE                              constant        bit(18)                  initial packed unaligned dcl 12-7 ref 2371 2611
ME                              000000 constant        char(7)                  initial packed unaligned dcl 160 set ref 1664* 1667*
M_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 362 362 370
                                                                                  370 398 489 489 547 676 723 747 748 748 825 828
                                                                                  1101 1101 1178 1197 1205 1256 1264 1372
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 12-8 ref 2615
N_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 615 619 638
                                                                                  685 699 707 737 756 1135 1702 1727 1735 1767 1774
                                                                                  1799 1806 1839 2446 2476
READ_LOCK                       000014 constant        bit(36)                  initial dcl 161 set ref 230* 274* 307* 426* 481*
                                                                                  516* 630* 1093* 1511* 1833* 1881* 2162* 2462*
                                                                                  2543*
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 4-11 ref 1509
SEG_TYPE                               constant        bit(18)                  initial packed unaligned dcl 12-9 ref 2349 2608
SM_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 4-11 ref 476 476 1507
                                                                                  1520 1520
S_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 390 668 715
                                                                                  1059 1059 1122 1161 1239 1305 2475
WRITE_LOCK                      000013 constant        bit(36)                  initial dcl 162 set ref 355* 469*
W_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 4-11 ref 751 751 831
                                                                                  1470 1566
a_audit_user_info_ptr                  parameter       pointer                  dcl 129 ref 253 264 1486 1495
a_bc                                   parameter       fixed bin(24,0)          dcl 130 ref 782 805 828
a_bc_delta                             parameter       fixed bin(24,0)          dcl 131 ref 771 800 825
a_chase_sw                             parameter       fixed bin(1,0)           dcl 132 ref 203 212 224 253 269 659 673 682 689 1113
                                                                                  1123 1153 1166 1175 1184 1194 1202 1211 1220 1229
a_code                                 parameter       fixed bin(35,0)          dcl 2311 in procedure "find_entry" set ref 2301
                                                                                  2323* 2385*
a_code                                 parameter       fixed bin(35,0)          dcl 1677 in procedure "dir_control_error" set ref
                                                                                  1689 1708 1712 1743 1747 1780 1792 1815 1827 1847
                                                                                  1865*
a_code                                 parameter       fixed bin(35,0)          dcl 2418 in procedure "get_dir_mode" set ref 2414
                                                                                  2436 2482*
a_code                                 parameter       fixed bin(35,0)          dcl 133 in procedure "dc_find" set ref 203 212 250*
                                                                                  253 293* 296 331* 334 379* 382 395 404 413 446*
                                                                                  449 499* 502 533* 536 578* 595 656* 659 673 682
                                                                                  696 704 712 720 768* 771 782 800 805 840* 843 858*
                                                                                  861 879 901 977* 980 1013* 1016 1073* 1076 1110*
                                                                                  1113 1150* 1153 1166 1175 1184 1194 1202 1211 1220
                                                                                  1236 1244 1253 1261 1270 1296* 1299 1310 1319
                                                                                  1366* 1369 1377 1418* 1421 1442 1456 1483* 1486
                                                                                  1529* 1532 1585* 1635*
a_detailed_operation                   parameter       fixed bin(18,0)          unsigned dcl 134 ref 395 401 413 419 536 543 673 679
                                                                                  720 726 1175 1181 1184 1190 1202 1208 1220 1226
                                                                                  1261 1267 1270 1276
a_dir_uid                              parameter       bit(36)                  dcl 135 set ref 502 511* 531*
a_dirname                              parameter       char(168)                packed unaligned dcl 136 set ref 203 212 246* 253
                                                                                  289* 296 334 382 395 404 413 449 502 536 554* 575*
                                                                                  595 605 654* 659 673 682 771 782 843 861 879 1076
                                                                                  1113 1153 1166 1175 1184 1194 1202 1211 1220 1299
                                                                                  1310 1319 1336* 1340* 1363* 1369 1377 1393* 1397*
                                                                                  1415* 1421 1486 1593 1611
a_dp                                   parameter       pointer                  dcl 2312 in procedure "find_entry" ref 2301 2325
a_dp                                   parameter       pointer                  dcl 137 in procedure "dc_find" set ref 203 212 249*
                                                                                  253 292* 296 330* 334 378* 382 395 404 413 445*
                                                                                  449 498* 502 532* 536 548* 577* 901 916 936* 1591*
a_dp                                   parameter       pointer                  dcl 1675 in procedure "dir_control_error" ref 1815
                                                                                  1829
a_dp                                   parameter       pointer                  dcl 1871 in procedure "get_mode_on_dir" ref 1869
                                                                                  1878
a_ename                                parameter       char(32)                 dcl 2313 set ref 2301 2331 2331
a_entryname                            parameter       char(32)                 packed unaligned dcl 138 set ref 203 212 222 247*
                                                                                  253 267 290* 595 606 655* 659 673 682 771 782 843
                                                                                  861 879 901 917 1076 1113 1153 1166 1175 1184 1194
                                                                                  1202 1211 1220 1299 1310 1319 1364* 1369 1377
                                                                                  1416* 1421 1486 1612
a_ep                                   parameter       pointer                  dcl 139 in procedure "dc_find" set ref 581 588 659
                                                                                  673 682 696 704 712 720 767* 771 782 800 805 839*
                                                                                  843 857* 861 879 901 915* 976* 1076 1109* 1113
                                                                                  1149* 1153 1166 1175 1184 1194 1202 1211 1220 1236
                                                                                  1244 1253 1261 1270 1295* 1299 1310 1319 1329*
                                                                                  1365* 1369 1377 1386* 1417* 1421 1442 1456 1482*
                                                                                  1486 1528* 1532 1545 1609* 1619*
a_ep                                   parameter       pointer                  dcl 2314 in procedure "find_entry" set ref 2301
                                                                                  2324* 2382*
a_ep                                   parameter       pointer                  dcl 1900 in procedure "get_mode_on_entry" ref 1898
                                                                                  1904
a_ep                                   parameter       pointer                  dcl 1676 in procedure "dir_control_error" ref 1689
                                                                                  1698 1708 1712 1718 1743 1747 1753 1780 1794 1847
                                                                                  1856
a_ep                                   parameter       pointer                  dcl 1640 in procedure "audit_success$msg" ref 1638
                                                                                  1651 1655 1658
a_exmode                               parameter       bit(36)                  dcl 140 set ref 1016 1071*
a_kstep                                parameter       pointer                  dcl 141 ref 1532 1544
a_message                              parameter       char(32)                 dcl 1641 ref 1638 1648
a_mode                                 parameter       bit(36)                  dcl 142 in procedure "dc_find" set ref 1016 1070*
a_mode                                 parameter       bit(36)                  dcl 2419 in procedure "get_dir_mode" set ref 2414
                                                                                  2436 2443* 2480*
a_pep                                  parameter       pointer                  dcl 143 set ref 203 212 225* 248* 253 266* 291* 334
                                                                                  343* 377* 449 458* 497* 536 548* 576* 1076 1087*
                                                                                  1108*
a_ppep                                 parameter       pointer                  dcl 144 set ref 449 458* 496*
a_ringbr                               parameter       fixed bin(3,0)           array dcl 145 set ref 1016 1072*
a_segptr                               parameter       pointer                  dcl 2420 in procedure "get_dir_mode" ref 2414 2436
                                                                                  2444
a_segptr                               parameter       pointer                  dcl 146 in procedure "dc_find" set ref 696 704 712
                                                                                  720 800 805 980 991 1012 1016 1025 1236 1244 1253
                                                                                  1261 1270 1442 1456 1621
a_type                                 parameter       bit(4)                   dcl 2315 ref 2301 2326
a_typelock                             parameter       bit(36)                  dcl 2586 ref 2584 2596
a_uid                                  parameter       bit(36)                  dcl 2587 ref 2584 2594
a_uidpath                              parameter       bit(36)                  array dcl 148 ref 536 550 1299 1310 1319 1332 1369
                                                                                  1377 1389
a_unlocksw                             parameter       bit(1)                   dcl 147 ref 581 590
access                    6(33)        based           bit(3)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 14-36 in procedure "dc_find" ref 1557
access                    2     000221 automatic       structure                level 2 in structure "sdwi" packed packed unaligned
                                                                                  dcl 186 in procedure "dc_find" set ref 1571 1580*
access_audit_$log_entry_ptr     000072 constant        entry                    external dcl 76 ref 1667
access_audit_$log_entry_ptr_user
                                000074 constant        entry                    external dcl 77 ref 1664
access_audit_check_ep_$self     000066 constant        entry                    external dcl 74 ref 1662
access_audit_check_ep_$user     000070 constant        entry                    external dcl 75 ref 1660
access_checker                  000100 automatic       entry variable           dcl 166 set ref 876* 886* 912* 951
access_class             13            based           bit(72)                  level 2 in structure "dir" dcl 8-11 in procedure
                                                                                  "dc_find" set ref 362* 2158*
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 7-8 in procedure
                                                                                  "dc_find" set ref 362* 2254* 2548*
access_information        5            based           structure                level 2 packed packed unaligned dcl 14-36
access_mode$effective           000076 constant        entry                    external dcl 78 ref 616 743 796 876 912 1132 1352
                                                                                  1438 1906
access_mode$raw                 000100 constant        entry                    external dcl 79 ref 236 368 474 487 566 886 1099
                                                                                  1467
access_mode$user_effmode        000102 constant        entry                    external dcl 80 ref 280 1503 1516 1905
access_operations_$fs_obj_access_mod
                                000200 external static bit(36)                  dcl 11-27 ref 455 1082 1180 1189
access_operations_$fs_obj_attr_mod
                                000174 external static bit(36)                  dcl 11-25 ref 678 725
access_operations_$fs_obj_contents_mod
                                000170 external static bit(36)                  dcl 11-23 ref 219 260 340 400 418 508 542 788 813
                                                                                  1429 1445 1459 1491 1567
access_operations_$fs_obj_contents_read
                                000166 external static bit(36)                  dcl 11-22 ref 392 409 628 987 1541 1629 2161 2258
                                                                                  2341 2552
access_operations_$fs_obj_delete
                                000160 external static bit(36)                  dcl 11-19 ref 1199 1216 1258 1374 1382
access_operations_$fs_obj_initiate
                                000162 external static bit(36)                  dcl 11-20 ref 301 874 882 910
access_operations_$fs_obj_prop_read
                                000172 external static bit(36)                  dcl 11-24 ref 602 670 701 717 851 1022 1119 1163
                                                                                  1171 1241 1249 1307 1315 1324 2353 2377
access_operations_$fs_obj_status_mod
                                000176 external static bit(36)                  dcl 11-26 ref 1207 1225 1266 1275
access_operations_$fs_obj_terminate
                                000164 external static bit(36)                  dcl 11-21 ref 687 709 730
activate                  2(05) 000201 automatic       bit(1)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  2145* 2528*
active_all_rings_data$maxlinks  000010 external static fixed bin(17,0)          dcl 48 ref 1942 1976 1997 2232
addcharno                                              builtin function         dcl 106 ref 2208 2215 2237 2239
addr                                                   builtin function         dcl 107 ref 220 261 341 401 410 419 420 456 457 509
                                                                                  510 543 544 679 726 789 814 883 1012 1083 1084
                                                                                  1172 1181 1190 1191 1208 1217 1226 1227 1250 1267
                                                                                  1276 1277 1316 1325 1340 1383 1397 1430 1446 1460
                                                                                  1461 1492 1564 1564 1564 1564 1568 1583 1583 1583
                                                                                  1583 1647 1653 1664 1664 2148 2158 2173 2187 2199
                                                                                  2208 2215 2237 2238 2246 2254 2265 2265 2273 2294
                                                                                  2294 2331 2331 2352 2533 2533 2548 2559 2559 2614
aim_check_$greater_or_equal     000104 constant        entry                    external dcl 81 ref 362
aim_template                           based           structure                level 1 dcl 5-12
allow_aim_isolated_final_dir
                          1     000232 automatic       bit(1)                   level 2 dcl 188 set ref 344* 545* 2158 2254 2548
allow_searching_aim_isolated_dirs
                                000232 automatic       bit(1)                   level 2 dcl 188 set ref 885* 1326* 2158 2254 2548
allow_write               2(02) 000201 automatic       bit(1)                   level 3 in structure "my_makeknown_info" packed
                                                                                  packed unaligned dcl 179 in procedure "dc_find"
                                                                                  set ref 2145* 2528*
allow_write               7(13)        based           bit(1)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 14-36 in procedure "dc_find" ref 1581
audit                           000402 automatic       bit(1)                   dcl 1643 set ref 1660* 1662* 1664
audit_event_flags                      based           structure                level 1 dcl 2-5
audit_flags              36     000232 automatic       bit(36)                  level 3 dcl 188 set ref 1660*
audit_user_info                        based           structure                level 1 dcl 3-13 ref 264 1495
authorization                   000544 automatic       bit(72)                  dcl 2115 in procedure "find_dir" set ref 2137* 2138*
                                                                                  2158* 2158 2254* 2254
authorization                   000610 automatic       bit(72)                  dcl 2317 in procedure "find_entry" set ref 2328*
                                                                                  2329* 2352
authorization            30     000232 automatic       bit(72)                  level 3 in structure "state" dcl 188 in procedure
                                                                                  "dc_find" set ref 280* 1503* 1516* 1660* 1905*
                                                                                  2137 2328 2511
authorization                   000704 automatic       bit(72)                  dcl 2492 in procedure "uid_path_util" set ref 2511*
                                                                                  2512* 2548* 2548
bad_dir_                        000000 stack reference condition                dcl 125 ref 2349 2371 2605 2606 2608 2610 2611 2615
baseptr                                                builtin function         dcl 108 ref 2156 2175 2201 2272 2537 2566
bc                       40(11)        based           fixed bin(24,0)          level 2 packed packed unaligned dcl 7-8 ref 828
binary                                                 builtin function         dcl 109 ref 2472
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 7-8 ref 741 931
                                                                                  1131 1729 1757 1801 2014 2226 2348 2606 2612
change_bc                       000104 automatic       bit(1)                   dcl 167 set ref 779* 784* 802* 807* 825
chase_sw                        000105 automatic       fixed bin(1,0)           dcl 168 set ref 224* 269* 689* 791* 852* 890* 1088*
                                                                                  1123* 1229* 1433* 1498* 1931 1960
code                            000612 automatic       fixed bin(35,0)          dcl 2318 in procedure "find_entry" set ref 2331*
                                                                                  2332 2333 2335* 2338* 2339* 2340* 2342* 2354* 2355
                                                                                  2355* 2358* 2361* 2362* 2364* 2366* 2367* 2372*
                                                                                  2374* 2376 2378* 2385
code                            000424 automatic       fixed bin(35,0)          dcl 1679 in procedure "dir_control_error" set ref
                                                                                  1699* 1702* 1704* 1720* 1727* 1731 1735* 1736*
                                                                                  1738* 1755* 1756* 1757* 1763 1767* 1774* 1775*
                                                                                  1793* 1796* 1799* 1803 1806* 1807* 1809* 1812
                                                                                  1828* 1833* 1834 1835 1835 1839* 1840* 1842 1857*
                                                                                  1858* 1865 1881* 1882 1882 1882 1885* 1892 1894*
                                                                                  1905* 1906*
code                            000106 automatic       fixed bin(35,0)          dcl 169 in procedure "dc_find" set ref 228 230* 231
                                                                                  232 232* 236* 237* 238 240* 250 272 274* 275 276
                                                                                  276* 280* 281 283* 293 305 307* 308 309 309* 313*
                                                                                  314 317* 318 321* 331 348* 353 355* 356 360* 361
                                                                                  364* 368* 369 371* 379 424 426* 427 428 428* 433*
                                                                                  434 436* 446 462* 467 469* 470 474* 475 477* 481*
                                                                                  482 483 483* 487* 488 490* 499 514 516* 517 518
                                                                                  518* 524* 525 533 549* 554 555 557* 558 561* 562
                                                                                  566* 567 569* 604* 610 613* 614 616* 617 620* 630*
                                                                                  631 632 632* 636* 637 639* 640* 648* 656 693 730
                                                                                  730 734* 736 743* 745* 746 757* 768 794 796* 797
                                                                                  817 819* 820 833* 840 855 858 893 894 896* 918*
                                                                                  920* 921 924* 925 927* 938 940* 944 946* 951* 953
                                                                                  964* 967* 968 968* 970* 977 990* 996 998* 999
                                                                                  1002* 1013 1024* 1029* 1030 1030 1032* 1041* 1042
                                                                                  1056* 1057 1060* 1067* 1073 1091 1093* 1094 1095
                                                                                  1095* 1099* 1100 1102* 1110 1126 1128* 1129 1132*
                                                                                  1133 1136* 1139* 1142* 1150 1233 1281 1285* 1286
                                                                                  1288* 1296 1331* 1335 1339 1344 1348* 1349 1352*
                                                                                  1353 1355* 1366 1388* 1392 1396 1401 1405* 1406
                                                                                  1408* 1418 1436 1438* 1439 1450 1452* 1453 1465
                                                                                  1467* 1468 1473* 1474* 1475 1475* 1483 1501 1503*
                                                                                  1504 1511* 1512 1516* 1519 1521* 1529 1543* 1548*
                                                                                  1549* 1560* 1585 1592* 1610* 1620* 1625 1627* 1628
                                                                                  1630* 1631* 1635 1664* 1667* 1927* 1933 1935* 1936
                                                                                  1942 1947 1947* 1948 1956* 1962 1964* 1965 1976
                                                                                  1981 1981* 1982 1991* 1997 2002 2002* 2003 2009
                                                                                  2011* 2012 2017* 2037* 2042* 2046* 2126* 2162*
                                                                                  2163 2165* 2190* 2212* 2219* 2220 2223* 2224 2234*
                                                                                  2259* 2265* 2266 2266 2276* 2294* 2295 2295 2392
                                                                                  2394* 2395* 2396 2407* 2408 2509* 2515* 2522*
                                                                                  2533* 2534 2534 2553* 2559* 2560 2560 2571* 2596*
                                                                                  2597* 2598 2624*
code                            000652 automatic       fixed bin(35,0)          dcl 2422 in procedure "get_dir_mode" set ref 2447*
                                                                                  2448 2462* 2463 2464 2464* 2482
copysw                   32(03)        based           bit(1)                   level 2 packed packed unaligned dcl 7-8 ref 1473
current_depth                   000706 automatic       fixed bin(17,0)          dcl 2493 set ref 2542* 2543 2548 2557*
detailed_operation        0(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-3 set
                                                                                  ref 220* 261* 341* 401* 419* 456* 509* 543* 679*
                                                                                  726* 789* 814* 1083* 1181* 1190* 1208* 1226* 1267*
                                                                                  1276* 1430* 1446* 1460* 1492* 1568*
dir                                    based           structure                level 1 dcl 8-11 in procedure "dc_find"
dir                       1(19)        based           bit(1)                   level 3 in structure "aim_template" packed packed
                                                                                  unaligned dcl 5-12 in procedure "dc_find" ref 2158
                                                                                  2254 2548
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-11 ref 2601
dir_held                  2     000232 automatic       bit(1)                   level 2 dcl 188 set ref 743 1602 2021* 2061 2063*
                                                                                  2157* 2176* 2202* 2250* 2284 2286* 2398* 2536*
                                                                                  2578 2580*
dir_locked                3     000232 automatic       bit(1)                   level 2 dcl 188 set ref 559* 922* 935* 1038* 1068
                                                                                  1601 2019* 2057 2059* 2221* 2248* 2269* 2280 2282*
                                                                                  2401* 2410* 2563* 2574 2576* 2599*
dir_uid                         000107 automatic       bit(36)                  dcl 170 set ref 524* 531
dirmode                         000110 automatic       bit(36)                  dcl 171 set ref 218* 239 239 390* 398* 407* 416* 432
                                                                                  435 435 547* 568 568 668* 676* 685* 699* 707* 715*
                                                                                  723* 737 737 747 1054* 1056* 1059 1122* 1130 1130
                                                                                  1161* 1169* 1178* 1187* 1197* 1205* 1214* 1223*
                                                                                  1239* 1247* 1256* 1264* 1273* 1283 1287 1287 1305*
                                                                                  1313* 1322* 1346 1350 1350 1372* 1380* 1403 1407
                                                                                  1407
dirmode_raw                     000111 automatic       bit(1)                   dcl 172 set ref 209* 214* 236
dirname                         000112 automatic       varying char(168)        dcl 173 set ref 246 289 347 461 554 575 605* 654
                                                                                  932* 1336 1340 1363 1393 1397 1415 1593* 1611*
                                                                                  2016* 2036 2040 2049 2050 2051* 2051 2141 2142
                                                                                  2246* 2507* 2523* 2540* 2541* 2545* 2545 2546*
                                                                                  2546
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 7-8 in procedure "dc_find" ref 618 748 755 822
                                                                                  960 966 1048 1067 1134 1475 1505 1553 1733 1765
                                                                                  1805 2349 2349 2358 2612
dirsw                     2     000201 automatic       bit(1)                   level 3 in structure "my_makeknown_info" packed
                                                                                  packed unaligned dcl 179 in procedure "dc_find"
                                                                                  set ref 2145* 2528*
dp                              000654 automatic       pointer                  dcl 2423 in procedure "get_dir_mode" set ref 2452*
                                                                                  2469* 2479*
dp                              000426 automatic       pointer                  dcl 1680 in procedure "dir_control_error" set ref
                                                                                  1725* 1726* 1772* 1773* 1795* 1798* 1829* 1833*
dp                              000314 automatic       pointer                  dcl 8-9 in procedure "dc_find" set ref 230* 237* 249
                                                                                  274* 292 307* 313* 330 355* 362 378 426* 433* 445
                                                                                  469* 498 516* 522 524* 532 548* 557* 561* 577 613*
                                                                                  630* 636* 640* 651* 652 652 734* 895* 916* 920*
                                                                                  924* 934* 945* 1008* 1037* 1056* 1068* 1093* 1128*
                                                                                  1285* 1348* 1405* 1511* 1591* 1601* 1602 1602
                                                                                  1928* 1935* 1957* 1964* 1992* 2011* 2018* 2020
                                                                                  2020 2058* 2062 2062 2156* 2158 2162* 2175* 2201*
                                                                                  2219* 2223* 2247* 2268* 2272* 2281* 2394* 2395*
                                                                                  2397 2397 2409* 2506* 2537* 2562* 2566* 2575* 2579
                                                                                  2579 2596* 2597* 2601 2601 2601 2603 2603 2606
                                                                                  2610 2622
dp                              000614 automatic       pointer                  dcl 2319 in procedure "find_entry" set ref 2325*
                                                                                  2331* 2342* 2349 2371
dp                              000450 automatic       pointer                  dcl 1873 in procedure "get_mode_on_dir" set ref
                                                                                  1878* 1881* 1894*
dseg$                           000012 external static fixed bin(71,0)          array dcl 49 set ref 1564 1564 1583 1583
dtbm                      5            based           bit(36)                  level 3 packed packed unaligned dcl 14-36 ref 1555
                                                                                  2453 2470
dtem                      3            based           bit(36)                  level 2 dcl 7-8 ref 1555 2470
ecount                          000722 automatic       fixed bin(17,0)          dcl 2589 set ref 2602* 2604* 2604 2605
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 7-8 ref 2622
ename_len                       000526 automatic       fixed bin(17,0)          dcl 2033 set ref 2040* 2041 2045 2049 2050
encoded_access_op                      based           structure                level 1 dcl 1-3
entry                                  based           structure                level 1 dcl 7-8 in procedure "dc_find"
entry                           000546 automatic       char(32)                 dcl 2116 in procedure "find_dir" set ref 2215* 2223*
entry_len                       000556 automatic       fixed bin(21,0)          dcl 2117 set ref 2208* 2209 2209* 2210* 2210 2211
                                                                                  2215 2216 2217
entry_rp                  2            based           bit(18)                  level 2 packed packed unaligned dcl 10-7 ref 2615
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 8-11 ref 2603
entryname                       000165 automatic       char(32)                 dcl 174 set ref 222* 244* 247 267* 287* 290 606* 655
                                                                                  917* 924* 933* 1364 1416 1612* 1935* 1964* 2011*
                                                                                  2027 2050* 2508* 2546 2618*
entryp                    1     000201 automatic       pointer                  level 2 in structure "my_makeknown_info" packed
                                                                                  packed unaligned dcl 179 in procedure "dc_find"
                                                                                  set ref 2263* 2293* 2531* 2558*
entryp                    3            based           pointer                  level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 14-36 in procedure "dc_find" ref 1549 1549
                                                                                  1631 1631 2467
entrysw                         000707 automatic       bit(1)                   dcl 2494 set ref 2500* 2504* 2539 2569
ep                              000466 automatic       pointer                  dcl 1902 in procedure "get_mode_on_entry" set ref
                                                                                  1904* 1905* 1906*
ep                              000430 automatic       pointer                  dcl 1681 in procedure "dir_control_error" set ref
                                                                                  1698* 1699 1701* 1718* 1720 1725 1729 1730* 1733
                                                                                  1753* 1755 1756 1757 1762* 1765 1772 1794* 1795
                                                                                  1796 1801 1802* 1805 1812* 1856* 1857 1861*
ep                              000312 automatic       pointer                  dcl 7-6 in procedure "dc_find" set ref 548* 588* 589
                                                                                  590 590 591 591 612 616* 618 620* 625* 741 743*
                                                                                  748 755 757* 764* 767 796* 822 828 833* 837* 839
                                                                                  857 895* 915* 924* 926 931 932 932 939 945* 951*
                                                                                  957 960 964 966 967* 970* 974* 976 989* 1002*
                                                                                  1006* 1023* 1029* 1033* 1037 1044 1048 1054 1060*
                                                                                  1065* 1067 1106* 1109 1131 1132* 1134 1136* 1139*
                                                                                  1142* 1147* 1149 1288* 1293* 1295 1329* 1352*
                                                                                  1355* 1361* 1365 1386* 1408* 1413* 1417 1438*
                                                                                  1467* 1473 1473* 1474* 1475 1480* 1482 1503* 1505
                                                                                  1521* 1526* 1528 1545* 1547 1553 1555 1555* 1560*
                                                                                  1571 1571 1571 1571* 1576 1577 1578 1609* 1619*
                                                                                  1928* 1935* 1964* 1992* 2011* 2014 2014 2016 2016
                                                                                  2407* 2409 2506* 2548 2553* 2558 2603* 2603* 2606
                                                                                  2606 2608 2608 2610 2611 2612 2612 2612 2614 2615
                                                                                  2615* 2622
ep                              000616 automatic       pointer                  dcl 2320 in procedure "find_entry" set ref 2331*
                                                                                  2348 2349 2349 2349 2349 2349 2352 2354* 2358 2371
                                                                                  2371 2378* 2382
ep                              000404 automatic       pointer                  dcl 1644 in procedure "audit_success$msg" set ref
                                                                                  1658* 1660* 1662* 1664* 1667*
ep                              000656 automatic       pointer                  dcl 2424 in procedure "get_dir_mode" set ref 2452*
                                                                                  2453* 2462* 2467* 2469 2470 2470*
ep                              000560 automatic       pointer                  dcl 2118 in procedure "find_dir" set ref 2223* 2226
                                                                                  2232 2239 2240 2243 2243 2243 2244 2254 2259* 2263
                                                                                  2264
error_table_$bad_uidpath        000014 external static fixed bin(35,0)          dcl 50 ref 1339 1396 2515 2624
error_table_$badpath            000016 external static fixed bin(35,0)          dcl 51 ref 2042 2190
error_table_$dirseg             000020 external static fixed bin(35,0)          dcl 52 ref 964 968 1067 1475 2361
error_table_$entlong            000022 external static fixed bin(35,0)          dcl 53 ref 2046 2212
error_table_$incorrect_access   000024 external static fixed bin(35,0)          dcl 54 ref 1699 1702 1720 1727 1735 1857 2355
error_table_$link               000026 external static fixed bin(35,0)          dcl 55 ref 1942 1947 1976 1981 1997 2002 2017 2374
error_table_$moderr             000030 external static fixed bin(35,0)          dcl 56 ref 968 1475 1756 1767 1774
error_table_$mylock             000032 external static fixed bin(35,0)          dcl 57 ref 1835 1882 2464
error_table_$namedup            000042 external static fixed bin(35,0)          dcl 61 ref 2358 2364 2372
error_table_$no_dir             000034 external static fixed bin(35,0)          dcl 58 ref 2339
error_table_$no_info            000036 external static fixed bin(35,0)          dcl 59 ref 639 927 940 1704 1736 1738 1755 1757 1775
                                                                                  1807 1809 1812 1840 1842
error_table_$no_s_permission    000040 external static fixed bin(35,0)          dcl 60 ref 1858
error_table_$noentry            000044 external static fixed bin(35,0)          dcl 62 ref 648 2333 2338
error_table_$not_link           000046 external static fixed bin(35,0)          dcl 63 ref 2340 2362 2367
error_table_$notadir            000050 external static fixed bin(35,0)          dcl 64 ref 2366
error_table_$oosw               000052 external static fixed bin(35,0)          dcl 65 ref 2355
error_table_$root               000054 external static fixed bin(35,0)          dcl 66 ref 232 276 309 348 428 462 483 518 554 632
                                                                                  730 894 944 1030 1095 1335 1392 1835 1882 2037
                                                                                  2522
error_table_$seg_deleted        000056 external static fixed bin(35,0)          dcl 67 ref 1548 1625 1630
error_table_$segknown           000060 external static fixed bin(35,0)          dcl 68 ref 2266 2295 2534 2560
error_table_$toomanylinks       000062 external static fixed bin(35,0)          dcl 69 ref 1947 1981 2002 2234
event_flags              13     000232 automatic       bit(36)                  level 2 dcl 188 set ref 410 420 457 510 544 883 1084
                                                                                  1172 1191 1217 1227 1250 1277 1316 1325 1340 1383
                                                                                  1397 1461 1647 1653 1660* 1662* 1664* 1667*
ex_rb                     7            based           bit(3)                   array level 3 packed packed unaligned dcl 14-36 ref
                                                                                  2472
exmode                          000432 automatic       bit(36)                  dcl 1682 in procedure "dir_control_error" set ref
                                                                                  1702 1727 1733 1765 1774 1799 1805 1839 1894*
                                                                                  1905* 1906*
exmode                          000175 automatic       bit(36)                  dcl 175 in procedure "dc_find" set ref 236* 237* 239
                                                                                  280* 282 313* 315 317* 320 360* 362 368* 370 433*
                                                                                  435 474* 476 487* 489 566* 568 613* 615 616* 618
                                                                                  636* 638 734* 737 737 743* 745* 748 755 796* 819*
                                                                                  824 951* 957 960 998* 1041* 1045 1046* 1049 1050*
                                                                                  1071 1099* 1101 1128* 1130 1132* 1134 1285* 1287
                                                                                  1348* 1350 1352* 1354 1405* 1407 1438* 1452* 1467*
                                                                                  1503* 1506 1516* 1520
extended_access           6            based           bit(33)                  level 3 packed packed unaligned dcl 14-36 ref 2454
                                                                                  2471
find_dir_has_work_area
                          7     000232 automatic       bit(1)                   level 2 dcl 188 set ref 2132 2134*
find_type                       000476 automatic       bit(4)                   dcl 1924 set ref 1940* 1974* 1995* 2011*
flags                     7(12)        based           structure                level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 14-36 in procedure "dc_find"
flags                     2     000201 automatic       structure                level 2 in structure "my_makeknown_info" packed
                                                                                  packed unaligned dcl 179 in procedure "dc_find"
for_user                  4     000232 automatic       bit(1)                   level 2 dcl 188 set ref 263* 1494* 1660 1664 1879
                                                                                  1905 2137 2328 2511
fs_modes$locked                 000106 constant        entry                    external dcl 82 ref 745 819 998 1041 1452
get_kstep                       000110 constant        entry                    external dcl 83 ref 1627 2447
grant                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 2-5 set ref
                                                                                  1647* 1653*
hash$search                     000112 constant        entry                    external dcl 84 ref 2331
index                                                  builtin function         dcl 110 ref 2040 2187 2208
info_only                       000433 automatic       bit(1)                   dcl 1683 set ref 1696* 1709* 1713* 1744* 1748* 1855*
                                                                                  1861
its_unsigned                           based           structure                level 1 dcl 13-30
kste                                   based           structure                level 1 dcl 14-36
kstep                           000316 automatic       pointer                  dcl 14-15 in procedure "dc_find" set ref 1544* 1549
                                                                                  1549 1555 1555* 1557 1564 1564 1581 1583 1583
                                                                                  1627* 1631 1631
kstep                           000660 automatic       pointer                  dcl 2425 in procedure "get_dir_mode" set ref 2447*
                                                                                  2450 2453 2453* 2454 2467 2470 2470* 2471 2472
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-11 ref 2601
length                                                 builtin function         dcl 111 ref 2049 2141 2232
level$get                       000114 constant        entry                    external dcl 85 ref 1010 1667 1667 2473
link                                   based           structure                level 1 dcl 9-6
linkage_ring                    000176 automatic       fixed bin(3,0)           dcl 176 set ref 1010* 1012
links                           000477 automatic       fixed bin(17,0)          dcl 1925 set ref 1942* 1976* 1997*
lock$dir_lock_read              000116 constant        entry                    external dcl 86 ref 920 2219 2395 2597
lock$dir_lock_salvage           000120 constant        entry                    external dcl 87 ref 524
lock$dir_lock_write             000122 constant        entry                    external dcl 88 ref 557 2394 2596
lock$dir_unlock                 000124 constant        entry                    external dcl 89 ref 328 443 529 590 646 651 934 1008
                                                                                  1068 1517 1599 1600 1601 1844 1891 2018 2058 2166
                                                                                  2247 2268 2281 2479 2562 2575
lock_for_writing                000177 automatic       bit(36)                  dcl 177 set ref 223* 268* 302* 345* 389* 397* 406*
                                                                                  415* 459* 551* 561* 607* 667* 675* 684* 698* 706*
                                                                                  714* 722* 790* 809* 849* 888* 914* 993* 1027*
                                                                                  1029* 1086* 1121* 1160* 1168* 1177* 1186* 1196*
                                                                                  1204* 1213* 1222* 1238* 1246* 1255* 1263* 1272*
                                                                                  1304* 1312* 1321* 1371* 1379* 1432* 1448* 1463*
                                                                                  1497* 2394 2407* 2569*
lock_sw                         000662 automatic       bit(1)                   dcl 2426 set ref 2451* 2458* 2463* 2479
locked                          000434 automatic       bit(1)                   dcl 1684 in procedure "dir_control_error" set ref
                                                                                  1831* 1834* 1844
locked                          000452 automatic       bit(1)                   dcl 1874 in procedure "get_mode_on_dir" set ref
                                                                                  1880* 1884* 1891
makeknown_                      000126 constant        entry                    external dcl 90 ref 2265 2294 2533 2559
makeknown_info                         based           structure                level 1 dcl 15-7
max                                                    builtin function         dcl 112 ref 2051
max_depth                       000710 automatic       fixed bin(17,0)          dcl 2495 set ref 2518* 2518* 2520* 2520 2521 2539*
                                                                                  2539 2540 2542 2548 2569
message                         000406 automatic       char(32)                 packed unaligned dcl 1645 set ref 1648* 1657* 1664*
                                                                                  1667*
min                                                    builtin function         dcl 113 ref 1010
mlr_                            000130 constant        entry                    external dcl 91 ref 2242
mode                            000200 automatic       bit(36)                  dcl 178 in procedure "dc_find" set ref 236* 280*
                                                                                  368* 474* 487* 566* 616* 618* 619 743* 745* 751
                                                                                  755* 756 796* 819* 824* 832 951* 963 998* 1001
                                                                                  1041* 1045* 1049* 1053 1070 1099* 1132* 1134* 1135
                                                                                  1352* 1438* 1452* 1467* 1472 1503* 1506* 1510
                                                                                  1516* 1555* 1557* 1559 1566 1571 1580
mode                            000663 automatic       bit(36)                  dcl 2427 in procedure "get_dir_mode" set ref 2446*
                                                                                  2453* 2454* 2470* 2471* 2475* 2475 2476* 2480
mode                            000435 automatic       bit(36)                  dcl 1685 in procedure "dir_control_error" set ref
                                                                                  1733* 1735 1765* 1767 1805* 1806 1905* 1906*
modify                                 based           bit(36)                  level 2 dcl 8-11 set ref 522*
mrl_                            000132 constant        entry                    external dcl 92 ref 2240
my_makeknown_info               000201 automatic       structure                level 1 dcl 179 set ref 2144* 2265 2265 2294 2294
                                                                                  2527* 2533 2533 2559 2559
name                      4            based           char(32)                 level 2 dcl 10-7 ref 2618
names                                  based           structure                level 1 dcl 10-7
need_to_lock                    000664 automatic       bit(1)                   dcl 2428 set ref 2433* 2441* 2461
new_son_ptr                     000562 automatic       pointer                  dcl 2119 set ref 2238* 2239* 2239 2240* 2242*
nnp                             000724 automatic       pointer                  dcl 2590 set ref 2614* 2615 2615 2615 2618
null                                                   builtin function         dcl 114 ref 225 266 316 343 458 548 589 612 895 915
                                                                                  926 936 939 945 957 964 989 1023 1033 1044 1054
                                                                                  1087 1329 1386 1547 1591 1609 1619 1664 1664 1667
                                                                                  1667 1699 1720 1756 1796 1832 1857 1928 1957 1992
                                                                                  2014 2293 2324 2452 2506 2531
num_entries_in_dir              000726 automatic       fixed bin(17,0)          dcl 2591 set ref 2601* 2605
numlinks                        000564 automatic       fixed bin(17,0)          dcl 2120 set ref 2146* 2231* 2231 2232
objmode                         000204 automatic       bit(36)                  dcl 180 set ref 825* 827* 828* 829* 831* 832 832
                                                                                  1470* 1472 1472 1507* 1509* 1510 1510
old_son_ptr                     000566 automatic       pointer                  dcl 2121 set ref 2237* 2240* 2242*
operation                12     000232 automatic       bit(36)                  level 2 dcl 188 set ref 219* 220 260* 261 301* 340*
                                                                                  341 392* 400* 401 409* 418* 419 455* 456 508* 509
                                                                                  542* 543 602* 628* 670* 678* 679 687* 701* 709*
                                                                                  717* 725* 726 730 788* 789 813* 814 851* 874* 882*
                                                                                  910* 987* 1022* 1082* 1083 1119* 1163* 1171* 1180*
                                                                                  1181 1189* 1190 1199* 1207* 1208 1216* 1225* 1226
                                                                                  1241* 1249* 1258* 1266* 1267 1275* 1276 1307*
                                                                                  1315* 1324* 1374* 1382* 1429* 1430 1445* 1446
                                                                                  1459* 1460 1491* 1492 1541* 1567* 1568 1629* 1660*
                                                                                  1662* 1664* 1667* 2161* 2258* 2341* 2353* 2377*
                                                                                  2552*
original_code                   000436 automatic       fixed bin(35,0)          dcl 1686 set ref 1792* 1796 1799 1806 1827* 1839
owner                                  based           bit(36)                  level 2 in structure "link" dcl 9-6 in procedure
                                                                                  "dc_find" ref 2371 2610
owner                    15            based           bit(36)                  level 2 in structure "names" dcl 10-7 in procedure
                                                                                  "dc_find" ref 2615
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 7-8 in procedure
                                                                                  "dc_find" ref 2349 2606
parent_len                             based           fixed bin(21,0)          level 2 dcl 2107 set ref 2141* 2142 2148 2148 2173
                                                                                  2187 2187 2189 2193 2194* 2198 2199 2199 2208 2215
                                                                                  2217* 2217 2237 2240 2244* 2246 2273 2273
parent_locked             5     000232 automatic       bit(1)                   level 2 dcl 188 set ref 231* 275* 308* 328 358* 427*
                                                                                  443 472* 517* 529 564* 631* 646 1094* 1514* 1518*
                                                                                  1600
parent_parent_locked      6     000232 automatic       bit(1)                   level 2 dcl 188 set ref 482* 1599
parent_path                            based           char                     dcl 2101 ref 2187 2246
parent_path_var                        based           varying char             dcl 2102 set ref 2148* 2173 2199* 2273*
path_len                        000527 automatic       fixed bin(17,0)          dcl 2034 set ref 2049* 2050 2051
pathname                 31            based           char                     level 2 packed packed unaligned dcl 9-6 ref 932 2016
                                                                                  2243
pathname_am$get_segno           000134 constant        entry                    external dcl 93 ref 2148 2199
pathname_am$set                 000136 constant        entry                    external dcl 94 ref 2273
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 9-6 ref 932 932
                                                                                  2016 2016 2232 2239 2240 2243 2243 2243 2244 2371
                                                                                  2610
pdp                             000206 automatic       pointer                  dcl 181 in procedure "dc_find" set ref 234* 278*
                                                                                  311* 316 317* 328* 357* 360* 430* 443* 471* 481*
                                                                                  520* 529* 548* 563* 634* 646* 1097* 1513* 1517*
                                                                                  1600* 2164* 2166*
pdp                             000454 automatic       pointer                  dcl 1875 in procedure "get_mode_on_dir" set ref
                                                                                  1889* 1891*
pds$access_authorization        000064 external static bit(72)                  dcl 70 ref 2138 2329 2512
pep                             000456 automatic       pointer                  dcl 1876 in procedure "get_mode_on_dir" set ref
                                                                                  1881* 1889 1890*
pep                             000210 automatic       pointer                  dcl 182 in procedure "dc_find" set ref 225* 230* 234
                                                                                  236* 240* 244* 248 266* 274* 278 280* 283* 287*
                                                                                  291 307* 311 321* 326* 343* 355* 357 362 364* 368*
                                                                                  371* 375* 377 426* 430 436* 441* 458* 469* 471
                                                                                  474* 477* 490* 494* 497 516* 520 527* 548* 561*
                                                                                  563 566* 569* 573* 576 630* 634 644* 1087* 1093*
                                                                                  1097 1099* 1102* 1108 1511* 1513 1516* 2162* 2164
                                                                                  2165*
pep                             000440 automatic       pointer                  dcl 1687 in procedure "dir_control_error" set ref
                                                                                  1832* 1833* 1838* 1842* 1844 1844
ppdp                            000212 automatic       pointer                  dcl 183 set ref 485* 1599*
ppep                            000214 automatic       pointer                  dcl 184 set ref 458* 481* 485 487* 496
primary_name             10            based           bit(504)                 level 2 packed packed unaligned dcl 7-8 set ref 2614
priv_init                 2(03) 000201 automatic       bit(1)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  2528*
priv_op                   0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-5 set ref 410*
                                                                                  420* 457* 510* 544* 883* 1084* 1172* 1191* 1217*
                                                                                  1227* 1250* 1277* 1316* 1325* 1340 1383* 1397
                                                                                  1461*
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 5-12
ptr                                                    builtin function         dcl 115 ref 234 278 311 357 430 471 485 520 563 590
                                                                                  590 634 1037 1097 1513 1549 1549 1631 1631 1725
                                                                                  1772 1795 1844 1844 1889 2164 2409 2469 2603 2622
r1                        3     000221 automatic       bit(3)                   level 3 packed packed unaligned dcl 186 set ref 1571
                                                                                  1576*
r2                        3(03) 000221 automatic       bit(3)                   level 3 packed packed unaligned dcl 186 set ref 1571
                                                                                  1577*
r3                        3(06) 000221 automatic       bit(3)                   level 3 packed packed unaligned dcl 186 set ref 1571
                                                                                  1578*
rb                              000665 automatic       fixed bin(3,0)           array dcl 2429 set ref 2455* 2455* 2455* 2472* 2474
                                                                                  2475
read_allowed_                   000140 constant        entry                    external dcl 95 ref 2158 2254 2548
rel                                                    builtin function         dcl 116 ref 1755 2603 2615
reverse                                                builtin function         dcl 117 ref 2040 2187
ring                            000670 automatic       fixed bin(3,0)           dcl 2430 in procedure "get_dir_mode" set ref 2473*
                                                                                  2474 2475
ring                     26     000232 automatic       fixed bin(3,0)           level 3 in structure "state" packed packed unsigned
                                                                                  unaligned dcl 188 in procedure "dc_find" set ref
                                                                                  280 1503 1516 1664 1905
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 7-8 ref
                                                                                  1571 1571 1571 1576 1577 1578
ringbr                          000216 automatic       fixed bin(3,0)           array dcl 185 set ref 745* 819* 998* 1010 1041* 1072
                                                                                  1452*
ringno                    0(18)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 13-30
                                                                                  set ref 1012*
rings                     3     000221 automatic       structure                level 2 packed packed unaligned dcl 186
rtrim                                                  builtin function         dcl 118 ref 605 932 1593 1611 2546
sdw_info                               based           structure                level 1 dcl 16-6
sdw_util_$construct             000142 constant        entry                    external dcl 96 ref 1583
sdw_util_$dissect               000144 constant        entry                    external dcl 97 ref 1564
sdwi                            000221 automatic       structure                level 1 dcl 186 set ref 1564 1564 1583 1583
security_oosw            32(07)        based           bit(1)                   level 2 packed packed unaligned dcl 7-8 ref 2352
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-11 ref 2601
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 14-36 in procedure "dc_find" ref 1564 1564
                                                                                  1583 1583
segno                                                  builtin function         dcl 119 in procedure "dc_find" ref 591 591 652 652
                                                                                  1602 1602 1627 1627 2020 2020 2062 2062 2397 2397
                                                                                  2447 2447 2579 2579
segno_usage$decrement           000146 constant        entry                    external dcl 98 ref 591 652 1602 2020 2062 2249 2270
                                                                                  2285 2397 2564 2579
segnum                          000711 automatic       fixed bin(17,0)          dcl 2496 in procedure "uid_path_util" set ref 2533*
                                                                                  2537 2564* 2565* 2566
segnum                          000570 automatic       fixed bin(17,0)          dcl 2122 in procedure "find_dir" set ref 2148* 2149
                                                                                  2156 2175 2183 2199* 2201 2249* 2270* 2271* 2272
                                                                                  2273* 2285* 2294*
segptr                          000230 automatic       pointer                  dcl 187 in procedure "dc_find" set ref 745* 819*
                                                                                  991* 998* 1025* 1029* 1041* 1452* 1621* 1627 1627
                                                                                  2407*
segptr                          000672 automatic       pointer                  dcl 2431 in procedure "get_dir_mode" set ref 2444*
                                                                                  2447 2447 2462*
size                                                   builtin function         dcl 120 ref 2133 2133
son_len                1001            based           fixed bin(21,0)          level 2 dcl 2107 set ref 2140* 2193* 2193 2207 2208
                                                                                  2209 2215 2216* 2216 2232 2240* 2240* 2242* 2242*
                                                                                  2244 2245* 2254
son_path                               based           char                     packed unaligned dcl 2103 ref 2208 2215
son_segnum                      000571 automatic       fixed bin(17,0)          dcl 2123 in procedure "find_dir" set ref 2265* 2271
son_segnum                      000712 automatic       fixed bin(17,0)          dcl 2497 in procedure "uid_path_util" set ref 2559*
                                                                                  2565
soos                      1(21)        based           bit(1)                   level 3 packed packed unaligned dcl 5-12 ref 2352
state                           000232 automatic       structure                level 1 dcl 188 set ref 541* 601* 909* 986* 1021*
                                                                                  1306* 1314* 1323* 1373* 1381* 1540* 1590* 1608*
                                                                                  1618*
string                                                 builtin function         dcl 121 in procedure "dc_find" set ref 1571 1580*
string                    1            based           char(2048)               level 2 in structure "work_pathname" dcl 2107
                                                                                  in procedure "find_dir" set ref 2142* 2187 2208
                                                                                  2215 2232 2237 2238 2243* 2246
sub_path_len                    000572 automatic       fixed bin(21,0)          dcl 2124 set ref 2187* 2188 2189 2193 2194
substr                                                 builtin function         dcl 122 set ref 932 1580 2016 2050 2051 2142* 2208
                                                                                  2215 2243* 2243
sum$getbranch                   000150 constant        entry                    external dcl 99 ref 355 469 561 1511 2162 2407
sum$getbranch_root_my           000152 constant        entry                    external dcl 100 ref 230 274 307 426 481 516 630
                                                                                  1029 1093 1833 1881 2462
type                      1            based           bit(18)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 9-6 in procedure "dc_find" ref 2371 2611
type                            000620 automatic       bit(4)                   dcl 2321 in procedure "find_entry" set ref 2326*
                                                                                  2334 2338 2339 2358 2358 2361 2364 2364 2366 2372
                                                                                  2372
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 7-8 in procedure "dc_find" ref 2349 2349 2608
                                                                                  2608
type                      1            based           bit(18)                  level 2 in structure "names" packed packed unaligned
                                                                                  dcl 10-7 in procedure "dc_find" ref 2615
uid                             000201 automatic       bit(36)                  level 2 in structure "my_makeknown_info" dcl 179
                                                                                  in procedure "dc_find" set ref 2264* 2292* 2532*
                                                                                  2557*
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 14-36 in procedure
                                                                                  "dc_find" ref 2450
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 7-8 in procedure
                                                                                  "dc_find" ref 2264 2612 2615
uid                             000727 automatic       bit(36)                  dcl 2592 in procedure "find_uid" set ref 2594* 2612
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 8-11 in procedure
                                                                                  "dc_find" ref 2349 2371 2606 2610
uidpath                         000271 automatic       bit(36)                  array dcl 201 set ref 550* 1332* 1389* 2514 2518
                                                                                  2543* 2557 2569*
unspec                                                 builtin function         dcl 123 set ref 541* 601* 909* 986* 1021* 1306*
                                                                                  1314* 1323* 1373* 1381* 1540* 1590* 1608* 1618*
                                                                                  2144* 2527*
update_kste_access              000154 constant        entry                    external dcl 101 ref 1555 2453 2470
user                     14     000232 automatic       structure                level 2 dcl 188 set ref 264* 1495* 1664 1664
user_id                  16     000232 automatic       char(32)                 level 3 dcl 188 set ref 280* 1503* 1516* 1905*
wired_utility_$grow_stack_frame 000156 constant        entry                    external dcl 102 ref 2133
work_pathname                          based           structure                level 1 dcl 2107 set ref 2133 2133
work_pathname_ptr        10     000232 automatic       pointer                  level 2 dcl 188 set ref 2133* 2133 2133 2140 2141
                                                                                  2142 2142 2148 2148 2173 2187 2187 2187 2189 2193
                                                                                  2193 2193 2194 2198 2199 2199 2207 2208 2208 2208
                                                                                  2209 2215 2215 2215 2216 2216 2217 2217 2232 2232
                                                                                  2237 2237 2238 2240 2240 2240 2242 2242 2243 2244
                                                                                  2244 2245 2246 2246 2254 2273 2273
write                     2(02) 000221 automatic       bit(1)                   level 3 packed packed unaligned dcl 186 set ref
                                                                                  1581*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 12-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 12-4
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 6-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 6-13
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-33
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 12-5
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 11-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 11-36
FS_OBJ_AUDIT_FLAG_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 11-67
FS_OBJ_AUTHOR_MOD                      internal static fixed bin(18,0)          initial unsigned dcl 11-46
FS_OBJ_BACKUP_TIMES_MOD                internal static fixed bin(18,0)          initial unsigned dcl 11-48
FS_OBJ_BC_AUTHOR_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 11-47
FS_OBJ_COPY_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 11-38
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 11-55
FS_OBJ_DAMAGED_SW_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 11-39
FS_OBJ_DATES_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 11-49
FS_OBJ_DNZP_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 11-40
FS_OBJ_DT_DUMPED_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 11-50
FS_OBJ_ENTRY_BOUND_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 11-41
FS_OBJ_FOR_RELOADER_MOD                internal static fixed bin(18,0)          initial unsigned dcl 11-51
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 11-65
FS_OBJ_MAX_LEN_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 11-42
FS_OBJ_MDIR_QUOTA_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 11-57
FS_OBJ_QUOTA_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 11-58
FS_OBJ_QUOTA_RELOAD                    internal static fixed bin(18,0)          initial unsigned dcl 11-59
FS_OBJ_RENAME                          internal static fixed bin(18,0)          initial unsigned dcl 11-37
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 11-35
FS_OBJ_SAFETY_SW_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 11-43
FS_OBJ_SEG_MOVE                        internal static fixed bin(18,0)          initial unsigned dcl 11-62
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 11-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 11-53
FS_OBJ_SYNC_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 11-44
FS_OBJ_TRP_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 11-63
FS_OBJ_VOL_DUMP_SW_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 11-45
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 12-10
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 13-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 13-55
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 4-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 4-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 4-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 4-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
access_name_type                       internal static fixed bin(17,0)          initial dcl 12-12
access_operations_$fs_obj_create       external static bit(36)                  dcl 11-18
acle_type                              internal static fixed bin(17,0)          initial dcl 12-13
audit_user_info_ptr                    automatic       pointer                  dcl 3-11
audit_user_info_version_1              internal static char(8)                  initial packed unaligned dcl 3-23
dc_find$dir_for_append          000000 constant        entry                    external dcl 6-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 6-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 6-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 6-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 6-21
dc_find$dir_read                000000 constant        entry                    external dcl 6-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 6-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 6-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 6-28
dc_find$dir_write               000000 constant        entry                    external dcl 6-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 6-31
dc_find$finished                000000 constant        entry                    external dcl 6-33
dc_find$link_target             000000 constant        entry                    external dcl 6-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 6-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 6-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 6-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 6-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 6-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 6-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 6-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 6-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 6-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 6-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 6-51
dc_find$obj_delete              000000 constant        entry                    external dcl 6-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 6-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 6-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 6-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 6-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 6-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 6-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 6-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 6-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 6-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 6-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 6-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 6-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 6-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 6-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 6-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 6-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 6-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 6-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 6-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 6-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 6-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 6-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 6-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 6-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 6-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 6-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 6-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 6-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 6-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 6-95
dc_find$seg_fault               000000 constant        entry                    external dcl 6-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 12-14
dir_type                               internal static fixed bin(17,0)          initial dcl 12-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 12-19
itp                                    based           structure                level 1 dcl 13-18
itp_unsigned                           based           structure                level 1 dcl 13-43
its                                    based           structure                level 1 dcl 13-5
kst                                    based           structure                level 1 dcl 14-18
kstp                                   automatic       pointer                  dcl 14-15
link_type                              internal static fixed bin(17,0)          initial dcl 12-16
makeknown_infop                        automatic       pointer                  dcl 15-5
name_type                              internal static fixed bin(17,0)          initial dcl 12-17
np                                     automatic       pointer                  dcl 10-5
pds$kstp                               external static pointer                  dcl 14-15
sdw_info_ptr                           automatic       pointer                  dcl 16-4
seg_type                               internal static fixed bin(17,0)          initial dcl 12-18
version_number_2                       internal static fixed bin(17,0)          initial dcl 8-84

NAMES DECLARED BY EXPLICIT CONTEXT.
Find_dir                        010677 constant        label                    dcl 2148 ref 2251
RETURN                          006744 constant        label                    dcl 1635 in procedure "dc_find" ref 228 272 305 349
                                                                                  353 424 463 467 514 555 610 693 794 855 894 921
                                                                                  944 1091 1126 1233 1337 1342 1344 1394 1399 1401
                                                                                  1436 1501 1550 1553 1561 1603
RETURN                          013074 constant        label                    dcl 2582 in procedure "uid_path_util" ref 2516 2524
SEGPTR_FAILURE                  006705 constant        label                    dcl 1625 ref 732 817 996 1030 1281 1450 1465
abort                           012446 constant        label                    dcl 2482 in procedure "get_dir_mode" ref 2448 2464
abort                           013041 constant        label                    dcl 2574 in procedure "uid_path_util" ref 2534 2554
                                                                                  2560 2598 2625
abort                           011516 constant        label                    dcl 2280 in procedure "find_dir" ref 2163 2167 2191
                                                                                  2213 2220 2224 2235 2260 2266 2295
abort                           010565 constant        entry                    internal dcl 2055 in procedure "find_" ref 1933 1936
                                                                                  1948 1962 1965 1982 2003 2009 2012 2038 2043 2047
abort                           012077 constant        label                    dcl 2385 in procedure "find_entry" ref 2333 2343
                                                                                  2356 2379
activate_root                   011546 constant        entry                    internal dcl 2290 ref 2174 2198
attributes_entry                007444 constant        label                    dcl 1718 ref 1710
audit_failure                   007147 constant        entry                    internal dcl 1655 ref 1812 1842 1861
audit_success                   007142 constant        entry                    internal dcl 1651 ref 326 375 441 494 527 573 625
                                                                                  644 764 837 974 1006 1065 1106 1147 1293 1361 1413
                                                                                  1480 1526 1571
audit_success$msg               007131 constant        entry                    internal dcl 1638 ref 244 287
check_audit                     007154 constant        label                    dcl 1658 ref 1649
contents_entry                  007537 constant        label                    dcl 1753 ref 1745
dc_find                         000045 constant        entry                    external dcl 43
dir_control_error               007377 constant        entry                    internal dcl 1671
dir_control_error$append        007401 constant        entry                    internal dcl 1689 ref 240 283
dir_control_error$attributes    007441 constant        entry                    internal dcl 1712 ref 321 620 757 1002 1060 1102
                                                                                  1136 1142 1288 1355 1408 2165 2259 2553
dir_control_error$attributes_info
                                007434 constant        entry                    internal dcl 1708 ref 2354
dir_control_error$contents      007534 constant        entry                    internal dcl 1747 ref 364 371 436 477 490 569 833
                                                                                  970 1474 1521 1560
dir_control_error$contents_info 007527 constant        entry                    internal dcl 1743 ref 967 1473
dir_control_error$name_existant 007626 constant        entry                    internal dcl 1780 ref 2378
dir_control_error$name_non_existant
                                007717 constant        entry                    internal dcl 1815 ref 640 1549 1631 2342
dir_control_error$status        010015 constant        entry                    internal dcl 1847 ref 1139
dir_for_append                  000061 constant        entry                    external dcl 203
dir_for_append_join             000127 constant        label                    dcl 216 set ref 210
dir_for_append_raw              000105 constant        entry                    external dcl 212
dir_for_retrieve_append         000274 constant        entry                    external dcl 253
dir_initiate                    000472 constant        entry                    external dcl 296
dir_join                        001161 constant        label                    dcl 422 ref 393 402 411
dir_move_quota                  000622 constant        entry                    external dcl 334
dir_name_setup                  006747 constant        entry                    internal dcl 1588 ref 216 259 300 339 391 399 408
                                                                                  417 454 507
dir_read                        001015 constant        entry                    external dcl 382
dir_read_priv                   001101 constant        entry                    external dcl 404
dir_reclassify                  001261 constant        entry                    external dcl 449
dir_salvage                     001507 constant        entry                    external dcl 502
dir_write                       001046 constant        entry                    external dcl 395
dir_write_priv                  001130 constant        entry                    external dcl 413
fatal_error                     007001 constant        entry                    internal dcl 1597 ref 233 238 241 277 281 284 310
                                                                                  314 318 322 356 361 365 369 372 429 434 437 470
                                                                                  475 478 484 488 491 519 525 558 562 567 570 614
                                                                                  617 621 633 637 641 736 746 758 797 820 834 925
                                                                                  928 941 953 971 999 1003 1042 1057 1061 1096 1100
                                                                                  1103 1129 1133 1137 1143 1286 1289 1349 1353 1356
                                                                                  1406 1409 1439 1453 1468 1477 1504 1512 1519 1522
find_                           010206 constant        entry                    internal dcl 1911 ref 692 793 854 892 1090 1125 1232
                                                                                  1435 1500
find_$append                    010265 constant        entry                    internal dcl 1952 ref 227 271
find_$link_target               010343 constant        entry                    internal dcl 1986 ref 609 937
find_chasing_link               010410 constant        entry                    internal dcl 2006 ref 1941 1944 1975 1978 1996 1999
find_dir                        010622 constant        entry                    internal dcl 2072 ref 513 2391
find_dir_return                 011514 constant        label                    dcl 2276 ref 2170 2177
find_entry                      011601 constant        entry                    internal dcl 2301 ref 924 1935 1964 2011 2223
find_locked_dir                 012103 constant        entry                    internal dcl 2389 ref 304 352 422 466 1932 1961 2008
find_segptr_branch              012162 constant        entry                    internal dcl 2405 ref 728 816 995 1279 1449 1464
find_uid                        013075 constant        entry                    internal dcl 2584 ref 2543 2569
finished                        002043 constant        entry                    external dcl 581
get_dir_mode                    012210 constant        entry                    internal dcl 2414 ref 317 360 613 734 1056 1128 1285
                                                                                  1348 1405 1894
get_dir_mode$locked             012215 constant        entry                    internal dcl 2436 ref 237 313 433 636
get_mode_on_dir                 010050 constant        entry                    internal dcl 1869 ref 1726 1773 1798
get_mode_on_entry               010132 constant        entry                    internal dcl 1898 ref 1701 1730 1762 1802 1838 1890
initiate_join                   003637 constant        label                    dcl 951 ref 899
initiate_name_join              003430 constant        label                    dcl 888 ref 877
join                            012220 constant        label                    dcl 2443 in procedure "get_dir_mode" ref 2434
join                            012462 constant        label                    dcl 2506 in procedure "uid_path_util" ref 2501
link_target                     002122 constant        entry                    external dcl 595
mdir_set_quota_uid              001642 constant        entry                    external dcl 536
non_local_return                010407 constant        label                    dcl 2068 ref 2065
not_found                       013312 constant        label                    dcl 2624 ref 2612
obj_access_write                004637 constant        entry                    external dcl 1175
obj_access_write_priv           004674 constant        entry                    external dcl 1184
obj_attribute_success           003007 constant        label                    dcl 764 ref 730
obj_attributes_check_target     002705 constant        label                    dcl 741 ref 737
obj_attributes_error            003004 constant        label                    dcl 757 ref 741 748 751
obj_attributes_join             002671 constant        label                    dcl 734 ref 694
obj_attributes_name_join        002521 constant        label                    dcl 689 ref 671 680
obj_attributes_ptr_join         002657 constant        label                    dcl 728 ref 702 710 718
obj_attributes_read             002404 constant        entry                    external dcl 659
obj_attributes_read_ptr         002602 constant        entry                    external dcl 712
obj_attributes_write            002440 constant        entry                    external dcl 673
obj_attributes_write_ptr        002631 constant        entry                    external dcl 720
obj_bc_delta_write              003023 constant        entry                    external dcl 771
obj_bc_delta_write_ptr          003134 constant        entry                    external dcl 800
obj_bc_join                     003227 constant        label                    dcl 822 ref 798
obj_bc_name_join                003071 constant        label                    dcl 786 ref 780
obj_bc_ptr_join                 003172 constant        label                    dcl 809 ref 803
obj_bc_write                    003050 constant        entry                    external dcl 782
obj_bc_write_ptr                003155 constant        entry                    external dcl 805
obj_delete                      004732 constant        entry                    external dcl 1194
obj_delete_priv                 005020 constant        entry                    external dcl 1211
obj_delete_priv_uid             005626 constant        entry                    external dcl 1377
obj_delete_ptr                  005167 constant        entry                    external dcl 1253
obj_delete_uid                  005573 constant        entry                    external dcl 1369
obj_delete_uid_join             005657 constant        label                    dcl 1386 ref 1375
obj_existence_ptr               002534 constant        entry                    external dcl 696
obj_for_audit                   003307 constant        entry                    external dcl 843
obj_initiate                    003345 constant        entry                    external dcl 861
obj_initiate_error              003675 constant        label                    dcl 964 ref 957 960
obj_initiate_for_linker_dp      003454 constant        entry                    external dcl 901
obj_initiate_raw                003376 constant        entry                    external dcl 879
obj_linkage_ring_ptr            003740 constant        entry                    external dcl 980
obj_modes_ptr                   004064 constant        entry                    external dcl 1016
obj_name_setup                  007056 constant        entry                    internal dcl 1606 ref 669 677 686 786 850 873 881
                                                                                  1081 1118 1162 1170 1179 1188 1198 1206 1215 1224
                                                                                  1428 1490
obj_ptr_setup                   007114 constant        entry                    internal dcl 1616 ref 700 708 716 724 812 1240 1248
                                                                                  1257 1265 1274 1444 1458
obj_reclassify                  004275 constant        entry                    external dcl 1076
obj_status_attributes_read      004433 constant        entry                    external dcl 1113
obj_status_join                 005277 constant        label                    dcl 1283 ref 1234
obj_status_name_join            005105 constant        label                    dcl 1229 ref 1164 1173 1182 1192 1200 1209 1218
obj_status_ptr_join             005274 constant        label                    dcl 1279 ref 1242 1251 1259 1268
obj_status_read                 004556 constant        entry                    external dcl 1153
obj_status_read_priv            004606 constant        entry                    external dcl 1166
obj_status_read_priv_ptr        005142 constant        entry                    external dcl 1244
obj_status_read_priv_uid        005363 constant        entry                    external dcl 1310
obj_status_read_ptr             005116 constant        entry                    external dcl 1236
obj_status_read_raw_uid         005416 constant        entry                    external dcl 1319
obj_status_read_uid             005331 constant        entry                    external dcl 1299
obj_status_uid_join             005450 constant        label                    dcl 1329 ref 1308 1317
obj_status_write                004763 constant        entry                    external dcl 1202
obj_status_write_priv           005052 constant        entry                    external dcl 1220
obj_status_write_priv_ptr       005245 constant        entry                    external dcl 1270
obj_status_write_ptr            005214 constant        entry                    external dcl 1261
obj_terminate                   002475 constant        entry                    external dcl 682
obj_terminate_ptr               002557 constant        entry                    external dcl 704
obj_truncate                    005760 constant        entry                    external dcl 1421
obj_truncate_join               006157 constant        label                    dcl 1470 ref 1440 1454
obj_truncate_ptr                006036 constant        entry                    external dcl 1442
obj_truncate_raw_ptr            006110 constant        entry                    external dcl 1456
obj_volume_retrieve             006222 constant        entry                    external dcl 1486
return_error_code               010040 constant        label                    dcl 1861 ref 1706 1741 1778 1859
return_error_code_no_audit      010044 constant        label                    dcl 1865 ref 1731 1763 1803 1813 1835 1845 1882 1892
seg_fault                       006442 constant        entry                    external dcl 1532
setup                           010476 constant        entry                    internal dcl 2026 ref 1929 1958 1993
split_pathname                  010505 constant        entry                    internal dcl 2031 ref 1943 1977 1998 2027
uid_path_util                   012452 constant        entry                    internal dcl 2486
uid_path_util$find_dir          012460 constant        entry                    internal dcl 2503 ref 553
uid_path_util$find_entry        012454 constant        entry                    internal dcl 2499 ref 1334 1391

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15376       15600   13600       15406
Length     16752   13600       202        1135    1575           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dc_find                             772 external procedure  is an external procedure.  
dir_name_setup                          internal procedure  shares stack frame of external procedure dc_find.  
fatal_error                             internal procedure  shares stack frame of external procedure dc_find.  
obj_name_setup                          internal procedure  shares stack frame of external procedure dc_find.  
obj_ptr_setup                           internal procedure  shares stack frame of external procedure dc_find.  
audit_success$msg                       internal procedure  shares stack frame of external procedure dc_find.  
dir_control_error                       internal procedure  shares stack frame of external procedure dc_find.  
get_mode_on_dir                         internal procedure  shares stack frame of external procedure dc_find.  
get_mode_on_entry                       internal procedure  shares stack frame of external procedure dc_find.  
find_                                   internal procedure  shares stack frame of external procedure dc_find.  
find_chasing_link                       internal procedure  shares stack frame of external procedure dc_find.  
setup                                   internal procedure  shares stack frame of external procedure dc_find.  
split_pathname                          internal procedure  shares stack frame of external procedure dc_find.  
abort                                   internal procedure  shares stack frame of external procedure dc_find.  
find_dir                                internal procedure  shares stack frame of external procedure dc_find.  
activate_root                           internal procedure  shares stack frame of external procedure dc_find.  
find_entry                              internal procedure  shares stack frame of external procedure dc_find.  
find_locked_dir                         internal procedure  shares stack frame of external procedure dc_find.  
find_segptr_branch                      internal procedure  shares stack frame of external procedure dc_find.  
get_dir_mode                            internal procedure  shares stack frame of external procedure dc_find.  
uid_path_util                           internal procedure  shares stack frame of external procedure dc_find.  
find_uid                                internal procedure  shares stack frame of external procedure dc_find.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dc_find                  000100 access_checker              dc_find
                         000104 change_bc                   dc_find
                         000105 chase_sw                    dc_find
                         000106 code                        dc_find
                         000107 dir_uid                     dc_find
                         000110 dirmode                     dc_find
                         000111 dirmode_raw                 dc_find
                         000112 dirname                     dc_find
                         000165 entryname                   dc_find
                         000175 exmode                      dc_find
                         000176 linkage_ring                dc_find
                         000177 lock_for_writing            dc_find
                         000200 mode                        dc_find
                         000201 my_makeknown_info           dc_find
                         000204 objmode                     dc_find
                         000206 pdp                         dc_find
                         000210 pep                         dc_find
                         000212 ppdp                        dc_find
                         000214 ppep                        dc_find
                         000216 ringbr                      dc_find
                         000221 sdwi                        dc_find
                         000230 segptr                      dc_find
                         000232 state                       dc_find
                         000271 uidpath                     dc_find
                         000312 ep                          dc_find
                         000314 dp                          dc_find
                         000316 kstep                       dc_find
                         000402 audit                       audit_success$msg
                         000404 ep                          audit_success$msg
                         000406 message                     audit_success$msg
                         000424 code                        dir_control_error
                         000426 dp                          dir_control_error
                         000430 ep                          dir_control_error
                         000432 exmode                      dir_control_error
                         000433 info_only                   dir_control_error
                         000434 locked                      dir_control_error
                         000435 mode                        dir_control_error
                         000436 original_code               dir_control_error
                         000440 pep                         dir_control_error
                         000450 dp                          get_mode_on_dir
                         000452 locked                      get_mode_on_dir
                         000454 pdp                         get_mode_on_dir
                         000456 pep                         get_mode_on_dir
                         000466 ep                          get_mode_on_entry
                         000476 find_type                   find_
                         000477 links                       find_
                         000526 ename_len                   split_pathname
                         000527 path_len                    split_pathname
                         000544 authorization               find_dir
                         000546 entry                       find_dir
                         000556 entry_len                   find_dir
                         000560 ep                          find_dir
                         000562 new_son_ptr                 find_dir
                         000564 numlinks                    find_dir
                         000566 old_son_ptr                 find_dir
                         000570 segnum                      find_dir
                         000571 son_segnum                  find_dir
                         000572 sub_path_len                find_dir
                         000610 authorization               find_entry
                         000612 code                        find_entry
                         000614 dp                          find_entry
                         000616 ep                          find_entry
                         000620 type                        find_entry
                         000652 code                        get_dir_mode
                         000654 dp                          get_dir_mode
                         000656 ep                          get_dir_mode
                         000660 kstep                       get_dir_mode
                         000662 lock_sw                     get_dir_mode
                         000663 mode                        get_dir_mode
                         000664 need_to_lock                get_dir_mode
                         000665 rb                          get_dir_mode
                         000670 ring                        get_dir_mode
                         000672 segptr                      get_dir_mode
                         000704 authorization               uid_path_util
                         000706 current_depth               uid_path_util
                         000707 entrysw                     uid_path_util
                         000710 max_depth                   uid_path_util
                         000711 segnum                      uid_path_util
                         000712 son_segnum                  uid_path_util
                         000722 ecount                      find_uid
                         000724 nnp                         find_uid
                         000726 num_entries_in_dir          find_uid
                         000727 uid                         find_uid

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ent_var        call_ext_out_desc   call_ext_out        return_mac          signal_op
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_$log_entry_ptr   access_audit_$log_entry_ptr_user                            access_audit_check_ep_$self
access_audit_check_ep_$user   access_mode$effective         access_mode$raw               access_mode$user_effmode
aim_check_$greater_or_equal   fs_modes$locked               get_kstep                     hash$search
level$get                     lock$dir_lock_read            lock$dir_lock_salvage         lock$dir_lock_write
lock$dir_unlock               makeknown_                    mlr_                          mrl_
pathname_am$get_segno         pathname_am$set               read_allowed_                 sdw_util_$construct
sdw_util_$dissect             segno_usage$decrement         sum$getbranch                 sum$getbranch_root_my
update_kste_access            wired_utility_$grow_stack_frame

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$fs_obj_access_mod                        access_operations_$fs_obj_attr_mod
access_operations_$fs_obj_contents_mod                      access_operations_$fs_obj_contents_read
access_operations_$fs_obj_delete                            access_operations_$fs_obj_initiate
access_operations_$fs_obj_prop_read                         access_operations_$fs_obj_status_mod
access_operations_$fs_obj_terminate                         active_all_rings_data$maxlinks
dseg$                         error_table_$bad_uidpath      error_table_$badpath          error_table_$dirseg
error_table_$entlong          error_table_$incorrect_access error_table_$link             error_table_$moderr
error_table_$mylock           error_table_$namedup          error_table_$no_dir           error_table_$no_info
error_table_$no_s_permission  error_table_$noentry          error_table_$not_link         error_table_$notadir
error_table_$oosw             error_table_$root             error_table_$seg_deleted      error_table_$segknown
error_table_$toomanylinks     pds$access_authorization




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000044        44 000052       203 000053       209 000101       210 000102       212 000103       214 000125
    216 000127       218 000130       219 000132       220 000135       222 000137       223 000143       224 000145
    225 000150       227 000153       228 000154       230 000156       231 000173       232 000200       233 000205
    234 000206       236 000210       237 000230       238 000232       239 000235       240 000241       241 000243
    244 000244       246 000246       247 000253       248 000257       249 000261       250 000263       251 000265
    253 000266       259 000316       260 000317       261 000322       263 000324       264 000326       266 000333
    267 000336       268 000342       269 000344       271 000347       272 000350       274 000352       275 000367
    276 000374       277 000401       278 000402       280 000404       281 000432       282 000435       283 000441
    284 000443       287 000444       289 000446       290 000453       291 000457       292 000461       293 000463
    294 000465       296 000466       300 000506       301 000507       302 000512       304 000513       305 000514
    307 000516       308 000533       309 000540       310 000545       311 000546       313 000550       314 000552
    315 000555       316 000557       317 000563       318 000565       320 000570       321 000572       322 000574
    326 000575       328 000577       330 000610       331 000612       332 000614       334 000615       339 000640
    340 000641       341 000644       343 000646       344 000651       345 000653       347 000655       348 000662
    349 000664       352 000665       353 000666       355 000670       356 000705       357 000710       358 000712
    360 000714       361 000716       362 000721       364 000750       365 000752       368 000753       369 000770
    370 000773       371 000777       372 001001       375 001002       377 001004       378 001006       379 001010
    380 001012       382 001013       389 001031       390 001032       391 001034       392 001035       393 001040
    395 001041       397 001064       398 001066       399 001070       400 001071       401 001074       402 001076
    404 001077       406 001115       407 001116       408 001117       409 001120       410 001123       411 001125
    413 001126       415 001146       416 001150       417 001151       418 001152       419 001155       420 001157
    422 001161       424 001162       426 001164       427 001201       428 001206       429 001213       430 001214
    432 001216       433 001220       434 001222       435 001225       436 001231       437 001233       441 001234
    443 001236       445 001247       446 001251       447 001253       449 001254       454 001277       455 001300
    456 001303       457 001305       458 001307       459 001315       461 001317       462 001324       463 001326
    466 001327       467 001330       469 001332       470 001347       471 001352       472 001354       474 001356
    475 001373       476 001376       477 001402       478 001404       481 001405       482 001422       483 001427
    484 001434       485 001435       487 001437       488 001454       489 001457       490 001463       491 001465
    494 001466       496 001470       497 001473       498 001475       499 001477       500 001501       502 001502
    507 001523       508 001524       509 001527       510 001531       511 001533       513 001535       514 001536
    516 001540       517 001555       518 001562       519 001567       520 001570       522 001572       524 001573
    525 001606       527 001611       529 001613       531 001624       532 001627       533 001631       534 001633
    536 001634       541 001662       542 001665       543 001670       544 001672       545 001674       547 001676
    548 001700       549 001707       550 001710       551 001715       553 001716       554 001717       555 001730
    557 001732       558 001742       559 001745       561 001747       562 001764       563 001767       564 001771
    566 001773       567 002010       568 002013       569 002017       570 002021       573 002022       575 002024
    576 002031       577 002033       578 002035       579 002036       581 002037       588 002053       589 002056
    590 002062       591 002077       593 002115       595 002116       601 002136       602 002141       604 002144
    605 002145       606 002166       607 002172       609 002173       610 002174       612 002176       613 002202
    614 002204       615 002207       616 002211       617 002226       618 002231       619 002237       620 002241
    621 002243       625 002244       626 002246       628 002247       630 002252       631 002266       632 002273
    633 002300       634 002301       636 002303       637 002305       638 002310       639 002312       640 002315
    641 002317       644 002320       646 002322       648 002333       651 002336       652 002345       654 002363
    655 002370       656 002374       657 002376       659 002377       667 002422       668 002423       669 002425
    670 002426       671 002431       673 002432       675 002460       676 002462       677 002464       678 002465
    679 002470       680 002472       682 002473       684 002513       685 002514       686 002515       687 002516
    689 002521       692 002524       693 002525       694 002527       696 002530       698 002546       699 002547
    700 002550       701 002551       702 002554       704 002555       706 002571       707 002572       708 002573
    709 002574       710 002577       712 002600       714 002614       715 002615       716 002617       717 002620
    718 002623       720 002624       722 002645       723 002647       724 002651       725 002652       726 002655
    728 002657       730 002660       732 002670       734 002671       736 002673       737 002676       739 002704
    741 002705       743 002711       745 002731       746 002750       747 002753       748 002756       750 002766
    751 002767       753 002773       755 002774       756 003002       757 003004       758 003006       764 003007
    767 003011       768 003013       769 003015       771 003016       779 003043       780 003045       782 003046
    784 003070       786 003071       788 003072       789 003075       790 003077       791 003101       793 003103
    794 003104       796 003106       797 003123       798 003126       800 003127       802 003150       803 003152
    805 003153       807 003171       809 003172       812 003174       813 003175       814 003200       816 003202
    817 003203       819 003205       820 003224       822 003227       824 003233       825 003235       827 003244
    828 003247       829 003257       830 003261       831 003262       832 003264       833 003270       834 003272
    837 003273       839 003275       840 003277       841 003301       843 003302       849 003325       850 003326
    851 003327       852 003332       854 003334       855 003335       857 003337       858 003341       859 003342
    861 003343       873 003363       874 003364       876 003367       877 003373       879 003374       881 003414
    882 003415       883 003420       885 003422       886 003424       888 003430       890 003431       892 003433
    893 003434       894 003437       895 003442       896 003445       899 003446       901 003447       909 003472
    910 003475       912 003500       914 003504       915 003505       916 003510       917 003513       918 003517
    920 003520       921 003530       922 003532       924 003534       925 003536       926 003541       927 003545
    928 003550       931 003551       932 003555       933 003577       934 003602       935 003611       936 003612
    937 003614       938 003615       939 003617       940 003623       941 003626       943 003627       944 003630
    945 003633       946 003636       951 003637       953 003653       957 003656       959 003664       960 003665
    963 003673       964 003675       966 003705       967 003711       968 003713       969 003721       970 003722
    971 003724       974 003725       976 003727       977 003731       978 003733       980 003734       986 003750
    987 003753       989 003756       990 003760       991 003761       993 003765       995 003766       996 003767
    998 003771       999 004010      1001 004013      1002 004017      1003 004021      1006 004022      1008 004024
   1010 004033      1012 004047      1013 004054      1014 004056      1016 004057      1021 004074      1022 004077
   1023 004102      1024 004104      1025 004105      1027 004111      1029 004112      1030 004126      1032 004133
   1033 004134      1034 004136      1037 004137      1038 004141      1041 004143      1042 004162      1044 004165
   1045 004171      1046 004173      1047 004174      1048 004175      1049 004201      1050 004203      1053 004204
   1054 004206      1056 004214      1057 004216      1059 004221      1060 004225      1061 004227      1065 004230
   1067 004232      1068 004241      1070 004252      1071 004255      1072 004257      1073 004265      1074 004267
   1076 004270      1081 004315      1082 004316      1083 004321      1084 004323      1086 004325      1087 004327
   1088 004332      1090 004334      1091 004335      1093 004337      1094 004354      1095 004361      1096 004366
   1097 004367      1099 004371      1100 004406      1101 004411      1102 004415      1103 004417      1106 004420
   1108 004422      1109 004424      1110 004426      1111 004430      1113 004431      1118 004451      1119 004452
   1121 004455      1122 004456      1123 004460      1125 004463      1126 004464      1128 004466      1129 004470
   1130 004473      1131 004477      1132 004503      1133 004520      1134 004523      1135 004531      1136 004533
   1137 004535      1138 004536      1139 004537      1140 004541      1142 004542      1143 004544      1147 004545
   1149 004547      1150 004551      1151 004553      1153 004554      1160 004574      1161 004575      1162 004577
   1163 004600      1164 004603      1166 004604      1168 004624      1169 004625      1170 004626      1171 004627
   1172 004632      1173 004634      1175 004635      1177 004657      1178 004661      1179 004663      1180 004664
   1181 004667      1182 004671      1184 004672      1186 004714      1187 004716      1188 004717      1189 004720
   1190 004723      1191 004725      1192 004727      1194 004730      1196 004750      1197 004752      1198 004754
   1199 004755      1200 004760      1202 004761      1204 005003      1205 005005      1206 005007      1207 005010
   1208 005013      1209 005015      1211 005016      1213 005036      1214 005040      1215 005041      1216 005042
   1217 005045      1218 005047      1220 005050      1222 005072      1223 005074      1224 005075      1225 005076
   1226 005101      1227 005103      1229 005105      1232 005110      1233 005111      1234 005113      1236 005114
   1238 005130      1239 005131      1240 005133      1241 005134      1242 005137      1244 005140      1246 005154
   1247 005155      1248 005156      1249 005157      1250 005162      1251 005164      1253 005165      1255 005201
   1256 005203      1257 005205      1258 005206      1259 005211      1261 005212      1263 005230      1264 005232
   1265 005234      1266 005235      1267 005240      1268 005242      1270 005243      1272 005261      1273 005263
   1274 005264      1275 005265      1276 005270      1277 005272      1279 005274      1281 005275      1283 005277
   1285 005301      1286 005303      1287 005306      1288 005312      1289 005314      1293 005315      1295 005317
   1296 005321      1297 005323      1299 005324      1304 005347      1305 005350      1306 005352      1307 005355
   1308 005360      1310 005361      1312 005401      1313 005402      1314 005403      1315 005406      1316 005411
   1317 005413      1319 005414      1321 005434      1322 005435      1323 005436      1324 005441      1325 005444
   1326 005446      1329 005450      1331 005453      1332 005454      1334 005461      1335 005462      1336 005466
   1337 005473      1339 005474      1340 005476      1342 005506      1344 005507      1346 005511      1348 005513
   1349 005515      1350 005520      1352 005524      1353 005541      1354 005544      1355 005546      1356 005550
   1361 005551      1363 005553      1364 005560      1365 005564      1366 005566      1367 005570      1369 005571
   1371 005611      1372 005613      1373 005615      1374 005620      1375 005623      1377 005624      1379 005644
   1380 005646      1381 005647      1382 005652      1383 005655      1386 005657      1388 005662      1389 005663
   1391 005670      1392 005671      1393 005675      1394 005702      1396 005703      1397 005705      1399 005715
   1401 005716      1403 005720      1405 005722      1406 005724      1407 005727      1408 005733      1409 005735
   1413 005736      1415 005740      1416 005745      1417 005751      1418 005753      1419 005755      1421 005756
   1428 005776      1429 005777      1430 006002      1432 006004      1433 006006      1435 006010      1436 006011
   1438 006013      1439 006030      1440 006033      1442 006034      1444 006050      1445 006051      1446 006054
   1448 006056      1449 006060      1450 006061      1452 006063      1453 006102      1454 006105      1456 006106
   1458 006122      1459 006123      1460 006126      1461 006130      1463 006132      1464 006134      1465 006135
   1467 006137      1468 006154      1470 006157      1472 006161      1473 006165      1474 006174      1475 006176
   1477 006210      1480 006211      1482 006213      1483 006215      1484 006217      1486 006220      1490 006242
   1491 006243      1492 006246      1494 006250      1495 006252      1497 006257      1498 006260      1500 006262
   1501 006263      1503 006265      1504 006313      1505 006316      1506 006322      1507 006324      1508 006326
   1509 006327      1510 006331      1511 006335      1512 006352      1513 006355      1514 006357      1516 006361
   1517 006407      1518 006416      1519 006417      1520 006422      1521 006426      1522 006430      1526 006431
   1528 006433      1529 006435      1530 006437      1532 006440      1540 006454      1541 006457      1543 006462
   1544 006463      1545 006467      1547 006472      1548 006476      1549 006500      1550 006506      1553 006507
   1555 006512      1557 006530      1559 006534      1560 006536      1561 006540      1564 006541      1566 006562
   1567 006565      1568 006570      1571 006572      1576 006632      1577 006637      1578 006643      1580 006647
   1581 006653      1583 006661      1585 006702      1586 006704      1625 006705      1627 006710      1628 006726
   1629 006730      1630 006733      1631 006735      1635 006744      1636 006746      1588 006747      1590 006750
   1591 006753      1592 006756      1593 006757      1594 007000      1597 007001      1599 007002      1600 007013
   1601 007024      1602 007035      1603 007055      1606 007056      1608 007057      1609 007062      1610 007065
   1611 007066      1612 007107      1613 007113      1616 007114      1618 007115      1619 007120      1620 007123
   1621 007124      1622 007130      1638 007131      1647 007133      1648 007135      1649 007141      1651 007142
   1653 007144      1655 007146      1657 007151      1658 007154      1660 007160      1662 007207      1664 007227
   1667 007315      1668 007376      1671 007377      1689 007400      1696 007403      1698 007404      1699 007410
   1701 007420      1702 007422      1704 007430      1706 007433      1708 007434      1709 007436      1710 007440
   1712 007441      1713 007443      1718 007444      1720 007450      1725 007460      1726 007462      1727 007464
   1729 007472      1730 007477      1731 007501      1733 007503      1735 007511      1736 007517      1737 007522
   1738 007523      1741 007526      1743 007527      1744 007531      1745 007533      1747 007534      1748 007536
   1753 007537      1755 007543      1756 007551      1757 007561      1762 007570      1763 007572      1765 007574
   1767 007602      1772 007610      1773 007612      1774 007614      1775 007622      1778 007625      1780 007626
   1792 007630      1793 007633      1794 007634      1795 007637      1796 007641      1798 007650      1799 007652
   1801 007657      1802 007663      1803 007665      1805 007667      1806 007675      1807 007702      1808 007705
   1809 007706      1812 007711      1813 007716      1815 007717      1827 007721      1828 007724      1829 007725
   1831 007730      1832 007731      1833 007733      1834 007750      1835 007755      1838 007762      1839 007764
   1840 007771      1842 007774      1844 010001      1845 010014      1847 010015      1855 010017      1856 010020
   1857 010024      1858 010034      1859 010037      1861 010040      1865 010044      1867 010047      1869 010050
   1878 010052      1879 010055      1880 010057      1881 010061      1882 010076      1884 010105      1885 010106
   1889 010107      1890 010111      1891 010113      1892 010124      1893 010126      1894 010127      1895 010131
   1898 010132      1904 010134      1905 010137      1906 010170      1907 010205      1911 010206      1927 010207
   1928 010210      1929 010213      1931 010214      1932 010216      1933 010217      1935 010222      1936 010224
   1937 010227      1940 010230      1941 010232      1942 010233      1943 010247      1944 010250      1945 010251
   1947 010253      1948 010261      1949 010264      1952 010265      1956 010266      1957 010267      1958 010271
   1960 010272      1961 010274      1962 010275      1964 010300      1965 010302      1966 010305      1974 010306
   1975 010310      1976 010311      1977 010325      1978 010326      1979 010327      1981 010331      1982 010337
   1983 010342      1986 010343      1991 010344      1992 010345      1993 010350      1995 010351      1996 010353
   1997 010354      1998 010371      1999 010372      2000 010373      2002 010375      2003 010403      2004 010406
   2068 010407      2006 010410      2008 010411      2009 010412      2011 010415      2012 010417      2014 010422
   2016 010432      2017 010444      2018 010447      2019 010455      2020 010456      2021 010474      2023 010475
   2026 010476      2027 010477      2028 010504      2031 010505      2036 010506      2037 010513      2038 010516
   2040 010517      2041 010530      2042 010532      2043 010535      2045 010536      2046 010541      2047 010544
   2049 010545      2050 010551      2051 010555      2052 010564      2055 010565      2057 010566      2058 010570
   2059 010577      2061 010600      2062 010602      2063 010620      2065 010621      2072 010622      2126 010623
   2132 010624      2133 010626      2134 010641      2137 010643      2138 010650      2140 010655      2141 010657
   2142 010661      2144 010665      2145 010670      2146 010676      2148 010677      2149 010720      2156 010723
   2157 010726      2158 010730      2161 010756      2162 010761      2163 010775      2164 010777      2165 011001
   2166 011003      2167 011012      2170 011013      2173 011014      2174 011022      2175 011023      2176 011027
   2177 011031      2183 011032      2187 011034      2188 011052      2189 011054      2190 011060      2191 011063
   2193 011064      2194 011067      2198 011071      2199 011074      2200 011113      2201 011114      2202 011117
   2207 011121      2208 011125      2209 011143      2210 011151      2211 011153      2212 011156      2213 011161
   2215 011162      2216 011165      2217 011171      2219 011173      2220 011204      2221 011206      2223 011210
   2224 011212      2226 011214      2231 011220      2232 011221      2234 011235      2235 011240      2237 011241
   2238 011245      2239 011247      2240 011252      2242 011271      2243 011305      2244 011315      2245 011317
   2246 011320      2247 011330      2248 011337      2249 011340      2250 011352      2251 011353      2254 011354
   2258 011404      2259 011407      2260 011411      2263 011412      2264 011414      2265 011416      2266 011436
   2268 011443      2269 011452      2270 011453      2271 011465      2272 011467      2273 011472      2274 011513
   2276 011514      2278 011515      2280 011516      2281 011520      2282 011527      2284 011530      2285 011532
   2286 011544      2288 011545      2290 011546      2292 011547      2293 011551      2294 011553      2295 011573
   2297 011600      2301 011601      2323 011603      2324 011604      2325 011606      2326 011611      2328 011614
   2329 011621      2331 011626      2332 011645      2333 011647      2334 011652      2335 011655      2336 011656
   2338 011657      2339 011664      2340 011671      2341 011673      2342 011675      2343 011677      2348 011700
   2349 011704      2352 011732      2353 011741      2354 011744      2355 011746      2356 011754      2358 011755
   2361 011771      2362 011777      2363 012002      2364 012003      2366 012014      2367 012022      2369 012025
   2371 012026      2372 012047      2374 012060      2376 012063      2377 012065      2378 012070      2379 012072
   2382 012073      2383 012076      2385 012077      2386 012102      2389 012103      2391 012104      2392 012105
   2394 012110      2395 012124      2396 012135      2397 012137      2398 012155      2399 012156      2401 012157
   2402 012161      2405 012162      2407 012163      2408 012200      2409 012203      2410 012205      2411 012207
   2414 012210      2433 012212      2434 012214      2436 012215      2441 012217      2443 012220      2444 012222
   2446 012225      2447 012226      2448 012245      2450 012247      2451 012253      2452 012254      2453 012257
   2454 012275      2455 012301      2456 012305      2458 012306      2461 012307      2462 012311      2463 012326
   2464 012333      2466 012337      2467 012340      2469 012342      2470 012344      2471 012364      2472 012370
   2473 012410      2474 012421      2475 012424      2476 012431      2479 012432      2480 012443      2482 012446
   2483 012451      2486 012452      2499 012453      2500 012455      2501 012457      2503 012460      2504 012461
   2506 012462      2507 012465      2508 012466      2509 012471      2511 012472      2512 012477      2514 012504
   2515 012507      2516 012512      2518 012513      2519 012523      2520 012525      2521 012527      2522 012531
   2523 012534      2524 012540      2527 012541      2528 012544      2531 012554      2532 012556      2533 012560
   2534 012600      2536 012605      2537 012607      2539 012613      2540 012617      2541 012626      2542 012627
   2543 012637      2545 012647      2546 012656      2548 012702      2552 012733      2553 012736      2554 012740
   2557 012741      2558 012744      2559 012746      2560 012766      2562 012773      2563 013002      2564 013003
   2565 013015      2566 013017      2567 013022      2569 013024      2571 013037      2572 013040      2574 013041
   2575 013043      2576 013052      2578 013053      2579 013055      2580 013073      2582 013074      2584 013075
   2594 013077      2596 013101      2597 013115      2598 013126      2599 013130      2601 013132      2602 013147
   2603 013150      2604 013160      2605 013161      2606 013167      2608 013203      2609 013214      2610 013215
   2611 013234      2612 013243      2614 013255      2615 013257      2618 013277      2619 013303      2622 013304
   2624 013312      2625 013315


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
