	COMPILATION LISTING OF SEGMENT salv_dir_checker_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1029.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       17*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       18*     Correct error message documentation.
       19*  2) change(86-05-22,Lippard), approve(86-06-17,MCR7433),
       20*     audit(86-06-26,Hartogs), install(86-07-11,MR12.0-1091):
       21*     Make ascii_check detect case when name is all blanks, which will
       22*     not hash properly.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       27 salv_dir_checker_:
       28      proc (arg_source_ptr, arg_salv_ptr, error, arg_set_security_oosw, arg_new_dir_pages);
       29 
       30 /* * This procedure checks the directory for syntatic errors, variation from the information supplied in the branch,
       31*   * and makes plausibility checks on the contents of the information blocks.  If any errors
       32*   * are found while checking the directory, it is rebuilt. The default action can be modified by these flags:
       33*   *
       34*   *	compact			Force a rebuild if at least one page can be saved.
       35*   *	force_rebuild		Force a rebuild of the directory.
       36*   *
       37*   * The following are returned:
       38*   *	new_dir_pages = 0		The directory was not rebuilt.
       39*   *	new_dir_pages > 0		Number of pages in rebuilt directory.
       40*   *
       41*   *	set_security_oosw = "0"b	No AIM errors were detected.
       42*   *	set_security_oosw = "1"b	An AIM error was detected.
       43*   *
       44*   *  AIM checking is only done if a branch was specified.  Protection auditing is done for AIM errors and
       45*   *  change in ACL counts for entries.
       46*   *	- The access class in the branch for the directory is not the same as the access class in the directory header.
       47*   *	- Some branch in the directory has an invalid access class.
       48*   *
       49*   *  All corrections are made after the error message is printed.  The following conventions are used:
       50*   *	SYSTEM	 0	Unexpected errors that indicate software/hardware bugs.
       51*   *	LOSS	 2	Loss of information.
       52*   *	CORRECTION 4	Correctable errors and changes in directory size.
       53*   *	DUMP	 5	Debugging information.  (salvage_directory will dump the directory in the off line case
       54*   *			for these messages.)
       55*   *
       56*   * Constructs used for performance reasons:
       57*   *	- ONES is used as a constant since the copy builtin causes allocates and frees
       58*   *	- The chain threading code is duplicated to prevent the cost of recursion.
       59**/
       60 /* Written 3/77 by S.E. Barr */
       61 /* Modified 6/77 to remove unreferenced access names after rebuilding directory. */
       62 /* Modified December 1981 by C. Hornig for 205K directories */
       63 /* Modified BIM 2/82 for zero length block protection, directed fault */
       64 /* Modified March 1982 by J. Bongiovanni to eliminate use of FSDCT */
       65 /* Modified 84-12-05 by EJ Sharpe to change protection_audit_ calls to access_audit_ */
       66 
       67 /* parameters */
       68 
       69 dcl  arg_new_dir_pages fixed bin;			/* Number of pages in rebuilt directory */
       70 dcl  arg_salv_ptr ptr;				/* ptr to information about directory */
       71 dcl  arg_set_security_oosw bit (1) aligned;		/* ON if the branch should be set security out-of-service */
       72 dcl  arg_source_ptr ptr;				/* pointer to directory */
       73 dcl  error entry options (variable);			/* error routine to print messages */
       74 
       75 /* automatic */
       76 
       77 dcl  audit bit (1) aligned;				/* ON, if have branch, so that audit will make sense */
       78 dcl  branch_ptr ptr;				/* ptr to the branch for this directory */
       79 dcl  check_access_names bit (1) aligned;		/* ON, it should free unused access names from list */
       80 dcl  correct_oosw bit (1) aligned;			/* ON if should put directories back in service. */
       81 dcl  count fixed bin;				/* number of valid blocks on list */
       82 dcl  dir_access_class bit (72) aligned;			/* access class of directory for AIM */
       83 dcl  dir_acl_cnt fixed bin;				/* total number of ACLs for directory */
       84 dcl  dir_name_cnt fixed bin;				/* Value of htused (number of names in directory) */
       85 dcl  dir_size fixed bin;				/* offset of last word in directory */
       86 dcl  dir_uid bit (36) aligned;			/* UID of directory */
       87 dcl  1 event_flags aligned like audit_event_flags;	/* particulars of the operation */
       88 dcl  time bit (36) aligned;				/* Highest value allowed for dates */
       89 dcl  output_area_ptr ptr;				/* ptr to area header in rebuilt directory */
       90 dcl  prodigal_search bit (1) aligned;			/* ON if looking for blocks that can't be reached by chains */
       91 dcl  rebuilding bit (1) aligned;			/* ON if rebuilding directory */
       92 dcl  ring fixed bin;				/* ring number for initial ACLs */
       93 dcl  salv_ptr ptr;					/* ptr to information about the directory */
       94 dcl  scratch_ptr ptr;				/* ptr to scratch segment */
       95 dcl  security_oos bit (1) aligned;			/* ON if directory should be set security out of service */
       96 dcl  source_ptr ptr;				/* ptr to directory being verified */
       97 dcl  stop_at_error bit (1) aligned;			/* ON if rebuild should occur at first uncorrectable error */
       98 dcl  target_ptr ptr;				/* ptr to the new version of the directory */
       99 dcl  trace bit (1) aligned;				/* ON if debugging information should be printed. */
      100 
      101 /* based */
      102 
      103 dcl  1 block_template aligned based,			/* First two words of all information blocks */
      104        2 frp bit (18) unaligned,
      105        2 brp bit (18) unaligned,
      106        2 type bit (18) unaligned,
      107        2 size fixed bin (17) unaligned;
      108 dcl  directory_space char (dir_size + 1) aligned based (scratch_ptr);
      109 dcl  1 info aligned like salv_args based (salv_ptr);
      110 dcl  1 input_dir aligned like dir based (source_ptr);	/* original directory */
      111 dcl  1 output_dir aligned like dir based (target_ptr);	/* rebuilt version of the directory */
      112 
      113 /* internal static */
      114 
      115 dcl  ONES char (1024) aligned int static;
      116 dcl  block_sizes (9) fixed bin int static;
      117 dcl  header_area_size fixed bin int static;		/* number of words in header + area header */
      118 dcl  root_lvid bit (36) int static;
      119 dcl  static_init bit (1) aligned int static init ("0"b);
      120 
      121 /* external */
      122 
      123 dcl  acc_name_$encode entry (ptr, ptr, fixed bin (35));
      124 dcl  access_audit_$log_obj_class entry options (variable);	/* don't use log_entry_ptr entry for
      125*						   fear of looping on bad dirs */
      126 dcl  access_operations_$fs_obj_set_soos bit (36) aligned external;
      127 dcl  access_operations_$fs_obj_access_mod bit (36) aligned external;
      128 dcl  active_hardcore_data$alloc_sizes (8) ext fixed bin;
      129 dcl  active_hardcore_data$dir_hdrsize ext fixed bin;
      130 dcl  active_hardcore_data$hash_table_sizes (1) ext fixed bin;
      131 dcl  active_hardcore_data$elcsize ext fixed bin;
      132 dcl  active_hardcore_data$aclsize ext fixed bin;
      133 dcl  active_hardcore_data$dir_arearp fixed bin (18) aligned ext;
      134 dcl  active_hardcore_data$ensize ext fixed bin;
      135 dcl  active_hardcore_data$esize ext static fixed bin;
      136 dcl  active_hardcore_data$nalloc_sizes ext fixed bin;
      137 dcl  active_hardcore_data$num_hash_table_sizes fixed bin ext;
      138 dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      139 dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      140 dcl  allocate_dir_ht_ entry (ptr, fixed bin, fixed bin (35));
      141 dcl  display_access_class_ entry (bit (72) aligned, char (32) aligned);
      142 dcl  fs_alloc$alloc entry (ptr, fixed bin, ptr, fixed bin (35));
      143 dcl  fs_alloc$init entry (ptr, fixed bin, ptr, fixed bin);
      144 dcl  fs_alloc$free entry (ptr, fixed bin, ptr);
      145 dcl  level$get entry () returns (fixed bin);
      146 dcl  pvt$root_lvid bit (36) ext;
      147 dcl  hash$in entry (ptr, ptr, fixed bin (35));
      148 dcl  hash$search entry (ptr, ptr, ptr, fixed bin (35));
      149 dcl  syserr entry options (variable);
      150 dcl  sys_info$access_class_ceiling ext static bit (72) aligned;
      151 dcl  sys_info$default_dir_max_length ext static fixed bin (19);
      152 dcl  salv_data$debugging_fault_dir_checker bit (1) aligned ext static;
      153 
      154 
      155 dcl  (addr, rel, null, bit, copy, divide, fixed, index, ptr, string, substr, unspec, length, mod, rtrim) builtin;
      156 
      157 /* constants */
      158 
      159 dcl  BLOCK_NAME (9) char (20) int static options (constant)
      160 	init ("access name", "ACL", "directory header", "directory", "link", "name", "segment", "entry", "hash table");
      161 dcl  CORRECTION fixed bin int static options (constant) init (4);
      162 dcl  DUMP fixed bin int static options (constant) init (5);
      163 dcl  entry_type fixed bin int static options (constant) init (8);
      164 dcl  INVALID_RP bit (18) unal int static options (constant) init ("000001"b3);
      165 dcl  LOSS fixed bin int static options (constant) init (2);
      166 dcl  ME char (17) int static options (constant) init ("salv_dir_checker_");
      167 dcl  SYSTEM fixed bin int static options (constant) init (0);
      168 
      169 
      170 	if salv_data$debugging_fault_dir_checker
      171 	then begin;
      172 declare  sfp pointer;
      173 declare  1 sfp_val aligned like its_unsigned;
      174 declare  falter bit (36) aligned based (sfp);
      175 
      176 	     sfp_val.pad1 = ""b;
      177 	     sfp_val.segno = 0;
      178 	     sfp_val.ringno = 0;
      179 	     sfp_val.pad2 = ""b;
      180 	     sfp_val.its_mod = "47"b3;		/* Directed Fault 3 */
      181 	     unspec (sfp) = unspec (sfp_val);
      182 	     call syserr (SL_LOG_CRASH, "salv_dir_checker_: Faulting on purpose.");
      183 	     sfp -> falter = "123456"b3;
      184 	end;
      185 
      186 	arg_new_dir_pages = 0;
      187 	call setup;
      188 	if valid_header () then do;
      189 	     if ^rebuilding
      190 	     then if info.compact then call check_free_list;
      191 RESTART:
      192 	     call mark_space_used (source_ptr, header_area_size);
      193 	     stop_at_error = ^rebuilding;
      194 	     dir_acl_cnt = 0;
      195 	     if rebuilding then call setup_dir_header;
      196 
      197 /* Check access names and check entries */
      198 
      199 	     call process_list (input_dir.proj_frp, input_dir.proj_brp, (null), access_name_type, null,
      200 		output_dir.proj_frp, output_dir.proj_brp, count);
      201 
      202 	     call process_list (input_dir.pers_frp, input_dir.pers_brp, (null), access_name_type, null,
      203 		output_dir.pers_frp, output_dir.pers_brp, count);
      204 
      205 	     call entry_chain;
      206 
      207 /* Check initial ACLs for segments and directories for each ring.  (There is no ring 0 initial ACL) */
      208 
      209 	     do ring = 1 to 7;
      210 		call process_list (input_dir.seg_frp (ring), input_dir.seg_brp (ring), (null), acle_type, null,
      211 		     output_dir.seg_frp (ring), output_dir.seg_brp (ring), count);
      212 		if count ^= input_dir.iacl_count (ring).seg then do;
      213 		     call error (LOSS, ME, "Segment initial ACL count for ring ^d changed from ^d to ^d", ring,
      214 			input_dir.iacl_count (ring).seg, count);
      215 		     input_dir.iacl_count (ring).seg = count;
      216 		     end;
      217 		if rebuilding then output_dir.iacl_count (ring).seg = count;
      218 		dir_acl_cnt = dir_acl_cnt + count;
      219 
      220 		call process_list (input_dir.dir_frp (ring), input_dir.dir_brp (ring), (null), acle_type, null,
      221 		     output_dir.dir_frp (ring), output_dir.dir_brp (ring), count);
      222 		if count ^= input_dir.iacl_count (ring).dir then do;
      223 		     call error (LOSS, ME, "Directory initial ACL count for ring ^d changed from ^d to ^d", ring,
      224 			input_dir.iacl_count (ring).dir, count);
      225 		     input_dir.iacl_count (ring).dir = count;
      226 		     end;
      227 		if rebuilding then output_dir.iacl_count (ring).dir = count;
      228 		dir_acl_cnt = dir_acl_cnt + count;
      229 	     end;
      230 	     if dir_acl_cnt ^= input_dir.acle_total then do;
      231 		call error (LOSS, ME, "ACL count changed from ^d to ^d", input_dir.acle_total, dir_acl_cnt);
      232 		input_dir.acle_total = dir_acl_cnt;
      233 		check_access_names = "1"b;
      234 		end;
      235 	     if rebuilding then do;
      236 		output_dir.acle_total = dir_acl_cnt;	/* Replace kludge by correct value */
      237 		if check_access_names then do;
      238 		     call delete_unused_access_names (output_dir.pers_frp, output_dir.pers_brp);
      239 		     call delete_unused_access_names (output_dir.proj_frp, output_dir.proj_brp);
      240 		     end;
      241 		end;
      242 	     end;
      243 
      244 	arg_set_security_oosw = security_oos;
      245 	if rebuilding then call copy_directory;
      246 	return;
      247 
      248 START_REBUILD:
      249 	rebuilding = "1"b;
      250 	directory_space = "";
      251 	call mark_space_used (ptr (source_ptr, input_dir.hash_table_rp),
      252 	     (ptr (source_ptr, input_dir.hash_table_rp) -> hash_table.size));
      253 	goto RESTART;
      254 
      255 /* This procedure checks and/or rebuilds the entry chain.  After each entry is verified, its names are checked and
      256*   in the case of segments and directories, the ACL chain is verified.
      257*   At the end of the entry chain, the name count should match the total expected.  If it doesn't, the prodigal search
      258*   is done.  This search checks the space not yet marked used, for valid entry or name blocks.
      259**/
      260 entry_chain:
      261      proc;
      262 
      263 dcl  back_rp bit (18);				/* back ptr expected */
      264 dcl  dir_cnt fixed bin;				/* number of directoies found */
      265 dcl  entry_rp bit (18);				/* relative pointer to entry block */
      266 dcl  ep ptr;					/* ptr to entry block */
      267 dcl  forward bit (1) aligned;				/* ON for forward loop; OFF for tracing back chain */
      268 dcl  last_good_entry bit (18) unal;
      269 dcl  link_cnt fixed bin;				/* number of links found */
      270 dcl  name_cnt fixed bin;				/* total entry names in the directory */
      271 dcl  seg_cnt fixed bin;				/* number of segments found */
      272 
      273 	name_cnt, link_cnt, seg_cnt, dir_cnt = 0;
      274 	forward = "1"b;
      275 	back_rp = "0"b;
      276 
      277 /* If the forward thread is zero, but the backward thread is non-zero, then force the forward chain to fail
      278*   to salvage entries using the backward thread.
      279**/
      280 	entry_rp = input_dir.entryfrp;
      281 	if entry_rp = "0"b
      282 	then if input_dir.entrybrp ^= "0"b then entry_rp = INVALID_RP;
      283 
      284 	do while (entry_rp ^= "0"b);
      285 	     ep = ptr (source_ptr, entry_rp);
      286 
      287 /* If the block is not valid, then the back chain is used to recover the rest of the entries. */
      288 /* The back chain is not started, if the back pointer specifies the same bad block.
      289**/
      290 	     if ^valid_block (ep, entry_type, dir_uid, back_rp) then do;
      291 		if trace then call trace_message ("Invalid block found on entry chain", ep);
      292 		if stop_at_error then goto START_REBUILD;
      293 		if ^forward
      294 		then entry_rp = "0"b;
      295 		else do;
      296 		     forward = "0"b;
      297 		     back_rp = INVALID_RP;		/* can't check back ptr while following the chain backward */
      298 		     last_good_entry = entry_rp;
      299 		     if entry_rp = input_dir.entrybrp
      300 		     then entry_rp = "0"b;
      301 		     else entry_rp = input_dir.entrybrp;
      302 		     end;
      303 		end;
      304 	     else do;
      305 		call mark_space_used (ep, 2);		/* Mark threads & size/type used */
      306 		call process_entry (ep);
      307 
      308 		if forward then do;
      309 		     back_rp = entry_rp;
      310 		     entry_rp = ep -> entry.efrp;
      311 		     end;
      312 		else do;
      313 		     entry_rp = ep -> entry.ebrp;
      314 		     if entry_rp = last_good_entry then entry_rp = "0"b;
      315 		     end;
      316 		end;
      317 	end;
      318 
      319 	if dir_name_cnt ^= name_cnt then do;
      320 	     if stop_at_error then goto START_REBUILD;
      321 	     call prodigal;
      322 	     end;
      323 
      324 /* Check and correct totals. */
      325 
      326 	if seg_cnt ^= input_dir.seg_count then do;
      327 	     call error (LOSS, ME, "Segment count changed from ^d to ^d", input_dir.seg_count, seg_cnt);
      328 	     input_dir.seg_count = seg_cnt;
      329 	     end;
      330 	if dir_cnt ^= input_dir.dir_count then do;
      331 	     call error (LOSS, ME, "Directory count changed from ^d to ^d", input_dir.dir_count, dir_cnt);
      332 	     input_dir.dir_count = dir_cnt;
      333 	     end;
      334 	if link_cnt ^= input_dir.lcount then do;
      335 	     call error (LOSS, ME, "Link count changed from ^d to ^d", input_dir.lcount, link_cnt);
      336 	     input_dir.lcount = link_cnt;
      337 	     end;
      338 
      339 	if name_cnt ^= dir_name_cnt then do;
      340 	     call error (LOSS, ME, "Name count changed from ^d to ^d", dir_name_cnt, name_cnt);
      341 	     end;
      342 
      343 	return;
      344 
      345 /* This code checks and rebuilds one entry -- its contents, ACLs and names */
      346 process_entry:
      347 	proc (arg_ep);
      348 
      349 dcl  arg_ep ptr;
      350 
      351 dcl  ep ptr;
      352 dcl  code fixed bin;
      353 dcl  type_expected fixed bin;
      354 dcl  (auth_valid, bc_auth_valid) bit (1);
      355 dcl  count fixed bin;				/*  count of ACLs or names found on chain */
      356 dcl  new_ep ptr;					/* ptr to entry in rebuilt directory */
      357 	     ep = arg_ep;
      358 	     new_ep = null;
      359 	     type_expected = fixed (ep -> entry.type, 18);
      360 	     call entry_contents;
      361 	     if code ^= 0 then do;
      362 		if trace then call trace_message ("Invalid entry contents", ep);
      363 		return;
      364 		end;
      365 
      366 	     call mark_space_used (ep, (ep -> entry.size));
      367 
      368 /* If the directory is being rebuilt, the entry is copied into the new directory, and then the name
      369*   and ACL information is cleared.
      370**/
      371 	     if rebuilding then do;
      372 		call move (ep, output_dir.entryfrp, output_dir.entrybrp, (null), new_ep);
      373 		new_ep -> entry.name_frp, new_ep -> entry.name_brp = "0"b;
      374 		if ep -> entry.bs then new_ep -> entry.acl_frp, new_ep -> entry.acl_brp = "0"b;
      375 		if type_expected = seg_type
      376 		then output_dir.seg_count = output_dir.seg_count + 1;
      377 		else if type_expected = link_type
      378 		     then output_dir.lcount = output_dir.lcount + 1;
      379 		     else if type_expected = dir_type then output_dir.dir_count = output_dir.dir_count + 1;
      380 		end;
      381 	     if type_expected = seg_type
      382 	     then seg_cnt = seg_cnt + 1;
      383 	     else if type_expected = dir_type
      384 		then dir_cnt = dir_cnt + 1;
      385 		else link_cnt = link_cnt + 1;
      386 
      387 /* Check name list */
      388 	     if ep -> entry.name_frp ^= rel (addr (ep -> entry.primary_name)) then do;
      389 		if stop_at_error then goto START_REBUILD;
      390 		call error (CORRECTION, ME, "Corrected primary name pointer for ^a", entry_name (ep));
      391 		ep -> entry.name_frp = rel (addr (ep -> entry.primary_name));
      392 		end;
      393 	     call process_list (ep -> entry.name_frp, ep -> entry.name_brp, new_ep, name_type, ep,
      394 		new_ep -> entry.name_frp, new_ep -> entry.name_brp, count);
      395 
      396 /* If no names were good, add a unique name. */
      397 	     if count = 0 then do;
      398 		if stop_at_error then goto START_REBUILD;
      399 		call get_unique_name (new_ep);
      400 		count = 1;
      401 		end;
      402 
      403 /* Check number of names found against number expected. */
      404 
      405 	     if ep -> entry.nnames ^= count then do;
      406 		if stop_at_error then goto START_REBUILD;
      407 		call error (LOSS, ME, "Corrected count of names from ^d to ^d for ^a", ep -> entry.nnames, count,
      408 		     entry_name (new_ep));
      409 		ep -> entry.nnames = count;
      410 		end;
      411 	     if rebuilding then new_ep -> entry.nnames = count;
      412 	     name_cnt = name_cnt + count;
      413 
      414 /* Check author */
      415 
      416 	     call check_acl_ref (addr (ep -> entry.author), code);
      417 	     auth_valid = (code = 0);
      418 	     if ^auth_valid then do;
      419 		code = 0;
      420 		if stop_at_error then goto START_REBUILD;
      421 		call error (LOSS, ME, "Invalid author found for ^a", entry_name (ep));
      422 		end;
      423 
      424 /* Check ACL list and set bc_author for directories and segments */
      425 
      426 	     if ep -> entry.bs then do;
      427 		call process_list (ep -> entry.acl_frp, ep -> entry.acl_brp, (null), acle_type, ep,
      428 		     new_ep -> entry.acl_frp, new_ep -> entry.acl_brp, count);
      429 		if ep -> entry.acle_count ^= count then do;
      430 		     if stop_at_error then goto START_REBUILD;
      431 		     call error (LOSS, ME, "Corrected count of ACLs from ^d to ^d for ^a", ep -> entry.acle_count, count,
      432 			addr (ep -> entry.primary_name) -> names.name);
      433 		     if audit
      434 		     then call access_audit_$log_obj_class ("salv_dir_checker_", level$get (), unspec (event_flags),
      435 			     access_operations_$fs_obj_access_mod, ep -> entry.access_class,
      436 			     target (info.pathname, entry_name (ep)), 0, null (), 0,
      437 			     "ACL count changed from ^d to ^d", ep -> entry.acle_count, count);
      438 		     ep -> entry.acle_count = count;
      439 		     end;
      440 		dir_acl_cnt = dir_acl_cnt + count;
      441 
      442 		call check_acl_ref (addr (ep -> entry.bc_author), code);
      443 		bc_auth_valid = (code = 0);
      444 		if ^bc_auth_valid then do;
      445 		     code = 0;
      446 		     if stop_at_error then goto START_REBUILD;
      447 		     call error (LOSS, ME, "Invalid bit count author found for ^a", entry_name (ep));
      448 		     end;
      449 		if rebuilding then do;
      450 		     new_ep -> entry.acle_count = count;
      451 		     if bc_auth_valid
      452 		     then call set_acl_ref (addr (ep -> entry.bc_author), addr (new_ep -> entry.bc_author));
      453 		     else call set_acl_ref$damaged (null (), addr (new_ep -> entry.bc_author));
      454 		     end;
      455 		end;
      456 
      457 	     if rebuilding
      458 	     then if auth_valid
      459 		then call set_acl_ref (addr (ep -> entry.author), addr (new_ep -> entry.author));
      460 		else call set_acl_ref$damaged (null (), addr (new_ep -> entry.author));
      461 
      462 entry_contents:
      463 	     proc;
      464 
      465 		code = 0;
      466 
      467 		if ep -> entry.uid = "0"b then do;
      468 		     if stop_at_error then goto START_REBUILD;
      469 		     code = 1;
      470 		     if prodigal_search then return;
      471 		     call error (LOSS, ME, "Deleted ^a ^a with zero UID", BLOCK_NAME (type_expected), entry_name (ep));
      472 		     return;
      473 		     end;
      474 
      475 /* Link */
      476 		if type_expected = link_type then do;
      477 		     call ascii_check (addr (ep -> link.pathname), (ep -> link.pathname_size), code);
      478 		     if code ^= 0 then do;
      479 			if stop_at_error then goto START_REBUILD;
      480 			if ^prodigal_search then do;
      481 			     if code = 1
      482 			     then call error (LOSS, ME, "Deleted link ^a with non-ASCII pathname ^a", entry_name (ep),
      483 				     ep -> link.pathname);
      484 			     else call error (LOSS, ME, "Deleted link with blank pathname");
      485 			     end;
      486 			return;
      487 			end;
      488 		     if ep -> entry.bs then do;
      489 			call error (CORRECTION, ME, "Corrected link branch switch for ^a", entry_name (ep));
      490 			ep -> link.bs = "0"b;
      491 			end;
      492 		     call check_dates;
      493 		     return;
      494 		     end;
      495 
      496 /* Segments and directories */
      497 /* Print message for out-of-service switch.  Don't reset for online case. */
      498 
      499 		if ep -> entry.dirsw & ep -> entry.oosw then do;
      500 		     if correct_oosw then do;
      501 			call error (CORRECTION, ME, "Directory ^a was put back in service", entry_name (ep));
      502 			ep -> entry.oosw = "0"b;
      503 			end;
      504 		     else call error (LOSS, ME, "Directory ^a was found out-of-service", entry_name (ep));
      505 		     end;
      506 
      507 		if ^ep -> entry.bs then do;
      508 		     call error (CORRECTION, ME, "Corrected ^a branch switch for ^a", BLOCK_NAME (type_expected),
      509 			entry_name (ep));
      510 		     ep -> entry.bs = "1"b;
      511 		     end;
      512 		if (ep -> entry.dirsw ^= (ep -> entry.type = DIR_TYPE)) then do;
      513 		     call error (CORRECTION, ME, "Corrected directory switch for ^a", entry_name (ep));
      514 		     ep -> entry.dirsw = (type_expected = dir_type);
      515 		     end;
      516 		call check_dates;
      517 		if ^audit then return;		/* Can only check access, if have branch */
      518 
      519 /* Multiple class segments are allowed for ring 0 and ring 1 segments only. */
      520 
      521 		if ^ep -> entry.dirsw
      522 		then if ep -> entry.multiple_class
      523 		     then if fixed (ep -> entry.ring_brackets (3)) > 1 then do;
      524 			     call error (LOSS, ME,
      525 				"Access error for ^a - invalid ring brackets (^d) for multiple class segment",
      526 				entry_name (ep), ep -> entry.ring_brackets (3));
      527 			     security_oos = "0"b;
      528 			     return;
      529 			     end;
      530 
      531 /*  Make sure access class is less than or equal maximum value. */
      532 
      533 		if (ep -> entry.access_class & (^sys_info$access_class_ceiling)) = "0"b then do;
      534 
      535 /* Multiple class segments and branches must be >= parent.
      536*   Non-multiple class segments and branches must be = parent.
      537**/
      538 		     if ep -> entry.multiple_class then do;
      539 			if aim_check_$greater_or_equal (ep -> entry.access_class, dir_access_class) then return;
      540 			end;
      541 		     else if aim_check_$equal (ep -> entry.access_class, dir_access_class) then return;
      542 		     end;
      543 
      544 		call error (LOSS, ME, "Access class error for ^a, parent ^a, branch ^a", entry_name (ep),
      545 		     cv_access (dir_access_class), cv_access (ep -> entry.access_class));
      546 		call access_audit_$log_obj_class ("salv_dir_checker_", level$get (), unspec (event_flags),
      547 		     access_operations_$fs_obj_set_soos, ep -> entry.access_class,
      548 		     target (info.pathname, entry_name (ep)), 0, null (), 0, "Parent class: ^a",
      549 		     cv_access (dir_access_class));
      550 		ep -> entry.access_class = ep -> entry.access_class & sys_info$access_class_ceiling;
      551 		security_oos = "1"b;
      552 
      553 	     end entry_contents;
      554 
      555 check_dates:
      556 	     proc;
      557 
      558 /* BUG fix: Fix, but do not print message for zero dtem. */
      559 		if ep -> entry.dtem > time | ep -> entry.dtem = "0"b then do;
      560 		     if ep -> entry.dtem ^= "0"b then do;
      561 			call error (CORRECTION, ME, "Corrected dtem for ^a ^a",
      562 			     BLOCK_NAME (fixed (ep -> entry.type, 18)), entry_name (ep));
      563 			end;
      564 		     ep -> entry.dtem = time;
      565 		     end;
      566 
      567 		if ep -> entry.type ^= LINK_TYPE then do;
      568 		     if ep -> entry.dtd > time then do;
      569 			call error (CORRECTION, ME, "Corrected dtd for ^a ^a",
      570 			     BLOCK_NAME (fixed (ep -> entry.type, 18)), entry_name (ep));
      571 			ep -> entry.dtd = "0"b;	/* So it will be dumped */
      572 			end;
      573 		     end;
      574 
      575 	     end check_dates;
      576 
      577 	end process_entry;
      578 
      579 /* This procedure searches the directory for blocks that are not on the entry chain.
      580*   The salvager has already marked the space that is occupied by valid entry, name and ACL blocks.  Only
      581*   initial ACL's have not been marked.  The procedure loops through the directory area free chain and
      582*   marks the blocks that have been released.  If there is any space left that is not marked used, the salvager
      583*   tries to recover the missing blocks within that space.
      584**/
      585 prodigal:
      586 	proc;
      587 
      588 dcl  (i, num_words) fixed bin;
      589 dcl  code fixed bin;
      590 dcl  bp ptr;
      591 dcl  1 block aligned like block_template based (bp);
      592 
      593 	     prodigal_search = "1"b;
      594 	     if trace then call trace_message ("prodigal search", null);
      595 	     trace = "0"b;
      596 
      597 /* Loop through the unused space looking for name or entry blocks. */
      598 	     i = 0;
      599 	     do while (i < dir_size);
      600 		num_words = index (substr (directory_space, i + 1, dir_size - i + 1), " ") - 1;
      601 		if num_words = -1 then return;
      602 		if num_words = 0
      603 		then i = i + 2;
      604 		else i = i + num_words + mod (num_words, 2);
      605 		if i > dir_size - 3 then go to prodend;
      606 		bp = ptr (source_ptr, i);
      607 		if block.type = SEG_TYPE | block.type = DIR_TYPE | block.type = LINK_TYPE then do;
      608 		     if valid_block (bp, (entry_type), dir_uid, (INVALID_RP)) then do;
      609 			call process_entry (bp);
      610 			end;
      611 
      612 		     end;
      613 		else if block.type = NAME_TYPE then call restore_name;
      614 	     end;
      615 
      616 prodend:
      617 	     prodigal_search = "0"b;
      618 	     trace = info.print_trace;
      619 	     return;
      620 
      621 /*  This procedure recovers a name block.  The name block must reference an entry that has already been verified. */
      622 restore_name:
      623 	     proc;
      624 
      625 dcl  a_code fixed bin (35);
      626 dcl  ep ptr;					/* ptr to entry block for name */
      627 dcl  new_ep ptr;
      628 dcl  np ptr;					/* ptr to name block */
      629 dcl  p ptr;
      630 
      631 /* Find entry block for the name.  If it has not yet been verified, check it. */
      632 
      633 		np = bp;
      634 		ep = ptr (source_ptr, np -> names.entry_rp);
      635 		if valid_block (ep, entry_type, dir_uid, INVALID_RP) then do;
      636 		     call process_entry (ep);
      637 		     end;
      638 
      639 		if fixed (rel (ep), 18) + block_sizes (entry_type) - 1 <= dir_size then do;
      640 		     if substr (directory_space, fixed (rel (ep), 18) + 1, 1) = "E" then do;
      641 
      642 /* Check structure and contents of name block. */
      643 			if valid_block (np, name_type, ep -> entry.uid, (INVALID_RP)) then do;
      644 			     call check_contents (np, name_type, ep, code);
      645 			     if code = 0 then do;
      646 				call mark_space_used (np, block_sizes (name_type));
      647 
      648 /* Find entry block in rebuilt directory in order to connect the name to it. */
      649 				p = addr (addr (ep -> entry.primary_name) -> names.name);
      650 				call hash$search (target_ptr, p, new_ep, a_code);
      651 				if a_code = 0
      652 				then call move (np, new_ep -> entry.name_frp, new_ep -> entry.name_brp, new_ep,
      653 					(null));
      654 				end;
      655 			     end;
      656 			end;
      657 		     end;
      658 		return;
      659 
      660 	     end restore_name;
      661 
      662 	end prodigal;
      663 
      664      end entry_chain;
      665 
      666 /* One directory chain is checked and or rebuilt. */
      667 process_list:
      668      proc (head, tail, a_new_owner_bp, a_type_expected, a_entry_p, a_new_head, a_new_tail, a_count);
      669 
      670 /* parameters */
      671 
      672 dcl  head bit (18) unal;				/* head of list */
      673 dcl  tail bit (18) unal;				/* end of list */
      674 dcl  a_entry_p ptr;					/* ptr to entry block (used for ACLs and names) */
      675 dcl  a_new_owner_bp ptr;				/* ptr to a_new entry block for threading names */
      676 dcl  a_type_expected fixed bin;			/* type of blocks on list */
      677 dcl  a_count fixed bin;				/* number of valid blocks found */
      678 dcl  a_new_head bit (18) unal;			/* rebuild: head of list in new directory */
      679 dcl  a_new_tail bit (18) unal;			/* rebuild: tail of list in new directory */
      680 
      681 /* automatic */
      682 
      683 dcl  back_rp bit (18);
      684 dcl  block_rp bit (18);
      685 dcl  bp ptr;
      686 dcl  code fixed bin;
      687 dcl  count fixed bin;
      688 dcl  entry_p ptr;
      689 dcl  forward bit (1) aligned;				/* ON for forward walk of list */
      690 dcl  last_good_block bit (18) unal;			/* Last good block from forward walk. Used to terminate
      691*						   backward walk. */
      692 dcl  new_bp ptr;					/* ptr to block in new directory after the move */
      693 dcl  new_head bit (18) unal;
      694 dcl  new_tail bit (18) unal;
      695 dcl  new_owner_bp ptr;				/* UID of owner block. */
      696 dcl  owner_expected bit (36) aligned;
      697 dcl  type_expected fixed bin;
      698 
      699 dcl  1 block aligned like block_template based (bp);
      700 
      701 	new_owner_bp = a_new_owner_bp;
      702 	type_expected = a_type_expected;
      703 	entry_p = a_entry_p;
      704 	if rebuilding then do;
      705 	     new_head = a_new_head;
      706 	     new_tail = a_new_tail;
      707 	     end;
      708 
      709 /* For names and ACLs of entries the owner is the entry.  For all other blocks, the owner is the directory. */
      710 	if entry_p ^= null
      711 	then owner_expected = entry_p -> entry.uid;
      712 	else owner_expected = dir_uid;
      713 	count = 0;
      714 	forward = "1"b;
      715 	back_rp = "0"b;
      716 
      717 /* If the forward thread is zero, but the backward thread is non-zero, then force the forward chain to fail
      718*   to salvage those entries.
      719**/
      720 	block_rp = head;
      721 	if block_rp = "0"b
      722 	then if tail ^= "0"b then block_rp = INVALID_RP;
      723 
      724 	do while (block_rp ^= "0"b);
      725 	     bp = ptr (source_ptr, block_rp);
      726 
      727 /* If the block is not valid, then the back chain is used to recover the rest of the entries.
      728*   ACL blocks can not be recoved this way, since the order is important.
      729**/
      730 	     if ^valid_block (bp, type_expected, owner_expected, back_rp) then do;
      731 		if trace then call trace_message ("Invalid block found on chain " || BLOCK_NAME (type_expected), bp);
      732 		if stop_at_error then goto START_REBUILD;
      733 		if ^forward
      734 		then block_rp = "0"b;
      735 		else do;
      736 		     forward = "0"b;
      737 		     if type_expected = acle_type
      738 		     then block_rp = "0"b;
      739 		     else do;
      740 			back_rp = INVALID_RP;	/* can't check back ptr while following the chain backward */
      741 			last_good_block = block_rp;
      742 			if block_rp = tail
      743 			then block_rp = "0"b;
      744 			else block_rp = tail;
      745 			end;
      746 		     end;
      747 		end;
      748 	     else do;
      749 		call mark_space_used (bp, 2);		/* Mark threads & size/type used */
      750 		call check_contents (bp, type_expected, entry_p, code);
      751 		if code = 0 then do;
      752 		     call mark_space_used (bp, block_sizes (type_expected));
      753 		     if rebuilding then do;
      754 			call move (bp, new_head, new_tail, new_owner_bp, new_bp);
      755 			if type_expected = acle_type
      756 			then call set_acl_ref (addr (bp -> acl_entry.name), addr (new_bp -> acl_entry.name));
      757 			else if type_expected = access_name_type then do;
      758 				new_bp -> access_name.usage = 0;
      759 				output_dir.acle_total = output_dir.acle_total + 1;
      760 						/* This is a kludge. We move access names before
      761*						   moving ACL entries, so the thread is quite
      762*						   long even though dir.acle_total would be zero.
      763*						   But acc_name_$encode (used to move ACLE) uses
      764*						   acle_total to check for looped access name thread.
      765*						   So we put in a number which will fool acc_name_.
      766*						   What should really be done is to have a new
      767*						   item, dir.access_name_total, but that is too much
      768*						   work for right now. THVV */
      769 				end;
      770 			end;
      771 		     count = count + 1;
      772 		     end;
      773 		else if trace
      774 		     then call trace_message (rtrim (BLOCK_NAME (type_expected)) || " chain has invalid contents", bp)
      775 			     ;
      776 		if forward then do;
      777 		     back_rp = block_rp;
      778 		     block_rp = bp -> block.frp;
      779 		     end;
      780 		else do;
      781 		     block_rp = bp -> block.brp;
      782 		     if block_rp = last_good_block then block_rp = "0"b;
      783 		     end;
      784 		end;
      785 	end;
      786 
      787 	if rebuilding then do;
      788 	     a_new_head = new_head;
      789 	     a_new_tail = new_tail;
      790 	     end;
      791 	a_count = count;
      792 
      793 	return;
      794      end process_list;
      795 
      796 /* This procedure verifies the structure of a block.  It returns "0", if these conditions fail:
      797*   1.  The block is within the directory and does not overlap any space that has been marked used.
      798*   2.  The owner field matches the one expected.
      799*
      800*   The following are not fatal errors and will be corrected. (except for the prodigal case)
      801*   1.  The type and size fields found are not compatible with the type expected.
      802*   2.  The back relative pointer is not the one expected.
      803*
      804*   Any errors during a prodigal search, cause "0"b to be returned
      805**/
      806 valid_block:
      807      proc (arg_tp, arg_type_expected, owner_expected, brp_expected) returns (bit (1) aligned);
      808 
      809 /* parameters */
      810 
      811 dcl  arg_tp ptr;					/* ptr to block */
      812 dcl  arg_type_expected fixed bin;
      813 dcl  owner_expected bit (36) aligned;
      814 dcl  brp_expected bit (18) unal;
      815 
      816 dcl  bp ptr;
      817 dcl  type_expected fixed bin;
      818 dcl  nwords fixed bin;
      819 dcl  i fixed bin;
      820 dcl  1 block aligned like block_template based (bp);
      821 
      822 
      823 /* Check that the block falls within the directory and does not overlap previously accepted blocks. */
      824 
      825 	bp = arg_tp;
      826 	type_expected = arg_type_expected;
      827 	if ^space_free (bp, block_sizes (type_expected)) then return ("0"b);
      828 
      829 	goto btype (type_expected);
      830 
      831 /* entry - directory, segment, link */
      832 btype (8):
      833 	if bp -> block.type = DIR_TYPE
      834 	then type_expected = dir_type;
      835 	else if bp -> block.type = SEG_TYPE
      836 	     then type_expected = seg_type;
      837 	     else if bp -> block.type = LINK_TYPE
      838 		then type_expected = link_type;
      839 		else return ("0"b);
      840 
      841 	goto btype (type_expected);
      842 
      843 /* access name */
      844 btype (1):
      845 	if bp -> access_name.owner ^= owner_expected then return ("0"b);
      846 	goto CHECK_TYPE;
      847 
      848 /* acl */
      849 btype (2):
      850 	if bp -> acl_entry.owner ^= owner_expected then return ("0"b);
      851 	goto CHECK_TYPE;
      852 
      853 /* segment or directory */
      854 btype (7):
      855 btype (4):
      856 	if bp -> entry.owner ^= owner_expected then return ("0"b);
      857 	goto CHECK_TYPE;
      858 
      859 /* link */
      860 /* The pathname size must be verified first, since the link structure uses it with the refer. */
      861 btype (5):
      862 	if bp -> link.pathname_size < 1 | bp -> link.pathname_size > 168 then return ("0"b);
      863 	nwords = active_hardcore_data$elcsize + 3 + divide (bp -> link.pathname_size + 3, 4, 17, 0);
      864 	do i = 1 to active_hardcore_data$nalloc_sizes while (nwords > active_hardcore_data$alloc_sizes (i));
      865 	end;
      866 	nwords = active_hardcore_data$alloc_sizes (i);
      867 	if ^space_free (bp, nwords) then return ("0"b);
      868 	if bp -> link.owner ^= owner_expected then return ("0"b);
      869 	if bp -> link.size ^= nwords then do;
      870 	     if prodigal_search then return ("0"b);
      871 	     call error (CORRECTION, ME, "Corrected size field in link block");
      872 	     bp -> link.size = nwords;
      873 	     end;
      874 	goto CHECK_BP;
      875 
      876 /* name */
      877 btype (6):
      878 	if bp -> names.owner ^= owner_expected then return ("0"b);
      879 	goto CHECK_TYPE;
      880 
      881 /* The type and size fields must be correct for the prodigal search.  They will be corrected for the normal loop. */
      882 
      883 CHECK_TYPE:
      884 	if fixed (bp -> block.type, 18) ^= type_expected then do;
      885 	     if prodigal_search then return ("0"b);
      886 	     call error (CORRECTION, ME, "Invalid type in ^a block", BLOCK_NAME (type_expected));
      887 	     bp -> block.type = bit (fixed (type_expected, 18), 18);
      888 	     end;
      889 	if bp -> block.size ^= block_sizes (type_expected) then do;
      890 	     if prodigal_search then return ("0"b);
      891 	     call error (CORRECTION, ME, "Corrected size field in ^a block", BLOCK_NAME (type_expected));
      892 	     bp -> block.size = block_sizes (type_expected);
      893 	     end;
      894 
      895 /* Check and correct the back ptr.  Do not print message for prodigals since it  is assumed they are not on chains. */
      896 
      897 CHECK_BP:
      898 	if brp_expected ^= INVALID_RP
      899 	then if bp -> block.brp ^= brp_expected then do;
      900 		call error (CORRECTION, ME, "Corrected invalid back pointer in ^a", BLOCK_NAME (type_expected));
      901 		bp -> block.brp = brp_expected;
      902 		end;
      903 
      904 	return ("1"b);
      905 
      906      end valid_block;
      907 
      908 /* This procedure makes plausibility checks on the contents of the block.
      909*   code = 0		No uncorrectable errors were found.
      910*   code ^= 0		The block can not be salvaged.
      911**/
      912 check_contents:
      913      proc (arg_bp, type_expected, entry_p, code);
      914 
      915 dcl  arg_bp ptr;
      916 dcl  type_expected fixed bin;
      917 dcl  entry_p ptr;
      918 dcl  code fixed bin;
      919 
      920 dcl  a_code fixed bin (35);
      921 dcl  bp ptr;
      922 dcl  p ptr;
      923 
      924 	code = 0;
      925 	bp = arg_bp;
      926 	goto check (type_expected);
      927 
      928 /* access names must be ASCII */
      929 check (1):
      930 	call ascii_check (addr (bp -> access_name.name), length (bp -> access_name.name), code);
      931 	if code ^= 0 then do;
      932 	     if stop_at_error then goto START_REBUILD;
      933 	     if code = 1
      934 	     then call error (LOSS, ME, "Deleted non-ASCII access name ^a", bp -> access_name.name);
      935 	     else call error (LOSS, ME, "Deleted blank access name");
      936 	     end;
      937 	if rebuilding
      938 	then if bp -> access_name.usage = 0 then code = 1;
      939 
      940 	return;
      941 
      942 /* The ACL entry must point to valid person and project names and have an ASCII tag.  All access names are verified
      943*   before any ACLs are checked. */
      944 check (2):
      945 	call check_acl_ref (addr (bp -> acl_entry.name), code);
      946 	return;
      947 
      948 /* The entry pointer must match the one expected.
      949*   The name must contain only ASCII characters
      950*   The name must not yet be in the hash table
      951**/
      952 check (6):
      953 	call ascii_check (addr (bp -> names.name), length (bp -> names.name), code);
      954 	if code ^= 0 then do;
      955 	     if stop_at_error then goto START_REBUILD;
      956 	     if ^prodigal_search then do;
      957 		if code = 1
      958 		then call error (LOSS, ME, "Deleted non-ASCII name  ^a", bp -> names.name);
      959 		else call error (LOSS, ME, "Deleted blank name");
      960 		end;
      961 	     return;
      962 	     end;
      963 
      964 /* Entry ptr check. */
      965 	if rel (entry_p) ^= bp -> names.entry_rp then do;
      966 	     if stop_at_error then goto START_REBUILD;
      967 	     call error (CORRECTION, ME, "Corrected entry ptr for name ^a", bp -> names.name);
      968 	     bp -> names.entry_rp = rel (entry_p);
      969 	     end;
      970 
      971 /* Name duplication check. */
      972 	if rebuilding
      973 	then p = target_ptr;
      974 	else p = source_ptr;
      975 	call hash$search (p, addr (bp -> names.name), (null), a_code);
      976 	if a_code = 0 then do;
      977 	     code = 1;
      978 	     if stop_at_error then goto START_REBUILD;
      979 	     if ^prodigal_search then call error (LOSS, ME, "Deleted duplicate name ^a", bp -> names.name);
      980 	     return;
      981 	     end;
      982 
      983 /* Hash name back into source directory. */
      984 	if ^rebuilding then do;
      985 	     call hash$in (source_ptr, bp, a_code);
      986 	     if a_code ^= 0 then do;
      987 		call error (SYSTEM, ME, "Unexpected error from hash$in for ^a", bp -> names.name);
      988 		goto START_REBUILD;
      989 		end;
      990 	     end;
      991 	return;
      992 
      993 
      994 
      995 
      996      end check_contents;
      997 
      998 /* This procedure turns on characters in the array directory_space to mark blocks of information that have been checked.
      999*   This is done so that chains which loop back on themselves can be detected.  One character in directory_space
     1000*   corresponds to one word in the directory being checked.
     1001*   Entry blocks are special cased so that the primary name block, that is within the entry block, is left empty.
     1002*
     1003*   The first character of the directory_space block is set:
     1004*   .	E	Entry block.  Used by prodigal search when a name has been found.
     1005*   .	A	Access name block.  Used in checking ACLs.  ACLs must point to verified access names.
     1006**/
     1007 mark_space_used:
     1008      proc (bp, num_words);
     1009 
     1010 dcl  bp ptr;
     1011 dcl  num_words fixed bin;
     1012 
     1013 dcl  start fixed bin;
     1014 
     1015 dcl  1 block aligned based (bp) like block_template;
     1016 
     1017 	start = fixed (rel (bp), 18) + 1;
     1018 	substr (directory_space, start, num_words) = substr (ONES, 1, num_words);
     1019 
     1020 	if num_words > 2 then do;
     1021 	     if bp -> block.type = LINK_TYPE | bp -> block.type = DIR_TYPE | bp -> block.type = SEG_TYPE then do;
     1022 		substr (directory_space, start, 1) = "E";
     1023 		start = fixed (rel (addr (bp -> entry.primary_name)), 18) + 1;
     1024 		substr (directory_space, start, block_sizes (name_type)) = " ";
     1025 		end;
     1026 	     else if bp -> block.type = ACCESS_NAME_TYPE then substr (directory_space, start, 1) = "A";
     1027 	     end;
     1028 
     1029      end mark_space_used;
     1030 
     1031 
     1032 
     1033 /* This procedure returns  "1"b, if the space specified is unused. */
     1034 
     1035 space_free:
     1036      proc (bp, num_words) returns (bit (1) aligned);
     1037 
     1038 dcl  bp ptr;					/* pointer to block */
     1039 dcl  num_words fixed bin;				/* size of block */
     1040 
     1041 dcl  start fixed bin;
     1042 
     1043 	if num_words ^> 0 then call error (SYSTEM, ME, "salv_dir_checker_$space_fre called with num_words = 0");
     1044 
     1045 	start = fixed (rel (bp), 18) + 1;
     1046 	if start + num_words - 2 > dir_size then return ("0"b);
     1047 
     1048 /* HARDWARE BUG  get last character in, in case it is on a different page */
     1049 	if substr (directory_space, start + num_words - 1, 1) ^= " " then return ("0"b);
     1050 	return (substr (directory_space, start, num_words) = " ");
     1051 
     1052      end space_free;
     1053 
     1054 /* This procedure is called to verify a name used in an ACL.  All access names are validated before any ACL's are
     1055*   checked.  The directory space array has an "A" at the start of all verified access names (stored by mark_space_used)
     1056**/
     1057 check_acl_ref:
     1058      proc (a_p, code);
     1059 
     1060 dcl  a_p ptr;
     1061 dcl  p ptr;
     1062 dcl  code fixed bin;
     1063 dcl  1 name unal like acl_entry.name based (p);
     1064 
     1065 	p = a_p;
     1066 	code = 0;
     1067 	if substr (unspec (name.tag), 1, 2) then do;
     1068 	     code = 1;
     1069 	     check_access_names = "1"b;
     1070 	     return;
     1071 	     end;
     1072 	if name.pers_rp ^= "0"b then call find_access_name (ptr (source_ptr, name.pers_rp));
     1073 	if code = 0
     1074 	then if name.proj_rp ^= "0"b then call find_access_name (ptr (source_ptr, name.proj_rp));
     1075 	if code = 1 then check_access_names = "1"b;
     1076 
     1077 
     1078 
     1079 
     1080 find_access_name:
     1081 	proc (np);
     1082 
     1083 dcl  np ptr;
     1084 
     1085 	     if fixed (rel (np), 18) + block_sizes (access_name_type) - 1 <= dir_size
     1086 	     then if substr (directory_space, fixed (rel (np), 18) + 1, 1) = "A" then return;
     1087 	     code = 1;
     1088 
     1089 	end find_access_name;
     1090 
     1091      end check_acl_ref;
     1092 
     1093 
     1094 
     1095 
     1096 /* This procedure checks for ASCII characters.  ASCII characters have the 2 high order bits off. */
     1097 
     1098 ascii_check:
     1099      proc (name_ptr, num_chars, code);
     1100 
     1101 dcl  name_ptr ptr;
     1102 dcl  num_chars fixed bin;
     1103 dcl  code fixed bin;
     1104 
     1105 dcl  i fixed bin;
     1106 dcl  name bit (i) aligned based (name_ptr);
     1107 
     1108 dcl  1 ascii_mask aligned static options (constant),
     1109        2 part1 bit (9 * 16) init ((16)"110000000"b),
     1110        2 part2 bit (9 * 16) init ((16)"110000000"b);
     1111 
     1112 dcl  1 spaces aligned static options (constant),
     1113        2 part1 bit (9 * 16) init ((16)"040"b3),
     1114        2 part2 bit (9 * 16) init ((16)"040"b3);
     1115 
     1116 	i = num_chars * 9;
     1117 	if (name & unspec (ascii_mask)) = "0"b
     1118 	then code = 0;
     1119 	else code = 1;
     1120 
     1121 	if name = unspec (spaces) then code = 2;         /* Check to see if name is blank. */
     1122 
     1123      end ascii_check;
     1124 
     1125 setup:
     1126      proc;
     1127 	if ^static_init then do;
     1128 	     block_sizes (dir_header_type) = active_hardcore_data$dir_hdrsize;
     1129 	     block_sizes (seg_type), block_sizes (dir_type), block_sizes (entry_type) = active_hardcore_data$esize;
     1130 	     block_sizes (acle_type) = active_hardcore_data$aclsize;
     1131 	     block_sizes (access_name_type), block_sizes (name_type) = active_hardcore_data$ensize;
     1132 	     header_area_size = active_hardcore_data$dir_hdrsize + active_hardcore_data$nalloc_sizes + 2;
     1133 	     ONES = copy ("1", length (ONES));
     1134 	     root_lvid = pvt$root_lvid;
     1135 	     static_init = "1"b;
     1136 	     end;
     1137 
     1138 	salv_ptr = arg_salv_ptr;
     1139 	branch_ptr = info.branch_ptr;
     1140 	source_ptr = arg_source_ptr;
     1141 	target_ptr = info.temp1_ptr;
     1142 	scratch_ptr = info.temp2_ptr;
     1143 	prodigal_search, check_access_names = "0"b;
     1144 	rebuilding = info.force_rebuild;
     1145 	correct_oosw = info.correct_oosw;
     1146 	trace = info.print_trace;
     1147 	security_oos = "0"b;
     1148 	time = info.salv_time;
     1149 
     1150 /* Use the value in the area header if it is plausible. MR6.0 has garbage after the end of the area.
     1151*   After this release, unused portion of the last page of the directory will be zero, so the next
     1152*   version can use the current length.
     1153**/
     1154 	dir_size = ptr (source_ptr, active_hardcore_data$dir_arearp) -> area.lu - 1;
     1155 	if dir_size > 1024 * info.current_length | dir_size < 1024 * (info.current_length - 1)
     1156 	then dir_size = info.current_length * 1024 - 1;
     1157 	directory_space = " ";
     1158 
     1159 	string (event_flags) = ""b;
     1160 	event_flags.special_op = "1"b;
     1161 	event_flags.grant = "1"b;			/* can't know whether we're doing this under privileged
     1162*						   maint operation or as user who encountered a bad dir.
     1163*						   assume the latter... */
     1164 
     1165      end setup;
     1166 
     1167 /* This procedure returns an entry name as characters, if it is ASCII or as octal, if it is not. */
     1168 
     1169 entry_name:
     1170      proc (ep) returns (char (32));
     1171 
     1172 dcl  ep ptr;
     1173 
     1174 dcl  string char (32 * 3);
     1175 dcl  np ptr;
     1176 
     1177 dcl  code fixed bin;
     1178 dcl  word8 bit (288) aligned based;			/* the name as a bit string for formline_ */
     1179 
     1180 	np = addr (ep -> entry.primary_name);
     1181 	call ascii_check (addr (np -> names.name), length (np -> names.name), code);
     1182 	if code = 0 then return (np -> names.name);
     1183 	call format ("^(^8w^)", addr (np -> names.name) -> word8, string);
     1184 	return (string);
     1185      end entry_name;
     1186 
     1187 
     1188 format:
     1189      proc (control_string, name_string, output_string) options (non_quick);
     1190 
     1191 dcl  control_string char (*);
     1192 dcl  name_string bit (288) aligned;
     1193 dcl  output_string char (*);
     1194 
     1195 dcl  formline_ entry (fixed bin, fixed bin, ptr, fixed bin, fixed bin);
     1196 
     1197 	call formline_ (1, 2, addr (output_string), length (output_string), 0);
     1198 
     1199      end format;
     1200 
     1201 /* Space for the block is allocated in the new directory and the new block is threaded onto the chain
     1202*   specified by the head and tail pointers.
     1203*   The primary name for an entry is contained within the entry block, so space is not allocated for it.
     1204*   Names are put in the hash table and their entry rel pointers set.
     1205**/
     1206 move:
     1207      proc (bp, head, tail, entry_bp, new_ptr);
     1208 
     1209 dcl  bp ptr;					/* ptr to entry in old directory */
     1210 dcl  head bit (18) unal;				/* head of chain */
     1211 dcl  tail bit (18) unal;				/* tail of chain */
     1212 dcl  entry_bp ptr;					/* pointer to entry for a name block */
     1213 dcl  new_ptr ptr;					/* pointer to block in rebuilt directory */
     1214 
     1215 dcl  code fixed bin (35);
     1216 dcl  num_words fixed bin;
     1217 dcl  last_ep ptr;					/* pointer to entry that was processed before the entry
     1218*						   for the this name. */
     1219 
     1220 dcl  copy (num_words) bit (36) aligned based;
     1221 dcl  1 block aligned like block_template based (bp);
     1222 
     1223 	num_words = bp -> block.size;
     1224 
     1225 /* The first name on a chain is the primary name. */
     1226 
     1227 	if bp -> block.type = NAME_TYPE & head = "0"b then do;
     1228 	     new_ptr = addr (entry_bp -> entry.primary_name);
     1229 	     end;
     1230 	else call fs_alloc$alloc (output_area_ptr, num_words, new_ptr, code);
     1231 
     1232 	new_ptr -> copy = bp -> copy;
     1233 	new_ptr -> block.frp = "0"b;
     1234 
     1235 	if head = "0"b then do;
     1236 	     head, tail = rel (new_ptr);
     1237 	     new_ptr -> block.brp = "0"b;
     1238 	     end;
     1239 	else do;
     1240 	     new_ptr -> block.brp = tail;
     1241 	     ptr (target_ptr, tail) -> block.frp = rel (new_ptr);
     1242 	     tail = rel (new_ptr);
     1243 	     end;
     1244 
     1245 /* Names are hashed into the new directory.  This code special cases rebuilding a directory whose hash table size
     1246*   is about to grow.  The code in hash will walk the entry chain and put the names into the new hash table.
     1247*   The current entry must be removed from the entry chain, since its name is not yet in the hash table. */
     1248 
     1249 	if new_ptr -> block.type = NAME_TYPE then do;
     1250 	     if output_dir.htused = output_dir.htsize then do;
     1251 		last_ep = ptr (target_ptr, entry_bp -> entry.ebrp);
     1252 		last_ep -> entry.efrp = "0"b;
     1253 		end;
     1254 	     else last_ep = null;
     1255 	     call hash$in (target_ptr, new_ptr, code);
     1256 	     if code ^= 0 then call error (SYSTEM, ME, "Unable to hash name ^a", new_ptr -> names.name);
     1257 	     ;
     1258 	     if last_ep ^= null then last_ep -> entry.efrp = rel (entry_bp);
     1259 	     new_ptr -> names.entry_rp = rel (entry_bp);
     1260 	     end;
     1261 
     1262      end move;
     1263 
     1264 /* The ACL pointers to the access name and access project are changed to the locations in the rebuilt directory. */
     1265 
     1266 set_acl_ref:
     1267      proc (a_old_p, a_new_p);
     1268 
     1269 dcl  a_old_p ptr;					/* ptr to access name structure in old directory */
     1270 dcl  a_new_p ptr;					/* ptr to access name structure in new directory */
     1271 dcl  p ptr;
     1272 dcl  code35 fixed bin (35);
     1273 dcl  1 acl_info aligned,				/* template for access name encoding */
     1274        2 name,
     1275          3 pers char (32),
     1276          3 proj char (32),
     1277          3 tag char (1),
     1278        2 pad (2) bit (36);
     1279 dcl  1 name aligned like acl_entry.name based (p);
     1280 
     1281 	p = a_old_p;
     1282 	if name.pers_rp = "0"b
     1283 	then acl_info.pers = "*";
     1284 	else acl_info.pers = ptr (source_ptr, name.pers_rp) -> access_name.name;
     1285 
     1286 	if name.proj_rp = "0"b
     1287 	then acl_info.proj = "*";
     1288 	else acl_info.proj = ptr (source_ptr, name.proj_rp) -> access_name.name;
     1289 	acl_info.tag = name.tag;
     1290 
     1291 join:
     1292 	call acc_name_$encode (a_new_p, addr (acl_info), code35);
     1293 	if code35 ^= 0 then do;
     1294 	     call error (SYSTEM, ME, "Unexpected error from acc_name_$encode ^w for ^a.^a.^a", code35, name.pers, name.proj,
     1295 		name.tag);
     1296 	     end;
     1297 
     1298 	return;
     1299 
     1300 set_acl_ref$damaged:
     1301      entry (a_old_p, a_new_p);			/* Called to put in constant. */
     1302 
     1303 	acl_info.pers = "Salvager";
     1304 	acl_info.proj = "SysDaemon";
     1305 	acl_info.tag = "z";
     1306 
     1307 	go to join;
     1308 
     1309 
     1310      end set_acl_ref;
     1311 
     1312 /* If the compact option was specified, then the space on the free list is totaled.  If it contains a page or more
     1313*   space, then a rebuild is forced.  If any errors are detected, a rebuild is forced.
     1314**/
     1315 check_free_list:
     1316      proc;
     1317 
     1318 dcl  bp ptr;
     1319 dcl  i fixed bin;
     1320 dcl  sum fixed bin;
     1321 dcl  1 block aligned like block_template based (bp);
     1322 
     1323 	areap = ptr (source_ptr, input_dir.arearp);
     1324 	sum = 0;
     1325 
     1326 	do i = 1 to area.nsizes;
     1327 	     do bp = ptr (source_ptr, area.array (i).fptr) repeat ptr (source_ptr, bp -> block.frp) while (rel (bp));
     1328 
     1329 		if area.array (i).size ^> 0 then go to START_REBUILD;
     1330 		if ^space_free (bp, (area.array (i).size)) then goto START_REBUILD;
     1331 		sum = sum + area.array (i).size;
     1332 		if sum > 1024 then goto START_REBUILD;
     1333 		call mark_space_used (bp, (area.array (i).size));
     1334 	     end;
     1335 	end;
     1336 
     1337      end check_free_list;
     1338 
     1339 /* Fields in the header are checked against values supplied in the branch and storage system constants
     1340*   Errors cause a message to be printed and the rebuilding flag to be set.  No corrections are made here,
     1341*   setup_header sets all fields using the branch information.
     1342*
     1343*   "0"b	If the UID in the branch does not equal the UID in the header
     1344*   "1"b	The UID does match.
     1345*
     1346*   If the access_class does not match, the branch will be set security_oos.
     1347**/
     1348 valid_header:
     1349      proc () returns (bit (1) aligned);
     1350 
     1351 dcl  1 branch aligned based (branch_ptr) like entry;
     1352 
     1353 dcl  num_buckets fixed bin;
     1354 dcl  i fixed bin;
     1355 dcl  block (i) bit (36) based (htp);
     1356 dcl  1 hash_table aligned based (htp),
     1357        2 pad bit (36),
     1358        2 type bit (18) unal,
     1359        2 size fixed bin (17) unal,
     1360        2 buckets (num_buckets) bit (18) unal;
     1361 
     1362 	if branch_ptr = null then do;
     1363 	     audit = "0"b;
     1364 
     1365 	     dir_uid = input_dir.uid;
     1366 	     end;
     1367 	else do;
     1368 	     audit = "1"b;
     1369 
     1370 /* If the UID in the header doesn't match the one in the branch, then a valid empty directory will be created. */
     1371 
     1372 	     if input_dir.uid ^= branch.uid then do;
     1373 		call error (LOSS, ME, "Invalid directory header - no information recovered");
     1374 		dir_name_cnt = 0;
     1375 		call setup_dir_header;
     1376 		rebuilding = "1"b;
     1377 		return ("0"b);
     1378 		end;
     1379 
     1380 	     if input_dir.owner ^= branch.owner then call header_err ("owner");
     1381 	     if input_dir.pvid ^= branch.pvid then call header_err ("physical volume id");
     1382 	     if input_dir.sons_lvid ^= branch.sons_lvid then call header_err ("sons logical volume id");
     1383 	     if input_dir.vtocx ^= branch.vtocx then call header_err ("vtoc index");
     1384 	     if input_dir.master_dir ^= branch.master_dir then call header_err ("master directory switch");
     1385 	     if input_dir.master_dir_uid ^= info.master_dir_uid then call header_err ("master directory UID");
     1386 	     dir_uid = branch.uid;
     1387 	     dir_access_class = branch.access_class;
     1388 
     1389 /* AIM check */
     1390 	     if input_dir.access_class ^= dir_access_class then do;
     1391 		call error (LOSS, ME, "Branch access class ^a does not match directory header access class ^a",
     1392 		     cv_access (branch.access_class), cv_access (input_dir.access_class));
     1393 
     1394 /* BUG FIX: This field is not always set, due to a bug in reclassify.  Add check after 6.0 */
     1395 /*
     1396*   *		call access_audit_$log_obj_class ("salv_dir_checker_", level$get(), unspec(event_flags),
     1397*   *		     access_operations_$fs_obj_set_soos, branch.access_class, info.pathname, 0, null(), 0,
     1398*   *		     "Dir header class: ^a", cv_access (dir_access_class));
     1399*   *		     security_oos = "1"b;
     1400**/
     1401 		end;
     1402 	     end;
     1403 	if input_dir.type ^= DIR_HEADER_TYPE then call header_err ("type");
     1404 	if input_dir.size ^= active_hardcore_data$dir_hdrsize then call header_err ("size");
     1405 	if input_dir.version_number ^= version_number_2 then call header_err ("version_number");
     1406 	if input_dir.arearp ^= bit (active_hardcore_data$dir_arearp, 18) then call header_err ("area pointer");
     1407 
     1408 /* Check area header */
     1409 
     1410 	areap = ptr (source_ptr, active_hardcore_data$dir_arearp);
     1411 	if area.nsizes ^= active_hardcore_data$nalloc_sizes
     1412 	then call header_err ("area header");
     1413 	else do;
     1414 	     do i = 1 to active_hardcore_data$nalloc_sizes;
     1415 		if area.array (i).size ^= active_hardcore_data$alloc_sizes (i) then do;
     1416 		     i = active_hardcore_data$nalloc_sizes;
     1417 		     call header_err ("area header");
     1418 		     end;
     1419 	     end;
     1420 	     end;
     1421 
     1422 	if area.lw ^= sys_info$default_dir_max_length - 1 then call header_err ("area size");
     1423 
     1424 /* Check hash block structure, clear the hash table information, and mark the space used.
     1425*   If rehashing is set, the procedure hash was rehashing to a larger table size when an error was detected. */
     1426 
     1427 	dir_name_cnt = input_dir.htused;
     1428 	if ^input_dir.rehashing then do;
     1429 	     htp = ptr (source_ptr, input_dir.hash_table_rp);
     1430 
     1431 /* This code depends on being the last check in valid_header. */
     1432 /* If the return statement inside is not executed, then the */
     1433 /* control point falls through to the error message */
     1434 
     1435 	     if hash_table.size > 0			/* has to be believable */
     1436 	     then if space_free (htp, (hash_table.size)) then do;
     1437 		     do i = 1 to active_hardcore_data$num_hash_table_sizes
     1438 			while (input_dir.htsize ^= active_hardcore_data$hash_table_sizes (i));
     1439 		     end;
     1440 		     if i <= active_hardcore_data$num_hash_table_sizes then do;
     1441 			num_buckets = active_hardcore_data$hash_table_sizes (i);
     1442 			if input_dir.htused <= num_buckets | i = active_hardcore_data$num_hash_table_sizes then do;
     1443 			     i = hash_table.size;
     1444 			     if hash_table.type = HASH_TABLE_TYPE & block (i) = dir_uid then do;
     1445 				unspec (buckets) = "0"b;
     1446 				input_dir.htused = 0;
     1447 				call mark_space_used (htp, (hash_table.size));
     1448 				return ("1"b);
     1449 				end;
     1450 			     end;
     1451 			end;
     1452 		     end;
     1453 	     end;
     1454 	call error (CORRECTION, ME, "Invalid hash table found");
     1455 	rebuilding = "1"b;
     1456 	return ("1"b);
     1457 
     1458 
     1459 
     1460 
     1461 header_err:
     1462 	proc (string);
     1463 
     1464 dcl  string char (*);
     1465 
     1466 	     call error (CORRECTION, ME, "Corrected ^a in header", string);
     1467 	     rebuilding = "1"b;
     1468 
     1469 	end header_err;
     1470      end valid_header;
     1471 
     1472 setup_dir_header:
     1473      proc;
     1474 
     1475 dcl  i fixed bin;
     1476 
     1477 dcl  1 branch aligned like entry based (branch_ptr);
     1478 
     1479 	unspec (output_dir) = "0"b;
     1480 	if branch_ptr ^= null then do;
     1481 	     output_dir.owner = branch.owner;
     1482 	     output_dir.uid = branch.uid;
     1483 	     output_dir.pvid = branch.pvid;
     1484 	     output_dir.sons_lvid = branch.sons_lvid;
     1485 	     output_dir.master_dir = branch.master_dir;
     1486 	     output_dir.access_class = branch.access_class;
     1487 	     output_dir.per_process_sw = branch.per_process_sw;
     1488 	     output_dir.vtocx = branch.vtocx;
     1489 	     if input_dir.force_rpv & branch.sons_lvid = root_lvid
     1490 	     then output_dir.force_rpv = "1"b;
     1491 	     else output_dir.force_rpv = "0"b;
     1492 	     end;
     1493 
     1494 	output_dir.master_dir_uid = info.master_dir_uid;
     1495 	output_dir.tree_depth = info.tree_depth;
     1496 	output_dir.type = DIR_HEADER_TYPE;
     1497 	output_dir.size = active_hardcore_data$dir_hdrsize;
     1498 	output_dir.dts = time;
     1499 	output_dir.version_number = version_number_2;
     1500 	output_dir.arearp = bit (active_hardcore_data$dir_arearp, 18);
     1501 	i = sys_info$default_dir_max_length - fixed (output_dir.arearp, 18);
     1502 	output_area_ptr = ptr (target_ptr, active_hardcore_data$dir_arearp);
     1503 	call fs_alloc$init (output_area_ptr, i, addr (active_hardcore_data$alloc_sizes),
     1504 	     active_hardcore_data$nalloc_sizes);
     1505 	i = dir_name_cnt;
     1506 	if i < 0 | i > 5 * input_dir.htsize then i = 0;
     1507 	call allocate_dir_ht_ (target_ptr, i, (0));
     1508 
     1509      end setup_dir_header;
     1510 
     1511 /* The rebuilt version is copied into the source.  The unused portion of the last page must be cleared so that
     1512*   it will not be "recovered" in a future prodigal search.
     1513**/
     1514 copy_directory:
     1515      proc;
     1516 
     1517 dcl  num_pages fixed bin;				/* number of pages in new directory */
     1518 dcl  num_words fixed bin (18);			/* number of used words in directory. */
     1519 dcl  zero_len fixed bin;				/* number of unused words on last page */
     1520 dcl  1 copy_dir aligned based,
     1521        2 contents (num_words) bit (36) aligned,
     1522        2 zero bit (zero_len) aligned;
     1523 
     1524 	num_words = output_area_ptr -> area.lu;		/* Note: lu is NEXT available block and offsets start at 0 */
     1525 	output_area_ptr -> area.lw = sys_info$default_dir_max_length - 1;
     1526 
     1527 	num_pages = divide (num_words + 1023, 1024, 17, 0);
     1528 	if num_pages > info.current_length
     1529 	then call error (CORRECTION, ME, "Directory pages increased from ^d to ^d.", info.current_length, num_pages);
     1530 	if num_words > dir_size + 1
     1531 	then call error (CORRECTION, ME, "Directory length increased from ^d to ^d", dir_size + 1, num_words);
     1532 	zero_len = mod (num_words, 1024);
     1533 	if zero_len > 0 then do;
     1534 	     zero_len = (1024 - zero_len) * 36;
     1535 	     source_ptr -> copy_dir.zero = "0"b;
     1536 	     end;
     1537 	source_ptr -> copy_dir.contents = target_ptr -> copy_dir.contents;
     1538 
     1539 	arg_new_dir_pages = num_pages;
     1540 
     1541      end copy_directory;
     1542 
     1543 /*  This procedure supplies a unique primary name for an entry.  It is only called when rebuilding. */
     1544 get_unique_name:
     1545      proc (ep);
     1546 
     1547 dcl  ep ptr;					/* ptr to entry block */
     1548 
     1549 dcl  1 new_name aligned like names;
     1550 dcl  unique_chars_ entry (bit (*)) returns (char (15));
     1551 
     1552 	new_name.name = unique_chars_ ("0"b);
     1553 	new_name.owner = ep -> entry.uid;
     1554 	new_name.type = NAME_TYPE;
     1555 	new_name.size = active_hardcore_data$ensize;
     1556 	call move (addr (new_name), ep -> entry.name_frp, ep -> entry.name_brp, ep, (null));
     1557 	call error (LOSS, ME, "Unique name ^a supplied for ^a", new_name.name, BLOCK_NAME (fixed (ep -> entry.type, 18)));
     1558 
     1559 	ep -> entry.nnames = 1;
     1560 
     1561 
     1562      end get_unique_name;
     1563 
     1564 /* This procedure prints debugging information. */
     1565 
     1566 trace_message:
     1567      proc (string, p);
     1568 
     1569 dcl  string char (*);
     1570 dcl  p ptr;
     1571 
     1572 	call error (DUMP, ME, "salv_dir_checker_ trace information - ^a at ^p", string, p);
     1573 
     1574      end trace_message;
     1575 
     1576 cv_access:
     1577      proc (access) returns (char (32) aligned);
     1578 
     1579 dcl  access bit (72) aligned;
     1580 dcl  string char (32) aligned;
     1581 
     1582 	call display_access_class_ (access, string);
     1583 	return (string);
     1584 
     1585      end cv_access;
     1586 
     1587 /* This procedure searches the access_name list and frees any names with a zero access count.
     1588*   Unused access names occur because the access name list is recovered before any of the ACL's that reference them.
     1589**/
     1590 delete_unused_access_names:
     1591      proc (head, tail);
     1592 
     1593 dcl  head bit (18) unal;
     1594 dcl  tail bit (18) unal;
     1595 
     1596 dcl  bp ptr;
     1597 dcl  next_rp bit (18);
     1598 
     1599 	do bp = ptr (target_ptr, head) repeat ptr (target_ptr, next_rp) while (rel (bp));
     1600 
     1601 	     next_rp = bp -> access_name.frp;
     1602 	     if bp -> access_name.usage = 0 then do;
     1603 		if bp -> access_name.brp
     1604 		then ptr (target_ptr, bp -> access_name.brp) -> access_name.frp = bp -> access_name.frp;
     1605 		else head = bp -> access_name.frp;
     1606 
     1607 		if bp -> access_name.frp
     1608 		then ptr (target_ptr, bp -> access_name.frp) -> access_name.brp = bp -> access_name.brp;
     1609 		else tail = bp -> access_name.brp;
     1610 
     1611 		call fs_alloc$free (output_area_ptr, block_sizes (access_name_type), bp);
     1612 		end;
     1613 	end;
     1614 
     1615      end delete_unused_access_names;
     1616 
     1617 target: proc (dir, ent) returns (char (*));
     1618 
     1619 dcl	dir	char (*) parameter;
     1620 dcl	ent	char (*) parameter;
     1621 
     1622 	if dir = ">"
     1623 	then return (">"||ent);
     1624 	else return (rtrim(dir)||">"||ent);
     1625 
     1626      end target;
  1     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  1     2 /* Modified 8/74 for NSS */
  1     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  1     4 /* Modified 3/82 BIM for change pclock */
  1     5 /* format: style3 */
  1     6 
  1     7 /* Template for the directory header. Length = 64 words. */
  1     8 
  1     9 dcl  dp ptr;
  1    10 
  1    11 dcl 1 dir based (dp) aligned,
  1    12 
  1    13    2 modify bit (36),				/* Process ID of last modifier */
  1    14    2 type bit (18) unaligned,			/* type of object = dir header */
  1    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  1    16     2 dtc (3),					/* date-time checked by salvager array */
  1    17       3 date bit (36),				/* the date */
  1    18       3 error bit (36),				/* what errors were discovered */
  1    19 
  1    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  1    21 
  1    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  1    23 
  1    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  1    25 
  1    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  1    27 
  1    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  1    29     2 version_number fixed bin (17),			/* version number of header */
  1    30 
  1    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  1    32     2 pad2 bit (18),
  1    33 
  1    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  1    35     2 pad3 bit (18),
  1    36 
  1    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  1    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  1    39 
  1    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  1    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  1    42 
  1    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  1    44     2 dir_count fixed bin (17),			/* number of directory branches */
  1    45 
  1    46     2 lcount fixed bin (17),				/* number of links */
  1    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  1    48 
  1    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  1    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  1    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  1    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  1    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  1    54     2 pad4 bit (14),
  1    55 
  1    56     2 iacl_count (0:7),
  1    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  1    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  1    59 
  1    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  1    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  1    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  1    63 
  1    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  1    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  1    66 
  1    67     2 htsize fixed bin (17),				/* size of hash table */
  1    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  1    69 
  1    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  1    71     2 pad6 fixed bin (17),
  1    72 
  1    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  1    74     2 pad7 bit (18)) unaligned,
  1    75 
  1    76     2 dts bit (36),					/* date-time directory last salvaged */
  1    77 
  1    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  1    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  1    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  1    81     2 checksum bit (36),				/* checksummed from uid on */
  1    82     2 owner bit (36);				/* uid of parent dir */
  1    83 
  1    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  1    85 
  1    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
     1627 
  2     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
     1628 
  3     1 /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  3     2 
  3     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  3     4 
  3     5 
  3     6 dcl 1 link based (ep) aligned,
  3     7 
  3     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  3    10 
  3    11     2 type bit (18),				/* type = dir link */
  3    12     2 size fixed bin (17),				/* size of link in words */
  3    13 
  3    14     2 uid bit (36),					/* unique id of entry */
  3    15 
  3    16     2 dtem bit (36),				/* date-time entry modified */
  3    17 
  3    18     2 bs bit (1),					/* entry switch = 1 if entry */
  3    19     2 pad0 bit (17),
  3    20     2 nnames fixed bin (17),				/* number of names for this entry */
  3    21 
  3    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    24 
  3    25     2 author,					/* user who created entry */
  3    26       3 pers_rp bit (18),				/* name of user who created entry */
  3    27       3 proj_rp bit (18),				/* project of user who created entry */
  3    28 
  3    29       3 tag char (1),				/* tag of user who created entry */
  3    30       3 pad1 char (3),
  3    31 
  3    32     2 primary_name bit (504),				/* first name on name list */
  3    33 
  3    34     2 dtd bit (36),					/* date time dumped */
  3    35 
  3    36     2 pad2 bit (36),
  3    37 
  3    38 
  3    39 /* the declarations below are only applicable to links */
  3    40 
  3    41     2 pad3 bit (18),
  3    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  3    43 
  3    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  3    45 
  3    46     2 checksum bit (36),				/* checksum from uid */
  3    47 
  3    48     2 owner bit (36);				/* uid of containing directory */
  3    49 
  3    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
     1629 
  4     1 /*     BEGIN INCLUDE FILE ... dir_acl.incl.pl1 ... last modified Nov 1975 for nss */
  4     2 
  4     3 /* Template for an ACL entry. Length = 8 words */
  4     4 
  4     5 dcl aclep ptr;
  4     6 
  4     7 dcl 1 acl_entry based (aclep) aligned,			/* length is 8 words */
  4     8     2 frp bit(18) unaligned,				/* rel ptr to next entry */
  4     9     2 brp bit(18) unaligned,				/* rel ptr to previous entry */
  4    10 
  4    11     2 type bit (18) unaligned,			/* type = dir acl */
  4    12     2 size fixed bin (17) unaligned,			/* size of acl entry */
  4    13 
  4    14 
  4    15     2 name unaligned,				/* user name associated with this ACL entry */
  4    16         3 pers_rp bit(18) unaligned,			/* name of user */
  4    17         3 proj_rp bit(18) unaligned,			/* project of user */
  4    18         3 tag char(1) unaligned,			/* tag of user */
  4    19     2 mode bit (3) unaligned,				/* mode for userid */
  4    20     2 pad24 bit(24) unaligned,
  4    21 
  4    22     2 ex_mode bit(36),				/* extended access modes */
  4    23 
  4    24     2 checksum bit (36),				/* checksum from acl_entry.name */
  4    25     2  owner bit (36);				/* uid of owning entry */
  4    26 
  4    27 /* Template for a person or project name on ACL. Length = 14 words. */
  4    28 
  4    29 dcl 1 access_name aligned based,			/* person or project name */
  4    30     2 frp bit(18) unaligned,				/* rel ptr to next name structure */
  4    31     2 brp bit(18) unaligned,				/* rel ptr to prev name structure */
  4    32 
  4    33     2 type bit (18) unaligned,			/* type = access name */
  4    34     2 size fixed bin (17) unaligned,			/* size of access name */
  4    35 
  4    36     2 salv_flag fixed bin(17) unaligned,		/* used by salvager to check for ascii names */
  4    37     2 usage fixed bin(17) unaligned,			/* number of ACL entries that refer to this name */
  4    38 
  4    39     2 pad1 bit (36),
  4    40 
  4    41     2 name char(32) aligned,				/* person or project name itself */
  4    42 
  4    43     2 checksum bit (36),				/* checksum from salv_flag */
  4    44 
  4    45     2 owner bit (36);				/* uid of containing directory */
  4    46 
  4    47 /*     END INCLUDE FILE ... dir_acl.incl.pl1 */
     1630 
  5     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
     1631 
  6     1 /*     BEGIN INCLUDE FILE ... dir_ht.incl.pl1 */
  6     2 
  6     3 
  6     4 dcl htp ptr;
  6     5 
  6     6 dcl 1 hash_table based (htp) aligned,			/* htp = ptr(dp,active_hardcore_data$htrp) */
  6     7     2 modify bit (36) unal,
  6     8     2 type bit (18) unal,				/* type = dir hash table */
  6     9     2 size fixed bin (17) unal,			/* size of current dir hash table entry */
  6    10     2 name_rp (0:1) bit(18) unal,			/* rel ptr of name entry  */
  6    11     2 checksum bit (36) unal,
  6    12     2 owner bit (36) unal;
  6    13 						/* otherwise rel ptr to name */
  6    14 
  6    15 /*     END INCLUDE FILE ... dir_ht.incl.pl1 */
     1632 
  7     1 /*     BEGIN INCLUDE FILE ... dir_allocation_area.incl.pl1 ... last modified December 1973 */
  7     2 
  7     3 dcl  areap ptr;
  7     4 
  7     5 dcl 1 area based (areap) aligned,
  7     6     2 nsizes fixed bin (18),				/* Number of types. */
  7     7     2 lu fixed bin (18),				/* Next available word in area. */
  7     8     2 lw fixed bin (18),				/* Last usable word. */
  7     9     2 array (100) aligned,				/* Array of types. */
  7    10       3 fptr bit (18) unaligned,			/* Free pointer for this size. */
  7    11       3 size fixed bin (17) unaligned;			/* Size. */
  7    12 
  7    13 /*     END INCLUDE FILE ... dir_allocation_area.incl.pl1 */
     1633 
  8     1 /* BEGIN INCLUDE FILE . . . salv_args */
  8     2 /* Keith Loepere made pathname unal November 1984. */
  8     3 
  8     4 dcl 1 salv_args aligned based,
  8     5     2 temp1_ptr ptr,				/* ptr to temp segment */
  8     6     2 temp2_ptr ptr,				/* ptr to temp segment */
  8     7     2 salv_time bit (36) aligned,			/* Highest valid date/time  */
  8     8     2 options aligned,
  8     9       3 force_rebuild bit (1) unal,			/* ON, if should rebuild directory */
  8    10       3 print_trace bit (1) unal,			/* ON, if debugging trace information should be printed. */
  8    11       3 correct_oosw bit (1) unal,			/* ON, if directory's out-of-service switch should be reset */
  8    12       3 check_vtoce bit (1) unal,			/* ON, if VTOC entries of all branches should be checked. */
  8    13       3 dump bit (1) unal,				/* ON, if should dump directory on error condition */
  8    14       3 compact bit (1) unal,				/* ON, to force rebuild if one pages can be recovered. */
  8    15       3 delete_connection_failure bit (1) unal,		/* ON, to delete branches that have no VTOC entries */
  8    16       3 pad bit (29),
  8    17     2 branch_ptr ptr,				/* ptr to branch for directory */
  8    18     2 current_length fixed bin,			/* number of pages in directory */
  8    19     2 pathname char (168) unal,			/* pathname of directory being salvaged */
  8    20     2 master_dir_uid bit (36) aligned,			/* master UID for this directory */
  8    21     2 tree_depth fixed bin;				/* number of levels from root for this directory */
  8    22 
  8    23 /* END INCLUDE FILE . . . salv_args */
     1634 
  9     1 /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  9     2 
  9     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  9     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  9     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  9     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  9     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  9     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  9     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  9    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  9    11 
  9    12 dcl  access_name_type fixed bin static options (constant) init (1);
  9    13 dcl  acle_type fixed bin static options (constant) init (2);
  9    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  9    15 dcl  dir_type fixed bin static options (constant) init (4);
  9    16 dcl  link_type fixed bin static options (constant) init (5);
  9    17 dcl  name_type fixed bin static options (constant) init (6);
  9    18 dcl  seg_type fixed bin static options (constant) init (7);
  9    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  9    20 
  9    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
     1635 
 10     1 /*     BEGIN INCLUDE FILE ... salv_data.incl.pl1 ... last modified July 1982 */
 10     2 
 10     3 dcl  salv_data$debug bit (1) aligned external;		/* ON, For additional debugging messages. */
 10     4 dcl  salv_data$dump bit (1) aligned external;		/* ON, to dump bad directories and VTOC entries. */
 10     5 dcl  salv_data$lock bit (36) external aligned;		/* lock to prevent more than one process from using salv_data. */
 10     6 dcl  salv_data$on_line bit (1) aligned external;		/* ON, for online salvage. */
 10     7 dcl  salv_data$print_path bit (1) aligned external;	/* ON, if pathname of each directory should be printed. */
 10     8 dcl  salv_data$printer_delay fixed bin aligned external;	/* Number of minutes to wait for a not ready printer. */
 10     9 dcl  salv_data$rpv bit (1) aligned external;		/* ON, for root physical volume salvage. */
 10    10 dcl  salv_data$vol_read_ahead fixed bin external;
 10    11 
 10    12 
 10    13 /*     END INCLUDE FILE ... salv_data.incl.pl1 ... */
     1636 
 11     1 /* BEGIN INCLUDE FILE sys_log_constants.incl.pl1 ... 82-09-24 E. N. Kittlitz */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(87-04-22,GDixon), approve(87-06-10,MCR7708),
 11     6*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 11     7*     Added sl_info structure and associated named constants for use in calling
 11     8*     sys_log_$general.
 11     9*                                                   END HISTORY COMMENTS */
 11    10 
 11    11 
 11    12 /* format: style4 */
 11    13 
 11    14 dcl  (
 11    15      SL_TYPE_CRASH init (-3),				/* type message with banner & kill system */
 11    16      SL_TYPE_BEEP init (-2),				/* type message with banner */
 11    17      SL_TYPE init (-1),				/* type message */
 11    18      SL_LOG_SILENT init (0),				/* log message */
 11    19      SL_LOG init (1),				/* log & type message */
 11    20      SL_LOG_BEEP init (2),				/* log & type message with banner */
 11    21      SL_LOG_CRASH init (3)				/* log & type message with banner & kill system */
 11    22      ) fixed bin internal static options (constant);
 11    23 
 11    24 dcl  1 sl_info aligned automatic,
 11    25        2 version char(8),			/* structure version       */
 11    26        2 arg_list_ptr ptr,			/* arg_list with values    */
 11    27        2 loc,
 11    28          3 (mode, severity, code, caller, data, class, ioa_msg) fixed bin,
 11    29            /* These flags control where the corresponding data item is found.*/
 11    30 	 /*  -1: data appears in the corresponding structure element below */
 11    31 	 /*   0: data is not present anywhere			       */
 11    32 	 /*  +N: data is Nth item in argument list pointed to by 	       */
 11    33 	 /*      sl_info.arg_list_ptr.  Upon return, data copied into      */
 11    34 	 /*      corresponding structure element.		       */
 11    35 	 /*  if data = +N:					       */
 11    36 	 /*      argN is data_ptr, argN+1 is data_len		       */
 11    37 	 /*  if ioa_msg = +N:				       */
 11    38 	 /*      argN+1, ... argLAST are arguments substituted into the    */
 11    39 	 /*      ioa_msg control string.  The formatted msg is returned.   */
 11    40        2 flags,
 11    41          3 ioa_msg_is_error_code bit(1) unal,	/* ioa_ctl is error code.  */
 11    42          3 flags_pad bit(35) unal,
 11    43        2 mode fixed bin,			/* as-mode, command-mode   */
 11    44        2 severity fixed bin,			/* error severity	       */
 11    45        2 code fixed bin(35),			/* error table code        */
 11    46        2 caller char(65) varying,		/* caller refname$entryname*/
 11    47        2 data,				/* binary data ptr/length  */
 11    48          3 data_ptr ptr,
 11    49          3 data_lth fixed bin(21),
 11    50        2 class char(10) varying,		/* binary data class       */
 11    51        2 ioa_msg char(500) varying;		/* formatted message text  */
 11    52 
 11    53 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    54 /*							       */
 11    55 /* If data values (eg, sl_info.caller) are passed in the argument list,      */
 11    56 /* their data types should be as shown in the structure above, except that   */
 11    57 /* character strings should be char(*) nonvarying.		       */
 11    58 /*							       */
 11    59 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    60 
 11    61 /* value for sl_info.version */
 11    62 dcl  SL_INFO_version_1 char (8) int static options(constant) init("sl_info1");
 11    63 
 11    64 /* values for sl_info.mode */
 11    65 dcl (SL_INFO_as_mode init(1),
 11    66      SL_INFO_command_mode init(2)) fixed bin int static options(constant);
 11    67 
 11    68 /* values for sl_info.loc.(severity code caller data class ioa_ctl arg) */
 11    69 dcl (SL_INFO_arg_given_in_structure init(-1),
 11    70      SL_INFO_arg_not_given init(0)) fixed bin int static options(constant);
 11    71 
 11    72 
 11    73 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    74 /*							       */
 11    75 /* The following static structures are commonly used in the Login Server     */
 11    76 /* user control software.					       */
 11    77 /*							       */
 11    78 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    79 
 11    80 /* Syntax: call Abort (severity, code, ioa_ctl, args);		       */
 11    81 
 11    82 dcl  1 sl_info_sev_code_msg		aligned int static options(constant),
 11    83        2 version char(8)		init ("sl_info1"),
 11    84        2 arg_list_ptr ptr		init (null),
 11    85        2 loc,
 11    86          3 (mode			init (-1),
 11    87 	  severity  		init ( 1),
 11    88 	  code 			init ( 2),
 11    89 	  caller 			init (-1),
 11    90 	  data 			init ( 0),
 11    91 	  class 			init ( 0),
 11    92 	  ioa_msg			init ( 3)) fixed bin,
 11    93        2 flags,
 11    94          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 11    95          3 flags_pad bit(35) unal	init ("0"b),
 11    96        2 mode fixed bin		init ( 1),
 11    97        2 severity fixed bin		init ( 0),
 11    98        2 code fixed bin(35)		init ( 0),
 11    99        2 caller char(65) varying	init (""),
 11   100        2 data,
 11   101          3 data_ptr ptr		init (null),
 11   102          3 data_lth fixed bin(21)	init ( 0),
 11   103        2 class char(10) varying	init (""),
 11   104        2 ioa_msg char(500) varying	init ("");
 11   105 
 11   106 /* Syntax: call Abort (severity, ioa_ctl, args);			       */
 11   107 
 11   108 dcl  1 sl_info_sev_msg		aligned int static options(constant),
 11   109        2 version char(8)		init ("sl_info1"),
 11   110        2 arg_list_ptr ptr		init (null),
 11   111        2 loc,
 11   112          3 (mode			init (-1),
 11   113 	  severity  		init ( 1),
 11   114 	  code 			init ( 0),
 11   115 	  caller 			init (-1),
 11   116 	  data 			init ( 0),
 11   117 	  class 			init ( 0),
 11   118 	  ioa_msg			init ( 2)) fixed bin,
 11   119        2 flags,
 11   120          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 11   121          3 flags_pad bit(35) unal	init ("0"b),
 11   122        2 mode fixed bin		init ( 1),
 11   123        2 severity fixed bin		init ( 0),
 11   124        2 code fixed bin(35)		init ( 0),
 11   125        2 caller char(65) varying	init (""),
 11   126        2 data,
 11   127          3 data_ptr ptr		init (null),
 11   128          3 data_lth fixed bin(21)	init ( 0),
 11   129        2 class char(10) varying	init (""),
 11   130        2 ioa_msg char(500) varying	init ("");
 11   131 
 11   132 /* Syntax: call Abort (severity, ioa_ctl_as_error_code, args);	       */
 11   133 
 11   134 dcl  1 sl_info_sev_coded_msg		aligned int static options(constant),
 11   135        2 version char(8)		init ("sl_info1"),
 11   136        2 arg_list_ptr ptr		init (null),
 11   137        2 loc,
 11   138          3 (mode			init (-1),
 11   139 	  severity  		init ( 1),
 11   140 	  code 			init ( 0),
 11   141 	  caller 			init (-1),
 11   142 	  data 			init ( 0),
 11   143 	  class 			init ( 0),
 11   144 	  ioa_msg			init ( 2)) fixed bin,
 11   145        2 flags,
 11   146          3 ioa_msg_is_error_code bit(1) unal init ("1"b),
 11   147          3 flags_pad bit(35) unal	init ("0"b),
 11   148        2 mode fixed bin		init ( 1),
 11   149        2 severity fixed bin		init ( 0),
 11   150        2 code fixed bin(35)		init ( 0),
 11   151        2 caller char(65) varying	init (""),
 11   152        2 data,
 11   153          3 data_ptr ptr		init (null),
 11   154          3 data_lth fixed bin(21)	init ( 0),
 11   155        2 class char(10) varying	init (""),
 11   156        2 ioa_msg char(500) varying	init ("");
 11   157 
 11   158 
 11   159 /* Syntax: call Abort (severity, code, error_return_label, ioa_ctl, args);   */
 11   160 
 11   161 dcl  1 sl_info_sev_code_label_msg	aligned int static options(constant),
 11   162        2 version char(8)		init ("sl_info1"),
 11   163        2 arg_list_ptr ptr		init (null),
 11   164        2 loc,
 11   165          3 (mode			init (-1),
 11   166 	  severity  		init ( 1),
 11   167 	  code 			init ( 2),
 11   168 	  caller 			init (-1),
 11   169 	  data 			init ( 0),
 11   170 	  class 			init ( 0),
 11   171 	  ioa_msg			init ( 4)) fixed bin,
 11   172        2 flags,
 11   173          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 11   174          3 flags_pad bit(35) unal	init ("0"b),
 11   175        2 mode fixed bin		init ( 1),
 11   176        2 severity fixed bin		init ( 0),
 11   177        2 code fixed bin(35)		init ( 0),
 11   178        2 caller char(65) varying	init (""),
 11   179        2 data,
 11   180          3 data_ptr ptr		init (null),
 11   181          3 data_lth fixed bin(21)	init ( 0),
 11   182        2 class char(10) varying	init (""),
 11   183        2 ioa_msg char(500) varying	init ("");
 11   184 
 11   185 /* Syntax:  call Log_error (code, ioa_ctl, args);			       */
 11   186 
 11   187 dcl  1 sl_info_code_msg		aligned int static options(constant),
 11   188        2 version char(8)		init ("sl_info1"),
 11   189        2 arg_list_ptr ptr		init (null),
 11   190        2 loc,
 11   191          3 (mode			init (-1),
 11   192 	  severity  		init (-1),
 11   193 	  code 			init ( 1),
 11   194 	  caller 			init (-1),
 11   195 	  data 			init ( 0),
 11   196 	  class 			init ( 0),
 11   197 	  ioa_msg			init ( 2)) fixed bin,
 11   198        2 flags,
 11   199          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 11   200          3 flags_pad bit(35) unal	init ("0"b),
 11   201        2 mode fixed bin		init ( 1),
 11   202        2 severity fixed bin		init ( 0),
 11   203        2 code fixed bin(35)		init ( 0),
 11   204        2 caller char(65) varying	init (""),
 11   205        2 data,
 11   206          3 data_ptr ptr		init (null),
 11   207          3 data_lth fixed bin(21)	init ( 0),
 11   208        2 class char(10) varying	init (""),
 11   209        2 ioa_msg char(500) varying	init ("");
 11   210 
 11   211 
 11   212 /* Syntax:  call Trace (ioa_ctl, args);				       */
 11   213 
 11   214 dcl  1 sl_info_msg			aligned int static options(constant),
 11   215        2 version char(8)		init ("sl_info1"),
 11   216        2 arg_list_ptr ptr		init (null),
 11   217        2 loc,
 11   218          3 (mode			init (-1),
 11   219 	  severity  		init (-1),
 11   220 	  code 			init ( 0),
 11   221 	  caller 			init (-1),
 11   222 	  data 			init ( 0),
 11   223 	  class 			init ( 0),
 11   224 	  ioa_msg			init ( 1)) fixed bin,
 11   225        2 flags,
 11   226          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 11   227          3 flags_pad bit(35) unal	init ("0"b),
 11   228        2 mode fixed bin		init ( 1),
 11   229        2 severity fixed bin		init ( 0),
 11   230        2 code fixed bin(35)		init ( 0),
 11   231        2 caller char(65) varying	init (""),
 11   232        2 data,
 11   233          3 data_ptr ptr		init (null),
 11   234          3 data_lth fixed bin(21)	init ( 0),
 11   235        2 class char(10) varying	init (""),
 11   236        2 ioa_msg char(500) varying	init ("");
 11   237 
 11   238 /* END INCLUDE FILE sys_log_constants.incl.pl1 */
     1637 
 12     1 /* BEGIN INCLUDE FILE its.incl.pl1
 12     2*   modified 27 July 79 by JRDavis to add its_unsigned
 12     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 12     4 
 12     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 12     6     2 pad1 bit (3) unaligned,
 12     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 12     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 12     9     2 pad2 bit (9) unaligned,
 12    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 12    11 
 12    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 12    13     2 pad3 bit (3) unaligned,
 12    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 12    15     2 pad4 bit (3) unaligned,
 12    16     2 mod bit (6) unaligned;				/* further modification */
 12    17 
 12    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 12    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 12    20     2 pad1 bit (27) unaligned,
 12    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 12    22 
 12    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 12    24     2 pad2 bit (3) unaligned,
 12    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 12    26     2 pad3 bit (3) unaligned,
 12    27     2 mod bit (6) unaligned;				/* further modification */
 12    28 
 12    29 
 12    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 12    31     2 pad1 bit (3) unaligned,
 12    32     2 segno fixed bin (15) unsigned unaligned,
 12    33     2 ringno fixed bin (3) unsigned unaligned,
 12    34     2 pad2 bit (9) unaligned,
 12    35     2 its_mod bit (6) unaligned,
 12    36 
 12    37     2 offset fixed bin (18) unsigned unaligned,
 12    38     2 pad3 bit (3) unaligned,
 12    39     2 bit_offset fixed bin (6) unsigned unaligned,
 12    40     2 pad4 bit (3) unaligned,
 12    41     2 mod bit (6) unaligned;
 12    42 
 12    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 12    44     2 pr_no fixed bin (3) unsigned unaligned,
 12    45     2 pad1 bit (27) unaligned,
 12    46     2 itp_mod bit (6) unaligned,
 12    47 
 12    48     2 offset fixed bin (18) unsigned unaligned,
 12    49     2 pad2 bit (3) unaligned,
 12    50     2 bit_offset fixed bin (6) unsigned unaligned,
 12    51     2 pad3 bit (3) unaligned,
 12    52     2 mod bit (6) unaligned;
 12    53 
 12    54 
 12    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 12    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 12    57 
 12    58 /* END INCLUDE FILE   its.incl.pl1 */
     1638 
 13     1 /* begin include file - access_audit_eventflags.incl.pl1 */
 13     2 /* NOTE: This include file has an ALM counterpart made with cif.
 13     3*Keep it up to date. */
 13     4 
 13     5 dcl 1 audit_event_flags	based aligned,
 13     6       2 special_op	bit (1) unal,  /* special sys operation */
 13     7       2 grant	bit (1) unal,  /* operation was successful */
 13     8       2 admin_op	bit (1) unal,  /* administrative operation */
 13     9       2 priv_op	bit (1) unal,  /* privileged operation */
 13    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
 13    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
 13    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
 13    13       2 pad	bit (29) unal;
 13    14 
 13    15 /* end include file - access_audit_eventflags.incl.pl1 */
     1639 
     1640 
     1641 /* BEGIN MESSAGE DOCUMENTATION
     1642*
     1643*   Message:
     1644*   AUDIT (salv_dir_checker_): GRANTED modification of fs_obj access ADDED_INFO
     1645*
     1646*   S: $access_audit
     1647*
     1648*   T: Salvaging
     1649*
     1650*   M: The salvager has truncated the ACL of a branch.
     1651*
     1652*   A: $inform_ssa
     1653*
     1654*
     1655*   Message:
     1656*   ADUIT (salv_dir_checker_): GRANTED modification of security out-of-service ADDED_INFO
     1657*
     1658*   S: $access_audit
     1659*
     1660*   T: Salvaging
     1661*
     1662*   M: The security-out-of-service switch has been set on
     1663*   a directory because of an AIM error.  The access class of
     1664*   a branch was not equal to that of the containing directory,
     1665*   or the access class in the directory's branch was not equal
     1666*   to the access class stored in its header.
     1667*
     1668*   A: $inform_ssa
     1669*
     1670*
     1671*   Message:
     1672*   salv_dir_checker_: MESSAGE.
     1673*
     1674*   S:     $log
     1675*
     1676*   T:     Salvaging
     1677*
     1678*   M:     Various messages are printed by salv_dir_checker_ indicating
     1679*   what salvaging is taking place--ACL counts being changed, entry counts
     1680*   being changed, unique names supplied for segments with invalid names,
     1681*   etc.
     1682*
     1683*   A:     $ignore
     1684*
     1685*   END MESSAGE DOCUMENTATION */
     1686 
     1687      end salv_dir_checker_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0808.0  salv_dir_checker_.pl1             >spec>install>1112>salv_dir_checker_.pl1
1627         1    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
1628         2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
1629         3    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
1630         4    04/29/76  1048.9  dir_acl.incl.pl1                  >ldd>include>dir_acl.incl.pl1
1631         5    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
1632         6    11/02/76  1414.6  dir_ht.incl.pl1                   >ldd>include>dir_ht.incl.pl1
1633         7    10/15/76  1242.9  dir_allocation_area.incl.pl1      >ldd>include>dir_allocation_area.incl.pl1
1634         8    01/30/85  1523.9  salv_args.incl.pl1                >ldd>include>salv_args.incl.pl1
1635         9    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
1636        10    10/25/82  1015.6  salv_data.incl.pl1                >ldd>include>salv_data.incl.pl1
1637        11    08/06/87  0913.5  sys_log_constants.incl.pl1        >ldd>include>sys_log_constants.incl.pl1
1638        12    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
1639        13    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCESS_NAME_TYPE                       constant        bit(18)                  initial packed unaligned dcl 9-3 ref 1026
BLOCK_NAME                      000043 constant        char(20)                 initial array packed unaligned dcl 159 set ref 471*
                                                                                  508* 561* 569* 731 773 886* 891* 900* 1557*
CORRECTION                      000226 constant        fixed bin(17,0)          initial dcl 161 set ref 390* 489* 501* 508* 513*
                                                                                  561* 569* 871* 886* 891* 900* 967* 1454* 1466*
                                                                                  1528* 1530*
DIR_HEADER_TYPE                        constant        bit(18)                  initial packed unaligned dcl 9-5 ref 1403 1496
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 9-6 ref 512 607 832
                                                                                  1021
DUMP                            000232 constant        fixed bin(17,0)          initial dcl 162 set ref 1572*
HASH_TABLE_TYPE                        constant        bit(18)                  initial packed unaligned dcl 9-10 ref 1444
INVALID_RP                      000121 constant        bit(18)                  initial packed unaligned dcl 164 set ref 281 297 608
                                                                                  635* 643 721 740 897
LINK_TYPE                              constant        bit(18)                  initial packed unaligned dcl 9-7 ref 567 607 837
                                                                                  1021
LOSS                            000230 constant        fixed bin(17,0)          initial dcl 165 set ref 213* 223* 231* 327* 331*
                                                                                  335* 340* 407* 421* 431* 447* 471* 481* 484* 504*
                                                                                  524* 544* 933* 935* 957* 959* 979* 1373* 1391*
                                                                                  1557*
ME                              000036 constant        char(17)                 initial packed unaligned dcl 166 set ref 213* 223*
                                                                                  231* 327* 331* 335* 340* 390* 407* 421* 431* 447*
                                                                                  471* 481* 484* 489* 501* 504* 508* 513* 524* 544*
                                                                                  561* 569* 871* 886* 891* 900* 933* 935* 957* 959*
                                                                                  967* 979* 987* 1043* 1256* 1294* 1373* 1391* 1454*
                                                                                  1466* 1528* 1530* 1557* 1572*
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 9-8 ref 613 1227 1249
                                                                                  1554
ONES                            000010 internal static char(1024)               dcl 115 set ref 1018 1133* 1133
SEG_TYPE                               constant        bit(18)                  initial packed unaligned dcl 9-9 ref 607 835 1021
SL_LOG_CRASH                    000223 constant        fixed bin(17,0)          initial dcl 11-14 set ref 182*
SYSTEM                          000220 constant        fixed bin(17,0)          initial dcl 167 set ref 987* 1043* 1256* 1294*
a_code                          000254 automatic       fixed bin(35,0)          dcl 625 in procedure "restore_name" set ref 650* 651
a_code                          000340 automatic       fixed bin(35,0)          dcl 920 in procedure "check_contents" set ref 975*
                                                                                  976 985* 986
a_count                                parameter       fixed bin(17,0)          dcl 677 set ref 667 791*
a_entry_p                              parameter       pointer                  dcl 674 ref 667 703
a_new_head                             parameter       bit(18)                  packed unaligned dcl 678 set ref 667 705 788*
a_new_owner_bp                         parameter       pointer                  dcl 675 ref 667 701
a_new_p                                parameter       pointer                  dcl 1270 set ref 1266 1291* 1300
a_new_tail                             parameter       bit(18)                  packed unaligned dcl 679 set ref 667 706 789*
a_old_p                                parameter       pointer                  dcl 1269 ref 1266 1281 1300
a_p                                    parameter       pointer                  dcl 1060 ref 1057 1065
a_type_expected                        parameter       fixed bin(17,0)          dcl 676 ref 667 702
acc_name_$encode                000424 constant        entry                    external dcl 123 ref 1291
access                                 parameter       bit(72)                  dcl 1579 set ref 1576 1582*
access_audit_$log_obj_class     000426 constant        entry                    external dcl 124 ref 433 546
access_class             33            based           bit(72)                  level 2 in structure "branch" dcl 1477 in procedure
                                                                                  "setup_dir_header" ref 1486
access_class             33            based           bit(72)                  level 2 in structure "branch" dcl 1351 in procedure
                                                                                  "valid_header" set ref 1387 1391* 1391*
access_class             13            based           bit(72)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1486*
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "salv_dir_checker_" set ref 433* 533 539* 541*
                                                                                  544* 544* 546* 550* 550
access_class             13            based           bit(72)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" set ref 1390
                                                                                  1391* 1391*
access_name                            based           structure                level 1 dcl 4-29
access_name_type                000225 constant        fixed bin(17,0)          initial dcl 9-12 set ref 199* 202* 757 1085 1131
                                                                                  1611
access_operations_$fs_obj_access_mod
                                000432 external static bit(36)                  dcl 127 set ref 433*
access_operations_$fs_obj_set_soos
                                000430 external static bit(36)                  dcl 126 set ref 546*
acl_brp                  36(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 374*
                                                                                  427* 427*
acl_entry                              based           structure                level 1 dcl 4-7
acl_frp                  36            based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 374*
                                                                                  427* 427*
acl_info                        000507 automatic       structure                level 1 dcl 1273 set ref 1291 1291
acle_count               35(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-8 set ref 429
                                                                                  431* 433* 438* 450*
acle_total               23(18)        based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 230 231* 232*
acle_total               23(18)        based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 236* 759* 759
acle_type                       000230 constant        fixed bin(17,0)          initial dcl 9-13 set ref 210* 220* 427* 737 755 1130
active_hardcore_data$aclsize    000444 external static fixed bin(17,0)          dcl 132 ref 1130
active_hardcore_data$alloc_sizes
                                000434 external static fixed bin(17,0)          array dcl 128 set ref 864 866 1415 1503 1503
active_hardcore_data$dir_arearp 000446 external static fixed bin(18,0)          dcl 133 ref 1154 1406 1410 1500 1502
active_hardcore_data$dir_hdrsize
                                000436 external static fixed bin(17,0)          dcl 129 ref 1128 1132 1404 1497
active_hardcore_data$elcsize    000442 external static fixed bin(17,0)          dcl 131 ref 863
active_hardcore_data$ensize     000450 external static fixed bin(17,0)          dcl 134 ref 1131 1555
active_hardcore_data$esize      000452 external static fixed bin(17,0)          dcl 135 ref 1129
active_hardcore_data$hash_table_sizes
                                000440 external static fixed bin(17,0)          array dcl 130 ref 1437 1441
active_hardcore_data$nalloc_sizes
                                000454 external static fixed bin(17,0)          dcl 136 set ref 864 1132 1411 1414 1416 1503*
active_hardcore_data$num_hash_table_sizes
                                000456 external static fixed bin(17,0)          dcl 137 ref 1437 1440 1442
addr                                                   builtin function         dcl 155 ref 388 391 416 416 431 442 442 451 451 451
                                                                                  451 453 453 457 457 457 457 460 460 477 477 649
                                                                                  649 755 755 755 755 929 929 944 944 952 952 975
                                                                                  975 1023 1180 1181 1181 1183 1197 1197 1228 1291
                                                                                  1291 1503 1503 1556 1556
aim_check_$equal                000460 constant        entry                    external dcl 138 ref 541
aim_check_$greater_or_equal     000462 constant        entry                    external dcl 139 ref 539
allocate_dir_ht_                000464 constant        entry                    external dcl 140 ref 1507
area                                   based           structure                level 1 dcl 7-5
areap                           000146 automatic       pointer                  dcl 7-3 set ref 1323* 1326 1327 1329 1330 1331 1333
                                                                                  1410* 1411 1415 1422
arearp                   24            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1323 1406
arearp                   24            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1500* 1501
arg_bp                                 parameter       pointer                  dcl 915 ref 912 925
arg_ep                                 parameter       pointer                  dcl 349 ref 346 357
arg_new_dir_pages                      parameter       fixed bin(17,0)          dcl 69 set ref 27 186* 1539*
arg_salv_ptr                           parameter       pointer                  dcl 70 ref 27 1138
arg_set_security_oosw                  parameter       bit(1)                   dcl 71 set ref 27 244*
arg_source_ptr                         parameter       pointer                  dcl 72 ref 27 1140
arg_tp                                 parameter       pointer                  dcl 811 ref 806 825
arg_type_expected                      parameter       fixed bin(17,0)          dcl 812 ref 806 826
array                     3            based           structure                array level 2 dcl 7-5
ascii_mask                      000016 constant        structure                level 1 dcl 1108 ref 1117
audit                           000100 automatic       bit(1)                   dcl 77 set ref 433 517 1363* 1368*
audit_event_flags                      based           structure                level 1 dcl 13-5
auth_valid                      000210 automatic       bit(1)                   packed unaligned dcl 354 set ref 417* 418 457
author                    6            based           structure                level 2 packed packed unaligned dcl 2-8 set ref 416
                                                                                  416 457 457 457 457 460 460
back_rp                         000274 automatic       bit(18)                  packed unaligned dcl 683 in procedure "process_list"
                                                                                  set ref 715* 730* 740* 777*
back_rp                         000162 automatic       bit(18)                  packed unaligned dcl 263 in procedure "entry_chain"
                                                                                  set ref 275* 290* 297* 309*
bc_auth_valid                   000211 automatic       bit(1)                   packed unaligned dcl 354 set ref 443* 444 451
bc_author                37            based           structure                level 2 packed packed unaligned dcl 2-8 set ref 442
                                                                                  442 451 451 451 451 453 453
bit                                                    builtin function         dcl 155 ref 887 1406 1500
block                                  based           bit(36)                  array packed unaligned dcl 1355 in procedure
                                                                                  "valid_header" ref 1444
block                                  based           structure                level 1 dcl 820 in procedure "valid_block"
block                                  based           structure                level 1 dcl 1221 in procedure "move"
block                                  based           structure                level 1 dcl 1015 in procedure "mark_space_used"
block                                  based           structure                level 1 dcl 699 in procedure "process_list"
block                                  based           structure                level 1 dcl 591 in procedure "prodigal"
block                                  based           structure                level 1 dcl 1321 in procedure "check_free_list"
block_rp                        000275 automatic       bit(18)                  packed unaligned dcl 684 set ref 720* 721 721* 724
                                                                                  725 733* 737* 741 742 742* 744* 777 778* 781* 782
                                                                                  782*
block_sizes                     000410 internal static fixed bin(17,0)          array dcl 116 set ref 639 646* 752* 827* 889 892
                                                                                  1024 1085 1128* 1129* 1129* 1129* 1130* 1131*
                                                                                  1131* 1611*
block_template                         based           structure                level 1 dcl 103
bp                                     parameter       pointer                  dcl 1010 in procedure "mark_space_used" ref 1007
                                                                                  1017 1021 1021 1021 1023 1026
bp                              000324 automatic       pointer                  dcl 816 in procedure "valid_block" set ref 825* 827*
                                                                                  832 835 837 844 849 854 861 861 863 867* 868 869
                                                                                  872 877 883 887 889 892 897 901
bp                                     parameter       pointer                  dcl 1209 in procedure "move" ref 1206 1223 1227 1232
bp                                     parameter       pointer                  dcl 1038 in procedure "space_free" ref 1035 1045
bp                              000540 automatic       pointer                  dcl 1318 in procedure "check_free_list" set ref
                                                                                  1327* 1327* 1330* 1333* 1334
bp                              000276 automatic       pointer                  dcl 685 in procedure "process_list" set ref 725*
                                                                                  730* 731* 749* 750* 752* 754* 755 755 773* 778 781
bp                              000244 automatic       pointer                  dcl 590 in procedure "prodigal" set ref 606* 607 607
                                                                                  607 608* 609* 613 633
bp                              000642 automatic       pointer                  dcl 1596 in procedure "delete_unused_access_names"
                                                                                  set ref 1599* 1599* 1601 1602 1603 1603 1603 1605
                                                                                  1607 1607 1607 1609 1611*
bp                              000342 automatic       pointer                  dcl 921 in procedure "check_contents" set ref 925*
                                                                                  929 929 929 929 933 937 944 944 952 952 952 952
                                                                                  957 965 967 968 975 975 979 985* 987
branch                                 based           structure                level 1 dcl 1477 in procedure "setup_dir_header"
branch                                 based           structure                level 1 dcl 1351 in procedure "valid_header"
branch_ptr               10            based           pointer                  level 2 in structure "info" dcl 109 in procedure
                                                                                  "salv_dir_checker_" ref 1139
branch_ptr                      000102 automatic       pointer                  dcl 78 in procedure "salv_dir_checker_" set ref
                                                                                  1139* 1362 1372 1380 1381 1382 1383 1384 1386 1387
                                                                                  1391 1391 1480 1481 1482 1483 1484 1485 1486 1487
                                                                                  1488 1489
brp                       0(18)        based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 699 in procedure "process_list" ref 781
brp                       0(18)        based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1221 in procedure "move" set ref 1237* 1240*
brp                       0(18)        based           bit(18)                  level 2 in structure "access_name" packed packed
                                                                                  unaligned dcl 4-29 in procedure
                                                                                  "salv_dir_checker_" set ref 1603 1603 1607* 1607
                                                                                  1609
brp                       0(18)        based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 820 in procedure "valid_block" set ref 897
                                                                                  901*
brp_expected                           parameter       bit(18)                  packed unaligned dcl 814 ref 806 897 897 901
bs                        4            based           bit(1)                   level 2 in structure "link" packed packed unaligned
                                                                                  dcl 3-6 in procedure "salv_dir_checker_" set ref
                                                                                  490*
bs                        4            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "salv_dir_checker_" set ref
                                                                                  374 426 488 507 510*
buckets                   2            based           bit(18)                  array level 2 packed packed unaligned dcl 1356 set
                                                                                  ref 1445*
check_access_names              000104 automatic       bit(1)                   dcl 79 set ref 233* 237 1069* 1075* 1143*
code                            000472 automatic       fixed bin(35,0)          dcl 1215 in procedure "move" set ref 1230* 1255*
                                                                                  1256
code                            000300 automatic       fixed bin(17,0)          dcl 686 in procedure "process_list" set ref 750* 751
code                                   parameter       fixed bin(17,0)          dcl 1062 in procedure "check_acl_ref" set ref 1057
                                                                                  1066* 1068* 1073 1075 1087*
code                                   parameter       fixed bin(17,0)          dcl 918 in procedure "check_contents" set ref 912
                                                                                  924* 929* 931 933 937* 944* 952* 954 957 977*
code                            000206 automatic       fixed bin(17,0)          dcl 352 in procedure "process_entry" set ref 361
                                                                                  416* 417 419* 442* 443 445* 465* 469* 477* 478 481
code                            000242 automatic       fixed bin(17,0)          dcl 589 in procedure "prodigal" set ref 644* 645
code                                   parameter       fixed bin(17,0)          dcl 1103 in procedure "ascii_check" set ref 1098
                                                                                  1117* 1119* 1121*
code                            000462 automatic       fixed bin(17,0)          dcl 1177 in procedure "entry_name" set ref 1181*
                                                                                  1182
code35                          000506 automatic       fixed bin(35,0)          dcl 1272 set ref 1291* 1293 1294*
compact                   5(05)        based           bit(1)                   level 3 packed packed unaligned dcl 109 ref 189
contents                               based           bit(36)                  array level 2 dcl 1520 set ref 1537* 1537
control_string                         parameter       char                     packed unaligned dcl 1191 ref 1188
copy                                                   builtin function         dcl 155 in procedure "salv_dir_checker_" ref 1133
copy                                   based           bit(36)                  array dcl 1220 in procedure "move" set ref 1232*
                                                                                  1232
copy_dir                               based           structure                level 1 dcl 1520
correct_oosw                    000105 automatic       bit(1)                   dcl 80 in procedure "salv_dir_checker_" set ref 500
                                                                                  1145*
correct_oosw              5(02)        based           bit(1)                   level 3 in structure "info" packed packed unaligned
                                                                                  dcl 109 in procedure "salv_dir_checker_" ref 1145
count                           000212 automatic       fixed bin(17,0)          dcl 355 in procedure "process_entry" set ref 393*
                                                                                  397 400* 405 407* 409 411 412 427* 429 431* 433*
                                                                                  438 440 450
count                           000301 automatic       fixed bin(17,0)          dcl 687 in procedure "process_list" set ref 713*
                                                                                  771* 771 791
count                           000106 automatic       fixed bin(17,0)          dcl 81 in procedure "salv_dir_checker_" set ref 199*
                                                                                  202* 210* 212 213* 215 217 218 220* 222 223* 225
                                                                                  227 228
current_length           12            based           fixed bin(17,0)          level 2 dcl 109 set ref 1155 1155 1155 1528 1528*
dir                                    parameter       char                     packed unaligned dcl 1619 in procedure "target" ref
                                                                                  1617 1622 1624
dir                      25(18)        based           fixed bin(17,0)          array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 227*
dir                                    based           structure                level 1 dcl 1-11 in procedure "salv_dir_checker_"
dir                      25(18)        based           fixed bin(17,0)          array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 222 223* 225*
dir_access_class                000110 automatic       bit(72)                  dcl 82 set ref 539* 541* 544* 544* 546* 546* 1387*
                                                                                  1390
dir_acl_cnt                     000112 automatic       fixed bin(17,0)          dcl 83 set ref 194* 218* 218 228* 228 230 231* 232
                                                                                  236 440* 440
dir_brp                  36(18)        based           bit(18)                  array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 220*
dir_brp                  36(18)        based           bit(18)                  array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 220*
dir_cnt                         000163 automatic       fixed bin(17,0)          dcl 264 set ref 273* 330 331* 332 383* 383
dir_count                22(18)        based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 330 331* 332*
dir_count                22(18)        based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 379* 379
dir_frp                  36            based           bit(18)                  array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 220*
dir_frp                  36            based           bit(18)                  array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 220*
dir_header_type                        constant        fixed bin(17,0)          initial dcl 9-14 ref 1128
dir_name_cnt                    000113 automatic       fixed bin(17,0)          dcl 84 set ref 319 339 340* 1374* 1427* 1505
dir_size                        000114 automatic       fixed bin(17,0)          dcl 85 set ref 250 599 600 600 605 639 640 1018 1022
                                                                                  1024 1026 1046 1049 1050 1085 1085 1154* 1155 1155
                                                                                  1155* 1157 1530 1530
dir_type                               constant        fixed bin(17,0)          initial dcl 9-15 ref 379 383 514 832 1129
dir_uid                         000115 automatic       bit(36)                  dcl 86 set ref 290* 608* 635* 712 1365* 1386* 1444
directory_space                        based           char                     dcl 108 set ref 250* 600 640 1018* 1022* 1024* 1026*
                                                                                  1049 1050 1085 1157*
dirsw                    32            based           bit(1)                   level 2 packed packed unaligned dcl 2-8 set ref 499
                                                                                  512 514* 521
display_access_class_           000466 constant        entry                    external dcl 141 ref 1582
divide                                                 builtin function         dcl 155 ref 863 1527
dtd                      26            based           bit(36)                  level 2 packed packed unaligned dcl 2-8 set ref 568
                                                                                  571*
dtem                      3            based           bit(36)                  level 2 dcl 2-8 set ref 559 559 560 564*
dts                      60            based           bit(36)                  level 2 dcl 111 set ref 1498*
ebrp                      0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-8 ref 313 1251
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 310
                                                                                  1252* 1258*
ent                                    parameter       char                     packed unaligned dcl 1620 ref 1617 1622 1624
entry                                  based           structure                level 1 dcl 2-8
entry_bp                               parameter       pointer                  dcl 1212 ref 1206 1228 1251 1258 1259
entry_p                                parameter       pointer                  dcl 917 in procedure "check_contents" ref 912 965
                                                                                  968
entry_p                         000302 automatic       pointer                  dcl 688 in procedure "process_list" set ref 703* 710
                                                                                  710 750*
entry_rp                  2            based           bit(18)                  level 2 in structure "names" packed packed unaligned
                                                                                  dcl 5-7 in procedure "salv_dir_checker_" set ref
                                                                                  634 965 968* 1259*
entry_rp                        000164 automatic       bit(18)                  packed unaligned dcl 265 in procedure "entry_chain"
                                                                                  set ref 280* 281 281* 284 285 293* 298 299 299*
                                                                                  301* 309 310* 313* 314 314*
entry_type                             constant        fixed bin(17,0)          initial dcl 163 set ref 290* 608 635* 639 1129
entrybrp                 17            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 281 299 301
entrybrp                 17            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 372*
entryfrp                 16            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 280
entryfrp                 16            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 372*
ep                              000256 automatic       pointer                  dcl 626 in procedure "restore_name" set ref 634*
                                                                                  635* 636* 639 640 643 644* 649
ep                              000166 automatic       pointer                  dcl 266 in procedure "entry_chain" set ref 285* 290*
                                                                                  291* 305* 306* 310 313
ep                              000204 automatic       pointer                  dcl 351 in procedure "process_entry" set ref 357*
                                                                                  359 362* 366* 366 372* 374 388 388 390* 390* 391
                                                                                  391 393 393 393* 405 407 409 416 416 421* 421* 426
                                                                                  427 427 427* 429 431 431 433 433* 433* 433 438 442
                                                                                  442 447* 447* 451 451 457 457 467 471* 471* 477
                                                                                  477 477 481* 481* 481 488 489* 489* 490 499 499
                                                                                  501* 501* 502 504* 504* 507 508* 508* 510 512 512
                                                                                  513* 513* 514 521 521 521 524* 524* 524 533 538
                                                                                  539 541 544* 544* 544 544 546 546* 546* 550 550
                                                                                  559 559 560 561 561* 561* 564 567 568 569 569*
                                                                                  569* 571
ep                                     parameter       pointer                  dcl 1172 in procedure "entry_name" ref 1169 1180
ep                                     parameter       pointer                  dcl 1547 in procedure "get_unique_name" set ref 1544
                                                                                  1553 1556 1556 1556* 1557 1559
error                                  parameter       entry variable           dcl 73 ref 27 213 223 231 327 331 335 340 390 407
                                                                                  421 431 447 471 481 484 489 501 504 508 513 524
                                                                                  544 561 569 871 886 891 900 933 935 957 959 967
                                                                                  979 987 1043 1256 1294 1373 1391 1454 1466 1528
                                                                                  1530 1557 1572
event_flags                     000116 automatic       structure                level 1 dcl 87 set ref 433 433 546 546 1159*
falter                                 based           bit(36)                  dcl 174 set ref 183*
fixed                                                  builtin function         dcl 155 ref 359 521 561 569 639 640 883 887 1017
                                                                                  1023 1045 1085 1085 1501 1557
force_rebuild             5            based           bit(1)                   level 3 packed packed unaligned dcl 109 ref 1144
force_rpv                24(20)        based           bit(1)                   level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1489
force_rpv                24(20)        based           bit(1)                   level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1489* 1491*
formline_                       000516 constant        entry                    external dcl 1195 ref 1197
forward                         000304 automatic       bit(1)                   dcl 689 in procedure "process_list" set ref 714* 733
                                                                                  736* 776
forward                         000170 automatic       bit(1)                   dcl 267 in procedure "entry_chain" set ref 274* 293
                                                                                  296* 308
fptr                      3            based           bit(18)                  array level 3 packed packed unaligned dcl 7-5 ref
                                                                                  1327
frp                                    based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1221 in procedure "move" set ref 1233* 1241*
frp                                    based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 699 in procedure "process_list" ref 778
frp                                    based           bit(18)                  level 2 in structure "access_name" packed packed
                                                                                  unaligned dcl 4-29 in procedure
                                                                                  "salv_dir_checker_" set ref 1601 1603* 1603 1605
                                                                                  1607 1607
frp                                    based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1321 in procedure "check_free_list" ref 1334
fs_alloc$alloc                  000470 constant        entry                    external dcl 142 ref 1230
fs_alloc$free                   000474 constant        entry                    external dcl 144 ref 1611
fs_alloc$init                   000472 constant        entry                    external dcl 143 ref 1503
grant                     0(01) 000116 automatic       bit(1)                   level 2 packed packed unaligned dcl 87 set ref 1161*
hash$in                         000502 constant        entry                    external dcl 147 ref 985 1255
hash$search                     000504 constant        entry                    external dcl 148 ref 650 975
hash_table                             based           structure                level 1 dcl 1356 in procedure "valid_header"
hash_table                             based           structure                level 1 dcl 6-6 in procedure "salv_dir_checker_"
hash_table_rp            55(18)        based           bit(18)                  level 2 packed packed unaligned dcl 110 ref 251 251
                                                                                  251 1429
head                                   parameter       bit(18)                  packed unaligned dcl 672 in procedure "process_list"
                                                                                  ref 667 720
head                                   parameter       bit(18)                  packed unaligned dcl 1210 in procedure "move" set
                                                                                  ref 1206 1227 1235 1236*
head                                   parameter       bit(18)                  packed unaligned dcl 1593 in procedure
                                                                                  "delete_unused_access_names" set ref 1590 1599
                                                                                  1605*
header_area_size                000421 internal static fixed bin(17,0)          dcl 117 set ref 191* 1132*
htp                             000144 automatic       pointer                  dcl 6-4 set ref 1429* 1435 1435* 1435 1443 1444 1444
                                                                                  1445 1447* 1447
htsize                   55            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1250
htsize                   55            based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1437 1506
htused                   56            based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 1427 1442 1446*
htused                   56            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1250
i                               000555 automatic       fixed bin(17,0)          dcl 1354 in procedure "valid_header" set ref 1414*
                                                                                  1415 1415 1416* 1437* 1437* 1440 1441 1442 1443*
                                                                                  1444
i                               000240 automatic       fixed bin(17,0)          dcl 588 in procedure "prodigal" set ref 598* 599 600
                                                                                  600 602* 602 604* 604 605 606
i                               000412 automatic       fixed bin(17,0)          dcl 1105 in procedure "ascii_check" set ref 1116*
                                                                                  1117 1121
i                               000574 automatic       fixed bin(17,0)          dcl 1475 in procedure "setup_dir_header" set ref
                                                                                  1501* 1503* 1505* 1506 1506 1506* 1507*
i                               000542 automatic       fixed bin(17,0)          dcl 1319 in procedure "check_free_list" set ref
                                                                                  1326* 1327 1329 1330 1331 1333*
i                               000330 automatic       fixed bin(17,0)          dcl 819 in procedure "valid_block" set ref 864* 864*
                                                                                  866
iacl                     35            based           structure                array level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
iacl                     35            based           structure                array level 2 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_"
iacl_count               25            based           structure                array level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
iacl_count               25            based           structure                array level 2 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_"
index                                                  builtin function         dcl 155 ref 600
info                                   based           structure                level 1 dcl 109
input_dir                              based           structure                level 1 dcl 110
its_mod                   0(30) 000152 automatic       bit(6)                   level 2 packed packed unaligned dcl 173 set ref 180*
its_unsigned                           based           structure                level 1 dcl 12-30
last_ep                         000474 automatic       pointer                  dcl 1217 set ref 1251* 1252 1254* 1258 1258
last_good_block                 000305 automatic       bit(18)                  packed unaligned dcl 690 set ref 741* 782
last_good_entry                 000171 automatic       bit(18)                  packed unaligned dcl 268 set ref 298* 314
lcount                   23            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 377* 377
lcount                   23            based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 334 335* 336*
length                                                 builtin function         dcl 155 ref 929 929 952 952 1133 1181 1181 1197 1197
level$get                       000476 constant        entry                    external dcl 145 ref 433 433 546 546
link                                   based           structure                level 1 dcl 3-6
link_cnt                        000172 automatic       fixed bin(17,0)          dcl 269 set ref 273* 334 335* 336 385* 385
link_type                              constant        fixed bin(17,0)          initial dcl 9-16 ref 377 476 837
lu                        1            based           fixed bin(18,0)          level 2 dcl 7-5 ref 1154 1524
lw                        2            based           fixed bin(18,0)          level 2 dcl 7-5 set ref 1422 1525*
master_dir               32(09)        based           bit(1)                   level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1477 in procedure "setup_dir_header"
                                                                                  ref 1485
master_dir               24(19)        based           bit(1)                   level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1384
master_dir               32(09)        based           bit(1)                   level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1351 in procedure "valid_header" ref
                                                                                  1384
master_dir               24(19)        based           bit(1)                   level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1485*
master_dir_uid           61            based           bit(36)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1494*
master_dir_uid           65            based           bit(36)                  level 2 in structure "info" dcl 109 in procedure
                                                                                  "salv_dir_checker_" ref 1385 1494
master_dir_uid           61            based           bit(36)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" ref 1385
mod                                                    builtin function         dcl 155 ref 604 1532
multiple_class           32(05)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 ref 521 538
name                                   based           structure                level 1 packed packed unaligned dcl 1063
                                                                                  in procedure "check_acl_ref"
name                                   based           bit                      dcl 1106 in procedure "ascii_check" ref 1117 1121
name                            000507 automatic       structure                level 2 in structure "acl_info" dcl 1273
                                                                                  in procedure "set_acl_ref"
name                      2            based           structure                level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 4-7 in procedure "salv_dir_checker_"
                                                                                  set ref 755 755 755 755 944 944
name                      4     000616 automatic       char(32)                 level 2 in structure "new_name" dcl 1549
                                                                                  in procedure "get_unique_name" set ref 1552* 1557*
name                                   based           structure                level 1 dcl 1279 in procedure "set_acl_ref"
name                      4            based           char(32)                 level 2 in structure "access_name" dcl 4-29
                                                                                  in procedure "salv_dir_checker_" set ref 929 929
                                                                                  929 929 933* 1284 1288
name                      4            based           char(32)                 level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "salv_dir_checker_" set ref 431* 649 952 952 952
                                                                                  952 957* 967* 975 975 979* 987* 1181 1181 1181
                                                                                  1181 1182 1183 1256*
name_brp                  5(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 373*
                                                                                  393* 393* 651* 1556*
name_cnt                        000173 automatic       fixed bin(17,0)          dcl 270 set ref 273* 319 339 340* 412* 412
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 373*
                                                                                  388 391* 393* 393* 651* 1556*
name_ptr                               parameter       pointer                  dcl 1101 ref 1098 1117 1121
name_string                            parameter       bit(288)                 dcl 1192 ref 1188
name_type                       000157 constant        fixed bin(17,0)          initial dcl 9-17 set ref 393* 643* 644* 646 1024
                                                                                  1131
names                                  based           structure                level 1 dcl 5-7
new_bp                          000306 automatic       pointer                  dcl 692 set ref 754* 755 755 758
new_ep                          000260 automatic       pointer                  dcl 627 in procedure "restore_name" set ref 650* 651
                                                                                  651 651*
new_ep                          000214 automatic       pointer                  dcl 356 in procedure "process_entry" set ref 358*
                                                                                  372* 373 373 374 374 393* 393 393 399* 407* 407*
                                                                                  411 427 427 450 451 451 453 453 457 457 460 460
new_head                        000310 automatic       bit(18)                  packed unaligned dcl 693 set ref 705* 754* 788
new_name                        000616 automatic       structure                level 1 dcl 1549 set ref 1556 1556
new_owner_bp                    000312 automatic       pointer                  dcl 695 set ref 701* 754*
new_ptr                                parameter       pointer                  dcl 1213 set ref 1206 1228* 1230* 1232 1233 1236
                                                                                  1237 1240 1241 1242 1249 1255* 1256 1259
new_tail                        000311 automatic       bit(18)                  packed unaligned dcl 694 set ref 706* 754* 789
next_rp                         000644 automatic       bit(18)                  packed unaligned dcl 1597 set ref 1601* 1613
nnames                    4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-8 set ref 405
                                                                                  407* 409* 411* 1559*
np                              000460 automatic       pointer                  dcl 1175 in procedure "entry_name" set ref 1180*
                                                                                  1181 1181 1181 1181 1182 1183
np                              000262 automatic       pointer                  dcl 628 in procedure "restore_name" set ref 633* 634
                                                                                  643* 644* 646* 651*
np                                     parameter       pointer                  dcl 1083 in procedure "find_access_name" ref 1080
                                                                                  1085 1085
nsizes                                 based           fixed bin(18,0)          level 2 dcl 7-5 ref 1326 1411
null                                                   builtin function         dcl 155 ref 199 199 199 202 202 202 210 210 210 220
                                                                                  220 220 358 372 427 433 433 453 453 460 460 546
                                                                                  546 594 594 651 710 975 1254 1258 1362 1480 1556
num_buckets                     000554 automatic       fixed bin(17,0)          dcl 1353 set ref 1441* 1442 1445
num_chars                              parameter       fixed bin(17,0)          dcl 1102 ref 1098 1116
num_pages                       000604 automatic       fixed bin(17,0)          dcl 1517 set ref 1527* 1528 1528* 1539
num_words                       000473 automatic       fixed bin(17,0)          dcl 1216 in procedure "move" set ref 1223* 1230*
                                                                                  1232
num_words                              parameter       fixed bin(17,0)          dcl 1039 in procedure "space_free" ref 1035 1043
                                                                                  1046 1049 1050
num_words                       000605 automatic       fixed bin(18,0)          dcl 1518 in procedure "copy_directory" set ref 1524*
                                                                                  1527 1530 1530* 1532 1535 1537
num_words                              parameter       fixed bin(17,0)          dcl 1011 in procedure "mark_space_used" ref 1007
                                                                                  1018 1018 1020
num_words                       000241 automatic       fixed bin(17,0)          dcl 588 in procedure "prodigal" set ref 600* 601 602
                                                                                  604 604
nwords                          000327 automatic       fixed bin(17,0)          dcl 818 set ref 863* 864 866* 867* 869 872
oosw                     32(01)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 set ref 499
                                                                                  502*
options                   5            based           structure                level 2 dcl 109
output_area_ptr                 000120 automatic       pointer                  dcl 89 set ref 1230* 1502* 1503* 1524 1525 1611*
output_dir                             based           structure                level 1 dcl 111 set ref 1479*
output_string                          parameter       char                     packed unaligned dcl 1193 set ref 1188 1197 1197
                                                                                  1197 1197
owner                                  based           bit(36)                  level 2 in structure "link" dcl 3-6 in procedure
                                                                                  "salv_dir_checker_" ref 868
owner                    77            based           bit(36)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" ref 1380
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "salv_dir_checker_" ref 854
owner                    15            based           bit(36)                  level 2 in structure "access_name" dcl 4-29
                                                                                  in procedure "salv_dir_checker_" ref 844
owner                     6            based           bit(36)                  level 2 in structure "acl_entry" dcl 4-7
                                                                                  in procedure "salv_dir_checker_" ref 849
owner                    15     000616 automatic       bit(36)                  level 2 in structure "new_name" dcl 1549
                                                                                  in procedure "get_unique_name" set ref 1553*
owner                    44            based           bit(36)                  level 2 in structure "branch" dcl 1351 in procedure
                                                                                  "valid_header" ref 1380
owner                    77            based           bit(36)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1481*
owner                    15            based           bit(36)                  level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "salv_dir_checker_" ref 877
owner                    44            based           bit(36)                  level 2 in structure "branch" dcl 1477 in procedure
                                                                                  "setup_dir_header" ref 1481
owner_expected                  000314 automatic       bit(36)                  dcl 696 in procedure "process_list" set ref 710*
                                                                                  712* 730*
owner_expected                         parameter       bit(36)                  dcl 813 in procedure "valid_block" ref 806 844 849
                                                                                  854 868 877
p                               000374 automatic       pointer                  dcl 1061 in procedure "check_acl_ref" set ref 1065*
                                                                                  1067 1072 1072 1072 1073 1073 1073
p                               000344 automatic       pointer                  dcl 922 in procedure "check_contents" set ref 972*
                                                                                  974* 975*
p                               000504 automatic       pointer                  dcl 1271 in procedure "set_acl_ref" set ref 1281*
                                                                                  1282 1284 1286 1288 1289 1294
p                               000264 automatic       pointer                  dcl 629 in procedure "restore_name" set ref 649*
                                                                                  650*
p                                      parameter       pointer                  dcl 1570 in procedure "trace_message" set ref 1566
                                                                                  1572*
pad1                            000152 automatic       bit(3)                   level 2 packed packed unaligned dcl 173 set ref 176*
pad2                      0(21) 000152 automatic       bit(9)                   level 2 packed packed unaligned dcl 173 set ref 179*
pathname                 31            based           char                     level 2 in structure "link" packed packed unaligned
                                                                                  dcl 3-6 in procedure "salv_dir_checker_" set ref
                                                                                  477 477 481*
pathname                 13            based           char(168)                level 2 in structure "info" packed packed unaligned
                                                                                  dcl 109 in procedure "salv_dir_checker_" set ref
                                                                                  433* 546*
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-6 ref 477 477
                                                                                  477 481 481 861 861 863 868
per_process_sw           24(18)        based           bit(1)                   level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1487*
per_process_sw           32(02)        based           bit(1)                   level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1477 in procedure "setup_dir_header"
                                                                                  ref 1487
pers                            000507 automatic       char(32)                 level 3 dcl 1273 set ref 1282* 1284* 1294* 1303*
pers_brp                 21            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 202* 238*
pers_brp                 21            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 202*
pers_frp                 20            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 202* 238*
pers_frp                 20            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 202*
pers_rp                                based           bit(18)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1279 in procedure "set_acl_ref" ref 1282 1284
pers_rp                                based           bit(18)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1063 in procedure "check_acl_ref" ref 1072
                                                                                  1072 1072
primary_name             10            based           bit(504)                 level 2 packed packed unaligned dcl 2-8 set ref 388
                                                                                  391 431 649 1023 1180 1228
print_trace               5(01)        based           bit(1)                   level 3 packed packed unaligned dcl 109 ref 618 1146
prodigal_search                 000122 automatic       bit(1)                   dcl 90 set ref 470 480 593* 616* 870 885 890 956 979
                                                                                  1143*
proj                     10     000507 automatic       char(32)                 level 3 dcl 1273 set ref 1286* 1288* 1294* 1304*
proj_brp                 21(18)        based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 199*
proj_brp                 21(18)        based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 199* 239*
proj_frp                 20(18)        based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 199*
proj_frp                 20(18)        based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 199* 239*
proj_rp                   0(18)        based           bit(18)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1063 in procedure "check_acl_ref" ref 1073
                                                                                  1073 1073
proj_rp                   0(18)        based           bit(18)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1279 in procedure "set_acl_ref" ref 1286 1288
ptr                                                    builtin function         dcl 155 ref 251 251 251 285 606 634 725 1072 1072
                                                                                  1073 1073 1154 1241 1251 1284 1288 1323 1327 1334
                                                                                  1410 1429 1502 1599 1603 1607 1613
pvid                     11            based           bit(36)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1483*
pvid                     30            based           bit(36)                  level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1477 in procedure "setup_dir_header"
                                                                                  ref 1483
pvid                     11            based           bit(36)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" ref 1381
pvid                     30            based           bit(36)                  level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1351 in procedure "valid_header" ref
                                                                                  1381
pvt$root_lvid                   000500 external static bit(36)                  packed unaligned dcl 146 ref 1134
rebuilding                      000123 automatic       bit(1)                   dcl 91 set ref 189 193 195 217 227 235 245 248* 371
                                                                                  411 449 457 704 753 787 937 972 984 1144* 1376*
                                                                                  1455* 1467*
rehashing                24(21)        based           bit(1)                   level 2 packed packed unaligned dcl 110 ref 1428
rel                                                    builtin function         dcl 155 ref 388 391 639 640 965 968 1017 1023 1045
                                                                                  1085 1085 1236 1241 1242 1258 1259 1327 1599
ring                            000124 automatic       fixed bin(17,0)          dcl 92 set ref 209* 210 210 210 210 212 213* 213 215
                                                                                  217 220 220 220 220 222 223* 223 225 227*
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 2-8 set
                                                                                  ref 521 524*
ringno                    0(18) 000152 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 173 set
                                                                                  ref 178*
root_lvid                       000422 internal static bit(36)                  packed unaligned dcl 118 set ref 1134* 1489
rtrim                                                  builtin function         dcl 155 ref 773 1624
salv_args                              based           structure                level 1 dcl 8-4
salv_data$debugging_fault_dir_checker
                                000514 external static bit(1)                   dcl 152 ref 170
salv_ptr                        000126 automatic       pointer                  dcl 93 set ref 189 433 546 618 1138* 1139 1141 1142
                                                                                  1144 1145 1146 1148 1155 1155 1155 1385 1494 1495
                                                                                  1528 1528
salv_time                 4            based           bit(36)                  level 2 dcl 109 ref 1148
scratch_ptr                     000130 automatic       pointer                  dcl 94 set ref 250 600 640 1018 1022 1024 1026 1049
                                                                                  1050 1085 1142* 1157
security_oos                    000132 automatic       bit(1)                   dcl 95 set ref 244 527* 551* 1147*
seg                      25            based           fixed bin(17,0)          array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 217*
seg                      25            based           fixed bin(17,0)          array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 212 213* 215*
seg_brp                  35(18)        based           bit(18)                  array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 210*
seg_brp                  35(18)        based           bit(18)                  array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 210*
seg_cnt                         000174 automatic       fixed bin(17,0)          dcl 271 set ref 273* 326 327* 328 381* 381
seg_count                22            based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 326 327* 328*
seg_count                22            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 375* 375
seg_frp                  35            based           bit(18)                  array level 3 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  set ref 210*
seg_frp                  35            based           bit(18)                  array level 3 in structure "output_dir" packed
                                                                                  packed unaligned dcl 111 in procedure
                                                                                  "salv_dir_checker_" set ref 210*
seg_type                               constant        fixed bin(17,0)          initial dcl 9-18 ref 375 381 835 1129
segno                     0(03) 000152 automatic       fixed bin(15,0)          level 2 packed packed unsigned unaligned dcl 173 set
                                                                                  ref 177*
sfp                             000150 automatic       pointer                  dcl 172 set ref 181* 183
sfp_val                         000152 automatic       structure                level 1 dcl 173 set ref 181
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "link" packed packed unaligned
                                                                                  dcl 3-6 in procedure "salv_dir_checker_" set ref
                                                                                  869 872*
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1404
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "hash_table" packed packed
                                                                                  unaligned dcl 1356 in procedure "valid_header" ref
                                                                                  1435 1435 1443 1447
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "salv_dir_checker_" ref 366
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1497*
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "hash_table" packed packed
                                                                                  unaligned dcl 6-6 in procedure "salv_dir_checker_"
                                                                                  ref 251
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1221 in procedure "move" ref 1223
size                      3(18)        based           fixed bin(17,0)          array level 3 in structure "area" packed packed
                                                                                  unaligned dcl 7-5 in procedure "salv_dir_checker_"
                                                                                  ref 1329 1330 1331 1333 1415
size                      1(18)        based           fixed bin(17,0)          level 2 in structure "block" packed packed unaligned
                                                                                  dcl 820 in procedure "valid_block" set ref 889
                                                                                  892*
size                      1(18) 000616 automatic       fixed bin(17,0)          level 2 in structure "new_name" packed packed
                                                                                  unaligned dcl 1549 in procedure "get_unique_name"
                                                                                  set ref 1555*
sons_lvid                41            based           bit(36)                  level 2 in structure "branch" dcl 1351 in procedure
                                                                                  "valid_header" ref 1382
sons_lvid                12            based           bit(36)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1484*
sons_lvid                41            based           bit(36)                  level 2 in structure "branch" dcl 1477 in procedure
                                                                                  "setup_dir_header" ref 1484 1489
sons_lvid                12            based           bit(36)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" ref 1382
source_ptr                      000134 automatic       pointer                  dcl 96 set ref 191* 199 199 202 202 210 210 212 213
                                                                                  215 220 220 222 223 225 230 231 232 251 251 251
                                                                                  251 251 251 280 281 285 299 301 326 327 328 330
                                                                                  331 332 334 335 336 606 634 725 974 985* 1072 1072
                                                                                  1073 1073 1140* 1154 1284 1288 1323 1323 1327 1334
                                                                                  1365 1372 1380 1381 1382 1383 1384 1385 1390 1391
                                                                                  1391 1403 1404 1405 1406 1410 1427 1428 1429 1429
                                                                                  1437 1442 1446 1489 1506 1535 1537
spaces                          000026 constant        structure                level 1 dcl 1112 ref 1121
special_op                      000116 automatic       bit(1)                   level 2 packed packed unaligned dcl 87 set ref 1160*
start                           000364 automatic       fixed bin(17,0)          dcl 1041 in procedure "space_free" set ref 1045*
                                                                                  1046 1049 1050
start                           000354 automatic       fixed bin(17,0)          dcl 1013 in procedure "mark_space_used" set ref
                                                                                  1017* 1018 1022 1023* 1024 1026
static_init                     000423 internal static bit(1)                   initial dcl 119 set ref 1127 1135*
stop_at_error                   000136 automatic       bit(1)                   dcl 97 set ref 193* 292 320 389 398 406 420 430 446
                                                                                  468 479 732 932 955 966 978
string                                 parameter       char                     packed unaligned dcl 1464 in procedure "header_err"
                                                                                  set ref 1461 1466*
string                          000100 automatic       char(32)                 dcl 1580 in procedure "cv_access" set ref 1582* 1583
string                                 parameter       char                     packed unaligned dcl 1569 in procedure
                                                                                  "trace_message" set ref 1566 1572*
string                          000430 automatic       char(96)                 packed unaligned dcl 1174 in procedure "entry_name"
                                                                                  set ref 1183* 1184
string                                                 builtin function         dcl 155 in procedure "salv_dir_checker_" set ref
                                                                                  1159*
substr                                                 builtin function         dcl 155 set ref 600 640 1018* 1018 1022* 1024* 1026*
                                                                                  1049 1050 1067 1085
sum                             000543 automatic       fixed bin(17,0)          dcl 1320 set ref 1324* 1331* 1331 1332
sys_info$access_class_ceiling   000510 external static bit(72)                  dcl 150 ref 533 550
sys_info$default_dir_max_length 000512 external static fixed bin(19,0)          dcl 151 ref 1422 1501 1525
syserr                          000506 constant        entry                    external dcl 149 ref 182
tag                      20     000507 automatic       char(1)                  level 3 in structure "acl_info" dcl 1273
                                                                                  in procedure "set_acl_ref" set ref 1289* 1305*
tag                       1            based           char(1)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1063 in procedure "check_acl_ref" ref 1067
tag                       1            based           char(1)                  level 2 in structure "name" packed packed unaligned
                                                                                  dcl 1279 in procedure "set_acl_ref" set ref 1289
                                                                                  1294*
tail                                   parameter       bit(18)                  packed unaligned dcl 673 in procedure "process_list"
                                                                                  ref 667 721 742 744
tail                                   parameter       bit(18)                  packed unaligned dcl 1211 in procedure "move" set
                                                                                  ref 1206 1236* 1240 1241 1242*
tail                                   parameter       bit(18)                  packed unaligned dcl 1594 in procedure
                                                                                  "delete_unused_access_names" set ref 1590 1609*
target_ptr                      000140 automatic       pointer                  dcl 98 set ref 199 199 202 202 210 210 217 220 220
                                                                                  227 236 238 238 239 239 372 372 375 375 377 377
                                                                                  379 379 650* 759 759 972 1141* 1241 1250 1250 1251
                                                                                  1255* 1479 1481 1482 1483 1484 1485 1486 1487 1488
                                                                                  1489 1491 1494 1495 1496 1497 1498 1499 1500 1501
                                                                                  1502 1507* 1537 1599 1603 1607 1613
temp1_ptr                              based           pointer                  level 2 dcl 109 ref 1141
temp2_ptr                 2            based           pointer                  level 2 dcl 109 ref 1142
time                            000117 automatic       bit(36)                  dcl 88 set ref 559 564 568 1148* 1498
trace                           000142 automatic       bit(1)                   dcl 99 set ref 291 362 594 595* 618* 731 773 1146*
tree_depth               57            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1495*
tree_depth               66            based           fixed bin(17,0)          level 2 in structure "info" dcl 109 in procedure
                                                                                  "salv_dir_checker_" ref 1495
type                      1            based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 591 in procedure "prodigal" ref 607 607 607
                                                                                  613
type                      1            based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1221 in procedure "move" ref 1227 1249
type                      1            based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 1015 in procedure "mark_space_used" ref 1021
                                                                                  1021 1021 1026
type                      1            based           bit(18)                  level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1403
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "salv_dir_checker_" ref 359
                                                                                  512 561 567 569 1557
type                      1            based           bit(18)                  level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1496*
type                      1            based           bit(18)                  level 2 in structure "block" packed packed unaligned
                                                                                  dcl 820 in procedure "valid_block" set ref 832 835
                                                                                  837 883 887*
type                      1            based           bit(18)                  level 2 in structure "hash_table" packed packed
                                                                                  unaligned dcl 1356 in procedure "valid_header" ref
                                                                                  1444
type                      1     000616 automatic       bit(18)                  level 2 in structure "new_name" packed packed
                                                                                  unaligned dcl 1549 in procedure "get_unique_name"
                                                                                  set ref 1554*
type_expected                   000315 automatic       fixed bin(17,0)          dcl 697 in procedure "process_list" set ref 702*
                                                                                  730* 731 737 750* 752 755 757 773
type_expected                   000207 automatic       fixed bin(17,0)          dcl 353 in procedure "process_entry" set ref 359*
                                                                                  375 377 379 381 383 471 476 508 514
type_expected                          parameter       fixed bin(17,0)          dcl 916 in procedure "check_contents" ref 912 926
type_expected                   000326 automatic       fixed bin(17,0)          dcl 817 in procedure "valid_block" set ref 826* 827
                                                                                  829 832* 835* 837* 841 883 886 887 889 891 892 900
uid                      10            based           bit(36)                  level 2 in structure "input_dir" dcl 110
                                                                                  in procedure "salv_dir_checker_" ref 1365 1372
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "salv_dir_checker_" set ref 467 643* 710 1553
uid                      10            based           bit(36)                  level 2 in structure "output_dir" dcl 111
                                                                                  in procedure "salv_dir_checker_" set ref 1482*
uid                       2            based           bit(36)                  level 2 in structure "branch" dcl 1351 in procedure
                                                                                  "valid_header" ref 1372 1386
uid                       2            based           bit(36)                  level 2 in structure "branch" dcl 1477 in procedure
                                                                                  "setup_dir_header" ref 1482
unique_chars_                   000520 constant        entry                    external dcl 1550 ref 1552
unspec                                                 builtin function         dcl 155 set ref 181* 181 433 433 546 546 1067 1117
                                                                                  1121 1445* 1479*
usage                     2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-29 set ref
                                                                                  758* 937 1602
version_number           15(18)        based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1405
version_number           15(18)        based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1499*
version_number_2                       constant        fixed bin(17,0)          initial dcl 1-84 ref 1405 1499
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "output_dir" packed packed
                                                                                  unaligned dcl 111 in procedure "salv_dir_checker_"
                                                                                  set ref 1488*
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1477 in procedure "setup_dir_header"
                                                                                  ref 1488
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "input_dir" packed packed
                                                                                  unaligned dcl 110 in procedure "salv_dir_checker_"
                                                                                  ref 1383
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 1351 in procedure "valid_header" ref
                                                                                  1383
word8                                  based           bit(288)                 dcl 1178 set ref 1183*
zero                                   based           bit                      level 2 dcl 1520 set ref 1535*
zero_len                        000606 automatic       fixed bin(17,0)          dcl 1519 set ref 1532* 1533 1534* 1534 1535

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 9-4
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 12-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 12-55
SL_INFO_arg_given_in_structure         internal static fixed bin(17,0)          initial dcl 11-69
SL_INFO_arg_not_given                  internal static fixed bin(17,0)          initial dcl 11-69
SL_INFO_as_mode                        internal static fixed bin(17,0)          initial dcl 11-65
SL_INFO_command_mode                   internal static fixed bin(17,0)          initial dcl 11-65
SL_INFO_version_1                      internal static char(8)                  initial packed unaligned dcl 11-62
SL_LOG                                 internal static fixed bin(17,0)          initial dcl 11-14
SL_LOG_BEEP                            internal static fixed bin(17,0)          initial dcl 11-14
SL_LOG_SILENT                          internal static fixed bin(17,0)          initial dcl 11-14
SL_TYPE                                internal static fixed bin(17,0)          initial dcl 11-14
SL_TYPE_BEEP                           internal static fixed bin(17,0)          initial dcl 11-14
SL_TYPE_CRASH                          internal static fixed bin(17,0)          initial dcl 11-14
aclep                                  automatic       pointer                  dcl 4-5
dp                                     automatic       pointer                  dcl 1-9
ep                                     automatic       pointer                  dcl 2-6
hash_table_type                        internal static fixed bin(17,0)          initial dcl 9-19
itp                                    based           structure                level 1 dcl 12-18
itp_unsigned                           based           structure                level 1 dcl 12-43
its                                    based           structure                level 1 dcl 12-5
np                                     automatic       pointer                  dcl 5-5
salv_data$debug                        external static bit(1)                   dcl 10-3
salv_data$dump                         external static bit(1)                   dcl 10-4
salv_data$lock                         external static bit(36)                  dcl 10-5
salv_data$on_line                      external static bit(1)                   dcl 10-6
salv_data$print_path                   external static bit(1)                   dcl 10-7
salv_data$printer_delay                external static fixed bin(17,0)          dcl 10-8
salv_data$rpv                          external static bit(1)                   dcl 10-9
salv_data$vol_read_ahead               external static fixed bin(17,0)          dcl 10-10
sl_info                                automatic       structure                level 1 dcl 11-24
sl_info_code_msg                       internal static structure                level 1 dcl 11-187
sl_info_msg                            internal static structure                level 1 dcl 11-214
sl_info_sev_code_label_msg             internal static structure                level 1 dcl 11-161
sl_info_sev_code_msg                   internal static structure                level 1 dcl 11-82
sl_info_sev_coded_msg                  internal static structure                level 1 dcl 11-134
sl_info_sev_msg                        internal static structure                level 1 dcl 11-108

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_BP                        006204 constant        label                    dcl 897 ref 874
CHECK_TYPE                      006057 constant        label                    dcl 883 ref 846 851 857 879
RESTART                         001366 constant        label                    dcl 191 ref 253
START_REBUILD                   002060 constant        label                    dcl 248 ref 292 320 389 398 406 420 430 446 468 479
                                                                                  732 932 955 966 978 988 1329 1330 1332
ascii_check                     007233 constant        entry                    internal dcl 1098 ref 477 929 952 1181
btype                           000000 constant        label                    array(8) dcl 832 ref 829 841
check                           000010 constant        label                    array(6) dcl 929 ref 926
check_acl_ref                   007117 constant        entry                    internal dcl 1057 ref 416 442 944
check_contents                  006261 constant        entry                    internal dcl 912 ref 644 750
check_dates                     004556 constant        entry                    internal dcl 555 ref 492 516
check_free_list                 010153 constant        entry                    internal dcl 1315 ref 189
copy_directory                  011322 constant        entry                    internal dcl 1514 ref 245
cv_access                       011676 constant        entry                    internal dcl 1576 ref 544 544 544 544 546 546 1391
                                                                                  1391 1391 1391
delete_unused_access_names      011722 constant        entry                    internal dcl 1590 ref 238 239
entry_chain                     002107 constant        entry                    internal dcl 260 ref 205
entry_contents                  003475 constant        entry                    internal dcl 462 ref 360
entry_name                      007416 constant        entry                    internal dcl 1169 ref 390 390 407 407 421 421 433
                                                                                  433 447 447 471 471 481 481 489 489 501 501 504
                                                                                  504 508 508 513 513 524 524 544 544 546 546 561
                                                                                  561 569 569
find_access_name                007203 constant        entry                    internal dcl 1080 ref 1072 1073
format                          007475 constant        entry                    internal dcl 1188 ref 1183
get_unique_name                 011470 constant        entry                    internal dcl 1544 ref 399
header_err                      011073 constant        entry                    internal dcl 1461 ref 1380 1381 1382 1383 1384 1385
                                                                                  1403 1404 1405 1406 1411 1417 1422
join                            010053 constant        label                    dcl 1291 ref 1307
mark_space_used                 006751 constant        entry                    internal dcl 1007 ref 191 251 305 366 646 749 752
                                                                                  1333 1447
move                            007546 constant        entry                    internal dcl 1206 ref 372 651 754 1556
process_entry                   002457 constant        entry                    internal dcl 346 ref 306 609 636
process_list                    005226 constant        entry                    internal dcl 667 ref 199 202 210 220 393 427
prodend                         005050 constant        label                    dcl 616 ref 605
prodigal                        004715 constant        entry                    internal dcl 585 ref 321
restore_name                    005057 constant        entry                    internal dcl 622 ref 613
salv_dir_checker_               001276 constant        entry                    external dcl 27
set_acl_ref                     010011 constant        entry                    internal dcl 1266 ref 451 457 755
set_acl_ref$damaged             010140 constant        entry                    internal dcl 1300 ref 453 460
setup                           007262 constant        entry                    internal dcl 1125 ref 187
setup_dir_header                011141 constant        entry                    internal dcl 1472 ref 195 1375
space_free                      007031 constant        entry                    internal dcl 1035 ref 827 867 1330 1435
target                          012026 constant        entry                    internal dcl 1617 ref 433 546
trace_message                   011623 constant        entry                    internal dcl 1566 ref 291 362 594 731 773
valid_block                     005576 constant        entry                    internal dcl 806 ref 290 608 635 643 730
valid_header                    010247 constant        entry                    internal dcl 1348 ref 188

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13270       14012   12641       13300
Length     14552   12641       522         523     427         414

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
salv_dir_checker_                  1430 external procedure  is an external procedure.  
begin block on line 170                 begin block         shares stack frame of external procedure salv_dir_checker_.  
entry_chain                             internal procedure  shares stack frame of external procedure salv_dir_checker_.  
process_entry                           internal procedure  shares stack frame of external procedure salv_dir_checker_.  
entry_contents                          internal procedure  shares stack frame of external procedure salv_dir_checker_.  
check_dates                             internal procedure  shares stack frame of external procedure salv_dir_checker_.  
prodigal                                internal procedure  shares stack frame of external procedure salv_dir_checker_.  
restore_name                            internal procedure  shares stack frame of external procedure salv_dir_checker_.  
process_list                            internal procedure  shares stack frame of external procedure salv_dir_checker_.  
valid_block                             internal procedure  shares stack frame of external procedure salv_dir_checker_.  
check_contents                          internal procedure  shares stack frame of external procedure salv_dir_checker_.  
mark_space_used                         internal procedure  shares stack frame of external procedure salv_dir_checker_.  
space_free                              internal procedure  shares stack frame of external procedure salv_dir_checker_.  
check_acl_ref                           internal procedure  shares stack frame of external procedure salv_dir_checker_.  
find_access_name                        internal procedure  shares stack frame of external procedure salv_dir_checker_.  
ascii_check                             internal procedure  shares stack frame of external procedure salv_dir_checker_.  
setup                                   internal procedure  shares stack frame of external procedure salv_dir_checker_.  
entry_name                              internal procedure  shares stack frame of external procedure salv_dir_checker_.  
format                               84 internal procedure  is declared options(non_quick).  
move                                    internal procedure  shares stack frame of external procedure salv_dir_checker_.  
set_acl_ref                             internal procedure  shares stack frame of external procedure salv_dir_checker_.  
check_free_list                         internal procedure  shares stack frame of external procedure salv_dir_checker_.  
valid_header                            internal procedure  shares stack frame of external procedure salv_dir_checker_.  
header_err                              internal procedure  shares stack frame of external procedure salv_dir_checker_.  
setup_dir_header                        internal procedure  shares stack frame of external procedure salv_dir_checker_.  
copy_directory                          internal procedure  shares stack frame of external procedure salv_dir_checker_.  
get_unique_name                         internal procedure  shares stack frame of external procedure salv_dir_checker_.  
trace_message                       102 internal procedure  is called during a stack extension.  
cv_access                            78 internal procedure  is called during a stack extension.  
delete_unused_access_names              internal procedure  shares stack frame of external procedure salv_dir_checker_.  
target                               70 internal procedure  uses returns(char(*)) or returns(bit(*)).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ONES                        salv_dir_checker_
000410 block_sizes                 salv_dir_checker_
000421 header_area_size            salv_dir_checker_
000422 root_lvid                   salv_dir_checker_
000423 static_init                 salv_dir_checker_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_access                000100 string                      cv_access
salv_dir_checker_        000100 audit                       salv_dir_checker_
                         000102 branch_ptr                  salv_dir_checker_
                         000104 check_access_names          salv_dir_checker_
                         000105 correct_oosw                salv_dir_checker_
                         000106 count                       salv_dir_checker_
                         000110 dir_access_class            salv_dir_checker_
                         000112 dir_acl_cnt                 salv_dir_checker_
                         000113 dir_name_cnt                salv_dir_checker_
                         000114 dir_size                    salv_dir_checker_
                         000115 dir_uid                     salv_dir_checker_
                         000116 event_flags                 salv_dir_checker_
                         000117 time                        salv_dir_checker_
                         000120 output_area_ptr             salv_dir_checker_
                         000122 prodigal_search             salv_dir_checker_
                         000123 rebuilding                  salv_dir_checker_
                         000124 ring                        salv_dir_checker_
                         000126 salv_ptr                    salv_dir_checker_
                         000130 scratch_ptr                 salv_dir_checker_
                         000132 security_oos                salv_dir_checker_
                         000134 source_ptr                  salv_dir_checker_
                         000136 stop_at_error               salv_dir_checker_
                         000140 target_ptr                  salv_dir_checker_
                         000142 trace                       salv_dir_checker_
                         000144 htp                         salv_dir_checker_
                         000146 areap                       salv_dir_checker_
                         000150 sfp                         begin block on line 170
                         000152 sfp_val                     begin block on line 170
                         000162 back_rp                     entry_chain
                         000163 dir_cnt                     entry_chain
                         000164 entry_rp                    entry_chain
                         000166 ep                          entry_chain
                         000170 forward                     entry_chain
                         000171 last_good_entry             entry_chain
                         000172 link_cnt                    entry_chain
                         000173 name_cnt                    entry_chain
                         000174 seg_cnt                     entry_chain
                         000204 ep                          process_entry
                         000206 code                        process_entry
                         000207 type_expected               process_entry
                         000210 auth_valid                  process_entry
                         000211 bc_auth_valid               process_entry
                         000212 count                       process_entry
                         000214 new_ep                      process_entry
                         000240 i                           prodigal
                         000241 num_words                   prodigal
                         000242 code                        prodigal
                         000244 bp                          prodigal
                         000254 a_code                      restore_name
                         000256 ep                          restore_name
                         000260 new_ep                      restore_name
                         000262 np                          restore_name
                         000264 p                           restore_name
                         000274 back_rp                     process_list
                         000275 block_rp                    process_list
                         000276 bp                          process_list
                         000300 code                        process_list
                         000301 count                       process_list
                         000302 entry_p                     process_list
                         000304 forward                     process_list
                         000305 last_good_block             process_list
                         000306 new_bp                      process_list
                         000310 new_head                    process_list
                         000311 new_tail                    process_list
                         000312 new_owner_bp                process_list
                         000314 owner_expected              process_list
                         000315 type_expected               process_list
                         000324 bp                          valid_block
                         000326 type_expected               valid_block
                         000327 nwords                      valid_block
                         000330 i                           valid_block
                         000340 a_code                      check_contents
                         000342 bp                          check_contents
                         000344 p                           check_contents
                         000354 start                       mark_space_used
                         000364 start                       space_free
                         000374 p                           check_acl_ref
                         000412 i                           ascii_check
                         000430 string                      entry_name
                         000460 np                          entry_name
                         000462 code                        entry_name
                         000472 code                        move
                         000473 num_words                   move
                         000474 last_ep                     move
                         000504 p                           set_acl_ref
                         000506 code35                      set_acl_ref
                         000507 acl_info                    set_acl_ref
                         000540 bp                          check_free_list
                         000542 i                           check_free_list
                         000543 sum                         check_free_list
                         000554 num_buckets                 valid_header
                         000555 i                           valid_header
                         000574 i                           setup_dir_header
                         000604 num_pages                   copy_directory
                         000605 num_words                   copy_directory
                         000606 zero_len                    copy_directory
                         000616 new_name                    get_unique_name
                         000642 bp                          delete_unused_access_names
                         000644 next_rp                     delete_unused_access_names

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       return_mac          mdfx1               shorten_stack       ext_entry
int_entry           int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_name_$encode              access_audit_$log_obj_class   aim_check_$equal              aim_check_$greater_or_equal
allocate_dir_ht_              display_access_class_         formline_                     fs_alloc$alloc
fs_alloc$free                 fs_alloc$init                 hash$in                       hash$search
level$get                     syserr                        unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$fs_obj_access_mod                        access_operations_$fs_obj_set_soos
active_hardcore_data$aclsize  active_hardcore_data$alloc_sizes
active_hardcore_data$dir_arearp                             active_hardcore_data$dir_hdrsize
active_hardcore_data$elcsize  active_hardcore_data$ensize   active_hardcore_data$esize
active_hardcore_data$hash_table_sizes                       active_hardcore_data$nalloc_sizes
active_hardcore_data$num_hash_table_sizes                   pvt$root_lvid
salv_data$debugging_fault_dir_checker                       sys_info$access_class_ceiling
sys_info$default_dir_max_length




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 001271       170 001303       176 001305       177 001307       178 001313       179 001317       180 001321
    181 001323       182 001325       183 001345       186 001347       187 001351       188 001352       189 001357
    191 001366       193 001377       194 001402       195 001403       199 001406       202 001444       205 001475
    209 001476       210 001503       212 001540       213 001546       215 001604       217 001612       218 001621
    220 001623       222 001660       223 001667       225 001727       227 001734       228 001742       229 001744
    230 001746       231 001754       232 002011       233 002014       235 002016       236 002020       237 002023
    238 002025       239 002035       244 002051       245 002054       246 002057       248 002060       250 002062
    251 002070       253 002106       260 002107       273 002110       274 002114       275 002116       280 002117
    281 002123       284 002131       285 002134       290 002137       291 002144       292 002165       293 002167
    296 002173       297 002174       298 002176       299 002200       301 002210       303 002211       305 002212
    306 002216       308 002220       309 002222       310 002224       311 002227       313 002230       314 002233
    317 002236       319 002237       320 002242       321 002244       326 002245       327 002252       328 002305
    330 002311       331 002316       332 002353       334 002356       335 002362       336 002415       339 002421
    340 002424       343 002456       346 002457       357 002461       358 002464       359 002466       360 002471
    361 002472       362 002474       363 002515       366 002516       371 002525       372 002527       373 002550
    374 002555       375 002565       377 002577       379 002610       381 002620       383 002625       385 002631
    388 002632       389 002643       390 002645       391 002700       392 002705       393 002706       397 002736
    398 002740       399 002742       400 002744       405 002746       406 002754       407 002756       409 003022
    411 003025       412 003032       416 003034       417 003040       418 003043       419 003044       420 003045
    421 003047       426 003101       427 003105       429 003137       430 003145       431 003147       433 003210
    438 003350       440 003354       442 003356       443 003362       444 003365       445 003366       446 003367
    447 003371       449 003423       450 003425       451 003430       453 003442       457 003450       460 003465
    577 003474       462 003475       465 003476       467 003477       468 003502       469 003504       470 003506
    471 003511       472 003553       476 003554       477 003557       478 003570       479 003572       480 003574
    481 003576       484 003646       486 003672       488 003673       489 003677       490 003731       492 003734
    493 003735       499 003736       500 003742       501 003744       502 003776       503 004001       504 004002
    507 004034       508 004040       510 004102       512 004105       513 004116       514 004150       516 004157
    517 004160       521 004163       524 004202       527 004243       528 004244       533 004245       538 004256
    539 004261       540 004277       541 004300       544 004316       546 004377       550 004543       551 004553
    553 004555       555 004556       559 004557       560 004566       561 004570       564 004633       567 004636
    568 004642       569 004647       571 004712       575 004714       585 004715       593 004716       594 004720
    595 004746       598 004747       599 004750       600 004753       601 004770       602 004773       604 005000
    605 005007       606 005013       607 005017       608 005030       609 005041       612 005043       613 005044
    614 005047       616 005050       618 005051       619 005056       622 005057       633 005060       634 005062
    635 005070       636 005075       639 005077       640 005110       643 005116       644 005142       645 005144
    646 005146       649 005160       650 005163       651 005200       658 005225       667 005226       701 005230
    702 005233       703 005235       704 005240       705 005242       706 005247       710 005254       712 005263
    713 005265       714 005266       715 005270       720 005271       721 005276       724 005307       725 005312
    730 005315       731 005322       732 005351       733 005353       736 005357       737 005360       740 005365
    741 005367       742 005371       744 005402       747 005404       749 005405       750 005411       751 005413
    752 005415       753 005427       754 005431       755 005433       757 005447       758 005451       759 005454
    771 005462       772 005463       773 005464       776 005537       777 005542       778 005544       779 005547
    781 005550       782 005553       785 005556       787 005557       788 005561       789 005566       791 005572
    793 005575       806 005576       825 005600       826 005603       827 005605       829 005626       832 005630
    835 005641       837 005646       839 005653       841 005656       844 005657       846 005666       849 005667
    851 005676       854 005677       857 005706       861 005707       863 005723       864 005733       865 005751
    866 005753       867 005760       868 005770       869 006006       870 006013       871 006017       872 006043
    874 006046       877 006047       879 006056       883 006057       885 006064       886 006071       887 006123
    889 006131       890 006140       891 006145       892 006177       897 006204       900 006216       901 006250
    904 006256       912 006261       924 006263       925 006264       926 006267       929 006271       931 006310
    932 006313       933 006315       935 006350       937 006374       940 006406       944 006407       946 006422
    952 006423       954 006442       955 006445       956 006447       957 006451       959 006505       961 006531
    965 006532       966 006543       967 006545       968 006575       972 006603       974 006610       975 006612
    976 006634       977 006636       978 006641       979 006643       980 006676       984 006677       985 006701
    986 006714       987 006716       988 006747       991 006750      1007 006751      1017 006753      1018 006761
   1020 006767      1021 006772      1022 007003      1023 007007      1024 007014      1025 007021      1026 007022
   1029 007030      1035 007031      1043 007033      1045 007061      1046 007070      1049 007077      1050 007107
   1057 007117      1065 007121      1066 007124      1067 007125      1068 007131      1069 007133      1070 007135
   1072 007136      1073 007153      1075 007174      1091 007202      1080 007203      1085 007205      1087 007227
   1089 007232      1098 007233      1116 007235      1117 007240      1119 007250      1121 007252      1123 007261
   1125 007262      1127 007263      1128 007266      1129 007271      1130 007300      1131 007303      1132 007310
   1133 007314      1134 007317      1135 007321      1138 007323      1139 007327      1140 007331      1141 007334
   1142 007336      1143 007340      1144 007342      1145 007345      1146 007351      1147 007355      1148 007356
   1154 007360      1155 007366      1157 007403      1159 007410      1160 007411      1161 007413      1165 007415
   1169 007416      1180 007420      1181 007424      1182 007432      1183 007443      1184 007466      1188 007474
   1197 007515      1199 007545      1206 007546      1223 007550      1227 007556      1228 007567      1229 007573
   1230 007574      1232 007612      1233 007624      1235 007626      1236 007633      1237 007644      1238 007646
   1240 007647      1241 007653      1242 007663      1249 007670      1250 007674      1251 007704      1252 007712
   1253 007714      1254 007715      1255 007717      1256 007732      1258 007767      1259 010001      1262 010010
   1266 010011      1281 010013      1282 010016      1284 010026      1286 010033      1288 010043      1289 010050
   1291 010053      1293 010071      1294 010073      1298 010137      1300 010140      1303 010142      1304 010145
   1305 010150      1307 010152      1315 010153      1323 010154      1324 010162      1326 010163      1327 010173
   1329 010204      1330 010212      1331 010220      1332 010226      1333 010232      1334 010236      1335 010244
   1337 010246      1348 010247      1362 010251      1363 010255      1365 010256      1366 010261      1368 010262
   1372 010264      1373 010271      1374 010315      1375 010316      1376 010317      1377 010321      1380 010324
   1381 010334      1382 010352      1383 010365      1384 010406      1385 010427      1386 010442      1387 010445
   1390 010450      1391 010455      1403 010531      1404 010543      1405 010557      1406 010576      1410 010620
   1411 010625      1414 010641      1415 010651      1416 010662      1417 010664      1419 010674      1422 010676
   1427 010713      1428 010717      1429 010722      1435 010727      1437 010741      1439 010761      1440 010763
   1441 010767      1442 010772      1443 011002      1444 011007      1445 011021      1446 011026      1447 011030
   1448 011036      1454 011042      1455 011066      1456 011070      1461 011073      1466 011104      1467 011136
   1469 011140      1472 011141      1479 011142      1480 011146      1481 011152      1482 011155      1483 011157
   1484 011161      1485 011163      1486 011170      1487 011174      1488 011201      1489 011203      1491 011216
   1494 011220      1495 011223      1496 011226      1497 011230      1498 011233      1499 011235      1500 011237
   1501 011244      1502 011251      1503 011255      1505 011273      1506 011275      1507 011305      1509 011321
   1514 011322      1524 011323      1525 011326      1527 011332      1528 011336      1530 011373      1532 011435
   1533 011441      1534 011442      1535 011446      1537 011455      1539 011464      1541 011467      1544 011470
   1552 011472      1553 011514      1554 011521      1555 011523      1556 011526      1557 011552      1559 011614
   1562 011621      1566 011622      1572 011636      1574 011674      1576 011675      1582 011703      1583 011714
   1590 011722      1599 011724      1601 011736      1602 011741      1603 011747      1605 011760      1607 011765
   1609 011776      1611 012003      1613 012017      1615 012024      1617 012025      1622 012046      1624 012075


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
