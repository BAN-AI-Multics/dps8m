	COMPILATION LISTING OF SEGMENT log_salvage_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1023.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4,indattr */
       10 
       11 log_salvage_:
       12      procedure (P_log_dname, P_log_ename, P_salvage_arg_ptr, P_salv_code);
       13 
       14 /* *	LOG_SALVAGE_
       15*   *
       16*   *	This user-ring program is responsible for ensuring the log
       17*   *	family is in a usable state.  System crashes at critical times
       18*   *	can cause a variety of disasters (mostly when an ESD is not
       19*   *	completed).  For instance, the "current" log segment may be
       20*   *	found out of service or uninitialized.
       21*   *
       22*   *	Here we check all segments in the primary log directory.  It
       23*   *	is assumed that all other history directories are OK.
       24*   *
       25*   *	NOTE: There is no attempt to lock other processes from modifying
       26*   *	the log.  This routine should be called only when some other means
       27*   *	has been employed to obtain exclusive access to the log.
       28*   *
       29*   *	Suggested usage:
       30*   *	     call log_write_$open (dir, name, "0"b, datap, code);
       31*   *	     if code ^= 0 then do;
       32*   *		unspec (salv_arg) = ""b;
       33*   *		salv_arg.version = LOG_SALVAGE_ARG_VERSION_1;
       34*   *		salv_arg.reporter_proc = print_errors;
       35*   *		call log_salvage_ (dir, name, addr(salv_arg), code);
       36*   *		if salv_code = 0
       37*   *		then call log_write_$open (dir, name, "0"b, datap, code);
       38*   *		if code ^= 0	(* still failing? *)
       39*   *		then call error (code);
       40*   *	     end;
       41*   *
       42*   *	Note that the call to log_write_ has the parameter which controls
       43*   *	log creation set to "0"b.  In cases where it is expected a log
       44*   *	segment already exists, it is best to leave possible re-creation
       45*   *	to log_salvage_.  The log_salvage_ routine will attempt to set the
       46*   *	proper sequence number in a newly created log segment; log_write_
       47*   *	will not.  This is because log_write_ does not have the facility
       48*   *	to interrogate the log history.
       49*   *
       50*   *	Modification History:
       51*   *	85-04-09, EJ Sharpe: initial coding
       52**/
       53 
       54 
       55 /* Parameters */
       56 
       57 declare  P_log_dname	  char (*) parameter;	/* Input: log dir path */
       58 declare  P_log_ename	  char (*) parameter;	/* Input: log family name */
       59 declare  P_salvage_arg_ptr	  pointer parameter;	/* Input: controls our behaviour */
       60 declare  P_salv_code	  fixed bin (35) parameter;	/* Output: 0 tells caller to retry open */
       61 
       62 
       63 /* Automatic */
       64 
       65 declare  log_dname		  char (168);		/* arg copy */
       66 declare  log_ename		  char (32);		/* arg copy */
       67 declare  1 auto_log_salvage_arg aligned like log_salvage_arg; /* arg copy */
       68 
       69 
       70 declare  bit_count		  fixed bin (24);		/* ignored */
       71 declare  code		  fixed bin (35);		/* the usual */
       72 declare  current_log_ptr	  pointer;		/* pointer to current (non-history) log seg */
       73 declare  done		  bit (1) aligned;		/* loop control */
       74 declare  error_found	  bit (1) aligned;		/* found some anomaly */
       75 declare  first_sequence_temp	  fixed bin (35);		/* temp value */
       76 declare  fix_applied	  bit (1) aligned;		/* changed something for the better */
       77 declare  i		  fixed bin;		/* loop control */
       78 declare  history_log_ptr	  pointer;		/* pointer to most recent usable history seg */
       79 declare  n_good_hist_segs	  fixed bin;		/* the number of usable history segs */
       80 declare  newest_hist_log_idx	  fixed bin;		/* index of most recent usable history seg */
       81 declare  next_older_log_idx	  fixed bin;		/* temp idx */
       82 declare  next_older_log_ptr	  pointer;		/* temp ptr */
       83 declare  oldest_hist_log_idx	  fixed bin;		/* index of oldest history log which is usable */
       84 declare  renamed_damaged_log	  bit (1) aligned;		/* set if current log seg damaged */
       85 declare  sequence_problem_detected bit (1) aligned;	/* found problem with history sequencing */
       86 
       87 
       88 /* Based */
       89 
       90 /* NOTE NOTE NOTE - The following structure is copied from log_segment_.  It
       91*   does not exist in an include file because log_segment_ is the only program
       92*   which is supposed to know this format.  */
       93 
       94 declare  sequence_info_ptr	  pointer;
       95 declare  1 sequence_info	  aligned based (sequence_info_ptr),
       96 	 2 pad		  bit (17) unal,
       97 	 2 number		  fixed bin (35) unal,	/* spans word boundary!!!!!!! */
       98 	 2 in_service	  bit (1) unal,
       99 	 2 words_used	  fixed bin (18) unsigned unal;
      100 
      101 
      102 /* External */
      103 
      104 declare  error_table_$action_not_performed fixed bin (35) external;
      105 declare  error_table_$bad_arg	  fixed bin (35) external;
      106 declare  error_table_$namedup	  fixed bin (35) external;
      107 declare  error_table_$noentry	  fixed bin (35) external;
      108 declare  error_table_$nomatch	  fixed bin (35) external;
      109 declare  error_table_$no_w_permission fixed bin (35) external;
      110 declare  error_table_$unexpected_condition fixed bin (35) external;
      111 declare  error_table_$unimplemented_version fixed bin (35) external;
      112 
      113 declare  log_data_$default_log_size fixed bin (35) external;
      114 
      115 declare  sys_info$first_reasonable_time fixed bin (71) external;
      116 
      117 
      118 /* Entries */
      119 
      120 declare  convert_status_code_	  entry (fixed bin (35), char (8) aligned, char (100) aligned);
      121 declare  cu_$arg_ptr	  entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      122 declare  cu_$level_get	  entry returns (fixed bin);
      123 declare  formline_		  entry options (variable);
      124 declare  get_group_id_	  entry () returns (char (32));
      125 declare  get_process_access_class_ entry () returns (bit (72) aligned);
      126 declare  get_system_free_area_  entry () returns (ptr);
      127 declare  hcs_$chname_file	  entry (char (*), char (*), char (*), char (*), fixed bin (35));
      128 declare  hcs_$chname_seg	  entry (ptr, char (*), char (*), fixed bin (35));
      129 declare  hcs_$get_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
      130 declare  hcs_$list_acl	  entry (char (*), char (*), ptr, ptr, ptr, fixed bin, fixed bin (35));
      131 declare  hcs_$status_for_backup entry (char (*), char (*), pointer, fixed bin (35));
      132 declare  hcs_$status_long	  entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      133 declare  initiate_file_	  entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      134 declare  ioa_$rsnpnnl	  entry () options (variable);
      135 declare  log_create_$new_segment entry (ptr, ptr, fixed bin (35));
      136 declare  log_list_history_$single_dir entry (char (*), char (*), ptr, fixed bin (35));
      137 declare  log_name_$name	  entry (char (*), fixed bin (71)) returns (char (32));
      138 declare  log_segment_$initialize_sequence entry (ptr, fixed bin (35), fixed bin (35));
      139 declare  log_segment_$place_in_service entry (ptr, fixed bin (35));
      140 declare  pathname_		  entry (char (*), char (*)) returns (char (168));
      141 declare  terminate_file_	  entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      142 declare  timer_manager_$sleep	  entry (fixed bin (71), bit (2));
      143 declare  unique_bits_	  entry () returns (bit (70));
      144 declare  unique_chars_	  entry (bit (*)) returns (char (15));
      145 
      146 
      147 /* Misc */
      148 
      149 declare  NUM_GOOD_HIST_DESIRED  fixed bin init (5) internal static options (constant);
      150 declare  ONE_SECOND		  fixed bin (71) init (1000000) internal static options (constant);
      151 declare  RELATIVE_MICROSECONDS  bit (2) init ("10"b) internal static options (constant);
      152 
      153 declare  any_other		  condition;
      154 declare  cleanup		  condition;
      155 declare  no_write_permission	  condition;
      156 declare  seg_fault_error	  condition;
      157 
      158 declare  abs		  builtin;
      159 declare  addr		  builtin;
      160 declare  clock		  builtin;
      161 declare  length		  builtin;
      162 declare  null		  builtin;
      163 declare  rtrim		  builtin;
      164 declare  size		  builtin;
      165 declare  substr		  builtin;
      166 
      167 
      168 /* MAIN CODE */
      169 
      170 /* Here's the plan:
      171*
      172*   Somehow log_write_ has failed to open the log, or we're being called just to
      173*   check up on things.  We will deal only with the log segments in the primary
      174*   log directory.  We won't try going off to other directories in search of older
      175*   family members.
      176*
      177*   The first step will be to get a list of the history logs in the directory
      178*   (i.e.  those with the name LOGNAME.??????.????).  This list will be used to
      179*   look at the last few segments or back to salvage_args.from_time.  Each seg
      180*   will be initiated and its header inspected.  Any errors will be reported.  The
      181*   log_read_data structure will be used to keep track of those found "good" (the
      182*   "ptr" element will be set non-null).
      183*
      184*   The next step will be to check the good history segments for consistant
      185*   sequence numbers.  Any inconsistancies will be reported (a future enhancement
      186*   will be to automatically adjust the sequence numbers).
      187*
      188*   Finally, the current log segment "LOG_NAME" will be checked.  If we're
      189*   supposed to migrate segments to this log, this segment should not exist.
      190*   Otherwise, we have to make sure the segment is there and usable.  If there's
      191*   some problem the segment will be renamed to "LOG_NAME.!(unique)" and a new one
      192*   created.  Some checks are made to ensure the sequence numbers are consistant
      193*   between the current log segment and the history.
      194**/
      195 
      196 /* Setup. */
      197 
      198 	error_found = "0"b;				/* this will get set if we find a proble, */
      199 	fix_applied = "0"b;				/* this will get set if we change something */
      200 
      201 	log_read_data_ptr = null ();
      202 	history_log_ptr = null ();
      203 	oldest_hist_log_idx = 0;
      204 	newest_hist_log_idx = 0;
      205 	current_log_ptr = null ();
      206 	renamed_damaged_log = "0"b;
      207 
      208 	/*** copy args */
      209 	log_dname = P_log_dname;
      210 	log_ename = P_log_ename;
      211 	log_salvage_arg_ptr = P_salvage_arg_ptr;
      212 	auto_log_salvage_arg = log_salvage_arg;
      213 	log_salvage_arg_ptr = addr (auto_log_salvage_arg);
      214 
      215 	if log_salvage_arg.version ^= LOG_SALVAGE_ARG_VERSION_1
      216 	then call Finished (error_table_$unimplemented_version);
      217 
      218 	if log_salvage_arg.from_time ^= 0
      219 	then if log_salvage_arg.from_time > clock ()
      220 		| log_salvage_arg.from_time < sys_info$first_reasonable_time
      221 	     then call Finished (error_table_$bad_arg);
      222 
      223 	on cleanup call Cleanup;
      224 
      225 
      226 /* Get a list of the history segments (in the primary log directory) for this
      227*   log. */
      228 
      229 	call log_list_history_$single_dir (log_dname, log_ename, log_read_data_ptr, code);
      230 	if code = error_table_$nomatch
      231 	then goto SKIP_HISTORY;
      232 	if code ^= 0 then do;
      233 	     call Report_Error (code, "Unable to list ""^a"" log segments in ^a.", log_ename, log_dname);
      234 	     call Finished (code);
      235 	end;
      236 
      237 
      238 /* Here we'll initiate the latest log history segments (excluding the damaged
      239*   ones).  The number of segments to initiate is determined by
      240*   log_salvage_arg.from_time (but at least one).  If zero, then we'll initiate
      241*   the last NUM_GOOD_HIST_DESIRED segments. */
      242 
      243 	n_good_hist_segs = 0;
      244 	done = "0"b;
      245 	do i = 1 to log_read_data.n_segments while (^done);
      246 	     call Initiate_History_Segment_and_Check (i); /* will remove damaged ones from list */
      247 	     if log_read_data.segments (i).ptr ^= null () /* will be null if seg is damaged in some way */
      248 	     then do;
      249 		n_good_hist_segs = n_good_hist_segs + 1;
      250 		if n_good_hist_segs = 1		/* first one? */
      251 		then newest_hist_log_idx = i;		/* remember it */
      252 		oldest_hist_log_idx = i;		/* and the  last one */
      253 	     end;
      254 	     if log_salvage_arg.from_time > 0
      255 	     then done = (log_read_data.segments (i).suffix_time <= log_salvage_arg.from_time);
      256 	     else done = n_good_hist_segs >= NUM_GOOD_HIST_DESIRED;
      257 	end;
      258 	if n_good_hist_segs = 0 then goto SKIP_HISTORY;
      259 
      260 
      261 /* At this point newest_hist_log_idx and oldest_hist_log_idx define the range
      262*   of log segments we're interested in investigating further.  There may be some
      263*   in-between that are damaged, so we have to be careful to make sure we have the
      264*   pointer.  */
      265 
      266 /* We'll check their sequence numbers to make sure they agree with the time
      267*   stamps on the segment names (i.e.  they must be ascending).  */
      268 
      269 	sequence_problem_detected = "0"b;
      270 	next_older_log_ptr = log_read_data.segments (oldest_hist_log_idx).ptr;
      271 	next_older_log_idx = oldest_hist_log_idx;
      272 	do i = (oldest_hist_log_idx - 1) to newest_hist_log_idx by -1;
      273 	     log_segment_ptr = log_read_data.segments (i).ptr;
      274 	     if log_segment_ptr ^= null ()
      275 	     then do;
      276 		if log_segment.first_sequence <= next_older_log_ptr -> log_segment.last_sequence then do;
      277 		     call Report_Error (0, "Sequence conflict in ""^a"" with ""^a"".",
      278 			log_read_data.segments (i).ename, log_read_data.segments (next_older_log_idx).ename);
      279 		     sequence_problem_detected = "1"b;
      280 		end;
      281 		next_older_log_ptr = log_segment_ptr;
      282 		next_older_log_idx = i;
      283 	     end;
      284 	end;
      285 
      286 
      287 	/*** The following is for future implementation; right now we'll have only the
      288*	     error messages, no fixes.
      289*
      290*	     if log_salvage_arg.flags.adjust_history_sequence & sequence_problem_detected
      291*	     then call Fix_History_Sequence;
      292*	*/
      293 
      294 
      295 /* OK, checking of the log history is done.  Now we deal with the current log
      296*   segment.  */
      297 
      298 SKIP_HISTORY:
      299 	call initiate_file_ (log_dname, log_ename, RW_ACCESS, current_log_ptr, bit_count, code);
      300 	if code = error_table_$noentry then do;
      301 	     if ^log_salvage_arg.flags.migrating
      302 	     then do;
      303 		call Create_New_Log_Seg (null ());	/* create a new one for 'em */
      304 		call Finished (0);
      305 	     end;
      306 	     else call Finished (0);			/* thats how it should be */
      307 	end;
      308 	else if code = 0 then do;
      309 	     if ^log_salvage_arg.flags.migrating
      310 	     then do;
      311 		if ^Check_Log_Segment (current_log_ptr, log_ename, "1"b)
      312 		then do;
      313 		     call Rename_as_Damaged (log_dname, log_ename);
      314 		     call Create_New_Log_Seg (current_log_ptr);
      315 		     call Finished (0);
      316 		end;
      317 	     end;
      318 	     else do;
      319 		call Report_Error (0, "Found history log without timestamp ""^a"".", log_ename);
      320 		if ^Check_Log_Segment (current_log_ptr, log_ename, "0"b)
      321 		then do;
      322 		     call Rename_as_Damaged (log_dname, log_ename);
      323 		     call Finished (0);
      324 		end;
      325 		else call Rename_for_Last_Message (current_log_ptr, log_ename); /* make it a history log segment */
      326 	     end;
      327 	end;
      328 	else do;					/* totally unexpected code, treat 'em as damaged */
      329 	     call Report_Error (code, "^a", pathname_ (log_dname, log_ename));
      330 	     call Rename_as_Damaged (log_dname, log_ename);
      331 	     if ^log_salvage_arg.flags.migrating
      332 	     then call Create_New_Log_Seg (null ());
      333 	     call Finished (0);
      334 	end;
      335 
      336 
      337 /* We end up here only if a current seg existed.  The last check is
      338*   to make sure the sequence succeeds the most recent history
      339*   segment.  */
      340 
      341 	if n_good_hist_segs = 0			/* but not if there was no history... */
      342 	then call Finished (0);
      343 
      344 	history_log_ptr = log_read_data.segments (newest_hist_log_idx).ptr;
      345 	if history_log_ptr ^= null ()			/* do we have at least one history seg? */
      346 	then do;
      347 	     if current_log_ptr -> log_segment.first_sequence ^= 0
      348 	     then first_sequence_temp = current_log_ptr -> log_segment.first_sequence;
      349 	     else do;
      350 						/* get first sequence number from the alloc info */
      351 		sequence_info_ptr = addr (current_log_ptr -> log_segment.alloc_info);
      352 		first_sequence_temp = sequence_info.number;
      353 	     end;
      354 	     if first_sequence_temp <= history_log_ptr -> log_segment.last_sequence
      355 	     then do;
      356 		call Report_Error (0, "Sequence conflict in ""^a"" with ""^a"".",
      357 		     log_ename, log_read_data.segments (newest_hist_log_idx).ename);
      358 		call Rename_as_Damaged (log_dname, log_ename);
      359 		if ^log_salvage_arg.migrating
      360 		then call Create_New_Log_Seg (current_log_ptr);
      361 		call Finished (0);
      362 	     end;
      363 	end;
      364 	else do;
      365 	     /*** We don't have any log history ptr, but we still want to
      366*		make sure the sequence numbers seem appropriate.  Thus,
      367*		if there was any history segment (damaged or inaccessable)
      368*		we'll make sure the present log does not start at the
      369*		beginning of the sequence.  log_segment_ starts all logs
      370*		at 1000000 (1 million), if this one starts there, and
      371*		there are history segs, the sequence was restarted somehow.
      372*		Unfortunately, there's no way to determine what the real
      373*		sequence numbers should be.  ***/
      374 	     if log_read_data.n_segments > 0 & log_segment.first_sequence < 1000001
      375 	     then do;
      376 		call Report_Error (0, "Sequence was restarted.");
      377 		call Finished (0);
      378 	     end;
      379 	end;
      380 
      381 	call Finished (0);
      382 
      383 
      384 /* *
      385*   *	FINISHED
      386*   *
      387*   *	This is the exit procedure.  The cleanup procedure is called, and
      388*   *	a little editing is done on the returned code.  We want to be sure
      389*   *	to return 0 if we didn't encounter a fatal error AND we actually
      390*   *	were of some help.  If there was nothing we could do, we return
      391*   *	error_table_$action_not_performed.  This tell's our caller that
      392*   *	it is useless to retry the log_write_$open operation.
      393*   *
      394**/
      395 
      396 Finished:
      397      procedure (P_code);
      398 
      399 declare  P_code		  fixed bin (35) parameter;
      400 
      401 	call Cleanup;
      402 
      403 	if fix_applied
      404 	then P_salv_code = P_code;
      405 	else if P_code = 0
      406 	then P_salv_code = error_table_$action_not_performed;
      407 	else P_salv_code = P_code;
      408 
      409 	goto MAIN_RETURN;
      410 
      411      end Finished;
      412 
      413 MAIN_RETURN:
      414 	return;
      415 
      416 
      417 /* *
      418*   *	CLEANUP
      419*   *
      420*   *	Terminate any initiated segs, and free allocated storage.
      421*   *
      422**/
      423 
      424 Cleanup:
      425      procedure;
      426 
      427 declare  p		  pointer;		/* local scratch pointer */
      428 
      429 	if log_read_data_ptr ^= null
      430 	then do;
      431 	     do i = 1 to log_read_data.n_segments;
      432 		if log_read_data.segments (i).ptr ^= null ()
      433 		then do;
      434 		     p = log_read_data.segments (i).ptr;
      435 		     log_read_data.segments (i).ptr = null ();
      436 		     call terminate_file_ (p, 0, TERM_FILE_TERM, (0));
      437 		end;
      438 	     end;
      439 	     free log_read_data;
      440 	     log_read_data_ptr = null ();
      441 	end;
      442 
      443 	if current_log_ptr ^= null ()
      444 	then do;
      445 	     p = current_log_ptr;
      446 	     current_log_ptr = null ();
      447 	     call terminate_file_ (p, 0, TERM_FILE_TERM, (0));
      448 	end;
      449 
      450      end Cleanup;
      451 
      452 
      453 /* *
      454*   *	REPORT_ERROR
      455*   *	REPORT_FIX
      456*   *
      457*   *	This routine is called whenever there is anything to say.  The
      458*   *	reporter procedure specified in log_salvage_arg is used to
      459*   *	print (or whatever pleases it) the message.
      460*   *
      461*   *	Also, this is where flags are set indicating whether any errors
      462*   *	were detected, and whether any fixes were applied.
      463*   *
      464**/
      465 
      466 Report_Error:
      467      procedure options (variable);
      468 
      469 declare  arg_code		  fixed bin (35) based (argp);
      470 declare  argl		  fixed bin (21);		/* ignored */
      471 declare  argp		  pointer;
      472 
      473 declare  ecode		  fixed bin (35);
      474 declare  ignore_short_mess	  char (8) aligned;		/* ignored */
      475 declare  long_mess		  char (100) aligned;	/* expanded status code */
      476 
      477 declare  msg		  char (msg_len) based (msg_ptr);
      478 declare  msg_buff		  char (512);
      479 declare  msg_len		  fixed bin (21);
      480 declare  msg_ptr		  pointer;
      481 
      482 declare  complete_msg	  char (complete_msg_len) based (complete_msg_ptr);
      483 declare  complete_msg_buff	  char (614);		/* 102 chars bigger than msg_buff */
      484 declare  complete_msg_len	  fixed bin (21);
      485 declare  complete_msg_ptr	  pointer;
      486 
      487 	error_found = "1"b;				/* so we remember we found some anomaly */
      488 	goto REPORT_COMMON;
      489 
      490 Report_Fix:
      491      entry options (variable);
      492 
      493 	fix_applied = "1"b;				/* so we remember we did something */
      494 
      495 REPORT_COMMON:
      496 
      497 	call cu_$arg_ptr (1, argp, argl, ecode);	/* get arg_code */
      498 	if ecode ^= 0
      499 	then call Finished (ecode);
      500 
      501 	ecode = arg_code;				/* copy our arg */
      502 
      503 	/*** first format the message passed to us */
      504 	msg_ptr = addr (msg_buff);
      505 	msg_len = size (msg_buff);
      506 	call formline_ (2, 3, addr (msg_buff), msg_len, 0 /* no pad */);
      507 
      508 	/*** second, expand the error code */
      509 	if ecode ^= 0
      510 	then do;
      511 	     call convert_status_code_ (ecode, ignore_short_mess, long_mess);
      512 	     complete_msg_ptr = addr (complete_msg_buff);
      513 	     complete_msg_len = length (complete_msg_buff);
      514 	     call ioa_$rsnpnnl ("^a  ^a", complete_msg_buff, complete_msg_len, long_mess, msg);
      515 	end;
      516 	else do;
      517 	     /*** This is all we have... */
      518 	     complete_msg_ptr = msg_ptr;
      519 	     complete_msg_len = msg_len;
      520 	end;
      521 
      522 	/*** finally, call the reporting procedure.
      523*	     This procedure will be responsible for adding the frosting on
      524*	     the messages (i.e. name of procedure generating the message,
      525*	     pathname of log we're salvaging, process group id, etc). */
      526 
      527 	on any_other call Finished (error_table_$unexpected_condition);
      528 	call log_salvage_arg.reporter_proc (complete_msg);
      529 
      530 	return;
      531 
      532      end Report_Error;
      533 
      534 
      535 /* *
      536*   *	INITIATE_HISTORY_SEGMENT_AND_CHECK
      537*   *
      538*   *	This routine initiates a log history segment.  The first attempt is
      539*   *	made requesting RW access.  If that fails, a second attempt is made
      540*   *	requesting only R access.  Having only R access becomes a problem
      541*   *	only if the service bit will need to be turned off (and, in the
      542*   *	future, if the sequence numbers need adjustment).  Any code in
      543*   *	log_salvage_ which tries to modify a history segment must be
      544*   *	prepared to take an access violation fault.
      545*   *
      546**/
      547 
      548 Initiate_History_Segment_and_Check:
      549      procedure (P_log_idx);
      550 
      551 declare  P_log_idx		  fixed bin;		/* index into log_read_data */
      552 
      553 declare  log_idx		  fixed bin;
      554 
      555 declare  ecode		  fixed bin (35);
      556 declare  log_ptr		  pointer;
      557 
      558 	log_idx = P_log_idx;
      559 	call initiate_file_ (log_dname, log_read_data.segments (log_idx).ename, RW_ACCESS, log_ptr, bit_count, ecode);
      560 	if ecode = error_table_$no_w_permission
      561 	then do;
      562 	     /*** We'll try it with just read access, the rest of
      563*		this routine can deal with access violation faults. */
      564 	     call initiate_file_ (log_dname, log_read_data.segments (log_idx).ename, R_ACCESS, log_ptr, bit_count, ecode);
      565 
      566 	     if ecode = 0				/* report an error in either case */
      567 	     then call Report_Error (error_table_$no_w_permission, "^a", log_read_data.segments (log_idx).ename);
      568 	     else call Report_Error (ecode, "^a", log_read_data.segments (log_idx).ename);
      569 	end;
      570 
      571 	if ^Check_Log_Segment (log_ptr, log_read_data.segments (log_idx).ename, "0"b)
      572 	then log_ptr = null ();			/* don't want to use this guy */
      573 
      574 	log_read_data.segments (log_idx).ptr = log_ptr;	/* it may still be null */
      575 
      576 	return;
      577 
      578      end Initiate_History_Segment_and_Check;
      579 
      580 
      581 /* *
      582*   *	CHECK_LOG_SEGMENT
      583*   *
      584*   *	This routine checks consistancy within a single log segment.
      585*   *	Sequence numbers and times in the header must be consistant
      586*   *	in respect to one another.  The service bit must be off for
      587*   *	history segs, on for the live seg (it is adjusted if necessary).
      588*   *	Also, the first message sentinel is checked.
      589*   *
      590**/
      591 
      592 Check_Log_Segment:
      593      procedure (P_log_ptr, P_log_name, P_current_log) returns (bit (1) aligned);
      594 
      595 declare  P_log_ptr		  pointer parameter;
      596 declare  P_log_name		  char (32) parameter;
      597 declare  P_current_log	  bit (1) aligned parameter;
      598 
      599 declare  lp		  pointer;
      600 declare  lname		  char (32);
      601 declare  current_log	  bit (1) aligned;
      602 
      603 
      604 	lp = P_log_ptr;
      605 	lname = P_log_name;
      606 	current_log = P_current_log;
      607 
      608 	on seg_fault_error begin;			/* watch out for damaged segs */
      609 	     call Report_Error (0, "Seg Fault Error while checking ^a.  Segment may be damaged.", lname);
      610 	     goto CHECK_LOG_SEG_EXIT;
      611 	end;
      612 
      613 	on any_other begin;
      614 	     call Report_Error (0, "Unexpected condition encountered while checking log segment ^a.", lname);
      615 	     goto CHECK_LOG_SEG_EXIT;
      616 	end;
      617 
      618 	if lp -> log_segment.version = LOG_SEGMENT_VERSION_1
      619 	then if lp -> log_segment.time_created > sys_info$first_reasonable_time
      620 		& lp -> log_segment.time_created <= clock ()
      621 	     then if lp -> log_segment.first_sequence <= lp -> log_segment.last_sequence
      622 		     & (lp -> log_segment.first_sequence >= 1000000 | lp -> log_segment.first_sequence = 0)
      623 		then if lp -> log_segment.first_time <= lp -> log_segment.last_time
      624 			& lp -> log_segment.last_time <= clock ()
      625 		     then return (Check_Alloc_Info_and_Messages ());
      626 
      627 	call Report_Error (0, "Internal header problem in seg ^a.", lname);
      628 CHECK_LOG_SEG_EXIT:
      629 	return ("0"b);
      630 
      631 
      632 
      633 Check_Alloc_Info_and_Messages:
      634 	procedure () returns (bit (1) aligned);
      635 
      636 declare  flip_service_bit	  bit (1) aligned;
      637 declare  service_bit	  bit (1) aligned;
      638 
      639 
      640 	     flip_service_bit = "0"b;
      641 	     sequence_info_ptr = addr (lp -> log_segment.alloc_info);
      642 	     service_bit = sequence_info.in_service;	/* compiler will have an easier time with it here */
      643 
      644 	     if current_log & ^service_bit		/* checking current seg? */
      645 	     then do;
      646 		call Report_Error (0, "Current log ^a found out of service.", lname);
      647 		flip_service_bit = "1"b;		/* will fix it if nothing else wrong */
      648 	     end;
      649 
      650 	     if ^current_log & service_bit		/* checking history seg? */
      651 	     then do;
      652 		call Report_Error (0, "History log ^a found in service.", lname);
      653 		flip_service_bit = "1"b;		/* will fix it if nothing else wrong */
      654 	     end;
      655 
      656 
      657 	     if abs (sequence_info.number - lp -> log_segment.last_sequence) > 3 & lp -> log_segment.first_sequence > 0
      658 	     then do;
      659 		call Report_Error (0, "Last sequence and ""real"" sequence disagree in ^a.", lname);
      660 		goto return_failure;
      661 	     end;
      662 
      663 	     if sequence_info.words_used > lp -> log_segment.max_size
      664 	     then do;
      665 		call Report_Error (0, "Words used inconsistant with max size in ^a.", lname);
      666 		goto return_failure;
      667 	     end;
      668 
      669 
      670 
      671 /* Check the first message. */
      672 
      673 	     if lp -> log_segment.first_sequence = 0	/* but not if there's none there */
      674 	     then goto return_success;
      675 
      676 	     log_message_ptr = addr (lp -> log_segment.data); /* get to first message */
      677 	     if log_message.sentinel ^= LOG_SEGMENT_NEW_MESSAGE
      678 		& log_message.sentinel ^= LOG_SEGMENT_COMPLETE_MESSAGE
      679 	     then do;
      680 		call Report_Error (0, "First message invalid in ^a.", lname);
      681 		goto return_failure;
      682 	     end;
      683 
      684 
      685 /* We might consider going through all the messages, but it seems a waste.  If
      686*   the first one is there intact, log_position_ will be able to handle any other
      687*   problem.  */
      688 
      689 
      690 return_success:
      691 	     if flip_service_bit
      692 	     then do;
      693 		on no_write_permission goto return_failure; /* may happen here */
      694 		sequence_info.in_service = ^service_bit;
      695 		revert no_write_permission;
      696 		call Report_Fix (0, "Service bit set ^[on^;off^] in ^a.", ^service_bit, lname);
      697 	     end;
      698 	     return ("1"b);
      699 
      700 return_failure:
      701 	     return ("0"b);
      702 
      703 	end Check_Alloc_Info_and_Messages;
      704 
      705      end Check_Log_Segment;
      706 
      707 
      708 /* *
      709*   *	CREATE_NEW_LOG_SEGMENT
      710*   *
      711*   *	This routine is invoked if there is no live log segment, or if
      712*   *	the live log segment has internal damages.  If the immediately
      713*   *	previous history segment is available, the sequence numbers
      714*   *	in the new segment may be set correctly.  However, if there
      715*   *	is no history, or it is damaged, an estimated sequence number
      716*   *	is calculated.
      717*   *
      718*   *	If some history segment is available, the access list and other
      719*   *	file system attributes are copied from that history segment to
      720*   *	the newly created segment.
      721*   *
      722**/
      723 
      724 Create_New_Log_Seg:
      725      procedure (P_old_log_ptr);
      726 
      727 declare  P_old_log_ptr	  pointer parameter;
      728 
      729 declare  old_logp		  pointer;
      730 
      731 declare  acl_ptr		  pointer;
      732 declare  acl_count		  fixed bin;
      733 declare  code		  fixed bin (35);
      734 declare  hist_log_name	  char (32);
      735 declare  max_len		  fixed bin (19);
      736 declare  n_logs_unseen	  fixed bin;
      737 declare  new_log_ptr	  pointer;
      738 declare  new_sequence	  fixed bin (35);
      739 declare  system_area	  area based (system_area_ptr);
      740 declare  system_area_ptr	  pointer;
      741 
      742 declare  1 auto_log_segment_info aligned like log_segment_info;
      743 declare  1 status		  aligned like status_branch;
      744 declare  1 sfb		  aligned like status_for_backup;
      745 
      746 
      747 	system_area_ptr = null ();
      748 	acl_ptr = null ();
      749 	acl_count = 0;
      750 	old_logp = P_old_log_ptr;
      751 
      752 	on cleanup call create_new_log_seg_cleanup ();
      753 	on any_other begin;
      754 	     call Report_Error (0, "Unexpected error while creating new log segment.");
      755 	     goto CREATE_NEW_LOG_SEG_EXIT;
      756 	end;
      757 
      758 /* This procedure mimicks the way log_write_ would create a new log segment.
      759*   That is, it attempts to set up the sequence such that it follows the history.
      760*   However, in this case the most recent history segment may not be available.
      761*   In that case we'll estimate what the next sequence number should be based upon
      762*   the number of history logs we can't see.  */
      763 
      764 	if log_read_data.n_segments = 0
      765 	then new_sequence = 1000000;			/* start it a a million */
      766 	else do;
      767 	     if n_good_hist_segs = 0
      768 	     then n_logs_unseen = log_read_data.n_segments; /* account for its possible sequence numbers */
      769 	     else n_logs_unseen = newest_hist_log_idx - 1;/* account for sequence
      770*						   numbers of history logs we can't look at */
      771 	     if renamed_damaged_log			/* was current log damaged? */
      772 	     then n_logs_unseen = n_logs_unseen + 1;	/* account for its sequence numbers too */
      773 
      774 	     if n_good_hist_segs = 0
      775 	     then					/* new sequence is based on number of logs in history */
      776 		new_sequence = 1000000 + (n_logs_unseen * 100000) + 1;
      777 	     else					/* new sequence is based on number of history logs we can't
      778*						   see and the last sequence number we can see. */
      779 		new_sequence = log_read_data.segments (newest_hist_log_idx).ptr ->
      780 		     log_segment.last_sequence + (n_logs_unseen * 100000) + 1;
      781 	end;
      782 
      783 	/*** set up default info about the new segment */
      784 	log_segment_info_ptr = addr (auto_log_segment_info);
      785 	log_segment_info.dname = log_dname;
      786 	log_segment_info.ename = log_ename;
      787 	log_segment_info.acl_ptr = null ();
      788 	log_segment_info.acl_count = 0;
      789 	log_segment_info.rings (*) = cu_$level_get ();
      790 	log_segment_info.max_length = log_data_$default_log_size;
      791 	log_segment_info.access_class = get_process_access_class_ ();
      792 	log_segment_info.multi_class = "0"b;
      793 	log_segment_info.effective_mode = RW_ACCESS;
      794 
      795 	/*** we may be able to get more precise info */
      796 	if newest_hist_log_idx ^= 0
      797 	then do;
      798 	     hist_log_name = log_read_data.segments (newest_hist_log_idx).ename;
      799 	     sfb.version = status_for_backup_version_2;
      800 	     call hcs_$status_for_backup (log_dname, hist_log_name, addr (sfb), code);
      801 	     if code = 0
      802 	     then do;
      803 		log_segment_info.multi_class = sfb.multiple_class;
      804 		log_segment_info.access_class = sfb.access_class;
      805 	     end;
      806 
      807 	     call hcs_$status_long (log_dname, hist_log_name, 1, addr (status), null (), code);
      808 	     if code = 0
      809 	     then do;
      810 		log_segment_info.effective_mode = substr (status.mode, 2, 3);
      811 		log_segment_info.rings (*) = status.ring_brackets (*);
      812 	     end;
      813 
      814 	     system_area_ptr = get_system_free_area_ ();
      815 	     call hcs_$list_acl (log_dname, hist_log_name, system_area_ptr, acl_ptr, null (), acl_count, code);
      816 	     if code = 0
      817 	     then do;
      818 		log_segment_info.acl_ptr = acl_ptr;
      819 		log_segment_info.acl_count = acl_count;
      820 	     end;
      821 
      822 	     call hcs_$get_max_length_seg (log_read_data.segments (newest_hist_log_idx).ptr, max_len, code);
      823 	     if code = 0
      824 	     then do;
      825 		log_segment_info.max_length = max_len;
      826 	     end;
      827 	end;
      828 
      829 	new_log_ptr = null ();
      830 	call log_create_$new_segment (log_segment_info_ptr, new_log_ptr, code);
      831 	if code ^= 0
      832 	then do;
      833 	     call Report_Error (code, "Unable to create new log segment.");
      834 	     call Finished (code);
      835 	end;
      836 	else do;
      837 	     call Report_Fix (0, "Created new log segment.");
      838 	     call log_segment_$initialize_sequence (new_log_ptr, new_sequence, code);
      839 	     if code ^= 0
      840 	     then call Report_Error (code, "Error initializing sequence in new log segment.");
      841 	     call log_segment_$place_in_service (new_log_ptr, code);
      842 	     if code ^= 0
      843 	     then call Report_Error (code, "Error placing new log segment in service.");
      844 	     call terminate_file_ (old_logp, 0, TERM_FILE_TERM, code);
      845 	     if code ^= 0
      846 	     then call Report_Error (code, "Error terminating old log pointer.");
      847 	     P_old_log_ptr = new_log_ptr;		/* change caller's pointer */
      848 	end;
      849 
      850 CREATE_NEW_LOG_SEG_EXIT:
      851 	call create_new_log_seg_cleanup ();
      852 
      853 	return;
      854 
      855 create_new_log_seg_cleanup:
      856 	procedure;
      857 
      858 declare  based_word		  bit (36) based;
      859 
      860 	     if acl_ptr ^= null ()
      861 	     then do;
      862 		/*** The runtime support for areas will know how
      863*		     much to actually free. ***/
      864 		free acl_ptr -> based_word in (system_area);
      865 	     end;
      866 
      867 	end create_new_log_seg_cleanup;
      868 
      869      end Create_New_Log_Seg;
      870 
      871 
      872 /* *
      873*   *	RENAME_AS_DAMAGED
      874*   *
      875*   *	This routine is invoked when the live log segment is found to
      876*   *	have internal inconsistancies or cannot be initiated.  It changes
      877*   *	the name to LOG_NAME.!(unique).  It happens that a unique character
      878*   *	string and the standard timestamp suffix ("YYYYMMDD.HHMMSS") are the
      879*   *	same length.  Thus, we need not worry about truncation of the name
      880*   *	and namedup errors.
      881*   *
      882**/
      883 
      884 Rename_as_Damaged:
      885      procedure (P_log_dir, P_log_name);
      886 
      887 declare  P_log_name		  char (32) parameter;
      888 declare  P_log_dir		  char (168) parameter;
      889 
      890 declare  lname		  char (32);
      891 declare  ldir		  char (168);
      892 
      893 declare  new_name		  char (32);
      894 declare  code		  fixed bin (35);
      895 
      896 	lname = P_log_name;
      897 	ldir = P_log_dir;
      898 	new_name = rtrim (P_log_name) || "." || unique_chars_ (unique_bits_ ());
      899 	call hcs_$chname_file (ldir, lname, lname, new_name, code);
      900 	if code = 0
      901 	then do;
      902 	     renamed_damaged_log = "1"b;
      903 	     call Report_Fix (0, "Changed name of damaged log segment ^a to ^a.", lname, new_name);
      904 	end;
      905 	else call Report_Error (code, "Unable to change name of damaged log segment ^a to ^a.", lname, new_name);
      906 
      907 	return;
      908 
      909      end Rename_as_Damaged;
      910 
      911 
      912 /* *
      913*   *	RENAME_FOR_LAST_MESSAGE
      914*   *
      915*   *	This routine is invoked when a live log segment is found in a
      916*   *	directory to which we are trying to perform a log migratation.
      917*   *	It places the standard timestamp suffix on the name of the log.
      918*   *
      919**/
      920 
      921 Rename_for_Last_Message:
      922      procedure (P_log_ptr, P_log_name);
      923 
      924 declare  P_log_name		  char (32) parameter;
      925 declare  P_log_ptr		  pointer parameter;
      926 
      927 declare  lname		  char (32);
      928 declare  log_ptr		  pointer;
      929 
      930 declare  name_time		  fixed bin (71);
      931 declare  new_name		  char (32);
      932 declare  code		  fixed bin (35);
      933 declare  i		  fixed bin;
      934 
      935 	lname = P_log_name;
      936 	log_ptr = P_log_ptr;
      937 
      938 	if log_ptr -> log_segment.last_time = 0
      939 	then name_time = clock ();
      940 	else name_time = log_ptr -> log_segment.last_time;
      941 
      942 	do i = 1 to 10;
      943 	     new_name = log_name_$name (lname, name_time);
      944 
      945 	     call hcs_$chname_seg (log_ptr, lname, new_name, code);
      946 	     if code = error_table_$namedup
      947 	     then do;
      948 		name_time = name_time + ONE_SECOND;
      949 		if name_time > clock ()
      950 		then call timer_manager_$sleep (ONE_SECOND, RELATIVE_MICROSECONDS);
      951 	     end;
      952 	     else if code = 0
      953 	     then do;
      954 		call Report_Fix (0, "Renamed log segment ^a to ^a.", lname, new_name);
      955 		return;
      956 	     end;
      957 	     else goto CANNOT_RENAME;			/* unexpected code */
      958 	end;
      959 
      960 CANNOT_RENAME:
      961 	call Report_Error (code, "Unable to rename log segment ^a to ^a.", lname, new_name);
      962 
      963 	return;
      964 
      965      end Rename_for_Last_Message;
      966 
      967 /* format: off */
      968  /* begin include file ... log_salvage_arg.incl.pl1 */
  1     2 
  1     3 /* History:
  1     4*	1985-04-09, EJ Sharpe: initial coding
  1     5**/
  1     6 
  1     7 declare	log_salvage_arg_ptr	pointer;
  1     8 
  1     9 declare 1	log_salvage_arg	aligned based (log_salvage_arg_ptr),
  1    10 	2 version		char (8),		/* LOG_SALVAGE_ARG_VERSION_1 */
  1    11 	2 reporter_proc	entry (char (*)) variable,	/* called to deal with error msgs */
  1    12 	2 from_time	fixed bin (71),	/* amount of history to check */
  1    13 					/* will check only last 5 segs if this is zero */
  1    14 	2 flags,
  1    15 	  3 migrating	bit (1) unal,	/* there should not be a live log seg */
  1    16 	  3 pad		bit (35) unal;
  1    17 
  1    18 declare	LOG_SALVAGE_ARG_VERSION_1 char (8) static options (constant) init ("LOGSLV01");
  1    19 
  1    20 /* end include file ... log_salvage_arg.incl.pl1 */
      968 
      969  /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  2     2 
  2     3 declare   log_segment_ptr               pointer;
  2     4 declare   log_segment_max_size          fixed bin (18);
  2     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  2     6 
  2     7 
  2     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  2     9           2 header                      aligned like log_segment_header,
  2    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  2    11 
  2    12 
  2    13 declare 1 log_segment_header            aligned based,
  2    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  2    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  2    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  2    17 
  2    18           2 limits,
  2    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  2    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  2    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  2    22             3 last_time                 fixed bin (71),
  2    23 
  2    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  2    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  2    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  2    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  2    28 
  2    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  2    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  2    31                                                             /* detect all the dead listeners after a reboot */
  2    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  2    33             3 process_id                bit (36) aligned,
  2    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  2    35 
  2    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  2    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  2    38 
  2    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  2    40 
  2    41 
  2    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  2    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  2    44 
  2    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      969 
      970  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  3     2 
  3     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  3     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  3     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  3     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  3     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  3     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  3     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  3    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  3    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  3    12 
  3    13 declare 1 log_message         aligned based (log_message_ptr),
  3    14           2 header            aligned like log_message_header,
  3    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  3    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  3    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  3    18 
  3    19 declare   log_message_ptr pointer;
  3    20 declare   log_message_text_lth fixed bin;
  3    21 declare   log_message_data_class_lth fixed bin;
  3    22 declare   log_message_data_lth fixed bin;
  3    23 
  3    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      970 
      971  /* BEGIN INCLUDE FILE ... log_read_data.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  4     2 
  4     3 /* Added reader_procedure, area_ptr, reader_data_ptr, and entry variables 11/28/84 Steve Herbst */
  4     4 /* Added (latest earlier)_message_ptr, (first last)_held_message and get_log_uid 11/30/84 Steve Herbst */
  4     5 /* Put everything before the segments array into header 12/04/84 Steve Herbst */
  4     6 /* Added entry variables free_message, register & deregister 12/06/84 Steve Herbst */
  4     7 
  4     8 
  4     9 declare   log_read_data_ptr             pointer;
  4    10 declare   log_read_data_n_segments      fixed bin;
  4    11 
  4    12 declare 1 log_read_data                 aligned based (log_read_data_ptr),
  4    13           2 header                      aligned,
  4    14 	  3 sentinel		char (8) aligned,
  4    15             3 n_segments                fixed bin,
  4    16             3 history_complete          bit (1) aligned,
  4    17 	  3 call_procedures		bit (1) aligned,
  4    18 	  3 allocate_copies		bit (1) aligned,
  4    19             3 current_ptr               pointer,            /* Trivial optimization for positioning */
  4    20             3 current_idx               fixed bin,
  4    21 	  3 reader_data_ptr		pointer,		/* log_read_data_ptr returned by reader_proc$open */
  4    22 	  3 user_area_ptr		pointer,            /* Used in the inner ring to allocate outer ring copies. */
  4    23 	  3 latest_message		aligned like saved_message,	/* The last message returned */
  4    24 	  3 earlier_message		aligned like saved_message,	/* The one returned before latest */
  4    25 	  3 n_held_messages           fixed bin,
  4    26 	  3 first_held_message_ptr	pointer,		/* Used by $hold_message */
  4    27 	  3 last_held_message_ptr	pointer,		/* ditto */
  4    28 	  3 ev,					/* Entry variable for each operation */
  4    29 	    4 open variable entry (char (*), char (*), pointer, pointer, fixed bin (35)),
  4    30 	    4 close variable entry (pointer, fixed bin (35)),
  4    31 	    4 next_message variable entry (pointer, pointer, fixed bin (35)),
  4    32 	    4 prev_message variable entry (pointer, pointer, fixed bin (35)),
  4    33 	    4 position_sequence variable entry (pointer, fixed bin (35), bit (1) aligned, pointer, fixed bin (35)),
  4    34 	    4 position_time variable entry (pointer, fixed bin (71), bit (1) aligned, pointer, fixed bin (35)),
  4    35 	    4 update variable entry (fixed bin (35), pointer, pointer, fixed bin (35)),
  4    36 	    4 hold_message variable entry (pointer, pointer),
  4    37 	    4 free_message variable entry (pointer, pointer),
  4    38 	    4 get_log_uid variable entry (pointer, bit (36) aligned, fixed bin (35)),
  4    39 	    4 register variable entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35)),
  4    40 	    4 deregister variable entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35)),
  4    41 	  3 limits                      aligned,            /* Absolute limits of family contents */
  4    42 	    4 very_first_time           fixed bin (71),     /* Set up during initialization */
  4    43 	    4 very_last_time            fixed bin (71),
  4    44 	    4 very_first_sequence       fixed bin (35),
  4    45 	    4 very_last_sequence        fixed bin (35),
  4    46 	    4 very_first_log_idx        fixed bin,
  4    47 	    4 very_last_log_idx         fixed bin,
  4    48 
  4    49           2 segments (log_read_data_n_segments refer (log_read_data.n_segments)),
  4    50             3 dname                     char (168) unaligned,
  4    51             3 ename                     char (32) unaligned,
  4    52             3 ptr                       pointer,
  4    53             3 suffix_time               fixed bin (71),     /* Time from suffix-- all messages in log are earlier */
  4    54             3 dir_uid                   bit (36) aligned,   /* UID of parent dir */
  4    55             3 prev_missing              bit (1) aligned,
  4    56             3 damaged                   bit (1) aligned,
  4    57 
  4    58           2 pad                         fixed bin;
  4    59 
  4    60 declare 1 saved_message		aligned based,
  4    61 	2 actual_ptr		pointer,		/* Points to message in log. */
  4    62 	2 copy_ptr		pointer;		/* Points to user-ring allocated copy. */
  4    63 
  4    64 dcl  1 log_held_message_node aligned based,
  4    65        2 message aligned like saved_message,
  4    66        2 reference_count fixed bin,
  4    67        2 next_ptr ptr;
  4    68 
  4    69 declare LOG_READ_DATA_VERSION_SENTINEL char (8) int static options (constant)
  4    70         init ("logr0001") options (constant);
  4    71 
  4    72 /* END INCLUDE FILE ... log_read_data.incl.pl1 */
      971 
      972  /* BEGIN INCLUDE FILE ... log_write_data.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  5     2 
  5     3 declare   log_write_data_ptr            pointer;
  5     4 declare   log_segment_info_ptr          pointer;
  5     5 
  5     6 declare 1 log_write_data                aligned based (log_write_data_ptr),
  5     7           2 log_name                    char (32) unaligned,
  5     8 
  5     9           2 log_ptr                     pointer,
  5    10           2 migrating                   bit (1) aligned,
  5    11           2 pad (13)                    bit (36) aligned,
  5    12 
  5    13           2 segment_info                aligned like log_segment_info;
  5    14 
  5    15 
  5    16 declare 1 log_segment_info              aligned based (log_segment_info_ptr),
  5    17           2 dname                       char (168) unaligned,
  5    18           2 ename                       char (32) unaligned,
  5    19 
  5    20           2 acl_ptr                     pointer,
  5    21           2 acl_count                   fixed bin,
  5    22           2 rings                       (3) fixed bin (3),
  5    23           2 max_length                  fixed bin (19),
  5    24           2 access_class                bit (72) aligned,
  5    25           2 multi_class                 bit (1) aligned,
  5    26 	2 effective_mode		bit (36) aligned;
  5    27 
  5    28 /* END INCLUDE FILE ... log_write_data.incl.pl1 */
      972 
      973  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  6     2*
  6     3*   Values for the "access mode" argument so often used in hardcore
  6     4*   James R. Davis 26 Jan 81  MCR 4844
  6     5*   Added constants for SM access 4/28/82 Jay Pattin
  6     6*   Added text strings 03/19/85 Chris Jones
  6     7**/
  6     8 
  6     9 
  6    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  6    11 dcl	(
  6    12 	N_ACCESS		   init ("000"b),
  6    13 	R_ACCESS		   init ("100"b),
  6    14 	E_ACCESS		   init ("010"b),
  6    15 	W_ACCESS		   init ("001"b),
  6    16 	RE_ACCESS		   init ("110"b),
  6    17 	REW_ACCESS	   init ("111"b),
  6    18 	RW_ACCESS		   init ("101"b),
  6    19 	S_ACCESS		   init ("100"b),
  6    20 	M_ACCESS		   init ("010"b),
  6    21 	A_ACCESS		   init ("001"b),
  6    22 	SA_ACCESS		   init ("101"b),
  6    23 	SM_ACCESS		   init ("110"b),
  6    24 	SMA_ACCESS	   init ("111"b)
  6    25 	)		   bit (3) internal static options (constant);
  6    26 
  6    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  6    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  6    29 
  6    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  6    31 			   static options (constant);
  6    32 
  6    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  6    34 			   static options (constant);
  6    35 
  6    36 dcl	(
  6    37 	N_ACCESS_BIN	   init (00000b),
  6    38 	R_ACCESS_BIN	   init (01000b),
  6    39 	E_ACCESS_BIN	   init (00100b),
  6    40 	W_ACCESS_BIN	   init (00010b),
  6    41 	RW_ACCESS_BIN	   init (01010b),
  6    42 	RE_ACCESS_BIN	   init (01100b),
  6    43 	REW_ACCESS_BIN	   init (01110b),
  6    44 	S_ACCESS_BIN	   init (01000b),
  6    45 	M_ACCESS_BIN	   init (00010b),
  6    46 	A_ACCESS_BIN	   init (00001b),
  6    47 	SA_ACCESS_BIN	   init (01001b),
  6    48 	SM_ACCESS_BIN	   init (01010b),
  6    49 	SMA_ACCESS_BIN	   init (01011b)
  6    50 	)		   fixed bin (5) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      973 
      974  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      974 
      975  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  8     2 
  8     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  8     4 
  8     5 /* This include file contains branch and link structures returned by
  8     6*   hcs_$status_ and hcs_$status_long. */
  8     7 
  8     8 dcl 1 status_branch aligned based (status_ptr),
  8     9     2 short aligned,
  8    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  8    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  8    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  8    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  8    14       3 dtu bit (36) unaligned,			/* date/time last used */
  8    15       3 mode bit (5) unaligned,			/* caller's effective access */
  8    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  8    17       3 pad1 bit (8) unaligned,
  8    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  8    19 
  8    20 /* Limit of information returned by hcs_$status_ */
  8    21 
  8    22     2 long aligned,
  8    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  8    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  8    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  8    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  8    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  8    28       3 pad2 bit (8) unaligned,
  8    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  8    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  8    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  8    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  8    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  8    34       3 pad3 bit (5) unaligned,
  8    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  8    36       3 uid bit (36) unaligned;			/* unique ID */
  8    37 
  8    38 dcl 1 status_link aligned based (status_ptr),
  8    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  8    40     2 nnames fixed bin (16) unaligned unsigned,
  8    41     2 names_relp bit (18) unaligned,
  8    42     2 dtem bit (36) unaligned,
  8    43     2 dtd bit (36) unaligned,
  8    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  8    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  8    46 
  8    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  8    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  8    49 						/* array of names returned */
  8    50      status_pathname character (status_link.pathname_length) aligned
  8    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  8    52 						/* link target path */
  8    53      status_area_ptr pointer,
  8    54      status_ptr pointer;
  8    55 
  8    56 dcl (Link initial (0),
  8    57      Segment initial (1),
  8    58      Directory initial (2)) fixed bin internal static options (constant);
  8    59 						/* values for type fields declared above */
  8    60 
  8    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      975 
      976  /* --------------- BEGIN include file status_for_backup.incl.pl1 --------------- */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-05-20,Lippard), approve(86-06-02,MCR7427),
  9     6*     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
  9     7*      Change non-returned information into pad fields.
  9     8*                                                   END HISTORY COMMENTS */
  9     9 
  9    10 
  9    11 dcl 1 status_for_backup aligned based,
  9    12     2 version fixed bin,
  9    13     2 pad1 bit (108),
  9    14     2 switches unaligned,
  9    15       3 safety bit (1) unaligned,
  9    16       3 entrypt bit (1) unaligned,
  9    17       3 security_oosw bit (1) unaligned,
  9    18       3 audit_flag bit (1) unaligned,
  9    19       3 multiple_class bit (1) unaligned,
  9    20       3 pad2 bit (2) unaligned,
  9    21       3 master_dir bit (1) unaligned,
  9    22       3 tpd bit (1) unaligned,
  9    23       3 pad13 bit (13) unaligned,
  9    24     2 entrypt_bound bit (14) unaligned,
  9    25     2 access_class bit (72),
  9    26     2 spad bit (36),
  9    27     2 author char (32),
  9    28     2 bc_author char (32),
  9    29     2 lvid bit (36),
  9    30     2 pvid bit (36),
  9    31     2 pad3 bit (216);
  9    32 
  9    33 dcl  status_for_backup_version_2 fixed bin initial (2) static options (constant);
  9    34 
  9    35 /* ---------------- END include file status_for_backup.incl.pl1 ---------------- */
      976 
      977  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 10     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 10     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 10     4 
 10     5 /* This include file has an ALM version.  Keep 'em in sync! */
 10     6 
 10     7 dcl (
 10     8 
 10     9 /* The following constants define the message action codes.  This indicates
 10    10*how a message is to be handled.  */
 10    11 
 10    12      SYSERR_CRASH_SYSTEM	init (1),			
 10    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 10    14 
 10    15      SYSERR_TERMINATE_PROCESS	init (2),
 10    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 10    17 
 10    18      SYSERR_PRINT_WITH_ALARM	init (3),
 10    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 10    20 
 10    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 10    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 10    23 
 10    24      SYSERR_LOG_OR_PRINT	init (4),
 10    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 10    26 
 10    27      SYSERR_LOG_OR_DISCARD	init (5),
 10    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 10    29 
 10    30 
 10    31 /* The following constants are added to the normal severities to indicate
 10    32*different sorting classes of messages.  */
 10    33 
 10    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 10    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 10    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 10    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 10    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 10    39 	) fixed bin internal static options (constant);
 10    40 
 10    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      977 
      978 
      979      end log_salvage_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  log_salvage_.pl1                  >spec>install>1111>log_salvage_.pl1
968          1    04/25/85  0909.8  log_salvage_arg.incl.pl1          >ldd>include>log_salvage_arg.incl.pl1
969          2    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
970          3    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
971          4    01/21/85  0912.3  log_read_data.incl.pl1            >ldd>include>log_read_data.incl.pl1
972          5    01/21/85  0912.3  log_write_data.incl.pl1           >ldd>include>log_write_data.incl.pl1
973          6    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
974          7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
975          8    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
976          9    06/17/86  1513.1  status_for_backup.incl.pl1        >ldd>include>status_for_backup.incl.pl1
977         10    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LOG_SALVAGE_ARG_VERSION_1       000006 constant        char(8)                  initial packed unaligned dcl 1-18 ref 215
LOG_SEGMENT_COMPLETE_MESSAGE    000002 constant        bit(36)                  initial dcl 2-43 ref 677
LOG_SEGMENT_NEW_MESSAGE         000003 constant        bit(36)                  initial dcl 2-42 ref 677
LOG_SEGMENT_VERSION_1           000004 constant        char(8)                  initial packed unaligned dcl 2-5 ref 618
NUM_GOOD_HIST_DESIRED                  constant        fixed bin(17,0)          initial dcl 149 ref 256
ONE_SECOND                      000010 constant        fixed bin(71,0)          initial dcl 150 set ref 948 949*
P_code                                 parameter       fixed bin(35,0)          dcl 399 ref 396 403 405 407
P_current_log                          parameter       bit(1)                   dcl 597 ref 592 606
P_log_dir                              parameter       char(168)                packed unaligned dcl 888 ref 884 897
P_log_dname                            parameter       char                     packed unaligned dcl 57 ref 11 209
P_log_ename                            parameter       char                     packed unaligned dcl 58 ref 11 210
P_log_idx                              parameter       fixed bin(17,0)          dcl 551 ref 548 558
P_log_name                             parameter       char(32)                 packed unaligned dcl 924 in procedure
                                                                                  "Rename_for_Last_Message" ref 921 935
P_log_name                             parameter       char(32)                 packed unaligned dcl 596 in procedure
                                                                                  "Check_Log_Segment" ref 592 605
P_log_name                             parameter       char(32)                 packed unaligned dcl 887 in procedure
                                                                                  "Rename_as_Damaged" ref 884 896 898
P_log_ptr                              parameter       pointer                  dcl 595 in procedure "Check_Log_Segment" ref 592 604
P_log_ptr                              parameter       pointer                  dcl 925 in procedure "Rename_for_Last_Message" ref
                                                                                  921 936
P_old_log_ptr                          parameter       pointer                  dcl 727 set ref 724 750 847*
P_salv_code                            parameter       fixed bin(35,0)          dcl 60 set ref 11 403* 405* 407*
P_salvage_arg_ptr                      parameter       pointer                  dcl 59 ref 11 211
RELATIVE_MICROSECONDS           000051 constant        bit(2)                   initial packed unaligned dcl 151 set ref 949*
RW_ACCESS                       000001 constant        bit(3)                   initial packed unaligned dcl 6-11 set ref 298* 559*
                                                                                  793
R_ACCESS                        000051 constant        bit(3)                   initial packed unaligned dcl 6-11 set ref 564*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 7-14 set ref 436* 447*
                                                                                  844*
abs                                                    builtin function         dcl 158 ref 657
access_class              5     000235 automatic       bit(72)                  level 2 in structure "sfb" dcl 744 in procedure
                                                                                  "Create_New_Log_Seg" set ref 804
access_class             71            based           bit(72)                  level 2 in structure "log_segment_info" dcl 5-16
                                                                                  in procedure "log_salvage_" set ref 791* 804*
acl_count                       000104 automatic       fixed bin(17,0)          dcl 732 in procedure "Create_New_Log_Seg" set ref
                                                                                  749* 815* 819
acl_count                64            based           fixed bin(17,0)          level 2 in structure "log_segment_info" dcl 5-16
                                                                                  in procedure "log_salvage_" set ref 788* 819*
acl_ptr                  62            based           pointer                  level 2 in structure "log_segment_info" dcl 5-16
                                                                                  in procedure "log_salvage_" set ref 787* 818*
acl_ptr                         000102 automatic       pointer                  dcl 731 in procedure "Create_New_Log_Seg" set ref
                                                                                  748* 815* 818 860 864
addr                                                   builtin function         dcl 159 ref 213 351 504 506 506 512 641 676 784 800
                                                                                  800 807 807
alloc_info               64            based           structure                level 3 dcl 2-8 set ref 351 641
any_other                       000000 stack reference condition                dcl 153 ref 527 613 753
arg_code                               based           fixed bin(35,0)          dcl 469 ref 501
argl                            000100 automatic       fixed bin(21,0)          dcl 470 set ref 495*
argp                            000102 automatic       pointer                  dcl 471 set ref 495* 501
auto_log_salvage_arg            000162 automatic       structure                level 1 dcl 67 set ref 212* 213
auto_log_segment_info           000126 automatic       structure                level 1 dcl 742 set ref 784
based_word                             based           bit(36)                  packed unaligned dcl 858 ref 864
bit_count                       000173 automatic       fixed bin(24,0)          dcl 70 set ref 298* 559* 564*
cleanup                         000224 stack reference condition                dcl 154 ref 223 752
clock                                                  builtin function         dcl 160 ref 218 618 618 938 949
code                            000360 automatic       fixed bin(35,0)          dcl 894 in procedure "Rename_as_Damaged" set ref
                                                                                  899* 900 905*
code                            000414 automatic       fixed bin(35,0)          dcl 932 in procedure "Rename_for_Last_Message" set
                                                                                  ref 945* 946 952 960*
code                            000174 automatic       fixed bin(35,0)          dcl 71 in procedure "log_salvage_" set ref 229* 230
                                                                                  232 233* 234* 298* 300 308 329*
code                            000105 automatic       fixed bin(35,0)          dcl 733 in procedure "Create_New_Log_Seg" set ref
                                                                                  800* 801 807* 808 815* 816 822* 823 830* 831 833*
                                                                                  834* 838* 839 839* 841* 842 842* 844* 845 845*
complete_msg                           based           char                     packed unaligned dcl 482 set ref 528*
complete_msg_buff               000344 automatic       char(614)                packed unaligned dcl 483 set ref 512 513 514*
complete_msg_len                000576 automatic       fixed bin(21,0)          dcl 484 set ref 513* 514* 519* 528 528
complete_msg_ptr                000600 automatic       pointer                  dcl 485 set ref 512* 518* 528
convert_status_code_            000034 constant        entry                    external dcl 120 ref 511
cu_$arg_ptr                     000036 constant        entry                    external dcl 121 ref 495
cu_$level_get                   000040 constant        entry                    external dcl 122 ref 789
current_log                     000112 automatic       bit(1)                   dcl 601 set ref 606* 644 650
current_log_ptr                 000176 automatic       pointer                  dcl 72 set ref 205* 298* 311* 314* 320* 325* 347 347
                                                                                  351 359* 443 445 446*
data                    226            based           bit(36)                  array level 2 dcl 2-8 set ref 676
dname                                  based           char(168)                level 2 packed packed unaligned dcl 5-16 set ref
                                                                                  785*
done                            000200 automatic       bit(1)                   dcl 73 set ref 244* 245 254* 256*
ecode                           000255 automatic       fixed bin(35,0)          dcl 555 in procedure
                                                                                  "Initiate_History_Segment_and_Check" set ref 559*
                                                                                  560 564* 566 568*
ecode                           000104 automatic       fixed bin(35,0)          dcl 473 in procedure "Report_Error" set ref 495* 498
                                                                                  498* 501* 509 511*
effective_mode           74            based           bit(36)                  level 2 dcl 5-16 set ref 793* 810*
ename                    52            based           char(32)                 level 2 in structure "log_segment_info" packed
                                                                                  packed unaligned dcl 5-16 in procedure
                                                                                  "log_salvage_" set ref 786*
ename                   176            based           char(32)                 array level 3 in structure "log_read_data" packed
                                                                                  packed unaligned dcl 4-12 in procedure
                                                                                  "log_salvage_" set ref 277* 277* 356* 559* 564*
                                                                                  566* 568* 571* 798
error_found                     000201 automatic       bit(1)                   dcl 74 set ref 198* 487*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 104 ref 405
error_table_$bad_arg            000012 external static fixed bin(35,0)          dcl 105 set ref 218*
error_table_$namedup            000014 external static fixed bin(35,0)          dcl 106 ref 946
error_table_$no_w_permission    000022 external static fixed bin(35,0)          dcl 109 set ref 560 566*
error_table_$noentry            000016 external static fixed bin(35,0)          dcl 107 ref 300
error_table_$nomatch            000020 external static fixed bin(35,0)          dcl 108 ref 230
error_table_$unexpected_condition
                                000024 external static fixed bin(35,0)          dcl 110 set ref 527*
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 111 set ref 215*
first_sequence           56            based           fixed bin(35,0)          level 4 dcl 2-8 ref 276 347 347 374 618 618 618 657
                                                                                  673
first_sequence_temp             000202 automatic       fixed bin(35,0)          dcl 75 set ref 347* 352* 354
first_time               60            based           fixed bin(71,0)          level 4 dcl 2-8 ref 618
fix_applied                     000203 automatic       bit(1)                   dcl 76 set ref 199* 403 493*
flags                    10            based           structure                level 2 dcl 1-9
flip_service_bit                000100 automatic       bit(1)                   dcl 636 set ref 640* 647* 653* 690
formline_                       000042 constant        entry                    external dcl 123 ref 506
from_time                 6            based           fixed bin(71,0)          level 2 dcl 1-9 ref 218 218 218 254 254
get_process_access_class_       000044 constant        entry                    external dcl 125 ref 791
get_system_free_area_           000046 constant        entry                    external dcl 126 ref 814
hcs_$chname_file                000050 constant        entry                    external dcl 127 ref 899
hcs_$chname_seg                 000052 constant        entry                    external dcl 128 ref 945
hcs_$get_max_length_seg         000054 constant        entry                    external dcl 129 ref 822
hcs_$list_acl                   000056 constant        entry                    external dcl 130 ref 815
hcs_$status_for_backup          000060 constant        entry                    external dcl 131 ref 800
hcs_$status_long                000062 constant        entry                    external dcl 132 ref 807
header                                 based           structure                level 2 in structure "log_segment" dcl 2-8
                                                                                  in procedure "log_salvage_"
header                                 based           structure                level 2 in structure "log_message" dcl 3-13
                                                                                  in procedure "log_salvage_"
header                                 based           structure                level 2 in structure "log_read_data" dcl 4-12
                                                                                  in procedure "log_salvage_"
hist_log_name                   000106 automatic       char(32)                 packed unaligned dcl 734 set ref 798* 800* 807* 815*
history_log_ptr                 000206 automatic       pointer                  dcl 78 set ref 202* 344* 345 354
i                               000415 automatic       fixed bin(17,0)          dcl 933 in procedure "Rename_for_Last_Message" set
                                                                                  ref 942*
i                               000204 automatic       fixed bin(17,0)          dcl 77 in procedure "log_salvage_" set ref 245* 246*
                                                                                  247 250 252 254* 272* 273 277 282* 431* 432 434
                                                                                  435*
ignore_short_mess               000106 automatic       char(8)                  dcl 474 set ref 511*
in_service                1(17)        based           bit(1)                   level 2 packed packed unaligned dcl 95 set ref 642
                                                                                  694*
initiate_file_                  000064 constant        entry                    external dcl 133 ref 298 559 564
ioa_$rsnpnnl                    000066 constant        entry                    external dcl 134 ref 514
last_sequence            57            based           fixed bin(35,0)          level 4 dcl 2-8 ref 276 354 618 657 777
last_time                62            based           fixed bin(71,0)          level 4 dcl 2-8 ref 618 618 938 940
ldir                            000276 automatic       char(168)                packed unaligned dcl 891 set ref 897* 899*
length                                                 builtin function         dcl 161 ref 513
limits                   56            based           structure                level 3 dcl 2-8
lname                           000102 automatic       char(32)                 packed unaligned dcl 600 in procedure
                                                                                  "Check_Log_Segment" set ref 605* 609* 614* 627*
                                                                                  646* 652* 659* 665* 680* 696*
lname                           000266 automatic       char(32)                 packed unaligned dcl 890 in procedure
                                                                                  "Rename_as_Damaged" set ref 896* 899* 899* 903*
                                                                                  905*
lname                           000370 automatic       char(32)                 packed unaligned dcl 927 in procedure
                                                                                  "Rename_for_Last_Message" set ref 935* 943* 945*
                                                                                  954* 960*
log_create_$new_segment         000070 constant        entry                    external dcl 135 ref 830
log_data_$default_log_size      000030 external static fixed bin(35,0)          dcl 113 ref 790
log_dname                       000100 automatic       char(168)                packed unaligned dcl 65 set ref 209* 229* 233* 298*
                                                                                  313* 322* 329* 329* 330* 358* 559* 564* 785 800*
                                                                                  807* 815*
log_ename                       000152 automatic       char(32)                 packed unaligned dcl 66 set ref 210* 229* 233* 298*
                                                                                  311* 313* 319* 320* 322* 325* 329* 329* 330* 356*
                                                                                  358* 786
log_idx                         000254 automatic       fixed bin(17,0)          dcl 553 set ref 558* 559 564 566 568 571 574
log_list_history_$single_dir    000072 constant        entry                    external dcl 136 ref 229
log_message                            based           structure                level 1 dcl 3-13
log_message_header                     based           structure                level 1 dcl 3-3
log_message_ptr                 000236 automatic       pointer                  dcl 3-19 set ref 676* 677 677
log_name_$name                  000074 constant        entry                    external dcl 137 ref 943
log_ptr                         000256 automatic       pointer                  dcl 556 in procedure
                                                                                  "Initiate_History_Segment_and_Check" set ref 559*
                                                                                  564* 571* 571* 574
log_ptr                         000400 automatic       pointer                  dcl 928 in procedure "Rename_for_Last_Message" set
                                                                                  ref 936* 938 940 945*
log_read_data                          based           structure                level 1 dcl 4-12 set ref 439
log_read_data_ptr               000240 automatic       pointer                  dcl 4-9 set ref 201* 229* 245 247 254 270 273 277
                                                                                  277 344 356 374 429 431 432 434 435 439 440* 559
                                                                                  564 566 568 571 574 764 767 777 798 822
log_salvage_arg                        based           structure                level 1 dcl 1-9 ref 212
log_salvage_arg_ptr             000232 automatic       pointer                  dcl 1-7 set ref 211* 212 213* 215 218 218 218 254
                                                                                  254 301 309 331 359 528
log_segment                            based           structure                level 1 dcl 2-8
log_segment_$initialize_sequence
                                000076 constant        entry                    external dcl 138 ref 838
log_segment_$place_in_service   000100 constant        entry                    external dcl 139 ref 841
log_segment_header                     based           structure                level 1 dcl 2-13
log_segment_info                       based           structure                level 1 dcl 5-16
log_segment_info_ptr            000242 automatic       pointer                  dcl 5-4 set ref 784* 785 786 787 788 789 790 791 792
                                                                                  793 803 804 810 811 818 819 825 830*
log_segment_ptr                 000234 automatic       pointer                  dcl 2-3 set ref 273* 274 276 281 374
long                      4     000223 automatic       structure                level 2 dcl 743
long_mess                       000110 automatic       char(100)                dcl 475 set ref 511* 514*
lp                              000100 automatic       pointer                  dcl 599 set ref 604* 618 618 618 618 618 618 618 618
                                                                                  618 618 641 657 657 663 673 676
max_len                         000116 automatic       fixed bin(19,0)          dcl 735 set ref 822* 825
max_length               70            based           fixed bin(19,0)          level 2 dcl 5-16 set ref 790* 825*
max_size                 66            based           fixed bin(18,0)          level 3 dcl 2-8 ref 663
migrating                10            based           bit(1)                   level 3 packed packed unaligned dcl 1-9 ref 301 309
                                                                                  331 359
mode                      3     000223 automatic       bit(5)                   level 3 packed packed unaligned dcl 743 set ref 810
msg                                    based           char                     packed unaligned dcl 477 set ref 514*
msg_buff                        000141 automatic       char(512)                packed unaligned dcl 478 set ref 504 505 506 506
msg_len                         000341 automatic       fixed bin(21,0)          dcl 479 set ref 505* 506* 514 514 519
msg_ptr                         000342 automatic       pointer                  dcl 480 set ref 504* 514 518
multi_class              73            based           bit(1)                   level 2 dcl 5-16 set ref 792* 803*
multiple_class            4(04) 000235 automatic       bit(1)                   level 3 packed packed unaligned dcl 744 set ref 803
n_good_hist_segs                000210 automatic       fixed bin(17,0)          dcl 79 set ref 243* 249* 249 250 256 258 341 767 774
n_logs_unseen                   000117 automatic       fixed bin(17,0)          dcl 736 set ref 767* 769* 771* 771 774 777
n_segments                2            based           fixed bin(17,0)          level 3 dcl 4-12 ref 245 374 431 439 764 767
name_time                       000402 automatic       fixed bin(71,0)          dcl 930 set ref 938* 940* 943* 948* 948 949
new_log_ptr                     000120 automatic       pointer                  dcl 737 set ref 829* 830* 838* 841* 847
new_name                        000350 automatic       char(32)                 packed unaligned dcl 893 in procedure
                                                                                  "Rename_as_Damaged" set ref 898* 899* 903* 905*
new_name                        000404 automatic       char(32)                 packed unaligned dcl 931 in procedure
                                                                                  "Rename_for_Last_Message" set ref 943* 945* 954*
                                                                                  960*
new_sequence                    000122 automatic       fixed bin(35,0)          dcl 738 set ref 764* 774* 777* 838*
newest_hist_log_idx             000211 automatic       fixed bin(17,0)          dcl 80 set ref 204* 250* 272 344 356 769 777 796 798
                                                                                  822
next_older_log_idx              000212 automatic       fixed bin(17,0)          dcl 81 set ref 271* 277 282*
next_older_log_ptr              000214 automatic       pointer                  dcl 82 set ref 270* 276 281*
no_write_permission             000000 stack reference condition                dcl 155 ref 693 695
null                                                   builtin function         dcl 162 ref 201 202 205 247 274 303 303 331 331 345
                                                                                  429 432 435 440 443 446 571 747 748 787 807 807
                                                                                  815 815 829 860
number                    0(17)        based           fixed bin(35,0)          level 2 packed packed unaligned dcl 95 ref 352 657
old_logp                        000100 automatic       pointer                  dcl 729 set ref 750* 844*
oldest_hist_log_idx             000216 automatic       fixed bin(17,0)          dcl 83 set ref 203* 252* 270 271 272
p                               000100 automatic       pointer                  dcl 427 set ref 434* 436* 445* 447*
pathname_                       000102 constant        entry                    external dcl 140 ref 329 329
ptr                     206            based           pointer                  array level 3 dcl 4-12 set ref 247 270 273 344 432
                                                                                  434 435* 574* 777 822*
renamed_damaged_log             000217 automatic       bit(1)                   dcl 84 set ref 206* 771 902*
reporter_proc             2            based           entry variable           level 2 dcl 1-9 ref 528
ring_brackets            10(18) 000223 automatic       fixed bin(6,0)           array level 3 packed packed unsigned unaligned
                                                                                  dcl 743 set ref 811
rings                    65            based           fixed bin(3,0)           array level 2 dcl 5-16 set ref 789* 811*
rtrim                                                  builtin function         dcl 163 ref 898
saved_message                          based           structure                level 1 dcl 4-60
seg_fault_error                 000000 stack reference condition                dcl 156 ref 608
segments                124            based           structure                array level 2 dcl 4-12
sentinel                               based           bit(36)                  level 3 dcl 3-13 ref 677 677
sequence_info                          based           structure                level 1 dcl 95
sequence_info_ptr               000222 automatic       pointer                  dcl 94 set ref 351* 352 641* 642 657 663 694
sequence_problem_detected       000220 automatic       bit(1)                   dcl 85 set ref 269* 279*
service_bit                     000101 automatic       bit(1)                   dcl 637 set ref 642* 644 650 694 696
sfb                             000235 automatic       structure                level 1 dcl 744 set ref 800 800
short                           000223 automatic       structure                level 2 dcl 743
size                                                   builtin function         dcl 164 ref 505
status                          000223 automatic       structure                level 1 dcl 743 set ref 807 807
status_branch                          based           structure                level 1 dcl 8-8
status_for_backup                      based           structure                level 1 dcl 9-11
status_for_backup_version_2            constant        fixed bin(17,0)          initial dcl 9-33 ref 799
substr                                                 builtin function         dcl 165 ref 810
suffix_time             210            based           fixed bin(71,0)          array level 3 dcl 4-12 ref 254
switches                  4     000235 automatic       structure                level 2 packed packed unaligned dcl 744
sys_info$first_reasonable_time  000032 external static fixed bin(71,0)          dcl 115 ref 218 618
system_area                            based           area(1024)               dcl 739 ref 864
system_area_ptr                 000124 automatic       pointer                  dcl 740 set ref 747* 814* 815* 864
terminate_file_                 000104 constant        entry                    external dcl 141 ref 436 447 844
time_created              2            based           fixed bin(71,0)          level 3 dcl 2-8 ref 618 618
timer_manager_$sleep            000106 constant        entry                    external dcl 142 ref 949
unique_bits_                    000110 constant        entry                    external dcl 143 ref 898 898
unique_chars_                   000112 constant        entry                    external dcl 144 ref 898
version                                based           char(8)                  level 3 in structure "log_segment" packed packed
                                                                                  unaligned dcl 2-8 in procedure "log_salvage_" ref
                                                                                  618
version                         000235 automatic       fixed bin(17,0)          level 2 in structure "sfb" dcl 744 in procedure
                                                                                  "Create_New_Log_Seg" set ref 799*
version                                based           char(8)                  level 2 in structure "log_salvage_arg" dcl 1-9
                                                                                  in procedure "log_salvage_" ref 215
words_used                1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 95 ref
                                                                                  663

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 10-7
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
BEEP                                   internal static fixed bin(17,0)          initial dcl 10-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 10-7
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-33
Directory                              internal static fixed bin(17,0)          initial dcl 8-56
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 10-7
LOG                                    internal static fixed bin(17,0)          initial dcl 10-7
LOG_READ_DATA_VERSION_SENTINEL         internal static char(8)                  initial packed unaligned dcl 4-69
Link                                   internal static fixed bin(17,0)          initial dcl 8-56
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 10-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
Segment                                internal static fixed bin(17,0)          initial dcl 8-56
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 10-7
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 7-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
get_group_id_                   000000 constant        entry                    external dcl 124
log_held_message_node                  based           structure                level 1 dcl 4-64
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 3-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 3-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 3-20
log_read_data_n_segments               automatic       fixed bin(17,0)          dcl 4-10
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 2-4
log_write_data                         based           structure                level 1 dcl 5-6
log_write_data_ptr                     automatic       pointer                  dcl 5-3
status_area_ptr                        automatic       pointer                  dcl 8-47
status_entry_names                     based           char(32)                 array dcl 8-47
status_link                            based           structure                level 1 dcl 8-38
status_pathname                        based           char                     dcl 8-47
status_ptr                             automatic       pointer                  dcl 8-47
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 7-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CANNOT_RENAME                   004667 constant        label                    dcl 960 ref 952
CHECK_LOG_SEG_EXIT              002743 constant        label                    dcl 628 ref 610 615
CREATE_NEW_LOG_SEG_EXIT         004263 constant        label                    dcl 850 ref 755
Check_Alloc_Info_and_Messages   002747 constant        entry                    internal dcl 633 ref 618
Check_Log_Segment               002510 constant        entry                    internal dcl 592 ref 311 320 571
Cleanup                         001651 constant        entry                    internal dcl 424 ref 223 401
Create_New_Log_Seg              003326 constant        entry                    internal dcl 724 ref 303 314 331 359
Finished                        001611 constant        entry                    internal dcl 396 ref 215 218 234 304 306 315 323 333
                                                                                  341 361 377 381 498 527 834
Initiate_History_Segment_and_Check
                                002260 constant        entry                    internal dcl 548 ref 246
MAIN_RETURN                     001607 constant        label                    dcl 413 ref 409
REPORT_COMMON                   002036 constant        label                    dcl 495 ref 488
Rename_as_Damaged               004306 constant        entry                    internal dcl 884 ref 313 322 330 358
Rename_for_Last_Message         004517 constant        entry                    internal dcl 921 ref 325
Report_Error                    002014 constant        entry                    internal dcl 466 ref 233 277 319 329 356 376 566 568
                                                                                  609 614 627 646 652 659 665 680 754 833 839 842
                                                                                  845 905 960
Report_Fix                      002026 constant        entry                    internal dcl 490 ref 696 837 903 954
SKIP_HISTORY                    001102 constant        label                    dcl 298 ref 230 258
create_new_log_seg_cleanup      004271 constant        entry                    internal dcl 855 ref 752 850
log_salvage_                    000473 constant        entry                    external dcl 11
return_failure                  003322 constant        label                    dcl 700 ref 660 666 681 693
return_success                  003226 constant        label                    dcl 690 ref 673

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5554        5670    4737        5564
Length      6356    4737       114         452     614           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_salvage_                        534 external procedure  is an external procedure.  
on unit on line 223                  64 on unit               
Finished                             64 internal procedure  is called by several nonquick procedures.  
Cleanup                              88 internal procedure  is called by several nonquick procedures.  
Report_Error                        430 internal procedure  enables or reverts conditions, and is declared options(variable).  
on unit on line 527                  70 on unit               
Initiate_History_Segment_and_Check
                                        internal procedure  shares stack frame of external procedure log_salvage_.  
Check_Log_Segment                   122 internal procedure  enables or reverts conditions.  
on unit on line 608                  98 on unit               
on unit on line 613                  98 on unit               
Check_Alloc_Info_and_Messages       138 internal procedure  enables or reverts conditions.  
on unit on line 693                  64 on unit               
Create_New_Log_Seg                  286 internal procedure  enables or reverts conditions.  
on unit on line 752                  64 on unit               
on unit on line 753                  90 on unit               
create_new_log_seg_cleanup           64 internal procedure  is called by several nonquick procedures.  
Rename_as_Damaged                       internal procedure  shares stack frame of external procedure log_salvage_.  
Rename_for_Last_Message                 internal procedure  shares stack frame of external procedure log_salvage_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
Check_Alloc_Info_and_Messages
                         000100 flip_service_bit            Check_Alloc_Info_and_Messages
                         000101 service_bit                 Check_Alloc_Info_and_Messages
Check_Log_Segment        000100 lp                          Check_Log_Segment
                         000102 lname                       Check_Log_Segment
                         000112 current_log                 Check_Log_Segment
Cleanup                  000100 p                           Cleanup
Create_New_Log_Seg       000100 old_logp                    Create_New_Log_Seg
                         000102 acl_ptr                     Create_New_Log_Seg
                         000104 acl_count                   Create_New_Log_Seg
                         000105 code                        Create_New_Log_Seg
                         000106 hist_log_name               Create_New_Log_Seg
                         000116 max_len                     Create_New_Log_Seg
                         000117 n_logs_unseen               Create_New_Log_Seg
                         000120 new_log_ptr                 Create_New_Log_Seg
                         000122 new_sequence                Create_New_Log_Seg
                         000124 system_area_ptr             Create_New_Log_Seg
                         000126 auto_log_segment_info       Create_New_Log_Seg
                         000223 status                      Create_New_Log_Seg
                         000235 sfb                         Create_New_Log_Seg
Report_Error             000100 argl                        Report_Error
                         000102 argp                        Report_Error
                         000104 ecode                       Report_Error
                         000106 ignore_short_mess           Report_Error
                         000110 long_mess                   Report_Error
                         000141 msg_buff                    Report_Error
                         000341 msg_len                     Report_Error
                         000342 msg_ptr                     Report_Error
                         000344 complete_msg_buff           Report_Error
                         000576 complete_msg_len            Report_Error
                         000600 complete_msg_ptr            Report_Error
log_salvage_             000100 log_dname                   log_salvage_
                         000152 log_ename                   log_salvage_
                         000162 auto_log_salvage_arg        log_salvage_
                         000173 bit_count                   log_salvage_
                         000174 code                        log_salvage_
                         000176 current_log_ptr             log_salvage_
                         000200 done                        log_salvage_
                         000201 error_found                 log_salvage_
                         000202 first_sequence_temp         log_salvage_
                         000203 fix_applied                 log_salvage_
                         000204 i                           log_salvage_
                         000206 history_log_ptr             log_salvage_
                         000210 n_good_hist_segs            log_salvage_
                         000211 newest_hist_log_idx         log_salvage_
                         000212 next_older_log_idx          log_salvage_
                         000214 next_older_log_ptr          log_salvage_
                         000216 oldest_hist_log_idx         log_salvage_
                         000217 renamed_damaged_log         log_salvage_
                         000220 sequence_problem_detected   log_salvage_
                         000222 sequence_info_ptr           log_salvage_
                         000232 log_salvage_arg_ptr         log_salvage_
                         000234 log_segment_ptr             log_salvage_
                         000236 log_message_ptr             log_salvage_
                         000240 log_read_data_ptr           log_salvage_
                         000242 log_segment_info_ptr        log_salvage_
                         000254 log_idx                     Initiate_History_Segment_and_Check
                         000255 ecode                       Initiate_History_Segment_and_Check
                         000256 log_ptr                     Initiate_History_Segment_and_Check
                         000266 lname                       Rename_as_Damaged
                         000276 ldir                        Rename_as_Damaged
                         000350 new_name                    Rename_as_Damaged
                         000360 code                        Rename_as_Damaged
                         000370 lname                       Rename_for_Last_Message
                         000400 log_ptr                     Rename_for_Last_Message
                         000402 name_time                   Rename_for_Last_Message
                         000404 new_name                    Rename_for_Last_Message
                         000414 code                        Rename_for_Last_Message
                         000415 i                           Rename_for_Last_Message

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_le_a              r_ge_a              alloc_char_temp     cat_realloc_chars
call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry_desc
int_entry           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          cu_$arg_ptr                   cu_$level_get                 formline_
get_process_access_class_     get_system_free_area_         hcs_$chname_file              hcs_$chname_seg
hcs_$get_max_length_seg       hcs_$list_acl                 hcs_$status_for_backup        hcs_$status_long
initiate_file_                ioa_$rsnpnnl                  log_create_$new_segment       log_list_history_$single_dir
log_name_$name                log_segment_$initialize_sequence                            log_segment_$place_in_service
pathname_                     terminate_file_               timer_manager_$sleep          unique_bits_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$namedup
error_table_$no_w_permission  error_table_$noentry          error_table_$nomatch
error_table_$unexpected_condition                           error_table_$unimplemented_version
log_data_$default_log_size    sys_info$first_reasonable_time




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000466       198 000513       199 000514       201 000515       202 000517       203 000520       204 000521
    205 000522       206 000523       209 000524       210 000532       211 000537       212 000542       213 000545
    215 000547       218 000561       223 000605       229 000627       230 000654       232 000660       233 000662
    234 000711       243 000717       244 000720       245 000721       246 000733       247 000735       249 000745
    250 000746       252 000753       254 000755       256 000765       257 000771       258 000773       269 000775
    270 000776       271 001003       272 001005       273 001015       274 001021       276 001026       277 001032
    279 001071       281 001073       282 001075       284 001077       298 001102       300 001137       301 001143
    303 001147       304 001157       305 001166       306 001167       307 001176       308 001177       309 001201
    311 001205       313 001226       314 001230       315 001236       317 001245       319 001246       320 001272
    322 001313       323 001315       324 001324       325 001325       327 001327       329 001330       330 001371
    331 001373       333 001407       341 001416       344 001427       345 001434       347 001441       351 001446
    352 001450       354 001455       356 001457       358 001513       359 001515       361 001527       363 001536
    374 001537       376 001546       377 001571       381 001600       413 001607       396 001610       401 001616
    403 001623       405 001633       407 001643       409 001645       424 001650       429 001656       431 001663
    432 001674       434 001703       435 001706       436 001710       438 001737       439 001742       440 001750
    443 001753       445 001757       446 001761       447 001763       450 002012       466 002013       487 002021
    488 002024       490 002025       493 002033       495 002036       498 002055       501 002066       504 002070
    505 002072       506 002074       509 002132       511 002134       512 002147       513 002151       514 002153
    515 002211       518 002212       519 002214       527 002216       528 002242       530 002257       548 002260
    558 002262       559 002264       560 002327       564 002333       566 002373       568 002425       571 002453
    574 002501       576 002506       592 002507       604 002515       605 002521       606 002525       608 002530
    609 002544       610 002572       613 002575       614 002611       615 002637       618 002642       627 002716
    628 002743       633 002746       640 002754       641 002755       642 002763       644 002767       646 002774
    647 003021       650 003023       652 003030       653 003055       657 003057       659 003107       660 003134
    663 003135       665 003141       666 003166       673 003167       676 003171       677 003173       680 003200
    681 003225       690 003226       693 003230       694 003247       695 003260       696 003261       698 003316
    700 003322       724 003325       747 003333       748 003335       749 003336       750 003337       752 003343
    753 003365       754 003401       755 003422       764 003425       767 003434       769 003441       771 003444
    774 003447       777 003457       784 003470       785 003472       786 003475       787 003500       788 003502
    789 003504       790 003527       791 003532       792 003540       793 003543       796 003545       798 003547
    799 003555       800 003557       801 003606       803 003610       804 003616       807 003621       808 003664
    810 003666       811 003674       814 003715       815 003724       816 003766       818 003770       819 003774
    822 003777       823 004016       825 004020       829 004024       830 004026       831 004042       833 004044
    834 004064       835 004073       837 004074       838 004120       839 004133       841 004155       842 004166
    844 004210       845 004236       847 004260       850 004263       853 004267       855 004270       860 004276
    864 004303       867 004305       884 004306       896 004310       897 004314       898 004320       899 004405
    900 004434       902 004436       903 004440       904 004467       905 004470       907 004516       921 004517
    935 004521       936 004525       938 004530       940 004535       942 004536       943 004543       945 004563
    946 004607       948 004613       949 004616       951 004632       952 004633       954 004635       955 004664
    958 004665       960 004667       963 004715


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
