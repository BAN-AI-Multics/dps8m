	COMPILATION LISTING OF SEGMENT init_disk_pack_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1018.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-01-16,Fawcett), approve(86-04-11,MCR7383),
       15*     audit(86-05-29,LJAdams), install(86-07-17,MR12.0-1097):
       16*     Add support for subvolumes, and 512_WORD_IO, 3380 and 3390.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 /* format: style3 */
       21 init_disk_pack_$parse_args:
       22      proc (Arg_list_ptr, Drive_id, Pvname, Copy_flag, RLV_flag, Code);
       23 
       24 /*  This procedure initializes a disk from Ring 1.  Two cases are covered,
       25*   either the disk is mounted, but not accepted, or a copy is being made of an
       26*   accepted disk.  It is passed the PVT index and a pointer to the disk_table entry.
       27*   This procedure prepares the label from the disk table entry and data derived
       28*   from interrogation of the operator, and calls init_vol_header_ to
       29*   write the disk based on this info. 
       30*
       31*   Revised for init_vol_header_, fixing several bugs, BSG 06/25/76 
       32*   Revised for fill_vol_extents_, forcing the latter to do all calculation, BSG 08/31/76 
       33*   Revised for countervalidate_label_ BSG 12/1/76 
       34*   Fixed not to assume pvtx and dtep correspond for Vol Backup, BSG 3/9/77 
       35*   Modified by Mike Grady 9/79 to improve above fix 
       36*   Modified by J. Bongiovanni, April 1982, to add parse_args entry, general cleanup 
       37*   Modified '82 for english error codes
       38*   Modified 84-09-24 by EJ Sharpe for "-rlv" arg and RLV_flag
       39*   Modified 84-10-30 by EJ Sharpe to user convert_status_code_ and some minor fixes
       40*   Modified 85-04-29 by EJ Sharpe to fix uninitialized copy_sw
       41**/
       42 
       43 /*  Parameter  */
       44 
       45 dcl	Arg_list_ptr	ptr parameter;		/* Command arg list pointer */
       46 dcl	Drive_id		char (*) parameter;		/* Drive identifier (dskX_NN) */
       47 dcl	Pvname		char (*) parameter;		/* Physical volume name */
       48 dcl	Copy_flag		bit (1) aligned parameter;	/* ON => -copy specified */
       49 dcl       RLV_flag            bit (1) aligned parameter;
       50 dcl	Dtp		ptr;			/* -> disk table */
       51 dcl	Dtep		ptr;			/* -> disk table entry */
       52 dcl	Pvtx		fixed bin;		/* PVT index */
       53 dcl	Code		fixed bin (35);
       54 
       55 /*  Automatic  */
       56 
       57 dcl	argl		fixed bin (21);
       58 dcl	argp		ptr;
       59 dcl	baseadd		fixed bin;
       60 dcl	conversation	bit (1) aligned;
       61 dcl	copy_sw		bit (1) aligned;
       62 dcl	dev_type		fixed bin;
       63 dcl	longerr		char (100) aligned;
       64 dcl	n_vtoce		fixed bin;
       65 dcl	no_reg_sw		bit (1) aligned;
       66 dcl	num_pages		fixed bin;
       67 dcl	pagep		ptr;
       68 dcl	pv_name		char (32);
       69 dcl       rlv_sw              bit (1) aligned;
       70 dcl	shorterr		char (8) aligned;
       71 dcl	thing		char (20);
       72 
       73 /*  Static  */
       74 
       75 dcl	myname		char (20) init ("init_disk_pack_") static options (constant);
       76 
       77 /*  Based  */
       78 
       79 dcl	arg		char (argl) based (argp);
       80 dcl	1 buffer		aligned like label;
       81 dcl	page		bit (36 * 1024) based (pagep);
       82 
       83 /*  External  */
       84 
       85 dcl	error_table_$badopt fixed bin (35) external;
       86 dcl       error_table_$bad_label fixed bin (35) external;
       87 dcl	sys_info$access_class_ceiling
       88 			bit (72) aligned external;
       89 
       90 /*  Builtin  */
       91 
       92 dcl	addr		builtin;
       93 dcl	clock		builtin;
       94 dcl	null		builtin;
       95 
       96 /*  Entry  */
       97 
       98 dcl	com_err_		entry options (variable);
       99 dcl	config_$find	entry (char(4) aligned, ptr);
      100 dcl	convert_status_code_ entry (fixed bin(35), char(8) aligned, char(100) aligned);
      101 dcl	countervalidate_label_$query
      102 			entry (ptr, char (*), char (*), char (*)) returns (bit (1));
      103 dcl	cu_$arg_ptr_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
      104 dcl	fill_vol_extents_	entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin, bit (1) aligned, fixed bin (17),
      105 			fixed bin (35));
      106 dcl       get_ring_           entry() returns(fixed bin(3));
      107 dcl	init_vol_header_	entry (fixed bin, fixed bin, ptr, entry, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35));
      108 dcl	initializer_gate_$write_disk
      109 			entry (fixed bin, fixed bin, ptr, fixed bin (35));
      110 dcl	initializer_gate_$read_disk
      111 			entry (fixed bin, fixed bin, ptr, fixed bin (35));
      112 dcl	ioa_		entry options (variable);
      113 
      114 
      115 
      116 
      117 
      118 
      119 
      120 /*  Parse command arguments and return information to disk_table_  */
      121 
      122 	Code = 0;
      123 
      124 	call cu_$arg_ptr_rel (1, argp, argl, Code, Arg_list_ptr);
      125 	if Code ^= 0
      126 	then do;
      127 		call com_err_ (Code, myname, "pvname");
      128 		return;
      129 	     end;
      130 
      131 	Pvname = arg;
      132 
      133 	call cu_$arg_ptr_rel (2, argp, argl, Code, Arg_list_ptr);
      134 	if Code ^= 0
      135 	then do;
      136 		call com_err_ (Code, myname, "drive_id");
      137 		return;
      138 	     end;
      139 
      140 	Drive_id = arg;
      141 
      142 	call PARSE_ARGS;
      143 
      144 	Copy_flag = copy_sw;
      145 	RLV_flag = rlv_sw;
      146 	return;
      147 
      148 
      149 /*  Entry to do the work  */
      150 init_disk_pack_:
      151      entry (Dtp, Dtep, Pvtx, Arg_list_ptr, Code);
      152 
      153 
      154 	dtp = Dtp;
      155 	dtep = Dtep;
      156 	labelp = addr (buffer);
      157 
      158 	call PARSE_ARGS;
      159 
      160 	pv_name = "read";
      161 	thing = "label";
      162 	call initializer_gate_$read_disk (Pvtx, LABEL_ADDR, labelp, Code);
      163 	if Code ^= 0
      164 	then do;
      165 		call com_err_ (Code, myname, "Cannot read current label of ^a.", (dt.array (Pvtx).drive_name));
      166 		return;
      167 	     end;
      168 	if ^countervalidate_label_$query (labelp, (dte.pvname), myname, (dt.array (Pvtx).drive_name))
      169 	then do;
      170 	          Code = error_table_$bad_label; 
      171 		return;
      172 	     end;
      173 
      174 
      175 	pagep = addr (buffer);
      176 	page = "0"b;
      177 
      178 	dev_type = dte.device_type;
      179 
      180 	label.version = 1;
      181 	label.mfg_serial = dte.pvname;		/* Good enough for a start */
      182 	pv_name, label.pv_name = dte.pvname;
      183 	label.time_registered = clock ();
      184 	if dte.is_sub_vol
      185 	then do;
      186 		label.vol_size = rec_per_sv (dte.device_type);
      187 		label.number_of_sv = dte.num_of_sv;
      188 		label.this_sv = dte.sv_num;
      189 		label.sub_vol_name = valid_sv_array (dte.sv_num);
      190 	     end;
      191 	else do;
      192 		label.vol_size = rec_per_dev (dte.device_type);
      193 						/* use whole pack */
      194 		label.number_of_sv = 0;
      195 		label.this_sv = 0;
      196 	     end;
      197 
      198 	if ^no_reg_sw
      199 	then do;
      200 		label.pvid = dte.pvid;		/* disk_table_ made this up */
      201 		lvep = addr (dt.lv_array (dte.lvx));
      202 		label.lvid = lve.lvid;		/* Get from disk_table_. who searched. */
      203 		label.lv_name = lve.lvname;
      204 		label.min_access_class = lve.min_access_class;
      205 		label.max_access_class = lve.max_access_class;
      206 		label.private = ^lve.public;
      207 	     end;
      208 	else do;
      209 		label.pvid, label.lvid = (36)"1"b;
      210 		label.lv_name = "";
      211 		label.max_access_class = sys_info$access_class_ceiling;
      212 		label.min_access_class = ""b;
      213 	     end;
      214 
      215 	label.Multics = Multics_ID_String;
      216 	label.password = ""b;
      217 	label.root.disk_table_vtocx = -1;
      218 	label.root.disk_table_uid = ""b;
      219 	label.root_vtocx = 0;
      220 	label.shutdown_state = 0;
      221 	label.esd_state = 0;
      222 
      223 
      224 
      225 /* Fill volume defaults. Hold a dialogue if requested. */
      226 
      227 	call fill_vol_extents_ (labelp, -1, n_vtoce, baseadd, num_pages, ^conversation, dev_type, Code);
      228 						/* -1 = no "lace" */
      229 	if Code ^= 0
      230 	then return;
      231 
      232 /* Write out the actual disk */
      233 
      234 	call init_vol_header_ (Pvtx, dev_type, pagep, initializer_gate_$write_disk, thing, n_vtoce, baseadd, num_pages,
      235 	     Code);
      236 
      237 	if Code ^= 0
      238 	then do;
      239 	     call convert_status_code_ (Code, shorterr, longerr);
      240 	     call ioa_ ("^a: ^a ^a disk err ""^a"" on ^a", myname, dte.drive_name, pv_name, longerr, thing);
      241 	end;
      242 
      243 	else call ioa_ ("volume ^a ^d records", pv_name, num_pages);
      244 	return;
      245 
      246 
      247 
      248 
      249 /*  Internal Procedure to do argument parsing  */
      250 
      251 PARSE_ARGS:
      252      proc;
      253 
      254 dcl	code		fixed bin (35);
      255 dcl	arg_no		fixed bin;
      256 
      257 
      258 
      259 	conversation, no_reg_sw, rlv_sw, copy_sw = "0"b;
      260 
      261 	code = 0;
      262 	do arg_no = 3 repeat arg_no + 1 while (code = 0);
      263 	     call cu_$arg_ptr_rel (arg_no, argp, argl, code, Arg_list_ptr);
      264 	     if code = 0
      265 	     then do;
      266 		     if arg = "-special"
      267 		     then conversation = "1"b;
      268 		     else if arg = "-copy"
      269 		     then conversation, copy_sw = "1"b;
      270 		     else if arg = "-no_reg"
      271 		     then conversation, no_reg_sw = "1"b;
      272 		     else if arg = "-rlv"
      273 			then if ^( (get_ring_() = 1)  &  BOOTED_COLD () ) then do;
      274 				Code = error_table_$badopt;
      275 				call com_err_ (Code, myname, """-rlv"" allowed only at ring 1 during cold boot.");
      276 				return;
      277 			     end;
      278 			     else rlv_sw = "1"b;
      279 		     else do;
      280 			     Code = error_table_$badopt;
      281 			     call com_err_ (Code, myname, arg);
      282 			     return;
      283 			end;
      284 		end;
      285 	end;
      286 
      287      end PARSE_ARGS;
      288 
      289 
      290 /* Internal procedure to determine if we're in middle of cold boot */
      291 
      292 BOOTED_COLD:
      293      proc () returns (bit (1) aligned);
      294 
      295 	intk_cardp = null ();
      296 	call config_$find ("intk", intk_cardp);
      297 	if intk_cardp = null () then do;
      298 	     call com_err_ (0, myname, "INTK card missing from config deck.");
      299 	     return ("0"b);
      300 	end;
      301 	else return (intk_card.warm_or_cold = "cold");
      302 
      303      end BOOTED_COLD;
      304 
  1     1 /* BEGIN INCLUDE FILE ... config_intk_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  1     2 
  1     3 dcl  intk_cardp pointer;				/* pointer to INTK card */
  1     4 
  1     5 dcl 1 intk_card aligned based (intk_cardp),		/* INTK card declaration */
  1     6     2 word char (4),				/* "intk" */
  1     7     2 warm_or_cold char (4),				/* Type of bootload: "warm" or "cold" */
  1     8     2 boot_drive fixed bin,				/* Tape drive on which MST is mounted */
  1     9     2 parms (12) char (4),				/* up to 12 arbitrary bootload parameters */
  1    10 
  1    11     2 type_word aligned,
  1    12       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  1    13       3 pad1 bit (4) unaligned,
  1    14       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  1    15 
  1    16 dcl 1 intk_card_array aligned based (intk_cardp),		/* Overlay for counting parameters */
  1    17     2 pad (3) bit (36) aligned,
  1    18     2 parms (max (0, intk_card.n_fields - 2)) bit (36) aligned;
  1    19 
  1    20 dcl  INTK_CARD_WORD char (4) aligned internal static options (constant) init ("intk");
  1    21 
  1    22 /* END INCLUDE FILE ... config_intk_card.incl.pl1 */
      305 
      306 
  2     1 /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  2     2 
  2     3 
  2     4 
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  2    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  2    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  2    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  2    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  2    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  2    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 /*
  2    20*   All disk packs have the standard layout described below:
  2    21*
  2    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  2    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  2    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  2    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  2    26*   Record  7		: formerly contained bad track list; no longer used.
  2    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  2    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  2    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  2    30*
  2    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  2    32*   of the particular partition.
  2    33*
  2    34*
  2    35*
  2    36*   A conceptual declaration for a disk pack could be:
  2    37*
  2    38*   dcl 1 disk_pack,
  2    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  2    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  2    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  2    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  2    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  2    44*   2 vtoc_array_records	(8 : n-1),
  2    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  2    46*   3 unused				bit(36 * 64),
  2    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  2    48*
  2    49*
  2    50*
  2    51*
  2    52**/
  2    53 
  2    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  2    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  2    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  2    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  2    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  2    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  2    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  2    61 		         fixed bin (17) int static options (constant);
  2    62 
  2    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  2    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  2    65 /* or the physical volume table entry (pvte) device type.		      */
  2    66 
  2    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  2    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  2    69 
  2    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  2    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  2    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  2    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    76 
  2    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      307 
      308 
  3     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  3     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  3     7*     Add support for subvolumes.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 
  3    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  3    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  3    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  3    14 
  3    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  3    16 
  3    17 dcl  dtp ptr,
  3    18      dtep ptr,
  3    19      lvep ptr;
  3    20 
  3    21      
  3    22 
  3    23 dcl 1 dt based (dtp) aligned,
  3    24 
  3    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  3    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  3    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  3    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  3    29     2 version fixed bin init (1),
  3    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  3    31     2 pad (2) bit (36),
  3    32     2 array (0 refer (dt.max_n_entries)) like dte,
  3    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  3    34 
  3    35 dcl 1 dte based (dtep) aligned,
  3    36     2 drive_name char (8),				/* device name */
  3    37     (2 device_type fixed bin (8),			/* device type */
  3    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  3    39     2 known bit (1),				/* TRUE if label has been read and checked */
  3    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  3    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  3    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  3    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  3    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  3    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  3    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  3    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  3    48     2 is_sub_vol bit (1),
  3    49     2 pad bit (3),
  3    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  3    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  3    52     2 sv_num  fixed bin unal,				/* this sv number */
  3    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  3    54     2 sv_name   char (2) aligned,
  3    55     2 pvid bit (36),				/* physical volume ID */
  3    56     2 pvname char (32);				/* Physical volume name. */
  3    57 
  3    58 dcl 1 lve based (lvep) aligned,
  3    59     2 lvid bit (36),				/* logical volume ID */
  3    60     (2 used bit (1),				/* TRUE if entry used */
  3    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  3    62     2 public bit (1),				/* TRUE for public vol */
  3    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  3    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  3    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  3    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  3    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  3    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  3    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  3    70     2 pad bit (26)) unal,
  3    71     2 lvname char (32),				/* Logical volume name */
  3    72     2 min_access_class bit (72),			/* Security stuff */
  3    73     2 max_access_class bit (72);			/* .. */
  3    74 
  3    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      309 
      310 
  4     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  4     6*     Add support for FIPS
  4     7*     3380.
  4     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  4    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  4    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  4    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  4    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 /* Modified 5/19/76 by N. I. Morris */
  4    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  4    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  4    19 /* Modified '82 by BIM for needs_alt_part */
  4    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  4    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  4    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  4    23*   volmap and record stock can be expanded. */
  4    24 
  4    25 /*
  4    26********************************************************************************
  4    27**							        *
  4    28**                           WARNING:                                          *
  4    29**							        *
  4    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  4    31**   type is added.						        *
  4    32**							        *
  4    33**   There are other include files that contain arrays indexed by the device   *
  4    34**   index obtained by references to MODELX or MODELN in this include file.    *
  4    35**   These must be modified when a new device type is added:		        *
  4    36**   disk_pack.incl.pl1					        *
  4    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  4    38**							        *
  4    39********************************************************************************
  4    40**/
  4    41 
  4    42 
  4    43 dcl (maxdevt init (9),				/* maximum legal devt */
  4    44      bulkdevt init (1),				/* bulk store devt */
  4    45      msu0500devt init (2),				/* MSU0500 device type */
  4    46      msu0451devt init (3),				/* MSU0451 device type */
  4    47      msu0450devt init (3),				/* MSU0450 device type */
  4    48      msu0400devt init (4),				/* MSU0400 device type */
  4    49      dsu191devt init (4),				/* DSU191 device type */
  4    50      dsu190devt init (5),				/* DSU190 device type */
  4    51      dsu181devt init (6),				/* DSU181 device type */
  4    52      msu0501devt init (7),				/* MSU0501 device type */
  4    53      fips3380devt init (8),				/* 3380D FIPS device type */
  4    54      fips3381devt init (9)				/* 3380E FIPS device type */
  4    55      ) fixed bin (4) static options (constant);
  4    56 
  4    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  4    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  4    59 
  4    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  4    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  4    62 
  4    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  4    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  4    65 
  4    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  4    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  4    68 
  4    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  4    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  4    71 
  4    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  4    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  4    74 
  4    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  4    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  4    77 
  4    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  4    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  4    80 
  4    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  4    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  4    83 
  4    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  4    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  4    86 
  4    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  4    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  4    89 
  4    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  4    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  4    92 
  4    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  4    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  4    95 
  4    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  4    97      ("abc");
  4    98 
  4    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  4   100      init ("a","b","c");
  4   101 
  4   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  4   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  4   104 
  4   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  4   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  4   107 
  4   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  4   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  4   110 
  4   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  4   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  4   113 
  4   114 
  4   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  4   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  4   117 
  4   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  4   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  4   120 
  4   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  4   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  4   123 
  4   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  4   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  4   126 
  4   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  4   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  4   129 
  4   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  4   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  4   132 
  4   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  4   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  4   135 
  4   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  4   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  4   138 
  4   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  4   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  4   141 
  5     1 /* Begin fs_dev_types_sector.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     7*     Add the sector differance for devices that do 64 word IO and devices that
  5     8*     do 512 word IO.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  5    12*	 need all the data in fs_dev_types. This is also included in
  5    13*	 fs_dev_types.incl.pl1  */
  5    14 
  5    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  5    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  5    17 
  5    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  5    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  5    20 
  5    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  5    22  /* table of # of sectors per record on each device */
  5    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  5    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    25 
  5    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  5    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    28 	
  5    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  5    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  5    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    32 
  5    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  5    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  5    35 
  5    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  5    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  5    38 
  5    39 /* End fs_dev_types_sector.incl.pl1 */
  5    40 
  4   142 
  4   143 
  4   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      311 
      312 
  6     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  6     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  6     6*     Add the subvolume info.
  6     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6     9*     Added inconsistent_dbm bit used to determine consistency of volume
  6    10*     dumper bit maps.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  6    14 /* Note: fsout_vol clears pad fields before writing the label */
  6    15 
  6    16 dcl  labelp ptr;
  6    17 
  6    18 dcl 1 label based (labelp) aligned,
  6    19 
  6    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  6    21 
  6    22     2 gcos (5*64) fixed bin,
  6    23 
  6    24 /* Now we have the Multics label */
  6    25 
  6    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  6    27     2 version fixed bin,				/* Version 1 */
  6    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  6    29     2 pv_name char (32),				/* Physical volume name. */
  6    30     2 lv_name char (32),				/* Name of logical volume for pack */
  6    31     2 pvid bit (36),				/* Unique ID of this pack */
  6    32     2 lvid bit (36),				/* unique ID of its logical vol */
  6    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  6    34     2 time_registered fixed bin (71),			/* time imported to system */
  6    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  6    36     2 vol_size fixed bin,				/* total size of volume, in records */
  6    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  6    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  6    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  6    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  6    41     2 flagpad bit (33) unal,
  6    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  6    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  6    44     2 password bit (72),				/* not yet used */
  6    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  6    46     2 this_sv fixed bin,				/* what subvolume number it is */
  6    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  6    48     2 pad1 (13) fixed bin,
  6    49     2 time_mounted fixed bin (71),			/* time mounted */
  6    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  6    51 
  6    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  6    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  6    54* */
  6    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  6    56     2 pad6 fixed bin,				
  6    57 
  6    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  6    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  6    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  6    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  6    62     2 pad1a (2) fixed bin,
  6    63     2 err_hist_size fixed bin,			/* size of pack error history */
  6    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  6    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  6    66     2 pad2 (40) fixed bin,
  6    67     2 root,
  6    68       3 here bit (1),				/* TRUE if the root is on this pack */
  6    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  6    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  6    71       3 pad7 bit (1) aligned,				
  6    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  6    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  6    74       3 esd_state fixed bin,				/* State of esd */
  6    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  6    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  6    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  6    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  6    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  6    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  6    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  6    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  6    83     2 pad3 (52) fixed bin,
  6    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  6    85     2 parts (47),
  6    86       3 part char (4),				/* Name of partition */
  6    87       3 frec fixed bin,				/* First record */
  6    88       3 nrec fixed bin,				/* Number of records */
  6    89       3 pad5 fixed bin,
  6    90     2 pad4 (5*64) fixed bin;
  6    91 
  6    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  6    93 
  6    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      313 
      314 
      315 /* BEGIN MESSAGE DOCUMENTATION
      316*
      317*   Message:
      318*   init_disk_pack_: Cannot read current label of DRIVE: ERROR_MESSAGE
      319*
      320*   S:	$initializer_io
      321*
      322*   T:	$response
      323*
      324*   M:	A disk error prevents checking the label of the pack on DRIVE.
      325*   The pack may need to be formatted before it can be initialized.
      326*
      327*   A:	Take appropriate action.
      328*
      329*
      330*   Message:
      331*   init_disk_pack_: INTK card missing from config deck.
      332*
      333*   S:	$initializer_io
      334*
      335*   T:	$response
      336*
      337*   M:	When the operator specifies the "-rlv" control argument to
      338*   "init_vol" this program attempts to verify that the system is in cold
      339*   boot by inspecting the INTK card in the config deck.  When this message
      340*   appears, there is some difficulty in locating that card.
      341*
      342*   A:	If really trying to boot cold, try again.
      343*
      344*
      345*   Message:
      346*   init_disk_pack_:  Specified control argument not accepted.  "-rlv"
      347*   allowed only at ring-1 during a cold boot.
      348*
      349*   S:	$initializer_io
      350*
      351*   T:	$response
      352*
      353*   M:	Automatic registration of root PVs is allowed only during
      354*   a cold boot of Multics.
      355*
      356*   A:	Use the "add_volume_registration" administrative command to
      357*   register the PV before attempting to initialize it.
      358*
      359*
      360*   Message:
      361*   init_disk_pack_: DRIVE PVNAME disk err WWWW on ITEM
      362*
      363*   S:	$initializer_io
      364*
      365*   T:	$response
      366*
      367*   M:	A disk error prevents writing the ITEM section of the disk volume PVNAME.
      368*
      369*   A:	Fix the drive, or use a new pack.
      370*
      371*
      372*   Message:
      373*   init_disk_pack_: Volume on DRIVE is Multics Storage System Volume "PVNAME",
      374*   .br
      375*   last used DATE_TIME. Do you wish to overwrite it?
      376*
      377*   S:	$initializer_io
      378*
      379*   T:	$response
      380*
      381*   M:	The init_disk command specifed a disk pack
      382*   which has a valid Multics label.
      383*   Initializing this pack will destroy all data contained on it.
      384*
      385*   A:	Do not answer yes unless you are sure that the pack contents should be destroyed.
      386*   Check the pack serial number.
      387*
      388*
      389*   Message:
      390*   init_disk_pack_: Volume on DRIVE is a copy of Multics Storage System Volume "PVNAME",
      391*   .br
      392*   last used DATE_TIME. Do you wish to overwrite it?
      393*
      394*   S:	$initializer_io
      395*
      396*   T:	$response
      397*
      398*   M:	The init_disk command specifed a disk pack
      399*   which has a valid Multics label.
      400*   Another copy of PVNAME is currently in use.
      401*   Initializing this pack will destroy all data contained on it.
      402*
      403*   A:	Do not answer yes unless you are sure that the pack contents should be destroyed.
      404*   Check the pack serial number.
      405*
      406*
      407*   Message:
      408*   init_disk_pack_: Volume on DRIVE is a copy of pv "PVNAME",
      409*   .br
      410*   last used DATE_TIME. Do you wish to overwrite it?
      411*
      412*   S:	$initializer_io
      413*
      414*   T:	$response
      415*
      416*   M:	The init_disk command specifed a disk pack
      417*   which has a valid Multics label.
      418*   It appears to be a copy of a mounted pack.
      419*   Initializing this pack will destroy all data contained on it.
      420*
      421*   A:	Do not answer yes unless you are sure that the pack contents should be destroyed.
      422*   Check the pack serial number.
      423*
      424*
      425*   Message:
      426*   init_disk_pack_: Volume on DRIVE is an earlier instance of pv "PVNAME",
      427*   .br
      428*   last used DATE_TIME. Do you wish to overwrite it?
      429*
      430*   S:	$initializer_io
      431*
      432*   T:	$response
      433*
      434*   M:	The init_disk command specifed a disk pack
      435*   which has a valid Multics label.
      436*   Initializing this pack will destroy all data contained on it.
      437*
      438*   A:	Do not answer yes unless you are sure that the pack contents should be destroyed.
      439*   Check the pack serial number.
      440*
      441*
      442*   Message:
      443*   init_disk_pack_: Volume on DRIVE is an unregistered pack named "PVNAME",
      444*   .br
      445*   last used DATE_TIME. Do you wish to overwrite it?
      446*
      447*   S:	$initializer_io
      448*
      449*   T:	$response
      450*
      451*   M:	The init_disk command specifed a disk pack
      452*   which has a valid Multics label.
      453*   Initializing this pack will destroy all data contained on it.
      454*
      455*   A:	Do not answer yes unless you are sure that the pack contents should be destroyed.
      456*   Check the pack serial number.
      457*
      458*
      459*   Message:
      460*   init_disk_pack_: unrecognized argument: BLAH
      461*
      462*   S:	$initializer_io
      463*
      464*   T:	$response
      465*
      466*   M:	Illegal input was typed.
      467*
      468*   A:	$tryagn
      469*
      470*
      471*   Message:
      472*   volume PVNAME XX records
      473*
      474*   S:	$initializer_io
      475*
      476*   T:	$response
      477*
      478*   M:	The physical volume PVNAME has been successfully initialized.
      479*   There are XX (decimal) records in the paging area.
      480*
      481*   A:	$ignore
      482*
      483*
      484*   END MESSAGE DOCUMENTATION */
      485 
      486      end init_disk_pack_$parse_args;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0803.1  init_disk_pack_.pl1               >spec>install>1111>init_disk_pack_.pl1
305          1    05/08/81  1853.6  config_intk_card.incl.pl1         >ldd>include>config_intk_card.incl.pl1
307          2    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
309          3    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
311          4    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
4-142        5    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
313          6    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Arg_list_ptr                           parameter       pointer                  dcl 45 set ref 21 124* 133* 150 263*
Code                                   parameter       fixed bin(35,0)          dcl 53 set ref 21 122* 124* 125 127* 133* 134 136*
                                                                                  150 162* 163 165* 170* 227* 229 234* 237 239* 274*
                                                                                  275* 280* 281*
Copy_flag                              parameter       bit(1)                   dcl 48 set ref 21 144*
Drive_id                               parameter       char                     packed unaligned dcl 46 set ref 21 140*
Dtep                                   parameter       pointer                  dcl 51 ref 150 155
Dtp                                    parameter       pointer                  dcl 50 ref 150 154
LABEL_ADDR                      000061 constant        fixed bin(17,0)          initial dcl 2-54 set ref 162*
Multics                 500            based           char(32)                 initial level 2 in structure "label" dcl 6-18
                                                                                  in procedure "init_disk_pack_$parse_args" set ref
                                                                                  215*
Multics                 500     000170 automatic       char(32)                 initial level 2 in structure "buffer" dcl 80
                                                                                  in procedure "init_disk_pack_$parse_args" set ref
                                                                                  80*
Multics_ID_String               000000 constant        char(32)                 initial packed unaligned dcl 6-92 ref 215
Pvname                                 parameter       char                     packed unaligned dcl 47 set ref 21 131*
Pvtx                                   parameter       fixed bin(17,0)          dcl 52 set ref 150 162* 165 168 234*
RLV_flag                               parameter       bit(1)                   dcl 49 set ref 21 145*
addr                                                   builtin function         dcl 92 ref 156 175 201
arg                                    based           char                     packed unaligned dcl 79 set ref 131 140 266 268 270
                                                                                  272 281*
arg_no                          002221 automatic       fixed bin(17,0)          dcl 255 set ref 262* 263* 285*
argl                            000100 automatic       fixed bin(21,0)          dcl 57 set ref 124* 131 133* 140 263* 266 268 270
                                                                                  272 281 281
argp                            000102 automatic       pointer                  dcl 58 set ref 124* 131 133* 140 263* 266 268 270
                                                                                  272 281
array                    10            based           structure                array level 2 dcl 3-23
baseadd                         000104 automatic       fixed bin(17,0)          dcl 59 set ref 227* 234*
buffer                          000170 automatic       structure                level 1 dcl 80 set ref 156 175
clock                                                  builtin function         dcl 93 ref 183
code                            002220 automatic       fixed bin(35,0)          dcl 254 set ref 261* 262 263* 264
com_err_                        000016 constant        entry                    external dcl 98 ref 127 136 165 275 281 298
config_$find                    000020 constant        entry                    external dcl 99 ref 296
conversation                    000105 automatic       bit(1)                   dcl 60 set ref 227 259* 266* 268* 270*
convert_status_code_            000022 constant        entry                    external dcl 100 ref 239
copy_sw                         000106 automatic       bit(1)                   dcl 61 set ref 144 259* 268*
countervalidate_label_$query    000024 constant        entry                    external dcl 101 ref 168
cu_$arg_ptr_rel                 000026 constant        entry                    external dcl 103 ref 124 133 263
dev_type                        000107 automatic       fixed bin(17,0)          dcl 62 set ref 178* 227* 234*
device_type               2            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 3-35 ref 178 186
                                                                                  192
disk_table_uid          705            based           bit(36)                  level 3 dcl 6-18 set ref 218*
disk_table_vtocx        704            based           fixed bin(17,0)          level 3 dcl 6-18 set ref 217*
drive_name               10            based           char(8)                  array level 3 in structure "dt" dcl 3-23
                                                                                  in procedure "init_disk_pack_$parse_args" ref 165
                                                                                  168
drive_name                             based           char(8)                  level 2 in structure "dte" dcl 3-35 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 240*
dt                                     based           structure                level 1 dcl 3-23
dte                                    based           structure                level 1 dcl 3-35
dtep                            002174 automatic       pointer                  dcl 3-17 set ref 155* 168 178 181 182 184 186 187
                                                                                  188 189 192 200 201 240
dtp                             002172 automatic       pointer                  dcl 3-17 set ref 154* 165 168 201
error_table_$bad_label          000012 external static fixed bin(35,0)          dcl 86 ref 170
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 85 ref 274 280
esd_state               706            based           fixed bin(17,0)          level 3 dcl 6-18 set ref 221*
fill_vol_extents_               000030 constant        entry                    external dcl 104 ref 227
get_ring_                       000032 constant        entry                    external dcl 106 ref 272
init_vol_header_                000034 constant        entry                    external dcl 107 ref 234
initializer_gate_$read_disk     000040 constant        entry                    external dcl 110 ref 162
initializer_gate_$write_disk    000036 constant        entry                    external dcl 108 ref 234 234
intk_card                              based           structure                level 1 dcl 1-5
intk_cardp                      002170 automatic       pointer                  dcl 1-3 set ref 295* 296* 297 301
ioa_                            000042 constant        entry                    external dcl 112 ref 240 243
is_sub_vol                2(19)        based           bit(1)                   level 2 packed packed unaligned dcl 3-35 ref 184
label                                  based           structure                level 1 dcl 6-18
labelp                          002202 automatic       pointer                  dcl 6-16 set ref 156* 162* 168* 180 181 182 183 186
                                                                                  187 188 189 192 194 195 200 202 203 204 205 206
                                                                                  209 209 210 211 212 215 216 217 218 219 220 221
                                                                                  227*
longerr                         000110 automatic       char(100)                dcl 63 set ref 239* 240*
lv_array                               based           structure                array level 2 dcl 3-23 set ref 201
lv_name                 531            based           char(32)                 level 2 dcl 6-18 set ref 203* 210*
lve                                    based           structure                level 1 dcl 3-58
lvep                            002176 automatic       pointer                  dcl 3-17 set ref 201* 202 203 204 205 206
lvid                    542            based           bit(36)                  level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 202* 209*
lvid                                   based           bit(36)                  level 2 in structure "lve" dcl 3-58 in procedure
                                                                                  "init_disk_pack_$parse_args" ref 202
lvname                    2            based           char(32)                 level 2 dcl 3-58 ref 203
lvx                       2(23)        based           fixed bin(11,0)          level 2 packed packed unaligned dcl 3-35 ref 201
max_access_class         14            based           bit(72)                  level 2 in structure "lve" dcl 3-58 in procedure
                                                                                  "init_disk_pack_$parse_args" ref 205
max_access_class        552            based           bit(72)                  level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 205* 211*
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 3-23 ref 201
mfg_serial              511            based           char(32)                 level 2 dcl 6-18 set ref 181*
min_access_class         12            based           bit(72)                  level 2 in structure "lve" dcl 3-58 in procedure
                                                                                  "init_disk_pack_$parse_args" ref 204
min_access_class        554            based           bit(72)                  level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 204* 212*
myname                          000033 constant        char(20)                 initial packed unaligned dcl 75 set ref 127* 136*
                                                                                  165* 168* 240* 275* 281* 298*
n_vtoce                         000141 automatic       fixed bin(17,0)          dcl 64 set ref 227* 234*
no_reg_sw                       000142 automatic       bit(1)                   dcl 65 set ref 198 259* 270*
null                                                   builtin function         dcl 94 ref 295 297
num_of_sv                 3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-35 ref 187
num_pages                       000143 automatic       fixed bin(17,0)          dcl 66 set ref 227* 234* 243*
number_of_sv            560            based           fixed bin(17,0)          level 2 dcl 6-18 set ref 187* 194*
page                                   based           bit(36864)               packed unaligned dcl 81 set ref 176*
pagep                           000144 automatic       pointer                  dcl 67 set ref 175* 176 234*
password                556            based           bit(72)                  level 2 dcl 6-18 set ref 216*
private                 551(01)        based           bit(1)                   level 2 packed packed unaligned dcl 6-18 set ref
                                                                                  206*
public                    1(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3-58 ref 206
pv_name                         000146 automatic       char(32)                 packed unaligned dcl 68 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 160* 182*
                                                                                  240* 243*
pv_name                 521            based           char(32)                 level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 182*
pvid                      5            based           bit(36)                  level 2 in structure "dte" dcl 3-35 in procedure
                                                                                  "init_disk_pack_$parse_args" ref 200
pvid                    541            based           bit(36)                  level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "init_disk_pack_$parse_args" set ref 200* 209*
pvname                    6            based           char(32)                 level 2 dcl 3-35 ref 168 181 182
rec_per_dev                     000022 constant        fixed bin(21,0)          initial array dcl 4-87 ref 192
rec_per_sv                      000011 constant        fixed bin(17,0)          initial array dcl 4-90 ref 186
rlv_sw                          000156 automatic       bit(1)                   dcl 69 set ref 145 259* 278*
root                    700            based           structure                level 2 dcl 6-18
root_vtocx              701            based           fixed bin(35,0)          level 3 dcl 6-18 set ref 219*
seek_command                    002200 automatic       bit(6)                   initial array packed unaligned dcl 4-84 set ref
                                                                                  4-84* 4-84* 4-84* 4-84* 4-84* 4-84* 4-84* 4-84*
                                                                                  4-84*
shorterr                        000160 automatic       char(8)                  dcl 70 set ref 239*
shutdown_state          702            based           fixed bin(17,0)          level 3 dcl 6-18 set ref 220*
sub_vol_name            562            based           char(1)                  level 2 dcl 6-18 set ref 189*
sv_num                    3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-35 ref 188 189
sys_info$access_class_ceiling   000014 external static bit(72)                  dcl 87 ref 211
thing                           000162 automatic       char(20)                 packed unaligned dcl 71 set ref 161* 234* 240*
this_sv                 561            based           fixed bin(17,0)          level 2 dcl 6-18 set ref 188* 195*
time_registered         544            based           fixed bin(71,0)          level 2 dcl 6-18 set ref 183*
valid_sv_array                  000010 constant        char(1)                  initial array packed unaligned dcl 4-99 ref 189
version                 510            based           fixed bin(17,0)          level 2 dcl 6-18 set ref 180*
vol_size                547            based           fixed bin(17,0)          level 2 dcl 6-18 set ref 186* 192*
warm_or_cold              1            based           char(4)                  level 2 dcl 1-5 ref 301

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 2-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 2-54
INTK_CARD_WORD                         internal static char(4)                  initial dcl 1-20
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 2-54
MODEL                                  internal static fixed bin(17,0)          initial array dcl 4-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 4-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 4-60
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 2-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 2-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 2-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 2-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 2-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 2-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 2-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 2-54
bulkdevt                               internal static fixed bin(4,0)           initial dcl 4-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 4-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 4-105
dev_time                               internal static float bin(27)            initial array dcl 4-139
device_names                           internal static char(4)                  initial array dcl 4-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 4-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 4-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 4-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 4-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 4-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 4-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 4-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 4-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 4-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 4-124
intk_card_array                        based           structure                level 1 dcl 1-16
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 4-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 4-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 4-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 4-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 4-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 4-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 4-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 4-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 4-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 4-93
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 4-108
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 5-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 5-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 5-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 5-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 4-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 4-111
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 4-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 5-36

NAMES DECLARED BY EXPLICIT CONTEXT.
BOOTED_COLD                     001463 constant        entry                    internal dcl 292 ref 272
PARSE_ARGS                      001265 constant        entry                    internal dcl 251 ref 142 158
init_disk_pack_                 000500 constant        entry                    external dcl 150
init_disk_pack_$parse_args      000277 constant        entry                    external dcl 21

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2004        2050    1557        2014
Length      2372    1557        44         306     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_disk_pack_$parse_args         1348 external procedure  is an external procedure.  
PARSE_ARGS                              internal procedure  shares stack frame of external procedure init_disk_pack_$parse_args.  
BOOTED_COLD                             internal procedure  shares stack frame of external procedure init_disk_pack_$parse_args.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_disk_pack_$parse_args
                         000100 argl                        init_disk_pack_$parse_args
                         000102 argp                        init_disk_pack_$parse_args
                         000104 baseadd                     init_disk_pack_$parse_args
                         000105 conversation                init_disk_pack_$parse_args
                         000106 copy_sw                     init_disk_pack_$parse_args
                         000107 dev_type                    init_disk_pack_$parse_args
                         000110 longerr                     init_disk_pack_$parse_args
                         000141 n_vtoce                     init_disk_pack_$parse_args
                         000142 no_reg_sw                   init_disk_pack_$parse_args
                         000143 num_pages                   init_disk_pack_$parse_args
                         000144 pagep                       init_disk_pack_$parse_args
                         000146 pv_name                     init_disk_pack_$parse_args
                         000156 rlv_sw                      init_disk_pack_$parse_args
                         000160 shorterr                    init_disk_pack_$parse_args
                         000162 thing                       init_disk_pack_$parse_args
                         000170 buffer                      init_disk_pack_$parse_args
                         002170 intk_cardp                  init_disk_pack_$parse_args
                         002172 dtp                         init_disk_pack_$parse_args
                         002174 dtep                        init_disk_pack_$parse_args
                         002176 lvep                        init_disk_pack_$parse_args
                         002200 seek_command                init_disk_pack_$parse_args
                         002202 labelp                      init_disk_pack_$parse_args
                         002220 code                        PARSE_ARGS
                         002221 arg_no                      PARSE_ARGS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          ext_entry           ext_entry_desc
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      config_$find                  convert_status_code_          countervalidate_label_$query
cu_$arg_ptr_rel               fill_vol_extents_             get_ring_                     init_vol_header_
initializer_gate_$read_disk   initializer_gate_$write_disk  ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_label        error_table_$badopt           sys_info$access_class_ceiling




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     80 000175    4   84 000200        21 000271       122 000325       124 000326       125 000347       127 000351
    128 000374       131 000375       133 000405       134 000426       136 000430       137 000453       140 000454
    142 000464       144 000465       145 000470       146 000472       150 000473       154 000513       155 000517
    156 000522       158 000524       160 000525       161 000530       162 000533       163 000551       165 000553
    166 000612       168 000613       170 000662       171 000665       175 000666       176 000670       178 000674
    180 000700       181 000704       182 000707       183 000720       184 000722       186 000725       187 000730
    188 000734       189 000737       190 000744       192 000745       194 000750       195 000751       198 000752
    200 000754       201 000756       202 000772       203 000774       204 000777       205 001003       206 001007
    207 001017       209 001020       210 001023       211 001026       212 001034       215 001037       216 001042
    217 001045       218 001047       219 001050       220 001051       221 001052       227 001053       229 001104
    234 001106       237 001160       239 001162       240 001175       241 001234       243 001235       244 001264
    251 001265       259 001266       261 001272       262 001273       263 001300       264 001317       266 001321
    268 001332       270 001342       272 001352       274 001377       275 001402       276 001425       278 001426
    280 001431       281 001434       282 001457       285 001460       287 001462       292 001463       295 001465
    296 001467       297 001502       298 001506       299 001533       301 001536


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
