	COMPILATION LISTING OF SEGMENT iom_data_init
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0951.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* iom_data_init - a system initialization routine to set up
       13*   the data bases used by the iom_manager.
       14*   First written in August 1971 by R F Mabee.
       15*   Converted for followon hardware July 27, 1972 by R. F. Mabee
       16*   Last modified 02/24/77 by Noel I. Morris
       17*   Modified for paged IOM by C. Hornig November 1980.
       18*   More paged IOM by C. Hornig, March 1982.
       19*   Modified for channel reconfiguration by Chris Jones, January 1984.
       20*   Modified to remove support for non-paged-mode IOMs by Chris Jones, August 1984
       21*   Modified to init system fault channel of unconfigured IOMs by M. Pandolf, November 1984
       22*   Modified to init iom_data$imw_lock and iom_data$n_intr_procs by M. Pandolf, January 1985
       23**/
       24 
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(86-01-06,Fawcett), approve(86-04-11,MCR7351),
       28*     audit(86-06-07,GDixon), install(86-07-17,MR12.0-1097):
       29*     Change iom_card model from "nsa" to "iom".
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       34 iom_data_init:
       35      procedure;
       36 
       37 dcl	i		   fixed bin;
       38 dcl	errcode		   fixed bin (35);
       39 dcl	iom_no		   fixed bin (3);
       40 dcl	iom_name		   char (1) aligned;
       41 dcl	found_iom		   bit (1) aligned;
       42 
       43 dcl	absadr		   entry (ptr, fixed bin (35)) returns (fixed bin (26));
       44 dcl	config$find	   entry (char (4) aligned, ptr);
       45 dcl	iom_overhead$init	   entry (fixed bin (3), fixed bin (35));
       46 dcl	iom_overhead$init_without_assign
       47 			   entry (fixed bin (3), fixed bin (35));
       48 dcl	syserr		   entry options (variable);
       49 
       50 dcl	1 cow		   based aligned,
       51 	  2 unused	   bit (33) unaligned,
       52 	  2 port		   uns fixed bin (3) unaligned;
       53 
       54 dcl	iom_int_mask	   (4) bit (72) aligned static options (constant)
       55 			   init ("088800000888800000"b4, "044400000444400000"b4, "022200000222200000"b4,
       56 			   "011100000111100000"b4);
       57 
       58 dcl	(addr, binary, bit, hbound, lbound, null, substr, unspec)
       59 			   builtin;
       60 
       61 	iom_data_ptr = addr (iom_data$);		/* Get pointer to iom_data segment. */
       62 	iom_mailbox_seg_ptr = addr (iom_mailbox$);	/* Get pointer to iom_mailbox segment. */
       63 
       64 /* Set up some constant items. */
       65 
       66 	unspec (iom_mailbox_seg) = ""b;
       67 
       68 	idcwp = addr (iom_data.stop_dcw);		/* Make DCW to stop any channel. */
       69 	idcw.code = "111"b;				/* Make it an instruction DCW. */
       70 	idcw.chan_cmd = "000010"b;			/* Non-data transfer. */
       71 
       72 	lpwp = addr (iom_data.stop_lpw);		/* LPW to use iom_data.stop_dcw. */
       73 	lpw.dcw_addr = abs_addr_18 (addr (iom_data.stop_dcw));
       74 	lpw.nc = "1"b;				/* Keep reusing same DCW. */
       75 
       76 	scwp = addr (iom_data.stop_scw);		/* SCW to use iom_data.stop_status */
       77 	scw.address = abs_addr_18 (addr (iom_data.stop_status));
       78 
       79 	iom_data.imw_lock = 1;			/* init to OK-to-process-interrupts */
       80 	iom_data.n_intr_procs = 0;			/* no one in interrupt handler yet */
       81 
       82 	do i = 1 to iom_data.n_devices;		/* initialize per_device */
       83 	     scwp = addr (iom_data.per_device (i).scw);	/* SCW's */
       84 	     scw.address = abs_addr_18 (addr (iom_data.per_device (i).status));
       85 	end;
       86 
       87 	do iom_no = lbound (iom_data.per_iom, 1) to hbound (iom_data.per_iom, 1);
       88 	     lpwp = addr (iom_data.per_iom (iom_no).connect_lpw);
       89 	     lpwp -> lpw.dcw_addr =
       90 		abs_addr_18 (addr (iom_mailbox_seg.iom_mailbox (iom_no).channel_mailbox (connect_channel).scw));
       91 	     lpwp -> lpw.tal = "1"b;			/* Allow tally update and tally runout recognition. */
       92 	     lpwp -> lpw.tally = "0001"b3;		/* Each connect will start a single channel. */
       93 
       94 /* Initialize each channel_table and mailbox entry. */
       95 
       96 	     do i = lbound (iom_mailbox_seg.iom_mailbox.channel_mailbox, 2)
       97 		to hbound (iom_mailbox_seg.iom_mailbox.channel_mailbox, 2);
       98 		iom_mailbox_seg.iom_mailbox (iom_no).channel_mailbox (i).lpw = iom_data.stop_lpw;
       99 		iom_mailbox_seg.iom_mailbox (iom_no).channel_mailbox (i).scw = iom_data.stop_scw;
      100 	     end;
      101 	     call iom_overhead$init_without_assign (iom_no, errcode);
      102 	end;
      103 
      104 /* Now loop through the IOM config cards. */
      105 
      106 	found_iom = "0"b;
      107 	iom_cardp = null ();
      108 
      109 config_loop:
      110 	call config$find (IOM_CARD_WORD, iom_cardp);
      111 	if iom_cardp = null () then do;		/* done at last */
      112 	     if ^found_iom then
      113 		call syserr (CRASH, "iom_data_init: No valid IOM cards found.");
      114 	     return;
      115 	end;
      116 
      117 /* Validate CONFIG IOM card */
      118 
      119 	if (iom_card.tag < lbound (iom_data.per_iom, 1)) | (iom_card.tag > hbound (iom_data.per_iom, 1)) then do;
      120 	     call syserr (CRASH, "iom_data_init: Bad IOM tag ^d. IOM card ignored.", iom_card.tag);
      121 	     goto config_loop;
      122 	end;
      123 
      124 	iom_no = iom_card.tag;
      125 	iom_name = substr ("ABCD", iom_no);
      126 
      127 	if iom_data.per_iom (iom_no).flags.configured then do;
      128 	     call syserr (CRASH, "iom_data_init: Duplicate IOM ^a in config deck.", iom_name);
      129 	     goto config_loop;
      130 	end;
      131 
      132 	if (iom_card.port < 0) | (iom_card.port > 7) then do;
      133 	     call syserr (CRASH, "iom_data_init: Illegal port number ^d for IOM ^a.", iom_card.port, iom_name);
      134 	     goto config_loop;
      135 	end;
      136 
      137 	if scs$port_data (iom_card.port).assigned > 0 then do;
      138 	     call syserr (CRASH, "iom_data_init: IOM ^a reuses port ^d.", iom_name, iom_card.port);
      139 	     goto config_loop;
      140 	end;
      141 	if iom_card.model = "nsa" then do;
      142 	     call syserr (ANNOUNCE, "iom_data_init:", "IOM model of ""nsa"" for IOM ^a will be changed to ""iom"".",
      143 		iom_card.tag);
      144 	     iom_card.model = "iom";
      145 	end;
      146 	if (iom_card.model ^= "iom") & (iom_card.model ^= "iioc") & (iom_card.model ^= "imu") then do;
      147 	     call syserr (CRASH, "iom_data_init: Bad model ""^a"" for IOM ^a. IOM card ignored.", iom_card.model,
      148 		iom_name);
      149 	     goto config_loop;
      150 	end;
      151 
      152 	if (iom_card.state ^= "on") & (iom_card.state ^= "off") then do;
      153 	     call syserr (CRASH, "iom_data_init: Bad state ""^a"" for IOM ^a. IOM card ignored.", iom_card.state,
      154 		iom_name);
      155 	     goto config_loop;
      156 	end;
      157 
      158 	found_iom = "1"b;
      159 	iom_data.per_iom (iom_no).flags.configured = "1"b;
      160 	iom_data.per_iom (iom_no).flags.on_line = (iom_card.state = "on");
      161 	iom_data.per_iom (iom_no).model = iom_card.model;
      162 	addr (iom_data.per_iom (iom_no).cow) -> cow.port, iom_data.per_iom (iom_no).port = iom_card.port;
      163 
      164 	scs$port_data (iom_card.port).assigned = IOM_PORT;
      165 	scs$port_data (iom_card.port).iom_number = iom_no;
      166 
      167 /* enable the IOM ports and interrupt cells */
      168 
      169 /* Do something to open up the port */
      170 
      171 	scs$open_level = scs$open_level | iom_int_mask (iom_no);
      172 
      173 /* Set up the handler and mailbox for the system fault channel. */
      174 
      175 	if iom_data.per_iom (iom_no).on_line then do;
      176 	     call iom_overhead$init (iom_no, errcode);
      177 	     if errcode ^= 0 then
      178 		call syserr (CRASH, "iom_data_init: Unable to assign overhead channel for IOM ^d.", iom_no);
      179 	end;
      180 	go to config_loop;
      181 
      182 
      183 /* * * * * * * * * * ABS_ADDR_18 * * * * * * * * * */
      184 
      185 abs_addr_18:
      186      procedure (P) returns (bit (18) aligned);
      187 dcl	P		   ptr parameter;
      188 dcl	address		   fixed bin (26);
      189 dcl	ec		   fixed bin (35);
      190 
      191 	address = absadr (P, ec);
      192 	if ec ^= 0 then
      193 	     call syserr (CRASH, "iom_data_init: Error from absadr.");
      194 	if address > (262144 - 4096) then
      195 	     call syserr (CRASH, "iom_data_init: Data not in low 256K.");
      196 	return (bit (binary (address, 18)));
      197      end abs_addr_18;
      198 
  1     1 /* BEGIN INCLUDE FILE ... config_iom_card.incl.pl1 ... 11/37/80 W. Olin Sibert */
  1     2 
  1     3 dcl  iom_cardp pointer;				/* pointer to IOM card */
  1     4 
  1     5 dcl 1 iom_card aligned based (iom_cardp),		/* IOM card declaration */
  1     6     2 word char (4),				/* "iom" */
  1     7     2 tag fixed bin (3),				/* One more than IOM tag set in maintenance panel switches */
  1     8     2 port fixed bin (3),				/* Controller port to which IOM is connected */
  1     9     2 model char (4),				/* IOM model number: "iomb", "nsa", "iioc" */
  1    10     2 state char (4),				/* State: "on" or "off" */
  1    11 
  1    12     2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  1    13 
  1    14     2 type_word aligned,
  1    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  1    16       3 pad1 bit (4) unaligned,
  1    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  1    18 
  1    19 dcl  IOM_CARD_WORD char (4) aligned internal static options (constant) init ("iom");
  1    20 
  1    21 /* END INCLUDE FILE ... config_iom_card.incl.pl1 */
      199 
      200 
  2     1 /* Begin include file ...... iom_data.incl.pl1
  2     2*   First written in August 1971 by R F Mabee.
  2     3*   Modified for paged IOM November 1980 by C. Hornig.
  2     4*   More IIOC changes by C. Hornig, June 1982.
  2     5*   Modified for channel reconfiguration by Chris Jones, January 1984.
  2     6*   Modified to remove support of non-paged IOMs by Chris Jones, August 1984.
  2     7*   Modified to add IMW read protocol flags by M. Pandolf, January 1985.
  2     8**/
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	iom_data$		   external;
  2    12 dcl	iom_mailbox$	   external;
  2    13 
  2    14 dcl	n_devices		   fixed bin;
  2    15 dcl	iom_data_ptr	   ptr;
  2    16 
  2    17 dcl	1 iom_data	   based (iom_data_ptr) aligned,
  2    18 	  2 n_devices	   fixed bin,		/* (0) Maximum number of channels. */
  2    19 	  2 stop_lpw	   bit (36),		/* (1) LPW pointing to stop_dcw. */
  2    20 	  2 stop_dcw	   bit (36),		/* (2) DCW to stop channel, probably storing bad status. */
  2    21 	  2 stop_scw	   bit (36),		/* (3) SCW for same */
  2    22 	  2 imw_lock	   fixed bin (35),		/* (4) Essentially a lock for iom switch checking: */
  2    23 						/* 1  : OK to poll IMW */
  2    24 						/* 0  : lock in transition */
  2    25 						/* -1 : DONT poll IMW */
  2    26 	  2 n_intr_procs fixed bin (35),		/* (5) Number of processors in interrupt handler */
  2    27 	  2 pad1		   (2) bit (36),
  2    28 	  2 stop_status	   bit (72),		/* (10) All unused channels store status here. */
  2    29 	  2 rfh1		   (6) bit (36),		/* can't use this */
  2    30 	  2 stop_ext_status	   bit (8 * 36),		/* (20) Unused channels' extended status */
  2    31 	  2 pad3		   (5) bit (36),
  2    32 	  2 invalid_interrupts fixed bin (35),		/* (35) interrupts on unused channels */
  2    33 	  2 null_interrupts	   fixed bin (35),		/* (36) spurious interrupts */
  2    34 	  2 multiple_interrupts
  2    35 			   fixed bin (35),		/* (37) several interrupts at a time */
  2    36 	  2 per_iom	   (4) like per_iom,	/* (40) for each IOM */
  2    37 	  2 per_device	   (n_devices refer (iom_data.n_devices)) like per_device;
  2    38 						/* (240) Data for assigned channels. */
  2    39 
  2    40 dcl	1 per_iom		   aligned based,
  2    41 	  2 lock		   bit (36),		/* (40) connect mailbox lock */
  2    42 	  2 flags,				/* (41) */
  2    43 	    3 configured	   bit (1) unal,		/* is configured */
  2    44 	    3 on_line	   bit (1) unal,		/* is ON */
  2    45 	    3 pad1	   bit (34) unal,
  2    46 	  2 model		   char (4),		/* (42) what kind of IOM */
  2    47 	  2 port		   fixed bin (3),		/* (43) SC port */
  2    48 	  2 connect_time	   fixed bin (71),		/* (44) time of last connect */
  2    49 	  2 connect_lpw	   bit (36),		/* (46) LPW for connect channel */
  2    50 	  2 cow		   bit (36),		/* (47) Connect Operand Word */
  2    51 	  2 special_chx	   fixed bin (35),		/* (50) chx of special status channel */
  2    52 	  2 fault_chx	   fixed bin (35),		/* (51) chx of system fault channel */
  2    53 	  2 pad2		   (4) bit (36),
  2    54 	  2 abandoned_connects fixed bin (35),		/* (56) times we couldn't get IOM to listen at all */
  2    55 	  2 reconnects	   fixed bin (35),		/* (57) times a connect was lost */
  2    56 	  2 chantab	   (0:63) uns fixed bin (9) unal;
  2    57 						/* (60) packed devtab indices */
  2    58 
  2    59 dcl	1 per_device	   aligned based,
  2    60 	  2 status	   bit (72),		/* (0) Status for channel is stored here. */
  2    61 	  2 rfh1		   (6) bit (36),
  2    62 	  2 ext_status	   bit (8 * 36),		/* (10) extended status stored by IIOC */
  2    63 	  2 iom		   uns fixed bin (3),	/* (20) IOM# (1-4) */
  2    64 	  2 channel	   uns fixed bin (6),	/* (21) channel # */
  2    65 	  2 handler	   entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  2    66 						/* (22) Interrupt handler for device. */
  2    67 	  2 flags,				/* (26) */
  2    68 	    3 in_use	   bit (1) unal,		/* assigned */
  2    69 	    3 queue_status	   bit (1) unal,		/* maintain status queue */
  2    70 	    3 on_line	   bit (1) unal,		/* can be assigned */
  2    71 	  2 index		   fixed bin (35),		/* (27) Channel identification index. */
  2    72 	  2 pcw		   bit (72),		/* (30) Peripheral Control Word */
  2    73 	  2 lpw		   bit (72),		/* (32) List Pointer Word */
  2    74 	  2 scw		   bit (36),		/* (34) Status Control Word */
  2    75 	  2 pad1		   fixed bin (35),
  2    76 	  2 status_queue_ptr   ptr,			/* (36) Status queue */
  2    77 	  2 connect_time	   fixed bin (71),		/* (40) time of last connect */
  2    78 	  2 connects	   fixed bin (71),		/* (42) Total connects */
  2    79 	  2 interrupts	   fixed bin (71),		/* (44) Total number of interrupts for this channel. */
  2    80 	  2 interrupt_time	   fixed bin (71);		/* (46) Total interrupt time for this channel. */
  2    81 
  2    82 dcl	iom_mailbox_seg_ptr	   ptr;
  2    83 dcl	1 iom_mailbox_seg	   aligned based (iom_mailbox_seg_ptr),
  2    84 	  2 imw_array	   (0:31) bit (32),		/* Indexed by interrupt cell number. One bit for each channel. */
  2    85 	  2 system_fault	   (4) aligned like status_queue,
  2    86 						/* system faults store here (12 words/IOM) */
  2    87 	  2 special_status	   (4) aligned like status_queue,
  2    88 						/* special status words here (12 words/IOM) */
  2    89 	  2 iom_mailbox	   (4) like iom_mailbox;	/* Used to communicate with the IOM. */
  2    90 
  2    91 dcl	status_queue_ptr	   ptr;
  2    92 dcl	1 status_queue	   aligned based (status_queue_ptr),
  2    93 	  2 status	   (12) bit (36);
  2    94 
  2    95 dcl	1 iom_mailbox	   aligned based,
  2    96 	  2 channel_mailbox	   (0:63) like channel_mailbox;
  2    97 
  2    98 dcl	1 channel_mailbox	   aligned based,
  2    99 	  2 lpw		   bit (72),		/* List pointer word. Points to DCW list. */
  2   100 	  2 scw		   bit (36),		/* Status control word. Points to channel_table.status. */
  2   101 	  2 dcw		   bit (36);		/* Data control word. Primarily scratch space for IOM. */
  2   102 
  2   103 /* Defined channel numbers. */
  2   104 
  2   105 dcl	(
  2   106 	system_fault_channel   init (1),		/* Stores system fault words using LPW and DCW. */
  2   107 	connect_channel	   init (2),		/* Starts other channels using LPW pointing to PCW. */
  2   108 	special_status_channel init (6)		/* Stores special status using LPW and DCW. */
  2   109 	)		   fixed bin (6) static options (constant);
  2   110 
  2   111 /* End of include file ..... iom_data.incl.pl1 */
      201 
      202 
  3     1 
  3     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  3     3 
  3     4 dcl  dcwp ptr,					/* pointer to DCW */
  3     5      tdcwp ptr;					/* pointer to TDCW */
  3     6 
  3     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  3     8      (2 address bit (18),				/* address for data transfer */
  3     9       2 char_pos bit (3),				/* character position */
  3    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  3    11       2 type bit (2),				/* DCW type */
  3    12       2 tally bit (12)) unal;				/* tally for data transfer */
  3    13 
  3    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  3    15      (2 address bit (18),				/* address to transfer to */
  3    16       2 mbz1 bit (4),
  3    17       2 type bit (2),				/* should be "10"b for TDCW */
  3    18       2 mbz2 bit (9),
  3    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  3    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  3    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  3    22 
  3    23 /* End of include file ...... iom_dcw.incl.pl1 */
  3    24 
      203 
  4     1 
  4     2 /* Begin include file ...... iom_lpw.incl.pl1 */
  4     3 /*	modified 3/4/75 by Noel I. Morris	*/
  4     4 
  4     5 dcl  lpwp ptr,					/* pointer to LPW */
  4     6      lpwep ptr;					/* pointer to LPW extension */
  4     7 
  4     8 dcl 1 lpw based (lpwp) aligned,			/* List Pointer Word */
  4     9      (2 dcw_addr bit (18),				/* address of DCW list */
  4    10       2 res bit (1),				/* "1"b to restrict use of IDCW */
  4    11       2 iom_rel bit (1),				/* IOM controlled copy of REL bit */
  4    12       2 ae bit (1),					/* "1"b to use addr extension for DCW list service */
  4    13       2 nc bit (1),					/* "1"b to supress LPW tally update */
  4    14       2 tal bit (1),				/* "1"b to enable tally runout fault */
  4    15       2 rel bit (1),				/* "1"b to set relative mode */
  4    16       2 tally bit (12)) unal;				/* LPW tally */
  4    17 
  4    18 dcl 1 lpw_ext based (lpwep) aligned,			/* List Pointer Word Extension */
  4    19      (2 base bit (9),				/* relative addressing base */
  4    20       2 bound bit (9),				/* relative addressing bound */
  4    21       2 idcwp bit (18)) unal;				/* address of last IDCW */
  4    22 
  4    23 /* End of include file ...... iom_lpw.incl.pl1 */
  4    24 
      204 
  5     1 
  5     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  5     3 
  5     4 dcl  pcwp ptr;					/* pointer to PCW */
  5     5 
  5     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  5     7      (2 command bit (6),				/* device command */
  5     8       2 device bit (6),				/* device code */
  5     9       2 ext bit (6),				/* address extension */
  5    10       2 code bit (3),				/* should be "111"b for PCW */
  5    11       2 mask bit (1),				/* channel mask bit */
  5    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  5    13       2 chan_cmd bit (6),				/* type of I/O operation */
  5    14       2 count bit (6),				/* record count or control character */
  5    15       2 mbz1 bit (3),
  5    16       2 channel bit (6),				/* channel number */
  5    17       2 mbz2 bit (27)) unal;
  5    18 
  5    19 dcl  idcwp ptr;					/* pointer to IDCW */
  5    20 
  5    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  5    22      (2 command bit (6),				/* device command */
  5    23       2 device bit (6),				/* device code */
  5    24       2 ext bit (6),				/* address extension */
  5    25       2 code bit (3),				/* should be "111"b for PCW */
  5    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  5    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  5    28       2 chan_cmd bit (6),				/* type of I/O operation */
  5    29       2 count bit (6)) unal;				/* record count or control character */
  5    30 
  5    31 /* End include file ...... iom_pcw.incl.pl1 */
  5    32 
      205 
  6     1 
  6     2 /* Begin include file ...... iom_scw.incl.pl1 */
  6     3 
  6     4 dcl  scwp ptr;					/* pointer to SCW */
  6     5 
  6     6 dcl 1 scw based (scwp) aligned,			/* Status Control Word */
  6     7      (2 address bit (18),				/* address of status queue */
  6     8       2 lq bit (2),					/* list/queue control */
  6     9       2 mbz bit (4),
  6    10       2 tally bit (12)) unal;				/* status queue is 1 word longer than tally */
  6    11 
  6    12 /* End of include file ...... iom_scw.incl.pl1 */
  6    13 
      206 
      207 
  7     1 /* Begin include file io_manager_dcls.incl.pl1 */
  7     2 
  7     3 /* Written by Charles Hornig, late 1980 and early 1981 */
  7     4 /* Modified for MR10 interface, February 1982 */
  7     5 /* Channel reconfiguration entries added by Chris Jones, January 1984 */
  7     6 
  7     7 /* These entries are callable on unwired stacks. */
  7     8 
  7     9 /* call io_manager$assign (Chx, Channel, Handler, Index, Statusp, Code); */
  7    10 dcl  io_manager$assign
  7    11 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  7    12 	fixed bin (35), ptr, fixed bin (35));
  7    13 
  7    14 /* call io_manager$assign_add (Chx, Channel, Handler, Index, Statusp, Code); */
  7    15 dcl  io_manager$assign_add
  7    16 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  7    17 	fixed bin (35), ptr, fixed bin (35));
  7    18 
  7    19 /* call io_manager$unassign (Chx, Code); */
  7    20 dcl  io_manager$unassign entry (fixed bin (35), fixed bin (35));
  7    21 
  7    22 /* call io_manager$unassign_delete (Chx, Code); */
  7    23 dcl  io_manager$unassign_delete entry (fixed bin (35), fixed bin (35));
  7    24 
  7    25 /* call io_manager$connect (Io_manager_arg); */
  7    26 dcl  io_manager$connect entry (1 aligned like io_manager_arg);
  7    27 
  7    28 /* call io_manager$connect_abs (Io_manager_arg); */
  7    29 dcl  io_manager$connect_abs entry (1 aligned like io_manager_arg);
  7    30 
  7    31 /* call io_manager$connect_direct (Io_manager_arg); */
  7    32 dcl  io_manager$connect_direct entry (1 aligned like io_manager_arg);
  7    33 
  7    34 /* call io_manager$get_status (Chx, Io_status_entry_ptr); */
  7    35 dcl  io_manager$get_status entry (fixed bin (35), ptr);
  7    36 
  7    37 /* call io_manager$mask (Chx); */
  7    38 dcl  io_manager$mask entry (fixed bin (35));
  7    39 
  7    40 /* call io_manager$ignore_interrupt (); */
  7    41 dcl  io_manager$ignore_interrupt entry (fixed bin (35), fixed bin (3), bit (36) aligned);
  7    42 
  7    43 /* call io_manager$data_tdcw (Io_manager_arg);
  7    44*   dcl  io_manager$data_tdcw entry (1 aligned like io_manager_arg);
  7    45*
  7    46*   /* call io_manager$workspace_tdcw (Io_manager_arg); */
  7    47 dcl  io_manager$workspace_tdcw entry (1 aligned like io_manager_arg);
  7    48 
  7    49 dcl  io_manager_arg_ptr ptr;
  7    50 dcl  1 io_manager_arg aligned based (io_manager_arg_ptr),
  7    51        2 chx fixed bin (35),				/* channel index from io_manager$assign */
  7    52        2 bound fixed bin (19),			/* workspace size */
  7    53        2 pcw bit (36) aligned,			/* or IDCW */
  7    54        2 listx fixed bin (18),			/* DCW list offset */
  7    55        2 ptp ptr,					/* page table pointer */
  7    56        2 listp ptr,					/* DCW list pointer */
  7    57        2 dcw_pair_ptr ptr;				/* DCW pair pointer */
  7    58 
  7    59 /* End include file io_manager_dcls.incl.pl1 */
      208 
      209 
  8     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  8     2 /* format: style4 */
  8     3 
  8     4 /* Information about system controllers */
  8     5 
  8     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  8     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  8     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  8     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  8    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  8    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  8    12          3 mbz bit (3) unaligned,
  8    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  8    14        2 info aligned,
  8    15          3 online bit (1) unaligned,			/* ON if controller is online */
  8    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  8    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  8    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  8    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  8    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  8    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  8    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  8    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  8    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  8    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  8    26          3 type bit (4) unaligned,			/* Model number for this controller */
  8    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  8    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  8    29          3 mbz bit (13) unaligned,
  8    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  8    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  8    32 
  8    33 /* Information about CPUs */
  8    34 
  8    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  8    36        (
  8    37        2 online bit (1),				/* "1"b if CPU is online */
  8    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  8    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  8    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  8    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  8    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  8    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  8    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  8    45        2 mbz1 bit (6),
  8    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  8    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  8    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  8    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  8    50        2 mbz2 bit (12),
  8    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  8    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  8    53        2 controller_port fixed bin (3) unsigned
  8    54        ) unaligned;					/* Port on controller */
  8    55 
  8    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  8    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  8    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  8    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  8    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  8    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  8    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  8    63        2 pad bit (12) unaligned;
  8    64 
  8    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  8    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  8    67        2 cow,
  8    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  8    69          3 mbz1 bit (13) unaligned,
  8    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  8    71          3 mbz2 bit (2) unaligned,
  8    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  8    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  8    74          3 mbz3 bit (3) unaligned,
  8    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  8    76 
  8    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  8    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  8    79        2 pad bit (12) unal,
  8    80        2 tag bit (6) unal;				/* Better be zero. */
  8    81 
  8    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  8    83        2 pad bit (36) aligned,
  8    84        2 cow,					/* Connect operand word, in odd location. */
  8    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  8    86          3 mbz1 bit (13) unaligned,
  8    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  8    88          3 mbz2 bit (9) unaligned,
  8    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  8    90 
  8    91 /* MASKS and PATTERNS */
  8    92 
  8    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  8    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  8    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  8    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  8    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  8    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  8    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  8   100 
  8   101 /* CAM and CACHE clear info */
  8   102 
  8   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  8   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  8   105 
  8   106 /* MASKING INSTRUCTIONS & POINTERS */
  8   107 
  8   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  8   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  8   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  8   111 
  8   112 /* MISCELLANEOUS */
  8   113 
  8   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  8   115        (
  8   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  8   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  8   118        2 pad1 bit (4),
  8   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  8   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  8   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  8   122        2 mask_cpu fixed bin (5)
  8   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  8   124 
  8   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  8   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  8   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  8   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  8   129 
  8   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  8   131 
  8   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  8   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  8   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  8   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  8   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  8   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  8   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  8   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  8   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  8   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  8   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  8   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  8   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  8   145 
  8   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  8   147 
  8   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  8   149 
  8   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  8   151 
  8   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  8   153 
  8   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  8   155 						/* Which ports have expanders */
  8   156 
  8   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  8   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  8   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  8   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  8   161 
  8   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  8   163 
  8   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  8   165 						/* Controller size on config card */
  8   166 
  8   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  8   168 
  8   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  8   170 						/* PTWs for SCAS pages */
  8   171 
  8   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  8   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  8   174 
  8   175 
  8   176 dcl  (
  8   177      IOM_PORT init (1),
  8   178      CPU_PORT init (2),
  8   179      BULK_PORT init (3)
  8   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  8   181 
  8   182 
  8   183 /* END INCLUDE FILE scs.incl.pl1 */
      210 
      211 
  9     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  9     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  9     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  9     4 
  9     5 /* This include file has an ALM version.  Keep 'em in sync! */
  9     6 
  9     7 dcl (
  9     8 
  9     9 /* The following constants define the message action codes.  This indicates
  9    10*how a message is to be handled.  */
  9    11 
  9    12      SYSERR_CRASH_SYSTEM	init (1),			
  9    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  9    14 
  9    15      SYSERR_TERMINATE_PROCESS	init (2),
  9    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  9    17 
  9    18      SYSERR_PRINT_WITH_ALARM	init (3),
  9    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  9    20 
  9    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  9    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  9    23 
  9    24      SYSERR_LOG_OR_PRINT	init (4),
  9    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  9    26 
  9    27      SYSERR_LOG_OR_DISCARD	init (5),
  9    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  9    29 
  9    30 
  9    31 /* The following constants are added to the normal severities to indicate
  9    32*different sorting classes of messages.  */
  9    33 
  9    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  9    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  9    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  9    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  9    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  9    39 	) fixed bin internal static options (constant);
  9    40 
  9    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      212 
      213 
      214 /*	BEGIN MESSAGE DOCUMENTATION
      215*
      216*   Message:
      217*   iom_data_init: No valid IOM cards found.
      218*
      219*   S: $crash
      220*
      221*   T: $init
      222*
      223*   M: There were no valid IOM cards in the configuration deck.
      224*
      225*   A: Correct configuration deck and reboot.
      226*
      227*
      228*   Message:
      229*   iom_data_init: Bad IOM tag TAG. IOM card ignored.
      230*
      231*   S: $crash
      232*
      233*   T: $init
      234*
      235*   M: An IOM card contained an IOM tag other than A, B, C, or D.
      236*
      237*   A: Correct configuration deck and reboot.
      238*
      239*
      240*   Message:
      241*   iom_data_init: Illegal port number PORT for IOM TAG.
      242*
      243*   S: $crash
      244*
      245*   T: $init
      246*
      247*   M: The IOM card for IOM TAG contained an illegal port number.
      248*   The port number must be between 0 and 7.
      249*
      250*   A: Correct configuration deck and reboot.
      251*
      252*
      253*   Message:
      254*   iom_data_init: IOM TAG reuses port PORT.
      255*
      256*   S: $crash
      257*
      258*   T: $init
      259*
      260*   M: IOM TAG has been given the same port as some other active module (CPU or IOM).
      261*
      262*   A: Correct configuration deck and reboot.
      263*
      264*
      265*   Message:
      266*   iom_data_init: Bad model MODEL for IOM TAG.  IOM card ignored.
      267*
      268*   S: $crash
      269*
      270*   T: $init
      271*
      272*   M: The model field for IOM TAG was not recognized.
      273*
      274*   A: Correct configuration deck and reboot.
      275*
      276*
      277*   Message:
      278*   iom_data_init: Bad state STATE for IOM TAG.  IOM card ignored.
      279*
      280*   S: $crash
      281*
      282*   T: $init
      283*
      284*   M: The state for IOM TAG was neither "on" or "off".
      285*
      286*   A: Correct configuration deck and reboot.
      287*
      288*
      289*   Message:
      290*   IOM model of "nsa" for IOM TAG will be changed to "iom".
      291*
      292*   S: $announce
      293*
      294*   T: $init
      295*
      296*   M: The model field of this IOM card should be "iom".  The system will
      297*      correct it for this boot.
      298*
      299*   A: Correct configuration deck before next boot.
      300*
      301*
      302*   Message:
      303*   iom_data_init: Error from absadr.
      304*
      305*   S: $crash
      306*
      307*   T: $init
      308*
      309*   M: $err
      310*
      311*   A: $contact
      312*
      313*
      314*   Message:
      315*   iom_data_init: Data not in low 256K.
      316*
      317*   S: $crash
      318*
      319*   T: $init
      320*
      321*   M: The IOM data bases are not located in the low 256K of memory.
      322*   $err
      323*
      324*   A: Correct configuration deck and reboot.
      325*
      326*
      327*   Message:
      328*   iom_data_init: Duplicate IOM TAG in config deck.
      329*
      330*   S: $crash
      331*
      332*   T: $init
      333*
      334*   M: Two IOM cards specifying IOM tag TAG were found
      335*   in the configuration deck.
      336*
      337*   A: Correct configuration deck and reboot.
      338*
      339*
      340*   Message:
      341*   iom_data_init: Unable to assign overhead channel for IOM TAG.
      342*
      343*   S: $crash
      344*
      345*   T: $init
      346*
      347*   M: Could not set up overhead channel handlers for IOM TAG.
      348*   $err
      349*
      350*   A: $contact
      351*
      352*
      353*   END MESSAGE DOCUMENTATION */
      354 
      355      end iom_data_init;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0816.1  iom_data_init.pl1                 >spec>install>1112>iom_data_init.pl1
199          1    05/08/81  1853.6  config_iom_card.incl.pl1          >ldd>include>config_iom_card.incl.pl1
201          2    04/11/85  1452.4  iom_data.incl.pl1                 >ldd>include>iom_data.incl.pl1
203          3    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
204          4    06/03/75  0715.0  iom_lpw.incl.pl1                  >ldd>include>iom_lpw.incl.pl1
205          5    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
206          6    04/29/76  1103.8  iom_scw.incl.pl1                  >ldd>include>iom_scw.incl.pl1
208          7    07/11/84  0937.3  io_manager_dcls.incl.pl1          >ldd>include>io_manager_dcls.incl.pl1
210          8    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
212          9    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000037 constant        fixed bin(17,0)          initial dcl 9-7 set ref 142*
CRASH                           000040 constant        fixed bin(17,0)          initial dcl 9-7 set ref 112* 120* 128* 133* 138*
                                                                                  147* 153* 177* 192* 194*
IOM_CARD_WORD                   000022 constant        char(4)                  initial dcl 1-19 set ref 109*
IOM_PORT                               constant        fixed bin(17,0)          initial dcl 8-176 ref 164
P                                      parameter       pointer                  dcl 187 set ref 185 191*
absadr                          000010 constant        entry                    external dcl 43 ref 191
addr                                                   builtin function         dcl 58 ref 61 62 68 72 73 73 76 77 77 83 84 84 88 89
                                                                                  89 162
address                                based           bit(18)                  level 2 in structure "scw" packed packed unaligned
                                                                                  dcl 6-6 in procedure "iom_data_init" set ref 77*
                                                                                  84*
address                         000132 automatic       fixed bin(26,0)          dcl 188 in procedure "abs_addr_18" set ref 191* 194
                                                                                  196
assigned                        000026 external static fixed bin(4,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 8-56 set ref 137 164*
binary                                                 builtin function         dcl 58 ref 196
bit                                                    builtin function         dcl 58 ref 196
chan_cmd                  0(24)        based           bit(6)                   level 2 packed packed unaligned dcl 5-21 set ref 70*
channel_mailbox         200            based           structure                array level 3 in structure "iom_mailbox_seg"
                                                                                  dcl 2-83 in procedure "iom_data_init" set ref 96
                                                                                  96
channel_mailbox                        based           structure                level 1 dcl 2-98 in procedure "iom_data_init"
code                      0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 5-21 set ref 69*
config$find                     000012 constant        entry                    external dcl 44 ref 109
configured               41            based           bit(1)                   array level 4 packed packed unaligned dcl 2-17 set
                                                                                  ref 127 159*
connect_channel                        constant        fixed bin(6,0)           initial dcl 2-105 ref 89 89
connect_lpw              46            based           bit(36)                  array level 3 dcl 2-17 set ref 88
cow                                    based           structure                level 1 dcl 50 in procedure "iom_data_init"
cow                      47            based           bit(36)                  array level 3 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init" set ref 162
dcw_addr                               based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 73*
                                                                                  89*
ec                              000133 automatic       fixed bin(35,0)          dcl 189 set ref 191* 192
errcode                         000101 automatic       fixed bin(35,0)          dcl 38 set ref 101* 176* 177
flags                    41            based           structure                array level 3 dcl 2-17
found_iom                       000104 automatic       bit(1)                   dcl 41 set ref 106* 112 158*
hbound                                                 builtin function         dcl 58 ref 87 96 119
i                               000100 automatic       fixed bin(17,0)          dcl 37 set ref 82* 83 84 84* 96* 98 99*
idcw                                   based           structure                level 1 dcl 5-21
idcwp                           000116 automatic       pointer                  dcl 5-19 set ref 68* 69 70
imw_lock                  4            based           fixed bin(35,0)          level 2 dcl 2-17 set ref 79*
io_manager_arg                         based           structure                level 1 dcl 7-50
iom_card                               based           structure                level 1 dcl 1-5
iom_cardp                       000106 automatic       pointer                  dcl 1-3 set ref 107* 109* 111 119 119 120 124 132
                                                                                  132 133 137 138 141 142 144 146 146 146 147 152
                                                                                  152 153 160 161 162 164 165
iom_data                               based           structure                level 1 dcl 2-17
iom_data$                       000022 external static fixed bin(17,0)          dcl 2-11 set ref 61
iom_data_ptr                    000110 automatic       pointer                  dcl 2-15 set ref 61* 68 72 73 73 76 77 77 79 80 82
                                                                                  83 84 84 87 87 88 98 99 119 119 127 159 160 161
                                                                                  162 162 175
iom_int_mask                    000000 constant        bit(72)                  initial array dcl 54 ref 171
iom_mailbox             200            based           structure                array level 2 in structure "iom_mailbox_seg"
                                                                                  dcl 2-83 in procedure "iom_data_init"
iom_mailbox                            based           structure                level 1 dcl 2-95 in procedure "iom_data_init"
iom_mailbox$                    000024 external static fixed bin(17,0)          dcl 2-12 set ref 62
iom_mailbox_seg                        based           structure                level 1 dcl 2-83 set ref 66*
iom_mailbox_seg_ptr             000112 automatic       pointer                  dcl 2-82 set ref 62* 66 89 89 96 96 98 99
iom_name                        000103 automatic       char(1)                  dcl 40 set ref 125* 128* 133* 138* 147* 153*
iom_no                          000102 automatic       fixed bin(3,0)           dcl 39 set ref 87* 88 89 89 98 99 101* 124* 125 127
                                                                                  159 160 161 162 162 165 171 175 176* 177*
iom_number                0(09) 000026 external static fixed bin(3,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 8-56 set ref 165*
iom_overhead$init               000014 constant        entry                    external dcl 45 ref 176
iom_overhead$init_without_assign
                                000016 constant        entry                    external dcl 46 ref 101
lbound                                                 builtin function         dcl 58 ref 87 96 119
lpw                                    based           structure                level 1 dcl 4-8 in procedure "iom_data_init"
lpw                     200            based           bit(72)                  array level 4 in structure "iom_mailbox_seg"
                                                                                  dcl 2-83 in procedure "iom_data_init" set ref 98*
lpwp                            000114 automatic       pointer                  dcl 4-5 set ref 72* 73 74 88* 89 91 92
model                     3            based           char(4)                  level 2 in structure "iom_card" dcl 1-5 in procedure
                                                                                  "iom_data_init" set ref 141 144* 146 146 146 147*
                                                                                  161
model                    42            based           char(4)                  array level 3 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init" set ref 161*
n_devices                              based           fixed bin(17,0)          level 2 dcl 2-17 ref 82
n_intr_procs              5            based           fixed bin(35,0)          level 2 dcl 2-17 set ref 80*
nc                        0(21)        based           bit(1)                   level 2 packed packed unaligned dcl 4-8 set ref 74*
null                                                   builtin function         dcl 58 ref 107 111
on_line                  41(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 2-17 set
                                                                                  ref 160* 175
per_device              240            based           structure                array level 2 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init"
per_device                             based           structure                level 1 dcl 2-59 in procedure "iom_data_init"
per_iom                  40            based           structure                array level 2 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init" set ref 87 87 119 119
per_iom                                based           structure                level 1 dcl 2-40 in procedure "iom_data_init"
port                      2            based           fixed bin(3,0)           level 2 in structure "iom_card" dcl 1-5 in procedure
                                                                                  "iom_data_init" set ref 132 132 133* 137 138* 162
                                                                                  164 165
port                     43            based           fixed bin(3,0)           array level 3 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init" set ref 162*
port                      0(33)        based           fixed bin(3,0)           level 2 in structure "cow" packed packed unsigned
                                                                                  unaligned dcl 50 in procedure "iom_data_init" set
                                                                                  ref 162*
scs$open_level                  000030 external static bit(72)                  dcl 8-94 set ref 171* 171
scs$port_data                   000026 external static structure                array level 1 dcl 8-56
scw                                    based           structure                level 1 dcl 6-6 in procedure "iom_data_init"
scw                     202            based           bit(36)                  array level 4 in structure "iom_mailbox_seg"
                                                                                  dcl 2-83 in procedure "iom_data_init" set ref 89
                                                                                  89 99*
scw                     274            based           bit(36)                  array level 3 in structure "iom_data" dcl 2-17
                                                                                  in procedure "iom_data_init" set ref 83
scwp                            000120 automatic       pointer                  dcl 6-4 set ref 76* 77 83* 84
state                     4            based           char(4)                  level 2 dcl 1-5 set ref 152 152 153* 160
status                  240            based           bit(72)                  array level 3 dcl 2-17 set ref 84 84
status_queue                           based           structure                level 1 dcl 2-92
stop_dcw                  2            based           bit(36)                  level 2 dcl 2-17 set ref 68 73 73
stop_lpw                  1            based           bit(36)                  level 2 dcl 2-17 set ref 72 98
stop_scw                  3            based           bit(36)                  level 2 dcl 2-17 set ref 76 99
stop_status              10            based           bit(72)                  level 2 dcl 2-17 set ref 77 77
substr                                                 builtin function         dcl 58 ref 125
syserr                          000020 constant        entry                    external dcl 48 ref 112 120 128 133 138 142 147 153
                                                                                  177 192 194
tag                       1            based           fixed bin(3,0)           level 2 dcl 1-5 set ref 119 119 120* 124 142*
tal                       0(22)        based           bit(1)                   level 2 packed packed unaligned dcl 4-8 set ref 91*
tally                     0(24)        based           bit(12)                  level 2 packed packed unaligned dcl 4-8 set ref 92*
unspec                                                 builtin function         dcl 58 set ref 66*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 9-7
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 8-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 8-176
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 9-7
LOG                                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 9-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 9-7
dcw                                    based           structure                level 1 dcl 3-7
dcwp                                   automatic       pointer                  dcl 3-4
io_manager$assign               000000 constant        entry                    external dcl 7-10
io_manager$assign_add           000000 constant        entry                    external dcl 7-15
io_manager$connect              000000 constant        entry                    external dcl 7-26
io_manager$connect_abs          000000 constant        entry                    external dcl 7-29
io_manager$connect_direct       000000 constant        entry                    external dcl 7-32
io_manager$get_status           000000 constant        entry                    external dcl 7-35
io_manager$ignore_interrupt     000000 constant        entry                    external dcl 7-41
io_manager$mask                 000000 constant        entry                    external dcl 7-38
io_manager$unassign             000000 constant        entry                    external dcl 7-20
io_manager$unassign_delete      000000 constant        entry                    external dcl 7-23
io_manager$workspace_tdcw       000000 constant        entry                    external dcl 7-47
io_manager_arg_ptr                     automatic       pointer                  dcl 7-49
lpw_ext                                based           structure                level 1 dcl 4-18
lpwep                                  automatic       pointer                  dcl 4-5
n_devices                              automatic       fixed bin(17,0)          dcl 2-14
pcw                                    based           structure                level 1 dcl 5-6
pcwp                                   automatic       pointer                  dcl 5-4
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 8-137
scs$bos_restart_flags                  external static bit(8)                   dcl 8-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 8-103
scs$cam_wait                           external static bit(8)                   dcl 8-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 8-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 8-152
scs$connect_lock                       external static bit(36)                  dcl 8-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 8-164
scs$controller_data                    external static structure                array level 1 dcl 8-6
scs$cow                                external static structure                array level 1 dcl 8-65
scs$cow_ptrs                           external static structure                array level 1 dcl 8-77
scs$cpu_test_mask                      external static bit(72)                  dcl 8-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 8-99
scs$cycle_priority_template            external static bit(7)                   dcl 8-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 8-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 8-140
scs$faults_initialized                 external static bit(1)                   dcl 8-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 8-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 8-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 8-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 8-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 8-97
scs$port_addressing_word               external static bit(3)                   array dcl 8-148
scs$processor                          external static bit(8)                   dcl 8-143
scs$processor_data                     external static structure                array level 1 dcl 8-35
scs$processor_data_switch_value        external static bit(36)                  dcl 8-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 8-142
scs$processor_start_mask               external static bit(72)                  dcl 8-95
scs$processor_start_pattern            external static bit(36)                  dcl 8-98
scs$processor_start_wait               external static bit(8)                   dcl 8-144
scs$processor_switch_compare           external static bit(36)                  array dcl 8-159
scs$processor_switch_data              external static bit(36)                  array dcl 8-157
scs$processor_switch_mask              external static bit(36)                  array dcl 8-160
scs$processor_switch_template          external static bit(36)                  array dcl 8-158
scs$processor_test_data                external static structure                level 1 dcl 8-114
scs$read_mask                          external static bit(36)                  array dcl 8-109
scs$reconfig_general_cow               external static structure                level 1 dcl 8-82
scs$reconfig_lock                      external static bit(36)                  dcl 8-133
scs$reconfig_locker_id                 external static char(32)                 dcl 8-167
scs$scas_page_table                    external static bit(36)                  array dcl 8-169
scs$set_cycle_switches                 external static bit(1)                   dcl 8-173
scs$set_mask                           external static bit(36)                  array dcl 8-108
scs$sys_level                          external static bit(72)                  dcl 8-93
scs$sys_trouble_pending                external static bit(1)                   dcl 8-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 8-146
scs$trouble_flags                      external static bit(8)                   dcl 8-134
special_status_channel                 internal static fixed bin(6,0)           initial dcl 2-105
status_queue_ptr                       automatic       pointer                  dcl 2-91
system_fault_channel                   internal static fixed bin(6,0)           initial dcl 2-105
tdcw                                   based           structure                level 1 dcl 3-14
tdcwp                                  automatic       pointer                  dcl 3-4

NAMES DECLARED BY EXPLICIT CONTEXT.
abs_addr_18                     001211 constant        entry                    internal dcl 185 ref 73 77 84 89
config_loop                     000466 constant        label                    dcl 109 ref 121 129 134 139 149 155 180
iom_data_init                   000261 constant        entry                    external dcl 34

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1430        1462    1310        1440
Length      2030    1310        32         332     120           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iom_data_init                       212 external procedure  is an external procedure.  
abs_addr_18                             internal procedure  shares stack frame of external procedure iom_data_init.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iom_data_init            000100 i                           iom_data_init
                         000101 errcode                     iom_data_init
                         000102 iom_no                      iom_data_init
                         000103 iom_name                    iom_data_init
                         000104 found_iom                   iom_data_init
                         000106 iom_cardp                   iom_data_init
                         000110 iom_data_ptr                iom_data_init
                         000112 iom_mailbox_seg_ptr         iom_data_init
                         000114 lpwp                        iom_data_init
                         000116 idcwp                       iom_data_init
                         000120 scwp                        iom_data_init
                         000132 address                     abs_addr_18
                         000133 ec                          abs_addr_18

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        config$find                   iom_overhead$init
iom_overhead$init_without_assign                            syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iom_data$                     iom_mailbox$                  scs$open_level                scs$port_data




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     34 000260        61 000266        62 000270        66 000272        68 000276        69 000300        70 000302
     72 000304        73 000306        74 000316        76 000320        77 000323        79 000334        80 000337
     82 000340        83 000347        84 000353        85 000364        87 000366        88 000373        89 000377
     91 000415        92 000417        96 000422        98 000427        99 000444       100 000446       101 000450
    102 000461       106 000463       107 000464       109 000466       111 000477       112 000503       114 000525
    119 000526       120 000534       121 000560       124 000561       125 000562       127 000573       128 000602
    129 000626       132 000627       133 000633       134 000663       137 000664       138 000670       139 000717
    141 000720       142 000725       144 000760       146 000763       147 001000       149 001030       152 001031
    153 001043       155 001073       158 001074       159 001076       160 001102       161 001113       162 001115
    164 001125       165 001133       171 001140       175 001147       176 001152       177 001162       180 001210
    185 001211       191 001213       192 001226       194 001250       196 001273


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
