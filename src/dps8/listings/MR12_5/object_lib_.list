	COMPILATION LISTING OF SEGMENT object_lib_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0955.9 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
       13*     audit(86-10-03,DGHowe), install(86-11-20,MR12.0-1222):
       14*     Written to support object multisegment files, for initiation, definition
       15*     searches, and info extraction.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       19 
       20 object_lib_:
       21   proc;
       22 
       23   /*** ****************************************************************/
       24   /***							*/
       25   /***	Name:	object_lib_				*/
       26   /***	Function:	This is a collection of subroutines used for the	*/
       27   /***		manipulation of executable binaries (segments or	*/
       28   /***		MSFs).					*/
       29   /***							*/
       30   /*** ****************************************************************/
       31 
       32   /* constants */
       33 
       34   dcl true		bit (1) static options (constant) init ("1"b);
       35   dcl false		bit (1) static options (constant) init ("0"b);
       36 
       37   dcl fault_tag_3		bit (6) static options (constant) init ("47"b3);
       38 
       39   /* parameters */
       40 
       41   dcl A_areap		ptr parameter;
       42   dcl A_code		fixed bin (35) parameter;
       43   dcl A_comp_infop		ptr parameter;
       44   dcl A_count		fixed bin (24) parameter;
       45   dcl A_dname		char (*) parameter;
       46   dcl A_ename		char (*) parameter;
       47   dcl A_live		bit (1) parameter;
       48   dcl A_offsetname		char (*) parameter;
       49   dcl A_oi_type		char (*) parameter;
       50   dcl A_refname		char (*) parameter;
       51   dcl A_segname		char (*) parameter;
       52   dcl A_segp		ptr parameter;
       53   dcl A_targetp		ptr parameter;
       54   dcl A_validate		bit (1) parameter;
       55   dcl A_version_reqd	char (8) parameter;
       56   dcl A_msf_sw		bit (1) parameter;
       57 
       58   /* procedures */
       59 
       60   dcl get_definition_	entry (ptr, char (*), char (*), ptr,
       61 			fixed bin (35));
       62   dcl get_system_free_area_	entry () returns (ptr);
       63   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
       64 			fixed bin (35));
       65   dcl hcs_$initiate_count	entry (char (*), char (*), char (*),
       66 			fixed bin (24), fixed bin (2), ptr,
       67 			fixed bin (35));
       68   dcl hcs_$status_minf	entry (char (*), char (*), fixed bin (1),
       69 			fixed bin (2), fixed bin (24),
       70 			fixed bin (35));
       71   dcl hcs_$status_mins	entry (ptr, fixed bin (2), fixed bin (24),
       72 			fixed bin (35));
       73   dcl hcs_$terminate_noname	entry (ptr, fixed bin (35));
       74   dcl initiate_file_	entry (char (*), char (*), bit (*), ptr,
       75 			fixed bin (24), fixed bin (35));
       76   dcl object_info_$brief	entry (ptr, fixed bin (24), ptr,
       77 			fixed bin (35));
       78   dcl object_info_$display	entry (ptr, fixed bin (24), ptr,
       79 			fixed bin (35));
       80   dcl object_info_$long	entry (ptr, fixed bin (24), ptr,
       81 			fixed bin (35));
       82   dcl pathname_		entry (char (*), char (*)) returns (char (168));
       83   dcl term_$no_clear	entry (char (*), fixed bin (35));
       84   dcl term_$single_refname	entry (char (*), fixed bin (35));
       85 
       86   /* external */
       87 
       88   dcl error_table_$bad_arg	external fixed bin (35);
       89   dcl error_table_$bad_class_def
       90 			external fixed bin (35);
       91   dcl error_table_$bad_indirect_def
       92 			external fixed bin (35);
       93   dcl error_table_$dirseg	external fixed bin (35);
       94   dcl error_table_$inconsistent_object_msf
       95 			external fixed bin (35);
       96   dcl error_table_$namedup	external fixed bin (35);
       97   dcl error_table_$nolinkag	external fixed bin (35);
       98   dcl error_table_$segknown	external fixed bin (35);
       99   dcl error_table_$unimplemented_version
      100 			external fixed bin (35);
      101 
      102   /* based */
      103 
      104   dcl based_area		area based (based_areap);
      105   dcl based_ptr		ptr based;
      106   dcl 01 def		aligned like definition based (defp);
      107   dcl 01 dh		aligned like definition_header based (dhp);
      108   dcl 01 mm		aligned like msf_map based (mmp);
      109 
      110   /* automatic */
      111 
      112   dcl based_areap		ptr automatic;
      113   dcl bc			fixed bin (24) automatic;
      114   dcl bit_count		fixed bin (24) automatic;
      115   dcl c			fixed bin automatic;
      116   dcl comp		fixed bin automatic;
      117   dcl defp		ptr automatic;
      118   dcl dhp			ptr automatic;
      119   dcl dname		char (168) automatic;
      120   dcl dnamel		fixed bin automatic;
      121   dcl ec			fixed bin (35) automatic;
      122   dcl ename		char (32) automatic;
      123   dcl i			fixed bin automatic;
      124   dcl info_ep		variable entry (ptr, fixed bin (24), ptr,
      125 			fixed bin (35)) automatic;
      126   dcl mmp			ptr automatic;
      127   dcl n_comp		fixed bin (24) automatic;
      128   dcl no_clear_sw		bit (1) automatic;
      129   dcl 01 oi		aligned like object_info automatic;
      130   dcl segp		ptr automatic;
      131   dcl targetp		ptr automatic;
      132   dcl term_sw		bit (1) automatic;
      133   dcl type		fixed bin automatic;
      134 
      135   /* conditions */
      136 
      137   dcl cleanup		condition;
      138 
      139   /* builtin */
      140 
      141   dcl addr		builtin;
      142   dcl addrel		builtin;
      143   dcl char		builtin;
      144   dcl ltrim		builtin;
      145   dcl null		builtin;
      146   dcl unspec		builtin;
      147 
      148 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      149 
      150 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      151 
      152 
      153 initiate:
      154   entry (A_dname,			/** target dir name     ( in)	*/
      155        A_ename,			/** target entry name   ( in)	*/
      156        A_refname,			/** target refname	    ( in)	*/
      157        A_validate,			/** validate switch	    ( in) */
      158        A_targetp,			/** target pointer	    (out)	*/
      159        A_count,			/** bit_count	    (out) */
      160        A_msf_sw,			/** MSF switch	    (out)	*/
      161        A_code);			/** error code	    (out)	*/
      162 
      163   /*** ****************************************************************/
      164   /***							*/
      165   /***	Name:	object_lib_$initiate			*/
      166   /***	Input:	dname, ename, refname, validate		*/
      167   /***	Function:	Initiates the binary file (segment or MSF),	*/
      168   /***		specified by dir_name and entry_name, with the	*/
      169   /***		reference name specified.  If the pathname given	*/
      170   /***		specifies an MSF, component 0 is initiated with	*/
      171   /***		the given refname.  If the validate switch is set	*/
      172   /***		the resultant segment is checked via object_info_	*/
      173   /***		to insure that it is in fact an object segment.	*/
      174   /***		The object segment is also checked to determine	*/
      175   /***		if it is a valid object MSF.  The pointer to the	*/
      176   /***		segment is returned if the thing in question ends	*/
      177   /***		up referring to an object segment regardless of	*/
      178   /***		conflicting information about it being an object	*/
      179   /***		MSF.					*/
      180   /***	Output:	targetp, count, msf_sw, code			*/
      181   /***							*/
      182   /*** ****************************************************************/
      183 
      184 
      185   no_clear_sw = false;
      186   goto INITIATE_JOIN;
      187 
      188 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      189 
      190 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      191 
      192 
      193 init_no_clear:
      194   entry (A_dname,			/** target dir name	    ( in)	*/
      195        A_ename,			/** target entryname    ( in)	*/
      196        A_refname,			/** target ref name	    ( in)	*/
      197        A_validate,			/** validate switch	    ( in) */
      198        A_targetp,			/** target pointer	    (out)	*/
      199        A_count,			/** bit count	    (out) */
      200        A_msf_sw,			/** MSF switch	    (out)	*/
      201        A_code);			/** error code	    (out)	*/
      202 
      203   /*** ****************************************************************/
      204   /***							*/
      205   /***	Name:	object_lib_$init_no_clear			*/
      206   /***	Input:	dname, ename, refname, validate		*/
      207   /***	Function:	the same as object_lib_$initiate except that	*/
      208   /***		term_$no_clear is called rather than		*/
      209   /***		term_$single_refname if the refname is already	*/
      210   /***		on another entry and must be terminated.  It is	*/
      211   /***		intended for use only by find_command_ who will	*/
      212   /***		take care of its associative memory itself.	*/
      213   /***	Output:	targetp, count, msf_sw, code			*/
      214   /***							*/
      215   /*** ****************************************************************/
      216 
      217   no_clear_sw = true;
      218   goto INITIATE_JOIN;
      219 
      220 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      221 
      222 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      223 
      224 
      225 INITIATE_JOIN:
      226   dname = A_dname;
      227   ename = A_ename;
      228   n_comp = 0;
      229   term_sw = false;
      230 
      231   A_code = 0;
      232   A_targetp = null;
      233   A_msf_sw = false;
      234   A_count = 0;
      235 
      236   /* try to initiate the segment/MSF */
      237 
      238   call hcs_$initiate_count (dname, ename, A_refname, bc, 0, targetp, ec);
      239 
      240   /* if the target is a directory, see if it is an MSF and try to	*/
      241   /* initiate component 0.					*/
      242 
      243   if ec = error_table_$dirseg
      244     then do;
      245       call hcs_$status_minf (dname, ename, 0, 0, n_comp, ec);
      246       if ec ^= 0
      247         then call exit (ec);
      248       if n_comp = 0
      249         then call exit (error_table_$dirseg);
      250       dname = pathname_ (dname, ename);
      251       ename = "0";
      252       call hcs_$initiate_count (dname, ename, A_refname, bc, 0, targetp, ec);
      253     end;
      254 
      255   /* if another segment already has that refname, terminate the	*/
      256   /* refname and retry the initiation.				*/
      257 
      258   if ec = error_table_$namedup
      259     then do;
      260       if no_clear_sw
      261         then call term_$no_clear (A_refname, ec);
      262         else call term_$single_refname (A_refname, ec);
      263       if ec ^= 0
      264         then call exit (ec);
      265       term_sw = true;
      266       call hcs_$initiate_count (dname, ename, A_refname, bc, 0, targetp, ec);
      267     end;
      268 
      269   /* if at this point we have a problem other than that the segment	*/
      270   /* is already known, we give up and return the code.		*/
      271 
      272   if ec = error_table_$segknown
      273     then ec = 0;
      274   else if ec ^= 0
      275     then call exit (ec);
      276 
      277   if A_validate
      278     then do;
      279 
      280       /* now we try to validate the target segment. */
      281 
      282       oi.version_number = object_info_version_2;
      283       call object_info_$brief (targetp, bc, addr (oi), ec);
      284 
      285       /* first see if it is an object at all */
      286 
      287       if ec ^= 0
      288         then call exit (ec);
      289 
      290       /* if we have gotten this far, we actually have an object so we	*/
      291       /* can legitimately return the pointer and bit count		*/
      292 
      293       A_targetp = targetp;
      294       A_count = bc;
      295 
      296       /* now we validate the status as a object MSF/segment */
      297 
      298       def_header_ptr = oi.defp;
      299       if definition_header.msf_map_relp ^= 0
      300         then do;
      301 
      302 	/* if the definition_header/msf_map say this thing is a MSF	*/
      303 	/* component, make sure the directory bit_count and the	*/
      304 	/* msf_map agree on how many components are here, as well	*/
      305 	/* as making sure that this component really is component 0	*/
      306 
      307 	msf_map_ptr = addrel (def_header_ptr,
      308 	     definition_header.msf_map_relp);
      309 	if msf_map.version ^= msf_map_version_1
      310 	  then A_msf_sw = false;
      311 	  else do;
      312 	    if (msf_map.component_count ^= n_comp) |
      313 	         (msf_map.my_component ^= 0)
      314 	      then call exit (error_table_$inconsistent_object_msf);
      315 	    A_msf_sw = true;
      316 	  end;
      317         end;
      318         else do;
      319 
      320 	/* if the definition_header says there is no msf_map, make	*/
      321 	/* sure we didn't find this thing through MSF indirection.	*/
      322 	/* (ie. in an MSF component.)				*/
      323 
      324 	if n_comp > 0
      325 	  then call exit (error_table_$inconsistent_object_msf);
      326 	A_msf_sw = false;
      327         end;
      328     end;
      329     else do;
      330       if n_comp > 0
      331         then A_msf_sw = true;
      332         else A_msf_sw = false;
      333       A_targetp = targetp;
      334       A_count = bc;
      335     end;
      336 
      337   /* if everything checks out, return the pointer and msf_switch. If	*/
      338   /* the no_clear_sw and term_sw are both set, return the error code	*/
      339   /* error_table_$namedup so that find_command_ will know to adjust	*/
      340   /* its associative memory.					*/
      341 
      342   if term_sw & no_clear_sw
      343     then call exit (error_table_$namedup);
      344     else call exit (0);
      345 
      346 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      347 
      348 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      349 
      350 
      351 get_component_info:
      352   entry (A_segp,			/** obejct segment ptr  (in )	*/
      353        A_areap,			/** area to allocate in (in ) */
      354        A_version_reqd,		/** version to return   (in ) */
      355        A_oi_type,			/** type of object_info (in ) */
      356        A_comp_infop,		/** component_info ptr  (out)	*/
      357        A_code);			/** error code	    (out) */
      358 
      359   /*** ****************************************************************/
      360   /***							*/
      361   /***	Name:	object_lib_$get_component_info		*/
      362   /***	Input:	segp, areap, version_reqd, oi_type		*/
      363   /***	Function:	given a pointer to an object segment or MSF	*/
      364   /***		component, initiate all of the components of the	*/
      365   /***		MSF and return various information about them.	*/
      366   /***	Output:	comp_infop, code				*/
      367   /***							*/
      368   /*** ****************************************************************/
      369 
      370   /* preset the return value */
      371 
      372   A_comp_infop = null;
      373 
      374   /* make sure the version requested is legitimate */
      375 
      376   if A_version_reqd ^= component_info_version_1
      377     then call exit (error_table_$unimplemented_version);
      378 
      379   /* get the area to allocate the return structure in */
      380 
      381   if A_areap = null
      382     then based_areap = get_system_free_area_ ();
      383     else based_areap = A_areap;
      384 
      385   /* get the bit count of the segment passed for the call to object_info_ */
      386 
      387   call hcs_$status_mins (A_segp, (0), bit_count, ec);
      388   if ec ^= 0
      389     then call exit (ec);
      390 
      391   /* get the section pointers and validate that this is an object seg */
      392 
      393   oi.version_number = object_info_version_2;
      394   if A_oi_type = "none" | A_oi_type = "brief"
      395     then info_ep = object_info_$brief;
      396   else if A_oi_type = "display"
      397     then info_ep = object_info_$display;
      398   else if A_oi_type = "long"
      399     then info_ep = object_info_$long;
      400   else call exit (error_table_$bad_arg);
      401 
      402   call info_ep (A_segp, bit_count, addr (oi), ec);
      403   if ec ^= 0
      404     then call exit (ec);
      405 
      406   /* see if we have an MSF component, a non-MSF returns a structure	*/
      407   /* with a single component entry and the msf flag false		*/
      408 
      409   dhp = oi.defp;
      410   if dh.msf_map_relp = 0
      411     then max_component = 0;
      412     else do;
      413       mmp = addrel (dhp, dh.msf_map_relp);
      414       if mm.version ^= msf_map_version_1
      415         then max_component = 0;
      416         else max_component = mm.component_count - 1;
      417     end;
      418 
      419   /* preset the structure pointer to remove cleanup error windows */
      420 
      421   comp_infop = null;
      422   c = -1;
      423 
      424   /* make sure the structure goes away if we abort */
      425 
      426   on cleanup
      427     begin;
      428     if comp_infop ^= null
      429       then do;
      430         do i = 0 to c;
      431 	if component_info.comp (c).segp ^= null
      432 	  then call hcs_$terminate_noname (component_info.comp (c).segp,
      433 		  (0));
      434         end;
      435         free component_info in (based_area);
      436       end;
      437   end;
      438 
      439   /* allocate the component info structure */
      440 
      441   allocate component_info in (based_area);
      442   component_info.version = A_version_reqd;
      443   component_info.flags.mbz = ""b;
      444   component_info.comp (*).mbz = ""b;
      445   component_info.comp (*).segp = null;
      446 
      447   if max_component = 0
      448     then do;
      449 
      450       /* if we have only 1 component (ie. a non-MSF), just copy the	*/
      451       /* info for the segment we were passed.			*/
      452 
      453       component_info.flags.msf = false;
      454       component_info.comp (0).segp = A_segp;
      455       component_info.comp (0).bc = bit_count;
      456       component_info.comp (0).info = oi;
      457     end;
      458     else do;
      459 
      460       /* if we have an MSF component, get the containing dir path and	*/
      461       /* initiate each of the other components.			*/
      462 
      463       component_info.flags.msf = true;
      464 
      465       call hcs_$fs_get_path_name (A_segp, dname, (0), ename, ec);
      466 
      467       do c = 0 to max_component;
      468         if c ^= mm.my_component
      469 	then do;
      470 
      471 	  /* if this isn't the component we were passed, generate	*/
      472 	  /* a name and try to initiate in the containing directory	*/
      473 
      474 	  ename = ltrim (char (c));
      475 	  call initiate_file_ (dname, ename, R_ACCESS,
      476 	       component_info.comp (c).segp,
      477 	       component_info.comp (c).bc, ec);
      478 
      479 	  /* if any other code was returned, free the structure and	*/
      480 	  /* complain that this MSF is broken.			*/
      481 
      482 	  if ec ^= 0
      483 	    then do;
      484 
      485 	      /* terminate all of the segments that we initiated	*/
      486 
      487 	      do i = 0 to c - 1;
      488 	        if component_info.comp (i).segp ^= null
      489 		   & i ^= mm.my_component
      490 		then call hcs_$terminate_noname (
      491 			component_info.comp (i).segp, (0));
      492 	      end;
      493 
      494 	      free component_info in (based_area);
      495 	      call exit (error_table_$inconsistent_object_msf);
      496 	    end;
      497 
      498 	  /* if the initiate was ok, try to get the object_info_ */
      499 
      500 	  if A_oi_type ^= "none"
      501 	    then do;
      502 	      component_info.comp (c).info.version_number =
      503 		 object_info_version_2;
      504 	      call info_ep (component_info.comp (c).segp,
      505 		 component_info.comp (c).bc,
      506 		 addr (component_info.comp (c).info), ec);
      507 	      if ec ^= 0
      508 	        then do;
      509 
      510 		/* terminate all the segments that we initiated	*/
      511 
      512 		do i = 0 to c;
      513 		  if component_info.comp (i).segp ^= null
      514 		       & i ^= mm.my_component
      515 		    then call hcs_$terminate_noname (
      516 			    component_info.comp (i).segp, 0);
      517 		end;
      518 
      519 		free component_info in (based_area);
      520 		call exit (ec);
      521 	        end;
      522 	    end;
      523 	    else unspec (component_info.comp (c).info) = ""b;
      524 
      525 	end;
      526 	else do;
      527 
      528 	  /* if this was the component he passed us, just fill in	*/
      529 	  /* the pointer and bit count 			*/
      530 
      531 	  component_info.comp (c).segp = A_segp;
      532 	  component_info.comp (c).bc = bit_count;
      533 	  if A_oi_type ^= "none"
      534 	    then component_info.comp (c).info = oi;
      535 	    else unspec (component_info.comp (c).info) = ""b;
      536 	end;
      537       end;
      538     end;
      539 
      540   /* everything worked so set the return pointer and return a 0 code */
      541 
      542   A_comp_infop = comp_infop;
      543 
      544   call exit (0);
      545 
      546 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      547 
      548 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      549 
      550 
      551 get_def_target:
      552   entry (A_segp,			/** segment to search   (in )	*/
      553        A_count,			/** segment bit count   (in ) */
      554        A_segname,			/** segname to find	    (in ) */
      555        A_offsetname,		/** offsetname to find  (in ) */
      556        A_live,			/** active/static	    (in ) */
      557        A_targetp,			/** target of def found (out) */
      558        A_code);			/** error code	    (out) */
      559 
      560   /*** ****************************************************************/
      561   /***							*/
      562   /***	Name:	object_lib_$get_def_target			*/
      563   /***	Input:	segp, count, segname, offsetname, live		*/
      564   /***	Function:	searches the given segment for the definition	*/
      565   /***		specified and return a pointer to the eventual	*/
      566   /***		target.  If the specified definition is an	*/
      567   /***		indirect definition, the pointer returned is the	*/
      568   /***		target of the indirection, not a pointer to the	*/
      569   /***		indirect link itself.  If the target of the	*/
      570   /***		definition is in the static or linkage sections,	*/
      571   /***		the live switch is used to determine whether the	*/
      572   /***		active version is used, or the static copy in the	*/
      573   /***		actual object segment.			*/
      574   /***	Output:	targetp, code				*/
      575   /***							*/
      576   /*** ****************************************************************/
      577 
      578   A_targetp = null;
      579 
      580   /* get the object info for the target segment */
      581 
      582   oi.version_number = object_info_version_2;
      583   call object_info_$brief (A_segp, A_count, addr (oi), ec);
      584   if ec ^= 0
      585     then call exit (ec);
      586 
      587   dhp = oi.defp;
      588 
      589   /* search for the definition */
      590 
      591   call get_definition_ (dhp, A_segname, A_offsetname, defp, ec);
      592   if ec ^= 0
      593     then call exit (ec);
      594 
      595   /* if the live switch is set, use the active linkage and static	*/
      596   /* pointers from the LOT and ISOT rather than the ones returned	*/
      597   /* by object_info_.					*/
      598 
      599   if A_live
      600     then do;
      601       call get_lp (A_segp, oi.linkp, oi.statp, ec);
      602       if ec ^= 0
      603         then call exit (ec);
      604     end;
      605 
      606   /* derive the target pointer of the definition. */
      607 
      608   if def.class = CLASS_TEXT
      609     then targetp = addrel (oi.textp, def.thing_relp);
      610   else if def.class = CLASS_LINKAGE
      611     then targetp = addrel (oi.linkp, def.thing_relp);
      612   else if def.class = CLASS_SYMBOL
      613     then targetp = addrel (oi.symbp, def.thing_relp);
      614   else if def.class = CLASS_STATIC
      615     then targetp = addrel (oi.statp, def.thing_relp);
      616   else call exit (error_table_$bad_class_def);
      617 
      618   /* if we are in an MSF transfer vector, indirect through the TV */
      619 
      620   if def.flags.indirect
      621     then do;
      622 
      623       /* make sure the definition target is a partial link */
      624 
      625       if def.class ^= CLASS_LINKAGE
      626         then call exit (error_table_$bad_indirect_def);
      627 
      628       /* if the live target was requested, return the value of the	*/
      629       /* snapped partial link.  Otherwise check to see if the target	*/
      630       /* is an unsnapped partial link.				*/
      631 
      632       if A_live
      633         then if targetp -> partial_link.tag ^= ITS_MODIFIER
      634 	     then call exit (error_table_$bad_indirect_def);
      635 	     else do;
      636 	       A_targetp = targetp -> based_ptr;
      637 	       call exit (0);
      638 	     end;
      639       else if targetp -> partial_link.tag ^= fault_tag_3
      640         then call exit (error_table_$bad_indirect_def);
      641       else ;
      642 
      643       /* get the pathname to find the target component */
      644 
      645       call hcs_$fs_get_path_name (targetp, dname, dnamel, ename, ec);
      646       if ec ^= 0
      647         then call exit (ec);
      648 
      649       comp = targetp -> partial_link.component;
      650       type = targetp -> partial_link.type;
      651       ename = ltrim (char (comp));
      652 
      653       /* initiate the target */
      654 
      655       call initiate_file_ (dname, ename, R_ACCESS, segp, bc, ec);
      656       if ec ^= 0
      657         then call exit (ec);
      658 
      659       call object_info_$brief (segp, bc, addr (oi), ec);
      660       if ec ^= 0
      661         then call exit (ec);
      662 
      663       /* apply the link offset to the appropriate section base */
      664 
      665       if type = CLASS_TEXT
      666         then targetp = addrel (segp, targetp -> partial_link.offset);
      667       else if type = CLASS_LINKAGE
      668         then targetp = addrel (oi.linkp, targetp -> partial_link.offset);
      669       else if type = CLASS_STATIC
      670         then targetp = addrel (oi.statp, targetp -> partial_link.offset);
      671       else if type = CLASS_SYMBOL
      672         then targetp = addrel (oi.symbp, targetp -> partial_link.offset);
      673       else call exit (error_table_$bad_indirect_def);
      674 
      675     end;
      676 
      677   A_targetp = targetp;
      678 
      679   call exit (0);
      680 
      681 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      682 
      683 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      684 
      685 
      686 get_lp:
      687   proc (segp,			/** segment pointer	    (in )	*/
      688        linkp,			/** linkage section ptr (out) */
      689        statp,			/** static section ptr  (out) */
      690        ec);			/** error code	    (out) */
      691 
      692   /*** ****************************************************************/
      693   /***							*/
      694   /***	Name:	get_lp					*/
      695   /***	Input:	segp					*/
      696   /***	Function:	gets the live linkage/static section pointers for	*/
      697   /***		the segment specified from the LOT/ISOT.  If the	*/
      698   /***		sections have not been copied, an error code is	*/
      699   /***		returned.					*/
      700   /***	Output:	linkp, statp, ec				*/
      701   /***							*/
      702   /*** ****************************************************************/
      703 
      704   /* parameters */
      705 
      706   dcl segp		ptr;
      707   dcl linkp		ptr;
      708   dcl statp		ptr;
      709   dcl ec			fixed bin (35);
      710 
      711   /* automatic */
      712 
      713   dcl seg_no		fixed bin;
      714 
      715   /* builtin */
      716 
      717   dcl segno		builtin;
      718   dcl stackbaseptr		builtin;
      719   dcl unspec		builtin;
      720 
      721   /* get the lot and isot pointers from the stack header */
      722 
      723   sb = stackbaseptr ();
      724   lotp = stack_header.lot_ptr;
      725   isotp = stack_header.isot_ptr;
      726 
      727   /* get the segment number for the segment we want */
      728 
      729   seg_no = segno (segp);
      730   
      731   /* make sure the lot is big enough */
      732   
      733   if seg_no > stack_header.cur_lot_size
      734     then do;
      735       ec = error_table_$nolinkag;
      736       return;
      737     end;
      738     
      739   /* make sure there is a lot entry */
      740 
      741   if unspec (lot.lp (seg_no)) = lot_fault
      742     then do;
      743       ec = error_table_$nolinkag;
      744       return;
      745     end;
      746 
      747   /* extract the pointers from the lot and isot */
      748 
      749   linkp = lot.lp (seg_no);
      750   statp = isot.isp (seg_no);
      751 
      752   end get_lp;
      753 
      754 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      755 
      756 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      757 
      758 
      759 exit:
      760   proc (ec);			/** error code	    (in )	*/
      761 
      762   /*** ****************************************************************/
      763   /***							*/
      764   /***	Name:	exit					*/
      765   /***	Input:	ec					*/
      766   /***	Function:	returns from object_lib_ returning the		*/
      767   /***		supplied error code.			*/
      768   /***	Output:	none					*/
      769   /***							*/
      770   /*** ****************************************************************/
      771 
      772   /* parameters */
      773 
      774   dcl ec			fixed bin (35);
      775 
      776   A_code = ec;
      777   goto EXIT;
      778 
      779   end exit;
      780 
      781 EXIT:
      782   return;
      783 
      784 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      785 
      786 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      787 
      788 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      789 
  2     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  2     8*     definition header, declare the msf_map, and add structures and constants
  2     9*     for deferred initialization.
  2    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  2    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  2    12*     added the structures for pointer initialization. pointer_init_template.
  2    13*     changed list_template_entry
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 
  2    17 /* Modified:  */
  2    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  2    19 /*	after unused half-word instead of before it. */
  2    20 /*   1 March 1983 by M. Weaver to add list template init type */
  2    21 
  2    22 /* format: style3,idind25 */
  2    23 /* everything for the definition section */
  2    24 
  2    25 declare	(
  2    26 	CLASS_TEXT	     init (0),		/* text section definition */
  2    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  2    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  2    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  2    30 	CLASS_STATIC	     init (4),		/* static section definition */
  2    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  2    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  2    33 	)		     fixed bin (3) unsigned internal static options (constant);
  2    34 
  2    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  2    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  2    37 
  2    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  2    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  2    40 			     options (constant);
  2    41 
  2    42 declare	1 definition_flags	     unaligned based,
  2    43 	  2 new		     bit (1),		/* should be "1"b */
  2    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  2    45 	  2 entry		     bit (1),		/* can tra here */
  2    46 	  2 retain	     bit (1),		/* binder respects this */
  2    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  2    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  2    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  2    50 	  2 unused	     bit (8);		/* Must be zero */
  2    51 
  2    52 
  2    53 
  2    54 
  2    55 /* Header of the definition section */
  2    56 
  2    57 declare	def_header_ptr	     pointer;
  2    58 declare	1 definition_header	     aligned based (def_header_ptr),
  2    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  2    60 						/* first definition, reloc def18 */
  2    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  2    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  2    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  2    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  2    65 	  2 flags		     unaligned like definition_flags;
  2    66 						/* both new and ignore must be "1"b here */
  2    67 
  2    68 /* A non class=3 definition. See segname_definition below for class=3 */
  2    69 
  2    70 
  2    71 declare	def_ptr		     pointer;
  2    72 declare	1 definition	     aligned based (def_ptr),
  2    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    74 						/* offset of next def */
  2    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    76 						/* offset of previous def */
  2    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  2    78 						/* offset in section specified by class of thing this defines */
  2    79 	  2 flags		     unaligned like definition_flags,
  2    80 	  2 class		     unal fixed bin (3) unsigned,
  2    81 						/* Type of definition */
  2    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  2    83 						/* offset of ACC for symbol */
  2    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  2    85 						/* offset of segname def to which this belongs */
  2    86 
  2    87 /* Class=3, segname definition */
  2    88 
  2    89 declare	segname_ptr	     pointer;
  2    90 declare	1 segname_definition     aligned based (segname_ptr),
  2    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    92 						/* offset of next def */
  2    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    94 						/* offset of previous def */
  2    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  2    96 						/* offset of next segname def */
  2    97 	  2 flags		     unaligned like definition_flags,
  2    98 	  2 class		     unal fixed bin (3) unsigned,
  2    99 						/* 3 for segname */
  2   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  2   101 						/* offset of ACC for symbol */
  2   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  2   103 						/* see following : */
  2   104 
  2   105 /* Definition blocks are chained off of segname definitions.
  2   106*   segname_definition.first_relp is one of three things:
  2   107*    (1) the def section offset of the first ordinary (class^=3) definition
  2   108*      belonging to this segname block. In the case where there are more than
  2   109*      one segname's on a block, all their first_relp will point
  2   110*      to the same place.
  2   111*
  2   112*    (2) if there are no ordinary definitions associated with this segname,
  2   113*      then it is the def section offset of the next segname. 
  2   114*
  2   115*    (3) if there are no ordinary definitions in the block, and it
  2   116*      is the last block, then it points to a word containing 0.
  2   117*
  2   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  2   119*   pointing to a class=3 definition whose first_relp is not the same as
  2   120*   the current definitions first_relp.
  2   121**/
  2   122 
  2   123 /* All the definitions are linked through the forward and
  2   124*   backward thread variables. The end of the chain can is indicated
  2   125*   by forward pointing to a zero word. */
  2   126 
  2   127 
  2   128 declare	exp_ptr		     pointer;
  2   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  2   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  2   131 						/* pointer (rel to defs) of type pair structure */
  2   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  2   133 
  2   134 declare	(
  2   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  2   136 						/* which section determined by segname_relp */
  2   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  2   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  2   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  2   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  2   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  2   142 	SECTION_TEXT	     init (0),		/* *text */
  2   143 	SECTION_LINK	     init (1),		/* *link */
  2   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  2   145 	SECTION_UNUSED	     init (3),		/* reserved */
  2   146 	SECTION_STATIC	     init (4),		/* *static */
  2   147 	SECTION_SYSTEM	     init (5),		/* *system */
  2   148 	SECTION_HEAP	     init (6)		/* *heap */
  2   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  2   150 
  2   151 /* use CLASS_NAMES for section names */
  2   152 
  2   153 declare	LINK_TYPE_NAMES	     (1:6)
  2   154 			     init ("absolute in section", "unused", "absolute off of refname",
  2   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  2   156 			     character (32) varying internal static options (constant);
  2   157 
  2   158 
  2   159 declare	type_ptr		     pointer;
  2   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  2   161 	  2 type		     fixed bin (18) unsigned unal,
  2   162 						/* see above */
  2   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  2   164 						/* pointer (rel to defs) to the trap word */
  2   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  2   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  2   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  2   168* /*or section code for SELF links */
  2   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  2   170 						/* for OFFSETNAME links, ACC string of name of location. */
  2   171 						/* for others, must be ZERO */
  2   172 
  2   173 
  2   174 /* Link Trap Pair */
  2   175 
  2   176 declare	link_trap_ptr	     pointer;
  2   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  2   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  2   179 						/* LINK18, link to thing to call */
  2   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  2   181 						/* LINK18, link to argument list */
  2   182 
  2   183 
  2   184 /* initialization info for *system or *heap link */
  2   185 
  2   186 
  2   187 /* NOTE --------------------------------------------------
  2   188*   the following structures defining initialization information are also
  2   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  2   190*   and should be kept equivalent
  2   191*   -------------------------------------------------------
  2   192**/
  2   193 
  2   194 declare	(
  2   195 	INIT_NO_INIT	     init (0),
  2   196 	INIT_COPY_INFO	     init (3),
  2   197 	INIT_DEFINE_AREA	     init (4),
  2   198 	INIT_LIST_TEMPLATE	     init (5),
  2   199 	INIT_DEFERRED	     init (6)
  2   200 	)		     fixed bin internal static options (constant);
  2   201 
  2   202 /* for type = 0 or 4 */
  2   203 
  2   204 declare	link_init_ptr	     pointer;
  2   205 declare	1 link_init	     aligned based (link_init_ptr),
  2   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  2   207 	  2 type		     fixed bin;		/* see types above */
  2   208 
  2   209 /* for type=3, there is data to copy */
  2   210 
  2   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  2   212 	  2 header	     aligned like link_init,
  2   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  2   214 
  2   215 declare	link_init_n_words	     fixed bin;
  2   216 
  2   217 /* for type = 5, there is a list template to copy */
  2   218 
  2   219 declare	1 link_init_list_template
  2   220 			     aligned based (link_init_ptr),
  2   221 	  2 header	     aligned like link_init,
  2   222 	  2 pad		     bit (18) unaligned,
  2   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  2   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  2   225 
  2   226 declare	link_init_n_words_in_list
  2   227 			     fixed bin;
  2   228 
  2   229 /* A list template consists of a series of entries with the following
  2   230*   description, concatenated together.  n_bits and datum are bit items,
  2   231*   to permit a wide range of inputs.
  2   232*
  2   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2   235*
  2   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2   237*   of their particular storage section. */
  2   238 
  2   239 declare	1 list_template_entry    aligned based,
  2   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2   244 						/* number of times to repeat datum */
  2   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  2   246 
  2   247 
  2   248 /* the pointer_init_template represents the initialization information
  2   249*   for ITS and packed pointers.  Both pointer types require the entire
  2   250*   72 bit structure.
  2   251**/
  2   252 
  2   253 dcl       1 pointer_init_template  based,
  2   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  2   257 	  2 mbz		     bit (12) unaligned,
  2   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  2   259 
  2   260 
  2   261 declare	link_init_n_bits_in_datum
  2   262 			     fixed bin (35);
  2   263 
  2   264 /* for type = 6, the init_info resides in another MSF component */
  2   265 /* target_relp is a linkage section offset to a partial link to */
  2   266 /* the base of the linkage section of the component containing  */
  2   267 /* the actual init_info. link_relp is the offset of the actual  */
  2   268 /* link within that linkage section.			    */
  2   269 
  2   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  2   271 	  2 header	     aligned like link_init,
  2   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  2   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  2   274 
  2   275 /* Definition section hash table */
  2   276 
  2   277 declare	def_ht_ptr	     pointer;
  2   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  2   279 	  2 n_entries	     fixed bin,
  2   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  2   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   282 	    3 unused	     bit (18) unaligned;
  2   283 
  2   284 declare	def_ht_n_entries	     fixed bin;
  2   285 
  2   286 
  2   287 /* Component name ht */
  2   288 declare	comp_ht_ptr	     pointer;
  2   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  2   290 	  2 n_entries	     fixed bin,
  2   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  2   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   293 						/* hashed segname */
  2   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   295 						/* first segname def of block containing def_relp */
  2   296 
  2   297 declare	comp_ht_n_entries	     fixed bin;
  2   298 
  2   299 /* Duplicate name table */
  2   300 
  2   301 declare	dup_table_ptr	     pointer;
  2   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  2   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  2   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  2   305 						/* n in table */
  2   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  2   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   309 
  2   310 declare	dup_table_n_names	     fixed bin;
  2   311 
  2   312 /* The msf_map is found in the definition section of an	*/
  2   313 /* object MSF component.  It is used by the linker to	*/
  2   314 /* determine whether a segment is a component of an object	*/
  2   315 /* MSF or a standard single-segment object.		*/
  2   316   
  2   317   dcl msf_map_ptr		ptr;
  2   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  2   319        02 version		char (8),
  2   320        02 component_count	fixed bin (15) unsigned,
  2   321        02 my_component	fixed bin (15) unsigned;
  2   322   
  2   323   dcl msf_map_version_1	char (8) static options (constant)
  2   324 			     init ("msfmp1.0");
  2   325   
  2   326 declare	acc_string_ptr	     pointer;
  2   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  2   328 	  2 count		     fixed bin (9) unsigned unaligned,
  2   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  2   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  2   331 						/* unspec (acc_string) = ""b to zero out */
  2   332 						/* the last word, if the string is not of length 0mod4 */
  2   333 
  2   334 declare	acc_string_length	     fixed bin (21);
  2   335 
  2   336 
  2   337 /* end include file definitions_dcls.incl.pl1 */
      790 
  3     1 /* BEGIN INCLUDE FILE its.incl.pl1
  3     2*   modified 27 July 79 by JRDavis to add its_unsigned
  3     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  3     4 
  3     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  3     6     2 pad1 bit (3) unaligned,
  3     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  3     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  3     9     2 pad2 bit (9) unaligned,
  3    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  3    11 
  3    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  3    13     2 pad3 bit (3) unaligned,
  3    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  3    15     2 pad4 bit (3) unaligned,
  3    16     2 mod bit (6) unaligned;				/* further modification */
  3    17 
  3    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  3    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  3    20     2 pad1 bit (27) unaligned,
  3    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  3    22 
  3    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  3    24     2 pad2 bit (3) unaligned,
  3    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  3    26     2 pad3 bit (3) unaligned,
  3    27     2 mod bit (6) unaligned;				/* further modification */
  3    28 
  3    29 
  3    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  3    31     2 pad1 bit (3) unaligned,
  3    32     2 segno fixed bin (15) unsigned unaligned,
  3    33     2 ringno fixed bin (3) unsigned unaligned,
  3    34     2 pad2 bit (9) unaligned,
  3    35     2 its_mod bit (6) unaligned,
  3    36 
  3    37     2 offset fixed bin (18) unsigned unaligned,
  3    38     2 pad3 bit (3) unaligned,
  3    39     2 bit_offset fixed bin (6) unsigned unaligned,
  3    40     2 pad4 bit (3) unaligned,
  3    41     2 mod bit (6) unaligned;
  3    42 
  3    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  3    44     2 pr_no fixed bin (3) unsigned unaligned,
  3    45     2 pad1 bit (27) unaligned,
  3    46     2 itp_mod bit (6) unaligned,
  3    47 
  3    48     2 offset fixed bin (18) unsigned unaligned,
  3    49     2 pad2 bit (3) unaligned,
  3    50     2 bit_offset fixed bin (6) unsigned unaligned,
  3    51     2 pad3 bit (3) unaligned,
  3    52     2 mod bit (6) unaligned;
  3    53 
  3    54 
  3    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  3    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  3    57 
  3    58 /* END INCLUDE FILE   its.incl.pl1 */
      791 
  4     1 /*  START OF:	object_lib_defs.incl.pl1		 *  *  *  *  *  */
  4     2 
  4     3   
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  4     6*     audit(86-10-03,DGHowe), install(86-11-20,MR12.0-1222):
  4     7*     Written to define structure returned by object_lib_$get_component_info.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10   /********************************************************************/
  4    11   /*							*/
  4    12   /*	Name:	object_lib_defs				*/
  4    13   /*							*/
  4    14   /*	Function:	This include file defines constants & structures	*/
  4    15   /*		used and returned by the object_lib_ subroutines.	*/
  4    16   /*							*/
  4    17   /********************************************************************/
  4    18   
  4    19   dcl 01 component_info	aligned based (comp_infop),
  4    20        02 version		char (8),
  4    21        02 flags		aligned,
  4    22         03 msf		bit (1) unaligned,
  4    23         03 mbz		bit (35) unaligned,
  4    24        02 max		fixed bin,
  4    25        02 comp		(0:max_component refer (component_info.max)),
  4    26         03 segp		ptr,
  4    27         03 bc		fixed bin (24),
  4    28         03 mbz		bit (36),
  4    29         03 info		like object_info;
  4    30   
  4    31   dcl comp_infop		ptr;
  4    32   dcl max_component		fixed bin;
  4    33   dcl component_info_version_1
  4    34 			char (8) static options (constant)
  4    35 			init ("cinfo1.0");
  4    36   
  4    37 /*  END OF:	object_lib_defs.incl.pl1		  *  *  *  *  *  */
      792 
  5     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  5     2*coded February 8, 1972 by Michael J. Spier	*/
  5     3 /* modified May 26, 1972 by M. Weaver */
  5     4 /* modified 15 April, 1975 by M. Weaver */
  5     5 
  5     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  5     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  5     8 	2 textp pointer,			/* pointer to beginning of text section */
  5     9 	2 defp pointer,			/* pointer to beginning of definition section */
  5    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  5    11 	2 statp pointer,			/* pointer to beginning of static section */
  5    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  5    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  5    14 	2 tlng fixed bin,			/* length in words of text section */
  5    15 	2 dlng fixed bin,			/* length in words of definition section */
  5    16 	2 llng fixed bin,			/* length in words of linkage section */
  5    17 	2 ilng fixed bin,			/* length in words of static section */
  5    18 	2 slng fixed bin,			/* length in words of symbol section */
  5    19 	2 blng fixed bin,			/* length in words of break map */
  5    20 	2 format,				/* word containing bit flags about object type */
  5    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  5    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  5    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  5    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  5    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  5    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  5    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  5    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  5    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  5    30 	  3 pad bit(27) unaligned,
  5    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  5    32 	2 textlinkp pointer,		/* ptr to first link in text */
  5    33 
  5    34 	/* LIMIT OF BRIEF STRUCTURE */
  5    35 
  5    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  5    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  5    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  5    39 	2 cvers aligned,			/* generator version name in printable char string form */
  5    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  5    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  5    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  5    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  5    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  5    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  5    46 
  5    47 	/* LIMIT OF DISPLAY STRUCTURE */
  5    48 
  5    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  5    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  5    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  5    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  5    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  5    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  5    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  5    56 					/* currently not used by system */
  5    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  5    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  5    59 
  5    60 declare	object_info_version_2 fixed bin int static init(2);
  5    61 
  5    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      793 
  6     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  6     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  6     7*     Modified to add partial_link structure for an object MSF partially snapped
  6     8*     link.
  6     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  6    10*     install(86-11-20,MR12.0-1222):
  6    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 /* format: style3 */
  6    16 /* everything you ever wanted in a linkage section */
  6    17 
  6    18 /*
  6    19* Last Modified (Date and Reason):
  6    20*  15 Nov 1971 by C Garman 
  6    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  6    22*   6/75 by S.Webber to comment existing structures better
  6    23*   9/77 by M. Weaver to add run_depth to link
  6    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  6    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  6    26**/
  6    27 
  6    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  6    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  6    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  6    31 	  2 mbz		bit (6) unal,
  6    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  6    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  6    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  6    35 	  2 mbz2		bit (12) unal,
  6    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    37 
  6    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  6    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  6    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  6    41 	  2 mbz1		bit (12) unal,
  6    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  6    43 	  
  6    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  6    45 	  2 mbz2		bit (3) unal,
  6    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  6    47 	  2 mbz3		bit (3) unal,
  6    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    49 
  6    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  6    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  6    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  6    53 	  2 original_linkage_ptr
  6    54 			ptr unal,			/* pointer to linkage section in object segment */
  6    55 	  2 unused	bit (72),
  6    56 	  2 stats,
  6    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  6    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  6    59 	    3 segment_number
  6    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  6    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  6    62 
  6    63 declare	1 linkage_header_flags
  6    64 			aligned based,		/* overlay of def_ptr for flags */
  6    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  6    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  6    67 	  2 perprocess_static
  6    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  6    69 	  2 pad2		bit (6) unaligned;
  6    70 
  6    71 declare	1 virgin_linkage_header
  6    72 			aligned based,		/* template for linkage header in object segment */
  6    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  6    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  6    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  6    76 						/* offset of definition section */
  6    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  6    78 						/* offset of trap-at-first-reference offset array */
  6    79 	  2 filled_in_later bit (144),
  6    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  6    81 						/* offset of first link */
  6    82 	  2 linkage_section_lng
  6    83 			fixed bin (18) unsigned unaligned,
  6    84 						/* length of linkage section */
  6    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  6    86 						/* will be segment number of copied linkage */
  6    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  6    88 						/* length of static section */
  6    89 
  6    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  6    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  6    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  6    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  6    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  6    95 						/* LINK18, offset of link defining procedure to call */
  6    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  6    97 						/* LINK18, offser of link defining argument list for trap proc */
  6    98 
  6    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  6   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  6   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  6   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  6   103 
  6   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      794 
  7     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  7     2 /* modified by M. Weaver 3/77 */
  7     3 
  7     4 dcl  lotp ptr;
  7     5 
  7     6 dcl 1 lot based (lotp) aligned,
  7     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  7     8 
  7     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  7    10 						/* lot fault has fault code = 0 and offset = 0 */
  7    11 
  7    12 dcl  isotp ptr;
  7    13 dcl 1 isot based (isotp) aligned,
  7    14     2 isp (0:9999) ptr unaligned;
  7    15 
  7    16 dcl 1 isot1 (0 :9999) aligned based,
  7    17     2 flags unaligned,
  7    18       3 fault bit (2) unaligned,
  7    19       3 system bit (1) unaligned,
  7    20       3 mbz bit (6) unaligned,
  7    21     2 fault_code fixed bin (8) unaligned,
  7    22     2 static_offset bit (18) unaligned;
  7    23 
  7    24 
  7    25 /* END INCLUDE FILE  lot.incl.pl1 */
      795 
  8     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  8     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  8     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  8     4 /*	Modified April 1983 by C. Hornig for tasking */
  8     5 
  8     6 /****^  HISTORY COMMENTS:
  8     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  8     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  8     9*     added the heap_header_ptr definition.
  8    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  8    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  8    12*     Modified to support control point management.  These changes were actually
  8    13*     made in February 1985 by G. Palter.
  8    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  8    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  8    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  8    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  8    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  8    19*     (ITS pair).
  8    20*                                                   END HISTORY COMMENTS */
  8    21 
  8    22 /* format: style2 */
  8    23 
  8    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  8    25 
  8    26      dcl	   1 stack_header	      based (sb) aligned,
  8    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  8    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  8    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  8    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  8    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  8    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  8    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  8    34 	     2 pad4	      bit (2) unal,
  8    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  8    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  8    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  8    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  8    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  8    40 	     2 null_ptr	      ptr,		/*  (16)  */
  8    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  8    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  8    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  8    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  8    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  8    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  8    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  8    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  8    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  8    50 	     2 return_no_pop_op_ptr
  8    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  8    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  8    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  8    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  8    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  8    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  8    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  8    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  8    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  8    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  8    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  8    62 	     2 trace,
  8    63 	       3 frames,
  8    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  8    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  8    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  8    67 	     2 pad2	      bit (36),		/*  (61) */
  8    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  8    69 
  8    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  8    71 
  8    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  8    73 						/* (551) octal */
  8    74 
  8    75 
  8    76 /*	The following constants are offsets within this transfer vector table.  */
  8    77 
  8    78      dcl	   (
  8    79 	   call_offset	      fixed bin init (271),
  8    80 	   push_offset	      fixed bin init (272),
  8    81 	   return_offset	      fixed bin init (273),
  8    82 	   return_no_pop_offset   fixed bin init (274),
  8    83 	   entry_offset	      fixed bin init (275)
  8    84 	   )		      internal static;
  8    85 
  8    86 
  8    87 
  8    88 
  8    89 
  8    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  8    91*	move the whole stack header should use this overlay.
  8    92**/
  8    93 
  8    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  8    95 
  8    96 
  8    97 
  8    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      796 
      797 
      798   end object_lib_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.2  object_lib_.pl1                   >spec>install>1110>object_lib_.pl1
789          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
790          2    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
791          3    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
792          4    11/24/86  1226.9  object_lib_defs.incl.pl1          >ldd>include>object_lib_defs.incl.pl1
793          5    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
794          6    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
795          7    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
796          8    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_areap                                parameter       pointer                  dcl 41 ref 351 381 383
A_code                                 parameter       fixed bin(35,0)          dcl 42 set ref 153 193 231* 351 551 776*
A_comp_infop                           parameter       pointer                  dcl 43 set ref 351 372* 542*
A_count                                parameter       fixed bin(24,0)          dcl 44 set ref 153 193 234* 294* 334* 551 583*
A_dname                                parameter       char                     packed unaligned dcl 45 ref 153 193 225
A_ename                                parameter       char                     packed unaligned dcl 46 ref 153 193 227
A_live                                 parameter       bit(1)                   packed unaligned dcl 47 ref 551 599 632
A_msf_sw                               parameter       bit(1)                   packed unaligned dcl 56 set ref 153 193 233* 309*
                                                                                  315* 326* 330* 332*
A_offsetname                           parameter       char                     packed unaligned dcl 48 set ref 551 591*
A_oi_type                              parameter       char                     packed unaligned dcl 49 ref 351 394 394 396 398 500
                                                                                  533
A_refname                              parameter       char                     packed unaligned dcl 50 set ref 153 193 238* 252*
                                                                                  260* 262* 266*
A_segname                              parameter       char                     packed unaligned dcl 51 set ref 551 591*
A_segp                                 parameter       pointer                  dcl 52 set ref 351 387* 402* 454 465* 531 551 583*
                                                                                  601*
A_targetp                              parameter       pointer                  dcl 53 set ref 153 193 232* 293* 333* 551 578* 636*
                                                                                  677*
A_validate                             parameter       bit(1)                   packed unaligned dcl 54 ref 153 193 277
A_version_reqd                         parameter       char(8)                  packed unaligned dcl 55 ref 351 376 442
CLASS_LINKAGE                          constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 610 625 667
CLASS_STATIC                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 614 669
CLASS_SYMBOL                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 612 671
CLASS_TEXT                             constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 608 665
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 3-55 ref 632
R_ACCESS                        000004 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 475* 655*
addr                                                   builtin function         dcl 141 ref 283 283 402 402 504 504 583 583 659 659
addrel                                                 builtin function         dcl 142 ref 307 413 608 610 612 614 665 667 669 671
based_area                             based           area(1024)               dcl 104 ref 435 441 494 519
based_areap                     000100 automatic       pointer                  dcl 112 set ref 381* 383* 435 441 494 519
based_ptr                              based           pointer                  dcl 105 ref 636
bc                              000102 automatic       fixed bin(24,0)          dcl 113 in procedure "object_lib_" set ref 238* 252*
                                                                                  266* 283* 294 334 655* 659*
bc                        6            based           fixed bin(24,0)          array level 3 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_" set ref 455* 475* 504*
                                                                                  532*
bit_count                       000103 automatic       fixed bin(24,0)          dcl 114 set ref 387* 402* 455 532
c                               000104 automatic       fixed bin(17,0)          dcl 115 set ref 422* 430 431 431 467* 468 474 475
                                                                                  475 487 502 504 504 504 504 512 523 531 532 533
                                                                                  535*
char                                                   builtin function         dcl 143 ref 474 651
class                     1(33)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 106 ref
                                                                                  608 610 612 614 625
cleanup                         000304 stack reference condition                dcl 137 ref 426
comp                            000105 automatic       fixed bin(17,0)          dcl 116 in procedure "object_lib_" set ref 649* 651
comp                      4            based           structure                array level 2 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_"
comp_infop                      000316 automatic       pointer                  dcl 4-31 set ref 421* 428 431 431 435 441* 442 443
                                                                                  444 445 453 454 455 456 463 475 475 488 488 494
                                                                                  502 504 504 504 504 513 513 519 523 531 532 533
                                                                                  535 542
component                 0(03)        based           fixed bin(15,0)          level 2 packed packed unsigned unaligned dcl 6-38
                                                                                  ref 649
component_count           2            based           fixed bin(15,0)          level 2 in structure "msf_map" unsigned dcl 2-318
                                                                                  in procedure "object_lib_" ref 312
component_count           2            based           fixed bin(15,0)          level 2 in structure "mm" unsigned dcl 108
                                                                                  in procedure "object_lib_" ref 416
component_info                         based           structure                level 1 dcl 4-19 set ref 435 441 494 519
component_info_version_1        000000 constant        char(8)                  initial packed unaligned dcl 4-33 ref 376
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-26 ref 733
def                                    based           structure                level 1 dcl 106
def_header_ptr                  000312 automatic       pointer                  dcl 2-57 set ref 298* 299 307 307
definition                             based           structure                level 1 dcl 2-72
definition_flags                       based           structure                level 1 packed packed unaligned dcl 2-42
definition_header                      based           structure                level 1 dcl 2-58
defp                      4     000210 automatic       pointer                  level 2 in structure "oi" dcl 129 in procedure
                                                                                  "object_lib_" set ref 298 409 587
defp                            000106 automatic       pointer                  dcl 117 in procedure "object_lib_" set ref 591* 608
                                                                                  608 610 610 612 612 614 614 620 625
dh                                     based           structure                level 1 dcl 107
dhp                             000110 automatic       pointer                  dcl 118 set ref 409* 410 413 413 587* 591*
dname                           000112 automatic       char(168)                packed unaligned dcl 119 set ref 225* 238* 245* 250*
                                                                                  250* 252* 266* 465* 475* 645* 655*
dnamel                          000164 automatic       fixed bin(17,0)          dcl 120 set ref 645*
ec                                     parameter       fixed bin(35,0)          dcl 774 in procedure "exit" ref 759 776
ec                              000165 automatic       fixed bin(35,0)          dcl 121 in procedure "object_lib_" set ref 238* 243
                                                                                  245* 246 246* 252* 258 260* 262* 263 263* 266* 272
                                                                                  272* 274 274* 283* 287 287* 387* 388 388* 402* 403
                                                                                  403* 465* 475* 482 504* 507 520* 583* 584 584*
                                                                                  591* 592 592* 601* 602 602* 645* 646 646* 655* 656
                                                                                  656* 659* 660 660*
ec                                     parameter       fixed bin(35,0)          dcl 709 in procedure "get_lp" set ref 686 735* 743*
ename                           000166 automatic       char(32)                 packed unaligned dcl 122 set ref 227* 238* 245* 250*
                                                                                  251* 252* 266* 465* 474* 475* 645* 651* 655*
error_table_$bad_arg            000044 external static fixed bin(35,0)          dcl 88 set ref 400*
error_table_$bad_class_def      000046 external static fixed bin(35,0)          dcl 89 set ref 616*
error_table_$bad_indirect_def   000050 external static fixed bin(35,0)          dcl 91 set ref 625* 632* 639* 673*
error_table_$dirseg             000052 external static fixed bin(35,0)          dcl 93 set ref 243 248*
error_table_$inconsistent_object_msf
                                000054 external static fixed bin(35,0)          dcl 94 set ref 312* 324* 495*
error_table_$namedup            000056 external static fixed bin(35,0)          dcl 96 set ref 258 342*
error_table_$nolinkag           000060 external static fixed bin(35,0)          dcl 97 ref 735 743
error_table_$segknown           000062 external static fixed bin(35,0)          dcl 98 ref 272
error_table_$unimplemented_version
                                000064 external static fixed bin(35,0)          dcl 99 set ref 376*
false                                  constant        bit(1)                   initial packed unaligned dcl 35 ref 185 229 233 309
                                                                                  326 332 453
fault_tag_3                            constant        bit(6)                   initial packed unaligned dcl 37 ref 639
flags                     1(18)        based           structure                level 2 in structure "def" packed packed unaligned
                                                                                  dcl 106 in procedure "object_lib_"
flags                     2            based           structure                level 2 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_"
get_definition_                 000010 constant        entry                    external dcl 60 ref 591
get_system_free_area_           000012 constant        entry                    external dcl 62 ref 381
hcs_$fs_get_path_name           000014 constant        entry                    external dcl 63 ref 465 645
hcs_$initiate_count             000016 constant        entry                    external dcl 65 ref 238 252 266
hcs_$status_minf                000020 constant        entry                    external dcl 68 ref 245
hcs_$status_mins                000022 constant        entry                    external dcl 71 ref 387
hcs_$terminate_noname           000024 constant        entry                    external dcl 73 ref 431 488 513
i                               000176 automatic       fixed bin(17,0)          dcl 123 set ref 430* 487* 488 488 488* 512* 513 513
                                                                                  513*
indirect                  1(24)        based           bit(1)                   level 3 packed packed unaligned dcl 106 ref 620
info                     10            based           structure                array level 3 dcl 4-19 set ref 456* 504 504 523*
                                                                                  533* 535*
info_ep                         000200 automatic       entry variable           dcl 124 set ref 394* 396* 398* 402 504
initiate_file_                  000026 constant        entry                    external dcl 74 ref 475 655
isot                                   based           structure                level 1 dcl 7-13
isot_ptr                 52            based           pointer                  level 2 dcl 8-26 ref 725
isotp                           000324 automatic       pointer                  dcl 7-12 set ref 725* 750
isp                                    based           pointer                  array level 2 packed packed unaligned dcl 7-13 ref
                                                                                  750
link_init                              based           structure                level 1 dcl 2-205
linkp                     6     000210 automatic       pointer                  level 2 in structure "oi" dcl 129 in procedure
                                                                                  "object_lib_" set ref 601* 610 667
linkp                                  parameter       pointer                  dcl 707 in procedure "get_lp" set ref 686 749*
lot                                    based           structure                level 1 dcl 7-6
lot_fault                              constant        bit(36)                  initial dcl 7-9 ref 741
lot_ptr                  26            based           pointer                  level 2 dcl 8-26 ref 724
lotp                            000322 automatic       pointer                  dcl 7-4 set ref 724* 741 749
lp                                     based           pointer                  array level 2 packed packed unaligned dcl 7-6 ref
                                                                                  741 749
ltrim                                                  builtin function         dcl 144 ref 474 651
max                       3            based           fixed bin(17,0)          level 2 dcl 4-19 set ref 435 441* 444 445 494 519
max_component                   000320 automatic       fixed bin(17,0)          dcl 4-32 set ref 410* 414* 416* 441 441 447 467
mbz                       7            based           bit(36)                  array level 3 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_" set ref 444*
mbz                       2(01)        based           bit(35)                  level 3 in structure "component_info" packed packed
                                                                                  unaligned dcl 4-19 in procedure "object_lib_" set
                                                                                  ref 443*
mm                                     based           structure                level 1 dcl 108
mmp                             000204 automatic       pointer                  dcl 126 set ref 413* 414 416 468 488 513
msf                       2            based           bit(1)                   level 3 packed packed unaligned dcl 4-19 set ref
                                                                                  453* 463*
msf_map                                based           structure                level 1 dcl 2-318
msf_map_ptr                     000314 automatic       pointer                  dcl 2-317 set ref 307* 309 312 312
msf_map_relp              0(18)        based           fixed bin(18,0)          level 2 in structure "definition_header" packed
                                                                                  packed unsigned unaligned dcl 2-58 in procedure
                                                                                  "object_lib_" ref 299 307
msf_map_relp              0(18)        based           fixed bin(18,0)          level 2 in structure "dh" packed packed unsigned
                                                                                  unaligned dcl 107 in procedure "object_lib_" ref
                                                                                  410 413
msf_map_version_1               000002 constant        char(8)                  initial packed unaligned dcl 2-323 ref 309 414
my_component              3            based           fixed bin(15,0)          level 2 in structure "mm" unsigned dcl 108
                                                                                  in procedure "object_lib_" ref 468 488 513
my_component              3            based           fixed bin(15,0)          level 2 in structure "msf_map" unsigned dcl 2-318
                                                                                  in procedure "object_lib_" ref 312
n_comp                          000206 automatic       fixed bin(24,0)          dcl 127 set ref 228* 245* 248 312 324 330
no_clear_sw                     000207 automatic       bit(1)                   packed unaligned dcl 128 set ref 185* 217* 260 342
null                                                   builtin function         dcl 145 ref 232 372 381 421 428 431 445 488 513 578
object_info                            based           structure                level 1 dcl 5-6
object_info_$brief              000030 constant        entry                    external dcl 76 ref 283 394 583 659
object_info_$display            000032 constant        entry                    external dcl 78 ref 396
object_info_$long               000034 constant        entry                    external dcl 80 ref 398
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 5-60 ref 282 393 502 582
offset                    1            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-38
                                                                                  ref 665 667 669 671
oi                              000210 automatic       structure                level 1 dcl 129 set ref 283 283 402 402 456 533 583
                                                                                  583 659 659
partial_link                           based           structure                level 1 dcl 6-38
pathname_                       000036 constant        entry                    external dcl 82 ref 250
sb                              000326 automatic       pointer                  dcl 8-24 set ref 723* 724 725 733
seg_no                          000350 automatic       fixed bin(17,0)          dcl 713 set ref 729* 733 741 749 750
segno                                                  builtin function         dcl 717 ref 729
segp                      4            based           pointer                  array level 3 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_" set ref 431 431* 445*
                                                                                  454* 475* 488 488* 504* 513 513* 531*
segp                                   parameter       pointer                  dcl 706 in procedure "get_lp" ref 686 729
segp                            000276 automatic       pointer                  dcl 130 in procedure "object_lib_" set ref 655* 659*
                                                                                  665
stack_header                           based           structure                level 1 dcl 8-26
stackbaseptr                                           builtin function         dcl 718 ref 723
statp                                  parameter       pointer                  dcl 708 in procedure "get_lp" set ref 686 750*
statp                    10     000210 automatic       pointer                  level 2 in structure "oi" dcl 129 in procedure
                                                                                  "object_lib_" set ref 601* 614 669
symbp                    12     000210 automatic       pointer                  level 2 dcl 129 set ref 612 671
tag                       0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 6-38 ref 632 639
targetp                         000300 automatic       pointer                  dcl 131 set ref 238* 252* 266* 283* 293 333 608*
                                                                                  610* 612* 614* 632 636 639 645* 649 650 665* 665
                                                                                  667* 667 669* 669 671* 671 677
term_$no_clear                  000040 constant        entry                    external dcl 83 ref 260
term_$single_refname            000042 constant        entry                    external dcl 84 ref 262
term_sw                         000302 automatic       bit(1)                   packed unaligned dcl 132 set ref 229* 265* 342
textp                     2     000210 automatic       pointer                  level 2 dcl 129 set ref 608
thing_relp                1            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 106 ref
                                                                                  608 610 612 614
true                            000004 constant        bit(1)                   initial packed unaligned dcl 34 ref 217 265 315 330
                                                                                  463
type                            000303 automatic       fixed bin(17,0)          dcl 133 in procedure "object_lib_" set ref 650* 665
                                                                                  667 669 671
type                                   based           fixed bin(3,0)           level 2 in structure "partial_link" packed packed
                                                                                  unsigned unaligned dcl 6-38 in procedure
                                                                                  "object_lib_" ref 650
unspec                                                 builtin function         dcl 719 in procedure "get_lp" ref 741
unspec                                                 builtin function         dcl 146 in procedure "object_lib_" set ref 523* 535*
version                                based           char(8)                  level 2 in structure "msf_map" dcl 2-318
                                                                                  in procedure "object_lib_" ref 309
version                                based           char(8)                  level 2 in structure "mm" dcl 108 in procedure
                                                                                  "object_lib_" ref 414
version                                based           char(8)                  level 2 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_" set ref 442*
version_number                  000210 automatic       fixed bin(17,0)          level 2 in structure "oi" dcl 129 in procedure
                                                                                  "object_lib_" set ref 282* 393* 582*
version_number           10            based           fixed bin(17,0)          array level 4 in structure "component_info" dcl 4-19
                                                                                  in procedure "object_lib_" set ref 502*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_NAMES                            internal static char(12)                 initial array packed unaligned dcl 2-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 2-25
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
FAULT_TAG_1                            internal static bit(6)                   initial packed unaligned dcl 6-100
FAULT_TAG_2                            internal static bit(6)                   initial packed unaligned dcl 6-101
FAULT_TAG_3                            internal static bit(6)                   initial packed unaligned dcl 6-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 6-99
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 2-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 2-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 2-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 2-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 2-194
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 3-56
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 2-153
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SECTION_HEAP                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_LINK                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-134
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array packed unaligned dcl 2-38
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
acc_string                             based           structure                level 1 dcl 2-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 2-334
acc_string_ptr                         automatic       pointer                  dcl 2-326
call_offset                            internal static fixed bin(17,0)          initial dcl 8-78
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 2-297
comp_ht_ptr                            automatic       pointer                  dcl 2-288
component_ht                           based           structure                level 1 dcl 2-289
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 2-284
def_ht_ptr                             automatic       pointer                  dcl 2-277
def_ptr                                automatic       pointer                  dcl 2-71
definition_ht                          based           structure                level 1 dcl 2-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 2-310
dup_table_ptr                          automatic       pointer                  dcl 2-301
duplicate_table                        based           structure                level 1 dcl 2-302
entry_offset                           internal static fixed bin(17,0)          initial dcl 8-78
exp_ptr                                automatic       pointer                  dcl 2-128
exp_word                               based           structure                level 1 dcl 2-129
fr_traps                               based           structure                level 1 dcl 6-90
isot1                                  based           structure                array level 1 dcl 7-16
itp                                    based           structure                level 1 dcl 3-18
itp_unsigned                           based           structure                level 1 dcl 3-43
its                                    based           structure                level 1 dcl 3-5
its_unsigned                           based           structure                level 1 dcl 3-30
link_init_copy_info                    based           structure                level 1 dcl 2-211
link_init_deferred                     based           structure                level 1 dcl 2-270
link_init_list_template                based           structure                level 1 dcl 2-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 2-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 2-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 2-226
link_init_ptr                          automatic       pointer                  dcl 2-204
link_trap_pair                         based           structure                level 1 dcl 2-177
link_trap_ptr                          automatic       pointer                  dcl 2-176
linkage_header                         based           structure                level 1 dcl 6-50
linkage_header_flags                   based           structure                level 1 dcl 6-63
list_template_entry                    based           structure                level 1 dcl 2-239
object_link                            based           structure                level 1 dcl 6-28
pointer_init_template                  based           structure                level 1 packed packed unaligned dcl 2-253
push_offset                            internal static fixed bin(17,0)          initial dcl 8-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 8-78
return_offset                          internal static fixed bin(17,0)          initial dcl 8-78
segname_definition                     based           structure                level 1 dcl 2-90
segname_ptr                            automatic       pointer                  dcl 2-89
stack_header_overlay                   based           fixed bin(17,0)          array dcl 8-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 8-72
type_pair                              based           structure                level 1 dcl 2-160
type_ptr                               automatic       pointer                  dcl 2-159
virgin_linkage_header                  based           structure                level 1 dcl 6-71

NAMES DECLARED BY EXPLICIT CONTEXT.
EXIT                            002477 constant        label                    dcl 781 ref 777
INITIATE_JOIN                   000151 constant        label                    dcl 225 ref 186 218
exit                            002543 constant        entry                    internal dcl 759 ref 246 248 263 274 287 312 324 342
                                                                                  344 376 388 400 403 495 520 544 584 592 602 616
                                                                                  625 632 637 639 646 656 660 673 679
get_component_info              000726 constant        entry                    external dcl 351
get_def_target                  001741 constant        entry                    external dcl 551
get_lp                          002500 constant        entry                    internal dcl 686 ref 601
init_no_clear                   000112 constant        entry                    external dcl 193
initiate                        000052 constant        entry                    external dcl 153
object_lib_                     000035 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3122        3210    2567        3132
Length      3610    2567        66         364     332           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
object_lib_                         279 external procedure  is an external procedure.  
on unit on line 426                  74 on unit               
get_lp                                  internal procedure  shares stack frame of external procedure object_lib_.  
exit                                    internal procedure  shares stack frame of external procedure object_lib_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
object_lib_              000100 based_areap                 object_lib_
                         000102 bc                          object_lib_
                         000103 bit_count                   object_lib_
                         000104 c                           object_lib_
                         000105 comp                        object_lib_
                         000106 defp                        object_lib_
                         000110 dhp                         object_lib_
                         000112 dname                       object_lib_
                         000164 dnamel                      object_lib_
                         000165 ec                          object_lib_
                         000166 ename                       object_lib_
                         000176 i                           object_lib_
                         000200 info_ep                     object_lib_
                         000204 mmp                         object_lib_
                         000206 n_comp                      object_lib_
                         000207 no_clear_sw                 object_lib_
                         000210 oi                          object_lib_
                         000276 segp                        object_lib_
                         000300 targetp                     object_lib_
                         000302 term_sw                     object_lib_
                         000303 type                        object_lib_
                         000312 def_header_ptr              object_lib_
                         000314 msf_map_ptr                 object_lib_
                         000316 comp_infop                  object_lib_
                         000320 max_component               object_lib_
                         000322 lotp                        object_lib_
                         000324 isotp                       object_lib_
                         000326 sb                          object_lib_
                         000350 seg_no                      get_lp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry
ext_entry_desc      int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_definition_               get_system_free_area_         hcs_$fs_get_path_name         hcs_$initiate_count
hcs_$status_minf              hcs_$status_mins              hcs_$terminate_noname         initiate_file_
object_info_$brief            object_info_$display          object_info_$long             pathname_
term_$no_clear                term_$single_refname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_class_def    error_table_$bad_indirect_def error_table_$dirseg
error_table_$inconsistent_object_msf                        error_table_$namedup          error_table_$nolinkag
error_table_$segknown         error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000034       153 000042       185 000106       186 000107       193 000110       217 000146       218 000150
    225 000151       227 000157       228 000164       229 000165       231 000166       232 000167       233 000171
    234 000175       238 000176       243 000241       245 000245       246 000303       248 000307       250 000320
    251 000340       252 000343       258 000407       260 000413       262 000434       263 000452       265 000456
    266 000460       272 000524       274 000532       277 000536       282 000544       283 000546       287 000565
    293 000571       294 000573       298 000575       299 000577       307 000603       309 000606       312 000620
    315 000634       317 000641       324 000642       326 000653       328 000660       330 000661       332 000670
    333 000674       334 000676       342 000700       344 000714       351 000717       372 000744       376 000747
    381 000763       383 001000       387 001003       388 001022       393 001026       394 001030       396 001051
    398 001063       400 001075       402 001104       403 001123       409 001127       410 001131       413 001137
    414 001142       416 001150       421 001153       422 001155       426 001157       428 001173       430 001200
    431 001210       434 001233       435 001236       437 001245       441 001246       442 001260       443 001265
    444 001267       445 001304       447 001320       453 001322       454 001324       455 001330       456 001332
    457 001335       463 001336       465 001340       467 001373       468 001401       474 001404       475 001430
    482 001474       487 001476       488 001505       492 001533       494 001535       495 001544       500 001553
    502 001562       504 001570       507 001606       512 001610       513 001617       517 001645       519 001647
    520 001656       522 001660       523 001661       525 001670       531 001671       532 001677       533 001702
    535 001716       537 001722       542 001724       544 001727       551 001732       578 001770       582 001772
    583 001774       584 002014       587 002020       591 002022       592 002054       599 002060       601 002066
    602 002102       608 002106       610 002121       612 002131       614 002141       616 002151       620 002160
    625 002164       632 002177       636 002221       637 002224       638 002227       639 002230       645 002243
    646 002274       649 002300       650 002304       651 002307       655 002333       656 002370       659 002374
    660 002413       665 002417       667 002430       669 002441       671 002452       673 002463       677 002472
    679 002474       781 002477       686 002500       723 002502       724 002504       725 002506       729 002510
    733 002516       735 002522       736 002525       741 002526       743 002532       744 002535       749 002536
    750 002540       752 002542       759 002543       776 002545       777 002547


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
