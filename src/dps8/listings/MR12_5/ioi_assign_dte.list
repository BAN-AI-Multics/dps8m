	COMPILATION LISTING OF SEGMENT ioi_assign_dte
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 10/28/82  1059.6 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* IOI_ASSIGN_DTE - Device table Assignment for the I/O Interfacer.
        7*   coded 7/15/74 by Noel I. Morris
        8*   modified 6/27/77 by Noel I. Morris
        9*   modified December 1979 by Larry Johnson for logging detailed status
       10*   modified February 1981 by Chris Jones for io_manager conversion
       11**/
       12 
       13 /* ******************************************************
       14*   *                                                    *
       15*   *                                                    *
       16*   * Copyright (c) 1972 by Massachusetts Institute of   *
       17*   * Technology and Honeywell Information Systems, Inc. *
       18*   *                                                    *
       19*   *                                                    *
       20*   ****************************************************** */
       21 
       22 
       23 /* This procedure is responsible for creating and destroying both a wired
       24*   and an unwired device table entry for a given I/O device.  Each wired
       25*   device table entry is placed in a circularly-threaded list of all devices
       26*   in a particular channel/device group.  An entry may be added to or removed
       27*   from this list without locking the interrupt side of the I/O Interfacer.
       28*   A lock must be set, however, to prevent simultaneous assignments and
       29*   unassignments from taking place.
       30**/
       31 
       32 
       33 /* format: style4,delnl,insnl,ifthen */
       34 ioi_assign_dte:
       35      proc (arg_gtep, device, priv, int_proc, wire_buffer, eventid, rcode) returns (fixed bin);
       36 
       37 dcl  arg_gtep ptr,					/* group table entry pointer */
       38      device bit (6),				/* physical device address */
       39      priv bit (1) aligned,				/* "1"b if privileged user of device */
       40      int_proc ptr,					/* interrupt procedure for hardcore user */
       41      wire_buffer bit (1) aligned,			/* "1"b if IOBM to be called */
       42      eventid fixed bin (71),				/* event ID for status wakeups */
       43      rcode fixed bin (35);				/* error code */
       44 
       45 dcl  dtx fixed bin,					/* device table index */
       46      dterp bit (18) aligned,				/* device table entry rel pointer */
       47      prev_dtep ptr,					/* pointer to previous device entry in thread */
       48      i fixed bin;					/* iteration variable */
       49 
       50 dcl  error_table_$already_assigned fixed bin (35) ext,
       51      error_table_$noalloc fixed bin (35) ext,
       52      pds$process_id bit (36) aligned ext;
       53 
       54 dcl  ioi_util$setbit entry (bit (1) unal) returns (bit (1) aligned),
       55      ioi_util$step entry (bit (18) unal) returns (bit (18) aligned),
       56      ioi_log_status$unassign_flush entry (ptr),
       57      level$get entry returns (fixed bin (3));
       58 
       59 dcl  (addr, divide, fixed, null, ptr, rel, unspec) builtin;
       60 
       61 
  1     1 /* Begin include file ...... ioi_data.incl.pl1 */
  1     2 /* format: style4,delnl,insnl,ifthen */
  1     3 
  1     4 dcl  (
  1     5      idp,						/* pointer to IOI data structure */
  1     6      gtep,					/* pointer to channel/device group entry */
  1     7      ctep,					/* pointer to channel table entry */
  1     8      dtep,					/* pointer to wired device table entry */
  1     9      stp
  1    10      ) ptr;					/* pointer to status control info */
  1    11 dcl  (ioi_subsystems, ioi_devices, ioi_channels) fixed bin;
  1    12 dcl  ioi_data$ ext;					/* IOI data segment */
  1    13 
  1    14 
  1    15 dcl  1 id based (idp) aligned,			/* I/O Interfacer data structure */
  1    16        2 assign_lock bit (36),			/* device assignment lock */
  1    17        2 assign_event fixed bin (35),			/* assignment lock event */
  1    18        2 default_time fixed bin (9) uns,		/* default I/O completion time limit */
  1    19        2 max_buffer_len fixed bin (18),			/* default maximum buffer size */
  1    20        2 max_time fixed bin (9) uns,			/* default maximum timeout grace time */
  1    21        2 wabs fixed bin (24),				/* absolute address of this segment */
  1    22        2 status_mask bit (36),			/* mask for testing for I/O error */
  1    23        2 select_count fixed bin,			/* count of processes search device thread */
  1    24        2 addev_count fixed bin,			/* count of times device added to thread */
  1    25        2 rss_idcw bit (36),				/* IDCW for reactivating channel after time-out */
  1    26        2 ngt fixed bin,				/* number of groups */
  1    27        2 nct fixed bin,				/* number of channels */
  1    28        2 ndt fixed bin,				/* number of devices */
  1    29        2 status_log_mask bit (72),			/* mask for comparing I/O syserr message */
  1    30        2 pad (1) fixed bin (35),			/* pad to 16 words */
  1    31        2 gt (ioi_subsystems refer (id.ngt)) like gte aligned,
  1    32 						/* channel/device group table */
  1    33        2 ct (ioi_channels refer (id.nct)) like cte aligned, /* channel table */
  1    34        2 dt (ioi_devices refer (id.ndt)) like dte aligned;	/* device table */
  1    35 
  1    36 dcl  1 gte based (gtep) aligned,			/* channel/device group table entry */
  1    37        (
  1    38        2 dtep bit (18),				/* rel ptr to device just serviced */
  1    39        2 ctep bit (18),				/* rel ptr to thread of channel table entries */
  1    40        2 allocated bit (1),				/* "1"b when gte allocated */
  1    41        2 mplex bit (1),				/* "1"b if more than one device possible */
  1    42        2 psia bit (1),				/* "1"b if channel is PSIA */
  1    43        2 connect_pending bit (1),			/* "1"b if connect has been requested */
  1    44        2 suspend_devices bit (1),			/* "1"b if device I/O suspended */
  1    45        2 dual_controller bit (1),			/* "1"b if dual controller subsystem (disk only) */
  1    46        2 eurc bit (1),				/* "1"b if EURC controller,	 detailed status must be packed */
  1    47        2 pad bit (2),
  1    48        2 sx fixed bin (8),				/* subsystem index (disk only) */
  1    49        2 ndev fixed bin (17)
  1    50        ) unal,					/* number of devices in device table thread */
  1    51        2 name char (4),				/* name of channel group */
  1    52        2 connect_count fixed bin,			/* count of pending connect requests */
  1    53        2 detailed_status_cmd bit (6) unal,		/* idcw command to read detailed status */
  1    54        2 pad2 bit (12) unal,
  1    55        2 io_log_info_index fixed bin (17) unal,		/* index into io_log_status_info table */
  1    56        2 pad3 fixed bin (35);				/* pad to 6 words */
  1    57 
  1    58 dcl  1 cte based (ctep) aligned,			/* channel table entry */
  1    59        (
  1    60        2 next_cte bit (18),				/* rel ptr to next channel table entry */
  1    61        2 gtep bit (18),				/* rel ptr to channel/device group table entry */
  1    62        2 ddchx fixed bin (35),			/* channel index (for disk DIM) */
  1    63        2 chx fixed bin (35),				/* channel index for io_manager */
  1    64        2 cur_dtep bit (18),				/* current device table entry */
  1    65        2 allocated bit (1),				/* "1"b when cte allocated */
  1    66        2 active bit (1),				/* "1"b if channel currently being used */
  1    67        2 in_use bit (1),				/* "1"b if this channel may be used */
  1    68        2 connected bit (1),				/* "1"b if channel is connected */
  1    69        2 connect_lock bit (1),			/* "1"b when channel being connected */
  1    70        2 abort bit (1),				/* "1"b when channel being aborted */
  1    71        2 release bit (1),				/* "1"b when suspended channel being released */
  1    72        2 pad2 bit (11)
  1    73        ) unal,
  1    74        2 chanid char (8),				/* io_manager's name for channel */
  1    75        2 statusp ptr,				/* pointer to first word of status */
  1    76        2 time_limit fixed bin (35),			/* connect time limit (in seconds) */
  1    77        2 istat,					/* saved copy of status while detailed status read */
  1    78          3 offset fixed bin (18),			/* DCW list offset */
  1    79          3 iom_stat bit (72),				/* IOM status */
  1    80          3 lpw bit (72),				/* LPW residue */
  1    81          3 idcw bit (36),				/* IDCW user connected with */
  1    82       2 pad3 fixed bin (35);				/* pad to 16 words */
  1    83 
  1    84 
  1    85 dcl  1 stctl based (stp) aligned,			/* control word for storing status */
  1    86        (
  1    87        2 add bit (18),				/* address in status queue */
  1    88        2 lth fixed bin (8),				/* length of status queue */
  1    89        2 tally fixed bin (8)
  1    90        ) unal;					/* current tally */
  1    91 
  1    92 dcl  1 stproc based (stp) aligned,			/* pointer to hardcore interrupt procedure */
  1    93        2 ptr ptr unal;
  1    94 
  1    95 dcl  1 dte based (dtep) aligned,			/* wired device table entry */
  1    96        (
  1    97        2 next_dte bit (18),				/* rel ptr to next entry in thread */
  1    98        2 gtep bit (18),				/* rel ptr to channel/device group table entry */
  1    99        2 allocated bit (1),				/* "1"b when dte allocated */
  1   100        2 priv bit (1),				/* "1"b if privileged user */
  1   101        2 special_assign bit (1),			/* "1"b if assigned from hardcore ring */
  1   102        2 pad4 bit (9),
  1   103        2 buff_absaddr bit (24)
  1   104        ) unal,					/* absolute address of buffer when wired */
  1   105        2 channel_required char (8),			/* channel name of required channel */
  1   106        2 buff_sdw fixed bin (71),			/* SDW of workspace buffer segment */
  1   107        2 eventid fixed bin (71),			/* event ID for status wakeups */
  1   108        (
  1   109        2 pad1 bit (1),
  1   110        2 buffer_bound fixed bin (10),			/* bound of buffer (in 512 word blocks) */
  1   111        2 pad2 bit (1),
  1   112        2 max_bound fixed bin (10),			/* largest allowable bound of buffer segment */
  1   113        2 buffer_index fixed bin (11),			/* index for IOBM */
  1   114        2 buff_segno bit (18),				/* workspace buffer segment number */
  1   115        2 buff_astep bit (18)
  1   116        ) unal,					/* rel pointer to ASTE for buffer segment */
  1   117        2 processid bit (36),				/* ID of process owning device */
  1   118        (
  1   119        2 in_use bit (1),				/* "1"b if device is to be used */
  1   120        2 active bit (1),				/* "1"b if device running or to run */
  1   121        2 not_connecting bit (1),			/* "0"b when device waiting to be connected */
  1   122        2 rel bit (1),				/* "1"b if connect to be performed in rel mode */
  1   123        2 hardcore bit (1),				/* "1"b if hardcore user */
  1   124        2 wire_buffer bit (1),				/* "1"b if IOBM to be called */
  1   125        2 special_interrupt bit (1),			/* "1"b if special interrupt received */
  1   126        2 log_status_cnt bit (1),			/* "1"b if count in log_status is valid */
  1   127        2 using bit (1),				/* "1"b if currently using device table entry */
  1   128        2 deleting bit (1),				/* "1"b if trying to delete device table entry */
  1   129        2 reading_detailed_status bit (1),		/* "1"b if read of detailed device status in progress */
  1   130        2 detailed_status_valid bit (1),			/* "1"b if detailed status read sucessfully */
  1   131        2 pad3 bit (14),
  1   132        2 ring fixed bin (3),				/* highest ring allowed to access device */
  1   133        2 device bit (6),				/* device code */
  1   134        2 listx bit (18),				/* DCW list index for connect */
  1   135        2 time fixed bin (9) uns,			/* time limit for I/O completion */
  1   136        2 max_time fixed bin (9) uns
  1   137        ) unal,					/* maximum allowable timeout grace time */
  1   138        2 pcw bit (36),				/* peripheral control word (PCW) */
  1   139        2 idcw bit (36),				/* instruction DCW */
  1   140        2 tdcw bit (36),				/* transfer DCW to remainder of list */
  1   141        2 special_status bit (36),			/* special interrupt status */
  1   142        2 detailed_status (6) bit (36),			/* buffer for reading most recent detailed status */
  1   143        2 sc bit (36),				/* status control word */
  1   144        2 log_status bit (72),				/* two words of I/O syserr message */
  1   145        2 log_detailed_status (6) bit (36);		/* copy of last detailed status logged */
  1   146 
  1   147 
  1   148 /* End of include file ...... ioi_data.incl.pl1 */
       62 
       63 
       64 
       65 	idp = addr (ioi_data$);			/* Get pointer to data segment. */
       66 	gtep = arg_gtep;				/* Get pointer to group table entry. */
       67 
       68 	dterp = gte.dtep;				/* Get rel pointer to first device table entry. */
       69 	if dterp then
       70 	     do i = 1 to gte.ndev;			/* Search for duplicated device. */
       71 	     dtep = ptr (idp, dterp);			/* Make pointer to table entry. */
       72 	     if dte.device = device then do;		/* If device already assigned ... */
       73 		rcode = error_table_$already_assigned;
       74 		return (0);
       75 	     end;
       76 	     dterp = dte.next_dte;			/* Get pointer to next entry in list. */
       77 	end;
       78 
       79 	do dtx = 1 to id.ndt;			/* Look for a free device table entry. */
       80 	     if ioi_util$setbit (id.dt (dtx).allocated) then
       81 		go to got_dte;			/* Try to lock an entry. */
       82 	end;
       83 	rcode = error_table_$noalloc;			/* Could not find a free device table entry. */
       84 	return (0);
       85 
       86 got_dte:
       87 	dtep = addr (id.dt (dtx));			/* Get pointer to device table entry. */
       88 
       89 	dte.buff_segno = "0"b;			/* Initialize the entry variables. */
       90 	dte.buff_astep = "0"b;
       91 	dte.ring = level$get ();
       92 	dte.priv = priv;
       93 	dte.max_bound = divide (id.max_buffer_len, 512, 10, 0);
       94 	dte.max_time = id.max_time;
       95 
       96 	dte.gtep = rel (gtep);			/* Initialize the wired entry variables. */
       97 	dte.active = "0"b;
       98 	dte.not_connecting = "1"b;
       99 	dte.wire_buffer = wire_buffer;
      100 	dte.special_interrupt = "0"b;
      101 	dte.buffer_bound = 0;
      102 	dte.buffer_index = 0;
      103 	dte.time = id.default_time;
      104 	dte.device = device;
      105 	dte.priv = dte.priv;
      106 	dte.channel_required = "";
      107 	dte.eventid = eventid;
      108 	dte.processid = pds$process_id;
      109 	dte.log_status_cnt = "0"b;
      110 	dte.using = "0"b;
      111 	dte.deleting = "0"b;
      112 	dte.log_status = "0"b;
      113 	dte.reading_detailed_status = "0"b;
      114 	dte.detailed_status_valid = "0"b;
      115 	unspec (dte.detailed_status) = "0"b;
      116 	unspec (dte.log_detailed_status) = "0"b;
      117 
      118 	if int_proc ^= null () then do;		/* If hardcore attachment ... */
      119 	     stp = addr (dte.sc);			/* Get pointer to place for interrupt procedure. */
      120 	     stproc.ptr = int_proc;			/* Save pointer to interrupt procedure. */
      121 	     dte.hardcore = "1"b;			/* Set flag. */
      122 	end;
      123 	else do;					/* If not hardcore attachment ... */
      124 	     dte.sc = "0"b;				/* Clear status control info. */
      125 	     dte.hardcore = "0"b;			/* Clear flag. */
      126 	end;
      127 
      128 	dte.in_use = ^gte.suspend_devices;		/* Allow use of device if devices not suspended. */
      129 
      130 
      131 /* The following steps _m_u_s_t occur in the following order:
      132*
      133*   1.	Add one to number of devices.
      134*   2.	Add one to the add device count, "addev_count".
      135*   3.	Thread the new device table entry into device thread.
      136**/
      137 
      138 	gte.ndev = gte.ndev + 1;			/* Increment the count of devices in this group. */
      139 
      140 	id.addev_count = fixed (id.addev_count + 1, 17);	/* Indicate another device is being added. */
      141 
      142 	dterp = gte.dtep;				/* Get pointer into circular list of devices. */
      143 	if dterp then do;				/* If list is not empty ... */
      144 	     prev_dtep = ptr (idp, dterp);		/* Get pointer to entry. */
      145 	     dte.next_dte = prev_dtep -> dte.next_dte;	/* Point new entry into list. */
      146 	     prev_dtep -> dte.next_dte = rel (dtep);	/* Make existing entry point to new one. */
      147 	end;
      148 	else do;					/* If list is empty ... */
      149 	     dte.next_dte,				/* Make entry point to itself. */
      150 		gte.dtep = rel (dtep);		/* Set pointer in group entry. */
      151 	end;
      152 
      153 	return (dtx);				/* Return index of table entries. */
      154 
      155 
      156 ioi_unassign_dte:
      157      entry (arg_dtep);
      158 
      159 dcl  arg_dtep ptr;					/* device table entry index */
      160 
      161 
      162 	idp = addr (ioi_data$);			/* Get pointer to IOI data segment. */
      163 	dtep = arg_dtep;				/* Generate pointer to device table entry. */
      164 	gtep = ptr (idp, dte.gtep);			/* Get pointer to channel/device group entry. */
      165 
      166 	call ioi_log_status$unassign_flush (dtep);	/* Write last syserr message if required */
      167 
      168 
      169 /* The following steps _m_u_s_t take place in the order shown:
      170*
      171*   1.	Turn off "in_use" flag in wired device table entry.
      172*   2.	Unthread entry from circular list.
      173*   3.	Make sure channel/device group not pointing to this entry.
      174*   4.	Wait for interrupt-time device selection to cease.
      175*   5.	Scrap the device table entry.
      176*   6.	Subtract 1 from the count of devices in this group.
      177**/
      178 
      179 	dte.in_use = "0"b;				/* This device may no longer be used. */
      180 
      181 	dterp = dte.next_dte;			/* Get rel pointer to next entry in list. */
      182 	prev_dtep = null ();			/* Set initial value. */
      183 	do while (dterp ^= rel (dtep));		/* Follow thread until we find entry pointing to this one. */
      184 	     prev_dtep = ptr (idp, dterp);		/* Get pointer to entry. */
      185 	     dterp = prev_dtep -> dte.next_dte;		/* Get rel pointer to next entry. */
      186 	end;
      187 
      188 	if prev_dtep = null () then			/* If only one item in circular list ... */
      189 	     gte.dtep = "0"b;			/* Clear the list pointer in group entry. */
      190 	else					/* If more than one item ... */
      191 	     prev_dtep -> dte.next_dte = dte.next_dte;	/* Thread around entry to be removed. */
      192 
      193 	dterp = ioi_util$step (gte.dtep);		/* Make sure group entry does not point to removed entry. */
      194 
      195 	do while (id.select_count ^= 0);		/* Wait for device selection to finish. */
      196 	end;
      197 
      198 	dte.allocated = "0"b;			/* Entry is now free to be used. */
      199 
      200 	gte.ndev = gte.ndev - 1;			/* Decrement count of devices in this group. */
      201 
      202 	return;
      203 
      204 
      205      end ioi_assign_dte;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/82  1102.9  ioi_assign_dte.pl1                >dumps>old>recomp>ioi_assign_dte.pl1
62           1    06/17/82  1132.4  ioi_data.incl.pl1                 >ldd>include>ioi_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
active                   13(01)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 97*
addev_count              10            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 140* 140
addr                                                   builtin function         dcl 59 ref 65 86 119 162
allocated                 1            based           bit(1)                   level 2 in structure "dte" packed unaligned dcl 1-95
                                                                                  in procedure "ioi_assign_dte" set ref 198*
allocated                              based           bit(1)                   array level 3 in structure "id" packed unaligned
                                                                                  dcl 1-15 in procedure "ioi_assign_dte" set ref 80*
arg_dtep                               parameter       pointer                  dcl 159 ref 156 163
arg_gtep                               parameter       pointer                  dcl 37 ref 34 66
buff_astep               11(18)        based           bit(18)                  level 2 packed unaligned dcl 1-95 set ref 90*
buff_segno               11            based           bit(18)                  level 2 packed unaligned dcl 1-95 set ref 89*
buffer_bound             10(01)        based           fixed bin(10,0)          level 2 packed unaligned dcl 1-95 set ref 101*
buffer_index             10(24)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-95 set ref 102*
channel_required          2            based           char(8)                  level 2 dcl 1-95 set ref 106*
cte                                    based           structure                level 1 dcl 1-58
default_time              2            based           fixed bin(9,0)           level 2 unsigned dcl 1-15 ref 103
deleting                 13(09)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 111*
detailed_status          21            based           bit(36)                  array level 2 dcl 1-95 set ref 115*
detailed_status_valid
                         13(11)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 114*
device                                 parameter       bit(6)                   unaligned dcl 37 in procedure "ioi_assign_dte" ref
                                                                                  34 72 104
device                   13(30)        based           bit(6)                   level 2 in structure "dte" packed unaligned dcl 1-95
                                                                                  in procedure "ioi_assign_dte" set ref 72 104*
divide                                                 builtin function         dcl 59 ref 93
dt                                     based           structure                array level 2 dcl 1-15 set ref 86
dte                                    based           structure                level 1 dcl 1-95
dtep                                   based           bit(18)                  level 2 in structure "gte" packed unaligned dcl 1-36
                                                                                  in procedure "ioi_assign_dte" set ref 68 142 149*
                                                                                  188* 193*
dtep                            000112 automatic       pointer                  dcl 1-4 in procedure "ioi_assign_dte" set ref 71* 72
                                                                                  76 86* 89 90 91 92 93 94 96 97 98 99 100 101 102
                                                                                  103 104 105 105 106 107 108 109 110 111 112 113
                                                                                  114 115 116 119 121 124 125 128 145 146 149 149
                                                                                  163* 164 166* 179 181 183 190 198
dterp                           000101 automatic       bit(18)                  dcl 45 set ref 68* 69 71 76* 142* 143 144 181* 183
                                                                                  184 185* 193*
dtx                             000100 automatic       fixed bin(17,0)          dcl 45 set ref 79* 80* 86 153
error_table_$already_assigned   000010 external static fixed bin(35,0)          dcl 50 ref 73
error_table_$noalloc            000012 external static fixed bin(35,0)          dcl 50 ref 83
eventid                                parameter       fixed bin(71,0)          dcl 37 in procedure "ioi_assign_dte" ref 34 107
eventid                   6            based           fixed bin(71,0)          level 2 in structure "dte" dcl 1-95 in procedure
                                                                                  "ioi_assign_dte" set ref 107*
fixed                                                  builtin function         dcl 59 ref 140
gte                                    based           structure                level 1 dcl 1-36
gtep                            000110 automatic       pointer                  dcl 1-4 in procedure "ioi_assign_dte" set ref 66* 68
                                                                                  69 96 128 138 138 142 149 164* 188 193 200 200
gtep                      0(18)        based           bit(18)                  level 2 in structure "dte" packed unaligned dcl 1-95
                                                                                  in procedure "ioi_assign_dte" set ref 96* 164
hardcore                 13(04)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 121* 125*
i                               000104 automatic       fixed bin(17,0)          dcl 45 set ref 69*
id                                     based           structure                level 1 dcl 1-15
idp                             000106 automatic       pointer                  dcl 1-4 set ref 65* 71 79 80 86 93 94 103 140 140
                                                                                  144 162* 164 184 195
in_use                   13            based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 128* 179*
int_proc                               parameter       pointer                  dcl 37 ref 34 118 120
ioi_data$                       000026 external static fixed bin(17,0)          dcl 1-12 set ref 65 162
ioi_log_status$unassign_flush   000022 constant        entry                    external dcl 54 ref 166
ioi_util$setbit                 000016 constant        entry                    external dcl 54 ref 80
ioi_util$step                   000020 constant        entry                    external dcl 54 ref 193
level$get                       000024 constant        entry                    external dcl 54 ref 91
log_detailed_status      32            based           bit(36)                  array level 2 dcl 1-95 set ref 116*
log_status               30            based           bit(72)                  level 2 dcl 1-95 set ref 112*
log_status_cnt           13(07)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 109*
max_bound                10(13)        based           fixed bin(10,0)          level 2 packed unaligned dcl 1-95 set ref 93*
max_buffer_len            3            based           fixed bin(18,0)          level 2 dcl 1-15 ref 93
max_time                  4            based           fixed bin(9,0)           level 2 in structure "id" unsigned dcl 1-15
                                                                                  in procedure "ioi_assign_dte" ref 94
max_time                 14(27)        based           fixed bin(9,0)           level 2 in structure "dte" packed unsigned unaligned
                                                                                  dcl 1-95 in procedure "ioi_assign_dte" set ref 94*
nct                      13            based           fixed bin(17,0)          level 2 dcl 1-15 ref 80 86
ndev                      1(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-36 set ref 69 138*
                                                                                  138 200* 200
ndt                      14            based           fixed bin(17,0)          level 2 dcl 1-15 ref 79
next_dte                               based           bit(18)                  level 2 packed unaligned dcl 1-95 set ref 76 145*
                                                                                  145 146* 149* 181 185 190* 190
ngt                      12            based           fixed bin(17,0)          level 2 dcl 1-15 ref 80 86
not_connecting           13(02)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 98*
null                                                   builtin function         dcl 59 ref 118 182 188
pds$process_id                  000014 external static bit(36)                  dcl 50 ref 108
prev_dtep                       000102 automatic       pointer                  dcl 45 set ref 144* 145 146 182* 184* 185 188 190
priv                      1(01)        based           bit(1)                   level 2 in structure "dte" packed unaligned dcl 1-95
                                                                                  in procedure "ioi_assign_dte" set ref 92* 105* 105
priv                                   parameter       bit(1)                   dcl 37 in procedure "ioi_assign_dte" ref 34 92
processid                12            based           bit(36)                  level 2 dcl 1-95 set ref 108*
ptr                                    based           pointer                  level 2 in structure "stproc" packed unaligned
                                                                                  dcl 1-92 in procedure "ioi_assign_dte" set ref
                                                                                  120*
ptr                                                    builtin function         dcl 59 in procedure "ioi_assign_dte" ref 71 144 164
                                                                                  184
rcode                                  parameter       fixed bin(35,0)          dcl 37 set ref 34 73* 83*
reading_detailed_status
                         13(10)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 113*
rel                                                    builtin function         dcl 59 ref 96 146 149 183
ring                     13(26)        based           fixed bin(3,0)           level 2 packed unaligned dcl 1-95 set ref 91*
sc                       27            based           bit(36)                  level 2 dcl 1-95 set ref 119 124*
select_count              7            based           fixed bin(17,0)          level 2 dcl 1-15 ref 195
special_interrupt        13(06)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 100*
stp                             000114 automatic       pointer                  dcl 1-4 set ref 119* 120
stproc                                 based           structure                level 1 dcl 1-92
suspend_devices           1(04)        based           bit(1)                   level 2 packed unaligned dcl 1-36 ref 128
time                     14(18)        based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 1-95 set ref
                                                                                  103*
unspec                                                 builtin function         dcl 59 set ref 115* 116*
using                    13(08)        based           bit(1)                   level 2 packed unaligned dcl 1-95 set ref 110*
wire_buffer              13(05)        based           bit(1)                   level 2 in structure "dte" packed unaligned dcl 1-95
                                                                                  in procedure "ioi_assign_dte" set ref 99*
wire_buffer                            parameter       bit(1)                   dcl 37 in procedure "ioi_assign_dte" ref 34 99

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ctep                                   automatic       pointer                  dcl 1-4
ioi_channels                           automatic       fixed bin(17,0)          dcl 1-11
ioi_devices                            automatic       fixed bin(17,0)          dcl 1-11
ioi_subsystems                         automatic       fixed bin(17,0)          dcl 1-11
stctl                                  based           structure                level 1 dcl 1-85

NAMES DECLARED BY EXPLICIT CONTEXT.
got_dte                         000202 constant        label                    dcl 86 ref 80
ioi_assign_dte                  000033 constant        entry                    external dcl 34
ioi_unassign_dte                000447 constant        entry                    external dcl 156

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       736         766     605         746
Length      1166     605        30         163     131           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ioi_assign_dte                      106 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ioi_assign_dte           000100 dtx                         ioi_assign_dte
                         000101 dterp                       ioi_assign_dte
                         000102 prev_dtep                   ioi_assign_dte
                         000104 i                           ioi_assign_dte
                         000106 idp                         ioi_assign_dte
                         000110 gtep                        ioi_assign_dte
                         000112 dtep                        ioi_assign_dte
                         000114 stp                         ioi_assign_dte

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              signal              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioi_log_status$unassign_flush ioi_util$setbit               ioi_util$step                 level$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$already_assigned error_table_$noalloc          ioi_data$                     pds$process_id


CONSTANTS
000573  aa     377777777777

000574  aa     757777777777

000575  aa     777677777777

000576  aa     777577777777

000577  aa     777377777777

000600  aa     776777777777

000601  aa     775777777777

000602  aa     773777777777

000603  aa     577777777777

000604  aa     000037770000

000000  aa     404000000003

000001  aa     514000000022

000002  aa     404000000043

000003  aa     410000000107

000004  aa     514000000001

000005  aa     516000000006

000006  aa     464000000000

000007  aa     404000000021

000010  aa     077777000043
000011  aa     000001000000

000012  aa     000000000000
000013  aa     000000000000

000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    

000016  aa  162 145 164 165	retu
000017  aa  162 156 137 143	rn_c
000020  aa  157 156 166 145	onve
000021  aa  162 163 151 157	rsio
000022  aa  156 137 145 162	n_er
000023  aa  162 157 162 000	ror

BEGIN PROCEDURE ioi_assign_dte
ENTRY TO ioi_assign_dte                                     STATEMENT 1 ON LINE 34
ioi_assign_dte:
     proc (arg_gtep, device, priv, int_proc, wire_buffer, eventid, rcode) returns (fixed bin);

000024  at     000010000006
000025  tt     000005000004
000026  tt     000006000004
000027  tt     000003000002
000030  ta     000007000000
000031  ta     000024000000
000032  da     000115320000
000033  aa   000160 6270 00	eax7 	112
000034  aa  7 00034 3521 20	epp2 	pr7|28,*
000035  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000036  aa     000020000000
000037  aa     000000000000
000040  aa   000001 2360 07	ldq  	1,dl
000041  aa  6 00116 7561 00	stq  	pr6|78
						STATEMENT 1 ON LINE 65
	idp = addr (ioi_data$);

000042  la  4 00026 3521 20	epp2 	pr4|22,*		ioi_data$
000043  aa  6 00106 2521 00	spri2	pr6|70		idp
						STATEMENT 1 ON LINE 66
	gtep = arg_gtep;

000044  aa  6 00032 3735 20	epp7 	pr6|26,*
000045  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_gtep
000046  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_gtep
000047  aa  6 00110 6515 00	spri5	pr6|72		gtep
						STATEMENT 1 ON LINE 68
	dterp = gte.dtep;

000050  aa  5 00000 2351 00	lda  	pr5|0		gte.dtep
000051  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000052  aa  6 00101 7551 00	sta  	pr6|65		dterp
						STATEMENT 1 ON LINE 69
	if dterp then
	     do i = 1 to gte.ndev;

000053  aa   000045 6000 04	tze  	37,ic		000120
000054  aa  5 00001 2351 00	lda  	pr5|1		gte.ndev
000055  aa   000022 7350 00	als  	18
000056  aa   000066 7330 00	lrs  	54
000057  aa  6 00117 7561 00	stq  	pr6|79
000060  aa   000001 2360 07	ldq  	1,dl
000061  aa  6 00104 7561 00	stq  	pr6|68		i
000062  aa  6 00104 2361 00	ldq  	pr6|68		i
000063  aa  6 00117 1161 00	cmpq 	pr6|79
000064  aa   000034 6054 04	tpnz 	28,ic		000120
						STATEMENT 1 ON LINE 71
	     dtep = ptr (idp, dterp);

000065  aa  6 00101 2351 00	lda  	pr6|65		dterp
000066  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000067  aa  6 00106 3521 20	epp2 	pr6|70,*		idp
000070  aa   000000 3120 01	eawp2	0,au
000071  aa  6 00112 2521 00	spri2	pr6|74		dtep
						STATEMENT 1 ON LINE 72
	     if dte.device = device then do;

000072  aa  6 00032 3735 20	epp7 	pr6|26,*
000073  aa  7 00004 3715 20	epp5 	pr7|4,*
000074  aa  000 100 066 500	cmpb 	(pr),(pr),fill(0)
000075  aa  2 00013 63 0006	descb	pr2|11(30),6	dte.device
000076  aa  5 00000 00 0006	descb	pr5|0,6		device
000077  aa   000014 6010 04	tnz  	12,ic		000113
						STATEMENT 1 ON LINE 73
		rcode = error_table_$already_assigned;

000100  aa  6 00044 3701 20	epp4 	pr6|36,*
000101  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$already_assigned
000102  aa  7 00016 7561 20	stq  	pr7|14,*		rcode
						STATEMENT 1 ON LINE 74
		return (0);

000103  aa  6 00116 2361 00	ldq  	pr6|78
000104  aa   000005 6010 04	tnz  	5,ic		000111
000105  aa   000027 7260 07	lxl6 	23,dl
000106  aa   777710 3520 04	epp2 	-56,ic		000016 = 162145164165
000107  aa  0 00716 7001 00	tsx0 	pr0|462		signal
000110  aa  0 00631 7101 00	tra  	pr0|409		return
000111  aa  7 00020 4501 20	stz  	pr7|16,*
000112  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 75
	     end;

						STATEMENT 1 ON LINE 76
	     dterp = dte.next_dte;

000113  aa  2 00000 2351 00	lda  	pr2|0		dte.next_dte
000114  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000115  aa  6 00101 7551 00	sta  	pr6|65		dterp
						STATEMENT 1 ON LINE 77
	end;

000116  aa  6 00104 0541 00	aos  	pr6|68		i
000117  aa   777743 7100 04	tra  	-29,ic		000062
						STATEMENT 1 ON LINE 79
	do dtx = 1 to id.ndt;

000120  aa  6 00106 3735 20	epp7 	pr6|70,*		idp
000121  aa  7 00014 2361 00	ldq  	pr7|12		id.ndt
000122  aa  6 00141 7561 00	stq  	pr6|97
000123  aa   000001 2360 07	ldq  	1,dl
000124  aa  6 00100 7561 00	stq  	pr6|64		dtx
000125  aa  6 00100 2361 00	ldq  	pr6|64		dtx
000126  aa  6 00141 1161 00	cmpq 	pr6|97
000127  aa   000037 6054 04	tpnz 	31,ic		000166
						STATEMENT 1 ON LINE 80
	     if ioi_util$setbit (id.dt (dtx).allocated) then
		go to got_dte;

000130  aa   000005 7360 00	qls  	5
000131  aa  6 00142 7561 00	stq  	pr6|98
000132  aa  6 00106 3735 20	epp7 	pr6|70,*		idp
000133  aa  7 00013 2361 00	ldq  	pr7|11		id.nct
000134  aa   000004 7360 00	qls  	4
000135  aa  6 00143 7561 00	stq  	pr6|99
000136  aa  7 00012 2361 00	ldq  	pr7|10		id.ngt
000137  aa   000006 4020 07	mpy  	6,dl
000140  aa   000020 0760 07	adq  	16,dl
000141  aa   000001 0760 07	adq  	1,dl
000142  aa   777776 3760 07	anq  	262142,dl
000143  aa  6 00143 0761 00	adq  	pr6|99
000144  aa   000001 0760 07	adq  	1,dl
000145  aa   777776 3760 07	anq  	262142,dl
000146  aa   000001 0760 07	adq  	1,dl
000147  aa  6 00142 0761 00	adq  	pr6|98
000150  aa  7 77740 3521 06	epp2 	pr7|-32,ql	id.allocated
000151  aa  6 00146 2521 00	spri2	pr6|102
000152  aa  6 00143 3521 00	epp2 	pr6|99
000153  aa  6 00150 2521 00	spri2	pr6|104
000154  aa  6 00144 6211 00	eax1 	pr6|100
000155  aa   010000 4310 07	fld  	4096,dl
000156  aa  6 00044 3701 20	epp4 	pr6|36,*
000157  la  4 00016 3521 20	epp2 	pr4|14,*		ioi_util$setbit
000160  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000161  aa  6 00143 2351 00	lda  	pr6|99
000162  aa   400000 3150 03	cana 	131072,du
000163  aa   000017 6010 04	tnz  	15,ic		000202
						STATEMENT 1 ON LINE 82
	end;

000164  aa  6 00100 0541 00	aos  	pr6|64		dtx
000165  aa   777740 7100 04	tra  	-32,ic		000125
						STATEMENT 1 ON LINE 83
	rcode = error_table_$noalloc;

000166  aa  6 00044 3701 20	epp4 	pr6|36,*
000167  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$noalloc
000170  aa  6 00032 3735 20	epp7 	pr6|26,*
000171  aa  7 00016 7561 20	stq  	pr7|14,*		rcode
						STATEMENT 1 ON LINE 84
	return (0);

000172  aa  6 00116 2361 00	ldq  	pr6|78
000173  aa   000005 6010 04	tnz  	5,ic		000200
000174  aa   000027 7260 07	lxl6 	23,dl
000175  aa   777621 3520 04	epp2 	-111,ic		000016 = 162145164165
000176  aa  0 00716 7001 00	tsx0 	pr0|462		signal
000177  aa  0 00631 7101 00	tra  	pr0|409		return
000200  aa  7 00020 4501 20	stz  	pr7|16,*
000201  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 86
got_dte:
	dtep = addr (id.dt (dtx));

000202  aa  6 00106 3735 20	epp7 	pr6|70,*		idp
000203  aa  7 00013 2361 00	ldq  	pr7|11		id.nct
000204  aa   000004 7360 00	qls  	4
000205  aa  6 00143 7561 00	stq  	pr6|99
000206  aa  7 00012 2361 00	ldq  	pr7|10		id.ngt
000207  aa   000006 4020 07	mpy  	6,dl
000210  aa   000020 0760 07	adq  	16,dl
000211  aa   000001 0760 07	adq  	1,dl
000212  aa   777776 3760 07	anq  	262142,dl
000213  aa  6 00143 0761 00	adq  	pr6|99
000214  aa   000001 0760 07	adq  	1,dl
000215  aa   777776 3760 07	anq  	262142,dl
000216  aa  6 00142 0761 00	adq  	pr6|98
000217  aa  7 77740 3521 06	epp2 	pr7|-32,ql	id.dt
000220  aa  6 00112 2521 00	spri2	pr6|74		dtep
						STATEMENT 1 ON LINE 89
	dte.buff_segno = "0"b;

000221  aa   777777 2350 07	lda  	262143,dl
000222  aa  2 00011 3551 00	ansa 	pr2|9		dte.buff_segno
						STATEMENT 1 ON LINE 90
	dte.buff_astep = "0"b;

000223  aa   777777 2350 03	lda  	262143,du
000224  aa  2 00011 3551 00	ansa 	pr2|9		dte.buff_astep
						STATEMENT 1 ON LINE 91
	dte.ring = level$get ();

000225  aa  6 00142 3521 00	epp2 	pr6|98
000226  aa  6 00146 2521 00	spri2	pr6|102
000227  aa  6 00144 6211 00	eax1 	pr6|100
000230  aa   004000 4310 07	fld  	2048,dl
000231  aa  6 00044 3701 20	epp4 	pr6|36,*
000232  la  4 00024 3521 20	epp2 	pr4|20,*		level$get
000233  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000234  aa  6 00142 2361 00	ldq  	pr6|98
000235  aa   000052 7370 00	lls  	42
000236  aa  6 00112 3735 20	epp7 	pr6|74,*		dtep
000237  aa  7 00013 6751 00	era  	pr7|11		dte.ring
000240  aa   001700 3750 07	ana  	960,dl
000241  aa  7 00013 6551 00	ersa 	pr7|11		dte.ring
						STATEMENT 1 ON LINE 92
	dte.priv = priv;

000242  aa  6 00032 3715 20	epp5 	pr6|26,*
000243  aa  5 00006 2351 20	lda  	pr5|6,*		priv
000244  aa   000001 7710 00	arl  	1
000245  aa  7 00001 6751 00	era  	pr7|1		dte.priv
000246  aa   200000 3750 03	ana  	65536,du
000247  aa  7 00001 6551 00	ersa 	pr7|1		dte.priv
						STATEMENT 1 ON LINE 93
	dte.max_bound = divide (id.max_buffer_len, 512, 10, 0);

000250  aa  6 00106 3535 20	epp3 	pr6|70,*		idp
000251  aa  3 00003 2361 00	ldq  	pr3|3		id.max_buffer_len
000252  aa   001000 5060 07	div  	512,dl
000253  aa   000060 7370 00	lls  	48
000254  aa  7 00010 6751 00	era  	pr7|8		dte.max_bound
000255  aa   000327 3750 04	ana  	215,ic		000604 = 000037770000
000256  aa  7 00010 6551 00	ersa 	pr7|8		dte.max_bound
						STATEMENT 1 ON LINE 94
	dte.max_time = id.max_time;

000257  aa  3 00004 2361 00	ldq  	pr3|4		id.max_time
000260  aa  7 00014 5521 04	stbq 	pr7|12,04		dte.max_time
						STATEMENT 1 ON LINE 96
	dte.gtep = rel (gtep);

000261  aa  6 00110 3515 20	epp1 	pr6|72,*		gtep
000262  aa  1 00000 6351 00	eaa  	pr1|0
000263  aa   000022 7710 00	arl  	18
000264  aa  7 00000 5511 14	stba 	pr7|0,14		dte.gtep
						STATEMENT 1 ON LINE 97
	dte.active = "0"b;

000265  aa   000316 2350 04	lda  	206,ic		000603 = 577777777777
000266  aa  7 00013 3551 00	ansa 	pr7|11		dte.active
						STATEMENT 1 ON LINE 98
	dte.not_connecting = "1"b;

000267  aa   100000 2350 03	lda  	32768,du
000270  aa  7 00013 2551 00	orsa 	pr7|11		dte.not_connecting
						STATEMENT 1 ON LINE 99
	dte.wire_buffer = wire_buffer;

000271  aa  5 00012 2351 20	lda  	pr5|10,*		wire_buffer
000272  aa   000005 7710 00	arl  	5
000273  aa  7 00013 6751 00	era  	pr7|11		dte.wire_buffer
000274  aa   010000 3750 03	ana  	4096,du
000275  aa  7 00013 6551 00	ersa 	pr7|11		dte.wire_buffer
						STATEMENT 1 ON LINE 100
	dte.special_interrupt = "0"b;

000276  aa   000304 2350 04	lda  	196,ic		000602 = 773777777777
000277  aa  7 00013 3551 00	ansa 	pr7|11		dte.special_interrupt
						STATEMENT 1 ON LINE 101
	dte.buffer_bound = 0;

000300  aa   000000 2350 03	lda  	0,du
000301  aa  7 00010 6751 00	era  	pr7|8		dte.buffer_bound
000302  aa   377700 3750 03	ana  	131008,du
000303  aa  7 00010 6551 00	ersa 	pr7|8		dte.buffer_bound
						STATEMENT 1 ON LINE 102
	dte.buffer_index = 0;

000304  aa   000000 2350 03	lda  	0,du
000305  aa  7 00010 7511 03	stca 	pr7|8,03		dte.buffer_index
						STATEMENT 1 ON LINE 103
	dte.time = id.default_time;

000306  aa  3 00002 2361 00	ldq  	pr3|2		id.default_time
000307  aa   000055 7370 00	lls  	45
000310  aa  7 00014 5511 10	stba 	pr7|12,10		dte.time
						STATEMENT 1 ON LINE 104
	dte.device = device;

000311  aa  5 00004 3515 20	epp1 	pr5|4,*
000312  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000313  aa  1 00000 00 0006	descb	pr1|0,6		device
000314  aa  7 00013 63 0006	descb	pr7|11(30),6	dte.device
						STATEMENT 1 ON LINE 105
	dte.priv = dte.priv;

000315  aa  7 00001 2351 00	lda  	pr7|1		dte.priv
000316  aa  7 00001 6751 00	era  	pr7|1		dte.priv
000317  aa   200000 3750 03	ana  	65536,du
000320  aa  7 00001 6551 00	ersa 	pr7|1		dte.priv
						STATEMENT 1 ON LINE 106
	dte.channel_required = "";

000321  aa   777473 2370 04	ldaq 	-197,ic		000014 = 040040040040 040040040040
000322  aa  7 00002 7551 00	sta  	pr7|2		dte.channel_required
000323  aa  7 00003 7561 00	stq  	pr7|3		dte.channel_required
						STATEMENT 1 ON LINE 107
	dte.eventid = eventid;

000324  aa  5 00014 2371 20	ldaq 	pr5|12,*		eventid
000325  aa  7 00006 7571 00	staq 	pr7|6		dte.eventid
						STATEMENT 1 ON LINE 108
	dte.processid = pds$process_id;

000326  aa  6 00044 3701 20	epp4 	pr6|36,*
000327  la  4 00014 2351 20	lda  	pr4|12,*		pds$process_id
000330  aa  7 00012 7551 00	sta  	pr7|10		dte.processid
						STATEMENT 1 ON LINE 109
	dte.log_status_cnt = "0"b;

000331  aa   000250 2350 04	lda  	168,ic		000601 = 775777777777
000332  aa  7 00013 3551 00	ansa 	pr7|11		dte.log_status_cnt
						STATEMENT 1 ON LINE 110
	dte.using = "0"b;

000333  aa   000245 2350 04	lda  	165,ic		000600 = 776777777777
000334  aa  7 00013 3551 00	ansa 	pr7|11		dte.using
						STATEMENT 1 ON LINE 111
	dte.deleting = "0"b;

000335  aa   000242 2350 04	lda  	162,ic		000577 = 777377777777
000336  aa  7 00013 3551 00	ansa 	pr7|11		dte.deleting
						STATEMENT 1 ON LINE 112
	dte.log_status = "0"b;

000337  aa   777453 2370 04	ldaq 	-213,ic		000012 = 000000000000 000000000000
000340  aa  7 00030 7551 00	sta  	pr7|24		dte.log_status
000341  aa  7 00031 7561 00	stq  	pr7|25		dte.log_status
						STATEMENT 1 ON LINE 113
	dte.reading_detailed_status = "0"b;

000342  aa   000234 2350 04	lda  	156,ic		000576 = 777577777777
000343  aa  7 00013 3551 00	ansa 	pr7|11		dte.reading_detailed_status
						STATEMENT 1 ON LINE 114
	dte.detailed_status_valid = "0"b;

000344  aa   000231 2350 04	lda  	153,ic		000575 = 777677777777
000345  aa  7 00013 3551 00	ansa 	pr7|11		dte.detailed_status_valid
						STATEMENT 1 ON LINE 115
	unspec (dte.detailed_status) = "0"b;

000346  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000347  aa   000000 00 0000	desc9a	0,0
000350  aa  7 00021 00 0030	desc9a	pr7|17,24
						STATEMENT 1 ON LINE 116
	unspec (dte.log_detailed_status) = "0"b;

000351  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000352  aa   000000 00 0000	desc9a	0,0
000353  aa  7 00032 00 0030	desc9a	pr7|26,24
						STATEMENT 1 ON LINE 118
	if int_proc ^= null () then do;

000354  aa  5 00010 2371 20	ldaq 	pr5|8,*		int_proc
000355  aa   777433 6770 04	eraq 	-229,ic		000010 = 077777000043 000001000000
000356  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000357  aa   000011 6000 04	tze  	9,ic		000370
						STATEMENT 1 ON LINE 119
	     stp = addr (dte.sc);

000360  aa  7 00027 3521 00	epp2 	pr7|23		dte.sc
000361  aa  6 00114 2521 00	spri2	pr6|76		stp
						STATEMENT 1 ON LINE 120
	     stproc.ptr = int_proc;

000362  aa  5 00010 3535 20	epp3 	pr5|8,*		int_proc
000363  aa  3 00000 3535 20	epp3 	pr3|0,*		int_proc
000364  aa  2 00000 5431 00	sprp3	pr2|0		stproc.ptr
						STATEMENT 1 ON LINE 121
	     dte.hardcore = "1"b;

000365  aa   020000 2350 03	lda  	8192,du
000366  aa  7 00013 2551 00	orsa 	pr7|11		dte.hardcore
						STATEMENT 1 ON LINE 122
	end;

000367  aa   000004 7100 04	tra  	4,ic		000373
						STATEMENT 1 ON LINE 123
	else do;

						STATEMENT 1 ON LINE 124
	     dte.sc = "0"b;

000370  aa  7 00027 4501 00	stz  	pr7|23		dte.sc
						STATEMENT 1 ON LINE 125
	     dte.hardcore = "0"b;

000371  aa   000203 2350 04	lda  	131,ic		000574 = 757777777777
000372  aa  7 00013 3551 00	ansa 	pr7|11		dte.hardcore
						STATEMENT 1 ON LINE 126
	end;

						STATEMENT 1 ON LINE 128
	dte.in_use = ^gte.suspend_devices;

000373  aa  6 00110 3535 20	epp3 	pr6|72,*		gtep
000374  aa  3 00001 2351 00	lda  	pr3|1		gte.suspend_devices
000375  aa   000004 7350 00	als  	4
000376  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000377  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000400  aa  7 00013 6751 00	era  	pr7|11		dte.in_use
000401  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
000402  aa  7 00013 6551 00	ersa 	pr7|11		dte.in_use
						STATEMENT 1 ON LINE 138
	gte.ndev = gte.ndev + 1;

000403  aa  3 00001 2351 00	lda  	pr3|1		gte.ndev
000404  aa   000022 7350 00	als  	18
000405  aa   000066 7330 00	lrs  	54
000406  aa   000001 0760 07	adq  	1,dl
000407  aa  3 00001 5521 14	stbq 	pr3|1,14		gte.ndev
						STATEMENT 1 ON LINE 140
	id.addev_count = fixed (id.addev_count + 1, 17);

000410  aa  6 00106 3515 20	epp1 	pr6|70,*		idp
000411  aa  1 00010 2361 00	ldq  	pr1|8		id.addev_count
000412  aa   000001 0760 07	adq  	1,dl
000413  aa  1 00010 7561 00	stq  	pr1|8		id.addev_count
						STATEMENT 1 ON LINE 142
	dterp = gte.dtep;

000414  aa  3 00000 2351 00	lda  	pr3|0		gte.dtep
000415  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000416  aa  6 00101 7551 00	sta  	pr6|65		dterp
						STATEMENT 1 ON LINE 143
	if dterp then do;

000417  aa   000011 6000 04	tze  	9,ic		000430
						STATEMENT 1 ON LINE 144
	     prev_dtep = ptr (idp, dterp);

000420  aa  1 00000 3521 00	epp2 	pr1|0
000421  aa   000000 3120 01	eawp2	0,au
000422  aa  6 00102 2521 00	spri2	pr6|66		prev_dtep
						STATEMENT 1 ON LINE 145
	     dte.next_dte = prev_dtep -> dte.next_dte;

000423  aa  2 00000 2351 00	lda  	pr2|0		dte.next_dte
000424  aa  7 00000 5511 60	stba 	pr7|0,60		dte.next_dte
						STATEMENT 1 ON LINE 146
	     prev_dtep -> dte.next_dte = rel (dtep);

000425  aa  7 00000 6351 00	eaa  	pr7|0
000426  aa  2 00000 5511 60	stba 	pr2|0,60		dte.next_dte
						STATEMENT 1 ON LINE 147
	end;

000427  aa   000004 7100 04	tra  	4,ic		000433
						STATEMENT 1 ON LINE 148
	else do;

						STATEMENT 1 ON LINE 149
	     dte.next_dte,				/* Make entry point to itself. */
		gte.dtep = rel (dtep);

000430  aa  7 00000 6351 00	eaa  	pr7|0
000431  aa  7 00000 5511 60	stba 	pr7|0,60		dte.next_dte
000432  aa  3 00000 5511 60	stba 	pr3|0,60		gte.dtep
						STATEMENT 1 ON LINE 151
	end;

						STATEMENT 1 ON LINE 153
	return (dtx);

000433  aa  6 00116 2361 00	ldq  	pr6|78
000434  aa   000005 6010 04	tnz  	5,ic		000441
000435  aa   000027 7260 07	lxl6 	23,dl
000436  aa   777360 3520 04	epp2 	-272,ic		000016 = 162145164165
000437  aa  0 00716 7001 00	tsx0 	pr0|462		signal
000440  aa  0 00631 7101 00	tra  	pr0|409		return
000441  aa  6 00100 2361 00	ldq  	pr6|64		dtx
000442  aa  5 00020 7561 20	stq  	pr5|16,*
000443  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ioi_unassign_dte                                   STATEMENT 1 ON LINE 156
ioi_unassign_dte:
     entry (arg_dtep);

000444  at     000001000006
000445  ta     000444000000
000446  da     000125300000
000447  aa   000160 6270 00	eax7 	112
000450  aa  7 00034 3521 20	epp2 	pr7|28,*
000451  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000452  aa     000002000000
000453  aa     000000000000
000454  aa  6 00116 4501 00	stz  	pr6|78
						STATEMENT 1 ON LINE 162
	idp = addr (ioi_data$);

000455  aa  6 00044 3701 20	epp4 	pr6|36,*
000456  la  4 00026 3521 20	epp2 	pr4|22,*		ioi_data$
000457  aa  6 00106 2521 00	spri2	pr6|70		idp
						STATEMENT 1 ON LINE 163
	dtep = arg_dtep;

000460  aa  6 00032 3735 20	epp7 	pr6|26,*
000461  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_dtep
000462  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_dtep
000463  aa  6 00112 6515 00	spri5	pr6|74		dtep
						STATEMENT 1 ON LINE 164
	gtep = ptr (idp, dte.gtep);

000464  aa  5 00000 2351 00	lda  	pr5|0		dte.gtep
000465  aa   000022 7350 00	als  	18
000466  aa  2 00000 3515 00	epp1 	pr2|0
000467  aa   000000 3114 01	eawp1	0,au
000470  aa  6 00110 2515 00	spri1	pr6|72		gtep
						STATEMENT 1 ON LINE 166
	call ioi_log_status$unassign_flush (dtep);

000471  aa  6 00112 3521 00	epp2 	pr6|74		dtep
000472  aa  6 00146 2521 00	spri2	pr6|102
000473  aa  6 00144 6211 00	eax1 	pr6|100
000474  aa   004000 4310 07	fld  	2048,dl
000475  la  4 00022 3521 20	epp2 	pr4|18,*		ioi_log_status$unassign_flush
000476  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 179
	dte.in_use = "0"b;

000477  aa   000074 2350 04	lda  	60,ic		000573 = 377777777777
000500  aa  6 00112 3735 20	epp7 	pr6|74,*		dtep
000501  aa  7 00013 3551 00	ansa 	pr7|11		dte.in_use
						STATEMENT 1 ON LINE 181
	dterp = dte.next_dte;

000502  aa  7 00000 2351 00	lda  	pr7|0		dte.next_dte
000503  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000504  aa  6 00101 7551 00	sta  	pr6|65		dterp
						STATEMENT 1 ON LINE 182
	prev_dtep = null ();

000505  aa   777303 2370 04	ldaq 	-317,ic		000010 = 077777000043 000001000000
000506  aa  6 00102 7571 00	staq 	pr6|66		prev_dtep
						STATEMENT 1 ON LINE 183
	do while (dterp ^= rel (dtep));

000507  aa  6 00112 3735 20	epp7 	pr6|74,*		dtep
000510  aa  7 00000 6351 00	eaa  	pr7|0
000511  aa  6 00142 7551 00	sta  	pr6|98
000512  aa  6 00101 2351 00	lda  	pr6|65		dterp
000513  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000514  aa  6 00142 1151 00	cmpa 	pr6|98
000515  aa   000010 6000 04	tze  	8,ic		000525
						STATEMENT 1 ON LINE 184
	     prev_dtep = ptr (idp, dterp);

000516  aa  6 00106 3521 20	epp2 	pr6|70,*		idp
000517  aa   000000 3120 01	eawp2	0,au
000520  aa  6 00102 2521 00	spri2	pr6|66		prev_dtep
						STATEMENT 1 ON LINE 185
	     dterp = prev_dtep -> dte.next_dte;

000521  aa  2 00000 2351 00	lda  	pr2|0		dte.next_dte
000522  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000523  aa  6 00101 7551 00	sta  	pr6|65		dterp
						STATEMENT 1 ON LINE 186
	end;

000524  aa   777763 7100 04	tra  	-13,ic		000507
						STATEMENT 1 ON LINE 188
	if prev_dtep = null () then			/* If only one item in circular list ... */
	     gte.dtep = "0"b;

000525  aa  6 00102 2371 00	ldaq 	pr6|66		prev_dtep
000526  aa   777262 6770 04	eraq 	-334,ic		000010 = 077777000043 000001000000
000527  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000530  aa   000004 6010 04	tnz  	4,ic		000534
000531  aa   777777 2350 07	lda  	262143,dl
000532  aa  6 00110 3551 20	ansa 	pr6|72,*		gte.dtep
000533  aa   000004 7100 04	tra  	4,ic		000537
						STATEMENT 1 ON LINE 190
	else					/* If more than one item ... */
	     prev_dtep -> dte.next_dte = dte.next_dte;

000534  aa  7 00000 2351 00	lda  	pr7|0		dte.next_dte
000535  aa  6 00102 3715 20	epp5 	pr6|66,*		dte.next_dte
000536  aa  5 00000 5511 60	stba 	pr5|0,60		dte.next_dte
						STATEMENT 1 ON LINE 193
	dterp = ioi_util$step (gte.dtep);

000537  aa  6 00110 3521 20	epp2 	pr6|72,*		gte.dtep
000540  aa  6 00146 2521 00	spri2	pr6|102
000541  aa  6 00101 3521 00	epp2 	pr6|65		dterp
000542  aa  6 00150 2521 00	spri2	pr6|104
000543  aa  6 00144 6211 00	eax1 	pr6|100
000544  aa   010000 4310 07	fld  	4096,dl
000545  aa  6 00044 3701 20	epp4 	pr6|36,*
000546  la  4 00020 3521 20	epp2 	pr4|16,*		ioi_util$step
000547  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 195
	do while (id.select_count ^= 0);

000550  aa  6 00106 3735 20	epp7 	pr6|70,*		idp
000551  aa  7 00007 2361 00	ldq  	pr7|7		id.select_count
000552  aa   000002 6000 04	tze  	2,ic		000554
						STATEMENT 1 ON LINE 196
	end;

000553  aa   777775 7100 04	tra  	-3,ic		000550
						STATEMENT 1 ON LINE 198
	dte.allocated = "0"b;

000554  aa   000017 2350 04	lda  	15,ic		000573 = 377777777777
000555  aa  6 00112 3715 20	epp5 	pr6|74,*		dtep
000556  aa  5 00001 3551 00	ansa 	pr5|1		dte.allocated
						STATEMENT 1 ON LINE 200
	gte.ndev = gte.ndev - 1;

000557  aa  6 00110 3535 20	epp3 	pr6|72,*		gtep
000560  aa  3 00001 2351 00	lda  	pr3|1		gte.ndev
000561  aa   000022 7350 00	als  	18
000562  aa   000066 7330 00	lrs  	54
000563  aa   000001 1760 07	sbq  	1,dl
000564  aa  3 00001 5521 14	stbq 	pr3|1,14		gte.ndev
						STATEMENT 1 ON LINE 202
	return;

000565  aa  6 00116 2361 00	ldq  	pr6|78
000566  aa  0 00631 6001 00	tze  	pr0|409		return
000567  aa   000027 7260 07	lxl6 	23,dl
000570  aa   777226 3520 04	epp2 	-362,ic		000016 = 162145164165
000571  aa  0 00716 7001 00	tsx0 	pr0|462		signal
000572  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 205
     end ioi_assign_dte;

  END PROCEDURE ioi_assign_dte


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
