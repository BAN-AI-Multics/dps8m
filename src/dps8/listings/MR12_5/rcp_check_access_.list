	COMPILATION LISTING OF SEGMENT rcp_check_access_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1415.1 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 rcp_check_access_: proc (rsc_type_arg, rsc_name, group_id, level, eff_access, code);
       12 
       13 
       14 /*
       15*
       16*   This procedure is called to obtain a user's access to a resource.  The resource may be either a device
       17*   or a volume.  The access is determined by the "old" method of checking >sc1>rcp for device ACSs if
       18*   resource management is not enabled.  If it is enabled, then RCPRM is called upon to make the decision.
       19*
       20*
       21*   Initially coded 3/79 by Michael R. Jordan for MR7.0R
       22*
       23*
       24**/
       25 
       26 /*		PARAMETERS		*/
       27 
       28 
       29 dcl  authorization bit (72) aligned;			/* Process' authorization. */
       30 dcl  code fixed bin (35);				/* Error code. */
       31 dcl  eff_access bit (3) aligned;			/* The user's effective access. */
       32 dcl  group_id char (32);				/* User requesting this resource. */
       33 dcl  level fixed bin;				/* User's validation level. */
       34 dcl  rsc_name char (32);				/* Resource rsc_name. */
       35 dcl  rsc_type_arg char (32);				/* Resource type. */
       36 
       37 
       38 /*		CONSTANTS			*/
       39 
       40 
       41 dcl  NULL bit (3) static internal options (constant) init ("000"b);
       42 dcl  REW bit (3) static internal options (constant) init ("111"b);
       43 dcl  RW bit (3) static internal options (constant) init ("101"b);
       44 
       45 
       46 /*		AUTOMATIC			*/
       47 
       48 
       49 dcl  actual_access fixed bin (5);			/* User's actual access to the ACS. */
       50 dcl  device_found bit (1);				/* ON => we found the device we're looking for. */
       51 dcl  device_off bit (18);				/* Offset in rcp_data of the device entry. */
       52 dcl  i fixed bin;					/* Just an index. */
       53 dcl  reserve_flag bit (1);				/* ON => we came in through the bathroom window. */
       54 dcl  rsc_type char (32);				/* primary type of rsc_type_arg */
       55 
       56 
       57 /*		ERROR  CODES		*/
       58 
       59 
       60 dcl  error_table_$action_not_performed fixed bin (35) ext;
       61 dcl  error_table_$resource_type_unknown fixed bin (35) ext;
       62 dcl  error_table_$resource_unknown fixed bin (35) ext;
       63 
       64 
       65 /*		BUILTINS			*/
       66 
       67 
       68 dcl  addr builtin;
       69 dcl  bit builtin;
       70 dcl  hbound builtin;
       71 dcl  ptr builtin;
       72 dcl  size builtin;
       73 dcl  string builtin;
       74 dcl  substr builtin;
       75 
       76 
       77 /*		ENTRIES  CALLED		*/
       78 
       79 
       80 dcl  get_authorization_ entry () returns (bit (72) aligned);
       81 dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
       82 dcl  rcp_pointers_$com_seg entry () returns (ptr);
       83 dcl  rcp_pointers_$data entry () returns (ptr);
       84 dcl  rcprm_find_resource_$reserve entry (ptr, char (*), ptr, fixed bin (35));
       85 dcl  rcprm_find_resource_$reserve_proxy entry (ptr, char (32), ptr, char (32), bit (72) aligned, fixed bin (35));
       86 dcl  rcprm_find_resource_$status entry (pointer, char (*), fixed bin (35));
       87 dcl  resource_info_$get_primary_type entry (char (*), char (*), fixed bin (35));
       88 
  1     1 /*	Begin  include file ... rcp_data.incl.pl1
  1     2*   *
  1     3*   *	Created on 09/06/74 by Bill Silver.
  1     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  1     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  1     6*   *	It contains information about all of the devices and volumes managed by RCP.
  1     7*   *	This include file references rcp_com_seg.incl.pl1.
  1     8*
  1     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  1    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  1    11*   *	Modified on 12/09/78 to add removable media bit.
  1    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  1    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  1    14**/
  1    15 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  1    16 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  1    17 dcl  device_ptr ptr;				/* Points to a device entry. */
  1    18 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  1    19 
  1    20 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  1    21     2 lock_info like lock_info,			/* Data used to lock this segment. */
  1    22     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  1    23     2 modes like rcp_init_flags unaligned,
  1    24     2 tot_dtypes fixed bin,				/* Number of known device types. */
  1    25     2 tot_devices fixed bin,				/* Total number of devices configured. */
  1    26     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  1    27     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  1    28     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  1    29     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  1    30     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  1    31     2 accounting_pid bit (36),			/* ID of accounting process */
  1    32     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  1    33     2 pad (7) fixed bin,
  1    34     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  1    35      like dtype,					/* See structure below. */
  1    36     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  1    37      like device,					/* See structure below. */
  1    38     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  1    39      like volume,					/* See structure below. */
  1    40     2 end bit (36) aligned;				/* End of rcp_data. */
  1    41 
  1    42 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  1    43     2 device_type char (32),				/* Name of this device type. */
  1    44     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  1    45     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  1    46     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  1    47     2 first_off bit (18),				/* Offset of first device entry. */
  1    48     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  1    49 
  1    50 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  1    51     2 device_name char (8),				/* Name of device associated with this entry. */
  1    52     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  1    53     2 dtypex fixed bin,				/* Device type index. */
  1    54     2 model fixed bin,				/* Device model number. */
  1    55     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    56     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    57     2 state_time fixed bin (71),			/* Time device put into current state. */
  1    58     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  1    59*						   3 => storage system, 4 => reserved */
  1    60 
  1    61 /*	*	*	*	*	** Following fields are unique to device entry. */
  1    62 
  1    63     2 unassign_state fixed bin,			/* State to return when unassigning. */
  1    64     2 acs_name char (12),				/* Entry name of ACS for this device. */
  1    65     2 next_off bit (18),				/* Offset of next entry for this device type. */
  1    66     2 iom_num fixed bin,				/* IOM number for this device. */
  1    67     2 chan_num fixed bin,				/* Channel number for this device. */
  1    68     2 num_channels fixed bin,				/* Num channels that may address device. */
  1    69     2 flags,					/* Special info flags. */
  1    70      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  1    71       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  1    72       3 reservable bit (1),				/* ON => may be reserved for system process. */
  1    73       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  1    74       3 mounting bit (1),				/* ON => mount pending. */
  1    75       3 writing bit (1),				/* ON => mounting for writing. */
  1    76       3 attached bit (1) unal,			/* ON => device is attached. */
  1    77       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  1    78       3 unused bit (28)) unal,
  1    79     2 process_id bit (36),				/* ID of assigned process. */
  1    80     2 group_id char (32),				/* Process group ID. */
  1    81     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  1    82     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  1    83     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  1    84     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  1    85     2 reservation_id fixed bin (71),
  1    86     2 reserved_by char (32),				/* Who made this reservation. */
  1    87     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  1    88 
  1    89 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  1    90     2 process_id bit (36),				/* "0"b => unassigned. */
  1    91     2 volume_name char (32),				/* Volume name. */
  1    92     2 vtypex fixed bin,				/* Volume type index. */
  1    93     2 group_id char (32),				/* This is used for the reserved_for field. */
  1    94     2 reserved_by char (32),
  1    95     2 reservation_id fixed bin (71),
  1    96     2 state_time fixed bin (71),			/* Same as for a device. */
  1    97     2 state fixed bin,				/* Same as for a device. */
  1    98     2 unassign_state fixed bin,			/* State to return when unassigning. */
  1    99     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  1   100 
  2     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2     2 
  2     3 /* Created on 04/24/78 by Michael R. Jordan */
  2     4 /* Modified 04/10/79 by C. D. Tavares */
  2     5 
  2     6 dcl  rifp ptr;
  2     7 
  2     8 dcl 1 rcp_init_flags based (rifp),
  2     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  2    10     2 pad1 bit (2) unaligned,				/* obsolete */
  2    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  2    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  2    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  2    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  2    15 
  2    16 dcl (No_authentication initial (0),
  2    17      Nominal_authentication initial (1),
  2    18      Automatic_authentication initial (2),
  2    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  2    20 
  2    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  2    22     ("none", "nominal", "automatic", "manual");
  2    23 
  2    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  1   101 
  1   102 
  1   103 /*	End of include file ... rcp_data.incl.pl1	*/
       89 
       90 
  3     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  3     2*   *
  3     3*   *	Created on 11/20/74 by Bill Silver.
  3     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  3     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  3     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  3     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  3     8*   *	This include file defines the Resource Control Package communication segment.
  3     9*   *	This segment is used to communicate requests between the various internal
  3    10*   *	parts of RCP.
  3    11**/
  3    12 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  3    13 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  3    14 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  3    15 
  3    16 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  3    17    (2 id_count fixed bin (17),			/* Unique count index. */
  3    18     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  3    19 
  3    20 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  3    21     2 lock_info like lock_info,			/* Data used to lock this segment. */
  3    22     2 ws_maxs (7) fixed bin (19),			/* Max IOI workspace size in words. */
  3    23     2 ws_pmaxs (7) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  3    24     2 to_maxs (7) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  3    25     2 sys_directory char (32),			/* Directory  used to define a system process. */
  3    26     2 sys_acs char (32),				/* Entry name used to define a system process. */
  3    27     2 acs_directory char (32),			/* Directory containing device ACSs. */
  3    28     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  3    29     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  3    30     2 num_entries fixed bin,				/* Total number of entries. */
  3    31     2 first_free_off bit (18),			/* Offset of first free entry. */
  3    32     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  3    33      like rcse,					/* See structure below. */
  3    34     2 end bit (36);					/* End of rcp_com_seg. */
  3    35 
  3    36 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  3    37     2 lock bit (36),				/* The lock itself. */
  3    38     2 num_locks fixed bin (35),			/* Number of times locked. */
  3    39     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  3    40     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  3    41     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  3    42     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  3    43     2 starting_time fixed bin (71);			/* Time metering started. */
  3    44 
  3    45 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  3    46     2 device_name char (8),				/* Name of device associated with this entry. */
  3    47     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  3    48     2 dtypex fixed bin,				/* Device type index. */
  3    49     2 model fixed bin,				/* Device model number. */
  3    50     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  3    51     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  3    52     2 state_time fixed bin (71),			/* Time device put into current state. */
  3    53     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  3    54 						/* 3 - attaching  4 - attached   5 - completed. */
  3    55 
  3    56 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  3    57     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  3    58     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  3    59     2 user_off bit (18),				/* Offset of next entry in user list. */
  3    60     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  3    61     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  3    62     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  3    63     2 caller_level fixed bin,				/* Caller's validation level. */
  3    64     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  3    65     2 flags,					/* Special info flags. */
  3    66      (3 device bit (1),				/* ON => assigning a specific device. */
  3    67       3 priv bit (1),				/* ON => attached with IOI privilege. */
  3    68       3 system bit (1),				/* ON => assigned to a system process. */
  3    69       3 t_and_d bit (1),				/* ON => T&D attachment. */
  3    70       3 volume bit (1),				/* ON => volume associated with this device. */
  3    71       3 writing bit (1),				/* ON => writing on volume. */
  3    72       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  3    73       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  3    74       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  3    75       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  3    76       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  3    77       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  3    78       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  3    79       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  3    80       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  3    81       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  3    82       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  3    83       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  3    84       3 unused bit (9),
  3    85       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  3    86       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  3    87     2 rcp_id bit (36),				/* ID of this entry. */
  3    88     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  3    89     2 process_id bit (36),				/* ID of calling process. */
  3    90     2 group_id char (32),				/* Group ID of calling process. */
  3    91     2 ecode fixed bin (35),				/* Assignment error code. */
  3    92     2 version_num fixed bin,				/* Device info version number. */
  3    93     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  3    94     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  3    95     2 ioi_index fixed bin,				/* IOI device index. */
  3    96     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  3    97     2 caller_comment char (64);			/* Caller's comment. */
  3    98 
  3    99 /*	End of include file ... rcp_com_seg.incl.pl1	*/
       91 
       92 
  4     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  4     2*   *
  4     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  4     4*   *
  4     5*   *	This include file defines the official RCP resource types.
  4     6*   *	The array of names is indexed by the corresponding device type.
  4     7*   *
  4     8**/
  4     9 
  4    10 
  4    11 dcl  DEVICE_TYPE (7) char (32)
  4    12      internal static options (constant)
  4    13      init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special");
  4    14 
  4    15 dcl  NUM_QUALIFIERS (7) fixed bin			/* Number of qualifiers for each device type. */
  4    16      internal static init (3, 0, 0, 2, 0, 0, 0);
  4    17 
  4    18 dcl  VOLUME_TYPE (7) char (32)
  4    19      internal static options (constant)
  4    20      init ("tape_vol", "disk_vol", "", "", "", "", "");
  4    21 
  4    22 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  4    23 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  4    24 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  4    25 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  4    26 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  4    27 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  4    28 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  4    29 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  4    30 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  4    31 
  4    32 
  4    33 /*	End include file ... rcp_resource_types.incl.pl1 */
       93 
       94 
  5     1 /* --------------- BEGIN include file resource_control_desc.incl.pl1 --------------- */
  5     2 
  5     3 /* Written by R.J.C. Kissel 3/78. */
  5     4 /* Modified 09/28/78 by C. D. Tavares */
  5     5 
  5     6 dcl 1 resource_descriptions based (resource_desc_ptr) aligned,
  5     7     2 version_no fixed bin,				/* caller must set this to resource_desc_version_1 */
  5     8     2 n_items fixed bin,				/* Number of resources described by this structure. */
  5     9     2 item (Resource_count refer (resource_descriptions.n_items)) aligned,
  5    10       3 type char (32),				/* e.g., "tape_drive" */
  5    11       3 name char (32),				/* e.g., "tapa_03" */
  5    12       3 uid bit (36),				/* The resource unique id. */
  5    13       3 potential_attributes bit (72),			/* resource's permissible attributes */
  5    14       3 attributes (2) bit (72),			/* RCP attribute description (output) */
  5    15       3 desired_attributes (4) bit (72),		/* desired attributes (input) */
  5    16       3 potential_aim_range (2) bit (72),		/* Lowest and highest possible AIM bounds for resource */
  5    17       3 aim_range (2) bit (72),			/* Current AIM range */
  5    18       3 owner char (32),				/* e.g., "Smith.Project" */
  5    19       3 acs_path char (168),				/* Access control segment pathname. */
  5    20       3 location char (168),				/* String describing location in unusual cases */
  5    21       3 comment char (168),				/* User-settable comment string */
  5    22       3 charge_type char (32),			/* accounting identifier for this resource */
  5    23       3 rew bit (3) unaligned,			/* user's effective access to resource */
  5    24       3 (usage_lock,				/* This resource may not be acquired or used. */
  5    25          release_lock,				/* The owner is not allowed to release the resource. */
  5    26          awaiting_clear,				/* Resource awaiting manual clear */
  5    27          user_alloc) bit (1) unaligned,			/* User claims volume contains useful data */
  5    28       3 pad2 bit (29) unaligned,			/* Ignored field. */
  5    29       3 given aligned,				/* each of these bits says the corresponding */
  5    30 						/* item is significant on input */
  5    31        (4 (name,
  5    32 	 uid,
  5    33 	 potential_attributes,
  5    34 	 desired_attributes,
  5    35 	 potential_aim_range,
  5    36 	 aim_range,
  5    37 	 owner,
  5    38 	 acs_path,
  5    39 	 location,
  5    40 	 comment,
  5    41 	 charge_type,
  5    42 	 usage_lock,
  5    43 	 release_lock,
  5    44 	 user_alloc) bit (1),
  5    45         4 pad1 bit (22)) unaligned,
  5    46       3 state bit (36) aligned,			/* For use of resource_control_ only */
  5    47       3 status_code fixed bin (35);			/* Standard system status code for this resource. */
  5    48 
  5    49 
  5    50 /* Note that the reservation description must always be used with a resource
  5    51*   description structure.  When they are used together the two structures must
  5    52*   have the same number of entries, i.e. Resource_count is the same for both. */
  5    53 
  5    54 
  5    55 dcl 1 reservation_description based (resource_res_ptr) aligned,
  5    56     2 version_no fixed bin,				/* The version number for this structure. */
  5    57     2 reserved_for char (32),				/* Group id of reserved for process. */
  5    58     2 reserved_by char (32),				/* Group id of reserved by process. */
  5    59     2 reservation_id fixed bin (71),			/* Reservation id of this reservation group. */
  5    60     2 group_starting_time fixed bin (71),		/* Starting time for this reservation group. */
  5    61     2 asap_duration fixed bin (71),			/* Duration after which as soon as possible is no longer good. */
  5    62     2 flags aligned,
  5    63      (3 auto_expire bit (1),				/* Should reservation expire when this process terminates. */
  5    64       3 asap bit (1),				/* Make this reservation group as soon as possible. */
  5    65       3 rel bit (1),				/* Times are relative/absolute. */
  5    66       3 sec bit (1)) unaligned,			/* Times are in sec/microsec. */
  5    67     2 n_items fixed bin,				/* Number of resources reserved in this group. */
  5    68     2 reservation_group (Resource_count refer (reservation_description.n_items)),
  5    69       3 starting_time fixed bin (71),			/* When this resource res. starts in the group. */
  5    70       3 duration fixed bin (71);			/* Duration of this resource res. in the group. */
  5    71 
  5    72 dcl (resource_desc_ptr,
  5    73      resource_res_ptr) pointer;
  5    74 
  5    75 dcl (resource_desc_version_1 initial (1),
  5    76      resource_res_version_1 initial (1)) internal static options (constant);
  5    77 
  5    78 dcl  Resource_count fixed bin;			/* The number of resources described in the structures. */
  5    79 
  5    80 /* ---------------- END include file resource_control_desc.incl.pl1 ---------------- */
       95 
       96 
       97 	reserve_flag = "0"b;			/* Not the reserve entry. */
       98 	goto JOIN;
       99 
      100 
      101 reserve:	entry (rsc_type_arg, rsc_name, group_id, level, authorization, eff_access, code);
      102 
      103 
      104 	reserve_flag = "1"b;
      105 
      106 
      107 JOIN:
      108 
      109 
      110 /*
      111*
      112*   Special case the Initializer.  He may call us before we're ready to handle any of this
      113*   and he is almighty anyway, so let him have it.
      114*
      115**/
      116 
      117 
      118 	if group_id = "Initializer.SysDaemon.z"		/* Special case the Initializer. */
      119 	then do;
      120 	     eff_access = REW;			/* Any access he wants. */
      121 	     return;
      122 	end;
      123 
      124 
      125 /*
      126*
      127*   Get set up.
      128*
      129**/
      130 
      131 
      132 	rcpd_ptr = rcp_pointers_$data ();
      133 	rcs_ptr = rcp_pointers_$com_seg ();		/* Get ptr to rcp_com_seg. */
      134 	code = 0;
      135 
      136 
      137 /*
      138*
      139*   First we must determine whether resource management is to be called into the act.
      140*
      141**/
      142 
      143 
      144 	if rcpd.modes.resource_mgmt_enabled then do;
      145 	     Resource_count = 1;
      146 	     begin;
      147 
      148 dcl  garbage (size (resource_descriptions)) bit (36);
      149 
      150 		string (garbage) = ""b;
      151 		resource_desc_ptr = addr (garbage);
      152 
      153 		resource_descriptions.version_no = resource_desc_version_1;
      154 		resource_descriptions.n_items = 1;
      155 		resource_descriptions.item (1).type = rsc_type_arg;
      156 		resource_descriptions.item (1).name = rsc_name;
      157 		resource_descriptions.item (1).given.name = "1"b;
      158 
      159 		if reserve_flag			/* Called by the reserve entry? */
      160 		then if authorization = get_authorization_ ()
      161 		     then call rcprm_find_resource_$reserve (resource_desc_ptr, (rcs.acs_directory), null (), code);
      162 		     else call rcprm_find_resource_$reserve_proxy (resource_desc_ptr, (rcs.acs_directory), null (), (group_id), authorization, code);
      163 		else call rcprm_find_resource_$status (resource_desc_ptr, (rcs.acs_directory), code);
      164 
      165 		if code = error_table_$action_not_performed then
      166 		     code = resource_descriptions.item (1).status_code;
      167 
      168 		eff_access = resource_descriptions.item (1).rew;
      169 		return;
      170 	     end;
      171 	end;
      172 
      173 /*
      174*
      175*   Now that we know we needen't call resource management, we can do it our way.
      176*
      177**/
      178 
      179 
      180 	call resource_info_$get_primary_type (rsc_type_arg, rsc_type, code);
      181 	if code ^= 0 then return;
      182 
      183 	do i = 1 to hbound (VOLUME_TYPE, 1);		/* Check all volume types. */
      184 	     if rsc_type = VOLUME_TYPE (i)		/* Got it! */
      185 	     then do;
      186 		eff_access = RW;			/* Everyone has RW access to volumes. */
      187 		return;
      188 	     end;
      189 	end;
      190 
      191 	do i = 1 to hbound (DEVICE_TYPE, 1);		/* Now check all device types. */
      192 	     if rsc_type = DEVICE_TYPE (i)		/* Got it! */
      193 	     then do;
      194 		device_found = "0"b;
      195 		do device_off = rcpd.dtype (i).first_off repeat device.next_off
      196 			while ((device_off ^= (18)"0"b) & ^device_found);
      197 		     device_ptr = ptr (rcpd_ptr, device_off);
      198 		     if device.device_name = rsc_name then device_found = "1"b;
      199 		end;
      200 		if ^device_found			/* Did not find this device. */
      201 		then do;
      202 		     code = error_table_$resource_unknown;
      203 		     eff_access = NULL;
      204 		     return;
      205 		end;
      206 		call hcs_$get_user_effmode ((rcs.acs_directory), (device.acs_name), group_id, level, actual_access, code);
      207 		if code ^= 0			/* Any error. */
      208 		then do;
      209 		     eff_access = NULL;		/* No access. */
      210 		     return;
      211 		end;
      212 		eff_access = substr (bit (actual_access), 2); /* Copy interesting bits. */
      213 		return;
      214 	     end;
      215 	end;
      216 
      217 	code = error_table_$resource_type_unknown;	/* Don't know this guy. */
      218 	eff_access = NULL;				/* No access here. */
      219 	return;
      220 
      221 
      222      end rcp_check_access_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1132.1  rcp_check_access_.pl1             >dumps>old_dumps>hardcore>rcp_check_access_.pl1
89           1    11/21/79  1458.3  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
1-101        2    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
91           3    11/21/79  1458.3  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
93           4    11/21/79  1509.5  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
95           5    02/13/79  1715.0  resource_control_desc.incl.pl1    >ldd>include>resource_control_desc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEVICE_TYPE                     000070 constant        char(32)                 initial array unaligned dcl 4-11 ref 191 192
NULL                                   constant        bit(3)                   initial unaligned dcl 41 ref 203 209 218
REW                                    constant        bit(3)                   initial unaligned dcl 42 ref 120
RW                                     constant        bit(3)                   initial unaligned dcl 43 ref 186
Resource_count                  000126 automatic       fixed bin(17,0)          dcl 5-78 set ref 145* 148
VOLUME_TYPE                     000000 constant        char(32)                 initial array unaligned dcl 4-18 ref 183 184
acs_directory            70            based           char(32)                 level 2 dcl 3-20 ref 159 162 163 206
acs_name                 26            based           char(12)                 level 2 dcl 1-50 ref 206
actual_access                   000100 automatic       fixed bin(5,0)           dcl 49 set ref 206* 212
addr                                                   builtin function         dcl 68 ref 151
authorization                          parameter       bit(72)                  dcl 29 set ref 101 159 162*
bit                                                    builtin function         dcl 69 ref 212
code                                   parameter       fixed bin(35,0)          dcl 30 set ref 11 101 134* 159* 162* 163* 165 165*
                                                                                  180* 181 202* 206* 207 217*
device                                 based           structure                level 1 dcl 1-50
device_found                    000101 automatic       bit(1)                   unaligned dcl 50 set ref 194* 195 198* 200
device_name                            based           char(8)                  level 2 dcl 1-50 ref 198
device_off                      000102 automatic       bit(18)                  unaligned dcl 51 set ref 195* 195* 197*
device_ptr                      000120 automatic       pointer                  dcl 1-17 set ref 197* 198 199 206
dtype                    43            based           structure                array level 2 in structure "rcpd" dcl 1-20
                                                                                  in procedure "rcp_check_access_"
dtype                                  based           structure                level 1 dcl 1-42 in procedure "rcp_check_access_"
eff_access                             parameter       bit(3)                   dcl 31 set ref 11 101 120* 168* 186* 203* 209* 212*
                                                                                  218*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 60 ref 165
error_table_$resource_type_unknown
                                000012 external static fixed bin(35,0)          dcl 61 ref 217
error_table_$resource_unknown   000014 external static fixed bin(35,0)          dcl 62 ref 202
first_off                56            based           bit(18)                  array level 3 dcl 1-20 ref 195
garbage                         000100 automatic       bit(36)                  array unaligned dcl 148 set ref 150* 151
get_authorization_              000016 constant        entry                    external dcl 80 ref 159
given                   270            based           structure                array level 3 dcl 5-6
group_id                               parameter       char(32)                 unaligned dcl 32 set ref 11 101 107 162 206*
hbound                                                 builtin function         dcl 70 ref 183 191
hcs_$get_user_effmode           000020 constant        entry                    external dcl 81 ref 206
i                               000103 automatic       fixed bin(17,0)          dcl 52 set ref 183* 184* 191* 192 195*
item                      2            based           structure                array level 2 dcl 5-6
level                                  parameter       fixed bin(17,0)          dcl 33 set ref 11 101 206*
lock_info                              based           structure                level 1 dcl 3-36
modes                    14(01)        based           structure                level 2 packed unaligned dcl 1-20
n_items                   1            based           fixed bin(17,0)          level 2 dcl 5-6 set ref 154*
name                    270            based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 5-6 in procedure
                                                                                  "rcp_check_access_" set ref 157*
name                     12            based           char(32)                 array level 3 in structure "resource_descriptions"
                                                                                  dcl 5-6 in procedure "rcp_check_access_" set ref
                                                                                  156*
next_off                 31            based           bit(18)                  level 2 dcl 1-50 ref 199
ptr                                                    builtin function         dcl 71 ref 197
rcp_init_flags                         based           structure                level 1 packed unaligned dcl 2-8
rcp_pointers_$com_seg           000022 constant        entry                    external dcl 82 ref 133
rcp_pointers_$data              000024 constant        entry                    external dcl 83 ref 132
rcpd                                   based           structure                level 1 dcl 1-20
rcpd_ptr                        000116 automatic       pointer                  dcl 1-15 set ref 132* 144 195 197
rcprm_find_resource_$reserve    000026 constant        entry                    external dcl 84 ref 159
rcprm_find_resource_$reserve_proxy
                                000030 constant        entry                    external dcl 85 ref 162
rcprm_find_resource_$status     000032 constant        entry                    external dcl 86 ref 163
rcs                                    based           structure                level 1 dcl 3-20
rcs_ptr                         000122 automatic       pointer                  dcl 3-13 set ref 133* 159 162 163 206
rcse                                   based           structure                level 1 dcl 3-45
reserve_flag                    000104 automatic       bit(1)                   unaligned dcl 53 set ref 97* 104* 159
resource_desc_ptr               000124 automatic       pointer                  dcl 5-72 set ref 148 151* 153 154 155 156 157 159*
                                                                                  162* 163* 165 168
resource_desc_version_1                constant        fixed bin(17,0)          initial dcl 5-75 ref 153
resource_descriptions                  based           structure                level 1 dcl 5-6 set ref 148
resource_info_$get_primary_type 000034 constant        entry                    external dcl 87 ref 180
resource_mgmt_enabled
                         14(04)        based           bit(1)                   level 3 packed unaligned dcl 1-20 ref 144
rew                     267            based           bit(3)                   array level 3 packed unaligned dcl 5-6 ref 168
rsc_name                               parameter       char(32)                 unaligned dcl 34 ref 11 101 156 198
rsc_type                        000105 automatic       char(32)                 unaligned dcl 54 set ref 180* 184 192
rsc_type_arg                           parameter       char(32)                 unaligned dcl 35 set ref 11 101 155 180*
size                                                   builtin function         dcl 72 ref 148
status_code             272            based           fixed bin(35,0)          array level 3 dcl 5-6 ref 165
string                                                 builtin function         dcl 73 set ref 150*
substr                                                 builtin function         dcl 74 ref 212
type                      2            based           char(32)                 array level 3 dcl 5-6 set ref 155*
version_no                             based           fixed bin(17,0)          level 2 dcl 5-6 set ref 153*
volume                                 based           structure                level 1 dcl 1-89

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 2-16
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 4-24
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 4-23
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 4-30
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 2-16
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 4-15
No_authentication                      internal static fixed bin(17,0)          initial dcl 2-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 2-16
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 4-25
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 4-26
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 4-27
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 4-28
TAPE_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 4-22
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 4-29
authentication_level_names             internal static char(12)                 initial array unaligned dcl 2-21
based_rcp_id                           based           structure                level 1 dcl 3-16
dtype_ptr                              automatic       pointer                  dcl 1-16
lock_info_ptr                          automatic       pointer                  dcl 3-12
rcse_ptr                               automatic       pointer                  dcl 3-14
reservation_description                based           structure                level 1 dcl 5-55
resource_res_ptr                       automatic       pointer                  dcl 5-72
resource_res_version_1                 internal static fixed bin(17,0)          initial dcl 5-75
rifp                                   automatic       pointer                  dcl 2-6
volume_ptr                             automatic       pointer                  dcl 1-18

NAMES DECLARED BY EXPLICIT CONTEXT.
JOIN                            000246 constant        label                    dcl 107 ref 98
rcp_check_access_               000210 constant        entry                    external dcl 11
reserve                         000232 constant        entry                    external dcl 101

NAME DECLARED BY CONTEXT OR IMPLICATION.
null                                                   builtin function         ref 159 159 162 162

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1126        1164     733        1136
Length      1464     733        36         264     172           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_check_access_                   138 external procedure  is an external procedure.  
begin block on line 146             114 begin block         uses auto adjustable storage.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 146  000100 garbage                     begin block on line 146
rcp_check_access_        000100 actual_access               rcp_check_access_
                         000101 device_found                rcp_check_access_
                         000102 device_off                  rcp_check_access_
                         000103 i                           rcp_check_access_
                         000104 reserve_flag                rcp_check_access_
                         000105 rsc_type                    rcp_check_access_
                         000116 rcpd_ptr                    rcp_check_access_
                         000120 device_ptr                  rcp_check_access_
                         000122 rcs_ptr                     rcp_check_access_
                         000124 resource_desc_ptr           rcp_check_access_
                         000126 Resource_count              rcp_check_access_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         call_ext_out_desc   call_ext_out        begin_return        return              alloc_auto_adj
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_authorization_            hcs_$get_user_effmode         rcp_pointers_$com_seg         rcp_pointers_$data
rcprm_find_resource_$reserve  rcprm_find_resource_$reserve_proxy                          rcprm_find_resource_$status
resource_info_$get_primary_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$resource_type_unknown
error_table_$resource_unknown


CONSTANTS
000000  aa  164 141 160 145	tape
000001  aa  137 166 157 154	_vol
000002  aa  040 040 040 040	    
000003  aa  040 040 040 040	    
000004  aa  040 040 040 040	    
000005  aa  040 040 040 040	    
000006  aa  040 040 040 040	    
000007  aa  040 040 040 040	    
000010  aa  144 151 163 153	disk
000011  aa  137 166 157 154	_vol
000012  aa  040 040 040 040	    
000013  aa  040 040 040 040	    
000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    
000016  aa  040 040 040 040	    
000017  aa  040 040 040 040	    
000020  aa  040 040 040 040	    
000021  aa  040 040 040 040	    
000022  aa  040 040 040 040	    
000023  aa  040 040 040 040	    
000024  aa  040 040 040 040	    
000025  aa  040 040 040 040	    
000026  aa  040 040 040 040	    
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa  040 040 040 040	    
000032  aa  040 040 040 040	    
000033  aa  040 040 040 040	    
000034  aa  040 040 040 040	    
000035  aa  040 040 040 040	    
000036  aa  040 040 040 040	    
000037  aa  040 040 040 040	    
000040  aa  040 040 040 040	    
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa  040 040 040 040	    
000044  aa  040 040 040 040	    
000045  aa  040 040 040 040	    
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa  040 040 040 040	    
000051  aa  040 040 040 040	    
000052  aa  040 040 040 040	    
000053  aa  040 040 040 040	    
000054  aa  040 040 040 040	    
000055  aa  040 040 040 040	    
000056  aa  040 040 040 040	    
000057  aa  040 040 040 040	    
000060  aa  040 040 040 040	    
000061  aa  040 040 040 040	    
000062  aa  040 040 040 040	    
000063  aa  040 040 040 040	    
000064  aa  040 040 040 040	    
000065  aa  040 040 040 040	    
000066  aa  040 040 040 040	    
000067  aa  040 040 040 040	    

000070  aa  164 141 160 145	tape
000071  aa  137 144 162 151	_dri
000072  aa  166 145 040 040	ve  
000073  aa  040 040 040 040	    
000074  aa  040 040 040 040	    
000075  aa  040 040 040 040	    
000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    
000100  aa  144 151 163 153	disk
000101  aa  137 144 162 151	_dri
000102  aa  166 145 040 040	ve  
000103  aa  040 040 040 040	    
000104  aa  040 040 040 040	    
000105  aa  040 040 040 040	    
000106  aa  040 040 040 040	    
000107  aa  040 040 040 040	    
000110  aa  143 157 156 163	cons
000111  aa  157 154 145 040	ole 
000112  aa  040 040 040 040	    
000113  aa  040 040 040 040	    
000114  aa  040 040 040 040	    
000115  aa  040 040 040 040	    
000116  aa  040 040 040 040	    
000117  aa  040 040 040 040	    
000120  aa  160 162 151 156	prin
000121  aa  164 145 162 040	ter 
000122  aa  040 040 040 040	    
000123  aa  040 040 040 040	    
000124  aa  040 040 040 040	    
000125  aa  040 040 040 040	    
000126  aa  040 040 040 040	    
000127  aa  040 040 040 040	    
000130  aa  160 165 156 143	punc
000131  aa  150 040 040 040	h   
000132  aa  040 040 040 040	    
000133  aa  040 040 040 040	    
000134  aa  040 040 040 040	    
000135  aa  040 040 040 040	    
000136  aa  040 040 040 040	    
000137  aa  040 040 040 040	    
000140  aa  162 145 141 144	read
000141  aa  145 162 040 040	er  
000142  aa  040 040 040 040	    
000143  aa  040 040 040 040	    
000144  aa  040 040 040 040	    
000145  aa  040 040 040 040	    
000146  aa  040 040 040 040	    
000147  aa  040 040 040 040	    
000150  aa  163 160 145 143	spec
000151  aa  151 141 154 040	ial 
000152  aa  040 040 040 040	    
000153  aa  040 040 040 040	    
000154  aa  040 040 040 040	    
000155  aa  040 040 040 040	    
000156  aa  040 040 040 040	    
000157  aa  040 040 040 040	    

000160  aa     404000000005

000161  aa     524000000014

000162  aa     524000000040

000163  aa     464000000000

000164  aa     404000000021

000165  aa     526000000040

000166  aa     514000000003

000167  aa     404000000043

000170  aa     514000000110

000172  aa     077777000043
000173  aa     000001000000

000174  aa  111 156 151 164	Init
000175  aa  151 141 154 151	iali
000176  aa  172 145 162 056	zer.
000177  aa  123 171 163 104	SysD
000200  aa  141 145 155 157	aemo
000201  aa  156 056 172 000	n.z

BEGIN PROCEDURE rcp_check_access_
ENTRY TO rcp_check_access_                                  STATEMENT 1 ON LINE 11
rcp_check_access_: proc (rsc_type_arg, rsc_name, group_id, level, eff_access, code);

000202  at     000006000165
000203  tt     000165000165
000204  tt     000164000166
000205  ta     000167000000
000206  ta     000202000000
000207  da     000163300000
000210  aa   000220 6270 00	eax7 	144
000211  aa  7 00034 3521 20	epp2 	pr7|28,*
000212  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000213  aa     000014000000
000214  aa     000000000000
000215  aa  6 00032 3735 20	epp7 	pr6|26,*
000216  aa  7 00012 3715 20	epp5 	pr7|10,*
000217  aa  6 00132 6515 00	spri5	pr6|90
000220  aa  7 00014 3535 20	epp3 	pr7|12,*
000221  aa  6 00130 2535 00	spri3	pr6|88
						STATEMENT 1 ON LINE 97
	reserve_flag = "0"b;

000222  aa  6 00104 4501 00	stz  	pr6|68		reserve_flag
						STATEMENT 1 ON LINE 98
	goto JOIN;

000223  aa   000023 7100 04	tra  	19,ic		000246
ENTRY TO reserve                                            STATEMENT 1 ON LINE 101
reserve:	entry (rsc_type_arg, rsc_name, group_id, level, authorization, eff_access, code);

000224  at     000007000165
000225  tt     000165000165
000226  tt     000164000170
000227  tt     000166000167
000230  ta     000224000000
000231  da     000166300000
000232  aa   000220 6270 00	eax7 	144
000233  aa  7 00034 3521 20	epp2 	pr7|28,*
000234  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000235  aa     000016000000
000236  aa     000000000000
000237  aa  6 00032 3735 20	epp7 	pr6|26,*
000240  aa  7 00014 3715 20	epp5 	pr7|12,*
000241  aa  6 00132 6515 00	spri5	pr6|90
000242  aa  7 00016 3535 20	epp3 	pr7|14,*
000243  aa  6 00130 2535 00	spri3	pr6|88
						STATEMENT 1 ON LINE 104
	reserve_flag = "1"b;

000244  aa   400000 2350 03	lda  	131072,du
000245  aa  6 00104 7551 00	sta  	pr6|68		reserve_flag
						STATEMENT 1 ON LINE 107
JOIN:


/*

   Special case the Initializer.  He may call us before we're ready to handle any of this
   and he is almighty anyway, so let him have it.

*/


	if group_id = "Initializer.SysDaemon.z"		/* Special case the Initializer. */
	then do;

000246  aa  6 00032 3735 20	epp7 	pr6|26,*
000247  aa  7 00006 3715 20	epp5 	pr7|6,*
000250  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000251  aa  5 00000 00 0040	desc9a	pr5|0,32		group_id
000252  aa   777724 00 0027	desc9a	-44,23		000174 = 111156151164
000253  aa   000004 6010 04	tnz  	4,ic		000257
						STATEMENT 1 ON LINE 120
	     eff_access = REW;

000254  aa   700000 2350 03	lda  	229376,du
000255  aa  6 00132 7551 20	sta  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 121
	     return;

000256  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 122
	end;

						STATEMENT 1 ON LINE 132
	rcpd_ptr = rcp_pointers_$data ();

000257  aa  6 00116 3521 00	epp2 	pr6|78		rcpd_ptr
000260  aa  6 00136 2521 00	spri2	pr6|94
000261  aa  6 00134 6211 00	eax1 	pr6|92
000262  aa   004000 4310 07	fld  	2048,dl
000263  aa  6 00044 3701 20	epp4 	pr6|36,*
000264  la  4 00024 3521 20	epp2 	pr4|20,*		rcp_pointers_$data
000265  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 133
	rcs_ptr = rcp_pointers_$com_seg ();

000266  aa  6 00122 3521 00	epp2 	pr6|82		rcs_ptr
000267  aa  6 00136 2521 00	spri2	pr6|94
000270  aa  6 00134 6211 00	eax1 	pr6|92
000271  aa   004000 4310 07	fld  	2048,dl
000272  aa  6 00044 3701 20	epp4 	pr6|36,*
000273  la  4 00022 3521 20	epp2 	pr4|18,*		rcp_pointers_$com_seg
000274  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 134
	code = 0;

000275  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 144
	if rcpd.modes.resource_mgmt_enabled then do;

000276  aa  6 00116 3735 20	epp7 	pr6|78,*		rcpd_ptr
000277  aa  7 00014 2351 00	lda  	pr7|12		rcpd.resource_mgmt_enabled
000300  aa   020000 3150 03	cana 	8192,du
000301  aa   000215 6000 04	tze  	141,ic		000516
						STATEMENT 1 ON LINE 145
	     Resource_count = 1;

000302  aa   000001 2360 07	ldq  	1,dl
000303  aa  6 00126 7561 00	stq  	pr6|86		Resource_count
						STATEMENT 1 ON LINE 146
	     begin;

000304  aa   000200 6270 00	eax7 	128
000305  aa  0 00614 2721 00	tsp2 	pr0|396		enter_begin
000306  aa     000000000000
BEGIN BLOCK  1
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 148
000307  aa  6 00040 3735 20	epp7 	pr6|32,*
000310  aa  7 00126 2361 00	ldq  	pr7|86		Resource_count
000311  aa   000271 4020 07	mpy  	185,dl
000312  aa   000002 0760 07	adq  	2,dl
000313  aa  6 00100 7561 00	stq  	pr6|64
000314  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
000315  aa  6 00102 2521 00	spri2	pr6|66
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 150
		string (garbage) = ""b;

000316  aa  6 00100 2361 00	ldq  	pr6|64
000317  aa   000044 4020 07	mpy  	36,dl
000320  aa  003 140 060 400	csl  	(),(pr,rl),fill(0),bool(move)
000321  aa   000000 00 0000	descb	0,0
000322  aa  2 00000 00 0006	descb	pr2|0,ql
						STATEMENT 1 ON LINE 151
		resource_desc_ptr = addr (garbage);

000323  aa  2 00000 3715 00	epp5 	pr2|0		garbage
000324  aa  7 00124 6515 00	spri5	pr7|84		resource_desc_ptr
						STATEMENT 1 ON LINE 153
		resource_descriptions.version_no = resource_desc_version_1;

000325  aa   000001 2360 07	ldq  	1,dl
000326  aa  5 00000 7561 00	stq  	pr5|0		resource_descriptions.version_no
						STATEMENT 1 ON LINE 154
		resource_descriptions.n_items = 1;

000327  aa   000001 2360 07	ldq  	1,dl
000330  aa  5 00001 7561 00	stq  	pr5|1		resource_descriptions.n_items
						STATEMENT 1 ON LINE 155
		resource_descriptions.item (1).type = rsc_type_arg;

000331  aa  7 00032 3535 20	epp3 	pr7|26,*
000332  aa  3 00002 3515 20	epp1 	pr3|2,*
000333  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000334  aa  1 00000 00 0040	desc9a	pr1|0,32		rsc_type_arg
000335  aa  5 00002 00 0040	desc9a	pr5|2,32		resource_descriptions.type
						STATEMENT 1 ON LINE 156
		resource_descriptions.item (1).name = rsc_name;

000336  aa  3 00004 3515 20	epp1 	pr3|4,*
000337  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000340  aa  1 00000 00 0040	desc9a	pr1|0,32		rsc_name
000341  aa  5 00012 00 0040	desc9a	pr5|10,32		resource_descriptions.name
						STATEMENT 1 ON LINE 157
		resource_descriptions.item (1).given.name = "1"b;

000342  aa   400000 2350 03	lda  	131072,du
000343  aa  5 00270 2551 00	orsa 	pr5|184		resource_descriptions.name
						STATEMENT 1 ON LINE 159
		if reserve_flag			/* Called by the reserve entry? */
		then if authorization = get_authorization_ ()
		     then call rcprm_find_resource_$reserve (resource_desc_ptr, (rcs.acs_directory), null (), code);

000344  aa  7 00104 2351 00	lda  	pr7|68		reserve_flag
000345  aa   000106 6000 04	tze  	70,ic		000453
000346  aa  6 00104 3521 00	epp2 	pr6|68
000347  aa  6 00110 2521 00	spri2	pr6|72
000350  aa  6 00106 6211 00	eax1 	pr6|70
000351  aa   004000 4310 07	fld  	2048,dl
000352  aa  6 00044 3701 20	epp4 	pr6|36,*
000353  la  4 00016 3521 20	epp2 	pr4|14,*		get_authorization_
000354  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000355  aa  6 00040 3735 20	epp7 	pr6|32,*
000356  aa  7 00032 3715 20	epp5 	pr7|26,*
000357  aa  5 00012 3535 20	epp3 	pr5|10,*
000360  aa  3 00000 2351 00	lda  	pr3|0		authorization
000361  aa  3 00001 2361 00	ldq  	pr3|1		authorization
000362  aa  6 00104 1171 00	cmpaq	pr6|68
000363  aa   000034 6010 04	tnz  	28,ic		000417
000364  aa  7 00122 3515 20	epp1 	pr7|82,*		rcs_ptr
000365  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000366  aa  1 00070 00 0040	desc9a	pr1|56,32		rcs.acs_directory
000367  aa  6 00112 00 0040	desc9a	pr6|74,32
000370  aa   777602 3534 24	epp3 	-126,ic*
000371  aa  6 00104 2535 00	spri3	pr6|68
000372  aa  7 00124 3521 00	epp2 	pr7|84		resource_desc_ptr
000373  aa  6 00124 2521 00	spri2	pr6|84
000374  aa  6 00112 3521 00	epp2 	pr6|74
000375  aa  6 00126 2521 00	spri2	pr6|86
000376  aa  6 00104 3521 00	epp2 	pr6|68
000377  aa  6 00130 2521 00	spri2	pr6|88
000400  aa  7 00130 3521 20	epp2 	pr7|88,*		code
000401  aa  6 00132 2521 00	spri2	pr6|90
000402  aa   777561 3520 04	epp2 	-143,ic		000163 = 464000000000
000403  aa  6 00134 2521 00	spri2	pr6|92
000404  aa  6 00140 2521 00	spri2	pr6|96
000405  aa   777555 3520 04	epp2 	-147,ic		000162 = 524000000040
000406  aa  6 00136 2521 00	spri2	pr6|94
000407  aa   777560 3520 04	epp2 	-144,ic		000167 = 404000000043
000410  aa  6 00142 2521 00	spri2	pr6|98
000411  aa  6 00122 6211 00	eax1 	pr6|82
000412  aa   020000 4310 07	fld  	8192,dl
000413  aa  6 00044 3701 20	epp4 	pr6|36,*
000414  la  4 00026 3521 20	epp2 	pr4|22,*		rcprm_find_resource_$reserve
000415  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000416  aa   000062 7100 04	tra  	50,ic		000500
						STATEMENT 1 ON LINE 162
		     else call rcprm_find_resource_$reserve_proxy (resource_desc_ptr, (rcs.acs_directory), null (), (group_id), authorization, code);

000417  aa  7 00122 3515 20	epp1 	pr7|82,*		rcs_ptr
000420  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000421  aa  1 00070 00 0040	desc9a	pr1|56,32		rcs.acs_directory
000422  aa  6 00112 00 0040	desc9a	pr6|74,32
000423  aa   777547 3534 24	epp3 	-153,ic*
000424  aa  6 00104 2535 00	spri3	pr6|68
000425  aa  5 00006 3515 20	epp1 	pr5|6,*
000426  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000427  aa  1 00000 00 0040	desc9a	pr1|0,32		group_id
000430  aa  6 00122 00 0040	desc9a	pr6|82,32
000431  aa  7 00124 3521 00	epp2 	pr7|84		resource_desc_ptr
000432  aa  6 00146 2521 00	spri2	pr6|102
000433  aa  6 00112 3521 00	epp2 	pr6|74
000434  aa  6 00150 2521 00	spri2	pr6|104
000435  aa  6 00104 3521 00	epp2 	pr6|68
000436  aa  6 00152 2521 00	spri2	pr6|106
000437  aa  6 00122 3521 00	epp2 	pr6|82
000440  aa  6 00154 2521 00	spri2	pr6|108
000441  aa  5 00012 3521 20	epp2 	pr5|10,*		authorization
000442  aa  6 00156 2521 00	spri2	pr6|110
000443  aa  7 00130 3521 20	epp2 	pr7|88,*		code
000444  aa  6 00160 2521 00	spri2	pr6|112
000445  aa  6 00144 6211 00	eax1 	pr6|100
000446  aa   030000 4310 07	fld  	12288,dl
000447  aa  6 00044 3701 20	epp4 	pr6|36,*
000450  la  4 00030 3521 20	epp2 	pr4|24,*		rcprm_find_resource_$reserve_proxy
000451  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000452  aa   000026 7100 04	tra  	22,ic		000500
						STATEMENT 1 ON LINE 163
		else call rcprm_find_resource_$status (resource_desc_ptr, (rcs.acs_directory), code);

000453  aa  7 00122 3515 20	epp1 	pr7|82,*		rcs_ptr
000454  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000455  aa  1 00070 00 0040	desc9a	pr1|56,32		rcs.acs_directory
000456  aa  6 00112 00 0040	desc9a	pr6|74,32
000457  aa  7 00124 3521 00	epp2 	pr7|84		resource_desc_ptr
000460  aa  6 00146 2521 00	spri2	pr6|102
000461  aa  6 00112 3521 00	epp2 	pr6|74
000462  aa  6 00150 2521 00	spri2	pr6|104
000463  aa  7 00130 3521 20	epp2 	pr7|88,*		code
000464  aa  6 00152 2521 00	spri2	pr6|106
000465  aa   777476 3520 04	epp2 	-194,ic		000163 = 464000000000
000466  aa  6 00154 2521 00	spri2	pr6|108
000467  aa   777473 3520 04	epp2 	-197,ic		000162 = 524000000040
000470  aa  6 00156 2521 00	spri2	pr6|110
000471  aa   777476 3520 04	epp2 	-194,ic		000167 = 404000000043
000472  aa  6 00160 2521 00	spri2	pr6|112
000473  aa  6 00144 6211 00	eax1 	pr6|100
000474  aa   014000 4310 07	fld  	6144,dl
000475  aa  6 00044 3701 20	epp4 	pr6|36,*
000476  la  4 00032 3521 20	epp2 	pr4|26,*		rcprm_find_resource_$status
000477  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 165
		if code = error_table_$action_not_performed then
		     code = resource_descriptions.item (1).status_code;

000500  aa  6 00040 3735 20	epp7 	pr6|32,*
000501  aa  7 00130 2361 20	ldq  	pr7|88,*		code
000502  aa  6 00044 3701 20	epp4 	pr6|36,*
000503  la  4 00010 1161 20	cmpq 	pr4|8,*		error_table_$action_not_performed
000504  aa   000004 6010 04	tnz  	4,ic		000510
000505  aa  7 00124 3715 20	epp5 	pr7|84,*		resource_desc_ptr
000506  aa  5 00272 2361 00	ldq  	pr5|186		resource_descriptions.status_code
000507  aa  7 00130 7561 20	stq  	pr7|88,*		code
						STATEMENT 1 ON LINE 168
		eff_access = resource_descriptions.item (1).rew;

000510  aa  7 00124 3715 20	epp5 	pr7|84,*		resource_desc_ptr
000511  aa  5 00267 2351 00	lda  	pr5|183		resource_descriptions.rew
000512  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
000513  aa  7 00132 7551 20	sta  	pr7|90,*		eff_access
						STATEMENT 1 ON LINE 169
		return;

000514  aa   000001 2360 07	ldq  	1,dl
000515  aa  0 00630 7101 00	tra  	pr0|408		begin_return
						STATEMENT 1 ON LINE 170
	     end;

  END BLOCK  1
						STATEMENT 1 ON LINE 171
	end;

						STATEMENT 1 ON LINE 180
	call resource_info_$get_primary_type (rsc_type_arg, rsc_type, code);

000516  aa  6 00032 3735 20	epp7 	pr6|26,*
000517  aa  7 00002 3521 20	epp2 	pr7|2,*		rsc_type_arg
000520  aa  6 00142 2521 00	spri2	pr6|98
000521  aa  6 00105 3521 00	epp2 	pr6|69		rsc_type
000522  aa  6 00144 2521 00	spri2	pr6|100
000523  aa  6 00130 3521 20	epp2 	pr6|88,*		code
000524  aa  6 00146 2521 00	spri2	pr6|102
000525  aa   777440 3520 04	epp2 	-224,ic		000165 = 526000000040
000526  aa  6 00150 2521 00	spri2	pr6|104
000527  aa  6 00152 2521 00	spri2	pr6|106
000530  aa   777437 3520 04	epp2 	-225,ic		000167 = 404000000043
000531  aa  6 00154 2521 00	spri2	pr6|108
000532  aa  6 00140 6211 00	eax1 	pr6|96
000533  aa   014000 4310 07	fld  	6144,dl
000534  aa  6 00044 3701 20	epp4 	pr6|36,*
000535  la  4 00034 3521 20	epp2 	pr4|28,*		resource_info_$get_primary_type
000536  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 181
	if code ^= 0 then return;

000537  aa  6 00130 2361 20	ldq  	pr6|88,*		code
000540  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 183
	do i = 1 to hbound (VOLUME_TYPE, 1);

000541  aa   000001 2360 07	ldq  	1,dl
000542  aa  6 00103 7561 00	stq  	pr6|67		i
000543  aa   000000 0110 03	nop  	0,du
000544  aa  6 00103 2361 00	ldq  	pr6|67		i
000545  aa   000007 1160 07	cmpq 	7,dl
000546  aa   000014 6054 04	tpnz 	12,ic		000562
						STATEMENT 1 ON LINE 184
	     if rsc_type = VOLUME_TYPE (i)		/* Got it! */
	     then do;

000547  aa   000003 7360 00	qls  	3
000550  ta   777770 3734 06	epp7 	-8,ql
000551  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
000552  aa  6 00105 00 0040	desc9a	pr6|69,32		rsc_type
000553  aa  7 00000 00 0040	desc9a	pr7|0,32		VOLUME_TYPE
000554  aa   000004 6010 04	tnz  	4,ic		000560
						STATEMENT 1 ON LINE 186
		eff_access = RW;

000555  aa   500000 2350 03	lda  	163840,du
000556  aa  6 00132 7551 20	sta  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 187
		return;

000557  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 188
	     end;

						STATEMENT 1 ON LINE 189
	end;

000560  aa  6 00103 0541 00	aos  	pr6|67		i
000561  aa   777763 7100 04	tra  	-13,ic		000544
						STATEMENT 1 ON LINE 191
	do i = 1 to hbound (DEVICE_TYPE, 1);

000562  aa   000001 2360 07	ldq  	1,dl
000563  aa  6 00103 7561 00	stq  	pr6|67		i
000564  aa  6 00103 2361 00	ldq  	pr6|67		i
000565  aa   000007 1160 07	cmpq 	7,dl
000566  aa   000140 6054 04	tpnz 	96,ic		000726
						STATEMENT 1 ON LINE 192
	     if rsc_type = DEVICE_TYPE (i)		/* Got it! */
	     then do;

000567  aa   000003 7360 00	qls  	3
000570  ta   000060 3734 06	epp7 	48,ql
000571  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
000572  aa  6 00105 00 0040	desc9a	pr6|69,32		rsc_type
000573  aa  7 00000 00 0040	desc9a	pr7|0,32		DEVICE_TYPE
000574  aa   000130 6010 04	tnz  	88,ic		000724
						STATEMENT 1 ON LINE 194
		device_found = "0"b;

000575  aa  6 00101 4501 00	stz  	pr6|65		device_found
						STATEMENT 1 ON LINE 195
		do device_off = rcpd.dtype (i).first_off repeat device.next_off
			while ((device_off ^= (18)"0"b) & ^device_found);

000576  aa  6 00103 2361 00	ldq  	pr6|67		i
000577  aa   000017 4020 07	mpy  	15,dl
000600  aa  6 00116 3715 20	epp5 	pr6|78,*		rcpd_ptr
000601  aa  5 00037 2351 06	lda  	pr5|31,ql		rcpd.first_off
000602  aa  6 00102 7551 00	sta  	pr6|66		device_off
000603  aa   000000 0110 03	nop  	0,du
000604  aa  6 00101 2351 00	lda  	pr6|65		device_found
000605  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000606  aa  6 00156 7551 00	sta  	pr6|110
000607  aa   000021 6000 04	tze  	17,ic		000630
000610  aa  6 00102 2351 00	lda  	pr6|66		device_off
000611  aa   000017 6000 04	tze  	15,ic		000630
						STATEMENT 1 ON LINE 197
		     device_ptr = ptr (rcpd_ptr, device_off);

000612  aa  6 00116 3521 20	epp2 	pr6|78,*		rcpd_ptr
000613  aa   000000 3120 01	eawp2	0,au
000614  aa  6 00120 2521 00	spri2	pr6|80		device_ptr
						STATEMENT 1 ON LINE 198
		     if device.device_name = rsc_name then device_found = "1"b;

000615  aa  6 00032 3735 20	epp7 	pr6|26,*
000616  aa  7 00004 3715 20	epp5 	pr7|4,*
000617  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
000620  aa  2 00000 00 0010	desc9a	pr2|0,8		device.device_name
000621  aa  5 00000 00 0040	desc9a	pr5|0,32		rsc_name
000622  aa   000003 6010 04	tnz  	3,ic		000625
000623  aa   400000 2350 03	lda  	131072,du
000624  aa  6 00101 7551 00	sta  	pr6|65		device_found
						STATEMENT 1 ON LINE 199
		end;

000625  aa  2 00031 2351 00	lda  	pr2|25		device.next_off
000626  aa  6 00102 7551 00	sta  	pr6|66		device_off
000627  aa   777755 7100 04	tra  	-19,ic		000604
						STATEMENT 1 ON LINE 200
		if ^device_found			/* Did not find this device. */
		then do;

000630  aa  6 00156 2351 00	lda  	pr6|110
000631  aa   000006 6000 04	tze  	6,ic		000637
						STATEMENT 1 ON LINE 202
		     code = error_table_$resource_unknown;

000632  aa  6 00044 3701 20	epp4 	pr6|36,*
000633  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$resource_unknown
000634  aa  6 00130 7561 20	stq  	pr6|88,*		code
						STATEMENT 1 ON LINE 203
		     eff_access = NULL;

000635  aa  6 00132 4501 20	stz  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 204
		     return;

000636  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 205
		end;

						STATEMENT 1 ON LINE 206
		call hcs_$get_user_effmode ((rcs.acs_directory), (device.acs_name), group_id, level, actual_access, code);

000637  aa  6 00122 3735 20	epp7 	pr6|82,*		rcs_ptr
000640  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000641  aa  7 00070 00 0040	desc9a	pr7|56,32		rcs.acs_directory
000642  aa  6 00140 00 0040	desc9a	pr6|96,32
000643  aa  6 00120 3715 20	epp5 	pr6|80,*		device_ptr
000644  aa  5 00026 2351 00	lda  	pr5|22		device.acs_name
000645  aa  5 00027 2361 00	ldq  	pr5|23		device.acs_name
000646  aa  6 00134 7571 00	staq 	pr6|92
000647  aa  5 00030 2351 00	lda  	pr5|24		device.acs_name
000650  aa  6 00136 7551 00	sta  	pr6|94
000651  aa  6 00140 3521 00	epp2 	pr6|96
000652  aa  6 00162 2521 00	spri2	pr6|114
000653  aa  6 00134 3521 00	epp2 	pr6|92
000654  aa  6 00164 2521 00	spri2	pr6|116
000655  aa  6 00032 3535 20	epp3 	pr6|26,*
000656  aa  3 00006 3521 20	epp2 	pr3|6,*		group_id
000657  aa  6 00166 2521 00	spri2	pr6|118
000660  aa  3 00010 3521 20	epp2 	pr3|8,*		level
000661  aa  6 00170 2521 00	spri2	pr6|120
000662  aa  6 00100 3521 00	epp2 	pr6|64		actual_access
000663  aa  6 00172 2521 00	spri2	pr6|122
000664  aa  6 00130 3521 20	epp2 	pr6|88,*		code
000665  aa  6 00174 2521 00	spri2	pr6|124
000666  aa   777274 3520 04	epp2 	-324,ic		000162 = 524000000040
000667  aa  6 00176 2521 00	spri2	pr6|126
000670  aa   777271 3520 04	epp2 	-327,ic		000161 = 524000000014
000671  aa  6 00200 2521 00	spri2	pr6|128
000672  aa   777273 3520 04	epp2 	-325,ic		000165 = 526000000040
000673  aa  6 00202 2521 00	spri2	pr6|130
000674  aa   777270 3520 04	epp2 	-328,ic		000164 = 404000000021
000675  aa  6 00204 2521 00	spri2	pr6|132
000676  aa   777262 3520 04	epp2 	-334,ic		000160 = 404000000005
000677  aa  6 00206 2521 00	spri2	pr6|134
000700  aa   777267 3520 04	epp2 	-329,ic		000167 = 404000000043
000701  aa  6 00210 2521 00	spri2	pr6|136
000702  aa  6 00160 6211 00	eax1 	pr6|112
000703  aa   030000 4310 07	fld  	12288,dl
000704  aa  6 00044 3701 20	epp4 	pr6|36,*
000705  la  4 00020 3521 20	epp2 	pr4|16,*		hcs_$get_user_effmode
000706  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 207
		if code ^= 0			/* Any error. */
		then do;

000707  aa  6 00130 2361 20	ldq  	pr6|88,*		code
000710  aa   000003 6000 04	tze  	3,ic		000713
						STATEMENT 1 ON LINE 209
		     eff_access = NULL;

000711  aa  6 00132 4501 20	stz  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 210
		     return;

000712  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 211
		end;

						STATEMENT 1 ON LINE 212
		eff_access = substr (bit (actual_access), 2);

000713  aa  6 00100 2351 00	lda  	pr6|64		actual_access
000714  aa   000002 6050 04	tpl  	2,ic		000716
000715  aa   000000 5310 00	neg  	0
000716  aa   000037 7350 00	als  	31
000717  aa  6 00157 7551 00	sta  	pr6|111
000720  aa   000001 7350 00	als  	1
000721  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
000722  aa  6 00132 7551 20	sta  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 213
		return;

000723  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 214
	     end;

						STATEMENT 1 ON LINE 215
	end;

000724  aa  6 00103 0541 00	aos  	pr6|67		i
000725  aa   777637 7100 04	tra  	-97,ic		000564
						STATEMENT 1 ON LINE 217
	code = error_table_$resource_type_unknown;

000726  aa  6 00044 3701 20	epp4 	pr6|36,*
000727  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$resource_type_unknown
000730  aa  6 00130 7561 20	stq  	pr6|88,*		code
						STATEMENT 1 ON LINE 218
	eff_access = NULL;

000731  aa  6 00132 4501 20	stz  	pr6|90,*		eff_access
						STATEMENT 1 ON LINE 219
	return;

000732  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 222
     end rcp_check_access_;

  END PROCEDURE rcp_check_access_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
