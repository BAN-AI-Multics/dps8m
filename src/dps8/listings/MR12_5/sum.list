	COMPILATION LISTING OF SEGMENT sum
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1007.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style2,indcomtxt */
       13 
       14 sum:
       15      procedure;
       16 
       17 /* Totally rewritten March 1975 by R. Bratt for new kst, to restructure to code, and to fix a horrid bug in dirmod */
       18 /* Mod 4/25/75 by BSG for NSS */
       19 /* Modified by Kobziar to drop get_ring entry */
       20 /* Last modified 760310 by LJS to use info-only entry in dir_control_error */
       21 /* Modified by Mike Grady 9/79 to stop using dir_control_error */
       22 /* Modified 12 August 1981, W. Olin Sibert, to move error code generation into validate_entryp */
       23 /* Modified 3/82 BIM for change_pclock in the dir header */
       24 /* Modified 84-03-14 BIM to make pc$updates actually do something for dirmod */
       25 /* Modified 84-10-15 Keith Loepere to move validate_entryp in here. */
       26 /* Modified 85-01-21 Keith Loepere for dtm setting covert event. */
       27 
       28 /* ---> sum$getbranch locks the directory and returns the branch pointer for
       29*   a given segment.
       30*
       31*   USAGE: call sum$getbranch (segptr, type_lock, aep, code);
       32*
       33*   1) segptr ptr - - - pointer to a segment
       34*   2) type_lock bit(36) aligned - - - string indicating whether lock is read or write lock (input)
       35*   3) aep ptr - - - pointer to the branch of that segment (output)
       36*   4) code fixed bin - - - error code (output)
       37*
       38*   ---> sum$dirmod sets the file modified switch on a directory and reflects it up, and bumps the pclock in the dir.
       39*
       40*   USAGE: call sum$dirmod (adp);
       41*
       42*   1) adp ptr - - - pointer to the directory that has been modified
       43**/
       44 
       45 /* Parameters */
       46 
       47 	dcl     a_code		 fixed bin (35);
       48 	dcl     a_dp		 ptr;
       49 	dcl     a_ep		 ptr;
       50 	dcl     a_segptr		 ptr;
       51 	dcl     a_type_lock		 bit (36) aligned;
       52 
       53 /* Variables */
       54 
       55 	dcl     code		 fixed bin (35);
       56 	dcl     dtm_changed		 bit (1) aligned;
       57 	dcl     lsw		 bit (1) aligned;
       58 	dcl     my_lock_entry	 bit (1) aligned init ("0"b);
       59 	dcl     old_dtm		 bit (36) aligned;
       60 	dcl     segptr		 ptr;
       61 	dcl     target_dp		 ptr;
       62 	dcl     type_lock		 bit (36) aligned;
       63 
       64 /* External */
       65 
       66 	dcl     error_table_$mylock	 fixed bin (35) ext;
       67 	dcl     error_table_$root	 fixed bin (35) ext;
       68 	dcl     error_table_$seg_deleted
       69 				 fixed bin (35) external static;
       70 	dcl     pds$throttle_segment_state_changes
       71 				 bit (1) aligned external static;
       72 	dcl     1 pds$transparent	 external aligned,
       73 	        ( 2 m		 bit (1),
       74 		2 u		 bit (1)
       75 		)		 unaligned;
       76 
       77 /* Entries */
       78 
       79 	dcl     activate		 ext entry (ptr, fixed bin (35)) returns (ptr);
       80 	dcl     get_kstep		 ext entry (fixed bin (17), ptr, fixed bin (35));
       81 	dcl     limit_covert_channel	 entry (fixed bin);
       82 	dcl     lock$dir_unlock	 external entry (ptr);
       83 	dcl     lock$dir_wait	 external entry (ptr, bit (36) aligned, fixed bin (35));
       84 	dcl     lock$lock_ast	 entry;
       85 	dcl     lock$unlock_ast	 entry;
       86 	dcl     pc$updates		 external entry (ptr);
       87 	dcl     syserr		 external entry options (variable);
       88 
       89 /* Misc */
       90 
       91 	dcl     (addr, baseno, fixed, null, pointer, ptr)
       92 				 builtin;
       93 
       94 	dcl     (bad_dir_, fixedoverflow)
       95 				 condition;
       96 
       97 getbranch_root_my:
       98      entry (a_segptr, a_type_lock, a_ep, a_code);
       99 
      100 /* same as getbranch but returns the mylock error code. */
      101 
      102 	my_lock_entry = "1"b;
      103 
      104 getbranch:
      105      entry (a_segptr, a_type_lock, a_ep, a_code);
      106 
      107 /* entry to lock the directory and return the branch pointer for a given segment */
      108 
      109 	segptr = a_segptr;
      110 	type_lock = a_type_lock;
      111 	a_code = 0;
      112 	a_ep = null ();
      113 	call get_kstep (fixed (baseno (segptr), 17), kstep, code);
      114 	if code ^= 0
      115 	then call abort (code);
      116 
      117 	if kstep -> kste.uid = (36)"1"b		/* is this the root */
      118 	then call abort (error_table_$root);		/* set the root code */
      119 
      120 	dp = ptr (kste.entryp, 0);
      121 	lsw = "1"b;				/* set lock switch */
      122 	call lock$dir_wait (dp, type_lock, code);	/* lock the directory */
      123 	if code ^= 0
      124 	then if code ^= error_table_$mylock		/* not mylock */
      125 	     then call abort (code);			/* then done */
      126 	     else if my_lock_entry			/* old getbranch entry */
      127 	     then do;
      128 		     lsw = "0"b;
      129 		     a_code = code;			/* be sure caller knows not to unlock */
      130 		end;
      131 	     else call syserr (CRASH, "sum: mylock error on ^p", dp);
      132 
      133 	ep = validate_entryp (kstep, code);
      134 	if ep = null ()
      135 	then do;
      136 		call unlock ();
      137 		call abort (code);
      138 	     end;
      139 	a_ep = ep;
      140 	return;
      141 
      142 dirmod:
      143      entry (a_dp);
      144 
      145 /* entry to set the file modified switch on a directory and reflect it up */
      146 
      147 	if pds$transparent.m = "1"b
      148 	then return;				/* Do nothing if in transparent modification mode. */
      149 	target_dp = a_dp;
      150 	on fixedoverflow
      151 	     begin;
      152 		target_dp -> dir.change_pclock = 0;
      153 		go to clocked;
      154 	     end;
      155 
      156 (fixedoverflow):
      157 	target_dp -> dir.change_pclock = target_dp -> dir.change_pclock + 1;
      158 
      159 clocked:
      160 	call get_kstep (fixed (baseno (target_dp), 17), kstep, code);
      161 	if code ^= 0
      162 	then return;				/* if segno invalid, skip it */
      163 	if kstep -> kste.uid = (36)"1"b
      164 	then do;					/* this is the root */
      165 		call lock$lock_ast;			/* so we can change gtms safely */
      166 		astep = addr (sst_seg$) -> sst.root_astep;
      167 						/* if so get the astep from the sst */
      168 	     end;
      169 	else do;
      170 		ep = validate_entryp (kstep, (0));	/* We don't care what is wrong, and code is already zero */
      171 		if ep = null
      172 		then return;			/* if it was deleted, skip it */
      173 		astep = activate (ep, code);		/* Get pointer to ASTE of dir */
      174 						/* Dir oughtta have been locked, can't delete */
      175 		if astep = null
      176 		then call syserr (CRASH, "sum: dirmod failed to activate ^p", ep);
      177 	     end;
      178 	aste.gtms = "0"b;				/* tell page control that we really mean it */
      179 	old_dtm = aste.dtm;
      180 	call pc$updates (astep);			/* set the fms switch on */
      181 	dtm_changed = (old_dtm ^= aste.dtm);
      182 	aste.gtms = "1"b;				/* shut the door */
      183 	call lock$unlock_ast;
      184 	if pds$throttle_segment_state_changes 
      185 	then if dtm_changed
      186 	     then call limit_covert_channel (1);	/* setting dtm propogates up thru aim boundaries */
      187 	return;
      188 
      189 unlock:
      190      proc ();
      191 	if lsw
      192 	then call lock$dir_unlock (dp);
      193      end unlock;
      194 
      195 abort:
      196      proc (code);
      197 	dcl     code		 fixed bin (35);
      198 	a_code = code;
      199 	go to non_local_return;
      200      end abort;
      201 
      202 non_local_return:
      203 	return;
      204 
      205 validate_entryp:
      206      procedure (a_kstep, a_code) returns (pointer);
      207 
      208 /* *	VALIDATE_ENTRYP
      209*   *
      210*   *	This procedure is used to ensure a kste entry pointer is valid; that is,
      211*   *	that the directory salvager has not moved it, and that repeated entry
      212*   *	deletions and creations have not rendered it invalid.
      213*   *
      214*   *	If the kste entry pointer points to an entry which passes a few simple
      215*   *	checks, it is assumed to be valid, and is returned. Otherwise, the
      216*   *	entire directory is searched for an entry with the proper matching UID,
      217*   *	and a pointer to that entry is returned. If this, too, fails, a null
      218*   *	pointer is returned, and an error code appropriate to the purpose,
      219*   *	depending on access.
      220*   *
      221*   *	The initial check avoids touching anything other than the entry structure
      222*   *	itself, to minimize page faults on the directory.
      223*   *
      224*   *	The caller of this procedure is assumed to have the directory already
      225*   *	locked. This procedure is capable of signalling bad_dir_.
      226*   *
      227*   *	Written April 1975 for new KST/RNT system by R. Bratt
      228*   *	Modified 8/76 by S.E. Barr for new hash table format
      229*   *	Modified 07/77 by THVV for bad_dir_ check
      230*   *	Modified 12 August 1981, W. Olin Sibert, to move the code for generation
      231*   *	  of the error code here, from sum, and to change the calling sequence from
      232*   *	  (entryp, uid) to (kstep, code).
      233*   *	Modified 23 March 1984, K. Loepere to check entry.bs
      234**/
      235 
      236 /* Parameters */
      237 
      238 	dcl     a_code		 fixed bin (35) parameter;
      239 	dcl     a_kstep		 pointer parameter;
      240 
      241 /* Variables */
      242 
      243 	dcl     dp		 pointer;
      244 	dcl     entries_in_dir	 fixed bin;
      245 	dcl     entries_seen	 fixed bin;
      246 	dcl     ep		 pointer;
      247 	dcl     kstep		 pointer;
      248 	dcl     np		 pointer;
      249 	dcl     rep		 bit (18) aligned;
      250 	dcl     uid		 bit (36) aligned;
      251 
      252 	kstep = a_kstep;
      253 	uid = kstep -> kste.uid;
      254 	ep = kstep -> kste.entryp;			/* What we think it is now... */
      255 	dp = pointer (ep, 0);
      256 	np = addr (ep -> entry.primary_name);
      257 
      258 /* Consistency check:  UID matches in entry and in primary name; and type is valid. */
      259 /* Also ensure entry.bs is on for branches */
      260 
      261 	if uid = ep -> entry.uid
      262 	then if (ep -> entry.type = SEG_TYPE) | (ep -> entry.type = DIR_TYPE)
      263 	     then if ep -> entry.bs = "1"b  /* Must have entry.bs on. */
      264 		then if np -> names.owner = uid
      265 		     then do;
      266 			     a_code = 0;		/* Looks OK */
      267 			     return (ep);
      268 			end;
      269 
      270 /* If it fails the check, then it has moved. We must go hunting for it. */
      271 /* We should probably meter these events in active_hardcore_data.... */
      272 
      273 	entries_in_dir = dp -> dir.seg_count + dp -> dir.dir_count + dp -> dir.lcount;
      274 	entries_seen = 0;
      275 
      276 	do rep = dp -> dir.entryfrp repeat (ep -> entry.efrp) while (rep ^= "0"b);
      277 	     ep = pointer (dp, rep);			/* get a pointer to the next entry */
      278 	     entries_seen = entries_seen + 1;
      279 
      280 	     if entries_seen > entries_in_dir
      281 	     then signal condition (bad_dir_);
      282 
      283 	     if ep -> entry.bs
      284 	     then if (ep -> entry.owner ^= dp -> dir.uid)
      285 		     | (ep -> entry.type ^= SEG_TYPE & ep -> entry.type ^= DIR_TYPE)
      286 		then signal condition (bad_dir_);
      287 
      288 	     if ep -> entry.uid = uid
      289 	     then do;				/* match is found */
      290 		     kstep -> kste.entryp = ep;	/* Update KSTE, so this will work next time */
      291 		     a_code = 0;			/* Success */
      292 		     return (ep);
      293 		end;
      294 	end;					/* Of loop through directory */
      295 
      296 /* Branch is no longer there.  Since this (sum) is just an internal interface,
      297*   we simply return error_table_$seg_deleted.  The gate entries (within
      298*   dc_find) will return a better (censored) error code. */
      299 
      300 	a_code = error_table_$seg_deleted;
      301 	return (null ());				/* Indicate failure */
      302      end validate_entryp;
      303 
  1     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      304 
      305 
  2     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      306 
      307 
  3     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      308 
      309 
  4     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  4     2 
  4     3 /* Template for names of branches or links. Length = 14 words. */
  4     4 
  4     5 dcl np ptr;
  4     6 
  4     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  4     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  4     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  4    10 
  4    11     2 type bit (18) unaligned,			/* type = dir name */
  4    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  4    13 
  4    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  4    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  4    16 
  4    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  4    18     2 pad3 bit (18) unal,
  4    19 
  4    20     2 name char(32) aligned,
  4    21 
  4    22     2 checksum bit (36),				/* checksum from entry_rp */
  4    23 
  4    24     2 owner bit (36);				/* uid of entry */
  4    25 
  4    26 
  4    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      310 
      311 
  5     1 /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  5     2 
  5     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  5     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  5     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  5     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  5     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  5     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  5     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  5    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  5    11 
  5    12 dcl  access_name_type fixed bin static options (constant) init (1);
  5    13 dcl  acle_type fixed bin static options (constant) init (2);
  5    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  5    15 dcl  dir_type fixed bin static options (constant) init (4);
  5    16 dcl  link_type fixed bin static options (constant) init (5);
  5    17 dcl  name_type fixed bin static options (constant) init (6);
  5    18 dcl  seg_type fixed bin static options (constant) init (7);
  5    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  5    20 
  5    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      312 
      313 
  6     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  6     2 
  6     3 /*
  6     4*Modified March 1976 by R. Bratt 
  6     5*Modified November 1984 to remove hdr, Keith Loepere. */
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  6    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  6    11*     Add warning on use of kste.entryp.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl  pds$kstp ext ptr,
  6    16     (kstp, kstep) ptr;
  6    17 
  6    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  6    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  6    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  6    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  6    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  6    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  6    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  6    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  6    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  6    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  6    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  6    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  6    30     2 unused_2 bit (9) unaligned,
  6    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  6    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  6    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  6    34     2 end_of_kst bit (36);
  6    35 
  6    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  6    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  6    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  6    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  6    40     2 entryp ptr unaligned,				/* branch pointer */
  6    41 						/* See WARNING below for requirements to use entryp. */
  6    42     2 uid bit (36) aligned,				/* unique identifier */
  6    43     2 access_information unaligned,
  6    44       3 dtbm bit (36),				/* date time branch modified */
  6    45       3 extended_access bit (33),			/* extended access from the branch */
  6    46       3 access bit (3),				/* rew */
  6    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  6    48     2 pad1 bit (3) unaligned,
  6    49     2 flags unaligned,
  6    50       3 dirsw bit (1),				/* directory switch */
  6    51       3 allow_write bit (1),				/* set if initiated with write permission */
  6    52       3 priv_init bit (1),				/* privileged initiation */
  6    53       3 tms bit (1),				/* transparent modification switch */
  6    54       3 tus bit (1),				/* transparent usage switch */
  6    55       3 tpd bit (1),				/* transparent paging device switch */
  6    56       3 audit bit (1),				/* audit switch */
  6    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  6    58       3 pad bit (3),
  6    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  6    60 
  6    61 
  6    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    63 /*							       */
  6    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  6    65 /* entry associated with the kst entry, you must first validate its value    */
  6    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  6    67 /* the containing directory.  The containing directory must remain locked    */
  6    68 /* during the entire period when kste.entryp and the directory entry are     */
  6    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  6    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  6    71 /* directory since the dir entry could have been moved within the directory  */
  6    72 /* by another processor.					       */
  6    73 /*							       */
  6    74 /* If you only need a pointer to the directory containing the associated     */
  6    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  6    76 /*    pointer (kste.entryp, 0)				       */
  6    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  6    78 /*							       */
  6    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    80 
  6    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      314 
      315 
  7     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  7     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  7     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  7     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  7     5 
  7     6 dcl  sst_seg$ external;
  7     7 dcl  sstp ptr;
  7     8 
  7     9 dcl 1 sst based (sstp) aligned,
  7    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  7    11 
  7    12 /* SST HEADER */
  7    13 
  7    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  7    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  7    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  7    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  7    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  7    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  7    20 
  7    21     2 ptl bit (36),					/* global page table loop lock */
  7    22     2 astl bit (36),				/* global ast allocation block lock */
  7    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  7    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  7    25     2 nused fixed bin,				/* number of pages on used list */
  7    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  7    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  7    28 
  7    29     2 astap ptr,					/* aste array pointer */
  7    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  7    31     2 astsize fixed bin,				/* size of an AST entry */
  7    32     2 cmesize fixed bin,				/* size of a CME entry */
  7    33     2 root_astep ptr,				/* pointer to the root AST entry */
  7    34 
  7    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  7    36     2 level (0:3),					/* per-list information about ASTE's */
  7    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  7    38 
  7    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  7    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  7    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  7    42     2 strsize fixed bin,				/* Trailer size in words. */
  7    43 
  7    44 /* CORE MAP HEADER */
  7    45 
  7    46     2 cmp ptr,					/* pointer to start of core map */
  7    47     2 usedp bit (18),				/* pointer to first used core block */
  7    48     2 wtct fixed bin,				/* count of pages being written */
  7    49 
  7    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  7    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  7    52 						/* MISC */
  7    53 
  7    54     2 double_write fixed bin,				/* trigger for store through scheme */
  7    55 						/* 0 = no double writes,
  7    56*						   1 = all non-pd pages get written,
  7    57*						   2 = all directories get written */
  7    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  7    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  7    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  7    61 
  7    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  7    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  7    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  7    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  7    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  7    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  7    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  7    69 
  7    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  7    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  7    72 
  7    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  7    74 
  7    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  7    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  7    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  7    78 
  7    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  7    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  7    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  7    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  7    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  7    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  7    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  7    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  7    87 
  7    88 
  7    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  7    90 
  7    91     2 steps fixed bin,				/* number of steps taken around used list */
  7    92     2 needc fixed bin,				/* number of times core page needed */
  7    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  7    94     2 ctwait fixed bin,				/* number of times write counter was full */
  7    95     2 wired fixed bin,				/* number of pages wired by pc */
  7    96     2 laps fixed bin,				/* number of times around used list */
  7    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  7    98     2 skipu fixed bin,				/* because of being used */
  7    99 
  7   100     2 skipm fixed bin,				/* because of being modified */
  7   101     2 skipos fixed bin,				/* because out of service */
  7   102     2 aused fixed bin,				/* number of AST entries on used list */
  7   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  7   104     2 deact_count fixed bin,				/* count of deactivations */
  7   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  7   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  7   107 
  7   108     2 reads (8) fixed bin,				/* number of reads for each did */
  7   109     2 writes (8) fixed bin,				/* number of writes for each did */
  7   110 
  7   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  7   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  7   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  7   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  7   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  7   116     2 total_sf fixed bin,				/* total number of seg_faults */
  7   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  7   118     2 post_list_size fixed bin,
  7   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  7   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  7   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  7   122     2 pre_page_list_size fixed bin,
  7   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  7   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  7   125 
  7   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  7   127 
  7   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  7   129 
  7   130 /* MAIN MEMORY USAGE INFORMATION */
  7   131 
  7   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  7   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  7   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  7   135     2 recopies fixed bin,				/* number of times recopied because modified */
  7   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  7   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  7   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  7   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  7   140 
  7   141 /*  AST METERS  */
  7   142 
  7   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  7   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  7   145 
  7   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  7   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  7   148     2 asearches fixed bin,				/* count of full searches made */
  7   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  7   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  7   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  7   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  7   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  7   154 
  7   155     2 alaps fixed bin,				/* lap counter for AST list */
  7   156     2 updates fixed bin,				/* calls to updateb */
  7   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  7   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  7   159     2 total_bf fixed bin,				/* count of bound faults */
  7   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  7   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  7   162 
  7   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  7   164 
  7   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  7   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  7   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  7   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  7   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  7   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  7   171 
  7   172 /* PRE-PAGE METERS */
  7   173 
  7   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  7   175 
  7   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  7   177 
  7   178 
  7   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  7   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  7   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  7   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  7   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  7   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  7   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  7   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  7   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  7   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  7   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  7   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  7   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  7   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  7   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  7   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  7   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  7   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  7   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  7   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  7   199     2 activations fixed bin,				/* total count of activations */
  7   200     2 dir_activations fixed bin,			/* count of directory activations */
  7   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  7   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  7   203     2 evict_recover_data,				/* see evict_page.alm */
  7   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  7   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  7   206 
  7   207 /* Data for metering force_write facility 08/19/78 */
  7   208 
  7   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  7   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  7   211     2 fw_none fixed bin,				/* Force write wrote none */
  7   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  7   213 
  7   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  7   215     2 pf_unlock_ptl_meterings fixed bin,
  7   216 
  7   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  7   218     2 backup_activations fixed bin (35),		/* activations for backup */
  7   219     2 metering_flags aligned,				/* small chunks of misc. information */
  7   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  7   221       3 pad bit (35) unal,
  7   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  7   223 
  7   224 /* METERS FOR STACK TRUNCATION */
  7   225 
  7   226     2 (stk_truncate_should_didnt,			/* counts */
  7   227        stk_truncate_should_did,
  7   228        stk_truncate_shouldnt_didnt,
  7   229        stk_truncate_shouldnt_did) fixed bin (35),
  7   230     2 stk_pages_truncated fixed bin (35),
  7   231     2 stk_pages_truncated_in_core fixed bin (35),
  7   232 
  7   233 /* SUPPORT FOR PC SEGMOVES */
  7   234 
  7   235     2 segmove_lock aligned,
  7   236       3 pid bit (36) aligned,
  7   237       3 event bit (36) aligned,
  7   238       3 notify bit (1) aligned,
  7   239     2 segmove_io_limit fixed bin, /* max read aheads */
  7   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  7   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  7   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  7   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  7   244 
  7   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  7   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  7   247     2 segmove_vtocx fixed bin,			/* ditto */
  7   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  7   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  7   250 
  7   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  7   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  7   253     2 trace_sw aligned,				/* tracing control flags */
  7   254       3 pad_trace bit (32) unaligned,
  7   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  7   256       3 tty_trace bit (1) unaligned,
  7   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  7   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  7   259     2 new_pages fixed bin,				/* newly created pages */
  7   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  7   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  7   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  7   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  7   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  7   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  7   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  7   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  7   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  7   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  7   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  7   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  7   272 
  7   273 /* END INCLUDE FILE sst.incl.pl1 */
      316 
      317 
  8     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  8     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  8     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  8     4 
  8     5 /* This include file has an ALM version.  Keep 'em in sync! */
  8     6 
  8     7 dcl (
  8     8 
  8     9 /* The following constants define the message action codes.  This indicates
  8    10*how a message is to be handled.  */
  8    11 
  8    12      SYSERR_CRASH_SYSTEM	init (1),			
  8    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  8    14 
  8    15      SYSERR_TERMINATE_PROCESS	init (2),
  8    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  8    17 
  8    18      SYSERR_PRINT_WITH_ALARM	init (3),
  8    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  8    20 
  8    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  8    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  8    23 
  8    24      SYSERR_LOG_OR_PRINT	init (4),
  8    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  8    26 
  8    27      SYSERR_LOG_OR_DISCARD	init (5),
  8    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  8    29 
  8    30 
  8    31 /* The following constants are added to the normal severities to indicate
  8    32*different sorting classes of messages.  */
  8    33 
  8    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  8    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  8    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  8    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  8    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  8    39 	) fixed bin internal static options (constant);
  8    40 
  8    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      318 
      319 
      320 /* BEGIN MESSAGE DOCUMENTATION
      321*
      322*   Message:
      323*   sum: mylock error on XXX|0
      324*
      325*   S:	$crash
      326*
      327*   T:	$run
      328*
      329*   M:	A directory which should not be locked
      330*   is found locked.
      331*   $err
      332*
      333*   A:	$recover
      334*
      335*   Message:
      336*   sum: dirmod failed to activate XXX|0
      337*
      338*   S:	$crash
      339*
      340*   T:	$run
      341*
      342*   M:	Directory control could not activate a directory.
      343*   $err
      344*   It is possible that the AST is damaged.
      345*
      346*   A:	$recover
      347*
      348*   END MESSAGE DOCUMENTATION */
      349 
      350      end sum;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.4  sum.pl1                           >special_ldd>install>MR12.3-1114>sum.pl1
304          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
306          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
308          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
310          4    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
312          5    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
314          6    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
316          7    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
318          8    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000004 constant        fixed bin(17,0)          initial dcl 8-7 set ref 131* 175*
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 5-6 ref 261 283
SEG_TYPE                               constant        bit(18)                  initial packed unaligned dcl 5-9 ref 261 283
a_code                                 parameter       fixed bin(35,0)          dcl 238 in procedure "validate_entryp" set ref 205
                                                                                  266* 291* 300*
a_code                                 parameter       fixed bin(35,0)          dcl 47 in procedure "sum" set ref 97 104 111* 129*
                                                                                  198*
a_dp                                   parameter       pointer                  dcl 48 ref 142 149
a_ep                                   parameter       pointer                  dcl 49 set ref 97 104 112* 139*
a_kstep                                parameter       pointer                  dcl 239 ref 205 252
a_segptr                               parameter       pointer                  dcl 50 ref 97 104 109
a_type_lock                            parameter       bit(36)                  dcl 51 ref 97 104 110
activate                        000022 constant        entry                    external dcl 79 ref 173
addr                                                   builtin function         dcl 91 ref 166 256
aste                                   based           structure                level 1 dcl 1-11
astep                           000122 automatic       pointer                  dcl 1-9 set ref 166* 173* 175 178 179 180* 181 182
bad_dir_                        000000 stack reference condition                dcl 94 ref 280 283
baseno                                                 builtin function         dcl 91 ref 113 113 159 159
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 2-8 ref 261 283
change_pclock            62            based           fixed bin(35,0)          level 2 dcl 3-11 set ref 152* 156* 156
code                                   parameter       fixed bin(35,0)          dcl 197 in procedure "abort" ref 195 198
code                            000100 automatic       fixed bin(35,0)          dcl 55 in procedure "sum" set ref 113* 114 114* 122*
                                                                                  123 123 123* 129 133* 137* 159* 161 173*
dir                                    based           structure                level 1 dcl 3-11
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 273
dp                              000154 automatic       pointer                  dcl 243 in procedure "validate_entryp" set ref 255*
                                                                                  273 273 273 276 277 283
dp                              000126 automatic       pointer                  dcl 3-9 in procedure "sum" set ref 120* 122* 131*
                                                                                  191*
dtm                       7            based           bit(36)                  level 2 packed packed unaligned dcl 1-11 ref 179 181
dtm_changed                     000101 automatic       bit(1)                   dcl 56 set ref 181* 184
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 2-8 ref 294
entries_in_dir                  000156 automatic       fixed bin(17,0)          dcl 244 set ref 273* 280
entries_seen                    000157 automatic       fixed bin(17,0)          dcl 245 set ref 274* 278* 278 280
entry                                  based           structure                level 1 dcl 2-8
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 3-11 ref 276
entryp                    3            based           pointer                  level 2 packed packed unaligned dcl 6-36 set ref 120
                                                                                  254 290*
ep                              000124 automatic       pointer                  dcl 2-6 in procedure "sum" set ref 133* 134 139 170*
                                                                                  171 173* 175*
ep                              000160 automatic       pointer                  dcl 246 in procedure "validate_entryp" set ref 254*
                                                                                  255 256 261 261 261 261 267 277* 283 283 283 283
                                                                                  288 290 292 294
error_table_$mylock             000010 external static fixed bin(35,0)          dcl 66 ref 123
error_table_$root               000012 external static fixed bin(35,0)          dcl 67 set ref 117*
error_table_$seg_deleted        000014 external static fixed bin(35,0)          dcl 68 ref 300
fixed                                                  builtin function         dcl 91 ref 113 113 159 159
fixedoverflow                   000114 stack reference condition                dcl 94 ref 150
get_kstep                       000024 constant        entry                    external dcl 80 ref 113 159
gtms                      5(03)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  178* 182*
kste                                   based           structure                level 1 dcl 6-36
kstep                           000162 automatic       pointer                  dcl 247 in procedure "validate_entryp" set ref 252*
                                                                                  253 254 290
kstep                           000130 automatic       pointer                  dcl 6-15 in procedure "sum" set ref 113* 117 120
                                                                                  133* 159* 163 170*
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 273
limit_covert_channel            000026 constant        entry                    external dcl 81 ref 184
lock$dir_unlock                 000030 constant        entry                    external dcl 82 ref 191
lock$dir_wait                   000032 constant        entry                    external dcl 83 ref 122
lock$lock_ast                   000034 constant        entry                    external dcl 84 ref 165
lock$unlock_ast                 000036 constant        entry                    external dcl 85 ref 183
lsw                             000102 automatic       bit(1)                   dcl 57 set ref 121* 128* 191
m                               000020 external static bit(1)                   level 2 packed packed unaligned dcl 72 ref 147
my_lock_entry                   000103 automatic       bit(1)                   initial dcl 58 set ref 58* 102* 126
names                                  based           structure                level 1 dcl 4-7
np                              000164 automatic       pointer                  dcl 248 set ref 256* 261
null                                                   builtin function         dcl 91 ref 112 134 171 175 301
old_dtm                         000104 automatic       bit(36)                  dcl 59 set ref 179* 181
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "sum" ref 283
owner                    15            based           bit(36)                  level 2 in structure "names" dcl 4-7 in procedure
                                                                                  "sum" ref 261
pc$updates                      000040 constant        entry                    external dcl 86 ref 180
pds$throttle_segment_state_changes
                                000016 external static bit(1)                   dcl 70 ref 184
pds$transparent                 000020 external static structure                level 1 dcl 72
pointer                                                builtin function         dcl 91 ref 255 277
primary_name             10            based           bit(504)                 level 2 packed packed unaligned dcl 2-8 set ref 256
ptr                                                    builtin function         dcl 91 ref 120
rep                             000166 automatic       bit(18)                  dcl 249 set ref 276* 276* 277*
root_astep               36            based           pointer                  level 2 dcl 7-9 ref 166
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 273
segptr                          000106 automatic       pointer                  dcl 60 set ref 109* 113 113
sst                                    based           structure                level 1 dcl 7-9
sst_seg$                        000044 external static fixed bin(17,0)          dcl 7-6 set ref 166
syserr                          000042 constant        entry                    external dcl 87 ref 131 175
target_dp                       000110 automatic       pointer                  dcl 61 set ref 149* 152 156 156 159 159
type                      1            based           bit(18)                  level 2 packed packed unaligned dcl 2-8 ref 261 261
                                                                                  283 283
type_lock                       000112 automatic       bit(36)                  dcl 62 set ref 110* 122*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "sum" ref 261 288
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 3-11 in procedure
                                                                                  "sum" ref 283
uid                             000167 automatic       bit(36)                  dcl 250 in procedure "validate_entryp" set ref 253*
                                                                                  261 261 288
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 6-36 in procedure
                                                                                  "sum" ref 117 163 253

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 5-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 5-4
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 8-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 8-7
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 5-5
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 5-10
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 8-7
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 5-7
LOG                                    internal static fixed bin(17,0)          initial dcl 8-7
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 5-8
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 8-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 8-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 8-7
access_name_type                       internal static fixed bin(17,0)          initial dcl 5-12
acle_type                              internal static fixed bin(17,0)          initial dcl 5-13
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
dir_header_type                        internal static fixed bin(17,0)          initial dcl 5-14
dir_type                               internal static fixed bin(17,0)          initial dcl 5-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 5-19
kst                                    based           structure                level 1 dcl 6-18
kstp                                   automatic       pointer                  dcl 6-15
link_type                              internal static fixed bin(17,0)          initial dcl 5-16
name_type                              internal static fixed bin(17,0)          initial dcl 5-17
np                                     automatic       pointer                  dcl 4-5
pds$kstp                               external static pointer                  dcl 6-15
seg_aste                               based           structure                level 1 dcl 1-96
seg_type                               internal static fixed bin(17,0)          initial dcl 5-18
sstp                                   automatic       pointer                  dcl 7-7
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
abort                           000517 constant        entry                    internal dcl 195 ref 114 117 123 137
clocked                         000324 constant        label                    dcl 159 ref 153
dirmod                          000256 constant        entry                    external dcl 142
getbranch                       000073 constant        entry                    external dcl 104
getbranch_root_my               000060 constant        entry                    external dcl 97
non_local_return                000503 constant        label                    dcl 202 ref 199
sum                             000044 constant        entry                    external dcl 14
unlock                          000504 constant        entry                    internal dcl 189 ref 136
validate_entryp                 000525 constant        entry                    internal dcl 205 ref 133 170

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1142        1210     721        1152
Length      1544     721        46         320     221           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sum                                 172 external procedure  is an external procedure.  
on unit on line 150                  64 on unit               
unlock                                  internal procedure  shares stack frame of external procedure sum.  
abort                                   internal procedure  shares stack frame of external procedure sum.  
validate_entryp                         internal procedure  shares stack frame of external procedure sum.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
sum                      000100 code                        sum
                         000101 dtm_changed                 sum
                         000102 lsw                         sum
                         000103 my_lock_entry               sum
                         000104 old_dtm                     sum
                         000106 segptr                      sum
                         000110 target_dp                   sum
                         000112 type_lock                   sum
                         000122 astep                       sum
                         000124 ep                          sum
                         000126 dp                          sum
                         000130 kstep                       sum
                         000154 dp                          validate_entryp
                         000156 entries_in_dir              validate_entryp
                         000157 entries_seen                validate_entryp
                         000160 ep                          validate_entryp
                         000162 kstep                       validate_entryp
                         000164 np                          validate_entryp
                         000166 rep                         validate_entryp
                         000167 uid                         validate_entryp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           signal_op
enable_op           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
activate                      get_kstep                     limit_covert_channel          lock$dir_unlock
lock$dir_wait                 lock$lock_ast                 lock$unlock_ast               pc$updates
syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$mylock           error_table_$root             error_table_$seg_deleted
pds$throttle_segment_state_changes                          pds$transparent               sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     58 000040        14 000043        97 000052       102 000066       104 000070       109 000101       110 000105
    111 000107       112 000110       113 000112       114 000131       117 000135       120 000150       121 000154
    122 000156       123 000172       126 000202       128 000204       129 000205       130 000207       131 000210
    133 000236       134 000240       136 000244       137 000245       139 000247       140 000252       142 000253
    147 000264       149 000271       150 000275       152 000311       153 000314       156 000317       159 000324
    161 000343       163 000345       165 000351       166 000356       168 000362       170 000363       171 000366
    173 000372       175 000405       178 000435       179 000440       180 000442       181 000451       182 000456
    183 000460       184 000465       187 000502       202 000503       189 000504       191 000505       193 000516
    195 000517       198 000521       199 000524       205 000525       252 000527       253 000532       254 000534
    255 000536       256 000540       261 000542       266 000562       267 000563       273 000565       274 000601
    276 000602       277 000610       278 000613       280 000614       283 000622       288 000645       290 000651
    291 000653       292 000655       294 000657       300 000663       301 000667


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
