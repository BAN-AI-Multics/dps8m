	COMPILATION LISTING OF SEGMENT put_aste
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1021.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /*
       14*			put_aste (astep)
       15*
       16*
       17*
       18*
       19*FUNCTION -
       20*
       21*The procedure "put_aste" frees  the  ASTE  pointed  to  by  the  input  argument
       22*"astep".  No matter if the ASTE was in the circular list or not, "put_aste" will
       23*put it in the list associated with the size of its  page  table,  at  the  first
       24*position.
       25*
       26*It  does  not  concern  itself  with  the  AST lock. It assumes there is no race
       27*condition. It is the responsibility of the caller to make sure no race condition
       28*exists. If called by the initializer or  shutdown,  it  may  be  called  without
       29*locking  the AST. In normal cases, however, the caller must make sure the AST is
       30*locked before issuing the call and it will be unlocked upon return as soon as it
       31*is safe to do so.
       32*
       33*All items of the ASTE are zeroed except fp, bp, ptsi and marker. All  PTW's  are
       34*initialized with a page not core flag and a coded null disk address.
       35*
       36*
       37*
       38*MODIFICATIONS -
       39*
       40*04/17/75	A. Bensoussan - Modified for the new storage system.
       41*03/21/81	W. Olin Sibert, for ADP PTW formats
       42*04/17/81	WOS -- remove ptw.os trap, convert for ptw_util_
       43*11/01/82  J. Bongiovanni, for synchronized segments
       44*84-01-16  BIM to zero aste counters.
       45*
       46**/
       47 
       48 
       49 put_aste: procedure (a_astep);
       50 
       51 
       52 dcl  a_astep	ptr;
       53 dcl (i, pts)	fixed bin(17);
       54 dcl  ptsi		fixed bin (3);
       55 dcl  ptp		ptr;
       56 dcl  pt		(1: pts) bit (36) aligned based;
       57 
       58 dcl  hc_dm_util$deactivate    entry (fixed bin (3));
       59 dcl  ptw_util_$make_null	entry (pointer, bit (22) aligned);
       60 dcl  thread$cin		entry (ptr, bit (18) unal);
       61 dcl  thread$out		entry (ptr, bit (18) unal);
       62 
       63 dcl (addr, addwordno, fixed, rel) builtin;
       64 
       65 
       66 
       67 	sstp = addr (sst_seg$);			/* get pointers */
       68 	astep = a_astep;				/* copy argument */
       69 
       70 	ptsi = fixed (astep -> aste.ptsi, 2);		/* get page table size index */
       71 	pts = sstp -> sst.pts (ptsi);			/* get page table size */
       72 
       73 
       74           if aste.synchronized
       75 	     then call hc_dm_util$deactivate (ptsi);
       76 
       77 	if sst.ausedp(ptsi) ^= rel(astep) then		/* If ASTE not first in list, make it first */
       78 	     do;
       79 	     if aste.fp ^= "0"b then 			/* If ASTE is in the list, take it out */
       80 		call thread$out (astep, sst.ausedp(ptsi));
       81 	     call thread$cin (astep, sst.ausedp(ptsi));	/* Put ASTE at the end of the list */
       82 	     sst.ausedp (ptsi) = rel (astep);		/* Move current ptr to ASTE to make it first */
       83 	     end;
       84 
       85 	aste.pvtx = 0;				/* Set pvtx to zero (unvalid pvtx) to prevent emergency
       86*						  shutdown from updatig the vtoce with wrong addresses */
       87 
       88 	aste.np, aste.csl, aste.records = ""b;		/* counters are irrelevant */
       89 
       90 /* There used to be a trap here which inspected ptw.os for each PTW, crashing if it was
       91*   found on, but this trap has outlived its usefulness. */
       92 
       93 	ptp = addwordno (astep, sst.astsize);		/* Start with page zero */
       94 
       95 	do i = 1 to pts;				/* Write coded null addresses in all PTW's */
       96 	     call ptw_util_$make_null (addr (ptp -> pt (i)) , put_aste_null_addr);
       97 	end;
       98 
       99 	astep -> aste_part.two = "0"b;		/* Zero the ASTE except fb, bp, ptsi and marker */
      100 
      101 	return;
      102 
      103  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
      103 
      104  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      104 
      105  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  3     2 /* Added segmove values, Benson Margulies, 84-01 */
  3     3 
  3     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  3     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  3     6      get_aste_null_addr init			("3770110"b3),
  3     7      make_sdw_null_addr init			("3770120"b3),
  3     8      put_aste_null_addr init			("3770130"b3),
  3     9      page_bad_pd_null_addr init		("3770150"b3),
  3    10      list_deposit_null_addr init		("3770160"b3),
  3    11      get_file_map_null_addr init		("3770170"b3),
  3    12      fill_page_table_null_addr init		("3770200"b3),
  3    13      init_sst_null_addr init			("3770210"b3),
  3    14      get_file_map_vt_null_addr init		("3770220"b3),
  3    15      unprotected_null_addr init		("3770230"b3),
  3    16      page_bad_null_addr init			("3770240"b3),
  3    17      page_problem_null_addr init		("3770250"b3),
  3    18      page_parity_null_addr init		("3770260"b3),
  3    19      page_devparity_null_addr init		("3770270"b3),
  3    20      segmove_old_addr_null_addr init              ("3770300"b3),
  3    21      segmove_new_addr_null_addr init		("3770310"b3),
  3    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  3    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  3    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  3    25 
  3    26 dcl (create_vtoce_null_addr init		("777777"b3),
  3    27      update_vtoce_null_addr init		("777776"b3),
  3    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  3    29      truncate_vtoce_null_addr init		("777002"b3),
  3    30      pv_salv_null_addr init			("777004"b3),
  3    31      pv_scav_null_addr init			("777006"b3),
  3    32      volume_reloader_null_addr init		("777774"b3),
  3    33      volume_retriever_null_addr init		("777773"b3),
  3    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  3    35 
  3    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
      105 
      106 
      107 	end put_aste;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0808.5  put_aste.pl1                      >spec>install>1112>put_aste.pl1
103          1    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
104          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
105          3    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_astep                                parameter       pointer                  dcl 52 ref 49 68
addr                                                   builtin function         dcl 63 ref 67 96 96
addwordno                                              builtin function         dcl 63 ref 93
aste                                   based           structure                level 1 dcl 2-11
aste_part                              based           structure                level 1 dcl 2-89
astep                           000110 automatic       pointer                  dcl 2-9 set ref 68* 70 74 77 79 79* 81* 82 85 88 88
                                                                                  88 93 99
astsize                  33            based           fixed bin(17,0)          level 2 dcl 1-9 ref 93
ausedp                   44            based           bit(18)                  array level 3 packed packed unaligned dcl 1-9 set
                                                                                  ref 77 79* 81* 82*
csl                      12            based           bit(9)                   level 2 packed packed unaligned dcl 2-11 set ref 88*
fixed                                                  builtin function         dcl 63 ref 70
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 79
hc_dm_util$deactivate           000010 constant        entry                    external dcl 58 ref 74
i                               000100 automatic       fixed bin(17,0)          dcl 53 set ref 95* 96 96*
level                    44            based           structure                array level 2 dcl 1-9
np                       12(27)        based           bit(9)                   level 2 packed packed unaligned dcl 2-11 set ref 88*
pt                                     based           bit(36)                  array dcl 56 set ref 96 96
ptp                             000104 automatic       pointer                  dcl 55 set ref 93* 96 96
pts                             000101 automatic       fixed bin(17,0)          dcl 53 in procedure "put_aste" set ref 71* 95
pts                      40            based           fixed bin(17,0)          array level 2 in structure "sst" dcl 1-9
                                                                                  in procedure "put_aste" ref 71
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "put_aste" ref 70
ptsi                            000102 automatic       fixed bin(3,0)           dcl 54 in procedure "put_aste" set ref 70* 71 74* 77
                                                                                  79 81 82
ptw_util_$make_null             000012 constant        entry                    external dcl 59 ref 96
put_aste_null_addr              000000 constant        bit(22)                  initial dcl 3-4 set ref 96*
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 2-11 set ref 85*
records                  12(18)        based           bit(9)                   level 2 packed packed unaligned dcl 2-11 set ref 88*
rel                                                    builtin function         dcl 63 ref 77 82
sst                                    based           structure                level 1 dcl 1-9
sst_seg$                        000020 external static fixed bin(17,0)          dcl 1-6 set ref 67
sstp                            000106 automatic       pointer                  dcl 1-7 set ref 67* 71 77 79 81 82 93
synchronized             13(21)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 74
thread$cin                      000014 constant        entry                    external dcl 60 ref 81
thread$out                      000016 constant        entry                    external dcl 61 ref 79
two                       1            based           bit(388)                 level 2 packed packed unaligned dcl 2-89 set ref 99*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
append_null_addr                       internal static bit(22)                  initial dcl 3-4
asta                                   based           bit(432)                 array dcl 2-86
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 3-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 3-26
fill_page_table_null_addr              internal static bit(22)                  initial dcl 3-4
get_aste_null_addr                     internal static bit(22)                  initial dcl 3-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 3-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 3-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 3-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 3-4
list_deposit_null_addr                 internal static bit(22)                  initial dcl 3-4
make_sdw_null_addr                     internal static bit(22)                  initial dcl 3-4
page_bad_null_addr                     internal static bit(22)                  initial dcl 3-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 3-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 3-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 3-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 3-4
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 3-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 3-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 3-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 3-26
salv_truncate_null_addr                internal static bit(18)                  initial dcl 3-26
seg_aste                               based           structure                level 1 dcl 2-96
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 3-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 3-4
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 3-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 3-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 3-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 3-26
volume_reloader_null_addr              internal static bit(18)                  initial dcl 3-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 3-26

NAME DECLARED BY EXPLICIT CONTEXT.
put_aste                        000005 constant        entry                    external dcl 49

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       242         264     155         252
Length       474     155        22         174      65           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
put_aste                             88 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
put_aste                 000100 i                           put_aste
                         000101 pts                         put_aste
                         000102 ptsi                        put_aste
                         000104 ptp                         put_aste
                         000106 sstp                        put_aste
                         000110 astep                       put_aste

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hc_dm_util$deactivate         ptw_util_$make_null           thread$cin                    thread$out

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     49 000002        67 000012        68 000014        70 000020        71 000024        74 000026        77 000037
     79 000047        81 000063        82 000076        85 000103        88 000106        93 000114        95 000120
     96 000127        97 000143        99 000145       101 000151


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
