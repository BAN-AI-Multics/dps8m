	COMPILATION LISTING OF SEGMENT tc_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1023.4 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style3 */
       14 
       15 tc_util:
       16      proc;
       17 
       18 /* DESCRIPTION:
       19*   Various traffic control utility functions which used to live in pxss.
       20*   They need to run wired and masked, with various traffic control locks,
       21*   but are called infrequently.
       22*
       23*   Entries:
       24*
       25*   check_abort         - returns non-zero code if a quit or trm_ IPS signal,
       26*		     or a stop is pending for the process. Can be used
       27*		     by long-running ring-0 procedures to simulate quits.
       28*
       29*   get_aptep	   - validates a processid and returns the apte pointer.
       30*
       31*   get_ipc_operands    - returns to the caller the values of apte.ipc_r_offset
       32*                         and apte.ipc_r_factor.  These are used by user-ring
       33*                         (and hardcore) IPC event channel validation and
       34*                         decoding.  It is the target of hcs_$get_ipc_operands.
       35*
       36*   get_ipc_operands_priv
       37*                       - returns to the caller the values of apte.ipc_r_offset
       38*		     and apte.ipc_r_factor for a specified process.  This
       39*		     is a highly privileged entrypoint and intended only
       40*		     to be used by hardcore IPC (hc_ipc) and the
       41*		     Initializer process (dialup_).  It is the target
       42*		     of the gate hphcs_$get_ipc_operands_priv.
       43*
       44*   ips_wakeup	   - send a given named IPS signal to a given process.
       45*
       46*   process_status      - return information about a process.
       47*
       48*   resume_tc	   - unfreeze traffic control scheduling (see suspend_tc
       49*		     described below).
       50*
       51*   set_cpu_monitor     - establishes a wakeup call to the term processid
       52*		     after a given amount of virtual CPU time has
       53*		     been used by a specified process.
       54*
       55*   set_timax           - sets timax for a process
       56*
       57*   suspend_tc	   - freeze traffic control's running of processes, with
       58*		     the exception of all idles and the calling process.
       59*
       60*   validate_processid  - determines whether a processid coresponds to an
       61*		     active process.
       62*
       63*   Moved from pxss and converted to PL1 by J. Bongiovanni, September 1981
       64*   Modified June 1982, J. Bongiovanni, to add validate_processid
       65*   Modified September 1982, J. Bongiovanni, to add check_abort
       66*   Modififed February 1983, E. N. Kittlitz, to clear cpu timer if arg < 0.
       67*   Modified 831111 for validate_processid_all entry -E. A. Ranzenbach
       68*   Modified 831213, E. N. Kittlitz, to remove validate_processid_all and 
       69*      several intermediate changes.
       70*   Modified: 07/15/84 by R. Michael Tague:  Added ips_wakeup.
       71*   Modified October 1984 by M. Pandolf to add suspend_tc and resume_tc
       72*   Modified 1984-11-11 by E. Swenson for IPC event channel validation
       73*      support of hcs_$get_ipc_operands.  Also added highly privileged
       74*      entrypoint get_ipc_operands_priv which is used in ring-0 and as
       75*      the garget of the gate hphcs_$get_ipc_operands_priv.      
       76**/
       77 
       78 /*  Parameter  */
       79 
       80 dcl	a_allow_special_procs
       81 			bit (1) aligned;		/* allow special processes in get_apte search */
       82 dcl	a_code		fixed bin (35) parameter;	/* standard error code */
       83 dcl	a_delta_vcpu	fixed bin (71) parameter;	/* increment to current VCPU for wakeup */
       84 dcl	a_info_ptr	ptr;			/* pointer to structure of process information */
       85 dcl	a_ips_signal_name	char (*);			/* name of the ips signal to be sent */
       86 dcl	a_processid	bit (36) aligned parameter;	/* target process ID */
       87 dcl	a_timax		fixed bin (35) parameter;	/* value to set timax to */
       88 dcl	P_ipc_r_offset	fixed bin (18) parameter;	/* IPC validation operand */
       89 dcl	P_ipc_r_factor	fixed bin (35) parameter;	/* IPC validation operand */
       90 
       91 /*  Automatic  */
       92 
       93 dcl	arg_list_ptr	ptr;			/* argument list pointer for ips_wakeup */
       94 dcl	code		fixed bin (35);		/* return code */
       95 dcl	delta_vcpu	fixed bin (71);		/* copy of increment to VCPU */
       96 dcl	ipc_r_offset	fixed bin (18);		/* automatic copy for wiring */
       97 dcl	ipc_r_factor	fixed bin (35);		/* automatic copy for wiring */
       98 dcl	ips_mask_index	fixed bin;		/* do loop index */
       99 dcl	ips_signal_name	char (32);		/* copy of ips signal name */
      100 dcl	oldmask		fixed bin (71);		/* value of interrupt mask at wire_mask */
      101 dcl	process_mp_state	fixed bin;		/* loaded (ON=1) + eligible (ON=2) */
      102 dcl	process_state	fixed bin;		/* traffic control state */
      103 dcl	process_timax	fixed bin (35);		/* copy of value to set timax for process */
      104 dcl	processid		bit (36) aligned;		/* copy of process ID */
      105 dcl	ptwp		ptr;			/* pointer to page table for stack */
      106 
      107 /*  Based  */
      108 
      109 dcl	1 a_process_status	aligned based (a_info_ptr) like process_status_return;
      110 dcl	1 my_arg_list	aligned based (arg_list_ptr) like arg_list;
      111 
      112 /*  Entry  */
      113 
      114 dcl	cu_$arg_list_ptr	entry (ptr);
      115 dcl	lock$lock_fast	entry (ptr);
      116 dcl	lock$unlock_fast	entry (ptr);
      117 dcl	pmut$wire_and_mask	entry (fixed bin (71), ptr);
      118 dcl	pmut$unwire_unmask	entry (fixed bin (71), ptr);
      119 dcl	pxss$lock_apte	entry (bit (36) aligned, ptr, fixed bin (35));
      120 dcl	pxss$ips_wakeup	entry (bit (36) aligned, bit (36) aligned);
      121 dcl	pxss$suspend_getwork
      122 			entry ();
      123 dcl	pxss$unlock_apte	entry (ptr);
      124 dcl	signal_		entry options (variable);
      125 dcl	wire_proc$unwire_me entry;
      126 dcl	wire_proc$wire_me	entry;
      127 
      128 /*  External  */
      129 
      130 dcl	error_table_$quit_term_abort
      131 			fixed bin (35) external;
      132 dcl	error_table_$process_unknown
      133 			fixed bin (35) external;
      134 dcl	pds$apt_ptr	ptr external;
      135 dcl	tc_data$		external;
      136 dcl	tc_data$abort_ips_mask
      137 			bit (36) aligned external;
      138 dcl	tc_data$apt	bit (36) aligned external;
      139 dcl	tc_data$apt_size	fixed bin external;
      140 dcl	tc_data$tc_suspend_lock
      141 			bit (36) aligned external;
      142 dcl	tc_data$timax	fixed bin (35) external;
      143 
      144 
      145 /*  Builtin  */
      146 
      147 dcl	addr		builtin;
      148 dcl	bin		builtin;
      149 dcl	divide		builtin;
      150 dcl	mod		builtin;
      151 dcl	null		builtin;
      152 dcl	ptr		builtin;
      153 dcl	rel		builtin;
      154 dcl	size		builtin;
      155 dcl	unspec		builtin;
      156 
      157 	return;					/* no tc_util entry */
      158 						/* END OF DECLARATIONS */
      159 
      160 
      161 /* CHECK_ABORT - checks for quit or term IPS signal pending, or stop pending. */
      162 
      163 check_abort:
      164      entry (a_code);
      165 
      166 	a_code = 0;
      167 
      168 	aptep = pds$apt_ptr;
      169 	if apte.flags.stop_pending | ((apte.ips_message & tc_data$abort_ips_mask) ^= ""b)
      170 	then a_code = error_table_$quit_term_abort;
      171 
      172 	return;
      173 
      174 
      175 /* GET_APTEP	    - validates that a processid corresponds to an active
      176*		      process and returns the apte pointer.
      177**/
      178 
      179 get_aptep:
      180      entry (a_processid, a_allow_special_procs) returns (ptr);
      181 
      182 	aptep = PROCESSID_TO_APTE ((a_processid), (a_allow_special_procs));
      183 	return (aptep);
      184 
      185 
      186 /* IPS_WAKEUP            - Look up the given ips signal name in sys_info and
      187*		       send the corresponding ips signal bit string to
      188*		       pxss$ips_wakeup.
      189**/
      190 
      191 ips_wakeup:
      192      entry (a_processid, a_ips_signal_name);
      193 
      194 /* For release MR11, this entry will check its calling arguments
      195*   to see if the old calling sequence of (bit (36), char (4)) was
      196*   used.  If so a gate_error signal is raised.  This should be taken
      197*   out by the next release.
      198**/
      199 	call cu_$arg_list_ptr (arg_list_ptr);
      200 	if my_arg_list.header.desc_count = 0
      201 	then call signal_ ("gate_err");
      202 	else do;
      203 		processid = a_processid;
      204 		ips_signal_name = a_ips_signal_name;
      205 		do ips_mask_index = 1 to sys_info$ips_mask_data.count
      206 		     while (ips_signal_name ^= sys_info$ips_mask_data.mask (ips_mask_index).name);
      207 		end;
      208 		if ips_mask_index <= sys_info$ips_mask_data.count
      209 		then call pxss$ips_wakeup (processid, sys_info$ips_mask_data.mask (ips_mask_index).mask);
      210 	     end;
      211 	return;
      212 
      213 
      214 /* PROCESS_STATUS      - return information about a process.
      215*
      216*		     fills in info structure like process_status_return.
      217*		     If processid not found, aptptr in structure is null.
      218*
      219**/
      220 
      221 process_status:
      222      entry (a_info_ptr);
      223 
      224 	processid = a_process_status.target_proc;	/* copy to stack to be wired */
      225 	a_process_status.up_exec = 0;
      226 	a_process_status.up_mp = 0;
      227 	a_process_status.aptptr = null ();
      228 
      229 	process_mp_state = 1;
      230 
      231 	aptep = PROCESSID_TO_APTE (processid, "0"b);
      232 	if aptep ^= null ()
      233 	then do;
      234 		process_state = bin (apte.state, 17);
      235 		if apte.flags.loaded
      236 		then process_mp_state = process_mp_state + 2;
      237 		if apte.flags.eligible
      238 		then process_mp_state = process_mp_state + 1;
      239 						/* fill in structure */
      240 		a_process_status.total_page_faults = apte.page_faults;
      241 		a_process_status.aptptr = aptep;
      242 		a_process_status.up_exec = process_state;
      243 		a_process_status.up_mp = process_mp_state;
      244 		a_process_status.up_block = apte.state_change_time;
      245 						/* mis-named */
      246 		a_process_status.up_cpu = apte.time_used_clock;
      247 		a_process_status.up_page = apte.paging_measure;
      248 		a_process_status.virtual_cpu = apte.virtual_cpu_time;
      249 		a_process_status.extra2 = 0;
      250 	     end;
      251 
      252 	return;
      253 
      254 /* SET_CPU_MONITOR     - establishes a wakeup call to the term processid
      255*		     after a given amount of virtual CPU time has
      256*		     been used by a specified process.
      257*
      258*   return code = 0     - wakeup established
      259*   = error_table_$process_unknown  - no such process
      260*
      261**/
      262 
      263 set_cpu_monitor:
      264      entry (a_processid, a_delta_vcpu, a_code);
      265 
      266 	processid = a_processid;			/* copy to stack to be wired */
      267 	delta_vcpu = a_delta_vcpu;
      268 
      269 	call WIRE_MASK;
      270 
      271 /* ---------- WIRED AND MASKED ---------- */
      272 
      273 	call pxss$lock_apte (processid, aptep, code);	/* try to lock target APTE */
      274 	if code = 0
      275 	then do;
      276 		if delta_vcpu < 0
      277 		then apte.cpu_monitor = 0;
      278 		else apte.cpu_monitor = divide (apte.virtual_cpu_time + delta_vcpu, 1024, 35);
      279 		call pxss$unlock_apte (aptep);
      280 	     end;
      281 
      282 	call UNWIRE_UNMASK;
      283 
      284 /* ---------- UNWIRED AND and UNMASKED ---------- */
      285 
      286 	if code ^= 0
      287 	then a_code = error_table_$process_unknown;
      288 	else a_code = 0;
      289 
      290 	return;
      291 
      292 /* SET_TIMAX           - sets timax for a process
      293*
      294*   If the value is 0, it is reset to the system default
      295**/
      296 
      297 set_timax:
      298      entry (a_processid, a_timax);
      299 
      300 	processid = a_processid;			/* copy to stack to be wired */
      301 	process_timax = a_timax;
      302 	if process_timax <= 0
      303 	then process_timax = tc_data$timax;
      304 
      305 	call WIRE_MASK;
      306 
      307 /* ---------- WIRED AND MASKED ---------- */
      308 
      309 	call pxss$lock_apte (processid, aptep, code);	/* Try to lock target APTE */
      310 	if code = 0
      311 	then do;					/* Process exists and is locked */
      312 		apte.timax = process_timax;
      313 		call pxss$unlock_apte (aptep);
      314 	     end;
      315 
      316 	call UNWIRE_UNMASK;
      317 
      318 /* ---------- UNWIRED AND UNMASKED ---------- */
      319 
      320 	return;
      321 
      322 /* VALIDATE_PROCESSID  - validates that a processid corresponds to an active
      323*		     process.
      324*
      325*   return code = 0     - process exists
      326*   = error_table_$process_unknown - no such process
      327*
      328**/
      329 
      330 validate_processid:
      331      entry (a_processid, a_code);
      332 
      333 	a_code = 0;
      334 
      335 	aptep = PROCESSID_TO_APTE ((a_processid), "0"b);
      336 	if aptep = null ()
      337 	then a_code = error_table_$process_unknown;
      338 
      339 	return;
      340 
      341 /* SUSPEND_TC	   - turn on the mechanism in getwork (of pxss fame) that
      342*		     suspends the running of processes, leaving only the
      343*		     idles and the caller available for running.  this
      344*		     state occurs only when tc_data$tc_suspend_lock is
      345*		     locked.  there are no parameters to this routine; its
      346*		     caller is guarenteed to be the only one running upon
      347*		     its return.
      348**/
      349 
      350 suspend_tc:
      351      entry ();
      352 
      353 	call lock$lock_fast (addr (tc_data$tc_suspend_lock));
      354 						/* get the lock, possibly */
      355 						/* entering the WAIT state */
      356 
      357 	call pxss$suspend_getwork ();			/* connect all processors */
      358 						/* and loop until only we remain */
      359 
      360 	return;
      361 
      362 
      363 /* RESUME_TC	   - disable the suspension mechanism in getwork. */
      364 
      365 resume_tc:
      366      entry ();
      367 
      368 	call lock$unlock_fast (addr (tc_data$tc_suspend_lock));
      369 						/* possibly wake others */
      370 						/* who want the suspend service */
      371 
      372 	return;
      373 
      374 get_ipc_operands:
      375      entry (P_ipc_r_offset, P_ipc_r_factor);
      376 
      377 /**** This entry, target of hcs_$get_ipc_operands, allows a process
      378*      to determine the operands used for IPC validation.  It returns
      379*      only the operands for the calling process.  These values are
      380*      retrieved from the apte by the user-ring IPC at Event Channel
      381*      Table initialization time. */
      382 
      383 	aptep = pds$apt_ptr;
      384 	P_ipc_r_offset = apte.ipc_r_offset;
      385 	P_ipc_r_factor = apte.ipc_r_factor;
      386 	return;
      387 
      388 get_ipc_operands_priv:
      389      entry (a_processid, P_ipc_r_offset, P_ipc_r_factor, a_code);
      390 
      391 /**** This entry is a highly priviledged entry to determine the operands
      392*      used for IPC validation for a specified process.  It is used by
      393*      ring-0 IPC (hc_ipc) and by the Initializer process through the
      394*      gate hphcs_$get_ipc_operands_priv. */
      395 
      396 	processid = a_processid;
      397 
      398 	call WIRE_MASK ();
      399 
      400 /***** WIRED AND MASKED *****/
      401 
      402 	call pxss$lock_apte (processid, aptep, code);
      403 	if code = 0
      404 	then do;
      405 		ipc_r_offset = apte.ipc_r_offset;	/* copy to wired stack frame */
      406 		ipc_r_factor = apte.ipc_r_factor;	/* copy to wired stack frame */
      407 		call pxss$unlock_apte (aptep);
      408 	     end;
      409 	call UNWIRE_UNMASK ();
      410 
      411 /***** UNWIRED AND UNMASKED *****/
      412 
      413 	if code ^= 0
      414 	then a_code = error_table_$process_unknown;
      415 	else do;
      416 		P_ipc_r_offset = ipc_r_offset;
      417 		P_ipc_r_factor = ipc_r_factor;
      418 		a_code = 0;
      419 	     end;
      420 	return;
      421 
      422 /*  Internal procedure to validate that a process ID corresponds to
      423*    an active process. We're not concerned with races here, since they
      424*    can happen anyway (between now and when the process ID is used). */
      425 
      426 PROCESSID_TO_APTE:
      427      proc (processid, allow_special_procs) returns (ptr);
      428 
      429 dcl	processid		bit (36) aligned;
      430 dcl	allow_special_procs bit (1) aligned;
      431 
      432 
      433 dcl	apte_offset	fixed bin (18);		/* Offset of APTE in tc_data */
      434 dcl	first_apte_offset	fixed bin (18);		/* offset of first APTE in tc_data */
      435 dcl	1 pid		aligned,			/* decomposition of process ID */
      436 	  2 offset	bit (18) unaligned,		/* offset of APTE */
      437 	  2 unique	bit (18) unaligned;		/* unique number assigned by AS */
      438 dcl	taptep		ptr;
      439 dcl	1 tapte		aligned like apte based (taptep);
      440 
      441 
      442 	unspec (pid) = processid;
      443 	apte_offset = bin (pid.offset, 18);
      444 	taptep = ptr (addr (tc_data$), pid.offset);
      445 	first_apte_offset = bin (rel (addr (tc_data$apt)), 18);
      446 
      447 	if apte_offset < first_apte_offset
      448 	then return (null ());
      449 	else if apte_offset >= first_apte_offset + tc_data$apt_size * size (apte)
      450 	then return (null ());
      451 	else if mod ((apte_offset - first_apte_offset), size (apte)) ^= 0
      452 	then return (null ());
      453 	else if tapte.processid ^= processid
      454 	then return (null ());
      455 	else if (^allow_special_procs & (tapte.flags.hproc | tapte.flags.idle))
      456 	then return (null ());
      457 	else return (taptep);
      458 
      459      end PROCESSID_TO_APTE;
      460 
      461 /* Internal Procedure to wire this procedure (text and linkage), wire
      462*   stack, and mask to system level */
      463 
      464 WIRE_MASK:
      465      proc;
      466 
      467 	call wire_proc$wire_me;
      468 	call pmut$wire_and_mask (oldmask, ptwp);
      469 
      470      end WIRE_MASK;
      471 
      472 
      473 
      474 
      475 
      476 
      477 
      478 
      479 /* Internal Procedure to reset mask to previous, unwire stack, unwire
      480*   text and linkage */
      481 
      482 UNWIRE_UNMASK:
      483      proc;
      484 
      485 	call pmut$unwire_unmask (oldmask, ptwp);
      486 	call wire_proc$unwire_me;
      487 
      488 
      489      end UNWIRE_UNMASK;
      490 
      491 /* format: off */
      492  /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  1     2 
  1     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  1     4 
  1     5 dcl  aptep pointer;
  1     6 
  1     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  1     8     2 thread unaligned,				/* List thread */
  1     9       3 fp bit (18),				/* Forward pointer */
  1    10       3 bp bit (18),				/* Backward pointer */
  1    11     2 flags unaligned,				/* Flags and miscellaneous */
  1    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  1    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  1    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  1    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  1    16       3 hproc bit (1),				/* ON if process is hardcore process */
  1    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  1    18       3 eligible bit (1),				/* ON if process is eligible */
  1    19       3 idle bit (1),				/* ON if  this is an idle process */
  1    20       3 interaction bit (1),				/* ON if process has interacted recently */
  1    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  1    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  1    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  1    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  1    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  1    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  1    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  1    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  1    29       3 firstsw bit (1),				/* OFF until process is intialized */
  1    30       3 state bit (18),				/* execution state */
  1    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  1    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  1    33 						/* bit 18-35: sequential number */
  1    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  1    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  1    36     2 ti fixed bin (35),				/* virtual time since interaction */
  1    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  1    38 
  1    39 /* * * * * * * * */
  1    40 
  1    41     2 ipc_pointers unaligned,
  1    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  1    43       3 pad3 bit (18),
  1    44     2 ips_message bit (36),				/* IPS signals pending */
  1    45     2 asteps unaligned,				/* relative ASTE pointers */
  1    46       3 pds bit (18),				/* PDS (per-process) */
  1    47       3 dseg bit (18),				/* DSEG (per-process) */
  1    48       3 prds bit (18),				/* PRDS (per-processor) */
  1    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  1    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  1    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  1    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  1    53 
  1    54 /* * * * * * * * */
  1    55 
  1    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  1    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  1    58     2 flags2 unaligned,
  1    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  1    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  1    61       3 pad7 bit (7),
  1    62       3 batch bit (1),				/* ON if absentee */
  1    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  1    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  1    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  1    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  1    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  1    68 
  1    69 /* * * * * * */
  1    70 
  1    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  1    72     2 ws_size fixed bin,				/* working set estimate for the process */
  1    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  1    74     2 deadline fixed bin (71),			/* time of next run */
  1    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  1    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  1    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  1    78*						/* reaches this (units = 1/1024 sec) */
  1    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  1    80     2 access_authorization bit (72),			/* authorization of this process */
  1    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  1    82 
  1    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  1    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  1    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  1    86 
  1    87 /*  Cells used to drive and instrument finite-state model for response time
  1    88*    measurement. Maintained by meter_response_time */
  1    89 
  1    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  1    91     2 pad18 bit (18) unaligned,
  1    92     2 number_processing fixed bin (35),			/* Number interactions */
  1    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  1    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  1    95 
  1    96 /* * * * * * */
  1    97 
  1    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  1    99 
  1   100 /*  End of cells for finite-state model */
  1   101 
  1   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  1   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  1   104     2 pad4 bit (28) unaligned,
  1   105     2 ipc_r_offset fixed bin (18) unsigned,
  1   106     2 ipc_r_factor fixed bin (35) unsigned,
  1   107     2 apad (10) fixed bin (35);
  1   108 
  1   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      492 
      493  /* BEGIN INCLUDE FILE process_status_return.incl.pl1 */
  2     2 
  2     3 /* T. Casey, May 1978 */
  2     4 
  2     5 dcl 1 process_status_return aligned,			/* structure returned by hphcs_$process_status */
  2     6     2 target_proc bit (36),				/* Input process id. */
  2     7     2 total_page_faults fixed bin (35),			/* Total page faults in process. */
  2     8     2 aptptr ptr,					/* ptr to user APTE */
  2     9     2 up_exec fixed bin,				/* execution state. 1=run, 4=block */
  2    10     2 up_mp fixed bin,				/* multiprogramming state. */
  2    11     2 up_block fixed bin (71),			/* time of last block */
  2    12     2 up_cpu fixed bin (71),				/* CPU usage in microseconds */
  2    13     2 up_page fixed bin (71),				/* memory usage in Frankstons */
  2    14     2 virtual_cpu fixed bin (71),			/* Process virtual CPU time */
  2    15     2 extra2 fixed bin (71);
  2    16 
  2    17 /* END INCLUDE FILE process_status_return.incl.pl1 */
      493 
      494  /* BEGIN INCLUDE FILE ips_mask_data.incl.pl1 */
  3     2 /* Added all_valid_ips_mask, Benson Margulies 83-12 */
  3     3 
  3     4 dcl 1 sys_info$ips_mask_data ext aligned,		/* structure of mask/name associations for IPS masks */
  3     5     2 count fixed bin,				/* number of ips signals currently in the system */
  3     6     2 mask (35),
  3     7       3 name char (32),				/* name of the ips signal */
  3     8       3 mask bit (36);				/* has one bit ON, the one for the current ips signal */
  3     9 
  3    10 dcl sys_info$all_valid_ips_mask bit (36) aligned external;
  3    11 
  3    12 /* END INCLUDE FILE ips_mask_data.incl.pl1 */
      494 
      495  /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  4     2*
  4     3*   James R. Davis 10 May 79 */
  4     4 
  4     5 
  4     6      
  4     7 /****^  HISTORY COMMENTS:
  4     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  4     9*     audit(86-07-15,Schroth):
  4    10*     added command_name_arglist declaration to allow the storage of the
  4    11*     command name given to the command processor
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14      dcl	   1 arg_list	      aligned based,
  4    15 	     2 header,
  4    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  4    17 	       3 pad1	      bit (1) unal,
  4    18 	       3 call_type	      fixed bin (18) unsigned unal,
  4    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  4    20 	       3 pad2	      bit (19) unal,
  4    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  4    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  4    23 
  4    24 
  4    25      dcl	   1 command_name_arglist	      aligned based,
  4    26 	     2 header,
  4    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  4    28 	       3 pad1	      bit (1) unal,
  4    29 	       3 call_type	      fixed bin (18) unsigned unal,
  4    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  4    31 	       3 mbz              bit(1) unal,
  4    32                  3 has_command_name bit(1) unal,
  4    33 	       3 pad2	      bit (17) unal,
  4    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  4    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  4    36 	     2 name,
  4    37                  3 command_name_ptr         pointer,
  4    38                  3 command_name_length      fixed bin (21);
  4    39 	
  4    40 
  4    41 
  4    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  4    43 	     2 header,
  4    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  4    45 	       3 pad1	      bit (1) unal,
  4    46 	       3 call_type	      fixed bin (18) unsigned unal,
  4    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  4    48 	       3 pad2	      bit (19) unal,
  4    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  4    50 	     2 envptr	      ptr,
  4    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  4    52 
  4    53 
  4    54      dcl	   (
  4    55 	   Quick_call_type	      init (0),
  4    56 	   Interseg_call_type     init (4),
  4    57 	   Envptr_supplied_call_type
  4    58 			      init (8)
  4    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  4    60 
  4    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  4    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  4    63*   an argument list of the proper size in the user's stack
  4    64*
  4    65**/
  4    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      495 
      496 /* format: on */
      497 
      498      end tc_util;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.0  tc_util.pl1                       >spec>install>1110>tc_util.pl1
492          1    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
493          2    08/03/78  2021.0  process_status_return.incl.pl1    >ldd>include>process_status_return.incl.pl1
494          3    07/11/84  0937.3  ips_mask_data.incl.pl1            >ldd>include>ips_mask_data.incl.pl1
495          4    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_ipc_r_factor                         parameter       fixed bin(35,0)          dcl 89 set ref 374 385* 388 417*
P_ipc_r_offset                         parameter       fixed bin(18,0)          dcl 88 set ref 374 384* 388 416*
a_allow_special_procs                  parameter       bit(1)                   dcl 80 ref 179 182
a_code                                 parameter       fixed bin(35,0)          dcl 82 set ref 163 166* 169* 263 286* 288* 330 333*
                                                                                  336* 388 413* 418*
a_delta_vcpu                           parameter       fixed bin(71,0)          dcl 83 ref 263 267
a_info_ptr                             parameter       pointer                  dcl 84 ref 221 224 225 226 227 240 241 242 243 244
                                                                                  246 247 248 249
a_ips_signal_name                      parameter       char                     packed unaligned dcl 85 ref 191 204
a_process_status                       based           structure                level 1 dcl 109
a_processid                            parameter       bit(36)                  dcl 86 ref 179 182 191 203 263 266 297 300 330 335
                                                                                  388 396
a_timax                                parameter       fixed bin(35,0)          dcl 87 ref 297 301
addr                                                   builtin function         dcl 147 ref 353 353 368 368 444 445
allow_special_procs                    parameter       bit(1)                   dcl 430 ref 426 455
apte                                   based           structure                level 1 dcl 1-7 set ref 449 451
apte_offset                     000174 automatic       fixed bin(18,0)          dcl 433 set ref 443* 447 449 451
aptep                           000132 automatic       pointer                  dcl 1-5 set ref 168* 169 169 182* 183 231* 232 234
                                                                                  235 237 240 241 244 246 247 248 273* 276 278 278
                                                                                  279* 309* 312 313* 335* 336 383* 384 385 402* 405
                                                                                  406 407* 449 451
aptptr                    2            based           pointer                  level 2 dcl 109 set ref 227* 241*
arg_list                               based           structure                level 1 dcl 4-14
arg_list_ptr                    000100 automatic       pointer                  dcl 93 set ref 199* 200
bin                                                    builtin function         dcl 148 ref 234 443 445
code                            000102 automatic       fixed bin(35,0)          dcl 94 set ref 273* 274 286 309* 310 402* 403 413
count                           000062 external static fixed bin(17,0)          level 2 dcl 3-4 ref 205 208
cpu_monitor              37            based           fixed bin(35,0)          level 2 dcl 1-7 set ref 276* 278*
cu_$arg_list_ptr                000010 constant        entry                    external dcl 114 ref 199
delta_vcpu                      000104 automatic       fixed bin(71,0)          dcl 95 set ref 267* 276 278
desc_count                1            based           fixed bin(17,0)          level 3 packed packed unsigned unaligned dcl 110 ref
                                                                                  200
divide                                                 builtin function         dcl 149 ref 278
eligible                  1(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 237
error_table_$process_unknown    000042 external static fixed bin(35,0)          dcl 132 ref 286 336 413
error_table_$quit_term_abort    000040 external static fixed bin(35,0)          dcl 130 ref 169
extra2                   16            based           fixed bin(71,0)          level 2 dcl 109 set ref 249*
first_apte_offset               000175 automatic       fixed bin(18,0)          dcl 434 set ref 445* 447 449 451
flags                     1            based           structure                level 2 in structure "apte" packed packed unaligned
                                                                                  dcl 1-7 in procedure "tc_util"
flags                     1            based           structure                level 2 in structure "tapte" packed packed unaligned
                                                                                  dcl 439 in procedure "PROCESSID_TO_APTE"
header                                 based           structure                level 2 dcl 110
hproc                     1(04)        based           bit(1)                   level 3 packed packed unaligned dcl 439 ref 455
idle                      1(07)        based           bit(1)                   level 3 packed packed unaligned dcl 439 ref 455
ipc_r_factor             65            based           fixed bin(35,0)          level 2 in structure "apte" unsigned dcl 1-7
                                                                                  in procedure "tc_util" ref 385 406
ipc_r_factor                    000107 automatic       fixed bin(35,0)          dcl 97 in procedure "tc_util" set ref 406* 417
ipc_r_offset                    000106 automatic       fixed bin(18,0)          dcl 96 in procedure "tc_util" set ref 405* 416
ipc_r_offset             64            based           fixed bin(18,0)          level 2 in structure "apte" unsigned dcl 1-7
                                                                                  in procedure "tc_util" ref 384 405
ips_mask_index                  000110 automatic       fixed bin(17,0)          dcl 98 set ref 205* 205* 208 208
ips_message              11            based           bit(36)                  level 2 dcl 1-7 ref 169
ips_signal_name                 000111 automatic       char(32)                 packed unaligned dcl 99 set ref 204* 205
loaded                    1(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 235
lock$lock_fast                  000012 constant        entry                    external dcl 115 ref 353
lock$unlock_fast                000014 constant        entry                    external dcl 116 ref 368
mask                     11     000062 external static bit(36)                  array level 3 in structure "sys_info$ips_mask_data"
                                                                                  dcl 3-4 in procedure "tc_util" set ref 208*
mask                      1     000062 external static structure                array level 2 in structure "sys_info$ips_mask_data"
                                                                                  dcl 3-4 in procedure "tc_util"
mod                                                    builtin function         dcl 150 ref 451
my_arg_list                            based           structure                level 1 dcl 110
name                      1     000062 external static char(32)                 array level 3 dcl 3-4 ref 205
null                                                   builtin function         dcl 151 ref 227 232 336 447 449 451 453 455
offset                          000176 automatic       bit(18)                  level 2 packed packed unaligned dcl 435 set ref 443
                                                                                  444
oldmask                         000122 automatic       fixed bin(71,0)          dcl 100 set ref 468* 485*
page_faults               2            based           fixed bin(35,0)          level 2 dcl 1-7 ref 240
paging_measure           40            based           fixed bin(71,0)          level 2 dcl 1-7 ref 247
pds$apt_ptr                     000044 external static pointer                  dcl 134 ref 168 383
pid                             000176 automatic       structure                level 1 dcl 435 set ref 442*
pmut$unwire_unmask              000020 constant        entry                    external dcl 118 ref 485
pmut$wire_and_mask              000016 constant        entry                    external dcl 117 ref 468
process_mp_state                000124 automatic       fixed bin(17,0)          dcl 101 set ref 229* 235* 235 237* 237 243
process_state                   000125 automatic       fixed bin(17,0)          dcl 102 set ref 234* 242
process_status_return           000134 automatic       structure                level 1 dcl 2-5
process_timax                   000126 automatic       fixed bin(35,0)          dcl 103 set ref 301* 302 302* 312
processid                       000127 automatic       bit(36)                  dcl 104 in procedure "tc_util" set ref 203* 208*
                                                                                  224* 231* 266* 273* 300* 309* 396* 402*
processid                 3            based           bit(36)                  level 2 in structure "tapte" dcl 439 in procedure
                                                                                  "PROCESSID_TO_APTE" ref 453
processid                              parameter       bit(36)                  dcl 429 in procedure "PROCESSID_TO_APTE" ref 426 442
                                                                                  453
ptr                                                    builtin function         dcl 152 ref 444
ptwp                            000130 automatic       pointer                  dcl 105 set ref 468* 485*
pxss$ips_wakeup                 000024 constant        entry                    external dcl 120 ref 208
pxss$lock_apte                  000022 constant        entry                    external dcl 119 ref 273 309 402
pxss$suspend_getwork            000026 constant        entry                    external dcl 121 ref 357
pxss$unlock_apte                000030 constant        entry                    external dcl 123 ref 279 313 407
rel                                                    builtin function         dcl 153 ref 445
signal_                         000032 constant        entry                    external dcl 124 ref 200
size                                                   builtin function         dcl 154 ref 449 451
state                     1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 1-7 ref 234
state_change_time        22            based           fixed bin(71,0)          level 2 dcl 1-7 ref 244
stop_pending              1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 169
sys_info$ips_mask_data          000062 external static structure                level 1 dcl 3-4
tapte                                  based           structure                level 1 dcl 439
taptep                          000200 automatic       pointer                  dcl 438 set ref 444* 453 455 455 457
target_proc                            based           bit(36)                  level 2 dcl 109 ref 224
tc_data$                        000046 external static fixed bin(17,0)          dcl 135 set ref 444
tc_data$abort_ips_mask          000050 external static bit(36)                  dcl 136 ref 169
tc_data$apt                     000052 external static bit(36)                  dcl 138 set ref 445
tc_data$apt_size                000054 external static fixed bin(17,0)          dcl 139 ref 449
tc_data$tc_suspend_lock         000056 external static bit(36)                  dcl 140 set ref 353 353 368 368
tc_data$timax                   000060 external static fixed bin(35,0)          dcl 142 ref 302
timax                     7            based           fixed bin(35,0)          level 2 dcl 1-7 set ref 312*
time_used_clock          16            based           fixed bin(71,0)          level 2 dcl 1-7 ref 246
total_page_faults         1            based           fixed bin(35,0)          level 2 dcl 109 set ref 240*
unspec                                                 builtin function         dcl 155 set ref 442*
up_block                  6            based           fixed bin(71,0)          level 2 dcl 109 set ref 244*
up_cpu                   10            based           fixed bin(71,0)          level 2 dcl 109 set ref 246*
up_exec                   4            based           fixed bin(17,0)          level 2 dcl 109 set ref 225* 242*
up_mp                     5            based           fixed bin(17,0)          level 2 dcl 109 set ref 226* 243*
up_page                  12            based           fixed bin(71,0)          level 2 dcl 109 set ref 247*
virtual_cpu              14            based           fixed bin(71,0)          level 2 dcl 109 set ref 248*
virtual_cpu_time         46            based           fixed bin(71,0)          level 2 dcl 1-7 ref 248 278
wire_proc$unwire_me             000034 constant        entry                    external dcl 125 ref 486
wire_proc$wire_me               000036 constant        entry                    external dcl 126 ref 467

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 4-54
Interseg_call_type                     internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 4-54
Quick_call_type                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 4-54
arg_list_with_envptr                   based           structure                level 1 dcl 4-42
command_name_arglist                   based           structure                level 1 dcl 4-25
sys_info$all_valid_ips_mask            external static bit(36)                  dcl 3-10

NAMES DECLARED BY EXPLICIT CONTEXT.
PROCESSID_TO_APTE               001056 constant        entry                    internal dcl 426 ref 182 231 335
UNWIRE_UNMASK                   001176 constant        entry                    internal dcl 482 ref 282 316 409
WIRE_MASK                       001156 constant        entry                    internal dcl 464 ref 269 305 398
check_abort                     000045 constant        entry                    external dcl 163
get_aptep                       000110 constant        entry                    external dcl 179
get_ipc_operands                000717 constant        entry                    external dcl 374
get_ipc_operands_priv           000760 constant        entry                    external dcl 388
ips_wakeup                      000144 constant        entry                    external dcl 191
process_status                  000272 constant        entry                    external dcl 221
resume_tc                       000664 constant        entry                    external dcl 365
set_cpu_monitor                 000402 constant        entry                    external dcl 263
set_timax                       000504 constant        entry                    external dcl 297
suspend_tc                      000627 constant        entry                    external dcl 350
tc_util                         000025 constant        entry                    external dcl 15
validate_processid              000566 constant        entry                    external dcl 330

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1634        1720    1250        1644
Length      2234    1250        64         277     363           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tc_util                             186 external procedure  is an external procedure.  
PROCESSID_TO_APTE                       internal procedure  shares stack frame of external procedure tc_util.  
WIRE_MASK                               internal procedure  shares stack frame of external procedure tc_util.  
UNWIRE_UNMASK                           internal procedure  shares stack frame of external procedure tc_util.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tc_util                  000100 arg_list_ptr                tc_util
                         000102 code                        tc_util
                         000104 delta_vcpu                  tc_util
                         000106 ipc_r_offset                tc_util
                         000107 ipc_r_factor                tc_util
                         000110 ips_mask_index              tc_util
                         000111 ips_signal_name             tc_util
                         000122 oldmask                     tc_util
                         000124 process_mp_state            tc_util
                         000125 process_state               tc_util
                         000126 process_timax               tc_util
                         000127 processid                   tc_util
                         000130 ptwp                        tc_util
                         000132 aptep                       tc_util
                         000134 process_status_return       tc_util
                         000174 apte_offset                 PROCESSID_TO_APTE
                         000175 first_apte_offset           PROCESSID_TO_APTE
                         000176 pid                         PROCESSID_TO_APTE
                         000200 taptep                      PROCESSID_TO_APTE

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               signal_op           ext_entry
ext_entry_desc      divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              lock$lock_fast                lock$unlock_fast              pmut$unwire_unmask
pmut$wire_and_mask            pxss$ips_wakeup               pxss$lock_apte                pxss$suspend_getwork
pxss$unlock_apte              signal_                       wire_proc$unwire_me           wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$process_unknown  error_table_$quit_term_abort  pds$apt_ptr                   sys_info$ips_mask_data
tc_data$                      tc_data$abort_ips_mask        tc_data$apt                   tc_data$apt_size
tc_data$tc_suspend_lock       tc_data$timax




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000024       157 000034       163 000042       166 000057       168 000060       169 000064       172 000075
    179 000104       182 000116       183 000126       191 000140       199 000161       200 000170       203 000210
    204 000213       205 000220       207 000241       208 000243       211 000260       221 000267       224 000301
    225 000305       226 000307       227 000310       229 000312       231 000314       232 000320       234 000324
    235 000330       237 000335       240 000341       241 000346       242 000347       243 000353       244 000355
    246 000357       247 000361       248 000363       249 000365       252 000367       263 000376       266 000414
    267 000417       269 000421       273 000422       274 000435       276 000437       278 000444       279 000452
    282 000461       286 000462       288 000470       290 000471       297 000500       300 000513       301 000516
    302 000520       305 000524       309 000525       310 000540       312 000542       313 000545       316 000554
    320 000555       330 000564       333 000600       335 000601       336 000610       339 000617       350 000626
    353 000636       357 000647       360 000654       365 000663       368 000673       372 000704       374 000713
    383 000733       384 000737       385 000742       386 000744       388 000753       396 000776       398 001001
    402 001002       403 001015       405 001017       406 001022       407 001024       409 001033       413 001034
    416 001042       417 001044       418 001046       420 001047       426 001056       442 001060       443 001062
    444 001067       445 001075       447 001101       449 001110       451 001123       453 001134       455 001143
    457 001154       464 001156       467 001157       468 001164       470 001175       482 001176       485 001177
    486 001210       489 001215


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
