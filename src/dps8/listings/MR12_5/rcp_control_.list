	COMPILATION LISTING OF SEGMENT rcp_control_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0950.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
       16*     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
       17*     Add support for FIPS
       18*     and IMU
       19*  2) change(86-08-07,Farley), approve(86-08-07,MCR7448),
       20*     audit(86-10-20,Beattie), install(86-10-28,MR12.0-1200):
       21*     Changed DELETE_DEVICE to unload the device BEFORE deleting it. Changed
       22*     TEST_DEVICE to set priv_gate_call to OFF, even when called through
       23*     rcp_priv_. Changed ASSIGN to properly unassign the volume when the device
       24*     assignment fails.
       25*  3) change(87-01-27,Farley), approve(87-04-06,MCR7650),
       26*     audit(87-04-15,Dickson), install(87-04-28,MR12.1-1028):
       27*     Changed to reset device.flags.attached before unloading the volume from
       28*     the device.  This is required when the device is still assigned.
       29*  4) change(87-06-25,Rauschelbach), approve(87-06-29,MCR7736),
       30*     audit(87-07-21,Farley), install(87-08-06,MR12.1-1063):
       31*     The error error_table_$resource_unknown was replaced with a new error code
       32*     error_table_$no_appropriate_device for the instance of mismatched device
       33*     and volume attributes.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       37 rcp_control_:
       38      procedure (a_operation, a_volume_offset, a_device_offset, a_device_name, a_error_count, a_process_id, a_ecode);
       39 
       40 /*	This program is an internal interface of RCP.
       41*   *	Created on 11/27/74 by Bill Silver
       42*   *
       43*   *      This routine performs the following functions:
       44*   *	     1.	Assign a device and/or volume.
       45*   *	     2.	Update the error count for the specified device.
       46*   *	     3.	Unassign a device and/or volume.
       47*   *	     4.	Forcedly unassign a device.
       48*   *	     5.	Unassign all resources of specified process.
       49*   *	     6.   Delete a device.
       50*   *	     7.	Add a device.
       51**/
       52 /*	Tape survey when adding drive by C. Hornig, September 1982.
       53*   *      Modified 12/8/83 by B. Braun to correct all device requests being denined (phx12105).
       54*   *	Modified 1/84 by Chris Jones to tell IOI what we've done about adding or deleting a device.
       55*   *	Modified 840521 for console addition / deletion... -E. A. Ranzenbach
       56*   *      Modified 841004 to change the name to rcp_control, to allow the
       57*   *       routine to accept arguments instead of a 72-bit message, and
       58*   *       perform some general cleanup...- M. M. Pozzo
       59*   *      Modified 850131 to interface with the new rcp_access_kernel_ for the
       60*   *       B2 effort...-M. M. Pozzo
       61*   *      Modified 1985-03-08, BIM: check console state.
       62*   *      Modified 1985-03-14, BIM: cleanup journals, translate "record not found" into "no such resource".
       63*   *	Modified 03/18/85 by Chris Jones to not delete devices until after their volumes are unloaded.
       64*   *	Modified 1985-04-3 by Paul Farley & Fawcett to add FIPS support and
       65*   *		             add no_protect and opr_int_available code
       66*   *      Modified 1985-04-11, BIM&MMP: Don't zero error code before testing it in TEST_DEVICE.
       67*   *               Also audit mounts of volumes.
       68*   *      Modified 1985-04-12, BIM: ioi delete device at unassign time
       69*   *	   that was added at assign time due to use of rcp_priv_ to assign
       70*   *	   a deleted device.
       71**/
       72 
       73 /*		ARGUMENT  DATA		*/
       74 
       75 dcl	a_operation	   bit (36) aligned;	/* Specifies the type of operation being requested */
       76 dcl	a_volume_offset	   bit (18) aligned;	/* Offset to volume information */
       77 dcl	a_device_offset	   bit (18) aligned;	/* Offset to device information */
       78 dcl	a_device_name	   char (*);		/* Drive name */
       79 dcl	a_error_count	   fixed bin (17);		/* Error count for device attachments */
       80 dcl	a_process_id	   bit (36) aligned;	/* Process id for which this operation is being performed */
       81 dcl	a_ecode		   fixed bin (35);		/* Error code */
       82 
       83 
       84 dcl	a_add_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b = add to RCP */
       85 dcl	a_del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */
       86 
       87 
       88 /*		AUTOMATIC  DATA		*/
       89 
       90 
       91 dcl	access		   bit (3) aligned;		/* User's access to resource. */
       92 dcl	effmode		   bit (3);
       93 dcl	accessible_flag	   bit (1) aligned;		/* ON => process has access to a segment. */
       94 dcl	add_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b => add to RCP. */
       95 dcl	available_flag	   bit (1) aligned;		/* ON => device is available. */
       96 dcl	console_free	   bit (1) aligned;		/* flag indicating that the ocdcm_ willlet us have the console. */
       97 dcl	del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */
       98 dcl	full		   bit (1) aligned;		/* "1"b if available_list array is full */
       99 dcl	match_flag	   bit (1) aligned;		/* ON => device matches. */
      100 dcl	system_flag	   bit (1) aligned;		/* ON => process is a system process. */
      101 dcl	volume_flag	   bit (1) aligned;		/* ON => we have assigned a volume. */
      102 dcl	temp_mode		   bit (3);
      103 dcl	dev_rcse_off	   bit (18) aligned;	/* Offset of RCS device entry. */
      104 dcl	device_off	   bit (18) aligned;	/* Offset of RCPD device entry. */
      105 dcl	vol_rcse_off	   bit (18) aligned;	/* Offset of RCS volume entry. */
      106 dcl	volume_off	   bit (18) aligned;	/* Offset of RCPD volume entry. */
      107 dcl	process_id	   bit (36) aligned;	/* Process ID. */
      108 
      109 dcl	operation		   bit (36) aligned;	/* Operation.   */
      110 dcl	base_op		   bit (36) aligned;	/* the basic operation */
      111 dcl	device_name	   char (32);		/* Device name. */
      112 dcl	volume_name	   char (32);		/* Volume name. */
      113 dcl	who_am_i		   char (32);		/* Identifies this program. */
      114 
      115 dcl	dtypex		   fixed bin;		/* Device type index. */
      116 dcl	ecode		   fixed bin (35);		/* error_table_ code. */
      117 dcl	error_count	   fixed bin (17);		/* error count for device attachments */
      118 dcl	num_assigned	   fixed bin;		/* Number of devices assigned to a process. */
      119 dcl	num_avail_nres	   fixed bin;		/* Number of non reservable devices available. */
      120 dcl	num_available	   fixed bin;		/* Number of devices available for assignment. */
      121 dcl	num_free_res	   fixed bin;		/* Number of reservable devices currently free. */
      122 dcl	num_reserved	   fixed bin;		/* Number of devices reserved to system processes. */
      123 dcl	num_resvd		   fixed bin;		/* Number of device reserved for this process. */
      124 dcl	one_was_accessible	   bit (1) aligned;		/* at least one was accessible */
      125 dcl	one_was_appropriate	   bit (1) aligned;		/* at least one was appropriate (but perhaps inaccessible or unavailable) */
      126 /**** there is no one_was_available, since available is conditional on the other two PLUS resource limits. */
      127 dcl	time_assigned	   fixed bin (71);		/* Used to compute metering data. */
      128 
      129 dcl	record_ptr	   ptr;			/* Pointer to the registry resource record. */
      130 dcl	reg_iocb_ptr	   ptr;			/* IOCB for the registry. */
      131 dcl	save_device_ptr	   ptr;			/* Used to save pointer to assigned device. */
      132 dcl	trans_iocb_ptr	   ptr;			/* IOCB for the transaction control file. */
      133 dcl	available_list	   (MAX_AVAILABLE) ptr;	/* List of appropriate, accessible, and available devices. */
      134 dcl	1 req_info	   like requestor_info automatic;
      135 						/* Requestor information for determining RCP access */
      136 dcl	1 res_info	   like resource_info automatic;
      137 						/* Resource information for determining RCP access */
      138 
      139 /*		CONSTANTS			*/
      140 
      141 
      142 dcl	MAX_AVAILABLE	   fixed bin (17) static internal options (constant) init (128);
      143 dcl	DEFAULT_REGISTRY_DIR   char (64) static internal options (constant) init (">sc1>rcp");
      144 
      145 /*		CONDITIONS		*/
      146 
      147 
      148 dcl	cleanup		   condition;		/* Used to establish a cleanup handler. */
      149 
      150 
      151 /*		BUILTIN FUNCTIONS		*/
      152 
      153 
      154 dcl	(addr, clock, divide, hbound, length, null, ptr, rel, string, substr, unspec)
      155 			   builtin;
      156 
      157 
      158 /*		ERROR CODES		*/
      159 
      160 
      161 dcl	error_table_$no_key	   fixed bin (35) ext static;
      162 dcl	error_table_$resource_unassigned
      163 			   fixed bin (35) ext;
      164 dcl	error_table_$device_deletion_deferred
      165 			   fixed bin (35) ext;
      166 dcl	error_table_$device_limit_exceeded
      167 			   fixed bin (35) ext;
      168 dcl	error_table_$invalid_state
      169 			   fixed bin (35) ext;
      170 dcl	error_table_$io_still_assnd
      171 			   fixed bin (35) ext;
      172 dcl	error_table_$notalloc  fixed bin (35) ext;
      173 dcl	error_table_$resource_bad_access
      174 			   fixed bin (35) ext;
      175 dcl	error_table_$resource_unavailable
      176 			   fixed bin (35) ext;
      177 dcl	error_table_$resource_unknown
      178 			   fixed bin (35) ext;
      179 dcl       error_table_$no_appropriate_device
      180                                  fixed bin (35) ext;
      181 dcl	error_table_$unsupported_operation
      182 			   fixed bin (35) ext;
      183 
      184 dcl	access_operations_$rcp_assign_read
      185 			   bit (36) aligned ext static;
      186 dcl	access_operations_$rcp_assign_write
      187 			   bit (36) aligned ext static;
      188 dcl	access_operations_$rcp_add_device
      189 			   bit (36) aligned ext static;
      190 dcl	access_operations_$rcp_delete_device
      191 			   bit (36) aligned ext static;
      192 dcl	access_operations_$rcp_error_count
      193 			   bit (36) aligned ext static;
      194 dcl	access_operations_$rcp_account
      195 			   bit (36) aligned ext static;
      196 dcl	access_operations_$rcp_unassign
      197 			   bit (36) aligned ext static;
      198 
      199 /*		EXTERNAL ENTRIES CALLED	*/
      200 
      201 
      202 dcl	admin_gate_$console_free
      203 			   entry (char (4) aligned, bit (1) aligned);
      204 dcl	admin_gate_$ocdcm_reconfigure
      205 			   entry (char (4) aligned, fixed bin, fixed bin (35));
      206 dcl	admin_gate_$ioi_add_device
      207 			   entry (char (*), fixed bin (35));
      208 dcl	admin_gate_$ioi_delete_device
      209 			   entry (char (*), fixed bin (35));
      210 dcl	admin_gate_$syserr	   entry options (variable);
      211 dcl	get_group_id_	   entry () returns (char (32));
      212 dcl	get_process_id_	   entry returns (bit (36));
      213 dcl	hcs_$wakeup	   entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      214 dcl	rcp_access_kernel_	   entry (bit (36) aligned, ptr, ptr, bit (3), fixed bin (35));
      215 dcl	rcp_lock_$lock	   entry (ptr, fixed bin (35));
      216 dcl	rcp_lock_$unlock	   entry (ptr);
      217 dcl	rcp_match_$match	   entry (ptr, ptr) returns (bit (1));
      218 dcl	rcp_match_$select	   entry (ptr, fixed bin, char (*) aligned, ptr);
      219 dcl	rcp_match_user_name_   entry (char (32) aligned, char (32) aligned) returns (bit (1));
      220 dcl	rcp_pointers_$com_seg  entry returns (ptr);
      221 dcl	rcp_pointers_$data	   entry returns (ptr);
      222 dcl	rcp_tape_survey_	   entry (char (*), fixed bin, bit (1) aligned, bit (1) aligned, (4) fixed bin (35),
      223 			   fixed bin (35));
      224 dcl	rcp_unload_$unload_device
      225 			   entry (ptr, bit (1));
      226 dcl	get_authorization_	   entry () returns (bit (72) aligned);
      227 dcl	hcs_$get_authorization entry (bit (72) aligned, bit (72) aligned);
      228 dcl	rcp_get_scratch_volume_
      229 			   entry (ptr, char (*), bit (3) aligned, fixed bin (35));
      230 dcl	rcp_cancel_resource_   entry (char (*), char (*), fixed bin (35));
      231 
      232 /*        This routine has two entry points.  rcp_control_$ss_io_interchange is called by mdx.pl1.  The main entry point will determine what functions to perform from the operation argument.  RCPD will be locked while it is being manipulated. */
      233 
      234 /**** NOTES
      235*      device.unassign_state, device.delete, device.priv:
      236*
      237*      These three variables overlap. device.unassign_state should always
      238*      be the correct value for device.state after the completion of unassign.
      239*      However, if device.delete is on, then the device must be marked
      240*      DELETED at unassign. However, unassign_state is not changed
      241*      when a deletion is requested for an assigned or reserved device,
      242*      so that if the device is added back before it is unassigned
      243*      things will work correctly.
      244*
      245*      If device.priv is on, then unassign_state
      246*      = DELETED implies that the device was deleted to begin with and assigned
      247*      with rcp_priv_, rather than deleted by the operator during the
      248*      assignment. The only implication of this is that unloads are not
      249*      attempted at unassignment. */
      250 
      251 	operation = a_operation;			/* Copy args */
      252 	base_op = basic_operation (operation);
      253 	ops_ptr = addr (addr (operation) -> encoded_access_op.detailed_operation);
      254 	error_count = a_error_count;
      255 
      256 	who_am_i = "rcp_control_";
      257 	rcpd_ptr = rcp_pointers_$data ();		/* Set up pointers. */
      258 	rcs_ptr = rcp_pointers_$com_seg ();
      259 	reg_iocb_ptr, trans_iocb_ptr = null ();
      260 	ecode = 0;
      261 
      262 	on cleanup
      263 	     begin;
      264 	     call cleanup_kernel_call ((0));
      265 	     call UNLOCK;				/* If trouble unlock rcp_data. */
      266 	end;
      267 
      268 	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
      269 	if ecode ^= 0 then do;
      270 	     a_ecode = ecode;
      271 	     return;
      272 	end;
      273 
      274 	if (base_op = access_operations_$rcp_assign_read) | (base_op = access_operations_$rcp_assign_write) then
      275 	     call ASSIGN;
      276 	else if base_op = access_operations_$rcp_error_count then
      277 	     call ERROR_COUNT;
      278 	else if base_op = access_operations_$rcp_unassign then
      279 	     call UNASSIGN;
      280 	else if base_op = access_operations_$rcp_delete_device then
      281 	     call DELETE_DEVICE;
      282 	else if base_op = access_operations_$rcp_add_device then
      283 	     call ADD_DEVICE;
      284 	else if base_op = access_operations_$rcp_account then
      285 	     call ACCOUNT_ATTACH;
      286 	else ecode = error_table_$unsupported_operation;
      287 
      288 	call UNLOCK;
      289 	a_ecode = ecode;
      290 
      291 	return;
      292 
      293 UNLOCK:
      294      procedure;					/* Unlock RCPD. */
      295 	call rcp_lock_$unlock (addr (rcpd.lock_info));
      296      end UNLOCK;
      297 
      298 ASSIGN:
      299      procedure;
      300 
      301 /*	This procedure is called to perform an assignment of a device
      302*   and/or volume.
      303*   The offsets provided as input determine what is to be assigned.
      304*   These offsets reference RCS entries.  We will communicate the
      305*   results of the assignment(s) by filling in these entries.
      306**/
      307 
      308 	vol_rcse_off = a_volume_offset;		/* Copy args */
      309 	dev_rcse_off = a_device_offset;
      310 
      311 	volume_flag = "0"b;				/* Assume no volume assigned. */
      312 
      313 	if vol_rcse_off ^= "0"b			/* Do we have to assign a volume? */
      314 	then do;					/* Yes. */
      315 	     call ASSIGN_VOLUME;			/* Assign one volume to this process. */
      316 	     rcse.ecode = ecode;			/* Tell results of volume assignment. */
      317 	     if ecode ^= 0				/* Any problems with volume? */
      318 		then
      319 		return;				/* Yes, abort all assignments. */
      320 	end;
      321 
      322 	if dev_rcse_off ^= "0"b			/* Do we have a device to assign? */
      323 	then do;					/* Yes. */
      324 	     base_op = access_operations_$rcp_assign_write;
      325 						/* Always assign a device for writing. */
      326 	     call ASSIGN_DEVICE;			/* Assign an appropriate device. */
      327 	     rcse.ecode = ecode;			/* Tell results of device assignment. */
      328 	end;
      329 
      330 	if ^volume_flag				/* Device assignment done.  Was there a volume? */
      331 	     then
      332 	     return;				/* No, nothing else to do. */
      333 
      334 	if ecode ^= 0				/* Was there an error assigning device? */
      335 	then do;					/* Yes. */
      336 	     call UNASSIGN_VOLUME ();
      337 	     return;
      338 	end;
      339 
      340 	if dev_rcse_off = "0"b			/* Was a device just assigned? */
      341 	then do;					/* No, put volume on previously assigned device. */
      342 	     rcse_ptr = ptr (rcs_ptr, vol_rcse_off);	/* Attachment RCS entry. */
      343 	     rcse_ptr = ptr (rcs_ptr, rcse.rcse_off);	/* Assignment RCS entry. */
      344 	     device_ptr = ptr (rcpd_ptr, rcse.device_off);
      345 	     dtypex = device.dtypex;			/* Get device type of this device. */
      346 	     dtype_ptr = addr (rcpd.dtype (dtypex));
      347 	end;
      348 
      349 	if device.volume_name = volume_name		/* Is volume already on this device? */
      350 	then do;					/* Yes, nothing more to do. */
      351 	     rcse.volume_name = volume_name;		/* ASSIGNment RCSE */
      352 	     return;
      353 	end;
      354 
      355 	if volume_name = "scratch"			/* Is this a scratch volume. */
      356 	then do;					/* Yes, special case. */
      357 	     device.volume_name = " ";		/* Scratch volumes not remembered. */
      358 	     return;
      359 	end;
      360 
      361 /*	The assigned volume is being put on a new device.  We must search through
      362*   *	all of the devices of this type to see if it is currently on any other
      363*   *	device.  If it is we will remove it from that device.
      364**/
      365 	save_device_ptr = device_ptr;			/* Save pointer to assigned device. */
      366 	device_off = dtype.first_off;			/* Get first device of this type. */
      367 	do while (device_off ^= "0"b);		/* Test all devices of this type. */
      368 	     device_ptr = ptr (rcpd_ptr, device_off);
      369 	     if device.volume_name = volume_name then do; /* We found the volume on another device. */
      370 		device.flags.attached = "0"b;		/* Mark it as _n_o_t attached. */
      371 		call rcp_unload_$unload_device (device_ptr, "0"b);
      372 						/* unload the volume */
      373 		device.volume_name = "";		/* Forget this occurance. */
      374 		goto REMEMBER_DEVICE;		/* No need to test any more devices. */
      375 	     end;
      376 	     device_off = device.next_off;		/* Test next device. */
      377 	end;
      378 
      379 REMEMBER_DEVICE:					/* Put volume on assigned device. */
      380 	save_device_ptr -> device.volume_name = volume_name;
      381 
      382      end ASSIGN;
      383 
      384 /*	This procedure is called to assign a volume.  The assignment of a volume
      385*   *	is independent of the assignment of a device.  A list of the currently
      386*   *	assigned volumes is kept in RCPD.
      387**/
      388 
      389 
      390 ASSIGN_VOLUME:
      391      procedure;
      392 
      393 dcl	i		   fixed bin;
      394 dcl	ignored_code	   fixed bin (35);
      395 
      396 	rcse_ptr = ptr (rcs_ptr, vol_rcse_off);		/* Get pointer to RCS entry that => volume. */
      397 	access = "000"b;
      398 	if rcse.volume_name ^= "scratch" then
      399 	     volume_name = rcse.volume_name;
      400 	else do;
      401 	     call rcp_get_scratch_volume_ (rcse_ptr, volume_name, access, ecode);
      402 	     if ecode ^= 0 then
      403 		return;
      404 	     rcse.volume_name = volume_name;
      405 	end;
      406 	volume_off = "0"b;				/* Initialize volume offset. */
      407 
      408 	do i = 1 to rcpd.last_volume;			/* Search through list of volumes. */
      409 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
      410 	     if volume.volume_name = volume_name then do;
      411 		if (volume.state = FREE) | ((volume.state = RESERVED) & (volume.process_id = rcse.process_id)) then
      412 		     volume_off = rel (volume_ptr);
      413 		else if volume_name ^= "" then do;
      414 		     ecode = error_table_$resource_unavailable;
      415 		     return;
      416 		end;
      417 	     end;
      418 	     else if (volume.state = FREE) & (volume.volume_name = "") then
      419 						/* If this is a free entry in the table ... */
      420 		if volume_off = "0"b then		/* ... and we don't have a slot to use yet ... */
      421 		     volume_off = rel (volume_ptr);	/* ... then remember this one for later. */
      422 	end;
      423 
      424 	if volume_off = "0"b			/* Volume not found, room for another? */
      425 	     then
      426 	     if rcpd.last_volume >= rcpd.tot_volumes then do;
      427 						/* No room. */
      428 		ecode = error_table_$notalloc;
      429 		return;
      430 	     end;
      431 	     else do;				/* Get a new entry. */
      432 		rcpd.last_volume = rcpd.last_volume + 1;
      433 		volume_off = rel (addr (rcpd.volume (rcpd.last_volume)));
      434 	     end;
      435 
      436 /*	Now we must make sure we have access to the volume requested.
      437**/
      438 	if access = "000"b then do;			/* Don't know yet. */
      439 	     call setup_kernel_call ((VOLUME_TYPE (rcse.dtypex)), rcse.volume_name, ecode);
      440 	     if ecode ^= 0 then
      441 		return;
      442 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
      443 	     if ecode ^= 0 then
      444 		if (ecode = error_table_$resource_unknown) & (rcpd.modes.auto_registration) then do;
      445 		     rcse.flags.must_auto_register = "1"b;
      446 		     access = REW_ACCESS;
      447 		     ecode = 0;
      448 		     call cleanup_kernel_call (ignored_code);
      449 		end;
      450 		else do;
      451 		     call cleanup_kernel_call (ignored_code);
      452 		     return;
      453 		end;
      454 	     else do;
      455 		access = effmode;
      456 		call cleanup_kernel_call (ignored_code);
      457 	     end;
      458 	end;
      459 
      460 
      461 /*	Assign volume by filling in the free volume entry that we have found.
      462**/
      463 	volume_ptr = ptr (rcpd_ptr, volume_off);	/* Get pointer to assigned volume entry. */
      464 	volume.process_id = rcse.process_id;		/* Assign volume entry to process. */
      465 	volume.vtypex = rcse.dtypex;
      466 	volume.unassign_state = volume.state;
      467 	volume.state = ASSIGNED;			/* Make it assigned. */
      468 	volume.state_time = clock ();
      469 	volume.volume_name = volume_name;
      470 	volume.group_id = rcse.group_id;
      471 	if volume.unassign_state = FREE then do;	/* if this was free ... */
      472 	     volume.reserved_by = "";			/* no reservation */
      473 	     volume.reservation_id = 0;
      474 	end;
      475 	volume.current_authorization = get_authorization_ ();
      476 						/* Save this guy's authorization. */
      477 
      478 	volume_name = rcse.volume_name;		/* Leave the real volume name here. */
      479 	volume_flag = "1"b;				/* ON => a volume has been assigned. */
      480 	rcse.state = 2;				/* State => volume now assigned. */
      481 	rcse.volume_off = volume_off;			/* Save offset of volume entry. */
      482 
      483      end ASSIGN_VOLUME;
      484 
      485 ASSIGN_DEVICE:
      486      procedure;
      487 
      488 dcl	ignored_code	   fixed bin (35);
      489 dcl	(i, j)		   fixed bin;
      490 
      491 /*	This procedure is called to assign a device.  The following tests
      492*   *	are made before assigning a device:
      493*   *	     1.	There must be an appropriate device.
      494*   *	     2.	The requesting process must have access to the device.
      495*   *	     3.  	There must be an appropriate and accessible device that is available.
      496*   *	     4.	The device limits must not be exceeded.
      497*   *	     5.	If the assignment is based on a volume then we will try to
      498*   *		find a device that has the specified volume already mounted.
      499*   *	     6.	Otherwise we take the device that has been unassigned the longest.
      500**/
      501 	rcse_ptr = ptr (rcs_ptr, dev_rcse_off);		/* Get pointer to RCS entry for device. */
      502 	dtypex = rcse.dtypex;			/* Get device type index. */
      503 	dtype_ptr = addr (rcpd.dtype (dtypex));		/* Get pointer to device type entry. */
      504 	system_flag = rcse.flags.system;		/* Get system flag. */
      505 	if rcse.group_id = "Initializer.SysDaemon.z" & rcse.caller_level = 1 then
      506 	     system_flag = "1"b;
      507 
      508 	num_assigned,				/* Initialize counters. */
      509 	     num_free_res, num_reserved, num_resvd = 0;
      510 	one_was_accessible, one_was_appropriate = "0"b;
      511 	num_available = 0;
      512 
      513 	device_off = dtype.first_off;			/* Start with first type of device. */
      514 	full = "0"b;				/* available_list array is empty. */
      515 	do while ((device_off ^= "0"b) & (^full));	/* Test all devices of this type until the available_list array is full. */
      516 	     device_ptr = ptr (rcpd_ptr, device_off);	/* Get pointer to RCPD device entry. */
      517 	     call TEST_DEVICE;			/* Test device to see if it can be assigned. */
      518 	     device_off = device.next_off;		/* Get offset of next device of this type. */
      519 	end;
      520 
      521 	if num_available = 0			/* none to return */
      522 	then do;					/* select the error code */
      523 	     if ^one_was_appropriate then
      524 		ecode = error_table_$no_appropriate_device;
      525 	     else if ^one_was_accessible then
      526 		ecode = error_table_$resource_bad_access;
      527 	     else ecode = error_table_$resource_unavailable;
      528 						/* there was one that we would have access too, but we couldn't have it */
      529 	     return;
      530 	end;
      531 
      532 	call CHECK_LIMITS;				/* Check device limits. */
      533 	if ecode ^= 0 then
      534 	     return;				/* Find the best device that matched. */
      535 	if num_resvd > 0 then do;
      536 	     j = 0;
      537 	     do i = 1 to num_available;
      538 		if available_list (i) -> device.state = RESERVED then do;
      539 		     j = j + 1;
      540 		     if i ^= j then
      541 			available_list (j) = available_list (i);
      542 		end;
      543 	     end;
      544 	     num_available = j;
      545 	end;
      546 
      547 	call rcp_match_$select (addr (available_list), num_available, rcse.volume_name, device_ptr);
      548 	device_off = rel (device_ptr);		/* Save offset of device entry. */
      549 
      550 /* When searching for any device, auditing is done after selection. */
      551 /* Call the kernel to perform the auditing since it has all the */
      552 /* information needed to do it.  */
      553 
      554 	if (^rcse.flags.device & rcpd.modes.resource_mgmt_enabled) then do;
      555 	     detailed_operation.search = "0"b;
      556 	     call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, ecode);
      557 	     temp_mode = ""b;
      558 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), temp_mode, ecode);
      559 	     call cleanup_kernel_call (ecode);		/* the above call was just to provoke an audit, so we can discard the error code. */
      560 	end;
      561 
      562 	rcse.flags.volume = "0"b;
      563 	if device.volume_name ^= "" then do;		/* then let him know it. */
      564 	     if rcpd.modes.resource_mgmt_enabled then do;
      565 		call setup_kernel_call ((VOLUME_TYPE (device.dtypex)), device.volume_name, ecode);
      566 		if ecode = 0 then do;
      567 		     detailed_operation.search = "1"b;	/* Don't audit this since a denial is unimportant. */
      568 		     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
      569 		     detailed_operation.search = "0"b;
      570 		     if ecode = 0 then do;
      571 			rcse.flags.volume = "1"b;
      572 			rcse.volume_name = device.volume_name;
      573 		     end;
      574 		     else ecode = 0;
      575 		end;
      576 		else ecode = 0;			/* no such volume? ignore the problem, and just hand over the requested device. ycch. */
      577 		call cleanup_kernel_call (ecode);
      578 	     end;
      579 	     else if rcp_match_user_name_ (rcse.group_id, device.group_id) then do;
      580 		rcse.flags.volume = "1"b;
      581 		rcse.volume_name = device.volume_name;
      582 	     end;
      583 	end;
      584 
      585 	if ^rcse.flags.volume then
      586 	     rcse.volume_name = "";
      587 	rcse.flags.preload_allowed = ^rcpd.modes.unload_on_detach;
      588 	rcse.flags.not_removable_media = device.flags.not_removable_media;
      589 
      590 	device.process_id = rcse.process_id;		/* Save info about assignment. */
      591 	device.group_id = rcse.group_id;
      592 	if device.flags.reservable			/* Can device be reserved? */
      593 	     then
      594 	     device.flags.reserved = system_flag;
      595 	else device.flags.reserved = "0"b;
      596 	if device.state = DELETED			/* Are we assigning a deleted device? */
      597 	then do;					/* Yes. */
      598 	     call admin_gate_$ioi_add_device ((device.device_name), ignored_code);
      599 	     device.flags.delete,			/* Remember to delete when unassigned. */
      600 		device.flags.priv = "1"b;		/* Special assignment for privileged attachment. */
      601 	end;
      602 	device.state_time = clock ();			/* Note when assigned. */
      603 	device.unassign_state = device.state;		/* redundant for DELETED, since flags.delete forces unassignment to delete */
      604 						/* the curious result of this is that if the operator  */
      605 						/* during the .priv attachment it will fail. */
      606 	device.current_authorization = get_authorization_ ();
      607 						/* Save this guy's authorization. */
      608 	device.state = ASSIGNED;			/* Device is now assigned. */
      609 
      610 	if device.unassign_state ^= RESERVED then	/* Accounting for reserved devices is done at reservation time. */
      611 	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_assign);
      612 
      613 	rcse.state = 2;				/* Tell requesting process assignment complete. */
      614 	rcse.device_off = device_off;			/* Save offset of rcp_data entry. */
      615 	rcse.device_name = device.device_name;		/* Return info about assigned device. */
      616 	rcse.model = device.model;
      617 	do i = 1 to device.num_qualifiers;
      618 	     rcse.qualifiers (i) = device.qualifiers (i);
      619 	end;
      620 	rcse.flags.system = system_flag;		/* Note whether assigned as a system process. */
      621 	rcse.flags.fips = device.flags.fips;		/* pass along fips flag */
      622 	rcse.flags.no_protect = device.flags.no_protect;	/* pass along no_protect flag */
      623 	rcse.flags.opr_int_available = device.flags.opr_int_available;
      624 						/* pass along opr_int_available flag */
      625 
      626 /*	Note this assignment in the syserr log.
      627**/
      628 	call admin_gate_$syserr (LOG, "RCP: Assigned ^a to ^a", device.device_name, device.group_id);
      629 
      630      end ASSIGN_DEVICE;
      631 
      632 TEST_DEVICE:
      633      procedure;
      634 
      635 /*	This procedure is called to test a device.  We will see if it is
      636*   *	appropriate, accessible, and available.  If it is all three we
      637*   *	will add it to a list of such devices.
      638**/
      639 
      640 /* Test free devices and deleted devices */
      641 
      642 	if (device.state = FREE) | (device.state = DELETED & rcse.flags.priv) then do;
      643 	     if device.dtypex = CONSOLE_DTYPEX then
      644 		call admin_gate_$console_free (substr (device.device_name, 1, 4), console_free);
      645 
      646 /**** The following test is obscure. Note the following:
      647*      if a console is RCP-DELETED, then it is in ocdcm_ unavailable.
      648*      However, ocdcm_ does nothing different for an UNAVAILABLE device
      649*      from an INOP or an I/O device.
      650*      Therefore, checking the console_free flag suffices for consoles. */
      651 
      652 	     if (device.dtypex = CONSOLE_DTYPEX & console_free) | (device.dtypex ^= CONSOLE_DTYPEX) then do;
      653 		if device.flags.reservable then	/* Can this device be reserved? */
      654 		     num_free_res = num_free_res + 1;	/* Yes, count free reservable devices. */
      655 		else ;
      656 		available_flag = "1"b;		/* Device is available. */
      657 	     end;
      658 	end;
      659 
      660 /*  Test assigned devices */
      661 
      662 	else if (device.state = ASSIGNED) then do;
      663 	     if device.process_id = rcse.process_id then	/* Assigned to requesting process? */
      664 		num_assigned = num_assigned + 1;	/* Yes, count number assigned to this process. */
      665 	     if device.flags.reserved then		/* Is device reserved to a system process? */
      666 		num_reserved = num_reserved + 1;	/* Yes, count these too. */
      667 	     available_flag = "0"b;			/* This device is not available. */
      668 	end;
      669 
      670 /*  Test reserved devices */
      671 
      672 	else if (device.state = RESERVED) then
      673 	     if device.process_id = rcse.process_id then
      674 		available_flag = "1"b;
      675 	     else available_flag = "0"b;
      676 
      677 /*  Must be a storage system device - forget it */
      678 	else return;
      679 
      680 /*  Make appropriate, accessible, available test */
      681 
      682 	match_flag = rcp_match_$match (rcse_ptr, device_ptr);
      683 	if match_flag then				/* Did it match, i.e., is it appropriate? */
      684 	     one_was_appropriate = "1"b;
      685 	else return;				/* No this device is not appropriate. */
      686 	operation = access_operations_$rcp_assign_write;
      687 	if ^rcse.flags.device then
      688 	     detailed_operation.search = "1"b;
      689 	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, ecode);
      690 	detailed_operation.priv_gate_call = ""b;	/* Device assignment is not a privileged */
      691 						/* gate call, even through rcp_priv_ */
      692 	if ecode = 0 then
      693 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
      694 	if ecode = 0 then
      695 	     accessible_flag = "1"b;
      696 	else do;
      697 	     accessible_flag = "0"b;
      698 	     ecode = 0;
      699 	end;
      700 	call cleanup_kernel_call (ecode);		/* don't zero code until it has been tested */
      701 
      702 	if ^accessible_flag then
      703 	     return;
      704 
      705 	one_was_accessible = "1"b;
      706 
      707 	if ^available_flag then
      708 	     return;
      709 
      710 	num_available = num_available + 1;
      711 	if num_available = MAX_AVAILABLE then
      712 	     full = "1"b;				/* available list is now full */
      713 	available_list (num_available) = device_ptr;	/* Put this device in the available list. */
      714 	if device.state = RESERVED then		/* a reserved device */
      715 	     num_resvd = num_resvd + 1;
      716 	return;					/* test passes here */
      717      end TEST_DEVICE;
      718 
      719 CHECK_LIMITS:
      720      procedure;
      721 
      722 dcl	i		   fixed bin;
      723 
      724 /*	This procedure is called to check the limits imposed upon non
      725*   *	system processes.  These limits are:
      726*   *	     1.	Only a certain number of devices of any one type may be assigned
      727*   *		to a process at at one time.
      728*   *	     2.	A certain number of reservable devices of this type
      729*   *		must be free or in use by system processes.
      730**/
      731 	if system_flag				/* Is this a system process? */
      732 	     then
      733 	     return;				/* Yes, no need to test limits. */
      734 
      735 	if num_resvd ^= 0 then
      736 	     return;				/* can always use reserved device */
      737 
      738 	if num_assigned >= dtype.max_concurrent		/* Maximum already assigned to this process? */
      739 	then do;					/* Yes. */
      740 	     ecode = error_table_$device_limit_exceeded;
      741 	     return;
      742 	end;
      743 
      744 	if num_reserved >= dtype.num_reserved		/* Already using the quota of system drives? */
      745 	     then
      746 	     return;				/* Yes, don't bother the user */
      747 
      748 	if num_free_res > (dtype.num_reserved - num_reserved) then
      749 	     return;				/* There are enough free reservable devices. */
      750 
      751 	num_avail_nres = 0;				/* Count number that will be available. *. */
      752 	do i = 1 to num_available;			/* Remove reservable devices from selection list. */
      753 	     device_ptr = available_list (i);
      754 	     if ^device.flags.reservable		/* If non reservable keep in list. */
      755 	     then do;
      756 		available_list (num_avail_nres) = device_ptr;
      757 		num_avail_nres = num_avail_nres + 1;
      758 	     end;
      759 	end;
      760 	num_available = num_avail_nres;		/* Now only non reservable devices are available. */
      761 	if num_available = 0			/* Are there any available devices left? */
      762 	then do;					/* No, only reservable devices were available. */
      763 	     ecode = error_table_$resource_unavailable;
      764 	     return;
      765 	end;
      766 
      767      end CHECK_LIMITS;
      768 
      769 ERROR_COUNT:
      770      procedure;
      771 
      772 /*	This procedure is called to update the error count for a device.
      773**/
      774 	dev_rcse_off = a_device_offset;
      775 	device_ptr = ptr (rcpd_ptr, dev_rcse_off);
      776 
      777 	if device.state ^= ASSIGNED then		/* Is device assigned? */
      778 	     ecode = error_table_$resource_unassigned;	/* No, ignore this call. */
      779 
      780 	if device.process_id ^= get_process_id_ () then
      781 	     ecode = error_table_$resource_unassigned;	/* Not assigned to this process. */
      782 
      783 	if ecode = 0 then do;
      784 	     device.error_count = device.error_count + error_count;
      785 	     a_error_count = device.error_count;
      786 	end;
      787 	return;
      788      end ERROR_COUNT;
      789 
      790 UNASSIGN:
      791      procedure;
      792 
      793 /*	This procedure is called to unassign a device and/or volume.
      794*   *	The volume and device offsets reference RCPD volume and
      795*   *	and device entries.  The resources associated with these
      796*   *	entries will be unassigned.  Before unassigning any
      797*   *	resource we will verify that it is actually assigned to the
      798*   *	requesting process.  We will note this unassignment in the syserr log.
      799**/
      800 	if detailed_operation.force then do;
      801 	     call FORCE_UNASSIGN;
      802 	     return;
      803 	end;
      804 	if detailed_operation.process then do;
      805 	     call PROC_UNASSIGN;
      806 	     return;
      807 	end;
      808 
      809 	volume_off = a_volume_offset;
      810 	device_off = a_device_offset;
      811 
      812 	process_id = get_process_id_ ();		/* Get process ID of calling process. */
      813 
      814 	if volume_off ^= "0"b			/* Is there a volume to unassign? */
      815 	then do;					/* Yes. */
      816 	     volume_ptr = ptr (rcpd_ptr, volume_off);
      817 	     if volume.process_id = process_id then	/* Volume is assigned to this process. */
      818 		call UNASSIGN_VOLUME ();
      819 	end;
      820 
      821 	if device_off ^= "0"b then do;		/* Is there a device to unassign? */
      822 	     device_ptr = ptr (rcpd_ptr, device_off);	/* Yes, get a pointer to its device entry. */
      823 	     if device.process_id = process_id then do;	/* Is it actually assigned to this process? */
      824 		device.error_count = device.error_count + error_count;
      825 		call UNASSIGN_DEVICE;
      826 		call admin_gate_$syserr (LOG, "RCP: Unassigned ^a from ^a", device.device_name, device.group_id);
      827 		a_error_count = error_count;
      828 	     end;
      829 	end;
      830 
      831      end UNASSIGN;
      832 
      833 FORCE_UNASSIGN:
      834      procedure;
      835 
      836 dcl	i		   fixed bin;
      837 
      838 /*	This procedure is called to force the unassignment of a device.
      839*   *	The device does not have to be assigned by the requesting process.
      840*   *	If there is a volume mounted on this device we will unassign it.
      841**/
      842 	device_name = a_device_name;
      843 
      844 	call FIND_DEVICE;				/* Search through all devices for this one. */
      845 	if device_off = "0"b then do;			/* Find it? */
      846 	     ecode = error_table_$resource_unknown;	/* No */
      847 	     return;
      848 	end;
      849 
      850 	if device.state = ASSIGNED then do;		/* Is device assigned? */
      851 	     call UNASSIGN_DEVICE;			/* Just forcedly unassign it. */
      852 	     call admin_gate_$syserr (ANNOUNCE, "RCP: Force Unassigned ^a from ^a", device_name, device.group_id);
      853 	end;
      854 
      855 	if device.volume_name = " "			/* Is there a volume on this device? */
      856 	     then
      857 	     return;				/* No, we are all done. */
      858 
      859 	do i = 1 to rcpd.last_volume;			/* Yes, find this volume. */
      860 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to next volume entry. */
      861 	     if volume.volume_name = device.volume_name then do;
      862 						/* We found this volume. */
      863 		call UNASSIGN_VOLUME ();
      864 		return;
      865 	     end;
      866 	end;
      867 
      868      end FORCE_UNASSIGN;
      869 
      870 PROC_UNASSIGN:
      871      procedure;
      872 
      873 dcl	i		   fixed bin;
      874 
      875 /*	This procedure is called to forcedly unassign all devices and volumes
      876*   *	currently assigned to the process whose process ID has been provided
      877*   *	by the caller of this routine.
      878**/
      879 
      880 	process_id = a_process_id;
      881 
      882 	do i = 1 to rcpd.last_volume;			/* Look at all volume entries. */
      883 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
      884 	     if volume.process_id = process_id		/* Does volume belong to this process? */
      885 	     then do;				/* Yes, unassign it. */
      886 		volume.unassign_state = FREE;
      887 		call UNASSIGN_VOLUME ();
      888 	     end;
      889 	end;
      890 
      891 	do i = 1 to rcpd.tot_devices;			/* Look at all devices. */
      892 	     device_ptr = addr (rcpd.device (i));
      893 	     if device.process_id = process_id		/* Does device belong to this process? */
      894 	     then do;				/* Yes, forcedly unassign. */
      895 		device.unassign_state = FREE;
      896 		call UNASSIGN_DEVICE;
      897 		call admin_gate_$syserr (LOG, "RCP: Force Unassigned ^a from ^a", device.device_name, device.group_id)
      898 		     ;
      899 	     end;
      900 	end;
      901 
      902      end PROC_UNASSIGN;
      903 
      904 DELETE_DEVICE:
      905      procedure;
      906 
      907 dcl	local_code	   fixed bin (35);
      908 dcl	local_effmode	   bit (3);
      909 
      910 /*	This procedure is called to put a device in the deleted state.
      911*   *	This means that the device cannot be assigned to any process.
      912*   *	If the device is currently assigned will will not delete it now.
      913*   *	We will remember to delete it when it is unassigned.
      914**/
      915 	device_name = a_device_name;			/* Get name of device to delete. */
      916 
      917 	call FIND_DEVICE;				/* Find the device with this name. */
      918 	if device_off = "0"b then do;			/* Did we find it? */
      919 	     ecode = error_table_$resource_unknown;
      920 	     goto DELETE_RETURN;
      921 	end;
      922 
      923 	if device.state = STORAGE_SYSTEM then
      924 	     goto DELETE_RETURN;			/* Should not be here, but check for ss drives */
      925 	if device.state = ASSIGNED | device.state = RESERVED
      926 						/* Is device still assigned? */
      927 	then do;					/* Yes, we won't delete it now. */
      928 	     device.flags.delete = "1"b;		/* Remember to delete it when unassigned. */
      929 	     ecode = error_table_$device_deletion_deferred;
      930 	     goto DELETE_RETURN;
      931 	end;
      932 
      933 	if device.volume_name ^= "" & device.dtypex = 1 then
      934 	     call rcp_unload_$unload_device (device_ptr, "1"b);
      935 						/* unload volume and forget it was here */
      936 
      937 	call admin_gate_$ioi_delete_device (device_name, ecode);
      938 	if ecode ^= 0 then
      939 	     goto DELETE_RETURN;
      940 
      941 	device.volume_name = " ";			/* Forget any volume on the deleted device. */
      942 	device.process_id = "0"b;			/* Make sure it doesn't belong to any process. */
      943 	device.state = DELETED;			/* Just change its state. */
      944 	device.state_time = clock ();			/* And remember when. */
      945 
      946 	if device.dtypex = CONSOLE_DTYPEX then		/* must inform console DIM of deletion... */
      947 	     call admin_gate_$ocdcm_reconfigure (substr (device_name, 1, 4), MAKE_UNAVAILABLE, ecode);
      948 
      949 	call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device_name);
      950 DELETE_RETURN:					/* Let's perform auditing. Call setup_kernel_call to set up */
      951 						/* the resource_info and requestor_info structures although we */
      952 						/* really don't call the kernel for this operation, it has all the */
      953 						/* information so let it do the auditing for us. */
      954 	local_code = 0;
      955 	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, local_code);
      956 	if local_code = 0 then do;			/* if we didn't find the resource at all ... */
      957 	     detailed_operation.priv_gate_call = "1"b;
      958 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), local_effmode, (ecode));
      959 	end;
      960 	call cleanup_kernel_call (local_code);
      961 	if ecode = 0 then
      962 	     ecode = local_code;
      963 	return;
      964 
      965      end DELETE_DEVICE;
      966 
      967 
      968 
      969 
      970 
      971 ADD_DEVICE:
      972      procedure;
      973 
      974 /*	This procedure is called to take a device out of the deleted state.
      975*   *	This will only be done if the device is already in the deleted state.
      976**/
      977 
      978 dcl	local_code	   fixed bin (35);
      979 dcl	local_effmode	   bit (3);
      980 dcl	operational	   bit (1) aligned;
      981 dcl	1 tape_name	   unaligned,
      982 	  2 subsystem	   char (4),
      983 	  2 bar		   char (1),
      984 	  2 drive		   pic "99";
      985 
      986 	device_name = a_device_name;			/* Get name of device to add. */
      987 
      988 	call FIND_DEVICE;				/* Find the device with this name. */
      989 	if device_off = "0"b			/* Did we find it? */
      990 	     then
      991 	     goto ADD_RETURN;
      992 
      993 	device.flags.delete = "0"b;			/* Make sure no delete is pending. */
      994 
      995 	if device.state ^= DELETED			/* Is device in the deleted state? */
      996 	     then
      997 	     goto ADD_RETURN;			/* No, leave it alone. */
      998 
      999 	if (device.dtypex = TAPE_DRIVE_DTYPEX) & (device.qualifiers (1) = 0) then do;
     1000 						/* this is a tape drive deleted during initialization */
     1001 	     string (tape_name) = substr (device_name, 1, length (string (tape_name)));
     1002 	     call rcp_tape_survey_ (tape_name.subsystem, (tape_name.drive), (device.flags.fips), operational,
     1003 		device.qualifiers, ecode);
     1004 	     if ^operational then do;
     1005 		if ecode = 0 then
     1006 		     call admin_gate_$syserr (ANNOUNCE, "RCP: ^a is not operational and will not be added.",
     1007 			device_name);
     1008 		goto ADD_RETURN;
     1009 	     end;
     1010 	end;
     1011 
     1012 	call admin_gate_$ioi_add_device (device_name, ecode);
     1013 	if ecode ^= 0 then
     1014 	     goto ADD_RETURN;
     1015 
     1016 	device.state = FREE;			/* Put it into the free state. */
     1017 	device.unassign_state = FREE;			/* And keep it there. */
     1018 	device.state_time = clock ();			/* Save time device added. */
     1019 
     1020 	if device.dtypex = CONSOLE_DTYPEX then		/* must inform console DIM of deletion... */
     1021 	     call admin_gate_$ocdcm_reconfigure (substr (device_name, 1, 4), MAKE_IO_DEVICE, ecode);
     1022 	call admin_gate_$syserr (ANNOUNCE, "RCP: Added device ^a", device_name);
     1023 ADD_RETURN:					/* Let's perform auditing. Call setup_kernel_call to set up */
     1024 						/* the resource_info and requestor_info structures although we */
     1025 						/* really don't call the kernel for this operation, it has all */
     1026 						/* information to do the auditing so let it do it. */
     1027 	local_code = 0;
     1028 	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, local_code);
     1029 	if local_code = 0 then do;			/* if we didn't find the resource at all ... */
     1030 	     detailed_operation.priv_gate_call = "1"b;
     1031 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), local_effmode, (ecode));
     1032 	end;
     1033 	call cleanup_kernel_call (local_code);
     1034 	if ecode = 0 then
     1035 	     ecode = local_code;
     1036 	return;
     1037 
     1038      end ADD_DEVICE;
     1039 
     1040 ACCOUNT_ATTACH:
     1041      procedure;
     1042 
     1043 /*	This procedure is called when an attachment is completed.  The rcp_control_
     1044*   *	wakes the accounting process with a datum about the attachment. */
     1045 
     1046 	device_off = a_device_offset;
     1047 
     1048 	device_ptr = ptr (rcpd_ptr, device_off);
     1049 
     1050 	call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_attach);
     1051 
     1052 	return;
     1053 
     1054      end ACCOUNT_ATTACH;
     1055 
     1056 UNASSIGN_DEVICE:
     1057      procedure;
     1058 
     1059 dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
     1060 dcl	i		   fixed bin;
     1061 dcl	old_state		   fixed bin;
     1062 
     1063 /*	This procedure is called to put a device in the state it was in
     1064*   *	at assignment time.
     1065*   *	It will also compute the metering statistics kept for each device.
     1066*   *	If the device was supposed to be deleted but was not because it was still
     1067*   *	assigned we will delete it now.
     1068**/
     1069 	time_assigned = device.state_time;		/* Save time assigned. */
     1070 
     1071 	old_state = device.state;
     1072 	if device.flags.delete			/* Are we waiting to delete this device? */
     1073 	     & (device.unassign_state = FREE | device.unassign_state = DELETED)
     1074 						/* and it won't still be reserved after this unassignment */
     1075 	then do;					/* Yes, delete it now. */
     1076 	     if ^device.flags.priv & device.volume_name ^= "" & device.dtypex <= 2 then do;
     1077 						/* Must unload this loaded device. */
     1078 		device.state = FREE;		/* do this now to permit unload */
     1079 		call rcp_unload_$unload_device (device_ptr, "1"b);
     1080 						/* unload volume and forget it was here */
     1081 	     end;
     1082 	     call admin_gate_$ioi_delete_device ((device.device_name), ignored_code);
     1083 	     device.state = DELETED;			/* Now it is deleted. */
     1084 	     device.volume_name = "";
     1085 	     if ^device.flags.priv			/* If not assigned while deleted say it is deleted now. */
     1086 		then
     1087 		call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device.device_name);
     1088 	     device.flags.delete,			/* Turn off these flags. */
     1089 		device.flags.priv = "0"b;
     1090 	end;
     1091 	else device.state = device.unassign_state;	/* No, unassign the device. */
     1092 
     1093 	device.unassign_state = FREE;
     1094 
     1095 	if device.state ^= RESERVED then do;		/* Accounting for reserved devices is done at cancel time. */
     1096 						/* the only other possibilities are DELETED and FREE */
     1097 	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_unassign);
     1098 						/* go send wakeup before clearing process_id */
     1099 	     device.process_id = "0"b;		/* No longer assigned to this process. */
     1100 	     device.reservation_id = 0;
     1101 	     device.reserved_by = "";
     1102 	end;
     1103 	device.state_time = clock ();			/* Time device made free. */
     1104 
     1105 	device.num_assigns = device.num_assigns + 1;
     1106 	device.flags.mounting = "0"b;			/* Turn off mount timer for this device. */
     1107 	device.flags.attached = "0"b;
     1108 
     1109 	time_assigned = device.state_time - time_assigned;
     1110 	device.tot_assign_time = device.tot_assign_time + time_assigned;
     1111 	time_assigned = divide (time_assigned, 1000000, 71, 0);
     1112 	dtype_ptr = addr (rcpd.dtype (device.dtypex));
     1113 
     1114 	do i = 1 to hbound (dtype.histo_times, 1);	/* Find histogram slot. */
     1115 	     if time_assigned < dtype.histo_times (i) then do;
     1116 						/* We found the right slot. */
     1117 		device.histogram (i) = device.histogram (i) + 1;
     1118 		return;
     1119 	     end;
     1120 	end;					/* Falling through loop => use last slot. */
     1121 	device.histogram (hbound (device.histogram, 1)) = device.histogram (hbound (device.histogram, 1)) + 1;
     1122 
     1123      end UNASSIGN_DEVICE;
     1124 
     1125 UNASSIGN_VOLUME:
     1126      proc ();
     1127 
     1128 dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
     1129 dcl	old_state		   fixed bin (35);
     1130 
     1131 /*
     1132*   This procedure is called to put a volume in the free or reserved
     1133*   state.  The choice is made based on the volume's state at the time of
     1134*   the last assignment.
     1135**/
     1136 
     1137 	volume.state_time = clock ();			/* record the time */
     1138 	old_state = volume.state;
     1139 	volume.state = volume.unassign_state;		/* and return the volume to the proper state */
     1140 	volume.unassign_state = FREE;			/* reset the unassign state */
     1141 	if volume.state = FREE then do;		/* if we are freeing it ... */
     1142 	     volume.process_id = "0"b;		/* no process owns it now */
     1143 	     volume.reserved_by = "";
     1144 	     volume.reservation_id = 0;
     1145 	     if old_state = RESERVED then
     1146 		call rcp_cancel_resource_ (VOLUME_TYPE (volume.vtypex), (volume.volume_name), ignored_code);
     1147 						/* Tell Resource Management that this volume has been turned loose. */
     1148 	     if rcpd.unload_on_detach then do;		/* all done */
     1149 		volume.volume_name = "";		/* no need to remember the volume_name */
     1150 		volume.group_id = "";
     1151 	     end;
     1152 	end;
     1153 	return;
     1154 
     1155      end UNASSIGN_VOLUME;
     1156 
     1157 FIND_DEVICE:
     1158      procedure;
     1159 
     1160 dcl	i		   fixed bin;		/*	This procedure is called to find the device entry of the device with
     1161*						   *	the specified name.  We will search by device type since tapes and
     1162*						   *	disks are the most active types.
     1163*						*/
     1164 	do i = 1 to rcpd.tot_dtypes;			/* Look at each device type. */
     1165 	     dtype_ptr = addr (rcpd.dtype (i));		/* Get pointer to device type entry. */
     1166 	     device_off = dtype.first_off;		/* Start with first device type. */
     1167 	     do while (device_off ^= "0"b);		/* Look at each device of this type. */
     1168 		device_ptr = ptr (rcpd_ptr, device_off);
     1169 		if device.device_name = device_name then
     1170 		     return;			/* This is the device.  Look no further. */
     1171 		device_off = device.next_off;
     1172 	     end;
     1173 	end;
     1174 
     1175 	device_off = "0"b;				/* Let caller know we didn't find device. */
     1176 
     1177      end FIND_DEVICE;
     1178 
     1179 ACCOUNT_WAKEUP:
     1180      procedure (a_devptr, a_action);
     1181 
     1182 /*	This procedure is called to format an accounting message, and send it to the
     1183*   *	accounting process.  If the accounting event channel has not been set up, no message is sent.
     1184**/
     1185 
     1186 
     1187 dcl	a_devptr		   ptr;			/* Pointer to rcp_data entry */
     1188 dcl	a_action		   fixed bin;		/* Accounting action */
     1189 
     1190 dcl	wakeup_buf	   fixed bin (71);
     1191 dcl	1 auto_rcpamsg	   like rcp_account_msg aligned;
     1192 
     1193 	unspec (auto_rcpamsg) = "0"b;
     1194 
     1195 	auto_rcpamsg.device_user_procid = a_devptr -> device.process_id;
     1196 	auto_rcpamsg.rcp_data_relp = rel (a_devptr);
     1197 	auto_rcpamsg.devtype = a_devptr -> device.dtypex;
     1198 	auto_rcpamsg.action = a_action;
     1199 
     1200 	unspec (wakeup_buf) = unspec (auto_rcpamsg);
     1201 	if rcpd.accounting_chan ^= 0 then
     1202 	     call hcs_$wakeup (rcpd.accounting_pid, rcpd.accounting_chan, wakeup_buf, (0));
     1203 
     1204      end ACCOUNT_WAKEUP;
     1205 
     1206 ss_io_interchange:
     1207      entry (a_device_name, a_add_sw, a_del_sw, a_ecode);
     1208 
     1209 /*	Entry to add and delete disk drives on demand, called from mdx in
     1210*   *	the initializer's process, in ring 1. a_add_sw is "1"b if drive is
     1211*   *	being given back to RCP.
     1212**/
     1213 
     1214 	device_name = a_device_name;
     1215 	add_sw = a_add_sw;
     1216 	del_sw = a_del_sw;
     1217 	ecode = 0;
     1218 
     1219 	rcpd_ptr = rcp_pointers_$data ();
     1220 	rcs_ptr = rcp_pointers_$com_seg ();
     1221 
     1222 	on cleanup
     1223 	     begin;
     1224 	     call cleanup_kernel_call ((0));
     1225 	     call UNLOCK;				/* If trouble unlock rcp_data. */
     1226 	end;
     1227 
     1228 	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
     1229 	if ecode ^= 0 then do;
     1230 	     a_ecode = ecode;
     1231 	     return;
     1232 	end;
     1233 
     1234 	call FIND_DEVICE;				/* Attempt to find the device */
     1235 
     1236 	if device_off = "000000"b3 then
     1237 	     ecode = error_table_$resource_unknown;
     1238 	else if dtype.device_type ^= DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
     1239 	     ecode = error_table_$invalid_state;
     1240 
     1241 	if ecode = 0 then
     1242 	     if add_sw then
     1243 		if device.state = STORAGE_SYSTEM then
     1244 		     if del_sw then
     1245 			device.state = DELETED;	/* deleted */
     1246 		     else device.state = FREE;	/* free */
     1247 		else ecode = error_table_$invalid_state;
     1248 	     else if device.state = ASSIGNED then
     1249 		ecode = error_table_$io_still_assnd;
     1250 	     else device.state = STORAGE_SYSTEM;
     1251 
     1252 	if ecode = 0 then do;
     1253 	     device.state_time = clock ();
     1254 	     device.volume_name = " ";
     1255 	     device.process_id = "000000000000"b3;
     1256 	     call admin_gate_$syserr (ANNOUNCE, "RCP: ^[Acquired ^a from^;Consigned ^a to^] storage system.", add_sw,
     1257 		device_name);
     1258 	end;
     1259 
     1260 	a_ecode = ecode;
     1261 	call UNLOCK;
     1262 	return;
     1263 
     1264 setup_kernel_call:
     1265      proc (a_resource_type, a_resource_name, a_code);
     1266 
     1267 dcl	(a_resource_type, a_resource_name)
     1268 			   char (*) aligned;
     1269 dcl	a_code		   fixed bin (35);
     1270 dcl	local_code	   fixed bin (35);
     1271 
     1272 dcl	rcprm_registry_util_$grab_transaction_control_file
     1273 			   entry (ptr, char (*) aligned, fixed bin (35));
     1274 dcl	rcprm_registry_util_$grab_registry
     1275 			   entry (ptr, char (*) aligned, char (*) aligned, fixed bin (35));
     1276 dcl	rcprm_registry_util_$find_resource_record
     1277 			   entry (ptr, char (*) aligned, ptr, fixed bin (35));
     1278 
     1279 	local_code = 0;
     1280 	if rcpd.modes.resource_mgmt_enabled then do;
     1281 	     res_info.registry_dir = DEFAULT_REGISTRY_DIR;
     1282 	     call rcprm_registry_util_$grab_transaction_control_file (trans_iocb_ptr, res_info.registry_dir, local_code)
     1283 		;
     1284 	     if local_code ^= 0 then
     1285 		goto SETUP_RETURN;
     1286 	     call rcprm_registry_util_$grab_registry (reg_iocb_ptr, res_info.registry_dir, a_resource_type, local_code);
     1287 	     if local_code ^= 0 then
     1288 		goto SETUP_RETURN;
     1289 	     call rcprm_registry_util_$find_resource_record (reg_iocb_ptr, a_resource_name, record_ptr, local_code);
     1290 	     if local_code ^= 0 then do;
     1291 		if local_code = error_table_$no_key then
     1292 		     local_code = error_table_$resource_unknown;
     1293 						/* well defined reason for this. */
     1294 		call cleanup_kernel_call ((0));	/* undo the above */
     1295 		goto SETUP_RETURN;
     1296 	     end;
     1297 	     res_info.registry_switch_ptr = reg_iocb_ptr;
     1298 	     res_info.registry_record_ptr = record_ptr;
     1299 	end;
     1300 	else do;
     1301 	     res_info.registry_dir = "";
     1302 	     res_info.registry_switch_ptr, res_info.registry_record_ptr = null ();
     1303 	end;
     1304 	if (basic_operation (operation) = access_operations_$rcp_unassign
     1305 	     & (detailed_operation.force | detailed_operation.process))
     1306 	     | (base_op = access_operations_$rcp_delete_device) | (base_op = access_operations_$rcp_add_device) then
     1307 	     detailed_operation.priv_gate_call = "1"b;
     1308 	else detailed_operation.priv_gate_call = "0"b;
     1309 	res_info.resource_type = a_resource_type;
     1310 	res_info.resource_name = a_resource_name;
     1311 	if base_op = access_operations_$rcp_add_device | base_op = access_operations_$rcp_delete_device then do;
     1312 	     req_info.user_id = get_group_id_ ();
     1313 	     req_info.validation_level = 1;
     1314 	end;
     1315 	else do;
     1316 	     req_info.user_id = rcse.group_id;
     1317 	     req_info.validation_level = rcse.caller_level;
     1318 	end;
     1319 	call hcs_$get_authorization (req_info.current_authorization, ""b);
     1320 
     1321 SETUP_RETURN:
     1322 	a_code = local_code;
     1323      end setup_kernel_call;
     1324 
     1325 cleanup_kernel_call:
     1326      proc (a_code);
     1327 
     1328 dcl	a_code		   fixed bin (35);
     1329 dcl	local_code	   fixed bin (35);
     1330 dcl	rcprm_registry_util_$release_transaction_control_file
     1331 			   entry (ptr, fixed bin (35));
     1332 dcl	rcprm_registry_util_$release_registry
     1333 			   entry (ptr, fixed bin (35));
     1334 
     1335 	local_code = 0;
     1336 	if reg_iocb_ptr ^= null () then
     1337 	     call rcprm_registry_util_$release_registry (reg_iocb_ptr, local_code);
     1338 	if trans_iocb_ptr ^= null () then
     1339 	     call rcprm_registry_util_$release_transaction_control_file (trans_iocb_ptr, local_code);
     1340 
     1341 	a_code = local_code;
     1342      end cleanup_kernel_call;
     1343 
     1344 basic_operation:
     1345      proc (oper) returns (bit (36) aligned);
     1346 
     1347 dcl	oper		   bit (36) aligned;
     1348 dcl	return_arg	   bit (36) aligned;
     1349 
     1350 	return_arg = oper;
     1351 	addr (return_arg) -> encoded_access_op.detailed_operation = 0;
     1352 	return (return_arg);
     1353 
     1354      end basic_operation;
     1355 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1356 
     1357 
  2     1 /*	Begin  include file ... rcp_data.incl.pl1
  2     2*   *
  2     3*   *	Created on 09/06/74 by Bill Silver.
  2     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  2     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  2     6*   *	It contains information about all of the devices and volumes managed by RCP.
  2     7*   *	This include file references rcp_com_seg.incl.pl1.
  2     8*
  2     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  2    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  2    11*   *	Modified on 12/09/78 to add removable media bit.
  2    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  2    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  2    14*   *	Modified 11/84 by Paul Farley to add fips flag.
  2    15*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  2    16**/
  2    17 
  2    18 /****^  HISTORY COMMENTS:
  2    19*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  2    20*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  2    21*     Support FIPS and IMU.
  2    22*                                                   END HISTORY COMMENTS */
  2    23 
  2    24 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  2    25 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  2    26 dcl  device_ptr ptr;				/* Points to a device entry. */
  2    27 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  2    28 
  2    29 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  2    30     2 lock_info like lock_info,			/* Data used to lock this segment. */
  2    31     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  2    32     2 modes like rcp_init_flags unaligned,
  2    33     2 tot_dtypes fixed bin,				/* Number of known device types. */
  2    34     2 tot_devices fixed bin,				/* Total number of devices configured. */
  2    35     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  2    36     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  2    37     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  2    38     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  2    39     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  2    40     2 accounting_pid bit (36),			/* ID of accounting process */
  2    41     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  2    42     2 pad (7) fixed bin,
  2    43     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  2    44      like dtype,					/* See structure below. */
  2    45     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  2    46      like device,					/* See structure below. */
  2    47     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  2    48      like volume,					/* See structure below. */
  2    49     2 end bit (36) aligned;				/* End of rcp_data. */
  2    50 
  2    51 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  2    52     2 device_type char (32),				/* Name of this device type. */
  2    53     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  2    54     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  2    55     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  2    56     2 first_off bit (18),				/* Offset of first device entry. */
  2    57     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  2    58 
  2    59 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  2    60     2 device_name char (8),				/* Name of device associated with this entry. */
  2    61     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  2    62     2 dtypex fixed bin,				/* Device type index. */
  2    63     2 model fixed bin,				/* Device model number. */
  2    64     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  2    65     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  2    66     2 state_time fixed bin (71),			/* Time device put into current state. */
  2    67     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  2    68*						   3 => storage system, 4 => reserved */
  2    69 
  2    70 /*	*	*	*	*	** Following fields are unique to device entry. */
  2    71 
  2    72     2 unassign_state fixed bin,			/* State to return when unassigning. */
  2    73     2 acs_name char (12),				/* Entry name of ACS for this device. */
  2    74     2 next_off bit (18),				/* Offset of next entry for this device type. */
  2    75     2 iom_num fixed bin,				/* IOM number for this device. */
  2    76     2 chan_num fixed bin,				/* Channel number for this device. */
  2    77     2 num_channels fixed bin,				/* Num channels that may address device. */
  2    78     2 flags,					/* Special info flags. */
  2    79      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  2    80       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  2    81       3 reservable bit (1),				/* ON => may be reserved for system process. */
  2    82       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  2    83       3 mounting bit (1),				/* ON => mount pending. */
  2    84       3 writing bit (1),				/* ON => mounting for writing. */
  2    85       3 attached bit (1) unal,			/* ON => device is attached. */
  2    86       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  2    87       3 fips bit (1),				/* ON => FIPS device. */
  2    88       3 no_protect bit (1),				/* ON => device has no protect sw. */
  2    89       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  2    90       3 unused bit (25)) unal,
  2    91     2 process_id bit (36),				/* ID of assigned process. */
  2    92     2 group_id char (32),				/* Process group ID. */
  2    93     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  2    94     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  2    95     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  2    96     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  2    97     2 reservation_id fixed bin (71),
  2    98     2 reserved_by char (32),				/* Who made this reservation. */
  2    99     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  2   100 
  2   101 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  2   102     2 process_id bit (36),				/* "0"b => unassigned. */
  2   103     2 volume_name char (32),				/* Volume name. */
  2   104     2 vtypex fixed bin,				/* Volume type index. */
  2   105     2 group_id char (32),				/* This is used for the reserved_for field. */
  2   106     2 reserved_by char (32),
  2   107     2 reservation_id fixed bin (71),
  2   108     2 state_time fixed bin (71),			/* Same as for a device. */
  2   109     2 state fixed bin,				/* Same as for a device. */
  2   110     2 unassign_state fixed bin,			/* State to return when unassigning. */
  2   111     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  2   112 
  3     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  3     2 
  3     3 /* Created on 04/24/78 by Michael R. Jordan */
  3     4 /* Modified 04/10/79 by C. D. Tavares */
  3     5 
  3     6 dcl  rifp ptr;
  3     7 
  3     8 dcl 1 rcp_init_flags based (rifp),
  3     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  3    10     2 pad1 bit (2) unaligned,				/* obsolete */
  3    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  3    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  3    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  3    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  3    15 
  3    16 dcl (No_authentication initial (0),
  3    17      Nominal_authentication initial (1),
  3    18      Automatic_authentication initial (2),
  3    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  3    20 
  3    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  3    22     ("none", "nominal", "automatic", "manual");
  3    23 
  3    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2   113 
  2   114 
  2   115 /*	End of include file ... rcp_data.incl.pl1	*/
     1358 
     1359 
  4     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  4     2*   *
  4     3*   *	Created on 11/20/74 by Bill Silver.
  4     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  4     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  4     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  4     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  4     8*   *	Modified 11/84 by Paul Farley to add fips flag.
  4     9*   *      Modified 1/3/85 by Fawcett to allow room for mca device type
  4    10*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  4    11*   *	This include file defines the Resource Control Package communication segment.
  4    12*   *	This segment is used to communicate requests between the various internal
  4    13*   *	parts of RCP.
  4    14**/
  4    15 
  4    16 /****^  HISTORY COMMENTS:
  4    17*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4    18*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  4    19*     Support MCA and FIPS.
  4    20*                                                   END HISTORY COMMENTS */
  4    21 
  4    22 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  4    23 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  4    24 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  4    25 
  4    26 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  4    27    (2 id_count fixed bin (17),			/* Unique count index. */
  4    28     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  4    29 
  4    30 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  4    31     2 lock_info like lock_info,			/* Data used to lock this segment. */
  4    32     2 ws_maxs (8) fixed bin (19),			/* Max IOI workspace size in words. */
  4    33     2 ws_pmaxs (8) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  4    34     2 to_maxs (8) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  4    35     2 sys_directory char (32),			/* Directory  used to define a system process. */
  4    36     2 sys_acs char (32),				/* Entry name used to define a system process. */
  4    37     2 acs_directory char (32),			/* Directory containing device ACSs. */
  4    38     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  4    39     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  4    40     2 num_entries fixed bin,				/* Total number of entries. */
  4    41     2 first_free_off bit (18),			/* Offset of first free entry. */
  4    42     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  4    43      like rcse,					/* See structure below. */
  4    44     2 end bit (36);					/* End of rcp_com_seg. */
  4    45 
  4    46 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  4    47     2 lock bit (36),				/* The lock itself. */
  4    48     2 num_locks fixed bin (35),			/* Number of times locked. */
  4    49     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  4    50     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  4    51     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  4    52     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  4    53     2 starting_time fixed bin (71);			/* Time metering started. */
  4    54 
  4    55 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  4    56     2 device_name char (8),				/* Name of device associated with this entry. */
  4    57     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  4    58     2 dtypex fixed bin,				/* Device type index. */
  4    59     2 model fixed bin,				/* Device model number. */
  4    60     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  4    61     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  4    62     2 state_time fixed bin (71),			/* Time device put into current state. */
  4    63     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  4    64 						/* 3 - attaching  4 - attached   5 - completed. */
  4    65 
  4    66 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  4    67     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  4    68     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  4    69     2 user_off bit (18),				/* Offset of next entry in user list. */
  4    70     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  4    71     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  4    72     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  4    73     2 caller_level fixed bin,				/* Caller's validation level. */
  4    74     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  4    75     2 flags,					/* Special info flags. */
  4    76      (3 device bit (1),				/* ON => assigning a specific device. */
  4    77       3 priv bit (1),				/* ON => attached with IOI privilege. */
  4    78       3 system bit (1),				/* ON => assigned to a system process. */
  4    79       3 t_and_d bit (1),				/* ON => T&D attachment. */
  4    80       3 volume bit (1),				/* ON => volume associated with this device. */
  4    81       3 writing bit (1),				/* ON => writing on volume. */
  4    82       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  4    83       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  4    84       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  4    85       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  4    86       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  4    87       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  4    88       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  4    89       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  4    90       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  4    91       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  4    92       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  4    93       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  4    94       3 fips bit (1),				/* ON => FIPS device. */
  4    95       3 no_protect bit (1),				/* ON => device has no protect sw. */
  4    96       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  4    97       3 unused bit (6),
  4    98       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  4    99       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  4   100     2 rcp_id bit (36),				/* ID of this entry. */
  4   101     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  4   102     2 process_id bit (36),				/* ID of calling process. */
  4   103     2 group_id char (32),				/* Group ID of calling process. */
  4   104     2 ecode fixed bin (35),				/* Assignment error code. */
  4   105     2 version_num fixed bin,				/* Device info version number. */
  4   106     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  4   107     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  4   108     2 ioi_index fixed bin,				/* IOI device index. */
  4   109     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  4   110     2 caller_comment char (64);			/* Caller's comment. */
  4   111 
  4   112 /*	End of include file ... rcp_com_seg.incl.pl1	*/
     1360 
     1361 
  5     1 /* BEGIN INCLUDE FILE rcp_account_msg.incl.pl1    B. Greenberg 8/1/77 */
  5     2 
  5     3 dcl 1 rcp_account_msg based aligned,			/* Message format */
  5     4     2 device_user_procid bit (36),			/* id of process using the device */
  5     5 
  5     6     2 rcp_data_relp bit (18) unal,			/* Ptr to rcp_data entry for device */
  5     7     2 devtype fixed bin (8) unal,			/* rcp device type involved */
  5     8     2 pad bit (6) unal,
  5     9     2 action fixed bin (2) unal;			/* see below... */
  5    10 
  5    11 dcl (
  5    12      RCP_ACCTMSG_assign init (0),
  5    13      RCP_ACCTMSG_unassign init (1),
  5    14      RCP_ACCTMSG_attach init (2)
  5    15      ) options (constant) fixed bin (17) static;
  5    16 
  5    17 /* END INCLUDE FILE rcp_account_msg.incl.pl1 */
     1362 
     1363 
  6     1 /*        Begin include file rcp_resource_states.incl.pl1
  6     2**
  6     3**         Created by M. M. Pozzo on 841005
  6     4**	Modified by Chris Jones, 12/84, to add volume states.
  6     5**
  6     6**/
  6     7 
  6     8 declare FREE fixed bin static internal options (constant) init (0);
  6     9 declare ASSIGNED fixed bin static internal options (constant) init (1);
  6    10 declare DELETED fixed bin static internal options (constant) init (2);
  6    11 declare STORAGE_SYSTEM fixed bin static internal options (constant) init (3);
  6    12 declare RESERVED fixed bin static internal options (constant) init (4);
  6    13 
  6    14 /* End include file ... rcp_resource_states.incl.pl1  */
     1364 
     1365 
  7     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  7     2 /*       Begin include file rcp_requestor_info.incl.pl1
  7     3* *       
  7     4* *       This include file gives information about the subject,
  7     5* *       or requestor of the RCP operation.  In one case, absentee
  7     6* *       requests, the user is the Initializer, so this piece of
  7     7* *       information tells us about the real requestor of the RCP
  7     8* *       operation.
  7     9**/
  7    10 
  7    11 dcl requestor_info_ptr ptr;
  7    12 
  7    13 dcl 1 requestor_info aligned based (requestor_info_ptr),
  7    14     2 user_id char (32),
  7    15     2 current_authorization bit (72) aligned,
  7    16     2 validation_level fixed bin (3);
  7    17 
  7    18 /*  end include file .. rcp_requestor_info.incl.pl1 */
     1366 
     1367 
  8     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8     2 /*       Begin include file rcp_resource_info.incl.pl1
  8     3*   *
  8     4*   *       This include file gives information about the object,
  8     5*   *       or resource for the RCP operation.  If RM is enabled this
  8     6*   *       information will provide the registry name and switch pointer
  8     7*   *       for the registry so additional resource information can be
  8     8*   *       determined.  If RM is disabled, this information will include
  8     9*   *       the resource name and/or type.
  8    10**/
  8    11 
  8    12 dcl	resource_info_ptr	   ptr;
  8    13 
  8    14 dcl	1 resource_info	   based (resource_info_ptr),
  8    15 	  2 registry_dir	   aligned char (64),	/*  Could be a different if it is reconstruct operation */
  8    16 	  2 registry_switch_ptr
  8    17 			   ptr,			/*  Switch to the registry */
  8    18 	  2 registry_record_ptr
  8    19 			   ptr,			/*  Pointer to the registry record */
  8    20 	  2 resource_type	   char (32),		/*  Resource type */
  8    21 	  2 resource_name	   char (32);		/*  Resource name */
  8    22 
  8    23 /*  end include file .. rcp_resource_info.incl.pl1 */
     1368 
     1369 
  9     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  9     2*   *
  9     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  9     4*   *
  9     5*   *	This include file defines the official RCP resource types.
  9     6*   *	The array of names is indexed by the corresponding device type.
  9     7*   *      MOD by RAF for MCA
  9     8**/
  9     9 
  9    10 
  9    11 
  9    12 /****^  HISTORY COMMENTS:
  9    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  9    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  9    15*     Support of MCA.
  9    16*                                                   END HISTORY COMMENTS */
  9    17 
  9    18 dcl  DEVICE_TYPE (8) char (32)
  9    19 	internal static options (constant)
  9    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  9    21 
  9    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  9    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  9    24 
  9    25 dcl  VOLUME_TYPE (8) char (32)
  9    26 	internal static options (constant)
  9    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  9    28 
  9    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  9    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  9    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  9    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  9    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  9    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  9    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  9    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  9    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  9    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  9    39 
  9    40 
  9    41 /*	End include file ... rcp_resource_types.incl.pl1 */
     1370 
     1371 
 10     1 /* begin include file - access_audit_encoded_op.incl.pl1 */
 10     2 
 10     3 dcl 1 encoded_access_op	aligned based,
 10     4       2 audit_type	unal,
 10     5         3 object_type	fixed bin (4) uns unal,
 10     6         3 access_type	fixed bin (2) uns unal,
 10     7       2 operation_index	fixed bin (12) uns unal,
 10     8       2 detailed_operation	fixed bin (18) uns unal;
 10     9 
 10    10 /* object_type = Seg, Dir, Rcp, Admin, Special, Other
 10    11*   access_type = None, Modify_Acl, Modify, Read
 10    12*   operation_index is the index of this code in
 10    13*     access_operations_$oper_codes and the index of
 10    14*     the text descriptor in access_operations_$text_offest_table
 10    15*     (see access_operations_.incl.pl1)
 10    16*   detailed_operation is additional info inserted by the
 10    17*     caller of the subsystem performing the operation
 10    18**/
 10    19 
 10    20 /* end include file - access_audit_encoded_op.incl.pl1 */
     1372 
 11     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 11     2 /*  BEGIN include rcp_ops.incl.pl1  */
 11     3 
 11     4 /* Written 02/27/85 by Chris Jones, Maria Pozzo */
 11     5 
 11     6 dcl	ops_ptr		   ptr;
 11     7 
 11     8 dcl	1 detailed_operation   unaligned based (ops_ptr),
 11     9 	  2 given,
 11    10 	    3 potential_attributes
 11    11 			   bit (1),
 11    12 	    3 desired_attributes
 11    13 			   bit (1),
 11    14 	    3 potential_aim_range
 11    15 			   bit (1),
 11    16 	    3 aim_range	   bit (1),
 11    17 	    3 owner	   bit (1),
 11    18 	    3 acs_path	   bit (1),
 11    19 	    3 location	   bit (1),
 11    20 	    3 comment	   bit (1),
 11    21 	    3 charge_type	   bit (1),
 11    22 	    3 usage_lock	   bit (1),
 11    23 	    3 release_lock	   bit (1),
 11    24 	    3 user_alloc	   bit (1),
 11    25 	  2 priv_gate_call	   bit (1),
 11    26 	  2 search	   bit (1),
 11    27 	  2 force		   bit (1),
 11    28 	  2 process	   bit (1),
 11    29 	  2 owner		   bit (1),
 11    30 	  2 pad		   bit (1);
 11    31 
     1373 
     1374 
 12     1 /*  START OF:	opc_reconfig_options.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
 12     2 
 12     3 	
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(85-09-09,Farley), approve(85-12-03,MCR7312),
 12     6*     audit(85-11-14,Fawcett), install(86-03-21,MR12.0-1033):
 12     7*     Add Lock and unlock
 12     8*     MCA.
 12     9*  2) change(85-12-03,Farley), approve(85-12-03,MCR7306),
 12    10*     audit(85-12-03,Fawcett), install(86-03-21,MR12.0-1033):
 12    11*     Fix bugs found while doing Dipper changes.
 12    12*  3) change(85-12-03,Farley), approve(85-12-03,MCR7312),
 12    13*     audit(85-12-03,Fawcett), install(86-03-21,MR12.0-1033):
 12    14*     Add BCE MCA lock and unlock.
 12    15*                                                   END HISTORY COMMENTS */
 12    16 
 12    17 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12    18 	/*										*/
 12    19 	/* Purpose:									*/
 12    20 	/*										*/
 12    21 	/* This include file contains the possible operator console reconfiguration options. These are 	*/
 12    22 	/* passed to hphcs_$ocdcm_reconfigure to effect explicit console reconfiguration.		*/
 12    23 	/*										*/
 12    24 	/* Initial Coding:		06/18/83							*/
 12    25 	/*										*/
 12    26 	/* Author:		E. A. Ranzenbach	(Ranzenbach.Multics@M)			*/
 12    27 	/* Location:		System-M.							*/
 12    28 	/* Release:		MR10.2							*/
 12    29 	/*										*/
 12    30 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12    31 	/*										*/
 12    32 	/* Modifications:									*/
 12    33 	/*										*/
 12    34 	/* Date    Author			Reason						*/
 12    35 	/*										*/
 12    36 	/* 840420  E. A. Ranzenbach		Added MAKE_UNAVAILABLE option.			*/
 12    37 	/* 850205  E. A. Ranzenbach		Added SEND_MC_IO option.				*/
 12    38 	/* 850520  Paul K Farley		Added LOCK_MCA_INPUT option.				*/
 12    39 	/*				Added UNLOCK_MCA_INPUT option.			*/
 12    40 	/*										*/
 12    41 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12    42 
 12    43 /* format: off */
 12    44 
 12    45      dcl	(
 12    46 	NOP			init	(0),			/* just to make sure...		*/
 12    47 	ENABLE_CONSOLE_SERVICE	init	(1),			/* allow syserr and normal I/O...	*/
 12    48 	SUSPEND_CONSOLE_SERVICE	init	(2),			/* the opposite of ENABLE...		*/
 12    49 	MAKE_BOOTLOAD_CONSOLE	init	(3),			/* make the bootload console...	*/
 12    50 	MAKE_ALTERNATE_CONSOLE	init	(4),			/* add console to alternate list...	*/
 12    51 	MAKE_IO_DEVICE		init	(5),			/* release the console to IOI...	*/
 12    52 	MAKE_INOP_DEVICE		init	(6),			/* release the console to IOI...	*/
 12    53 	RESET_CONSOLE		init	(7),			/* reset the bootload console...	*/
 12    54 	CRASH_ON_CRF		init	(8),			/* CRASH on console recovery failure... */
 12    55 	RUN_ON_CRF		init	(9),			/* RUN on console recovery failure... 	*/
 12    56 	MAKE_UNAVAILABLE		init	(10),			/* put console into the OFF state...	*/
 12    57           SEND_MC_IO		init	(11),			/* forward all I/O to the MC console... */
 12    58           LOCK_MCA_INPUT		init	(12),			/* Disable input path from console to MCA(in IMU)... */
 12    59           UNLOCK_MCA_INPUT		init	(13)			/* Enable input path from console to MCA(in IMU)... */
 12    60 	)
 12    61 				fixed bin	(17)
 12    62 				internal static	options (constant);
 12    63 
 12    64 /*  END OF:	opc_reconfig_options.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1375 
     1376 
 13     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 13     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 13     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 13     4 
 13     5 /* This include file has an ALM version.  Keep 'em in sync! */
 13     6 
 13     7 dcl (
 13     8 
 13     9 /* The following constants define the message action codes.  This indicates
 13    10*how a message is to be handled.  */
 13    11 
 13    12      SYSERR_CRASH_SYSTEM	init (1),			
 13    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 13    14 
 13    15      SYSERR_TERMINATE_PROCESS	init (2),
 13    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 13    17 
 13    18      SYSERR_PRINT_WITH_ALARM	init (3),
 13    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 13    20 
 13    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 13    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 13    23 
 13    24      SYSERR_LOG_OR_PRINT	init (4),
 13    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 13    26 
 13    27      SYSERR_LOG_OR_DISCARD	init (5),
 13    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 13    29 
 13    30 
 13    31 /* The following constants are added to the normal severities to indicate
 13    32*different sorting classes of messages.  */
 13    33 
 13    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 13    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 13    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 13    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 13    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 13    39 	) fixed bin internal static options (constant);
 13    40 
 13    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     1377 
     1378 
     1379 /* BEGIN MESSAGE DOCUMENTATION
     1380*
     1381*   Message:
     1382*   RCP: Acquired DEVICE from storage system.
     1383*
     1384*   S:	$info
     1385*
     1386*   T:	$response
     1387*
     1388*   M:	The operator has used the set_drive_usage command to make
     1389*   DRIVE an IO drive.
     1390*
     1391*   A:	$ignore
     1392*
     1393*
     1394*   Message:
     1395*   RCP: Added device DEVICE
     1396*
     1397*   S:	$info
     1398*
     1399*   T:	$response
     1400*
     1401*   M:	The operator has added a user I/O disk drive with adddev.
     1402*
     1403*   A:	$ignore
     1404*
     1405*
     1406*   Message:
     1407*   RCP: Assigned DEVICE to PERSON.PROJ.T
     1408*
     1409*   S:	$log
     1410*
     1411*   T:	$run
     1412*
     1413*   M:	DEVICE has been assigned to a user process.
     1414*
     1415*   A:	$ignore
     1416*
     1417*
     1418*   Message:
     1419*   RCP: Consigned DEVICE to storage system.
     1420*
     1421*   S:	$info
     1422*
     1423*   T:	$response
     1424*
     1425*   M:	The operator has used the set_drive_usage command to make DRIVE a storage system drive.
     1426*
     1427*   A:	$ignore
     1428*
     1429*
     1430*   Message:
     1431*   RCP: Deleted device DEVICE
     1432*
     1433*   S:	$info
     1434*
     1435*   T:	$response
     1436*
     1437*   M:	The operator has deleted user I/O disk DRIVE with deldev.
     1438*
     1439*   A:	$ignore
     1440*
     1441*
     1442*   Message:
     1443*   RCP: Force Unassigned DEVICE from PERSON.PROJ.T
     1444*
     1445*   S:	$info
     1446*
     1447*   T:	$run
     1448*
     1449*   M:	The user process PERSON.PROJ.T has terminated,
     1450*   and its resources have been freed.
     1451*   Or, the operator may have forced the unassignment of DRIVE.
     1452*
     1453*   A:	$ignore
     1454*
     1455*
     1456*   Message:
     1457*   RCP: Unassigned DEVICE from PERSON.PROJ.T
     1458*
     1459*   S:	$log
     1460*
     1461*   T:	$run
     1462*
     1463*   M:	PERSON.PROJ.T has released DRIVE normally.
     1464*
     1465*   A:	$ignore
     1466*
     1467*
     1468*   Message:
     1469*   RCP: DEVICE is not operational and has not been added.
     1470*
     1471*   S:	$info
     1472*
     1473*   T:	$response
     1474*
     1475*   M:	An attempt was made to add a non-operational device with adddev.
     1476*
     1477*   A:	Ready the device and add it again.
     1478*
     1479*
     1480*   Message:
     1481*   rcp_control_: Error surveying DEVICE. MESSAGE
     1482*
     1483*   S:	$info
     1484*
     1485*   T:	$response
     1486*
     1487*   M:	An error occurred while surveying the device.
     1488*
     1489*   A:	$notify
     1490*
     1491*
     1492*   END MESSAGE DOCUMENTATION */
     1493 
     1494      end rcp_control_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.7  rcp_control_.pl1                  >spec>install>1111>rcp_control_.pl1
1356         1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1358         2    03/27/86  1120.0  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
2-113        3    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
1360         4    03/27/86  1120.0  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
1362         5    11/09/77  0713.6  rcp_account_msg.incl.pl1          >ldd>include>rcp_account_msg.incl.pl1
1364         6    03/15/85  0953.1  rcp_resource_states.incl.pl1      >ldd>include>rcp_resource_states.incl.pl1
1366         7    03/15/85  0953.1  rcp_requestor_info.incl.pl1       >ldd>include>rcp_requestor_info.incl.pl1
1368         8    03/15/85  0953.1  rcp_resource_info.incl.pl1        >ldd>include>rcp_resource_info.incl.pl1
1370         9    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
1372        10    01/30/85  1523.9  access_audit_encoded_op.incl.pl1  >ldd>include>access_audit_encoded_op.incl.pl1
1373        11    03/15/85  0953.1  rcp_ops.incl.pl1                  >ldd>include>rcp_ops.incl.pl1
1375        12    03/27/86  1120.0  opc_reconfig_options.incl.pl1     >ldd>include>opc_reconfig_options.incl.pl1
1377        13    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000234 constant        fixed bin(17,0)          initial dcl 13-7 set ref 852* 949* 1005* 1022* 1085*
                                                                                  1256*
ASSIGNED                               constant        fixed bin(17,0)          initial dcl 6-9 ref 467 608 662 777 850 925 1248
CONSOLE_DTYPEX                         constant        fixed bin(17,0)          initial dcl 9-31 ref 643 652 652 946 1020
DEFAULT_REGISTRY_DIR            000200 constant        char(64)                 initial packed unaligned dcl 143 ref 1281
DELETED                                constant        fixed bin(17,0)          initial dcl 6-10 ref 596 642 943 995 1072 1083 1241
DEVICE_TYPE                     000100 constant        char(32)                 initial array packed unaligned dcl 9-18 ref 556 689
                                                                                  955 1028 1238
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 9-30 ref 1238
FREE                                   constant        fixed bin(17,0)          initial dcl 6-8 ref 411 418 471 642 886 895 1016
                                                                                  1017 1072 1078 1093 1140 1141 1246
LOG                             000235 constant        fixed bin(17,0)          initial dcl 13-7 set ref 628* 826* 897*
MAKE_IO_DEVICE                  000246 constant        fixed bin(17,0)          initial dcl 12-45 set ref 1020*
MAKE_UNAVAILABLE                000236 constant        fixed bin(17,0)          initial dcl 12-45 set ref 946*
MAX_AVAILABLE                          constant        fixed bin(17,0)          initial dcl 142 ref 133 711
RCP_ACCTMSG_assign                     constant        fixed bin(17,0)          initial dcl 5-11 set ref 610*
RCP_ACCTMSG_attach                     constant        fixed bin(17,0)          initial dcl 5-11 set ref 1050*
RCP_ACCTMSG_unassign                   constant        fixed bin(17,0)          initial dcl 5-11 set ref 1097*
RESERVED                               constant        fixed bin(17,0)          initial dcl 6-12 ref 411 538 610 672 714 925 1095
                                                                                  1145
REW_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 1-11 ref 446
STORAGE_SYSTEM                         constant        fixed bin(17,0)          initial dcl 6-11 ref 923 1241 1250
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 9-29 ref 999
VOLUME_TYPE                     000000 constant        char(32)                 initial array packed unaligned dcl 9-25 set ref 439
                                                                                  565 1145*
a_action                               parameter       fixed bin(17,0)          dcl 1188 ref 1179 1198
a_add_sw                               parameter       bit(1)                   dcl 84 ref 1206 1215
a_code                                 parameter       fixed bin(35,0)          dcl 1269 in procedure "setup_kernel_call" set ref
                                                                                  1264 1321*
a_code                                 parameter       fixed bin(35,0)          dcl 1328 in procedure "cleanup_kernel_call" set ref
                                                                                  1325 1341*
a_del_sw                               parameter       bit(1)                   dcl 85 ref 1206 1216
a_device_name                          parameter       char                     packed unaligned dcl 78 ref 37 842 915 986 1206 1214
a_device_offset                        parameter       bit(18)                  dcl 77 ref 37 309 774 810 1046
a_devptr                               parameter       pointer                  dcl 1187 ref 1179 1195 1196 1197
a_ecode                                parameter       fixed bin(35,0)          dcl 81 set ref 37 270* 289* 1206 1230* 1260*
a_error_count                          parameter       fixed bin(17,0)          dcl 79 set ref 37 254 785* 827*
a_operation                            parameter       bit(36)                  dcl 75 ref 37 251
a_process_id                           parameter       bit(36)                  dcl 80 ref 37 880
a_resource_name                        parameter       char                     dcl 1267 set ref 1264 1289* 1310
a_resource_type                        parameter       char                     dcl 1267 set ref 1264 1286* 1309
a_volume_offset                        parameter       bit(18)                  dcl 76 ref 37 308 809
access                          000100 automatic       bit(3)                   dcl 91 set ref 397* 401* 438 446* 455*
access_operations_$rcp_account  000052 external static bit(36)                  dcl 194 ref 284
access_operations_$rcp_add_device
                                000044 external static bit(36)                  dcl 188 ref 282 1304 1311
access_operations_$rcp_assign_read
                                000040 external static bit(36)                  dcl 184 ref 274
access_operations_$rcp_assign_write
                                000042 external static bit(36)                  dcl 186 ref 274 324 686
access_operations_$rcp_delete_device
                                000046 external static bit(36)                  dcl 190 ref 280 1304 1311
access_operations_$rcp_error_count
                                000050 external static bit(36)                  dcl 192 ref 276
access_operations_$rcp_unassign 000054 external static bit(36)                  dcl 196 ref 278 1304
accessible_flag                 000102 automatic       bit(1)                   dcl 93 set ref 694* 697* 702
accounting_chan          26            based           fixed bin(71,0)          level 2 dcl 2-29 set ref 1201 1201*
accounting_pid           30            based           bit(36)                  level 2 dcl 2-29 set ref 1201*
action                    1(33) 000522 automatic       fixed bin(2,0)           level 2 packed packed unaligned dcl 1191 set ref
                                                                                  1198*
add_sw                          000103 automatic       bit(1)                   dcl 94 set ref 1215* 1241 1256*
addr                                                   builtin function         dcl 154 ref 253 253 268 268 295 295 346 409 433 442
                                                                                  442 442 442 503 547 547 558 558 558 558 568 568
                                                                                  568 568 692 692 692 692 860 883 892 958 958 958
                                                                                  958 1031 1031 1031 1031 1112 1165 1228 1228 1351
admin_gate_$console_free        000056 constant        entry                    external dcl 202 ref 643
admin_gate_$ioi_add_device      000062 constant        entry                    external dcl 206 ref 598 1012
admin_gate_$ioi_delete_device   000064 constant        entry                    external dcl 208 ref 937 1082
admin_gate_$ocdcm_reconfigure   000060 constant        entry                    external dcl 204 ref 946 1020
admin_gate_$syserr              000066 constant        entry                    external dcl 210 ref 628 826 852 897 949 1005 1022
                                                                                  1085 1256
attached                 35(06)        based           bit(1)                   level 3 packed packed unaligned dcl 2-59 set ref
                                                                                  370* 1107*
auto_rcpamsg                    000522 automatic       structure                level 1 dcl 1191 set ref 1193* 1200
auto_registration        14(05)        based           bit(1)                   level 3 packed packed unaligned dcl 2-29 ref 443
available_flag                  000104 automatic       bit(1)                   dcl 95 set ref 656* 667* 672* 675* 707
available_list                  000200 automatic       pointer                  array dcl 133 set ref 538 540* 540 547 547 713* 753
                                                                                  756*
base_op                         000122 automatic       bit(36)                  dcl 110 set ref 252* 274 274 276 278 280 282 284
                                                                                  324* 1304 1304 1311 1311
caller_level             33            based           fixed bin(17,0)          level 2 dcl 4-55 ref 505 1317
cleanup                         000260 stack reference condition                dcl 148 ref 262 1222
clock                                                  builtin function         dcl 154 ref 468 602 944 1018 1103 1137 1253
console_free                    000105 automatic       bit(1)                   dcl 96 set ref 643* 652
current_authorization
                         40            based           bit(72)                  level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 475*
current_authorization
                         72            based           bit(72)                  level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 606*
current_authorization
                         10     000200 automatic       bit(72)                  level 2 in structure "req_info" dcl 134 in procedure
                                                                                  "rcp_control_" set ref 1319*
del_sw                          000106 automatic       bit(1)                   dcl 97 set ref 1216* 1241
delete                   35            based           bit(1)                   level 3 packed packed unaligned dcl 2-59 set ref
                                                                                  599* 928* 993* 1072 1088*
detailed_operation                     based           structure                level 1 packed packed unaligned dcl 11-8
                                                                                  in procedure "rcp_control_"
detailed_operation        0(18)        based           fixed bin(18,0)          level 2 in structure "encoded_access_op" packed
                                                                                  packed unsigned unaligned dcl 10-3 in procedure
                                                                                  "rcp_control_" set ref 253 1351*
dev_rcse_off                    000114 automatic       bit(18)                  dcl 103 set ref 309* 322 340 501 774* 775
device                                 based           structure                array level 2 in structure "rcpd" dcl 2-29
                                                                                  in procedure "rcp_control_" set ref 892
device                   35            based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" ref 554 687
device                                 based           structure                level 1 dcl 2-59 in procedure "rcp_control_"
device_name                     000123 automatic       char(32)                 packed unaligned dcl 111 in procedure "rcp_control_"
                                                                                  set ref 842* 852* 915* 937* 946 946 949* 986* 1001
                                                                                  1005* 1012* 1020 1020 1022* 1169 1214* 1256*
device_name                            based           char(8)                  level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 556* 598 615 628* 643 643
                                                                                  689* 826* 897* 955* 1028* 1082 1085* 1169
device_name                            based           char(8)                  level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 615*
device_off                      000115 automatic       bit(18)                  dcl 104 in procedure "rcp_control_" set ref 366* 367
                                                                                  368 376* 513* 515 516 518* 548* 614 810* 821 822
                                                                                  845 918 989 1046* 1048 1166* 1167 1168 1171* 1175*
                                                                                  1236
device_off               30            based           bit(18)                  level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 344 614*
device_ptr                      000272 automatic       pointer                  dcl 2-26 set ref 344* 345 349 357 365 368* 369 370
                                                                                  371* 373 376 516* 518 547* 548 556 556 563 565 565
                                                                                  572 579 581 588 590 591 592 592 595 596 598 599
                                                                                  599 602 603 603 606 608 610 610* 615 616 617 618
                                                                                  621 622 623 628 628 642 642 643 643 643 652 652
                                                                                  653 662 663 665 672 672 682* 689 689 713 714 753*
                                                                                  754 756 775* 777 780 784 784 785 822* 823 824 824
                                                                                  826 826 850 852 855 861 892* 893 895 897 897 923
                                                                                  925 925 928 933 933 933* 941 942 943 944 946 955
                                                                                  955 993 995 999 999 1002 1002 1016 1017 1018 1020
                                                                                  1028 1028 1048* 1050* 1069 1071 1072 1072 1072
                                                                                  1076 1076 1076 1078 1079* 1082 1083 1084 1085 1085
                                                                                  1088 1088 1091 1091 1093 1095 1097* 1099 1100 1101
                                                                                  1103 1105 1105 1106 1107 1109 1110 1110 1112 1117
                                                                                  1117 1121 1121 1121 1121 1168* 1169 1171 1241 1241
                                                                                  1246 1248 1250 1253 1254 1255
device_type                            based           char(32)                 level 2 dcl 2-51 ref 1238
device_user_procid              000522 automatic       bit(36)                  level 2 dcl 1191 set ref 1195*
devtype                   1(18) 000522 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 1191 set ref
                                                                                  1197*
divide                                                 builtin function         dcl 154 ref 1111
drive                     1(09) 000450 automatic       picture(2)               level 2 packed packed unaligned dcl 981 set ref 1002
dtype                                  based           structure                level 1 dcl 2-51 in procedure "rcp_control_"
dtype                    43            based           structure                array level 2 in structure "rcpd" dcl 2-29
                                                                                  in procedure "rcp_control_" set ref 346 503 1112
                                                                                  1165
dtype_ptr                       000270 automatic       pointer                  dcl 2-25 set ref 346* 366 503* 513 738 744 748 1112*
                                                                                  1114 1115 1165* 1166 1238
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" ref 345 556 565 643 652 652 689 933
                                                                                  946 955 999 1020 1028 1076 1112 1197
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" ref 439 465 502
dtypex                          000153 automatic       fixed bin(17,0)          dcl 115 in procedure "rcp_control_" set ref 345* 346
                                                                                  502* 503
ecode                    53            based           fixed bin(35,0)          level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 316* 327*
ecode                           000154 automatic       fixed bin(35,0)          dcl 116 in procedure "rcp_control_" set ref 260*
                                                                                  268* 269 270 286* 289 316 317 327 334 401* 402
                                                                                  414* 428* 439* 440 442* 443 443 447* 523* 525*
                                                                                  527* 533 556* 558* 559* 565* 566 568* 570 574*
                                                                                  576* 577* 689* 692 692* 694 698* 700* 740* 763*
                                                                                  777* 780* 783 846* 919* 929* 937* 938 946* 958 961
                                                                                  961* 1002* 1005 1012* 1013 1020* 1031 1034 1034*
                                                                                  1217* 1228* 1229 1230 1236* 1238* 1241 1247* 1248*
                                                                                  1252 1260
effmode                         000101 automatic       bit(3)                   packed unaligned dcl 92 set ref 442* 455 568* 692*
encoded_access_op                      based           structure                level 1 dcl 10-3
error_count                     000155 automatic       fixed bin(17,0)          dcl 117 in procedure "rcp_control_" set ref 254* 784
                                                                                  824 827
error_count              47            based           fixed bin(35,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 784* 784 785 824* 824
error_table_$device_deletion_deferred
                                000014 external static fixed bin(35,0)          dcl 164 ref 929
error_table_$device_limit_exceeded
                                000016 external static fixed bin(35,0)          dcl 166 ref 740
error_table_$invalid_state      000020 external static fixed bin(35,0)          dcl 168 ref 1238 1247
error_table_$io_still_assnd     000022 external static fixed bin(35,0)          dcl 170 ref 1248
error_table_$no_appropriate_device
                                000034 external static fixed bin(35,0)          dcl 179 ref 523
error_table_$no_key             000010 external static fixed bin(35,0)          dcl 161 ref 1291
error_table_$notalloc           000024 external static fixed bin(35,0)          dcl 172 ref 428
error_table_$resource_bad_access
                                000026 external static fixed bin(35,0)          dcl 173 ref 525
error_table_$resource_unassigned
                                000012 external static fixed bin(35,0)          dcl 162 ref 777 780
error_table_$resource_unavailable
                                000030 external static fixed bin(35,0)          dcl 175 ref 414 527 763
error_table_$resource_unknown   000032 external static fixed bin(35,0)          dcl 177 ref 443 846 919 1236 1291
error_table_$unsupported_operation
                                000036 external static fixed bin(35,0)          dcl 181 ref 286
fips                     35(08)        based           bit(1)                   level 3 in structure "device" packed packed
                                                                                  unaligned dcl 2-59 in procedure "rcp_control_" ref
                                                                                  621 1002
fips                     35(18)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" set ref 621*
first_off                13            based           bit(18)                  level 2 dcl 2-51 ref 366 513 1166
flags                    35            based           structure                level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_"
flags                    35            based           structure                level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_"
force                     0(14)        based           bit(1)                   level 2 packed packed unaligned dcl 11-8 ref 800
                                                                                  1304
full                            000107 automatic       bit(1)                   dcl 98 set ref 514* 515 711*
get_authorization_              000122 constant        entry                    external dcl 226 ref 475 606
get_group_id_                   000070 constant        entry                    external dcl 211 ref 1312
get_process_id_                 000072 constant        entry                    external dcl 212 ref 780 812
group_id                 12            based           char(32)                 level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 470* 1150*
group_id                 43            based           char(32)                 level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 470 505 579* 591 1316
group_id                 37            based           char(32)                 level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 579* 591* 628* 826* 852*
                                                                                  897*
hbound                                                 builtin function         dcl 154 ref 1114 1121 1121
hcs_$get_authorization          000124 constant        entry                    external dcl 227 ref 1319
hcs_$wakeup                     000074 constant        entry                    external dcl 213 ref 1201
histo_times              14            based           fixed bin(17,0)          array level 2 dcl 2-51 ref 1114 1115
histogram                54            based           fixed bin(17,0)          array level 2 dcl 2-59 set ref 1117* 1117 1121* 1121
                                                                                  1121 1121
i                               000467 automatic       fixed bin(17,0)          dcl 1060 in procedure "UNASSIGN_DEVICE" set ref
                                                                                  1114* 1115 1117 1117*
i                               000366 automatic       fixed bin(17,0)          dcl 722 in procedure "CHECK_LIMITS" set ref 752*
                                                                                  753*
i                               000332 automatic       fixed bin(17,0)          dcl 393 in procedure "ASSIGN_VOLUME" set ref 408*
                                                                                  409*
i                               000412 automatic       fixed bin(17,0)          dcl 836 in procedure "FORCE_UNASSIGN" set ref 859*
                                                                                  860*
i                               000345 automatic       fixed bin(17,0)          dcl 489 in procedure "ASSIGN_DEVICE" set ref 537*
                                                                                  538 540 540* 617* 618 618*
i                               000422 automatic       fixed bin(17,0)          dcl 873 in procedure "PROC_UNASSIGN" set ref 882*
                                                                                  883* 891* 892*
i                               000510 automatic       fixed bin(17,0)          dcl 1160 in procedure "FIND_DEVICE" set ref 1164*
                                                                                  1165*
ignored_code                    000500 automatic       fixed bin(35,0)          dcl 1128 in procedure "UNASSIGN_VOLUME" set ref
                                                                                  1145*
ignored_code                    000344 automatic       fixed bin(35,0)          dcl 488 in procedure "ASSIGN_DEVICE" set ref 598*
ignored_code                    000466 automatic       fixed bin(35,0)          dcl 1059 in procedure "UNASSIGN_DEVICE" set ref
                                                                                  1082*
ignored_code                    000333 automatic       fixed bin(35,0)          dcl 394 in procedure "ASSIGN_VOLUME" set ref 448*
                                                                                  451* 456*
j                               000346 automatic       fixed bin(17,0)          dcl 489 set ref 536* 539* 539 540 540 544
last_volume              20            based           fixed bin(17,0)          level 2 dcl 2-29 set ref 408 424 432* 432 433 859
                                                                                  882
length                                                 builtin function         dcl 154 ref 1001
local_code                      000444 automatic       fixed bin(35,0)          dcl 978 in procedure "ADD_DEVICE" set ref 1023*
                                                                                  1028* 1029 1033* 1034
local_code                      000100 automatic       fixed bin(35,0)          dcl 1329 in procedure "cleanup_kernel_call" set ref
                                                                                  1335* 1336* 1338* 1341
local_code                      000434 automatic       fixed bin(35,0)          dcl 907 in procedure "DELETE_DEVICE" set ref 950*
                                                                                  955* 956 960* 961
local_code                      000532 automatic       fixed bin(35,0)          dcl 1270 in procedure "setup_kernel_call" set ref
                                                                                  1279* 1282* 1284 1286* 1287 1289* 1290 1291 1291*
                                                                                  1321
local_effmode                   000445 automatic       bit(3)                   packed unaligned dcl 979 in procedure "ADD_DEVICE"
                                                                                  set ref 1031*
local_effmode                   000435 automatic       bit(3)                   packed unaligned dcl 908 in procedure
                                                                                  "DELETE_DEVICE" set ref 958*
lock_info                              based           structure                level 1 dcl 4-46 in procedure "rcp_control_"
lock_info                              based           structure                level 2 in structure "rcpd" dcl 2-29 in procedure
                                                                                  "rcp_control_" set ref 268 268 295 295 1228 1228
match_flag                      000110 automatic       bit(1)                   dcl 99 set ref 682* 683
max_concurrent           10            based           fixed bin(17,0)          level 2 dcl 2-51 ref 738
model                    13            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 616*
model                    13            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" ref 616
modes                    14(01)        based           structure                level 2 packed packed unaligned dcl 2-29
mounting                 35(04)        based           bit(1)                   level 3 packed packed unaligned dcl 2-59 set ref
                                                                                  1106*
must_auto_register       35(17)        based           bit(1)                   level 3 packed packed unaligned dcl 4-55 set ref
                                                                                  445*
next_off                 31            based           bit(18)                  level 2 dcl 2-59 ref 376 518 1171
no_protect               35(09)        based           bit(1)                   level 3 in structure "device" packed packed
                                                                                  unaligned dcl 2-59 in procedure "rcp_control_" ref
                                                                                  622
no_protect               35(19)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" set ref 622*
not_removable_media      35(07)        based           bit(1)                   level 3 in structure "device" packed packed
                                                                                  unaligned dcl 2-59 in procedure "rcp_control_" ref
                                                                                  588
not_removable_media      35(11)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" set ref 588*
null                                                   builtin function         dcl 154 ref 259 1302 1336 1338
num_assigned                    000156 automatic       fixed bin(17,0)          dcl 118 set ref 508* 663* 663 738
num_assigns              50            based           fixed bin(35,0)          level 2 dcl 2-59 set ref 1105* 1105
num_avail_nres                  000157 automatic       fixed bin(17,0)          dcl 119 set ref 751* 756 757* 757 760
num_available                   000160 automatic       fixed bin(17,0)          dcl 120 set ref 511* 521 537 544* 547* 710* 710 711
                                                                                  713 752 760* 761
num_free_res                    000161 automatic       fixed bin(17,0)          dcl 121 set ref 508* 653* 653 748
num_qualifiers           14            based           fixed bin(17,0)          level 2 dcl 2-59 ref 617
num_reserved             11            based           fixed bin(17,0)          level 2 in structure "dtype" dcl 2-51 in procedure
                                                                                  "rcp_control_" ref 744 748
num_reserved                    000162 automatic       fixed bin(17,0)          dcl 122 in procedure "rcp_control_" set ref 508*
                                                                                  665* 665 744 748
num_resvd                       000163 automatic       fixed bin(17,0)          dcl 123 set ref 508* 535 714* 714 735
old_state                       000501 automatic       fixed bin(35,0)          dcl 1129 in procedure "UNASSIGN_VOLUME" set ref
                                                                                  1138* 1145
old_state                       000470 automatic       fixed bin(17,0)          dcl 1061 in procedure "UNASSIGN_DEVICE" set ref
                                                                                  1071*
one_was_accessible              000164 automatic       bit(1)                   dcl 124 set ref 510* 525 705*
one_was_appropriate             000165 automatic       bit(1)                   dcl 125 set ref 510* 523 683*
oper                                   parameter       bit(36)                  dcl 1347 ref 1344 1350
operation                       000121 automatic       bit(36)                  dcl 109 set ref 251* 252* 253 442* 558* 568* 686*
                                                                                  692* 958* 1031* 1304*
operational                     000446 automatic       bit(1)                   dcl 980 set ref 1002* 1004
opr_int_available        35(20)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" set ref 623*
opr_int_available        35(10)        based           bit(1)                   level 3 in structure "device" packed packed
                                                                                  unaligned dcl 2-59 in procedure "rcp_control_" ref
                                                                                  623
ops_ptr                         000302 automatic       pointer                  dcl 11-6 set ref 253* 555 567 569 687 690 800 804
                                                                                  957 1030 1304 1304 1304 1308
preload_allowed          35(09)        based           bit(1)                   level 3 packed packed unaligned dcl 4-55 set ref
                                                                                  587*
priv                     35(01)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" ref 642
priv                     35(01)        based           bit(1)                   level 3 in structure "device" packed packed
                                                                                  unaligned dcl 2-59 in procedure "rcp_control_" set
                                                                                  ref 599* 1076 1085 1088*
priv_gate_call            0(12)        based           bit(1)                   level 2 packed packed unaligned dcl 11-8 set ref
                                                                                  690* 957* 1030* 1304* 1308*
process                   0(15)        based           bit(1)                   level 2 packed packed unaligned dcl 11-8 ref 804
                                                                                  1304
process_id               36            based           bit(36)                  level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 590* 663 672 780 823 893
                                                                                  942* 1099* 1195 1255*
process_id                             based           bit(36)                  level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 411 464* 817 884 1142*
process_id                      000120 automatic       bit(36)                  dcl 107 in procedure "rcp_control_" set ref 812* 817
                                                                                  823 880* 884 893
process_id               42            based           bit(36)                  level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" ref 411 464 590 663 672
ptr                                                    builtin function         dcl 154 ref 342 343 344 368 396 463 501 516 775 816
                                                                                  822 1048 1168
qualifiers               15            based           fixed bin(35,0)          array level 2 in structure "device" dcl 2-59
                                                                                  in procedure "rcp_control_" set ref 618 999 1002*
qualifiers               15            based           fixed bin(35,0)          array level 2 in structure "rcse" dcl 4-55
                                                                                  in procedure "rcp_control_" set ref 618*
rcp_access_kernel_              000076 constant        entry                    external dcl 214 ref 442 558 568 692 958 1031
rcp_account_msg                        based           structure                level 1 dcl 5-3
rcp_cancel_resource_            000130 constant        entry                    external dcl 230 ref 1145
rcp_data_relp             1     000522 automatic       bit(18)                  level 2 packed packed unaligned dcl 1191 set ref
                                                                                  1196*
rcp_get_scratch_volume_         000126 constant        entry                    external dcl 228 ref 401
rcp_init_flags                         based           structure                level 1 packed packed unaligned dcl 3-8
rcp_lock_$lock                  000100 constant        entry                    external dcl 215 ref 268 1228
rcp_lock_$unlock                000102 constant        entry                    external dcl 216 ref 295
rcp_match_$match                000104 constant        entry                    external dcl 217 ref 682
rcp_match_$select               000106 constant        entry                    external dcl 218 ref 547
rcp_match_user_name_            000110 constant        entry                    external dcl 219 ref 579
rcp_pointers_$com_seg           000112 constant        entry                    external dcl 220 ref 258 1220
rcp_pointers_$data              000114 constant        entry                    external dcl 221 ref 257 1219
rcp_tape_survey_                000116 constant        entry                    external dcl 222 ref 1002
rcp_unload_$unload_device       000120 constant        entry                    external dcl 224 ref 371 933 1079
rcpd                                   based           structure                level 1 dcl 2-29
rcpd_ptr                        000266 automatic       pointer                  dcl 2-24 set ref 257* 268 268 295 295 344 346 368
                                                                                  408 409 424 424 432 432 433 433 443 463 503 516
                                                                                  554 564 587 775 816 822 859 860 882 883 891 892
                                                                                  1048 1112 1148 1164 1165 1168 1201 1201 1201 1219*
                                                                                  1228 1228 1280
rcprm_registry_util_$find_resource_record
                                000136 constant        entry                    external dcl 1276 ref 1289
rcprm_registry_util_$grab_registry
                                000134 constant        entry                    external dcl 1274 ref 1286
rcprm_registry_util_$grab_transaction_control_file
                                000132 constant        entry                    external dcl 1272 ref 1282
rcprm_registry_util_$release_registry
                                000142 constant        entry                    external dcl 1332 ref 1336
rcprm_registry_util_$release_transaction_control_file
                                000140 constant        entry                    external dcl 1330 ref 1338
rcs_ptr                         000276 automatic       pointer                  dcl 4-23 set ref 258* 342 343 396 501 1220*
rcse                                   based           structure                level 1 dcl 4-55
rcse_off                 32            based           bit(18)                  level 2 dcl 4-55 ref 343
rcse_ptr                        000300 automatic       pointer                  dcl 4-24 set ref 316 327 342* 343* 343 344 351 396*
                                                                                  398 398 401* 404 411 439 439 445 464 465 470 478
                                                                                  480 481 501* 502 504 505 505 547 554 562 571 572
                                                                                  579 580 581 585 585 587 588 590 591 613 614 615
                                                                                  616 618 620 621 622 623 642 663 672 682* 687 1316
                                                                                  1317
record_ptr                      000170 automatic       pointer                  dcl 129 set ref 1289* 1298
reg_iocb_ptr                    000172 automatic       pointer                  dcl 130 set ref 259* 1286* 1289* 1297 1336 1336*
registry_dir                    000214 automatic       char(64)                 level 2 dcl 136 set ref 1281* 1282* 1286* 1301*
registry_record_ptr      22     000214 automatic       pointer                  level 2 dcl 136 set ref 1298* 1302*
registry_switch_ptr      20     000214 automatic       pointer                  level 2 dcl 136 set ref 1297* 1302*
rel                                                    builtin function         dcl 154 ref 411 418 433 548 1196
req_info                        000200 automatic       structure                level 1 unaligned dcl 134 set ref 442 442 558 558
                                                                                  568 568 692 692 958 958 1031 1031
requestor_info                         based           structure                level 1 dcl 7-13
res_info                        000214 automatic       structure                level 1 unaligned dcl 136 set ref 442 442 558 558
                                                                                  568 568 692 692 958 958 1031 1031
reservable               35(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-59 ref 592 653
                                                                                  754
reservation_id           60            based           fixed bin(71,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 1100*
reservation_id           32            based           fixed bin(71,0)          level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 473* 1144*
reserved                 35(03)        based           bit(1)                   level 3 packed packed unaligned dcl 2-59 set ref
                                                                                  592* 595* 665
reserved_by              62            based           char(32)                 level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 1101*
reserved_by              22            based           char(32)                 level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 472* 1143*
resource_info                          based           structure                level 1 unaligned dcl 8-14
resource_mgmt_enabled
                         14(04)        based           bit(1)                   level 3 packed packed unaligned dcl 2-29 ref 554 564
                                                                                  1280
resource_name            34     000214 automatic       char(32)                 level 2 packed packed unaligned dcl 136 set ref
                                                                                  1310*
resource_type            24     000214 automatic       char(32)                 level 2 packed packed unaligned dcl 136 set ref
                                                                                  1309*
return_arg                      000542 automatic       bit(36)                  dcl 1348 set ref 1350* 1351 1352
save_device_ptr                 000174 automatic       pointer                  dcl 131 set ref 365* 379
search                    0(13)        based           bit(1)                   level 2 packed packed unaligned dcl 11-8 set ref
                                                                                  555* 567* 569* 687*
state                    24            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 538 596 603 608* 642 642
                                                                                  662 672 714 777 850 923 925 925 943* 995 1016*
                                                                                  1071 1078* 1083* 1091* 1095 1241 1241* 1246* 1248
                                                                                  1250*
state                    24            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 480* 613*
state                    36            based           fixed bin(17,0)          level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 411 411 418 466 467* 1138
                                                                                  1139* 1141
state_time               22            based           fixed bin(71,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 602* 944* 1018* 1069 1103*
                                                                                  1109 1253*
state_time               34            based           fixed bin(71,0)          level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 468* 1137*
string                                                 builtin function         dcl 154 set ref 1001* 1001
substr                                                 builtin function         dcl 154 ref 643 643 946 946 1001 1020 1020
subsystem                       000450 automatic       char(4)                  level 2 packed packed unaligned dcl 981 set ref
                                                                                  1002*
system                   35(02)        based           bit(1)                   level 3 packed packed unaligned dcl 4-55 set ref 504
                                                                                  620*
system_flag                     000111 automatic       bit(1)                   dcl 100 set ref 504* 505* 592 620 731
tape_name                       000450 automatic       structure                level 1 packed packed unaligned dcl 981 set ref
                                                                                  1001* 1001
temp_mode                       000113 automatic       bit(3)                   packed unaligned dcl 102 set ref 557* 558*
time_assigned                   000166 automatic       fixed bin(71,0)          dcl 127 set ref 1069* 1109* 1109 1110 1111* 1111
                                                                                  1115
tot_assign_time          52            based           fixed bin(71,0)          level 2 dcl 2-59 set ref 1110* 1110
tot_devices              16            based           fixed bin(17,0)          level 2 dcl 2-29 ref 409 433 860 883 891
tot_dtypes               15            based           fixed bin(17,0)          level 2 dcl 2-29 ref 409 433 860 883 892 1164
tot_volumes              17            based           fixed bin(17,0)          level 2 dcl 2-29 ref 424
trans_iocb_ptr                  000176 automatic       pointer                  dcl 132 set ref 259* 1282* 1338 1338*
unassign_state           37            based           fixed bin(17,0)          level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 466* 471 886* 1139 1140*
unassign_state           25            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 603* 610 895* 1017* 1072
                                                                                  1072 1091 1093*
unload_on_detach         14(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-29 ref 587
                                                                                  1148
unspec                                                 builtin function         dcl 154 set ref 1193* 1200* 1200
user_id                         000200 automatic       char(32)                 level 2 packed packed unaligned dcl 134 set ref
                                                                                  1312* 1316*
validation_level         12     000200 automatic       fixed bin(3,0)           level 2 dcl 134 set ref 1313* 1317*
vol_rcse_off                    000116 automatic       bit(18)                  dcl 105 set ref 308* 313 342 396
volume                   35(04)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 4-55 in procedure "rcp_control_" set ref 562*
                                                                                  571* 580* 585
volume                                 based           structure                array level 2 in structure "rcpd" dcl 2-29
                                                                                  in procedure "rcp_control_" set ref 409 433 860
                                                                                  883
volume                                 based           structure                level 1 dcl 2-101 in procedure "rcp_control_"
volume_flag                     000112 automatic       bit(1)                   dcl 101 set ref 311* 330 479*
volume_name               2            based           char(32)                 level 2 in structure "device" dcl 2-59 in procedure
                                                                                  "rcp_control_" set ref 349 357* 369 373* 379* 563
                                                                                  565* 572 581 855 861 933 941* 1076 1084* 1254*
volume_name               1            based           char(32)                 level 2 in structure "volume" dcl 2-101 in procedure
                                                                                  "rcp_control_" set ref 410 418 469* 861 1145 1149*
volume_name               2            based           char(32)                 level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 351* 398 398 404* 439* 478
                                                                                  547* 572* 581* 585*
volume_name                     000133 automatic       char(32)                 packed unaligned dcl 112 in procedure "rcp_control_"
                                                                                  set ref 349 351 355 369 379 398* 401* 404 410 413
                                                                                  469 478*
volume_off                      000117 automatic       bit(18)                  dcl 106 in procedure "rcp_control_" set ref 406*
                                                                                  411* 418 418* 424 433* 463 481 809* 814 816
volume_off               31            based           bit(18)                  level 2 in structure "rcse" dcl 4-55 in procedure
                                                                                  "rcp_control_" set ref 481*
volume_ptr                      000274 automatic       pointer                  dcl 2-27 set ref 409* 410 411 411 411 411 418 418
                                                                                  418 463* 464 465 466 466 467 468 469 470 471 472
                                                                                  473 475 816* 817 860* 861 883* 884 886 1137 1138
                                                                                  1139 1139 1140 1141 1142 1143 1144 1145 1145 1149
                                                                                  1150
vtypex                   11            based           fixed bin(17,0)          level 2 dcl 2-101 set ref 465* 1145
wakeup_buf                      000520 automatic       fixed bin(71,0)          dcl 1190 set ref 1200* 1201*
who_am_i                        000143 automatic       char(32)                 packed unaligned dcl 113 set ref 256*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 3-16
BEEP                                   internal static fixed bin(17,0)          initial dcl 13-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 13-7
CRASH_ON_CRF                           internal static fixed bin(17,0)          initial dcl 12-45
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 9-38
ENABLE_CONSOLE_SERVICE                 internal static fixed bin(17,0)          initial dcl 12-45
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 13-7
LOCK_MCA_INPUT                         internal static fixed bin(17,0)          initial dcl 12-45
MAKE_ALTERNATE_CONSOLE                 internal static fixed bin(17,0)          initial dcl 12-45
MAKE_BOOTLOAD_CONSOLE                  internal static fixed bin(17,0)          initial dcl 12-45
MAKE_INOP_DEVICE                       internal static fixed bin(17,0)          initial dcl 12-45
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 9-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 3-16
NOP                                    internal static fixed bin(17,0)          initial dcl 12-45
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 9-22
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
No_authentication                      internal static fixed bin(17,0)          initial dcl 3-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 3-16
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 9-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 9-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 9-34
RESET_CONSOLE                          internal static fixed bin(17,0)          initial dcl 12-45
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RUN_ON_CRF                             internal static fixed bin(17,0)          initial dcl 12-45
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SEND_MC_IO                             internal static fixed bin(17,0)          initial dcl 12-45
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 9-35
SUSPEND_CONSOLE_SERVICE                internal static fixed bin(17,0)          initial dcl 12-45
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 13-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 9-37
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 13-7
UNLOCK_MCA_INPUT                       internal static fixed bin(17,0)          initial dcl 12-45
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
authentication_level_names             internal static char(12)                 initial array packed unaligned dcl 3-21
based_rcp_id                           based           structure                level 1 dcl 4-26
lock_info_ptr                          automatic       pointer                  dcl 4-22
rcs                                    based           structure                level 1 dcl 4-30
requestor_info_ptr                     automatic       pointer                  dcl 7-11
resource_info_ptr                      automatic       pointer                  dcl 8-12
rifp                                   automatic       pointer                  dcl 3-6

NAMES DECLARED BY EXPLICIT CONTEXT.
ACCOUNT_ATTACH                  004436 constant        entry                    internal dcl 1040 ref 284
ACCOUNT_WAKEUP                  005031 constant        entry                    internal dcl 1179 ref 610 1050 1097
ADD_DEVICE                      004107 constant        entry                    internal dcl 971 ref 282
ADD_RETURN                      004340 constant        label                    dcl 1023 ref 989 995 1008 1013
ASSIGN                          001116 constant        entry                    internal dcl 298 ref 274
ASSIGN_DEVICE                   001711 constant        entry                    internal dcl 485 ref 326
ASSIGN_VOLUME                   001275 constant        entry                    internal dcl 390 ref 315
CHECK_LIMITS                    003072 constant        entry                    internal

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
