	COMPILATION LISTING OF SEGMENT salv_directory
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1028.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       14 salv_directory:
       15      proc (arg_info_p, message, arg_old_dir_p, arg_old_dir_len, arg_code);
       16 
       17 /* One directory is found and salvaged.
       18*   *
       19*   * salv_directory		hphcs_ gate entry.  Used to invoke salvager from ring 4.
       20*   *
       21*   * ring0_salvage		regular call from salvager for the ring 1 salv command.
       22*   *
       23*   * online_salvage		Online salvager call.
       24**/
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(77-07-01,Barr), approve(), audit(), install():
       28*      Written by S.E. Barr.
       29*  2) change(79-11-01,Grady), approve(), audit(), install():
       30*      Modified by Mike Grady to add cleanup handler.
       31*  3) change(81-11-12,Sibert), approve(), audit(), install():
       32*      Modified by W. Olin Sibert to set the dir.uid properly to avoid an
       33*      online salvage when locking.
       34*  4) change(81-12-01,Hornig), approve(), audit(), install():
       35*      Modified by C. Hornig for 205K directories.
       36*  5) change(82-02-01,Margulies), approve(), audit(), install():
       37*      Modified by BIM for new salv dir locking.
       38*  6) change(82-03-01,Bongiovanni), approve(), audit(), install():
       39*      Modified by J. Bongiovanni to eliminate use of FSDCT.
       40*  7) change(82-03-01,Margulies), approve(), audit(), install():
       41*      Modified for new vtoc_attributes info.
       42*  8) change(84-07-01,Loepere), approve(), audit(), install():
       43*      Modified by Keith Loepere to use the new dc_find.
       44*  9) change(84-11-01,Loepere), approve(), audit(), install():
       45*      Modified to clean up a little.
       46* 10) change(84-12-05,EJSharpe), approve(), audit(), install():
       47*      Modified to use access_audit_ instead of protection_audit_.
       48* 11) change(86-05-23,Lippard), approve(86-06-17,MCR7433),
       49*     audit(86-06-26,Hartogs), install(86-07-11,MR12.0-1091):
       50*      Modified by Jim Lippard to establish cleanup handler before call to
       51*      hold_segs.
       52* 12) change(86-11-11,Lippard), approve(86-12-08,MCR7590),
       53*     audit(87-04-16,Dickson), install(87-04-28,MR12.1-1028):
       54*      Modified to copy caller name correctly for printing error messages.
       55*                                                   END HISTORY COMMENTS */
       56 
       57 
       58 /* Parameters */
       59 
       60 dcl  arg_branch_p ptr;				/* ONLINE: ptr to branch for directory. */
       61 dcl  arg_code fixed bin (35);				/* 0 = salvage completed. */
       62 dcl  arg_dp ptr;					/* ONLINE: ptr to directory. */
       63 dcl  arg_info_p ptr;				/* ptr to argument structure */
       64 dcl  arg_old_dir_len fixed bin;			/* RING_4: Number of words in dump segment. */
       65 dcl  arg_old_dir_p ptr;				/* RING_4: Buffer for copy of directory. */
       66 dcl  message char (*) var;				/* RING_4: Error message segment. */
       67 
       68 /* Automatic */
       69 
       70 dcl  astep (4) ptr;					/* RING_4: ptrs for segments that were entry held. */
       71 dcl  branch_p ptr;					/* ptr to branch for directory. */
       72 dcl  caller fixed bin;				/* Identifies the entry point */
       73 dcl  child_dirmod bit (1) aligned;			/* changed this dir */
       74 dcl  code fixed bin (35);
       75 dcl  1 copy_args aligned like salv_args;		/* Copy of args for ring 4. */
       76 dcl  dir_uid bit (36) aligned;			/* The UID in the vtoce when the dir was made known */
       77 dcl  1 event_flags aligned like audit_event_flags;	/* specifics of the operation */
       78 dcl  info_p ptr;					/* Copy of argument structure ptr. */
       79 dcl  new_dir_pages fixed bin;				/* Number of pages in rebuilt directory. */
       80 dcl  parent_dirmod bit (1) aligned;			/* changed containing dir */
       81 dcl  root bit (1) aligned;				/* ON, if root is being salaged. */
       82 dcl  1 root_entry aligned like entry;			/* Dummy branch for the root. */
       83 dcl  set_security_oosw bit (1) aligned;			/* ON, if the security_oosw in branch should be set. */
       84 dcl  should_dump bit (1) aligned;			/* ON, if the directory has not yet been dumped. */
       85 dcl  unlock_dir bit (1) aligned;			/* ON, if directory should be unlocked. */
       86 dcl  unlock_parent bit (1) aligned;			/* ON, if parent directory should be unlocked. */
       87 
       88 /* Based */
       89 
       90 dcl  1 dir_branch aligned like entry based (branch_p);
       91 dcl  1 info aligned like salv_args based (info_p);
       92 
       93 /* Constants */
       94 
       95 dcl  ME char (14) int static options (constant) init ("salv_directory");
       96 dcl  MAX_MESSAGE_SIZE fixed bin (18) int static options (constant) init (16 * 1024);
       97 dcl  NEW_LINE char (1) int static options (constant) init ("
       98 ");
       99 dcl  ONLINE fixed bin int static options (constant) init (3);
      100 dcl  RING_0 fixed bin int static options (constant) init (1);
      101 dcl  RING_4 fixed bin int static options (constant) init (2);
      102 dcl  packed_null ptr unal int static options (constant) init (null ());
      103 
      104 /* External */
      105 
      106 dcl  access_operations_$fs_obj_set_soos bit (36) aligned external;
      107 dcl  error_table_$ external static;
      108 dcl  error_table_$no_terminal_quota fixed bin (35) external;
      109 dcl  error_table_$mylock fixed bin (35) external static;
      110 dcl  pds$processid bit (36) aligned external static;
      111 dcl  pvt$root_lvid bit (36) aligned external;
      112 dcl  pvt$root_pvid bit (36) aligned external;
      113 dcl  pvt$root_vtocx fixed bin (17) external;
      114 dcl  sys_info$default_dir_max_length fixed bin (19) external;
      115 
      116 /* Entries */
      117 
      118 dcl  access_audit_$log_obj_class entry options (variable);
      119 dcl  arg_count_ entry returns (fixed bin);
      120 dcl  arg_list_ptr_ entry returns (pointer);
      121 dcl  dir_dump entry (ptr, fixed bin);
      122 dcl  formline_ entry (fixed bin, fixed bin, ptr, fixed bin, fixed bin (35));
      123 dcl  grab_aste$prewithdraw entry (ptr, fixed bin (18), fixed bin (35)) returns (ptr);
      124 dcl  grab_aste$release_prewithdraw entry (ptr);
      125 dcl  level$get entry () returns (fixed bin);
      126 dcl  lock$dir_unlock entry (pointer);
      127 dcl  lock$dir_unlock_given_uid entry (bit (36) aligned);
      128 dcl  salv_dir_checker_ entry (ptr, ptr, entry, bit (1) aligned, fixed bin);
      129 dcl  salv_check_vtoce_ entry (ptr, char (*), bit (1) aligned, entry);
      130 dcl  salv_err_msg$path entry options (variable);
      131 dcl  sum$dirmod entry (pointer);
      132 dcl  sum$getbranch_root_my entry (ptr, bit (1) aligned, ptr, fixed bin (35));
      133 dcl  syserr entry options (variable);
      134 dcl  truncate_vtoce entry (ptr, fixed bin, fixed bin (35));
      135 dcl  vtoc_attributes$get_info entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin (35));
      136 dcl  vtoc_attributes$set_max_lth
      137 	entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (9), bit (1) aligned, fixed bin (35));
      138 
      139 /* Misc */
      140 
      141 dcl  cleanup condition;
      142 
      143 dcl  (addr, baseno, divide, hbound, length, min, null, ptr, rel, rtrim, string, substr, unspec) builtin;
      144 
      145 /* Copy arguments and entry hold segments. */
      146 
      147 	call setup;
      148 	caller = RING_4;
      149 	arg_old_dir_len = 0;
      150 	copy_args = arg_info_p -> salv_args;
      151 	info_p = addr (copy_args);
      152 
      153 	goto START;
      154 
      155 
      156 ring0_salvage:
      157      entry (arg_info_p, arg_code);
      158 
      159 	call setup;
      160 	caller = RING_0;
      161 	info_p = arg_info_p;
      162 	goto START;
      163 
      164 
      165 /* ONLINE:  Already have pointers to the branch and the directory. */
      166 /*	  and the appropriate locks are locked */
      167 
      168 online_salvage:
      169      entry (arg_info_p, arg_branch_p, arg_dp, arg_code);
      170 
      171 	call setup;
      172 	info_p = arg_info_p;
      173 	branch_p = arg_branch_p;
      174 	dp = arg_dp;
      175 	caller = ONLINE;
      176 
      177 
      178 START:
      179 	arg_code = 0;
      180 
      181 
      182 /* We do not want to allow verify_lock to salvage (again) the directory */
      183 /* in which the salvager has just taken a fault. This can cause locking */
      184 /* difficulties, and is generally not very useful. Since salvager.pl1 */
      185 /* has an any_other handler that hand-calls verify_lock, we have to */
      186 /* always have a cleanup handler to unlock our locks, so that verify_lock */
      187 /* will not find them. salvager makes an explicit call to the unwinder */
      188 /* to insure that our cleanup handler runs. */
      189 
      190 	unlock_dir, unlock_parent = "0"b;
      191 
      192 	on cleanup call clean_up;
      193 
      194 	if caller = RING_4 then do;
      195 	     call hold_segs (code);
      196 	     if code ^= 0 then do;
      197 		arg_code = code;
      198 		call rel_segs;
      199 		return;
      200 		end;
      201 	     end;
      202 
      203 	call get_dir (code);
      204 	if code = 0 then do;
      205 
      206 /* Fill information for this directory: master_dir_uid, tree depth, branch_ptr. */
      207 	     should_dump = info.dump;
      208 
      209 	     if dir_branch.master_dir
      210 	     then info.master_dir_uid = dir_branch.uid;
      211 	     else info.master_dir_uid = ptr (branch_p, 0) -> dir.master_dir_uid;
      212 
      213 	     if root
      214 	     then info.tree_depth = 0;
      215 	     else info.tree_depth = ptr (branch_p, 0) -> dir.tree_depth + 1;
      216 
      217 	     info.branch_ptr = branch_p;
      218 
      219 /* current length and quota */
      220 
      221 	     call vtoc_attributes$get_info ((dir_branch.uid), (dir_branch.pvid), (dir_branch.vtocx), addr (sc_info),
      222 		code);
      223 	     if code = 0 then do;
      224 		info.current_length = divide (sc_info.csl + 1023, 1024, 17, 0);
      225 		if sc_info.msl ^= sys_info$default_dir_max_length then do;
      226 		     call vtoc_attributes$set_max_lth ((dir_branch.uid), (dir_branch.pvid), (dir_branch.vtocx),
      227 			divide (sys_info$default_dir_max_length, 1024, 9, 0), "0"b, code);
      228 		     if code = 0
      229 		     then call print (SALV_LOG, ME, "Changed max length in VTOCE from ^d to ^d.", sc_info.msl,
      230 			     sys_info$default_dir_max_length);
      231 		     else call print_code (SALV_LOG, ME, code, "Changing max length in VTOCE.");
      232 		     end;
      233 
      234 		call salv_dir_checker_ (dp, info_p, print, set_security_oosw, new_dir_pages);
      235 
      236 /* If the directory was rebuilt (new_dir_pages > 0), then print error message and truncate the directory. */
      237 		if new_dir_pages > 0 then do;
      238 		     child_dirmod = "1"b;
      239 
      240 		     if new_dir_pages < info.current_length then do;
      241 			call truncate_vtoce (branch_p, new_dir_pages, code);
      242 			if code ^= 0
      243 			then call print_code (SALV_ANNOUNCE, ME, code, "truncate_vtoce to length ^d failed.",
      244 				new_dir_pages);
      245 			code = 0;
      246 			end;
      247 		     end;
      248 		call check_upgraded_dir;
      249 		if set_security_oosw then do;
      250 		     dir_branch.security_oosw = "1"b;
      251 		     parent_dirmod = "1"b;
      252 		     end;
      253 
      254 		if info.check_vtoce
      255 		then call salv_check_vtoce_ (dp, (info.pathname), (info.delete_connection_failure), print_code);
      256 						/* Call protection audit for any branches that are security out-of-service. */
      257 
      258 		do ep = ptr (dp, dir.entryfrp) repeat ptr (dp, entry.efrp) while (rel (ep));
      259 
      260 		     if entry.bs
      261 		     then if entry.security_oosw then do;
      262 			     call print (SALV_LOG, ME,
      263 				"Branch is security out-of-service: " || addr (entry.primary_name) -> names.name);
      264 			     string(event_flags) = ""b;
      265 			     event_flags.special_op = "1"b;
      266 			     event_flags.grant = "1"b; /* we're not doing anything but auditing */
      267 			     if caller = RING_4
      268 			     then event_flags.priv_op = "1"b;
      269 			     call access_audit_$log_obj_class ("salv_directory", level$get(),
      270 				string(event_flags), access_operations_$fs_obj_set_soos,
      271 				entry.access_class, target (info.pathname,
      272 				(addr(entry.primary_name)->names.name)), 0, null(), 0,
      273 				"switch found already on");
      274 
      275 			     end;
      276 
      277 		end;
      278 		end;
      279 	     end;
      280 	call clean_up;
      281 
      282 	if code ^= 0 then do;			/* vtoc_attributes$get_info failed */
      283 	     call print_code (SALV_ANNOUNCE, ME, code, "Could not read VTOCE attributes.");
      284 	     arg_code = code;
      285 	     end;
      286 
      287 	return;
      288 
      289 /* AIM - Upgraded directories must have non-zero quota.  If such a directory is found, it will be
      290*   set security out-of-service */
      291 check_upgraded_dir:
      292      proc;
      293 
      294 dcl  1 quota_info aligned like quota_cell defined (sc_info.qcell (0));
      295 
      296 	if root then return;
      297 	if ptr (branch_p, 0) -> dir.access_class = dir.access_class then return;
      298 	if quota_info.quota = 0 then do;
      299 	     call print (SALV_ANNOUNCE, ME, "Upgraded dir set security out-of-service due to no quota.");
      300 	     string(event_flags) = ""b;
      301 	     event_flags.special_op = "1"b;
      302 	     event_flags.grant = "1"b;
      303 	     if caller = RING_4
      304 	     then event_flags.priv_op = "1"b;
      305 	     call access_audit_$log_obj_class ("salv_directory", level$get(),
      306 		string(event_flags), access_operations_$fs_obj_set_soos, dir.access_class,
      307 		info.pathname, error_table_$no_terminal_quota, null(), 0);
      308 	     set_security_oosw = "1"b;
      309 	     end;
      310 
      311      end check_upgraded_dir;
      312 
      313 get_dir:
      314      proc (code);
      315 
      316 dcl  code fixed bin (35) parameter;
      317 
      318 	root = (info.pathname = ">");
      319 	code = 0;
      320 
      321 
      322 /* Directory and parent are already locked in the online case. */
      323 
      324 	if caller = ONLINE then do;
      325 	     if root then call setup_root_branch;
      326 	     return;
      327 	     end;
      328 
      329 /* Find and lock directory.  If the directory is out-of-service, salvage anyway. */
      330 
      331 	call dc_find$dir_salvage (info.pathname, dir_uid, dp, code);
      332 	if code ^= 0 then return;
      333 	unlock_dir = "1"b;
      334 
      335 	dir.modify = pds$processid;
      336 
      337 /* Lock the parent directory and get the branch.  The root needs a phony branch. */
      338 
      339 	if root
      340 	then call setup_root_branch;
      341 	else do;
      342 	     call sum$getbranch_root_my (dp, "1"b, branch_p, code);
      343 	     if code = 0
      344 	     then unlock_parent = "1"b;
      345 	     else if code ^= error_table_$mylock then return;
      346 	     end;
      347 
      348 	return;
      349 
      350      end get_dir;
      351 
      352 hold_segs:
      353      proc (code);
      354 
      355 dcl  code fixed bin (35) parameter;
      356 
      357 	astep (*) = null;
      358 
      359 /* Message segment. */
      360 	astep (1) = grab_aste$prewithdraw (addr (message), MAX_MESSAGE_SIZE, code);
      361 	if code ^= 0 then return;
      362 
      363 /* Copy of directory for the case of a dump */
      364 	if info.dump then do;
      365 	     astep (2) = grab_aste$prewithdraw (arg_old_dir_p, 255 * 1024, code);
      366 	     if code ^= 0 then return;
      367 	     end;
      368 
      369 /* Storage image of the directory is 1/4th of the size of the directory. */
      370 
      371 	astep (3) = grab_aste$prewithdraw (info.temp2_ptr, 64 * 1024, code);
      372 	if code ^= 0 then return;
      373 
      374 /* Rebuilt directory. */
      375 
      376 	astep (4) = grab_aste$prewithdraw (info.temp1_ptr, 255 * 1024, code);
      377 	return;
      378 
      379      end hold_segs;
      380 
      381 clean_up:
      382      proc;
      383 
      384 /* On non-RING_0 salvages we could leave it to verify_lock to */
      385 /* clean things up, but that would produce salvages of parent dirs. */
      386 
      387 	if dp ^= null then dir.modify = "0"b;
      388 
      389 	if child_dirmod
      390 	then call sum$dirmod (dp);
      391 	else if parent_dirmod then call sum$dirmod (ptr (branch_p, 0));
      392 
      393 	if unlock_dir then call lock$dir_unlock_given_uid (dir_uid);
      394 	if unlock_parent then call lock$dir_unlock (ptr (branch_p, 0));
      395 	if dp ^= null then call dc_find$finished (dp, "0"b);
      396 
      397 	if caller = RING_4 then call rel_segs;
      398 
      399      end clean_up;
      400 
      401 
      402 
      403 rel_segs:
      404      proc;
      405 
      406 dcl  i fixed bin;
      407 
      408 	do i = 1 to hbound (astep, 1);
      409 	     if astep (i) ^= null then call grab_aste$release_prewithdraw (astep (i));
      410 	end;
      411 
      412      end rel_segs;
      413 
      414 print:
      415      procedure options (variable);
      416 
      417 
      418 dcl  arg_list_arg_count fixed bin;
      419 dcl  arg_list_ptr pointer;
      420 dcl  caller_name char (32);
      421 dcl  copy_len fixed bin;
      422 dcl  have_code bit (1) aligned;			/* ON, if non-zero code was specified with call. */
      423 dcl  line char (256);				/* Complete output line. */
      424 dcl  line_len fixed bin;				/* Number of characters for output */
      425 dcl  msg_len fixed bin;				/* Number of characters in error_table_message. */
      426 dcl  msg_p ptr unal;				/* ptr to error_table_ message structure. */
      427 dcl  pic pic "99";
      428 dcl  severity fixed bin;				/* copy of severity level. */
      429 dcl  start fixed bin;				/* index of 1st arg for message. */
      430 dcl  string char (253) defined (line) pos (3);		/* Message from formline. */
      431 
      432 dcl  based_code fixed bin (35) based;
      433 dcl  based_severity fixed bin based;
      434 dcl  based_caller_name char (32) based;
      435 dcl  copy (copy_len) bit (36) based;
      436 dcl  1 et aligned based (msg_p),			/* An error_table_ message */
      437        2 len fixed bin (8) unal,			/* Length of the message */
      438        2 msg char (et.len) unal;			/* The message */
      439 
      440 	have_code = "0"b;
      441 	start = 3;
      442 	goto FORMAT;
      443 
      444 print_code:
      445      entry options (variable);
      446 
      447 	have_code = "1"b;				/* can correct later if code = 0 */
      448 	start = 4;
      449 
      450 FORMAT:						/* Format line:  <blank> <blank> <message> <new_line>    */
      451 	arg_list_ptr = arg_list_ptr_ ();
      452 	arg_list_arg_count = arg_count_ ();
      453 
      454 	if arg_list_arg_count < 3 then call syserr (CRASH, "salv_directory: Invalid call to error message printer.");
      455 
      456 	severity = arg_list_ptr -> arg_list_with_envptr.arg_ptrs (1) -> based_severity;
      457 	caller_name = substr (arg_list_ptr -> arg_list_with_envptr.arg_ptrs (2) -> based_caller_name,
      458 	     1, arg_list_ptr -> arg_list_with_envptr.desc_ptrs (2) -> arg_descriptor.size);
      459 	if have_code
      460 	then code = arg_list_ptr -> arg_list_with_envptr.arg_ptrs (3) -> based_code;
      461 	else code = 0;
      462 	if code = 0 then have_code = "0"b;		/* dont bother to print null message */
      463 
      464 	line_len = length (string);
      465 	call formline_ (start, start + 1, addr (string), line_len, (0));
      466 	line_len = length (rtrim (substr (string, 1, line_len)));
      467 	substr (line, 1, 2) = "";
      468 	line_len = line_len + 2;
      469 
      470 /* Add error_table_ message. Interpret code as a packed ptr that points to the error message. */
      471 
      472 	if have_code then do;
      473 	     unspec (msg_p) = unspec (code);
      474 	     if baseno (msg_p) = baseno (packed_null) then do;
      475 		msg_p = ptr (addr (error_table_$), rel (msg_p));
      476 		msg_len = min (length (line) - line_len, et.len + 1);
      477 		if msg_len > 0 then do;
      478 		     substr (line, line_len + 1, msg_len) = " " || et.msg;
      479 		     line_len = line_len + msg_len;
      480 		     end;
      481 		end;
      482 	     end;
      483 
      484 
      485 /* Put message in ring 4 segment or call hardcore print routine */
      486 
      487 	if caller = RING_4 then do;
      488 	     pic = severity;
      489 	     if length (message) + line_len < MAX_MESSAGE_SIZE then do;
      490 		message = message || pic;
      491 		message = message || substr (line, 1, line_len) || NEW_LINE;
      492 		if (severity = SALV_DEBUG) & should_dump then do;
      493 		     copy_len, arg_old_dir_len = info.current_length * 1024;
      494 		     arg_old_dir_p -> copy = dp -> copy;
      495 		     should_dump = "0"b;
      496 		     end;
      497 		end;
      498 	     end;
      499 	else do;
      500 	     call salv_err_msg$path (severity, info.pathname, rtrim (caller_name) || ": " || substr (line, 1, line_len));
      501 	     if (severity = SALV_DEBUG) & should_dump then do;
      502 		call dir_dump (dp, info.current_length);
      503 		should_dump = "0"b;
      504 		end;
      505 	     end;
      506 
      507      end print;
      508 
      509 setup_root_branch:
      510      procedure;
      511 
      512 	branch_p = addr (root_entry);
      513 	unspec (root_entry) = "0"b;
      514 	root_entry.uid, root_entry.owner = (36)"1"b;
      515 	root_entry.pvid = pvt$root_pvid;
      516 	root_entry.sons_lvid = pvt$root_lvid;
      517 	root_entry.vtocx = pvt$root_vtocx;
      518 	root_entry.dirsw = "1"b;
      519 	root_entry.master_dir = "1"b;
      520 	root_entry.name_frp = rel (addr (root_entry.primary_name));
      521 	addr (root_entry.primary_name) -> names.name = ">";
      522 	root_entry.per_process_sw = "0"b;
      523 	root_entry.bs = "1"b;
      524 	root_entry.access_class = "0"b;
      525 
      526      end setup_root_branch;
      527 
      528 setup:
      529      procedure;
      530 
      531 /* Initialize here for benefit of handlers */
      532 
      533 	dp, branch_p = null ();
      534 	unlock_dir, unlock_parent = "0"b;
      535 	parent_dirmod, child_dirmod = "0"b;
      536      end setup;
      537 
      538 target: proc (dir, ent) returns (char (*));
      539 
      540 dcl	dir	char (*) parameter;
      541 dcl	ent	char (*) parameter;
      542 
      543 	if dir = ">"
      544 	then return (">"||ent);
      545 	else return (rtrim(dir)||">"||ent);
      546 
      547      end target;
      548 
  1     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  1     2*
  1     3*   James R. Davis 1 Mar 79 */
  1     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  1     5 
  1     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  1     7 	     2 flag	      bit (1) unal,
  1     8 	     2 type	      fixed bin (6) unsigned unal,
  1     9 	     2 packed	      bit (1) unal,
  1    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    11 	     2 size	      fixed bin (24) unsigned unal;
  1    12 
  1    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    14 	     2 flag	      bit (1) unal,
  1    15 	     2 type	      fixed bin (6) unsigned unal,
  1    16 	     2 packed	      bit (1) unal,
  1    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    18 	     2 scale	      fixed bin (11) unal,
  1    19 	     2 precision	      fixed bin (12) unsigned unal;
  1    20 
  1    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  1    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  1    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  1    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  1    26 	     2 size	      bit (24) unal,
  1    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  1    28 	       3 low	      fixed bin (35),
  1    29 	       3 high	      fixed bin (35),
  1    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  1    31 	     2 real_type	      fixed bin (18) unsigned unal,
  1    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  1    33 
  1    34      dcl	   arg_descriptor_ptr     ptr;
  1    35 
  1    36      dcl	   extended_arg_type      fixed bin init (58);
  1    37 
  1    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      549 
      550 
  2     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  2     2*
  2     3*   James R. Davis 10 May 79 */
  2     4 
  2     5 
  2     6      
  2     7 /****^  HISTORY COMMENTS:
  2     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  2     9*     audit(86-07-15,Schroth):
  2    10*     added command_name_arglist declaration to allow the storage of the
  2    11*     command name given to the command processor
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14      dcl	   1 arg_list	      aligned based,
  2    15 	     2 header,
  2    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  2    17 	       3 pad1	      bit (1) unal,
  2    18 	       3 call_type	      fixed bin (18) unsigned unal,
  2    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  2    20 	       3 pad2	      bit (19) unal,
  2    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  2    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  2    23 
  2    24 
  2    25      dcl	   1 command_name_arglist	      aligned based,
  2    26 	     2 header,
  2    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  2    28 	       3 pad1	      bit (1) unal,
  2    29 	       3 call_type	      fixed bin (18) unsigned unal,
  2    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  2    31 	       3 mbz              bit(1) unal,
  2    32                  3 has_command_name bit(1) unal,
  2    33 	       3 pad2	      bit (17) unal,
  2    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  2    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  2    36 	     2 name,
  2    37                  3 command_name_ptr         pointer,
  2    38                  3 command_name_length      fixed bin (21);
  2    39 	
  2    40 
  2    41 
  2    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  2    43 	     2 header,
  2    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  2    45 	       3 pad1	      bit (1) unal,
  2    46 	       3 call_type	      fixed bin (18) unsigned unal,
  2    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  2    48 	       3 pad2	      bit (19) unal,
  2    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  2    50 	     2 envptr	      ptr,
  2    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  2    52 
  2    53 
  2    54      dcl	   (
  2    55 	   Quick_call_type	      init (0),
  2    56 	   Interseg_call_type     init (4),
  2    57 	   Envptr_supplied_call_type
  2    58 			      init (8)
  2    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  2    60 
  2    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  2    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  2    63*   an argument list of the proper size in the user's stack
  2    64*
  2    65**/
  2    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      551 
      552 
  3     1 /* BEGIN include file dc_find_dcls.incl.pl1 */
  3     2 
  3     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  3     4 /* Added a few more, October 1984. */
  3     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  3     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  3     7 
  3     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  3     9 
  3    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  3    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  3    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  3    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  3    14 
  3    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  3    18 
  3    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  3    20 
  3    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  3    22 
  3    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  3    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  3    25 
  3    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  3    27 
  3    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  3    29 
  3    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    32 
  3    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  3    34 
  3    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  3    36 
  3    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  3    38 
  3    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    41 
  3    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    44 
  3    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    47 
  3    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    52 
  3    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  3    58 
  3    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  3    60 
  3    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  3    62 
  3    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  3    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  3    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  3    66 
  3    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  3    68 
  3    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  3    70 
  3    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    72 
  3    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    74 
  3    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  3    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    82 
  3    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    87 
  3    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  3    90 
  3    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  3    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  3    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  3    94 
  3    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    96 
  3    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  3    98 
  3    99 /* END include file dc_find_dcls.incl.pl1 */
      553 
      554 
  4     1 /*     BEGIN INCLUDE FILE ... dir_allocation_area.incl.pl1 ... last modified December 1973 */
  4     2 
  4     3 dcl  areap ptr;
  4     4 
  4     5 dcl 1 area based (areap) aligned,
  4     6     2 nsizes fixed bin (18),				/* Number of types. */
  4     7     2 lu fixed bin (18),				/* Next available word in area. */
  4     8     2 lw fixed bin (18),				/* Last usable word. */
  4     9     2 array (100) aligned,				/* Array of types. */
  4    10       3 fptr bit (18) unaligned,			/* Free pointer for this size. */
  4    11       3 size fixed bin (17) unaligned;			/* Size. */
  4    12 
  4    13 /*     END INCLUDE FILE ... dir_allocation_area.incl.pl1 */
      555 
      556 
  5     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  5     2 
  5     3 
  5     4 /* Template for an entry. Length = 38 words */
  5     5 
  5     6 dcl  ep ptr;
  5     7 
  5     8 dcl 1 entry based (ep) aligned,
  5     9 
  5    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  5    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  5    12 
  5    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  5    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  5    15 
  5    16     2 uid bit (36),					/* unique id of entry */
  5    17 
  5    18     2 dtem bit (36),				/* date-time entry modified */
  5    19 
  5    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  5    21     2 pad0 bit (17),
  5    22     2 nnames fixed bin (17),				/* number of names for this entry */
  5    23 
  5    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  5    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  5    26 
  5    27     2 author,					/* user who created branch */
  5    28       3 pers_rp bit (18),				/* name of user who created branch */
  5    29       3 proj_rp bit (18),				/* project of user who created branch */
  5    30 
  5    31       3 tag char (1),				/* tag of user who created branch */
  5    32       3 pad1 char (3),
  5    33 
  5    34     2 primary_name bit (504),				/* first name on name list */
  5    35 
  5    36     2 dtd bit (36),					/* date time dumped */
  5    37 
  5    38     2 pad2 bit (36),
  5    39 
  5    40 
  5    41 /* the declarations below are for branch only */
  5    42 
  5    43 
  5    44     2 pvid bit (36),				/* physical volume id */
  5    45 
  5    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  5    47     2 pad3 bit (18),
  5    48 
  5    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  5    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  5    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  5    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  5    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  5    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  5    55     2 audit_flag bit (1),				/* segment must be audited for security */
  5    56     2 security_oosw bit (1),				/* security out of service switch */
  5    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  5    58     2 master_dir bit (1),				/* TRUE for master directory */
  5    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  5    60     2 pad4 bit (11),
  5    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  5    62 
  5    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  5    64 
  5    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  5    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  5    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  5    68 
  5    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  5    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  5    71 
  5    72     2 bc_author,					/* user who last set the bit count */
  5    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  5    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  5    75 
  5    76       3 tag char (1),				/* tag of user who set the bit count */
  5    77       3 pad5 bit (2),
  5    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  5    79 
  5    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  5    81 
  5    82     2 pad6 bit (36),
  5    83 
  5    84     2 checksum bit (36),				/* checksum from dtd */
  5    85 
  5    86     2 owner bit (36);				/* uid of containing directory */
  5    87 
  5    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      557 
      558 
  6     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  6     2 /* Modified 8/74 for NSS */
  6     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  6     4 /* Modified 3/82 BIM for change pclock */
  6     5 /* format: style3 */
  6     6 
  6     7 /* Template for the directory header. Length = 64 words. */
  6     8 
  6     9 dcl  dp ptr;
  6    10 
  6    11 dcl 1 dir based (dp) aligned,
  6    12 
  6    13    2 modify bit (36),				/* Process ID of last modifier */
  6    14    2 type bit (18) unaligned,			/* type of object = dir header */
  6    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  6    16     2 dtc (3),					/* date-time checked by salvager array */
  6    17       3 date bit (36),				/* the date */
  6    18       3 error bit (36),				/* what errors were discovered */
  6    19 
  6    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  6    21 
  6    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  6    23 
  6    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  6    25 
  6    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  6    27 
  6    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  6    29     2 version_number fixed bin (17),			/* version number of header */
  6    30 
  6    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  6    32     2 pad2 bit (18),
  6    33 
  6    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  6    35     2 pad3 bit (18),
  6    36 
  6    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  6    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  6    39 
  6    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  6    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  6    42 
  6    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  6    44     2 dir_count fixed bin (17),			/* number of directory branches */
  6    45 
  6    46     2 lcount fixed bin (17),				/* number of links */
  6    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  6    48 
  6    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  6    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  6    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  6    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  6    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  6    54     2 pad4 bit (14),
  6    55 
  6    56     2 iacl_count (0:7),
  6    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  6    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  6    59 
  6    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  6    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  6    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  6    63 
  6    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  6    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  6    66 
  6    67     2 htsize fixed bin (17),				/* size of hash table */
  6    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  6    69 
  6    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  6    71     2 pad6 fixed bin (17),
  6    72 
  6    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  6    74     2 pad7 bit (18)) unaligned,
  6    75 
  6    76     2 dts bit (36),					/* date-time directory last salvaged */
  6    77 
  6    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  6    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  6    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  6    81     2 checksum bit (36),				/* checksummed from uid on */
  6    82     2 owner bit (36);				/* uid of parent dir */
  6    83 
  6    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  6    85 
  6    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      559 
      560 
  7     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  7     2 
  7     3 /* Template for names of branches or links. Length = 14 words. */
  7     4 
  7     5 dcl np ptr;
  7     6 
  7     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  7     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  7     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  7    10 
  7    11     2 type bit (18) unaligned,			/* type = dir name */
  7    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  7    13 
  7    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  7    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  7    16 
  7    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  7    18     2 pad3 bit (18) unal,
  7    19 
  7    20     2 name char(32) aligned,
  7    21 
  7    22     2 checksum bit (36),				/* checksum from entry_rp */
  7    23 
  7    24     2 owner bit (36);				/* uid of entry */
  7    25 
  7    26 
  7    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      561 
      562 
  8     1 /* BEGIN INCLUDE FILE ... quota_cell.incl.pl1 ... February 1982 */
  8     2 
  8     3 dcl 1 quota_cell based (qcp) aligned,			/* Argument used by vtoc_attributes$(get set)_quota */
  8     4     2 quota fixed bin (35),				/* Record quota */
  8     5     2 used fixed bin (35),				/* Current use */
  8     6     2 received fixed bin (35),			/* Quota moved down */
  8     7     2 tup bit (36),					/* Clock time of update */
  8     8     2 trp fixed bin (71),				/* Time-page-product, in page-seconds */
  8     9     2 pad fixed bin,
  8    10     2 terminal_quota_sw bit (1);			/* TRUE if terminal quota */
  8    11 
  8    12 dcl  qcp ptr;
  8    13 
  8    14 /* END INCLUDE FILE ... quota_cell */
      563 
      564 
  9     1 /* BEGIN INCLUDE FILE . . . salv_args */
  9     2 /* Keith Loepere made pathname unal November 1984. */
  9     3 
  9     4 dcl 1 salv_args aligned based,
  9     5     2 temp1_ptr ptr,				/* ptr to temp segment */
  9     6     2 temp2_ptr ptr,				/* ptr to temp segment */
  9     7     2 salv_time bit (36) aligned,			/* Highest valid date/time  */
  9     8     2 options aligned,
  9     9       3 force_rebuild bit (1) unal,			/* ON, if should rebuild directory */
  9    10       3 print_trace bit (1) unal,			/* ON, if debugging trace information should be printed. */
  9    11       3 correct_oosw bit (1) unal,			/* ON, if directory's out-of-service switch should be reset */
  9    12       3 check_vtoce bit (1) unal,			/* ON, if VTOC entries of all branches should be checked. */
  9    13       3 dump bit (1) unal,				/* ON, if should dump directory on error condition */
  9    14       3 compact bit (1) unal,				/* ON, to force rebuild if one pages can be recovered. */
  9    15       3 delete_connection_failure bit (1) unal,		/* ON, to delete branches that have no VTOC entries */
  9    16       3 pad bit (29),
  9    17     2 branch_ptr ptr,				/* ptr to branch for directory */
  9    18     2 current_length fixed bin,			/* number of pages in directory */
  9    19     2 pathname char (168) unal,			/* pathname of directory being salvaged */
  9    20     2 master_dir_uid bit (36) aligned,			/* master UID for this directory */
  9    21     2 tree_depth fixed bin;				/* number of levels from root for this directory */
  9    22 
  9    23 /* END INCLUDE FILE . . . salv_args */
      565 
      566 
 10     1 /* Begin include file salvager_severities.incl.pl1 BIM 831118 */
 10     2 /* format: style3 */
 10     3 
 10     4 declare	(
 10     5 	SALV_CRASH	init (1),			/** Something salvager-detected is life threatening. Should never happen */
 10     6 	SALV_ANNOUNCE	init (2),			/** Worthy of the console if online */
 10     7 	SALV_LOG		init (4),			/** worthy of the syserr log */
 10     8 	SALV_DEBUG	init (5),			/** just like 4, but dump the dir */
 10     9 	SALV_JUST_LOG	init (6)			/** barely worthy of the syserr log */
 10    10 	)		fixed bin int static options (constant);
 10    11 
 10    12 /* End include file salvager_severities.incl.pl1 */
      567 
      568 
 11     1 
 11     2 /* Begin include file ...  sc_info.incl.pl1  */
 11     3 /* format: style3 */
 11     4 /* quota_cell.incl.pl1 MUST be included with this file. */
 11     5 
 11     6 /* This file defines a structure used for communicating vtoc-resident
 11     7*   information between status accessing and setting primitives in
 11     8*   segment control */
 11     9 
 11    10 dcl	scip		ptr;
 11    11 
 11    12 dcl	1 based_sc_info	aligned based (scip),
 11    13 	  2 dtu		bit (36),			/* Date-time used */
 11    14 	  2 dtm		bit (36),			/* Date-time modified */
 11    15 	  2 records	fixed bin,		/* # records of storage used */
 11    16 	  2 msl		fixed bin,		/* Maximum segment length, words */
 11    17 	  2 csl		fixed bin,		/* Current segment length, words */
 11    18 	  2 flags,
 11    19 	    3 dnzp	bit (1) unal,
 11    20 	    3 pad_gtpd	bit (1) unal,		/* obsolete PML */
 11    21 	    3 damaged	bit (1) unal,
 11    22 	    3 nid		bit (1) unal,		/* no incremental volume dump switch */
 11    23 	    3 ncd		bit (1) unal,		/* no complete dump switch */
 11    24 	    3 synchronized  bit (1) unal,
 11    25 	    3 pad		bit (30) unal,
 11    26 	  2 pf_count	fixed bin (35),		/* page fault counter. may wrap */
 11    27 	  2 qcell (0:1)	aligned like quota_cell,
 11    28 	  2 vol_dtd	bit (36),			/* volume date-time-dumped */
 11    29 	  2 volid		(3) bit (36) aligned;	/* these belong to the dumper */
 11    30 
 11    31 
 11    32 dcl	1 sc_info		like based_sc_info aligned;
 11    33 
 11    34 /* End include file ...  sc_info.incl.pl1 */
      569 
      570 
 12     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 12     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 12     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 12     4 
 12     5 /* This include file has an ALM version.  Keep 'em in sync! */
 12     6 
 12     7 dcl (
 12     8 
 12     9 /* The following constants define the message action codes.  This indicates
 12    10*how a message is to be handled.  */
 12    11 
 12    12      SYSERR_CRASH_SYSTEM	init (1),			
 12    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 12    14 
 12    15      SYSERR_TERMINATE_PROCESS	init (2),
 12    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 12    17 
 12    18      SYSERR_PRINT_WITH_ALARM	init (3),
 12    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 12    20 
 12    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 12    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 12    23 
 12    24      SYSERR_LOG_OR_PRINT	init (4),
 12    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 12    26 
 12    27      SYSERR_LOG_OR_DISCARD	init (5),
 12    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 12    29 
 12    30 
 12    31 /* The following constants are added to the normal severities to indicate
 12    32*different sorting classes of messages.  */
 12    33 
 12    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 12    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 12    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 12    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 12    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 12    39 	) fixed bin internal static options (constant);
 12    40 
 12    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      571 
      572 
 13     1 /* begin include file - access_audit_eventflags.incl.pl1 */
 13     2 /* NOTE: This include file has an ALM counterpart made with cif.
 13     3*Keep it up to date. */
 13     4 
 13     5 dcl 1 audit_event_flags	based aligned,
 13     6       2 special_op	bit (1) unal,  /* special sys operation */
 13     7       2 grant	bit (1) unal,  /* operation was successful */
 13     8       2 admin_op	bit (1) unal,  /* administrative operation */
 13     9       2 priv_op	bit (1) unal,  /* privileged operation */
 13    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
 13    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
 13    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
 13    13       2 pad	bit (29) unal;
 13    14 
 13    15 /* end include file - access_audit_eventflags.incl.pl1 */
      573 
      574 
      575 
      576 /* BEGIN MESSAGE DOCUMENTAION
      577*
      578*   Message:
      579*   AUDIT (salv_directory): GRANTED modification of security out-of-service ADDED_INFO switch found already on
      580*
      581*   S:	$access_audit
      582*
      583*   T:	Salvaging
      584*
      585*   M:	At a previous time the system set the branch security out-of-service
      586*   because of an AIM error.
      587*
      588*   A:	$inform_ssa
      589*
      590*
      591*   Message:
      592*   AUDIT (salv_directory): GRANTED modification of security out-of-service ADDED_INFO
      593*
      594*   S:	$access_audit
      595*
      596*   T:	Salvaging
      597*
      598*   M:	The directory has a different access class from its parent and
      599*   it has no quota.  This is an AIM violation.
      600*
      601*   A:	$inform_ssa
      602*
      603*   Message:
      604*   salv_directory: Changed max length in VTOCE from LENGTH to MAXLENGTH.
      605*
      606*   S:     $log
      607*
      608*   T:     Salvaging
      609*
      610*   M:     The max length of a directory was changed to the system default.
      611*
      612*   A:     $ignore
      613*
      614*
      615*   Message:
      616*   salv_directory: ERROR_MESSAGE. Changing max length in VTOCE.
      617*
      618*   S:     $log
      619*
      620*   T:     Salvaging
      621*
      622*   M:     An error occurred while changing a dir's max length.
      623*
      624*   A:     $inform
      625*
      626*
      627*   Message:
      628*   salv_directory: ERROR_MESSAGE. truncate_vtoce to length LENGTH failed.
      629*
      630*   S:     $log
      631*
      632*   T:     Salvaging
      633*
      634*   M:     An error occurred while truncating a directory.
      635*
      636*   A:     $inform
      637*
      638*
      639*   Message:
      640*   salv_directory: Branch is security out-of-service: BRANCH_NAME
      641*
      642*   S:     $log
      643*
      644*   T:     Salvaging
      645*
      646*   M:     A branch is security out-of-service.
      647*
      648*   A:     $inform_ssa
      649*
      650*
      651*   Message:
      652*   salv_directory: ERROR_MESSAGE. Could not read VTOCE attributes.
      653*
      654*   S:     $log
      655*
      656*   T:     Salvaging
      657*
      658*   M:     An error occurred while reading the VTOCE.
      659*
      660*   A:     $inform_sa
      661*
      662*
      663*   Message:
      664*   salv_directory: Upgraded dir set security out-of-service due to no quota.
      665*
      666*   S:     $log
      667*
      668*   T:     Salvaging
      669*
      670*   M:     An upgraded directory was set soos due to not having terminal quota.
      671*
      672*   A:     $inform_ssa
      673*
      674*
      675*   Message:
      676*   salv_directory: Invalid call to error message printer.
      677*
      678*   S:     $log
      679*
      680*   T:     Salvaging
      681*
      682*   M:     An programming error resulted in an invalid call to the error
      683*   message printing procedure.
      684*
      685*   A:     $inform
      686*
      687*   END MESSAGE DOCUMENTATION */
      688 
      689      end salv_directory;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0807.4  salv_directory.pl1                >spec>install>1112>salv_directory.pl1
549          1    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
551          2    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
553          3    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
555          4    10/15/76  1242.9  dir_allocation_area.incl.pl1      >ldd>include>dir_allocation_area.incl.pl1
557          5    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
559          6    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
561          7    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
563          8    05/27/82  1525.9  quota_cell.incl.pl1               >ldd>include>quota_cell.incl.pl1
565          9    01/30/85  1523.9  salv_args.incl.pl1                >ldd>include>salv_args.incl.pl1
567         10    11/29/83  0929.9  salvager_severities.incl.pl1      >ldd>include>salvager_severities.incl.pl1
569         11    11/22/82  0955.7  sc_info.incl.pl1                  >ldd>include>sc_info.incl.pl1
571         12    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
573         13    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000041 constant        fixed bin(17,0)          initial dcl 12-7 set ref 454*
MAX_MESSAGE_SIZE                000001 constant        fixed bin(18,0)          initial dcl 96 set ref 360* 489
ME                              000002 constant        char(14)                 initial packed unaligned dcl 95 set ref 228* 231*
                                                                                  242* 262* 283* 299*
NEW_LINE                        002734 constant        char(1)                  initial packed unaligned dcl 97 ref 491
ONLINE                                 constant        fixed bin(17,0)          initial dcl 99 ref 175 324
RING_0                                 constant        fixed bin(17,0)          initial dcl 100 ref 160
RING_4                                 constant        fixed bin(17,0)          initial dcl 101 ref 148 194 267 303 397 487
SALV_ANNOUNCE                   000037 constant        fixed bin(17,0)          initial dcl 10-4 set ref 242* 283* 299*
SALV_DEBUG                             constant        fixed bin(17,0)          initial dcl 10-4 ref 492 501
SALV_LOG                        000034 constant        fixed bin(17,0)          initial dcl 10-4 set ref 228* 231* 262*
access_audit_$log_obj_class     000032 constant        entry                    external dcl 118 ref 269 305
access_class             33     000215 automatic       bit(72)                  level 2 in structure "root_entry" dcl 82
                                                                                  in procedure "salv_directory" set ref 524*
access_class             13            based           bit(72)                  level 2 in structure "dir" dcl 6-11 in procedure
                                                                                  "salv_directory" set ref 297 297 305*
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 5-8 in procedure
                                                                                  "salv_directory" set ref 269*
access_operations_$fs_obj_set_soos
                                000010 external static bit(36)                  dcl 106 set ref 269* 305*
addr                                                   builtin function         dcl 143 ref 151 221 221 262 269 360 360 465 465 475
                                                                                  512 520 521
arg_branch_p                           parameter       pointer                  dcl 60 ref 168 173
arg_code                               parameter       fixed bin(35,0)          dcl 61 set ref 14 156 168 178* 197* 284*
arg_count                              based           fixed bin(17,0)          level 3 packed packed unsigned unaligned dcl 2-42
                                                                                  ref 457
arg_count_                      000034 constant        entry                    external dcl 119 ref 452
arg_descriptor                         based           structure                level 1 dcl 1-6
arg_dp                                 parameter       pointer                  dcl 62 ref 168 174
arg_info_p                             parameter       pointer                  dcl 63 ref 14 150 156 161 168 172
arg_list_arg_count              000100 automatic       fixed bin(17,0)          dcl 418 set ref 452* 454
arg_list_ptr                    000102 automatic       pointer                  dcl 419 set ref 450* 456 457 457 459
arg_list_ptr_                   000036 constant        entry                    external dcl 120 ref 450
arg_list_with_envptr                   based           structure                level 1 dcl 2-42
arg_old_dir_len                        parameter       fixed bin(17,0)          dcl 64 set ref 14 149* 493*
arg_old_dir_p                          parameter       pointer                  dcl 65 set ref 14 365* 494
arg_ptrs                  2            based           pointer                  array level 2 dcl 2-42 ref 456 457 459
astep                           000100 automatic       pointer                  array dcl 70 set ref 357* 360* 365* 371* 376* 408
                                                                                  409 409*
audit_event_flags                      based           structure                level 1 dcl 13-5
based_caller_name                      based           char(32)                 packed unaligned dcl 434 ref 457
based_code                             based           fixed bin(35,0)          dcl 432 ref 459
based_sc_info                          based           structure                level 1 dcl 11-12
based_severity                         based           fixed bin(17,0)          dcl 433 ref 456
baseno                                                 builtin function         dcl 143 ref 474 474
branch_p                        000110 automatic       pointer                  dcl 71 set ref 173* 209 209 211 215 217 221 221 221
                                                                                  226 226 226 241* 250 297 342* 391 391 394 394 512*
                                                                                  533*
branch_ptr               10            based           pointer                  level 2 dcl 91 set ref 217*
bs                        4     000215 automatic       bit(1)                   level 2 in structure "root_entry" packed packed
                                                                                  unaligned dcl 82 in procedure "salv_directory" set
                                                                                  ref 523*
bs                        4            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 5-8 in procedure "salv_directory" ref 260
caller                          000112 automatic       fixed bin(17,0)          dcl 72 set ref 148* 160* 175* 194 267 303 324 397
                                                                                  487
caller_name                     000104 automatic       char(32)                 packed unaligned dcl 420 set ref 457* 500
check_vtoce               5(03)        based           bit(1)                   level 3 packed packed unaligned dcl 91 ref 254
child_dirmod                    000113 automatic       bit(1)                   dcl 73 set ref 238* 389 535*
cleanup                         000266 stack reference condition                dcl 141 ref 192
code                                   parameter       fixed bin(35,0)          dcl 316 in procedure "get_dir" set ref 313 319* 331*
                                                                                  332 342* 343 345
code                                   parameter       fixed bin(35,0)          dcl 355 in procedure "hold_segs" set ref 352 360*
                                                                                  361 365* 366 371* 372 376*
code                            000114 automatic       fixed bin(35,0)          dcl 74 in procedure "salv_directory" set ref 195*
                                                                                  196 197 203* 204 221* 223 226* 228 231* 241* 242
                                                                                  242* 245* 282 283* 284 459* 461* 462 473
copy                                   based           bit(36)                  array packed unaligned dcl 435 set ref 494* 494
copy_args                       000116 automatic       structure                level 1 dcl 75 set ref 150* 151
copy_len                        000114 automatic       fixed bin(17,0)          dcl 421 set ref 493* 494 494 494
csl                       4     000302 automatic       fixed bin(17,0)          level 2 dcl 11-32 set ref 224
current_length           12            based           fixed bin(17,0)          level 2 dcl 91 set ref 224* 240 493 502*
dc_find$dir_salvage             000100 constant        entry                    external dcl 3-28 ref 331
dc_find$finished                000102 constant        entry                    external dcl 3-33 ref 395
delete_connection_failure
                          5(06)        based           bit(1)                   level 3 packed packed unaligned dcl 91 ref 254
desc_ptrs                              based           pointer                  array level 2 dcl 2-42 ref 457
dir                                    based           structure                level 1 dcl 6-11 in procedure "salv_directory"
dir                                    parameter       char                     packed unaligned dcl 540 in procedure "target" ref
                                                                                  538 543 545
dir_branch                             based           structure                level 1 dcl 90
dir_dump                        000040 constant        entry                    external dcl 121 ref 502
dir_uid                         000205 automatic       bit(36)                  dcl 76 set ref 331* 393*
dirsw                    32     000215 automatic       bit(1)                   level 2 packed packed unaligned dcl 82 set ref 518*
divide                                                 builtin function         dcl 143 ref 224 226 226
dp                              000300 automatic       pointer                  dcl 6-9 set ref 174* 234* 254* 258 258 277 297 305
                                                                                  331* 335 342* 387 387 389* 395 395* 494 502* 533*
dump                      5(04)        based           bit(1)                   level 3 packed packed unaligned dcl 91 ref 207 364
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 5-8 ref 277
ent                                    parameter       char                     packed unaligned dcl 541 ref 538 543 545
entry                                  based           structure                level 1 dcl 5-8
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 6-11 ref 258
ep                              000276 automatic       pointer                  dcl 5-6 set ref 258* 258* 260 260 262 269 269* 277
error_table_$                   000012 external static fixed bin(17,0)          dcl 107 set ref 475
error_table_$mylock             000016 external static fixed bin(35,0)          dcl 109 ref 345
error_table_$no_terminal_quota  000014 external static fixed bin(35,0)          dcl 108 set ref 305*
et                                     based           structure                level 1 dcl 436
event_flags                     000206 automatic       structure                level 1 dcl 77 set ref 264* 269 269 300* 305 305
extended_arg_type               000274 automatic       fixed bin(17,0)          initial dcl 1-36 set ref 1-36*
formline_                       000042 constant        entry                    external dcl 122 ref 465
grab_aste$prewithdraw           000044 constant        entry                    external dcl 123 ref 360 365 371 376
grab_aste$release_prewithdraw   000046 constant        entry                    external dcl 124 ref 409
grant                     0(01) 000206 automatic       bit(1)                   level 2 packed packed unaligned dcl 77 set ref 266*
                                                                                  302*
have_code                       000115 automatic       bit(1)                   dcl 422 set ref 440* 447* 459 462* 472
hbound                                                 builtin function         dcl 143 ref 408
header                                 based           structure                level 2 dcl 2-42
i                               000100 automatic       fixed bin(17,0)          dcl 406 set ref 408* 409 409*
info                                   based           structure                level 1 dcl 91
info_p                          000210 automatic       pointer                  dcl 78 set ref 151* 161* 172* 207 209 211 213 215
                                                                                  217 224 234* 240 254 254 254 269 305 318 331 364
                                                                                  371 376 493 500 502
len                                    based           fixed bin(8,0)           level 2 packed packed unaligned dcl 436 ref 476 478
length                                                 builtin function         dcl 143 ref 464 466 476 489
level$get                       000050 constant        entry                    external dcl 125 ref 269 269 305 305
line                            000116 automatic       char(256)                packed unaligned dcl 423 set ref 464 464 465 465 465
                                                                                  465 466 466 467* 476 478* 491 500
line_len                        000216 automatic       fixed bin(17,0)          dcl 424 set ref 464* 465* 466* 466 468* 468 476 478
                                                                                  479* 479 489 491 500
lock$dir_unlock                 000052 constant        entry                    external dcl 126 ref 394
lock$dir_unlock_given_uid       000054 constant        entry                    external dcl 127 ref 393
master_dir               32(09) 000215 automatic       bit(1)                   level 2 in structure "root_entry" packed packed
                                                                                  unaligned dcl 82 in procedure "salv_directory" set
                                                                                  ref 519*
master_dir               32(09)        based           bit(1)                   level 2 in structure "dir_branch" packed packed
                                                                                  unaligned dcl 90 in procedure "salv_directory" ref
                                                                                  209
master_dir_uid           61            based           bit(36)                  level 2 in structure "dir" dcl 6-11 in procedure
                                                                                  "salv_directory" ref 211
master_dir_uid           65            based           bit(36)                  level 2 in structure "info" dcl 91 in procedure
                                                                                  "salv_directory" set ref 209* 211*
message                                parameter       varying char             dcl 66 set ref 14 360 360 489 490* 490 491* 491
min                                                    builtin function         dcl 143 ref 476
modify                                 based           bit(36)                  level 2 dcl 6-11 set ref 335* 387*
msg                       0(09)        based           char                     level 2 packed packed unaligned dcl 436 ref 478
msg_len                         000217 automatic       fixed bin(17,0)          dcl 425 set ref 476* 477 478 479
msg_p                           000220 automatic       pointer                  packed unaligned dcl 426 set ref 473* 474 475* 475
                                                                                  476 478 478
msl                       3     000302 automatic       fixed bin(17,0)          level 2 dcl 11-32 set ref 225 228*
name                      4            based           char(32)                 level 2 dcl 7-7 set ref 262 269 521*
name_frp                  5     000215 automatic       bit(18)                  level 2 packed packed unaligned dcl 82 set ref 520*
names                                  based           structure                level 1 dcl 7-7
new_dir_pages                   000212 automatic       fixed bin(17,0)          dcl 79 set ref 234* 237 240 241* 242*
null                                                   builtin function         dcl 143 ref 269 269 305 305 357 387 395 409 533
options                   5            based           structure                level 2 dcl 91
owner                    44     000215 automatic       bit(36)                  level 2 dcl 82 set ref 514*
packed_null                     000000 constant        pointer                  initial packed unaligned dcl 102 ref 474
parent_dirmod                   000213 automatic       bit(1)                   dcl 80 set ref 251* 391 535*
pathname                 13            based           char(168)                level 2 packed packed unaligned dcl 91 set ref 254
                                                                                  269* 305* 318 331* 500*
pds$processid                   000020 external static bit(36)                  dcl 110 ref 335
per_process_sw           32(02) 000215 automatic       bit(1)                   level 2 packed packed unaligned dcl 82 set ref 522*
pic                             000221 automatic       picture(2)               packed unaligned dcl 427 set ref 488* 490
primary_name             10     000215 automatic       bit(504)                 level 2 in structure "root_entry" packed packed
                                                                                  unaligned dcl 82 in procedure "salv_directory" set
                                                                                  ref 520 521
primary_name             10            based           bit(504)                 level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 5-8 in procedure "salv_directory" set ref 262
                                                                                  269
priv_op                   0(03) 000206 automatic       bit(1)                   level 2 packed packed unaligned dcl 77 set ref 267*
                                                                                  303*
ptr                                                    builtin function         dcl 143 ref 211 215 258 277 297 391 391 394 394 475
pvid                     30     000215 automatic       bit(36)                  level 2 in structure "root_entry" packed packed
                                                                                  unaligned dcl 82 in procedure "salv_directory" set
                                                                                  ref 515*
pvid                     30            based           bit(36)                  level 2 in structure "dir_branch" packed packed
                                                                                  unaligned dcl 90 in procedure "salv_directory" ref
                                                                                  221 226
pvt$root_lvid                   000022 external static bit(36)                  dcl 111 ref 516
pvt$root_pvid                   000024 external static bit(36)                  dcl 112 ref 515
pvt$root_vtocx                  000026 external static fixed bin(17,0)          dcl 113 ref 517
qcell                    10     000302 automatic       structure                array level 2 dcl 11-32 set ref 298 298
quota                                  defined         fixed bin(35,0)          level 2 dcl 294 ref 298
quota_cell                             based           structure                level 1 dcl 8-3
quota_info                             defined         structure                level 1 dcl 294
rel                                                    builtin function         dcl 143 ref 258 475 520
root                            000214 automatic       bit(1)                   dcl 81 set ref 213 296 318* 325 339
root_entry                      000215 automatic       structure                level 1 dcl 82 set ref 512 513*
rtrim                                                  builtin function         dcl 143 ref 466 500 545
salv_args                              based           structure                level 1 dcl 9-4 ref 150
salv_check_vtoce_               000060 constant        entry                    external dcl 129 ref 254
salv_dir_checker_               000056 constant        entry                    external dcl 128 ref 234
salv_err_msg$path               000062 constant        entry                    external dcl 130 ref 500
sc_info                         000302 automatic       structure                level 1 dcl 11-32 set ref 221 221
security_oosw            32(07)        based           bit(1)                   level 2 in structure "dir_branch" packed packed
                                                                                  unaligned dcl 90 in procedure "salv_directory" set
                                                                                  ref 250*
security_oosw            32(07)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 5-8 in procedure "salv_directory" ref 260
set_security_oosw               000262 automatic       bit(1)                   dcl 83 set ref 234* 249 308*
severity                        000222 automatic       fixed bin(17,0)          dcl 428 set ref 456* 488 492 500* 501
should_dump                     000263 automatic       bit(1)                   dcl 84 set ref 207* 492 495* 501 503*
size                      0(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 1-6 ref
                                                                                  457
sons_lvid                41     000215 automatic       bit(36)                  level 2 dcl 82 set ref 516*
special_op                      000206 automatic       bit(1)                   level 2 packed packed unaligned dcl 77 set ref 265*
                                                                                  301*
start                           000223 automatic       fixed bin(17,0)          dcl 429 set ref 441* 448* 465* 465
string                                 defined         char(253)                packed unaligned dcl 430 in procedure "print" set
                                                                                  ref 464 465 465 466
string                                                 builtin function         dcl 143 in procedure "salv_directory" set ref 264*
                                                                                  269 269 300* 305 305
substr                                                 builtin function         dcl 143 set ref 457 466 467* 478* 491 500
sum$dirmod                      000064 constant        entry                    external dcl 131 ref 389 391
sum$getbranch_root_my           000066 constant        entry                    external dcl 132 ref 342
sys_info$default_dir_max_length 000030 external static fixed bin(19,0)          dcl 114 set ref 225 226 226 228*
syserr                          000070 constant        entry                    external dcl 133 ref 454
temp1_ptr                              based           pointer                  level 2 dcl 91 set ref 376*
temp2_ptr                 2            based           pointer                  level 2 dcl 91 set ref 371*
tree_depth               57            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 6-11 in procedure "salv_directory" ref 215
tree_depth               66            based           fixed bin(17,0)          level 2 in structure "info" dcl 91 in procedure
                                                                                  "salv_directory" set ref 213* 215*
truncate_vtoce                  000072 constant        entry                    external dcl 134 ref 241
uid                       2     000215 automatic       bit(36)                  level 2 in structure "root_entry" dcl 82
                                                                                  in procedure "salv_directory" set ref 514*
uid                       2            based           bit(36)                  level 2 in structure "dir_branch" dcl 90
                                                                                  in procedure "salv_directory" ref 209 221 226
unlock_dir                      000264 automatic       bit(1)                   dcl 85 set ref 190* 333* 393 534*
unlock_parent                   000265 automatic       bit(1)                   dcl 86 set ref 190* 343* 394 534*
unspec                                                 builtin function         dcl 143 set ref 473* 473 513*
vtoc_attributes$get_info        000074 constant        entry                    external dcl 135 ref 221
vtoc_attributes$set_max_lth     000076 constant        entry                    external dcl 136 ref 226
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "dir_branch" packed packed
                                                                                  unaligned dcl 90 in procedure "salv_directory" ref
                                                                                  221 226
vtocx                    31     000215 automatic       fixed bin(17,0)          level 2 in structure "root_entry" packed packed
                                                                                  unaligned dcl 82 in procedure "salv_directory" set
                                                                                  ref 517*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 12-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 12-7
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 3-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 3-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 3-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 3-13
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-54
Interseg_call_type                     internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-54
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 12-7
LOG                                    internal static fixed bin(17,0)          initial dcl 12-7
Quick_call_type                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 2-54
SALV_CRASH                             internal static fixed bin(17,0)          initial dcl 10-4
SALV_JUST_LOG                          internal static fixed bin(17,0)          initial dcl 10-4
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 12-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 12-7
area                                   based           structure                level 1 dcl 4-5
areap                                  automatic       pointer                  dcl 4-3
arg_descriptor_ptr                     automatic       pointer                  dcl 1-34
arg_list                               based           structure                level 1 dcl 2-14
command_name_arglist                   based           structure                level 1 dcl 2-25
dc_find$dir_for_append          000000 constant        entry                    external dcl 3-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 3-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 3-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 3-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 3-21
dc_find$dir_read                000000 constant        entry                    external dcl 3-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 3-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 3-26
dc_find$dir_write               000000 constant        entry                    external dcl 3-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 3-31
dc_find$link_target             000000 constant        entry                    external dcl 3-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 3-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 3-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 3-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 3-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 3-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 3-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 3-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 3-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 3-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 3-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 3-51
dc_find$obj_delete              000000 constant        entry                    external dcl 3-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 3-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 3-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 3-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 3-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 3-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 3-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 3-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 3-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 3-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 3-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 3-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 3-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 3-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 3-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 3-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 3-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 3-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 3-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 3-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 3-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 3-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 3-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 3-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 3-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 3-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 3-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 3-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 3-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 3-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 3-95
dc_find$seg_fault               000000 constant        entry                    external dcl 3-97
extended_arg_descriptor                based           structure                level 1 dcl 1-21
fixed_arg_descriptor                   based           structure                level 1 dcl 1-13
np                                     automatic       pointer                  dcl 7-5
qcp                                    automatic       pointer                  dcl 8-12
scip                                   automatic       pointer                  dcl 11-10
version_number_2                       internal static fixed bin(17,0)          initial dcl 6-84

NAMES DECLARED BY EXPLICIT CONTEXT.
FORMAT                          002057 constant        label                    dcl 450 set ref 442
START                           000322 constant        label                    dcl 178 set ref 153 162
check_upgraded_dir              001242 constant        entry                    internal dcl 291 ref 248
clean_up                        001660 constant        entry                    internal dcl 381 ref 192 280
get_dir                         001414 constant        entry                    internal dcl 313 ref 203
hold_segs                       001520 constant        entry                    internal dcl 352 ref 195
online_salvage                  000274 constant        entry                    external dcl 168
print                           002034 constant        entry                    internal dcl 414 ref 228 234 234 262 299
print_code                      002046 constant        entry                    internal dcl 444 ref 231 242 254 254 283
rel_segs                        001777 constant        entry                    internal dcl 403 ref 198 397
ring0_salvage                   000246 constant        entry                    external dcl 156
salv_directory                  000206 constant        entry                    external dcl 14
setup                           002601 constant        entry                    internal dcl 528 ref 147 159 171
setup_root_branch               002537 constant        entry                    internal dcl 509 ref 325 339
target                          002613 constant        entry                    internal dcl 538 ref 269

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3412        3516    2741        3422
Length      4234    2741       104         501     450           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
salv_directory                      460 external procedure  is an external procedure.  
on unit on line 192                  64 on unit               
check_upgraded_dir                      internal procedure  shares stack frame of external procedure salv_directory.  
get_dir                                 internal procedure  shares stack frame of external procedure salv_directory.  
hold_segs                               internal procedure  shares stack frame of external procedure salv_directory.  
clean_up                             78 internal procedure  is called by several nonquick procedures.  
rel_segs                             70 internal procedure  is called by several nonquick procedures.  
print                               186 internal procedure  is assigned to an entry variable, and is declared options(variable).  
setup_root_branch                       internal procedure  shares stack frame of external procedure salv_directory.  
setup                                   internal procedure  shares stack frame of external procedure salv_directory.  
target                               70 internal procedure  uses returns(char(*)) or returns(bit(*)).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
print                    000100 arg_list_arg_count          print
                         000102 arg_list_ptr                print
                         000104 caller_name                 print
                         000114 copy_len                    print
                         000115 have_code                   print
                         000116 line                        print
                         000216 line_len                    print
                         000217 msg_len                     print
                         000220 msg_p                       print
                         000221 pic                         print
                         000222 severity                    print
                         000223 start                       print
rel_segs                 000100 i                           rel_segs
salv_directory           000100 astep                       salv_directory
                         000110 branch_p                    salv_directory
                         000112 caller                      salv_directory
                         000113 child_dirmod                salv_directory
                         000114 code                        salv_directory
                         000116 copy_args                   salv_directory
                         000205 dir_uid                     salv_directory
                         000206 event_flags                 salv_directory
                         000210 info_p                      salv_directory
                         000212 new_dir_pages               salv_directory
                         000213 parent_dirmod               salv_directory
                         000214 root                        salv_directory
                         000215 root_entry                  salv_directory
                         000262 set_security_oosw           salv_directory
                         000263 should_dump                 salv_directory
                         000264 unlock_dir                  salv_directory
                         000265 unlock_parent               salv_directory
                         000274 extended_arg_type           salv_directory
                         000276 ep                          salv_directory
                         000300 dp                          salv_directory
                         000302 sc_info                     salv_directory

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     alloc_temp          cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_$log_obj_class   arg_count_                    arg_list_ptr_                 dc_find$dir_salvage
dc_find$finished              dir_dump                      formline_                     grab_aste$prewithdraw
grab_aste$release_prewithdraw level$get                     lock$dir_unlock               lock$dir_unlock_given_uid
salv_check_vtoce_             salv_dir_checker_             salv_err_msg$path             sum$dirmod
sum$getbranch_root_my         syserr                        truncate_vtoce                vtoc_attributes$get_info
vtoc_attributes$set_max_lth

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$fs_obj_set_soos                          error_table_$                 error_table_$mylock
error_table_$no_terminal_quota                              pds$processid                 pvt$root_lvid
pvt$root_pvid                 pvt$root_vtocx                sys_info$default_dir_max_length




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 1   36 000175        14 000201       147 000225       148 000226       149 000230       150 000232       151 000237
    153 000241       156 000242       159 000257       160 000260       161 000262       162 000266       168 000267
    171 000305       172 000306       173 000312       174 000315       175 000320       178 000322       190 000323
    192 000325       194 000347       195 000352       196 000354       197 000356       198 000357       199 000363
    203 000364       204 000366       207 000370       209 000375       211 000404       213 000407       215 000413
    217 000420       221 000421       223 000451       224 000453       225 000460       226 000464       228 000521
    231 000557       234 000606       237 000630       238 000632       240 000634       241 000637       242 000652
    245 000706       248 000707       249 000710       250 000713       251 000716       254 000720       258 000763
    260 000774       262 001003       264 001031       265 001032       266 001034       267 001036       269 001043
    275 001173       277 001174       280 001202       282 001206       283 001210       284 001237       287 001241
    291 001242       296 001243       297 001246       298 001260       299 001262       300 001305       301 001306
    302 001310       303 001312       305 001317       308 001411       311 001413       313 001414       318 001416
    319 001424       324 001425       325 001430       326 001433       331 001434       332 001452       333 001456
    335 001460       339 001463       342 001467       343 001505       345 001513       348 001517       352 001520
    357 001522       360 001535       361 001557       364 001563       365 001567       366 001607       371 001613
    372 001633       376 001637       377 001656       381 001657       387 001665       389 001673       391 001704
    393 001716       394 001730       395 001744       397 001764       399 001775       403 001776       408 002004
    409 002011       410 002030       412 002032       414 002033       440 002041       441 002042       442 002044
    444 002045       447 002053       448 002055       450 002057       452 002066       454 002075       456 002120
    457 002123       459 002134       461 002142       462 002144       464 002147       465 002151       466 002200
    467 002212       468 002214       472 002216       473 002220       474 002223       475 002232       476 002241
    477 002255       478 002261       479 002303       487 002306       488 002312       489 002322       490 002330
    491 002342       492 002376       493 002404       494 002411       495 002427       498 002431       500 002432
    501 002513       502 002522       503 002534       507 002536       509 002537       512 002540       513 002542
    514 002545       515 002550       516 002553       517 002555       518 002560       519 002562       520 002564
    521 002567       522 002572       523 002574       524 002576       526 002600       528 002601       533 002602
    534 002605       535 002607       536 002611       538 002612       543 002633       545 002662


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
