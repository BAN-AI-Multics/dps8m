	COMPILATION LISTING OF SEGMENT bce_probe
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1032.9 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-01-10,Farley), approve(86-01-10,MCR6979),
       11*     audit(86-01-24,GDixon), install(86-03-21,MR12.0-1033):
       12*     Corrected to use first_rec_num & last_rec_num instead of 0 & rec_per_dev.
       13*  2) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
       14*     audit(86-05-14,Farley), install(86-07-17,MR12.0-1097):
       15*     Add subvolume support, by calling disk_name_pvtx.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 bce_probe: proc (p_ss_info_ptr);
       19 
       20 /* Program to examine and change locations in the saved Multics image.
       21*Written in November of 1983 by Keith Loepere. */
       22 /* Modified (get_address) June of 1984 to find addresses with symbolic
       23*references. - Allen Ball. */
       24 /* Modified March 1985 to move relocate_instruction_ into hardcore, Keith Loepere. */
       25 
       26 /* WARNING: this must be run through pl1_macro, without args, before compilation. */
       27 
       28 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       29 
       30 /* Types of addresses and modes... */
       31 
       32 
       33 dcl  Absolute			fixed bin static options (constant) init (1);
       34 dcl  Accessing_breakpoint_page	char (25) static options (constant) init ("Accessing breakpoint page");
       35 dcl  Accessing_segment		char (17) static options (constant) init ("Accessing segment");
       36 dcl  Address_missing		char (15) static options (constant) init ("Address missing");
       37 dcl  Address_type_must_be_virtual	char (28) static options (constant) init ("Address type must be virtual");
       38 dcl  Apte_number_missing		char (19) static options (constant) init ("Apte number missing");
       39 dcl  Ascii			fixed bin static options (constant) init (1); /* mode */
       40 dcl  Bad_apte			char (8) static options (constant) init ("Bad apte");
       41 dcl  Bad_component_name		char (18) static options (constant) init ("Bad component name");
       42 dcl  Bad_disk_record		char (15) static options (constant) init ("Bad disk record");
       43 dcl  Bad_decimal_value		char (17) static options (constant) init ("Bad decimal value");
       44 dcl  Bad_octal_value		char (15) static options (constant) init ("Bad octal value");
       45 dcl  Bad_page_offset		char (15) static options (constant) init ("Bad page offset");
       46 dcl  Bad_segment_offset		char (18) static options (constant) init ("Bad segment offset");
       47 dcl  Base8			fixed bin static options (constant) init (8);
       48 dcl  Base10			fixed bin static options (constant) init (10);
       49 dcl  Bce_mode			fixed bin static options (constant) init (3);
       50 dcl  Break_already_set		char (17) static options (constant) init ("Break already set");
       51 dcl  Break_mode			fixed bin static options (constant) init (1);
       52 dcl  Crash_mode			fixed bin static options (constant) init (2);
       53 dcl  DRL_1			bit (36) aligned static options (constant) init ("777777002000"b3);
       54 dcl  Decimal			fixed bin static options (constant) init (2); /* mode */
       55 dcl  Disk				fixed bin static options (constant) init (2);
       56 dcl  Dot_must_be_followed_by_plus_or_minus char (37) static options (constant) init ("Dot must be followed by plus or minus");
       57 dcl  Function_arg_list_missing	char (25) static options (constant) init ("Function arg list missing");
       58 dcl  Function_argument_missing	char (25) static options (constant) init ("Function argument missing");
       59 dcl  Improper_arg_list_end_for_function char (34) static options (constant) init ("Improper arg list end for function");
       60 dcl  Improper_syntax_in_line		char (23) static options (constant) init ("Improper syntax in line");
       61 dcl  Instruction			fixed bin static options (constant) init (3); /* mode */
       62 dcl  Invalid_word_offset		char (19) static options (constant) init ("Invalid word offset");
       63 dcl  Instruction_cannot_be_breakpointed char (34) static options (constant) init ("Instruction cannot be breakpointed");
       64 dcl  Missing_component		char (17) static options (constant) init ("Missing component");
       65 dcl  Missing_equals			char (9) static options (constant) init ("Missing =");
       66 dcl  Missing_offset			char (14) static options (constant) init ("Missing offset");
       67 dcl  Missing_seg_id			char (14) static options (constant) init ("Missing seg id");
       68 dcl  Missing_value			char (13) static options (constant) init ("Missing value");
       69 dcl  Missing_word_offset		char (19) static options (constant) init ("Missing word offset");
       70 dcl  NOP				bit (36) static options (constant) init ("000000011000"b3);
       71 dcl  Name				char (4) static options (constant) init ("Name");
       72 dcl  Name_missing			char (12) static options (constant) init ("Name missing");
       73 dcl  No_break_set			char (12) static options (constant) init ("No break set");
       74 dcl  No_current_address		char (18) static options (constant) init ("No current address");
       75 dcl  No_current_break		char (16) static options (constant) init ("No current break");
       76 dcl  No_image_to_restart		char (19) static options (constant) init ("No image to restart");
       77 dcl  No_offset_may_be_added_to_register_addresses char (44) static options (constant) init ("No offset may be added to register addresses");
       78 dcl  No_such_drive			char (13) static options (constant) init ("No such drive");
       79 dcl  Octal			fixed bin static options (constant) init (4); /* mode */
       80 dcl  Offset_makes_address_negative	char (29) static options (constant) init ("Offset makes address negative");
       81 dcl  Plus_or_minus_allowed_only_with_an_entry_name char (45) static options (constant) init ("Plus or minus allowed only with an entry name");
       82 dcl  Pointer			fixed bin static options (constant) init (5); /* mode */
       83 dcl  Reading_a_line			char (14) static options (constant) init ("Reading a line");
       84 dcl  Reading_disk			char (12) static options (constant) init ("Reading disk");
       85 dcl  Register			fixed bin static options (constant) init (3);
       86 dcl  Register_address_not_allowed	char (28) static options (constant) init ("Register address not allowed");
       87 dcl  Segment_name			char (12) static options (constant) init ("Segment name");
       88 dcl  Segment_not_breakpointable	char (26) static options (constant) init ("Segment not breakpointable");
       89 dcl  Segment_number_missing		char (22) static options (constant) init ("Segment number missing");
       90 dcl  TRA				bit (18) init ("710000"b3);
       91 dcl  Too_many_breakpoints_in_segment	char (31) static options (constant) init ("Too many breakpoints in segment");
       92 dcl  Unexpected_args_follow		char (22) static options (constant) init ("Unexpected args follow");
       93 dcl  Unknown_mode			char (12) static options (constant) init ("Unknown mode");
       94 dcl  Unmatched_quotes		char (16) static options (constant) init ("Unmatched_quotes");
       95 dcl  Unrecognizable_address		char (22) static options (constant) init ("Unrecognizable address");
       96 dcl  Unrecognizable_request		char (22) static options (constant) init ("Unrecognizable request");
       97 dcl  Unrecognizable_option		char (21) static options (constant) init ("Unrecognizable option");
       98 dcl  Unrecognizable_value		char (20) static options (constant) init ("Unrecognizable value");
       99 dcl  Unknown_register		char (16) static options (constant) init ("Unknown register");
      100 dcl  Values_being_let_too_long	char (25) static options (constant) init ("Values being let too long");
      101 dcl  Virtual			fixed bin static options (constant) init (4);
      102 dcl  Writing_disk			char (12) static options (constant) init ("Writing disk");
      103 
      104 dcl  absadr			entry (ptr, fixed bin (35)) returns (fixed bin (26));
      105 dcl  addbitno			builtin;
      106 dcl  addcharno			builtin;
      107 dcl  addr				builtin;
      108 dcl  addrel			builtin;
      109 dcl  addwordno			builtin;
      110 dcl  arg				char (arg_len) based (arg_ptr);
      111 dcl  arg_index			fixed bin;	/* loop var for function args */
      112 dcl  arg_len			fixed bin (21);
      113 dcl  arg_num			fixed bin;
      114 dcl  arg_ptr			ptr;
      115 dcl  1 arg_list			aligned,		/* for calling functions within us */
      116        2 twice_num_args		fixed bin (18) uns unal, /* standard stuff */
      117        2 tag			bit (18) unal init ("000004"b3),
      118        2 pad_descriptors		fixed bin (18) uns unal init (0),
      119        2 arg_ptrs			(8) ptr;
      120 dcl  arg_str_lens			(4) fixed bin;	/* used as built arguments to functions we call */
      121 dcl  arg_str_ptrs			(4) ptr;		/* used as built arguments to functions we call */
      122 dcl  baseptr			builtin;
      123 dcl  bce_appending_simulation$get_absolute entry (fixed bin (26), fixed bin (18), ptr, fixed bin (35));
      124 dcl  bce_appending_simulation$get_virtual entry (ptr, fixed bin (26), fixed bin (18), ptr, fixed bin (35));
      125 dcl  bce_appending_simulation$put_absolute entry (fixed bin (26), fixed bin (18), ptr, fixed bin (35));
      126 dcl  bce_appending_simulation$put_virtual entry (ptr, fixed bin (26), fixed bin (18), ptr, fixed bin (35));
      127 dcl  bce_appending_simulation$init	entry (bit (1) aligned, fixed bin (35));
      128 dcl  bce_appending_simulation$new_dbr	entry (bit (72) aligned, fixed bin (15), fixed bin (35));
      129 dcl  bce_appending_simulation$new_segment entry (fixed bin (15), ptr, fixed bin (35));
      130 dcl  bce_component_to_wordnum_	entry (fixed bin (15), char (32), char (32), fixed bin (15), fixed bin (26), fixed bin (35));
      131 dcl  bce_continue			entry;
      132 dcl  bce_data$get_line		external variable entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
      133 dcl  disk_name_pvtx		entry (char (8), fixed bin, fixed bin (35));
      134 dcl  bce_display_instruction_		entry (ptr, fixed bin, fixed bin (26));
      135 dcl  bce_display_scu_		entry (ptr, fixed bin (26), bit (1) aligned);
      136 dcl  bce_inst_length_		entry (ptr, fixed bin) returns (fixed bin);
      137 dcl  bce_name_to_segnum_		entry (char (*), fixed bin (15), fixed bin (35));
      138 dcl  1 bce_probe_data		aligned,
      139        2 my_seg_info_ptr		ptr,		/* current seg_info */
      140        2 last_segnum		fixed bin (15),	/* highest segnum valid for this dbr */
      141        2 address,					/* current address */
      142          3 type			fixed bin,
      143          3 pvtx			fixed bin,	/* for disk address */
      144          3 record_num		fixed bin (18),
      145          3 pad			bit (36),
      146          3 reg_ptr			ptr,		/* address of register (in toehold or breakpoint_page)  */
      147          3 segnum			fixed bin (15),
      148          3 wordnum			fixed bin (26),
      149          3 default_mode		fixed bin,
      150          3 default_len		fixed bin (24),	/* in bits */
      151          3 error_name		char (32) unal;	/* used in error msgs */
      152 dcl  bce_relocate_instruction_	entry (ptr, ptr, fixed bin (18), fixed bin, fixed bin, fixed bin (35));
      153 dcl  bce_segnum_to_name_		entry (fixed bin (15)) returns (char (*));
      154 dcl  bce_segptr_to_name_		entry (ptr) returns (char (*));
      155 dcl  bin				builtin;
      156 dcl  bit				builtin;
      157 dcl  breakpoint_absadr		fixed bin (26);	/* to breakpoint_page */
      158 dcl  breakpoint_at			ptr;		/* within simulated space of active break */
      159 dcl  breakpoint_page$		external;
      160 dcl  1 breakpoint_page_buffer		aligned like bkpt_page.header;
      161 dcl  code				fixed bin (35);
      162 dcl  com_err_			entry () options (variable);
      163 dcl  crash_definitions_$		ext;
      164 dcl  crash_name_table$		ext;
      165 dcl  crash_lot$			ext;
      166 dcl  crash_slt$			ext;
      167 dcl  cu_$arg_count_rel		entry (fixed bin, ptr, fixed bin (35));
      168 dcl  cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
      169 dcl  cu_$generate_call		entry (entry, ptr);
      170 dcl  cv_integer_string_check_		entry (char (*), fixed bin, fixed bin (35)) returns (fixed bin (35));
      171 dcl  date_time_			entry (fixed bin (71), char (*));
      172 dcl  definitions_$			ext;
      173 dcl  dimension			builtin;
      174 dcl  divide			builtin;
      175 dcl  error_table_$bad_arg		fixed bin (35) ext static;
      176 dcl  examine_mode			fixed bin;	/* break versus crash vs bce */
      177 dcl  fixed			builtin;
      178 dcl  get_ptrs_$given_segno		entry (fixed bin (15)) returns (ptr);
      179 dcl  index			builtin;
      180 dcl  ioa_				entry () options (variable);
      181 dcl  length			builtin;
      182 dcl  line				char (line_len) based (line_ptr); /* amount of input request line left to process */
      183 dcl  line_buffer			char (128);	/* area to hold input request line */
      184 dcl  line_len			fixed bin;
      185 dcl  line_ptr			ptr;
      186 dcl  lot$				external;
      187 dcl  me				char (5) static options (constant) init ("probe");
      188 dcl  min				builtin;
      189 dcl  mod				builtin;
      190 dcl  my_dbr			bit (72) aligned;
      191 dcl  my_initial_dbr			bit (72) aligned;
      192 dcl  1 my_seg_info			aligned like seg_info; /* describe seg being dumped for virtual addr */
      193 dcl  name_table$			ext;
      194 dcl  null				builtin;
      195 dcl  old_instr_buffer		(4) bit (36) aligned;
      196 dcl  p_ss_info_ptr			ptr parameter;
      197 dcl  pc$nullify			entry (ptr);
      198 dcl  prs				(0:7) char (4) int static options (constant)
      199 				init ("(ap)", "(ab)", "(bp)", "(bb)", "(lp)", "(lb)", "(sp)", "(sb)");
      200 dcl  ptr				builtin;
      201 dcl  read_disk			entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
      202 dcl  rtrim			builtin;
      203 
      204  
      205  
      206  
      207  
      208  
      209  
      210  
      211  
      212  
      213  
      214  
      215  
      216  
      217  
      218  
      219  
      220  
      221  
      222  
      223  
      224  
      225  
      226  
      227  
      228  
      229  
      230  
      231 dcl  reg_lens			(27) fixed bin static options (constant) init /* become default lengths for register display */
      232 				(72, 72, 72, 72, 72, 72, 72, 72,
      233 				18, 18, 18, 18, 18, 18, 18, 18,
      234 				36, 36, 8, 27, 3, 36, 15, 36,
      235 				36, 72, 36);
      236 dcl  reg_modes			(27) fixed bin init
      237 				(Pointer, Pointer, Pointer, Pointer, Pointer, Pointer, Pointer, Pointer,
      238 				Octal, Octal, Octal, Octal, Octal, Octal, Octal, Octal,
      239 				Octal, Octal, Octal, Octal, Octal, Octal, Octal, Octal,
      240 				Octal, Octal, Octal);
      241 dcl  reg_names			(27) char (9) static options (constant) init
      242 				("pr0", "pr1", "pr2", "pr3", "pr4", "pr5", "pr6", "pr7",
      243 				"x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
      244 				"a", "q", "e", "t", "ralr", "fault", "ext_fault", "mode",
      245 				"cache", "dbr", "bar");
      246 dcl  reg_ptrs			(27) ptr;	/* start of reg */
      247 dcl  req_index			fixed bin;	/* loop index on requests */
      248 
      249  
      250  
      251  
      252  
      253  
      254  
      255  
      256  
      257  
      258  
      259  
      260  
      261  
      262  
      263  
      264  
      265  
      266  
      267  
      268  
      269  
      270  
      271  
      272  
      273 dcl  requests			(24) char (16) static options (constant) init
      274 				("b", "before", "c", "continue", "dbr", "display", ".", "ds", "l", "let", "list_requests", "lr", "mc", "name", "proc", "q", "quit", "r", "reset", "segno", "sk", "st", "stack", "status");
      275 dcl  search			builtin;
      276 dcl  segno			builtin;
      277 dcl  size				builtin;
      278 dcl  slt$				external;
      279 dcl  string			char (string_len) based (string_ptr); /* item in request line being examined */
      280 dcl  string_len			fixed bin;
      281 dcl  string_ptr			ptr;
      282 dcl  sub_request_abort_		condition;
      283 dcl  substr			builtin;
      284 dcl  sys_boot_info$bce_dbr		bit (72) aligned external;
      285 dcl  tc_data$			external;
      286 dcl  1 toehold$			aligned like toe_hold external;
      287 dcl  unspec			builtin;
      288 dcl  1 value			aligned,		/* description of value in let request */
      289        2 type			fixed bin,
      290        2 length			fixed bin,	/* in bits */
      291        2 align			fixed bin (71),
      292        2 data			bit (256 * 9) aligned; /* max allowed */
      293 dcl  verify			builtin;
      294 dcl  1 work_area			aligned,
      295        2 left_from_before		bit (4 * 36),
      296        2 buffer			bit (1024 * 36);	/* for building data to write */
      297 dcl  write_disk			entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
      298 dcl  wordno			builtin;
      299 
      300 	ss_info_ptr = p_ss_info_ptr;
      301 	fgbxp = addr (flagbox$);
      302 	if fgbx.breakpoint then examine_mode = Break_mode;
      303 	else if sys_info$collection_1_phase = CRASH_INITIALIZATION | sys_info$collection_1_phase = BCE_CRASH_INITIALIZATION then examine_mode = Crash_mode;
      304 	else examine_mode = Bce_mode;
      305 	if ss_info_ptr ^= null then do;
      306 	     call cu_$arg_count_rel (arg_num, ss_info.arg_list_ptr, code);
      307 	     if code = 0 then do arg_index = 1 to arg_num;
      308 		call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_len, code, ss_info.arg_list_ptr);
      309 		if arg = "-crash" then examine_mode = Crash_mode;
      310 		else if arg = "-bce" then examine_mode = Bce_mode;
      311 		else if arg = "-break" then examine_mode = Break_mode;
      312 		else do;
      313 		     call com_err_ (error_table_$bad_arg, me, "^a", arg);
      314 		     return;
      315 		end;
      316 	     end;
      317 	end;
      318 	call ioa_ ("Using ^[breakpoint info^;Multics image^;bce^].", examine_mode);
      319 
      320 	if examine_mode = Crash_mode then do;
      321 	     reg_ptrs (1) = addr (toehold$.mc_.prs (0));
      322 	     reg_ptrs (2) = addr (toehold$.mc_.prs (1));
      323 	     reg_ptrs (3) = addr (toehold$.mc_.prs (2));
      324 	     reg_ptrs (4) = addr (toehold$.mc_.prs (3));
      325 	     reg_ptrs (5) = addr (toehold$.mc_.prs (4));
      326 	     reg_ptrs (6) = addr (toehold$.mc_.prs (5));
      327 	     reg_ptrs (7) = addr (toehold$.mc_.prs (6));
      328 	     reg_ptrs (8) = addr (toehold$.mc_.prs (7));
      329 	     reg_ptrs (9) = addr (toehold$.mc_.x (0));
      330 	     reg_ptrs (10) = addr (toehold$.mc_.x (1));
      331 	     reg_ptrs (11) = addr (toehold$.mc_.x (2));
      332 	     reg_ptrs (12) = addr (toehold$.mc_.x (3));
      333 	     reg_ptrs (13) = addr (toehold$.mc_.x (4));
      334 	     reg_ptrs (14) = addr (toehold$.mc_.x (5));
      335 	     reg_ptrs (15) = addr (toehold$.mc_.x (6));
      336 	     reg_ptrs (16) = addr (toehold$.mc_.x (7));
      337 	     reg_ptrs (17) = addr (toehold$.mc_.a);
      338 	     reg_ptrs (18) = addr (toehold$.mc_.q);
      339 	     reg_ptrs (19) = addr (toehold$.mc_.e);
      340 	     reg_ptrs (20) = addr (toehold$.mc_.t);
      341 	     reg_ptrs (21) = addr (toehold$.mc_.ralr);
      342 	     reg_ptrs (22) = addr (toehold$.mc_.fault_reg);
      343 	     reg_ptrs (23) = addr (toehold$.mc_.ext_fault_reg);
      344 	     reg_ptrs (24) = addr (toehold$.mode_reg);
      345 	     reg_ptrs (25) = addr (toehold$.cache_mode_reg);
      346 	     reg_ptrs (26) = addr (toehold$.multics_state.dbr);
      347 	     reg_ptrs (27) = addr (toehold$.bar);
      348 	end;
      349 	else do;
      350 	     reg_ptrs (1) = addr (breakpoint_page_buffer.mc_.prs (0));
      351 	     reg_ptrs (2) = addr (breakpoint_page_buffer.mc_.prs (1));
      352 	     reg_ptrs (3) = addr (breakpoint_page_buffer.mc_.prs (2));
      353 	     reg_ptrs (4) = addr (breakpoint_page_buffer.mc_.prs (3));
      354 	     reg_ptrs (5) = addr (breakpoint_page_buffer.mc_.prs (4));
      355 	     reg_ptrs (6) = addr (breakpoint_page_buffer.mc_.prs (5));
      356 	     reg_ptrs (7) = addr (breakpoint_page_buffer.mc_.prs (6));
      357 	     reg_ptrs (8) = addr (breakpoint_page_buffer.mc_.prs (7));
      358 	     reg_ptrs (9) = addr (breakpoint_page_buffer.mc_.x (0));
      359 	     reg_ptrs (10) = addr (breakpoint_page_buffer.mc_.x (1));
      360 	     reg_ptrs (11) = addr (breakpoint_page_buffer.mc_.x (2));
      361 	     reg_ptrs (12) = addr (breakpoint_page_buffer.mc_.x (3));
      362 	     reg_ptrs (13) = addr (breakpoint_page_buffer.mc_.x (4));
      363 	     reg_ptrs (14) = addr (breakpoint_page_buffer.mc_.x (5));
      364 	     reg_ptrs (15) = addr (breakpoint_page_buffer.mc_.x (6));
      365 	     reg_ptrs (16) = addr (breakpoint_page_buffer.mc_.x (7));
      366 	     reg_ptrs (17) = addr (breakpoint_page_buffer.mc_.a);
      367 	     reg_ptrs (18) = addr (breakpoint_page_buffer.mc_.q);
      368 	     reg_ptrs (19) = addr (breakpoint_page_buffer.mc_.e);
      369 	     reg_ptrs (20) = addr (breakpoint_page_buffer.mc_.t);
      370 	     reg_ptrs (21) = addr (breakpoint_page_buffer.mc_.ralr);
      371 	     reg_ptrs (22) = addr (breakpoint_page_buffer.mc_.fault_reg);
      372 	     reg_ptrs (23) = addr (breakpoint_page_buffer.mc_.ext_fault_reg);
      373 	     reg_ptrs (24) = addr (breakpoint_page_buffer.mode_reg);
      374 	     reg_ptrs (25) = addr (breakpoint_page_buffer.cache_mode_reg);
      375 	     reg_ptrs (26) = addr (breakpoint_page_buffer.dbr);
      376 	     reg_ptrs (27) = addr (breakpoint_page_buffer.bar);
      377 	end;
      378 
      379 	bce_probe_data.my_seg_info_ptr = addr (my_seg_info);
      380 	sltp = addr (slt$);
      381 	bce_probe_data.address.type = 0;
      382 	do arg_index = 1 to dimension (arg_str_ptrs, 1);
      383 	     arg_list.arg_ptrs (arg_index * 2 - 1) = addr (arg_str_ptrs (arg_index));
      384 	     arg_list.arg_ptrs (arg_index * 2) = addr (arg_str_lens (arg_index));
      385 	end;
      386 
      387 	call bce_appending_simulation$init (examine_mode ^= Bce_mode, code);
      388 	if examine_mode ^= Bce_mode then my_dbr = toehold$.multics_state.dbr;
      389 	else my_dbr = sys_boot_info$bce_dbr;
      390 	my_initial_dbr = my_dbr;
      391 	call new_dbr (my_dbr);
      392 
      393 	breakpoint_absadr = absadr (addr (breakpoint_page$), (0));
      394 	breakpoint_at = null;
      395 	if examine_mode = Break_mode then do;
      396 	     call bce_appending_simulation$get_absolute (breakpoint_absadr, size (breakpoint_page_buffer), addr (breakpoint_page_buffer), code);
      397 	     if code ^= 0 then do;
      398 		call com_err_ (code, me, "Cannot process break info.");
      399 		return;
      400 	     end;
      401 	     scup = addr (breakpoint_page_buffer.mc_.scu);
      402 	     breakpoint_at = addrel (baseptr (bin (scu.ppr.psr, 15)), bin (scu.ilc, 18) - 1); /* the drl - start of breakpoint info */
      403 	     call bce_appending_simulation$new_segment (segno (breakpoint_at), bce_probe_data.my_seg_info_ptr, code);
      404 	     if code = 0 then do;
      405 		breakpoint_ptr = addr (buffer);
      406 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, wordno (breakpoint_at), size (breakpoint), breakpoint_ptr, code);
      407 		if code = 0 then do;
      408 		     breakpoint_at = breakpoint.original_instr_ptr;
      409 		     call ioa_ ("Break before ^a.", bce_segptr_to_name_ (breakpoint_at));
      410 		end;
      411 		else breakpoint_at = null;
      412 	     end;
      413 	     else breakpoint_at = null;
      414 	end;
      415 
      416 	line_len = 0;
      417 	on sub_request_abort_ begin;
      418 	     line_len = 0;
      419 	     go to request_done;
      420 	end;
      421 	do while ("1"b);
      422 	     string_len = 0;
      423 	     do while (string_len = 0);		/* find a command name */
      424 		do while (line_len = 0);		/* get a line */
      425 		     line_ptr = addr (line_buffer);
      426 		     code = 1;
      427 		     do while (code ^= 0);
      428 			call bce_data$get_line (addr (bce_data$get_line), addr (line_buffer), length (line_buffer), line_len, code);
      429 			if code ^= 0 then call line_error_code (code, Reading_a_line);
      430 		     end;
      431 		end;
      432 
      433 /* extract command name */
      434 
      435 		call get_string;
      436 		if string_len = 0 then do;		/* we have found a delimiter */
      437 		     if substr (line, 1, 1) = ";" | substr (line, 1, 1) = "
      438 " /* NL */ then do;
      439 			line_len = line_len - 1;	/* pass ; or NL */
      440 			line_ptr = addcharno (line_ptr, 1);
      441 		     end;
      442 		     else call line_error (Improper_syntax_in_line);
      443 		end;
      444 	     end;
      445 
      446 	     do req_index = 1 to dimension (requests, 1) while (requests (req_index) ^= string);
      447 	     end;
      448 	     if req_index > dimension (requests, 1) then call line_error (Unrecognizable_request);
      449 	     else go to do_request (req_index);
      450 
      451 do_request (1 /* b_req */):
      452 
      453 	     go to do_request (2 /* before_req */);
      454 
      455 do_request (2 /* before_req */): begin;
      456 
      457 dcl  bkpt_num			fixed bin;	/* loop counter */
      458 dcl  1 bkpt_tra_instr		aligned based (addr (old_instr_buffer)),
      459        2 offset			fixed bin (18) uns unal, /* tra instruction that the breakpoint becomes */
      460        2 op			bit (18) unal;
      461 dcl  eis_len			fixed bin;	/* num of eis descrs */
      462 dcl  instr_delta			fixed bin (18);	/* amt to reloacte instr being broken at */
      463 dcl  instr_len			fixed bin;	/* of instr being reloacted */
      464 dcl  instr_num			fixed bin;	/* loop counter */
      465 dcl  instr_ptr			ptr;		/* to instruction to set break at */
      466 
      467 		call pass_white;
      468 		if line_len > 0 then
      469 		     if substr (line, 1, 1) ^= ";" & substr (line, 1, 1) ^= "
      470 " /* nl */ then call get_address;
      471 		if bce_probe_data.address.type ^= Virtual then call line_error (Address_type_must_be_virtual);
      472 		call check_no_more_args;
      473 
      474 		sltp = addr (crash_slt$);
      475 		sltep = addr (slt.seg (bce_probe_data.address.segnum));
      476 		bce_probe_data.address.error_name = bce_segnum_to_name_ (bce_probe_data.address.segnum);
      477 		if ^slte.breakpointable then call line_error_arg (Segment_not_breakpointable, bce_probe_data.address.error_name);
      478 
      479 		call bce_appending_simulation$new_segment (bce_probe_data.address.segnum, bce_probe_data.my_seg_info_ptr, code);
      480 		if code ^= 0 then go to before_bad_access;
      481 		bkpt_page_ptr = addr (buffer);
      482 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, my_seg_info.size - 1024, 1024, bkpt_page_ptr, code);
      483 		if code ^= 0 then go to before_bad_access;
      484 		instr_ptr = addrel (baseptr (bce_probe_data.address.segnum), bce_probe_data.address.wordnum);
      485 		do bkpt_num = 1 to dimension (bkpt_page.bkpts, 1);
      486 		     if bkpt_page.bkpts (bkpt_num).original_instr_ptr = instr_ptr then call line_error (Break_already_set);
      487 		end;
      488 		do bkpt_num = 1 to dimension (bkpt_page.bkpts, 1) while (unspec (bkpt_page.bkpts (bkpt_num)) ^= "0"b);
      489 		end;
      490 		if bkpt_num > dimension (bkpt_page.bkpts, 1) then call line_error_arg (Too_many_breakpoints_in_segment, bce_probe_data.address.error_name);
      491 		breakpoint_ptr = addr (bkpt_page.bkpts (bkpt_num));
      492 		instr_delta = my_seg_info.size - 1024 + wordno (addr (breakpoint.instructions)) - wordno (bkpt_page_ptr) - bce_probe_data.address.wordnum;
      493 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, bce_probe_data.address.wordnum, size (old_instr_buffer), addr (old_instr_buffer), code);
      494 		if code ^= 0 then go to before_bad_access;
      495 		do instr_num = 1 to dimension (breakpoint.instructions, 1);
      496 		     breakpoint.instructions (instr_num) = NOP;
      497 		end;
      498 
      499 		instr_len = bce_inst_length_ (addr (old_instr_buffer), eis_len);
      500 		if instr_len = 0 then go to bad_instr_error;
      501 		call bce_relocate_instruction_ (addr (old_instr_buffer), addr (breakpoint.instructions), -instr_delta, instr_len, eis_len, code);
      502 		if code ^= 0 then
      503 bad_instr_error:	     call line_error (Instruction_cannot_be_breakpointed);
      504 		breakpoint.breakpoint_drl = DRL_1;
      505 		breakpoint.tra_back = TRA;
      506 		breakpoint.tra_back_offset = instr_len + bce_probe_data.address.wordnum;
      507 		breakpoint.original_instr_ptr = instr_ptr;
      508 		breakpoint.original_instr = old_instr_buffer (1);
      509 
      510 		call bce_appending_simulation$put_virtual (bce_probe_data.my_seg_info_ptr,
      511 		     my_seg_info.size - 1024 + wordno (breakpoint_ptr) - wordno (bkpt_page_ptr),
      512 		     size (breakpoint), breakpoint_ptr, code);
      513 		if code ^= 0 then go to before_bad_access;
      514 		bkpt_tra_instr.op = TRA;
      515 		bkpt_tra_instr.offset = instr_delta - 1 + bce_probe_data.address.wordnum;
      516 		call bce_appending_simulation$put_virtual (bce_probe_data.my_seg_info_ptr, bce_probe_data.address.wordnum, 1, addr (old_instr_buffer), code);
      517 		if code ^= 0 then
      518 before_bad_access:	     call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      519 		call ioa_ ("Break set before ^a.", bce_segptr_to_name_ (instr_ptr));
      520 		go to request_done;
      521 	     end;
      522 
      523 do_request (3 /* c_req */):
      524 	     go to do_request (4 /* continue_req */);
      525 
      526 do_request (4 /* continue_req */):
      527 	     call check_no_more_args;
      528 	     if ^(sys_info$collection_1_phase = CRASH_INITIALIZATION | sys_info$collection_1_phase = BCE_CRASH_INITIALIZATION) then call line_error (No_image_to_restart);
      529 	     call bce_continue;
      530 	     go to request_done;
      531 
      532 do_request (5 /* dbr_req */): begin;
      533 
      534 dcl  dbr_value			bit (72) aligned;	/* new value being built */
      535 dcl  dbr_word			fixed bin (35);	/* single part of new value */
      536 
      537 		call get_string;
      538 		if string_len = 0 then do;
      539 		     call check_no_more_args;
      540 		     my_dbr = my_initial_dbr;
      541 		     call new_dbr (my_dbr);
      542 		     call ioa_ ("dbr = ^24.3b", my_dbr);
      543 		     goto request_done;
      544 		end;
      545 		dbr_word = cv_integer_string_check_ (string, Base8, code);
      546 		if code ^= 0 then go to bad_octal;
      547 		dbr_value = my_dbr;
      548 		substr (dbr_value, 1, 36) = unspec (dbr_word);
      549 		call get_string;
      550 		if string_len > 0 then do;
      551 		     dbr_word = cv_integer_string_check_ (string, Base8, code);
      552 		     if code ^= 0 then
      553 bad_octal:		call line_error (Bad_octal_value);
      554 		     substr (dbr_value, 37, 36) = unspec (dbr_word);
      555 		end;
      556 		call check_no_more_args;
      557 		call new_dbr (dbr_value);
      558 		go to request_done;
      559 	     end;
      560 
      561 do_request (6 /* display_req */): begin;
      562 
      563 dcl  bits_left_over			fixed bin;	/* amt of previous buffer we couldn't display */
      564 dcl  buffer_data_ptr		ptr;		/* where in buffer data starts */
      565 dcl  data_address			fixed bin (26);	/* relative to address type */
      566 dcl  data_bits_done			fixed bin (24);	/* normally for instruction mode - => how many bits not done because of chance that instr wrapped onto next buffer */
      567 dcl  data_label			fixed bin (26);	/* for display */
      568 dcl  data_length			fixed bin (24);	/* in bits */
      569 dcl  data_part_bits			fixed bin (24);	/* number of bits in this bunch to dump */
      570 dcl  data_part_words		fixed bin (18);	/* number of words in this bunch to dump */
      571 dcl  display_buffer_ptr		ptr;		/* start of bits to display taking into account amount scrolled from previous buffer */
      572 dcl  mode				fixed bin;	/* display mode */
      573 
      574 		call get_address;
      575 		mode = bce_probe_data.address.default_mode;
      576 		data_length = bce_probe_data.address.default_len;
      577 		call get_string;
      578 		if string_len > 0 then do;
      579 		     if string = "a" then do;
      580 			mode = Ascii;
      581 			data_length = 9;
      582 		     end;
      583 		     else if string = "d" then mode = Decimal;
      584 		     else if string = "i" then mode = Instruction;
      585 		     else if string = "o" then mode = Octal;
      586 		     else if string = "p" then do;
      587 			mode = Pointer;
      588 			data_length = 72;
      589 		     end;
      590 		     else call line_error (Unknown_mode);
      591 		     call get_string;
      592 		     if string_len > 0 then
      593 			if string = "*" & bce_probe_data.address.type = Virtual then
      594 			     data_length = 36 * (my_seg_info.size - bce_probe_data.address.wordnum);
      595 			else do;
      596 			     data_length = cv_integer_string_check_ (string, Base10, code);
      597 			     if code ^= 0 then call line_error (Bad_decimal_value);
      598 			     if mode = Ascii then data_length = data_length * 9;
      599 			     else if mode = Pointer then data_length = data_length * 72;
      600 			     else data_length = data_length * 36;
      601 			end;
      602 		end;
      603 		call check_no_more_args;
      604 		if bce_probe_data.address.type = Register then do;
      605 		     data_length = min (data_length, bce_probe_data.address.default_len);
      606 		     call display (bce_probe_data.address.reg_ptr, data_length, -1, mode, data_bits_done, "0"b);
      607 		end;
      608 		else do;
      609 		     data_address = bce_probe_data.address.wordnum;
      610 		     data_label = data_address;
      611 		     bits_left_over = 0;
      612 		     do while (data_length > 0);	/* do a page at a time */
      613 			data_part_words = 1024 - mod (data_address, 1024);
      614 			buffer_data_ptr = addrel (addr (buffer), mod (data_address, 1024));
      615 			data_part_bits = min (36 * data_part_words, data_length);
      616 			data_part_words = divide (data_part_bits + 35, 36, 18);
      617 			call fetch_ (buffer_data_ptr, data_part_words, data_address - bce_probe_data.address.wordnum, code);
      618 			if code ^= 0 then call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      619 			display_buffer_ptr = addwordno (buffer_data_ptr, -divide (bits_left_over, 36, 17));
      620 			call display (display_buffer_ptr, data_part_bits + bits_left_over, data_label, mode, data_bits_done, data_part_bits < data_length);
      621 			data_length = data_length - data_part_bits;
      622 			data_address = data_address + data_part_words;
      623 			bits_left_over = data_part_bits - data_bits_done;
      624 			data_label = data_label + data_part_words - divide (bits_left_over, 36, 17);
      625 			if bits_left_over > 0 then substr (left_from_before, length (left_from_before) - bits_left_over + 1) = substr (buffer, length (buffer) - bits_left_over + 1); /* scroll bits */
      626 		     end;
      627 		end;
      628 		go to request_done;
      629 	     end;
      630 
      631 do_request (7 /* dot_req */):
      632 	     call check_no_more_args;
      633 	     call ioa_ ("probe: Using ^[breakpoint info^;Multics image^;bce^], dbr = ^24.3b", examine_mode, my_dbr);
      634 	     go to request_done;
      635 
      636 do_request (8 /* ds_req */):
      637 	     go to do_request (6 /* display_req */);
      638 
      639 do_request (9 /* l_req */):
      640 	     go to do_request (10 /* let_req */);
      641 
      642 do_request (10 /* let_req */): begin;
      643 dcl  data_length			fixed bin (24);	/* in bits */
      644 dcl  register			bit (data_length) based (bce_probe_data.address.reg_ptr); /* overlay to overwrite register */
      645 dcl  starting_bit			fixed bin;	/* first bit in buffer containing data to move into patch area */
      646 
      647 		call get_address;
      648 		starting_bit = 1;
      649 		if bce_probe_data.address.type = Disk then do;
      650 		     if bce_probe_data.address.wordnum < 0 | bce_probe_data.address.wordnum > 1023 then call line_error (Bad_page_offset);
      651 		     call read_disk (bce_probe_data.address.pvtx, bce_probe_data.address.record_num, addr (buffer), code);
      652 		     if code ^= 0 then call line_error_arg_code (code, Reading_disk, bce_probe_data.address.error_name);
      653 		     starting_bit = bce_probe_data.address.wordnum * 36 + 1;
      654 		end;
      655 		call pass_white;
      656 		data_length = 0;
      657 		if substr (line, 1, 1) ^= "=" then call line_error (Missing_equals);
      658 		line_len = line_len - 1;
      659 		line_ptr = addcharno (line_ptr, 1);
      660 		call get_value;
      661 		if starting_bit + data_length > length (buffer) then go to let_values_too_long;
      662 		substr (buffer, starting_bit + data_length, value.length) = substr (value.data, 1, value.length);
      663 		data_length = data_length + value.length;
      664 		call pass_white;
      665 		do while (substr (line, 1, 1) ^= ";" & substr (line, 1, 1) ^= "
      666 " /* NL */);
      667 		     call get_value;
      668 		     if starting_bit + data_length > length (buffer) then
      669 let_values_too_long:	call line_error (Values_being_let_too_long);
      670 		     substr (buffer, starting_bit + data_length, value.length) = substr (value.data, 1, value.length);
      671 		     data_length = data_length + value.length;
      672 		     call pass_white;
      673 		end;
      674 		if bce_probe_data.address.type = Virtual then do;
      675 		     call bce_appending_simulation$put_virtual (bce_probe_data.my_seg_info_ptr, bce_probe_data.address.wordnum, divide (data_length, 36, 18), addr (buffer), code);
      676 		     if code ^= 0 then go to let_bad_access;
      677 		end;
      678 		else if bce_probe_data.address.type = Absolute then do;
      679 		     call bce_appending_simulation$put_absolute (bce_probe_data.address.wordnum, divide (data_length, 36, 18), addr (buffer), code);
      680 		     if code ^= 0 then
      681 let_bad_access:		call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      682 		end;
      683 		else if bce_probe_data.address.type = Register then do;
      684 		     data_length = min (data_length, bce_probe_data.address.default_len);
      685 		     if bce_probe_data.address.default_len > 36 then starting_bit = 72 - mod (data_length - 1, 72);
      686 		     else starting_bit = 36 - mod (data_length - 1, 36);
      687 		     register = substr (buffer, starting_bit, data_length);
      688 		     if examine_mode = Break_mode then do;
      689 			call bce_appending_simulation$put_absolute (breakpoint_absadr, size (breakpoint_page_buffer), addr (breakpoint_page_buffer), code);
      690 			if code ^= 0 then call line_error_code (code, Accessing_breakpoint_page);
      691 		     end;
      692 		end;
      693 		else do;				/* Disk */
      694 		     call write_disk (bce_probe_data.address.pvtx, bce_probe_data.address.record_num, addr (buffer), code);
      695 		     if code ^= 0 then call line_error_arg_code (code, Writing_disk, bce_probe_data.address.error_name);
      696 		end;
      697 		go to request_done;
      698 	     end;
      699 
      700 do_request (11 /* list_requests_req */):
      701 	     call check_no_more_args;
      702 	     call ioa_ ("Requests are:");
      703 	     call ioa_ ("before, b         continue, c       dbr");
      704 	     call ioa_ ("display, ds       let, l            list_requests, lr");
      705 	     call ioa_ ("mc                name              proc");
      706 	     call ioa_ ("quit, q           reset, r          segno");
      707 	     call ioa_ ("stack, sk         status, st");
      708 	     go to request_done;
      709 
      710 do_request (12 /* lr_req */):
      711 	     go to do_request (11 /* list_requests_req */);
      712 
      713 do_request (13 /* mc_req */): begin;
      714 
      715 dcl  j				fixed bin;
      716 dcl  long				bit (1) aligned;
      717 dcl  ptr_from_mc			ptr;
      718 dcl  time				char (32);
      719 
      720 		call get_address;
      721 		long = "0"b;
      722 		call get_string;
      723 		if string_len > 0 then
      724 		     if string = "lg" | string = "long" then long = "1"b;
      725 		     else call line_error (Unrecognizable_option);
      726 		call check_no_more_args;
      727 		mcp = addr (buffer);
      728 		scup = addr (mcp -> mc.scu);
      729 
      730 		call fetch_ (mcp, size (mc), 0, code);
      731 		if code ^= 0 then call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      732 		if long then do;
      733 		     do j = 0 to 7;
      734 			ptr_from_mc = validate_ptr (unspec (mc.prs (j)));
      735 			call ioa_ ("pr^d ^4a^2x^20p^a", j, prs (j), ptr_from_mc, bce_segptr_to_name_ (ptr_from_mc));
      736 		     end;
      737 		     call ioa_;
      738 		     call ioa_ ("x0 ^6o^3xx1 ^6o^3xx2 ^6o^3xx3 ^6o", fixed (mc.x (0), 18), fixed (mc.x (1), 18),
      739 			fixed (mc.x (2), 18), fixed (mc.x (3), 18));
      740 		     call ioa_ ("x4 ^6o^3xx5 ^6o^3xx6 ^6o^3xx7 ^6o", fixed (mc.x (4), 18), fixed (mc.x (5), 18),
      741 			fixed (mc.x (6), 18), fixed (mc.x (7), 18));
      742 		     call ioa_ ("a ^w  q ^w  e ^o", fixed (mc.a, 35), fixed (mc.q, 35), fixed (mc.e, 8));
      743 		     call ioa_ ("Timer reg - ^o, Ring alarm reg - ^1.3b", fixed (mc.regs.t, 27), mc.regs.ralr);
      744 		     if mc.fault_reg ^= "0"b then	/* display fault reg if present */
      745 			call ioa_ ("Fault reg - ^12.3b", mc.fault_reg);
      746 		end;
      747 		call ioa_ ("^/SCU Data:^/");
      748 		call bce_display_scu_ (scup, bce_probe_data.address.wordnum + wordno (scup) - wordno (mcp), "0"b);
      749 		if mc.fault_time then do;		/* print out time of day if available */
      750 		     call date_time_ (fixed (mc.fault_time, 71), time);
      751 		     call ioa_ ("Time stored: ^a (^18.3b)", time, mc.fault_time);
      752 		end;
      753 		call ioa_ ("Ring:^10x^o", fixed (scu.ppr.prr, 3));
      754 
      755 		if substr (scu.even_inst, 28, 1) & long then do; /* if bit 27 of instruction on display spl data */
      756 		     call ioa_ ("^/EIS Pointers and Lengths:^/");
      757 		     call ioa_ ("^6x^-^w  ^w  ^w  ^w^/^-^w  ^w  ^w  ^w", mc.eis_info (0),
      758 			mc.eis_info (1), mc.eis_info (2), mc.eis_info (3), mc.eis_info (4), mc.eis_info (5), mc.eis_info (6), mc.eis_info (7));
      759 		end;
      760 		go to request_done;
      761 	     end;
      762 
      763 do_request (14 /* name_req */): begin;
      764 
      765 dcl  segnum			fixed bin (15);	/* segnum supplied */
      766 
      767 		call get_string;
      768 		if string_len = 0 then call line_error (Segment_number_missing);
      769 		segnum = cv_integer_string_check_ (string, Base8, code);
      770 		if code ^= 0 then call line_error (Bad_octal_value);
      771 		call check_no_more_args;
      772 		call ioa_ ("^a", bce_segnum_to_name_ (segnum));
      773 		go to request_done;
      774 	     end;
      775 
      776 do_request (15 /* proc_req */): begin;
      777 
      778 dcl  apte_num			fixed bin;
      779 dcl  1 my_apte			aligned like apte;
      780 
      781 		call get_string;
      782 		if string_len = 0 then call line_error (Apte_number_missing);
      783 		apte_num = cv_integer_string_check_ (string, Base10, code);
      784 		if apte_num < 1 | code ^= 0 then call line_error (Bad_decimal_value);
      785 		call check_no_more_args;
      786 		tcmp = addr (tc_data$);
      787 		call bce_appending_simulation$new_segment (segno (tcmp), bce_probe_data.my_seg_info_ptr, code);
      788 		if code ^= 0 then go to bad_apte;
      789 		aptep = addr (my_apte);
      790 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, wordno (addr (tcm.apt)) + (apte_num - 1) * size (apte), size (apte), aptep, code);
      791 		if code ^= 0 then go to bad_apte;
      792 		if apte.state = Empty_apte then
      793 bad_apte:		     call line_error (Bad_apte);
      794 		call ioa_ ("dbr = ^24.3b", unspec (apte.dbr));
      795 		call new_dbr (unspec (apte.dbr));
      796 		go to request_done;
      797 	     end;
      798 
      799 do_request (16 /* q_req */):
      800 	     go to do_request (17 /* quit_req */);
      801 
      802 do_request (17 /* quit_req */):
      803 	     call check_no_more_args;
      804 	     go to finish;
      805 
      806 do_request (18 /* r_req */):
      807 	     go to do_request (19 /* reset_req */);
      808 
      809 do_request (19 /* reset_req */): begin;
      810 
      811 dcl  bkpt_num			fixed bin;	/* loop counter */
      812 dcl  instr_ptr			ptr;		/* to instruction to set break at */
      813 
      814 		call pass_white;
      815 		instr_ptr = null;
      816 		if line_len > 0 then
      817 		     if substr (line, 1, 1) ^= ";" & substr (line, 1, 1) ^= "
      818 " /* nl */ then do;
      819 			call get_address;
      820 			if bce_probe_data.address.type ^= Virtual then call line_error (Address_type_must_be_virtual);
      821 			instr_ptr = addrel (baseptr (bce_probe_data.address.segnum), bce_probe_data.address.wordnum);
      822 		     end;
      823 		call check_no_more_args;
      824 
      825 		if instr_ptr = null then do;
      826 		     if breakpoint_at = null then call line_error (No_current_break);
      827 		     instr_ptr = breakpoint_at;
      828 		     bce_probe_data.address.segnum = segno (instr_ptr);
      829 		     bce_probe_data.address.wordnum = wordno (instr_ptr);
      830 		     bce_probe_data.address.type = Virtual;
      831 		     call bce_appending_simulation$new_segment (bce_probe_data.address.segnum, bce_probe_data.my_seg_info_ptr, code);
      832 		     if code ^= 0 then go to reset_bad_access;
      833 		end;
      834 
      835 		sltp = addr (crash_slt$);
      836 		sltep = addr (slt.seg (bce_probe_data.address.segnum));
      837 		if ^slte.breakpointable then call line_error_arg (Segment_not_breakpointable, bce_probe_data.address.error_name);
      838 
      839 		bkpt_page_ptr = addr (buffer);
      840 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, my_seg_info.size - 1024, 1024, bkpt_page_ptr, code);
      841 		if code ^= 0 then go to reset_bad_access;
      842 		do bkpt_num = 1 to dimension (bkpt_page.bkpts, 1) while (bkpt_page.bkpts (bkpt_num).original_instr_ptr ^= instr_ptr);
      843 		end;
      844 		if bkpt_num > dimension (bkpt_page.bkpts, 1) then call line_error (No_break_set);
      845 		breakpoint_ptr = addr (bkpt_page.bkpts (bkpt_num));
      846 		if instr_ptr = breakpoint_at then do;	/* fix up scu data for breakpoint restart since we will move breakpoint code */
      847 		     scup = addr (breakpoint_page_buffer.mc_.scu);
      848 		     scu.ilc = bit (bin (bce_probe_data.address.wordnum, 18), 18); /* redo instr */
      849 		     call bce_appending_simulation$put_absolute (breakpoint_absadr, size (breakpoint_page_buffer), addr (breakpoint_page_buffer), code);
      850 		     if code ^= 0 then go to reset_bad_access;
      851 		     breakpoint_at = null;
      852 		end;
      853 		call bce_appending_simulation$put_virtual (bce_probe_data.my_seg_info_ptr, bce_probe_data.address.wordnum, 1, addr (breakpoint.original_instr), code);
      854 		if code ^= 0 then go to reset_bad_access;
      855 		unspec (breakpoint) = "0"b;
      856 		call bce_appending_simulation$put_virtual (bce_probe_data.my_seg_info_ptr,
      857 		     my_seg_info.size - 1024 + wordno (breakpoint_ptr) - wordno (bkpt_page_ptr),
      858 		     size (breakpoint), breakpoint_ptr, code);
      859 		if code ^= 0 then
      860 reset_bad_access:	     call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      861 		call ioa_ ("Break reset before ^a.", bce_segptr_to_name_ (instr_ptr));
      862 		go to request_done;
      863 	     end;
      864 
      865 do_request (20 /* segno_req */): begin;
      866 
      867 dcl  segname			char (32);
      868 dcl  segnum			fixed bin (15);	/* segnum supplied */
      869 
      870 		call get_string;
      871 		if string_len = 0 then call line_error (Name_missing);
      872 		segname = string;
      873 		call check_no_more_args;
      874 		call bce_name_to_segnum_ (segname, segnum, code);
      875 		if code ^= 0 then call line_error_arg_code (code, Name, segname);
      876 		call ioa_ ("^o", segnum);
      877 		go to request_done;
      878 	     end;
      879 
      880 do_request (21 /* sk_req */):
      881 	     go to do_request (23 /* stack_req */);
      882 
      883 do_request (22 /* st_req */):
      884 	     go to do_request (24 /* status_req */);
      885 
      886 do_request (23 /* stack_req */): begin;
      887 
      888 dcl  current_sp			ptr;
      889 dcl  last_sp			ptr;
      890 dcl  prev_sp			ptr;
      891 
      892 		call get_address;
      893 		if bce_probe_data.address.type ^= Virtual then call line_error (Address_type_must_be_virtual);
      894 		call check_no_more_args;
      895 		prev_sp = baseptr (bce_probe_data.address.segnum);
      896 		current_sp = ptr (baseptr (bce_probe_data.address.segnum), bce_probe_data.address.wordnum);
      897 		sb, sp = addr (buffer);
      898 		call fetch_ (sb, size (stack_header), -bce_probe_data.address.wordnum, code);
      899 		if code ^= 0 then go to stack_bad_access;
      900 		last_sp = validate_ptr (unspec (stack_header.stack_end_ptr));
      901 		if wordno (current_sp) = 0 then current_sp = validate_ptr (unspec (stack_header.stack_begin_ptr));
      902 		do while ("1"b);
      903 		     if wordno (current_sp) < wordno (prev_sp) + 16 |
      904 			segno (current_sp) ^= segno (last_sp) |
      905 			wordno (current_sp) >= wordno (last_sp) then do;
      906 			call ioa_ ("Bad next stack frame ptr ^p", current_sp);
      907 			go to request_done;
      908 		     end;
      909 		     call fetch_ (sp, size (stack_frame), wordno (current_sp) - bce_probe_data.address.wordnum, code);
      910 		     if code ^= 0 then
      911 stack_bad_access:		call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
      912 		     call ioa_ ("frame ptr:  ^p", current_sp);
      913 		     call ioa_ ("arg ptr:    ^p", validate_ptr (unspec (stack_frame.arg_ptr)));
      914 		     call ioa_ ("return ptr: ^a", bce_segptr_to_name_ (validate_ptr (unspec (stack_frame.return_ptr))));
      915 		     call ioa_ ("entry ptr:  ^a^/", bce_segptr_to_name_ (validate_ptr (unspec (stack_frame.entry_ptr))));
      916 		     prev_sp = current_sp;
      917 		     current_sp = validate_ptr (unspec (stack_frame.next_sp));
      918 		end;
      919 		go to request_done;
      920 	     end;
      921 
      922 do_request (24 /* status_req */): begin;
      923 
      924 dcl  any_breaks			bit (1) aligned;
      925 dcl  segnum			fixed bin (15);
      926 
      927 		call pass_white;
      928 		segnum = -1;
      929 		call get_string;
      930 		if string_len > 0 then do;
      931 		     segnum = cv_integer_string_check_ (string, Base8, code);
      932 		     if code ^= 0 then do;		/* name? */
      933 			call bce_name_to_segnum_ (string, segnum, code);
      934 			if code ^= 0 then call line_error (Unrecognizable_address);
      935 		     end;
      936 		end;
      937 
      938 		call check_no_more_args;
      939 
      940 		any_breaks = "0"b;
      941 		if segnum < 0 then do;
      942 		     sltp = addr (crash_slt$);
      943 		     do segnum = slt.first_sup_seg to slt.last_sup_seg, slt.first_init_seg to slt.last_init_seg;
      944 			call status (segnum, "1"b, any_breaks);
      945 		     end;
      946 		end;
      947 		else call status (segnum, "0"b, any_breaks);
      948 		if ^any_breaks then call ioa_ ("No breaks set.");
      949 		go to request_done;
      950 	     end;
      951 
      952 request_done:
      953 	end;
      954 finish:	return;
      955 
      956 check_no_more_args: proc;
      957 
      958 /* make sure that only white space follows */
      959 
      960 	call pass_white;
      961 	if line_len > 0 then
      962 	     if substr (line, 1, 1) ^= ";" & substr (line, 1, 1) ^= "
      963 " then call line_error (Unexpected_args_follow);
      964 	string_len = 0;				/* don't confuse error messages */
      965 	return;
      966      end;
      967 
      968 display: proc (p_data_ptr, p_data_bit_lth, p_word_label, mode, data_bits_done, partial);
      969 
      970 /* display a buffer in the current mode for the given bit length */
      971 
      972 dcl  data_area			bit (4 * 36) aligned; /* area in whcih to place and nicely align data for display */
      973 dcl  data_area_ptr			ptr;		/* ptr to place in data_area to move */
      974 dcl  data_bits_done			fixed bin (24);
      975 dcl  data_in_ascii			(item_num) char (1) unal based (addr (data_area));
      976 dcl  data_in_decimal		(item_num) fixed bin (35) aligned based (addr (data_area));
      977 dcl  data_in_octal			(item_num) bit (36) aligned based (addr (data_area));
      978 dcl  data_in_pointer		(item_num) ptr aligned based (addr (data_area));
      979 dcl  data_bit_lth			fixed bin (24);	/* to display this line */
      980 dcl  data_ptr			ptr;		/* to user area to move and display for this line */
      981 dcl  item_num			fixed bin;	/* how many display items on this line */
      982 dcl  mode				fixed bin parameter;/* display mode */
      983 dcl  p_data_bit_lth			fixed bin (24) parameter; /* total bits to display */
      984 dcl  p_data_ptr			ptr parameter;	/* to user area to move and display */
      985 dcl  p_word_label			fixed bin (26) parameter; /* address label for first word, auto incr, < 0 => no label */
      986 dcl  partial			bit (1) aligned;	/* if we approach the end of data and we can not print a full line or instruction,
      987*						stop and return how much done */
      988 dcl  this_data_lth			fixed bin;	/* data to move for this line */
      989 dcl  user_data			bit (this_data_lth) based (data_ptr); /* data being moved for this line */
      990 dcl  word_label			fixed bin (26);	/* label for this line */
      991 
      992 	data_bit_lth = p_data_bit_lth;
      993 	data_bits_done = 0;
      994 	data_ptr = p_data_ptr;
      995 	word_label = p_word_label;
      996 	do while (data_bit_lth > 0);
      997 	     this_data_lth = min (4 * 36, data_bit_lth);
      998 	     data_area = "0"b;
      999 	     if mode = Ascii then data_area_ptr = addbitno (addr (data_area), 8 - mod (this_data_lth - 1, 9));
     1000 	     else if mode = Pointer then data_area_ptr = addbitno (addr (data_area), 71 - mod (this_data_lth - 1, 72));
     1001 	     else data_area_ptr = addbitno (addr (data_area), 35 - mod (this_data_lth - 1, 36));
     1002 	     data_area_ptr -> user_data = user_data;	/* copy user data right aligned into buffer */
     1003 	     if mode = Ascii then item_num = divide (this_data_lth + 8, 9, 17);
     1004 	     else if mode = Pointer then item_num = divide (this_data_lth + 71, 72, 17);
     1005 	     else item_num = divide (this_data_lth + 35, 36, 17);
     1006 	     if partial & this_data_lth < 4 * 36 then return; /* stop when we can't be sure all of data is present */
     1007 	     if mode = Ascii then call ioa_ ("^[^9o   ^;^s^]^v(^1a^)", word_label >= 0, word_label, item_num, data_in_ascii);
     1008 	     else if mode = Decimal then call ioa_ ("^[^9o   ^;^s^]^v(^12d   ^)", word_label >= 0, word_label, item_num, data_in_decimal);
     1009 	     else if mode = Octal then call ioa_ ("^[^9o   ^;^s^]^v(^w   ^)", word_label >= 0, word_label, item_num, data_in_octal);
     1010 	     else if mode = Pointer then call ioa_ ("^[^9o  ^;^s^]^v(^18p  ^)", word_label >= 0, word_label, item_num, data_in_pointer);
     1011 	     else if mode = Instruction then do;
     1012 		call bce_display_instruction_ (data_area_ptr, item_num, word_label);
     1013 		this_data_lth = item_num * 36;
     1014 	     end;
     1015 	     data_bit_lth = data_bit_lth - this_data_lth;
     1016 	     data_ptr = addbitno (data_ptr, this_data_lth);
     1017 	     if word_label >= 0 then word_label = word_label + divide (this_data_lth, 36, 17);
     1018 	     data_bits_done = data_bits_done + this_data_lth;
     1019 	end;
     1020 	return;
     1021      end;
     1022 
     1023 function: proc (entry_var, num_args);
     1024 
     1025 /* extracts from the line num_args args.   A call is generated to the routine 
     1026*supplied with these char strings. */
     1027 
     1028 dcl  arg_index			fixed bin;	/* loop var */
     1029 dcl  entry_var			entry variable;	/* routine to call */
     1030 dcl  num_args			fixed bin;	/* number of args that we must find */
     1031 
     1032 	arg_list.twice_num_args = num_args * 4;		/* 2 * because its a rule; 2 * for ptr and len for each char str arg */
     1033 	call pass_white;
     1034 	if line_len = 0 then go to arg_list_missing;
     1035 	if substr (line, 1, 1) ^= "(" then
     1036 arg_list_missing:
     1037 	     call line_error (Function_arg_list_missing);
     1038 	do arg_index = 1 to num_args;
     1039 	     line_len = line_len - 1;			/* pass ( or , */
     1040 	     line_ptr = addcharno (line_ptr, 1);
     1041 	     call get_string;
     1042 	     if string_len = 0 then go to arg_missing;
     1043 	     arg_str_ptrs (arg_index) = string_ptr;
     1044 	     arg_str_lens (arg_index) = string_len;
     1045 	     call pass_white;
     1046 	     if line_len = 0 then go to arg_missing;
     1047 	     if arg_index = num_args then
     1048 		if substr (line, 1, 1) ^= ")" then call line_error (Improper_arg_list_end_for_function);
     1049 		else ;
     1050 	     else if substr (line, 1, 1) ^= "," then
     1051 arg_missing:
     1052 		call line_error (Function_argument_missing);
     1053 	end;
     1054 	line_len = line_len - 1;			/* pass ) */
     1055 	line_ptr = addcharno (line_ptr, 1);
     1056 
     1057 	call cu_$generate_call (entry_var, addr (arg_list));
     1058 	return;
     1059      end;
     1060 
     1061 fetch_: proc (data_ptr, data_lth, address_offset, code);
     1062 
     1063 dcl  address_offset			fixed bin (26) parameter;
     1064 dcl  buffer			(1024) bit (36) aligned;
     1065 dcl  code				fixed bin (35) parameter;
     1066 dcl  data_area			(data_lth) bit (36) aligned based;
     1067 dcl  data_lth			fixed bin (18);
     1068 dcl  data_ptr			ptr;
     1069 dcl  error_table_$boundviol		fixed bin (35) ext static;
     1070 
     1071 	if bce_probe_data.address.type = Absolute then call bce_appending_simulation$get_absolute (bce_probe_data.address.wordnum + address_offset, data_lth, data_ptr, code);
     1072 	else if bce_probe_data.address.type = Virtual then call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, bce_probe_data.address.wordnum + address_offset, data_lth, data_ptr, code);
     1073 	else if bce_probe_data.address.type = Disk then
     1074 	     if bce_probe_data.address.wordnum + address_offset < 0 | bce_probe_data.address.wordnum + address_offset + data_lth > 1024 then code = error_table_$boundviol;
     1075 	     else do;
     1076 		call read_disk (bce_probe_data.address.pvtx, bce_probe_data.address.record_num, addr (buffer), code);
     1077 		data_ptr -> data_area = addrel (addr (buffer), bce_probe_data.address.wordnum + address_offset) -> data_area;
     1078 	     end;
     1079 	else code = error_table_$bad_arg;
     1080 	return;
     1081      end;
     1082 
     1083 
     1084 get_address: proc;
     1085 
     1086 /* Find the desired address of an object. */
     1087 
     1088 dcl  component			char (32);
     1089 dcl  component_delim_pos		fixed bin;	/* Position of "$". */
     1090 dcl  new_segnum			fixed bin (15);
     1091 dcl  new_wordnum			fixed bin (26);	/* after incrementing */
     1092 dcl  number			fixed bin (35);	/* result of ascii - numeric conversions */
     1093 dcl  offset			char (16);
     1094 dcl  offset_delim_pos		fixed bin;	/* Position of "|", "+", or "-". */
     1095 dcl  seg_id			char (32);
     1096 
     1097 	call get_string;
     1098 	if string_len = 0 then call line_error (Address_missing);
     1099 	if substr (string, 1, 1) = "." then do;		/* relative address */
     1100 	     if bce_probe_data.address.type = 0 then call line_error (No_current_address);
     1101 	     if string_len = 1 then go to done;		/* same addr */
     1102 	     if bce_probe_data.address.type = Register then
     1103 		call line_error (No_offset_may_be_added_to_register_addresses);
     1104 	     if string_len < 3 then call line_error (Missing_offset);
     1105 	     if substr (string, 2, 1) ^= "+" & substr (string, 2, 1) ^= "-" then call line_error (Dot_must_be_followed_by_plus_or_minus);
     1106 	     number = cv_integer_string_check_ (substr (string, 3), Base8, code);
     1107 	     if code ^= 0 then call line_error (Bad_octal_value);
     1108 	     if substr (string, 2, 1) = "+" then new_wordnum = bce_probe_data.address.wordnum + number;
     1109 	     else new_wordnum = bce_probe_data.address.wordnum - number;
     1110 	     if new_wordnum < 0 then call line_error (Offset_makes_address_negative);
     1111 	     bce_probe_data.address.wordnum = new_wordnum;
     1112 	     go to done;
     1113 	end;
     1114 
     1115 /* a new address is desired - wipe out old address */
     1116 
     1117 	bce_probe_data.address.type = 0;
     1118 	bce_probe_data.address.default_mode = Octal;
     1119 	bce_probe_data.address.default_len = 36;
     1120 
     1121 	component_delim_pos = index (string, "$");
     1122 	offset_delim_pos = search (string, "|+-");
     1123 
     1124 	if component_delim_pos > 0 | offset_delim_pos > 0 then do; /* Virtual address */
     1125 	     if offset_delim_pos < component_delim_pos & offset_delim_pos > 0 then call line_error (Invalid_word_offset);
     1126 	     if component_delim_pos > 0 then do;
     1127 		if component_delim_pos = 1 then call line_error (Missing_seg_id);
     1128 		if offset_delim_pos > 0 then do;
     1129 		     if offset_delim_pos = string_len then call line_error (Missing_word_offset);
     1130 		     if offset_delim_pos = component_delim_pos + 1 then call line_error (Missing_component);
     1131 		     seg_id = substr (string, 1, component_delim_pos - 1);
     1132 		     component = substr (string, component_delim_pos + 1, offset_delim_pos - component_delim_pos - 1);
     1133 		     offset = substr (string, offset_delim_pos + 1);
     1134 		end;
     1135 		else do;
     1136 		     if component_delim_pos = string_len then call line_error (Missing_component);
     1137 		     seg_id = substr (string, 1, component_delim_pos - 1);
     1138 		     component = substr (string, component_delim_pos + 1);
     1139 		     offset = "0";
     1140 		end;
     1141 	     end;
     1142 	     else do;
     1143 		if substr (string, offset_delim_pos, 1) = "+" | substr (string, offset_delim_pos, 1) = "-" then call line_error (Plus_or_minus_allowed_only_with_an_entry_name);
     1144 		if offset_delim_pos = string_len then call line_error (Missing_word_offset);
     1145 		if offset_delim_pos = 1 then call line_error (Missing_seg_id);
     1146 		seg_id = substr (string, 1, offset_delim_pos - 1);
     1147 		component = "";
     1148 		offset = substr (string, offset_delim_pos + 1);
     1149 	     end;
     1150 	     if component = "" then bce_probe_data.address.error_name = seg_id;
     1151 	     else bce_probe_data.address.error_name = rtrim (seg_id) || "$" || rtrim (component);
     1152 	     number = cv_integer_string_check_ (seg_id, Base8, code);
     1153 	     if code = 0 then bce_probe_data.address.segnum = number;
     1154 	     else do;
     1155 		call bce_name_to_segnum_ (seg_id, bce_probe_data.address.segnum, code);
     1156 		if code ^= 0 then call line_error_code (code, Segment_name);
     1157 	     end;
     1158 	     if component ^= "" then do;
     1159 		call bce_component_to_wordnum_ (bce_probe_data.address.segnum, seg_id, component, new_segnum, new_wordnum, code);
     1160 		if code ^= 0 then call line_error_code (code, Bad_component_name);
     1161 		bce_probe_data.address.segnum = new_segnum;
     1162 		bce_probe_data.address.wordnum = new_wordnum;
     1163 	     end;
     1164 	     else bce_probe_data.address.wordnum = 0;
     1165 	     number = cv_integer_string_check_ (offset, Base8, code);
     1166 	     if code ^= 0 | number < 0 then call line_error (Bad_segment_offset);
     1167 	     else do;
     1168 		if substr (string, offset_delim_pos, 1) ^= "-" then bce_probe_data.address.wordnum = bce_probe_data.address.wordnum + number;
     1169 		else do;
     1170 		     if bce_probe_data.address.wordnum - number < 0 then call line_error (Offset_makes_address_negative);
     1171 		     else bce_probe_data.address.wordnum = bce_probe_data.address.wordnum - number;
     1172 		end;
     1173 		bce_probe_data.address.type = Virtual;
     1174 	     end;
     1175 	     goto done;
     1176 	end;
     1177 
     1178 
     1179 	if string = "reg" | string = "register" then do;
     1180 	     call function (reg_address, 1);
     1181 	     go to done;
     1182 	end;
     1183 	if string = "disk" then do;
     1184 	     call function (disk_address, 3);
     1185 	     go to done;
     1186 	end;
     1187 	number = cv_integer_string_check_ (string, Base8, code); /* must be just a number */
     1188 	if code = 0 then do;
     1189 	     bce_probe_data.address.type = Absolute;
     1190 	     bce_probe_data.address.wordnum = number;
     1191 	     bce_probe_data.address.error_name = string;
     1192 	     go to done;
     1193 	end;
     1194 	else call line_error (Unrecognizable_address);
     1195 
     1196 done:	if bce_probe_data.address.type = Virtual then do;
     1197 	     call bce_appending_simulation$new_segment (bce_probe_data.address.segnum, bce_probe_data.my_seg_info_ptr, code);
     1198 	     if code ^= 0 then call line_error_code (code, Accessing_segment);
     1199 	end;
     1200 	return;
     1201 
     1202 disk_address: proc (disk_name_ptr, disk_name_len, disk_record_str_ptr, disk_record_str_len, disk_offset_str_ptr, disk_offset_str_len);
     1203 
     1204 dcl  disk_name			char (disk_name_len) based (disk_name_ptr);
     1205 dcl  disk_name_len			fixed bin;
     1206 dcl  disk_name_ptr			ptr;
     1207 dcl  disk_offset_str		char (disk_offset_str_len) based (disk_offset_str_ptr);
     1208 dcl  disk_offset_str_len		fixed bin;
     1209 dcl  disk_offset_str_ptr		ptr;
     1210 dcl  disk_record_str		char (disk_record_str_len) based (disk_record_str_ptr);
     1211 dcl  disk_record_str_len		fixed bin;
     1212 dcl  disk_record_str_ptr		ptr;
     1213 
     1214 	     pvtp = addr (pvt$);
     1215 	     pvt_arrayp = addr (pvt.array);
     1216 	     call lookup_disk;
     1217 	     bce_probe_data.address.error_name = disk_name;
     1218 	     bce_probe_data.address.record_num = cv_integer_string_check_ (disk_record_str, Base8, code);
     1219 	     if code ^= 0 | bce_probe_data.address.record_num < first_rec_num (pvt_array (bce_probe_data.address.pvtx).device_type) | bce_probe_data.address.record_num > last_sv_rec_num (pvt_array (bce_probe_data.address.pvtx).device_type) then call line_error_arg (Bad_disk_record, disk_record_str);
     1220 	     bce_probe_data.address.wordnum = cv_integer_string_check_ (disk_offset_str, Base8, code);
     1221 	     if code ^= 0 | bce_probe_data.address.wordnum < 0 then call line_error_arg (Bad_page_offset, disk_offset_str);
     1222 	     bce_probe_data.address.type = Disk;
     1223 	     return;
     1224 
     1225 lookup_disk:   proc;
     1226 
     1227 /* find the disk in the pvt */
     1228 
     1229 dcl  devname			char (8);
     1230 
     1231 		devname = disk_name;
     1232 		call disk_name_pvtx (devname, bce_probe_data.address.pvtx, code);	
     1233 		if code ^= 0 then do;
     1234 bad_disk_name:
     1235 		     call line_error_arg_code (code, No_such_drive, disk_name);
     1236 		return;
     1237 		end;
     1238 	     end;
     1239 	end;
     1240 
     1241 reg_address: proc (reg_name_ptr, reg_name_len);
     1242 
     1243 dcl  reg_index			fixed bin;	/* loop var */
     1244 dcl  reg_name			char (reg_name_len) based (reg_name_ptr);
     1245 dcl  reg_name_len			fixed bin;
     1246 dcl  reg_name_ptr			ptr;
     1247 
     1248 	     if examine_mode = Bce_mode then call line_error (Register_address_not_allowed);
     1249 	     bce_probe_data.address.error_name = reg_name;
     1250 	     do reg_index = 1 to dimension (reg_names, 1) while (reg_names (reg_index) ^= reg_name);
     1251 	     end;
     1252 	     if reg_index > dimension (reg_names, 1) then call line_error_arg (Unknown_register, reg_name);
     1253 	     bce_probe_data.address.reg_ptr = reg_ptrs (reg_index);
     1254 	     bce_probe_data.address.default_mode = reg_modes (reg_index);
     1255 	     bce_probe_data.address.default_len = reg_lens (reg_index);
     1256 	     bce_probe_data.address.type = Register;
     1257 	     return;
     1258 	end;
     1259      end;
     1260 
     1261 get_string: proc;
     1262 
     1263 /* Set string_(ptr len) to indicate the next string of chars */
     1264 
     1265 	call pass_white;
     1266 	string_ptr = line_ptr;
     1267 	string_len = search (line, "=,""();
     1268  	");					/* ; NL (delimiters) FF SP VT HT (whitespace) */
     1269 	if string_len = 0 then string_len = line_len;
     1270 	else string_len = string_len - 1;
     1271 	line_len = line_len - string_len;
     1272 	line_ptr = addcharno (line_ptr, string_len);
     1273 	return;
     1274      end;
     1275 
     1276 get_value: proc;
     1277 
     1278 /* Setup value given the next set of strings */
     1279 
     1280 dcl  ascii_value			char (256) aligned based (addr (value.data));
     1281 dcl  decimal_value			fixed bin (35) based (addr (value.data));
     1282 dcl  number			fixed bin (35);	/* result of ascii to numeric conversions */
     1283 dcl  pointer_value			ptr based (addr (value.data));
     1284 dcl  seg_id_len			fixed bin;	/* length of segid portion of virtual pointer */
     1285 dcl  segnum			fixed bin (15);	/* for virtual pointer */
     1286 dcl  substr_len			fixed bin;	/* portion of ascii string being extracted */
     1287 
     1288 	call pass_white;
     1289 	if substr (line, 1, 1) = ";" | substr (line, 1, 1) = "
     1290 " /* NL */ then call line_error (Missing_value);
     1291 	string_len = 0;				/* don't confuse error routines */
     1292 	if substr (line, 1, 1) = """" then do;		/* ascii string */
     1293 	     value.type = Ascii;
     1294 	     value.length = 0;
     1295 	     do while (substr (line, 1, 1) = """");
     1296 		line_ptr = addcharno (line_ptr, 1);
     1297 		line_len = line_len - 1;
     1298 		substr_len = index (line, """");
     1299 		if substr_len = 0 then call line_error (Unmatched_quotes);
     1300 		if substr (line, substr_len, 2) ^= """""" then do;
     1301 		     substr (ascii_value, value.length + 1, substr_len - 1) = substr (line, 1, substr_len - 1);
     1302 		     value.length = value.length + (substr_len - 1);
     1303 		end;
     1304 		else do;
     1305 		     substr (ascii_value, value.length + 1, substr_len) = substr (line, 1, substr_len); /* take one " */
     1306 		     value.length = value.length + substr_len;
     1307 		end;
     1308 		line_ptr = addcharno (line_ptr, substr_len);
     1309 		line_len = line_len - substr_len;
     1310 	     end;
     1311 	     substr (ascii_value, value.length + 1) = " ";
     1312 	     value.length = divide (value.length + 3, 4, 17) * 36; /* integral num of words */
     1313 	     return;
     1314 	end;
     1315 	call get_string;
     1316 	if string_len = 0 then call line_error (Missing_value);
     1317 	seg_id_len = index (string, "|");
     1318 	if seg_id_len > 0 then do;			/* pointer? */
     1319 	     if seg_id_len = 1 then call line_error (Missing_seg_id);
     1320 	     segnum = cv_integer_string_check_ (substr (string, 1, seg_id_len - 1), Base8, code);
     1321 	     if code ^= 0 then do;			/* segname? */
     1322 		call bce_name_to_segnum_ (substr (string, 1, seg_id_len - 1), segnum, code);
     1323 		if code ^= 0 then call line_error_code (code, Segment_name);
     1324 
     1325 	     end;
     1326 	     if seg_id_len = string_len then call line_error (Missing_word_offset);
     1327 	     number = cv_integer_string_check_ (substr (string, seg_id_len + 1), Base8, code);
     1328 	     if code ^= 0 | number < 0 | number >= 256 * 1024 then call line_error (Bad_segment_offset);
     1329 	     value.type = Pointer;
     1330 	     value.length = 72;
     1331 	     pointer_value = ptr (baseptr (segnum), number);
     1332 	     return;
     1333 	end;
     1334 	number = cv_integer_string_check_ (string, Base10, code);
     1335 	if code = 0 then do;			/* just a number */
     1336 	     value.type = Decimal;
     1337 	     value.length = 36;
     1338 	     decimal_value = number;
     1339 	     return;
     1340 	end;
     1341 	else call line_error (Unrecognizable_value);
     1342      end;
     1343 
     1344 line_error: proc (message);
     1345 
     1346 /* Report syntax error in line */
     1347 
     1348 dcl  arg				char (*) parameter; /* argument of function to print */
     1349 dcl  code				fixed bin (35) parameter;
     1350 dcl  int_code			fixed bin (35);	/* internal version of sometimes supplied parameter */
     1351 dcl  message			char (*) parameter; /* message text for error message */
     1352 
     1353 	int_code = 0;
     1354 	go to error;
     1355 
     1356 line_error_code: entry (code, message);
     1357 
     1358 	int_code = code;
     1359 error:
     1360 	call com_err_ (int_code, me, "^a^[: ^a^;^s^]", message, string_len > 0, string);
     1361 	line_len = 0;				/* abort */
     1362 	go to request_done;
     1363 
     1364 line_error_arg: entry (message, arg);
     1365 
     1366 	int_code = 0;
     1367 	go to arg_error;
     1368 
     1369 line_error_arg_code: entry (code, message, arg);
     1370 
     1371 	int_code = code;
     1372 arg_error:
     1373 	call com_err_ (int_code, me, "^a: ^a", message, arg);
     1374 	line_len = 0;
     1375 	go to request_done;
     1376      end;
     1377 
     1378 new_dbr: proc (dbr_value);
     1379 
     1380 /* Change the dbr_value for simulation.  Also, set up various segments. */
     1381 
     1382 dcl  dbr_value			bit (72) aligned parameter;
     1383 
     1384 	call bce_appending_simulation$new_dbr (dbr_value, bce_probe_data.last_segnum, code);
     1385 	if code = 0 then do;
     1386 	     call pc$nullify (get_ptrs_$given_segno (segno (addr (crash_slt$)))); /* free previous contents */
     1387 	     call bce_appending_simulation$new_segment (segno (addr (slt$)), bce_probe_data.my_seg_info_ptr, code);
     1388 	     if code ^= 0 then call com_err_ (code, me, "no slt");
     1389 	     else do;
     1390 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, 0, (my_seg_info.sdwi.size), addr (crash_slt$), code);
     1391 		if code ^= 0 then call com_err_ (code, me, "cannot copy slt");
     1392 	     end;
     1393 
     1394 	     call pc$nullify (get_ptrs_$given_segno (segno (addr (crash_name_table$)))); /* free previous contents */
     1395 	     call bce_appending_simulation$new_segment (segno (addr (name_table$)), bce_probe_data.my_seg_info_ptr, code);
     1396 	     if code ^= 0 then call com_err_ (code, me, "no name_table");
     1397 	     else do;
     1398 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, 0, (my_seg_info.sdwi.size), addr (crash_name_table$), code);
     1399 		if code ^= 0 then call com_err_ (code, me, "cannot copy name_table");
     1400 	     end;
     1401 
     1402 	     call pc$nullify (get_ptrs_$given_segno (segno (addr (crash_definitions_$)))); /* free previous contents */
     1403 	     call bce_appending_simulation$new_segment (segno (addr (definitions_$)), bce_probe_data.my_seg_info_ptr, code);
     1404 	     if code ^= 0 then call com_err_ (code, me, "no definitions_");
     1405 	     else do;
     1406 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, 0, (my_seg_info.sdwi.size), addr (crash_definitions_$), code);
     1407 		if code ^= 0 then call com_err_ (code, me, "cannot copy definitions_");
     1408 	     end;
     1409 
     1410 	     call pc$nullify (get_ptrs_$given_segno (segno (addr (crash_lot$)))); /* free previous contents */
     1411 	     call bce_appending_simulation$new_segment (segno (addr (lot$)), bce_probe_data.my_seg_info_ptr, code);
     1412 	     if code ^= 0 then call com_err_ (code, me, "no lot");
     1413 	     else do;
     1414 		call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, 0, (my_seg_info.sdwi.size), addr (crash_lot$), code);
     1415 		if code ^= 0 then call com_err_ (code, me, "cannot copy lot");
     1416 	     end;
     1417 	end;
     1418 	else call com_err_ (code, me, "No virtual addresses will be allowed because of error initting appending simulation.");
     1419 	bce_probe_data.address.type = 0;		/* no current */
     1420 	return;
     1421      end;
     1422 
     1423 pass_white: proc;
     1424 
     1425 /* pass by whitespace in request line */
     1426 
     1427 dcl  white_len			fixed bin;
     1428 
     1429 	white_len = verify (line, " 	");					/* FF SP VT HT */
     1430 	if white_len = 0 then line_len = 0;
     1431 	else if white_len > 1 then do;
     1432 	     line_len = line_len - (white_len - 1);
     1433 	     line_ptr = addcharno (line_ptr, white_len - 1);
     1434 	end;
     1435 	return;
     1436      end;
     1437 
     1438 status: proc (segnum, brief, any_breaks);
     1439 
     1440 dcl  any_breaks			bit (1) aligned;
     1441 dcl  bkpt_num			fixed bin;
     1442 dcl  brief			bit (1) aligned parameter;
     1443 dcl  1 packed_ptr			aligned,
     1444        2 bitnum			fixed bin (6) uns unal,
     1445        2 segnum			fixed bin (12) uns unal,
     1446        2 wordnum			fixed bin (18) uns unal;
     1447 dcl  segnum			fixed bin (15) parameter;
     1448 
     1449 	sltp = addr (crash_slt$);
     1450 	sltep = addr (slt.seg (segnum));
     1451 	if ^slte.breakpointable then
     1452 	     if brief then return;
     1453 	     else call line_error_arg (Segment_not_breakpointable, bce_probe_data.address.error_name);
     1454 	call bce_appending_simulation$new_segment (segnum, bce_probe_data.my_seg_info_ptr, code);
     1455 	if code ^= 0 then
     1456 	     if brief then return;
     1457 	     else go to status_bad_access;
     1458 	bkpt_page_ptr = addr (buffer);
     1459 	call bce_appending_simulation$get_virtual (bce_probe_data.my_seg_info_ptr, my_seg_info.size - 1024, 1024, bkpt_page_ptr, code);
     1460 	if code ^= 0 then
     1461 	     if brief then return;
     1462 	     else
     1463 status_bad_access:	call line_error_arg_code (code, Accessing_segment, bce_probe_data.address.error_name);
     1464 	do bkpt_num = 1 to dimension (bkpt_page.bkpts, 1);
     1465 	     unspec (packed_ptr) = unspec (bkpt_page.bkpts (bkpt_num).original_instr_ptr);
     1466 	     if packed_ptr.segnum = segnum & packed_ptr.bitnum = 0 then do;
     1467 		any_breaks = "1"b;
     1468 		if brief then do;
     1469 		     call ioa_ ("Breaks set in ^a.", bce_segnum_to_name_ (segnum));
     1470 		     return;
     1471 		end;
     1472 		else call ioa_ ("Break before ^a.", bce_segptr_to_name_ ((bkpt_page.bkpts (bkpt_num).original_instr_ptr)));
     1473 	     end;
     1474 	end;
     1475 	return;
     1476      end;
     1477 
     1478 validate_ptr: proc (ptr_bits) returns (ptr);
     1479 
     1480 /* See if dump ptr is good, or make null */
     1481 
     1482 dcl  my_ptr			ptr;
     1483 dcl  1 my_ptr_bits			aligned like its based (addr (ptr_bits));
     1484 dcl  ptr_bits			bit (72) aligned parameter;
     1485 
     1486 	if my_ptr_bits.its_mod = ITS_MODIFIER & my_ptr_bits.pad1 = "0"b & my_ptr_bits.pad2 = "0"b & my_ptr_bits.mod = "0"b then unspec (my_ptr) = ptr_bits;
     1487 	else my_ptr = null;
     1488 	return (my_ptr);
     1489      end;
     1490  /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  1     2 
  1     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  1     4 
  1     5 dcl  aptep pointer;
  1     6 
  1     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  1     8     2 thread unaligned,				/* List thread */
  1     9       3 fp bit (18),				/* Forward pointer */
  1    10       3 bp bit (18),				/* Backward pointer */
  1    11     2 flags unaligned,				/* Flags and miscellaneous */
  1    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  1    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  1    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  1    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  1    16       3 hproc bit (1),				/* ON if process is hardcore process */
  1    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  1    18       3 eligible bit (1),				/* ON if process is eligible */
  1    19       3 idle bit (1),				/* ON if  this is an idle process */
  1    20       3 interaction bit (1),				/* ON if process has interacted recently */
  1    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  1    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  1    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  1    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  1    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  1    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  1    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  1    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  1    29       3 firstsw bit (1),				/* OFF until process is intialized */
  1    30       3 state bit (18),				/* execution state */
  1    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  1    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  1    33 						/* bit 18-35: sequential number */
  1    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  1    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  1    36     2 ti fixed bin (35),				/* virtual time since interaction */
  1    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  1    38 
  1    39 /* * * * * * * * */
  1    40 
  1    41     2 ipc_pointers unaligned,
  1    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  1    43       3 pad3 bit (18),
  1    44     2 ips_message bit (36),				/* IPS signals pending */
  1    45     2 asteps unaligned,				/* relative ASTE pointers */
  1    46       3 pds bit (18),				/* PDS (per-process) */
  1    47       3 dseg bit (18),				/* DSEG (per-process) */
  1    48       3 prds bit (18),				/* PRDS (per-processor) */
  1    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  1    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  1    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  1    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  1    53 
  1    54 /* * * * * * * * */
  1    55 
  1    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  1    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  1    58     2 flags2 unaligned,
  1    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  1    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  1    61       3 pad7 bit (7),
  1    62       3 batch bit (1),				/* ON if absentee */
  1    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  1    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  1    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  1    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  1    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  1    68 
  1    69 /* * * * * * */
  1    70 
  1    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  1    72     2 ws_size fixed bin,				/* working set estimate for the process */
  1    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  1    74     2 deadline fixed bin (71),			/* time of next run */
  1    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  1    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  1    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  1    78*						/* reaches this (units = 1/1024 sec) */
  1    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  1    80     2 access_authorization bit (72),			/* authorization of this process */
  1    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  1    82 
  1    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  1    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  1    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  1    86 
  1    87 /*  Cells used to drive and instrument finite-state model for response time
  1    88*    measurement. Maintained by meter_response_time */
  1    89 
  1    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  1    91     2 pad18 bit (18) unaligned,
  1    92     2 number_processing fixed bin (35),			/* Number interactions */
  1    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  1    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  1    95 
  1    96 /* * * * * * */
  1    97 
  1    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  1    99 
  1   100 /*  End of cells for finite-state model */
  1   101 
  1   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  1   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  1   104     2 pad4 bit (28) unaligned,
  1   105     2 ipc_r_offset fixed bin (18) unsigned,
  1   106     2 ipc_r_factor fixed bin (35) unsigned,
  1   107     2 apad (10) fixed bin (35);
  1   108 
  1   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
     1490 
     1491  /* BEGIN include file bce_appending_seg_info.incl.pl1 */
  2     2 
  2     3 /* Description of data returned by bce_appending_simulation$new_segment. 
  2     4*Keith Loepere, November 1983. */
  2     5 
  2     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  2     7 
  2     8 dcl  seg_info_ptr		        ptr;
  2     9 dcl  1 seg_info		        aligned based (seg_info_ptr),
  2    10        2 sst_data		        aligned like aste,
  2    11        2 page_table		        (0:255) bit (36) aligned,
  2    12        2 sdwi		        aligned like sdw_info;
  2    13 
  2    14  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
  2    14 
  2    15  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  4     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  4     3 
  4     4 dcl  sdw_info_ptr pointer;
  4     5 
  4     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  4     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  4     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  4     9 
  4    10     2 access unaligned,				/* REWP */
  4    11       3 read bit (1) unaligned,
  4    12       3 execute bit (1) unaligned,
  4    13       3 write bit (1) unaligned,
  4    14       3 privileged bit (1) unaligned,
  4    15 
  4    16     2 pad1 bit (32) unaligned,
  4    17 
  4    18     2 rings unaligned,				/* Ring brackets */
  4    19       3 r1 bit (3) unaligned,
  4    20       3 r2 bit (3) unaligned,
  4    21       3 r3 bit (3) unaligned,
  4    22 
  4    23     2 pad2 bit (27) unaligned,
  4    24 
  4    25     2 flags aligned,
  4    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  4    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  4    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  4    29       3 pad3 bit (33) unaligned,
  4    30 
  4    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  4    32 
  4    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
  2    15 
  2    16 
  2    17 /* END include file bce_appending_seg_info.incl.pl1 */
     1491 
     1492  /* BEGIN include file bce_breakpoint_page.incl.pl1 */
  5     2 
  5     3 /* Description of hardcore breakpoint information saved in breakpoint_page.
  5     4*Keith Loepere, December 1983. */
  5     5 /* Sentinel added, July 1984 by Keith Loepere. */
  5     6 
  5     7 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  5     8 
  5     9 dcl  1 bkpt_page		        aligned based (bkpt_page_ptr),
  5    10        2 header		        aligned,
  5    11          3 mc_		        aligned like mc,
  5    12          3 mode_reg		        bit (36) aligned,
  5    13          3 cache_mode_reg	        bit (36) aligned,
  5    14          3 dbr		        bit (72) aligned,
  5    15          3 bar		        bit (36) aligned,
  5    16          3 sentinel		        char (4) unal,
  5    17          3 pad		        (10) bit (36),
  5    18        2 bkpts		        (120) aligned like breakpoint;
  5    19 dcl  bkpt_page_ptr		        ptr;
  5    20 
  5    21 dcl  1 breakpoint		        aligned based (breakpoint_ptr),
  5    22        2 breakpoint_drl	        bit (36),		/* drl -1 => breakpoint */
  5    23        2 instructions	        (4) bit (36),
  5    24        2 tra_back_offset	        fixed bin (18) unal uns,
  5    25        2 tra_back		        bit (18) unal,	/* tra back to original code */
  5    26        2 original_instr_ptr	        ptr unal,		/* ptr to where original instruction was */
  5    27        2 original_instr	        bit (36);		/* real instruction moved */
  5    28 dcl  breakpoint_ptr		        ptr;
  5    29 
  5    30 dcl  BKPT_page_sentinel	        char (4) static options (constant) init ("bkpt");
  5    31 
  5    32 /* END include file bce_breakpoint_page.incl.pl1 */
     1492 
     1493  /* Begin include file bce_subsystem_info_.incl.pl1 BIM 11/82 */
  6     2 
  6     3 /* format: style3 */
  6     4 
  6     5 /* Deleted unused items, Keith Loepere, 5/84 */
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(86-04-22,Farley), approve(86-07-18,MCR7439),
  6    10*     audit(86-10-08,Fawcett), install(86-10-20,MR12.0-1189):
  6    11*     Added request_handling_opr_aborts flag for save/restore.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 declare	ss_info_ptr	pointer;
  6    15 declare	1 ss_info		aligned based (ss_info_ptr),
  6    16 	  2 request_table_ptr
  6    17 			pointer,
  6    18 	  2 abort_label	label,
  6    19 	  2 name		char (32) unaligned,
  6    20 	  2 arg_list_ptr	pointer,
  6    21 	  2 info_ptr	pointer,
  6    22 	  2 flags           aligned,
  6    23 	    3 forbid_semicolons bit (1) unaligned,
  6    24 	    3 request_handling_opr_aborts bit (1) unaligned;
  6    25 
  6    26 /* End include file bce_subsystem_info_ */
     1493 
     1494  /* BEGIN include file collection_1_phases.incl.pl1 */
  7     2 
  7     3 /* Symbolic names for the various collection1 phases.
  7     4*Keith Loepere, October 1983. */
  7     5 
  7     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  7     7 
  7     8 dcl  sys_info$collection_1_phase	        fixed bin external static;
  7     9 
  7    10 dcl  EARLY_INITIALIZATION		        fixed bin init (1) static options (constant);  /* phase to find the config deck */
  7    11 dcl  BOOT_INITIALIZATION		        fixed bin init (2) static options (constant);  /* phase to setup up crash handler, bce */
  7    12 dcl  SERVICE_INITIALIZATION		        fixed bin init (3) static options (constant);  /* phase to set up for service */
  7    13 
  7    14 /* These first 3 (EARLY, BOOT and SERVICE) must be 1, 2, 3 in that order so
  7    15*programs can simply tell apart the booting phases from all others (crash or
  7    16*recovery type phases). */
  7    17 
  7    18 dcl  CRASH_INITIALIZATION		        fixed bin init (4) static options (constant);  /* phase to set up bce after crash/shut down */
  7    19 dcl  RE_EARLY_INITIALIZATION		        fixed bin init (5) static options (constant);  /* retry boot initialization given safe config to a new early level */
  7    20 dcl  BCE_CRASH_INITIALIZATION		        fixed bin init (6) static options (constant);  /* retry boot initialization to give a new boot level given a crash of bce */
  7    21 dcl  SHUT_INITIALIZATION		        fixed bin init (7) static options (constant);  /* same as boot but don't load new disk mpcs */
  7    22 
  7    23 dcl  COLLECTION_1_PHASE_NAMES		        (7) char (16) unal static options (constant) init
  7    24 				        ("early", "boot", "service", "crash", "re_early", "bce_crash", "shut");
  7    25 
  7    26 /* END include file collection_1_phases.incl.pl1 */
     1494 
     1495  /* BEGIN INCLUDE FILE ... flagbox.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(87-02-26,Farley), approve(87-04-15,MCR7661),
  8     6*     audit(87-04-21,Fawcett), install(87-04-28,MR12.1-1028):
  8     7*     Added io_reconfig flag to inhibit BCE from attempting an emergency
  8     8*     shutdown when the data in memory could be corrupted.
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 
  8    12 /* last modified 5/3/77 by Noel I. Morris	*/
  8    13 /* Modified 8/79 by R.J.C. Kissel to add FNP blast message. */
  8    14 /* Modified 7/82 BIM for recognizable sentinel field */
  8    15 /* Modified for bootload Multics flagbox starting in 8/83 by Keith Loepere. */
  8    16 
  8    17 /* The contents of this segment are data shared by Multics and bce.
  8    18*   This entity occupies the locations within the toehold starting at 40o
  8    19*   (not counting the toehold_used spacer at the beginning). */
  8    20 
  8    21 dcl  flagbox$ ext;
  8    22 dcl  fgbxp ptr;
  8    23 
  8    24 dcl 1 fgbx based (fgbxp) aligned,
  8    25     2 toehold_used (32) bit (36) aligned,		/* flagbox seg now mapped onto all of first page of toehold -
  8    26*						This is what was unused before. */
  8    27     2 flags (36) bit (1) unal,			/* communications switches */
  8    28     2 slt_segno bit (18),				/* segment # of the SLT */
  8    29     2 pad1 fixed bin,
  8    30     2 rtb,					/* return to bce info */
  8    31      (3 ssenb bit (1),				/* "1"b if storage system enabled */
  8    32       3 call_bce bit (1),				/* "1"b if bce called by operator */
  8    33       3 shut bit (1),				/* "1"b if bce called after shutdown */
  8    34       3 mess bit (1),				/* "1"b if message has been provided */
  8    35       3 alert bit (1),				/* "1"b if audible alarm to be sounded */
  8    36       3 breakpoint bit (1),				/* "1"b is breakpoint caused call to bce */
  8    37       3 manual_crash bit (1),				/* either manual entry or execute fault */
  8    38       3 io_reconfig bit (1),				/* "1"b if I/O reconfiguration */
  8    39 						/* could cause memory corruption */
  8    40       3 pad bit (21),
  8    41       3 bce_entry fixed bin (6) uns) unal,		/* type of entry into bce
  8    42*						   00o => Multics entry
  8    43*						   20o => manual entry
  8    44*						   40o => esd entry */
  8    45     2 sentinel char (32) aligned,			/* set by bce (for now) */
  8    46     2 sst_sdw bit (72),				/* set by init_sst */
  8    47     2 hc_dbr bit (72),				/* set by start_cpu, idle DBR */
  8    48     2 message char (64),				/* message for return to bce */
  8    49     2 return_to_bce_command char (128) unal;		/* command to run upon crash/shutdown */
  8    50 
  8    51 declare FLAGBOX_SENTINEL char (32) init ("Flagbox & Toehold Valid") int static options (constant);
  8    52 
  8    53 /* END INCLUDE FILE ... flagbox.incl.pl1 */
     1495 
     1496  /* Begin include file ...... fs_dev_types.incl.pl1 */
  9     2 
  9     3 /****^  HISTORY COMMENTS:
  9     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  9     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  9     6*     Add support for FIPS
  9     7*     3380.
  9     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  9     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  9    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  9    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  9    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  9    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  9    14*                                                   END HISTORY COMMENTS */
  9    15 
  9    16 /* Modified 5/19/76 by N. I. Morris */
  9    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  9    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  9    19 /* Modified '82 by BIM for needs_alt_part */
  9    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  9    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  9    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  9    23*   volmap and record stock can be expanded. */
  9    24 
  9    25 /*
  9    26********************************************************************************
  9    27**							        *
  9    28**                           WARNING:                                          *
  9    29**							        *
  9    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  9    31**   type is added.						        *
  9    32**							        *
  9    33**   There are other include files that contain arrays indexed by the device   *
  9    34**   index obtained by references to MODELX or MODELN in this include file.    *
  9    35**   These must be modified when a new device type is added:		        *
  9    36**   disk_pack.incl.pl1					        *
  9    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  9    38**							        *
  9    39********************************************************************************
  9    40**/
  9    41 
  9    42 
  9    43 dcl (maxdevt init (9),				/* maximum legal devt */
  9    44      bulkdevt init (1),				/* bulk store devt */
  9    45      msu0500devt init (2),				/* MSU0500 device type */
  9    46      msu0451devt init (3),				/* MSU0451 device type */
  9    47      msu0450devt init (3),				/* MSU0450 device type */
  9    48      msu0400devt init (4),				/* MSU0400 device type */
  9    49      dsu191devt init (4),				/* DSU191 device type */
  9    50      dsu190devt init (5),				/* DSU190 device type */
  9    51      dsu181devt init (6),				/* DSU181 device type */
  9    52      msu0501devt init (7),				/* MSU0501 device type */
  9    53      fips3380devt init (8),				/* 3380D FIPS device type */
  9    54      fips3381devt init (9)				/* 3380E FIPS device type */
  9    55      ) fixed bin (4) static options (constant);
  9    56 
  9    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  9    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  9    59 
  9    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  9    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  9    62 
  9    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  9    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  9    65 
  9    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  9    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  9    68 
  9    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  9    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  9    71 
  9    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  9    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  9    74 
  9    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  9    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  9    77 
  9    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  9    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  9    80 
  9    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  9    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  9    83 
  9    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  9    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  9    86 
  9    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  9    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  9    89 
  9    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  9    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  9    92 
  9    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  9    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  9    95 
  9    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  9    97      ("abc");
  9    98 
  9    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  9   100      init ("a","b","c");
  9   101 
  9   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  9   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  9   104 
  9   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  9   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  9   107 
  9   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  9   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  9   110 
  9   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  9   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  9   113 
  9   114 
  9   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  9   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  9   117 
  9   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  9   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  9   120 
  9   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  9   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  9   123 
  9   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  9   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  9   126 
  9   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  9   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  9   129 
  9   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  9   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  9   132 
  9   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  9   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  9   135 
  9   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  9   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  9   138 
  9   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  9   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  9   141 
 10     1 /* Begin fs_dev_types_sector.incl.pl1 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 10     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
 10     7*     Add the sector differance for devices that do 64 word IO and devices that
 10     8*     do 512 word IO.
 10     9*                                                   END HISTORY COMMENTS */
 10    10 
 10    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
 10    12*	 need all the data in fs_dev_types. This is also included in
 10    13*	 fs_dev_types.incl.pl1  */
 10    14 
 10    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
 10    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
 10    17 
 10    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
 10    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
 10    20 
 10    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
 10    22  /* table of # of sectors per record on each device */
 10    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
 10    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
 10    25 
 10    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
 10    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
 10    28 	
 10    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
 10    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
 10    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
 10    32 
 10    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
 10    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
 10    35 
 10    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
 10    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
 10    38 
 10    39 /* End fs_dev_types_sector.incl.pl1 */
 10    40 
  9   142 
  9   143 
  9   144 /* End of include file ...... fs_dev_types.incl.pl1 */
     1496 
     1497  /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
 11     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
 11     3*   encourages name conflicts.
 11     4*   USE HC_FAST_LOCK INSTEAD!
 11     5**/
 11     6 
 11     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
 11     8 
 11     9 /* format: style3 */
 11    10 
 11    11 declare	lock_ptr		pointer;
 11    12 declare	1 lock		aligned based (lock_ptr),
 11    13 	  2 pid		bit (36) aligned,		/* holder of lock */
 11    14 	  2 event		bit (36) aligned,		/* event associated with lock */
 11    15 	  2 flags		aligned,
 11    16 	    3 notify_sw	bit (1) unaligned,
 11    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
 11    18 
 11    19 /* End include file hc_lock.incl.pl1 */
     1497 
     1498  /* BEGIN INCLUDE FILE its.incl.pl1
 12     2*   modified 27 July 79 by JRDavis to add its_unsigned
 12     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 12     4 
 12     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 12     6     2 pad1 bit (3) unaligned,
 12     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 12     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 12     9     2 pad2 bit (9) unaligned,
 12    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 12    11 
 12    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 12    13     2 pad3 bit (3) unaligned,
 12    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 12    15     2 pad4 bit (3) unaligned,
 12    16     2 mod bit (6) unaligned;				/* further modification */
 12    17 
 12    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 12    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 12    20     2 pad1 bit (27) unaligned,
 12    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 12    22 
 12    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 12    24     2 pad2 bit (3) unaligned,
 12    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 12    26     2 pad3 bit (3) unaligned,
 12    27     2 mod bit (6) unaligned;				/* further modification */
 12    28 
 12    29 
 12    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 12    31     2 pad1 bit (3) unaligned,
 12    32     2 segno fixed bin (15) unsigned unaligned,
 12    33     2 ringno fixed bin (3) unsigned unaligned,
 12    34     2 pad2 bit (9) unaligned,
 12    35     2 its_mod bit (6) unaligned,
 12    36 
 12    37     2 offset fixed bin (18) unsigned unaligned,
 12    38     2 pad3 bit (3) unaligned,
 12    39     2 bit_offset fixed bin (6) unsigned unaligned,
 12    40     2 pad4 bit (3) unaligned,
 12    41     2 mod bit (6) unaligned;
 12    42 
 12    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 12    44     2 pr_no fixed bin (3) unsigned unaligned,
 12    45     2 pad1 bit (27) unaligned,
 12    46     2 itp_mod bit (6) unaligned,
 12    47 
 12    48     2 offset fixed bin (18) unsigned unaligned,
 12    49     2 pad2 bit (3) unaligned,
 12    50     2 bit_offset fixed bin (6) unsigned unaligned,
 12    51     2 pad3 bit (3) unaligned,
 12    52     2 mod bit (6) unaligned;
 12    53 
 12    54 
 12    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 12    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 12    57 
 12    58 /* END INCLUDE FILE   its.incl.pl1 */
     1498 
     1499  /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
 13     2 
 13     3 
 13     4 /* The physical volume table (PVT) is a wired-down table.
 13     5*   It has one entry for each spindle present, be it for
 13     6*   Storage System or "I/O" use.
 13     7**/
 13     8 
 13     9      dcl	   pvt$		      ext,
 13    10 	   pvtp		      ptr;
 13    11 
 13    12 
 13    13      dcl	   1 pvt		      based (pvtp) aligned,
 13    14 
 13    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
 13    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
 13    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
 13    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
 13    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
 13    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
 13    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
 13    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
 13    23 
 13    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
 13    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
 13    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
 13    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
 13    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
 13    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
 13    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
 13    31 
 13    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
 13    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
 13    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
 13    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 13    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 13    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
 13    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
 13    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
 13    40 
 13    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
 13    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
 13    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
 13    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
 13    45 
 13    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
 13    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
 13    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
 13    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
 13    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
 13    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
 13    52 	     2 pad (2) bit (36) aligned,
 13    53 
 13    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
 13    55 
 13    56 
 13    57 
 13    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
     1499 
     1500  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14     2 
 14     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
 14     4 
 14     5 /****^  HISTORY COMMENTS:
 14     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
 14     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 14     8*     Add the support for subvolumes
 14     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
 14    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 14    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
 14    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 14    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 14    14*     Added inconsistent_dbm bit for determining the status of volume
 14    15*     dumper bit maps.
 14    16*                                                   END HISTORY COMMENTS */
 14    17 
 14    18      dcl	   pvt$array	      aligned external;
 14    19      dcl	   pvt$max_n_entries      fixed bin external;
 14    20 
 14    21      dcl	   pvt_arrayp	      ptr;
 14    22      dcl	   pvtep		      ptr;
 14    23 
 14    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
 14    25 
 14    26      dcl	   1 pvte		      based (pvtep) aligned,
 14    27 
 14    28 	     2 pvid	      bit (36),		/* physical volume ID */
 14    29 
 14    30 	     2 lvid	      bit (36),		/* logical volume ID */
 14    31 
 14    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
 14    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
 14    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
 14    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
 14    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
 14    37 	     2 pad3	      bit (2) unaligned,
 14    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
 14    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
 14    40 
 14    41 
 14    42 
 14    43 	     2 devname	      char (4),		/* device name */
 14    44 
 14    45 	     (2 device_type	      fixed bin (8),	/* device type */
 14    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
 14    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
 14    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
 14    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
 14    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
 14    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
 14    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
 14    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
 14    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
 14    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
 14    56 	     2 scav_check_address
 14    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
 14    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
 14    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
 14    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
 14    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
 14    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
 14    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
 14    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
 14    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
 14    66 
 14    67 
 14    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
 14    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
 14    70 
 14    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
 14    72 
 14    73 	     2 nleft	      fixed bin (17),	/* number of records left */
 14    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
 14    75 
 14    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
 14    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
 14    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
 14    79 	     2 records_per_cyl    fixed bin,
 14    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
 14    81 	     2 sv_name            char (2) aligned,
 14    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
 14    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
 14    84 
 14    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
 14    86 	     2 pad2	      bit (18) unaligned,
 14    87 
 14    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
 14    89 
 14    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
 14    91 
 14    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
 14    93 
 14    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
 14    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
 14    96 
 14    97 
 14    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
 14    99 
 14   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
 14   101 
 14   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
 14   103 
 14   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
 14   105 
 14   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
 14   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
 14   108 
 14   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
 14   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
 14   111 
 14   112 
 14   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
 14   114 	   VOLMAP_ASYNC_READ      init (1),
 14   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
 14   116 
 14   117 
 14   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1500 
     1501  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
 15     2 
 15     3 /* Declarations for Segment Loading Table header and array.
 15     4*
 15     5*   Used by Initialization and MST Checker subroutines */
 15     6 
 15     7 dcl sltp ptr,					/* pointer to base of SLT segment */
 15     8     names_ptr ptr,					/* pointer to base of SLT names segment */
 15     9     namep ptr,					/* pointer to segment name list block */
 15    10     pathp ptr,					/* pointer to segment's directory path name */
 15    11     aclp ptr;					/* pointer to acl structure */
 15    12 
 15    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
 15    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
 15    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
 15    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
 15    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
 15    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
 15    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
 15    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
 15    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
 15    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
 15    23 
 15    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
 15    25 
 15    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
 15    27 	2 pad bit (18) unal,
 15    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
 15    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
 15    30 
 15    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
 15    32 	2 count fixed bin (17),			/* number of segment names in this block */
 15    33 	2 names (50 refer (segnam.count)),		/* segment name array */
 15    34 	  3 hp bit (18) unal,			/* hash thread pointer */
 15    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
 15    36 	  3 pad bit (5) unal,
 15    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
 15    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
 15    39 
 15    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
 15    41 	2 size fixed bin (17),			/* length of pathname */
 15    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
 15    43 	2 acls fixed bin;				/* ACL list starts here */
 15    44 
 15    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
 15    46 	2 count fixed bin,				/* number of entries in acl list */
 15    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
 15    48 	  3 userid char (32),			/* user specification */
 15    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
 15    50 	  3 pad bit (36) aligned,
 15    51 	  3 code fixed bin;
 15    52 
 15    53 
 15    54 /* END INCLUDE FILE slt.incl.pl1 */
     1501 
     1502  /* BEGIN INCLUDE FILE slte.incl.pl1 */
 16     2 /* Declaration for Segment Loading Table Entry structure.
 16     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
 16     4 /* modified 5/4/76 by Noel I. Morris	*/
 16     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
 16     6 /* format: style3 */
 16     7 
 16     8 dcl	sltep		ptr;
 16     9 
 16    10 dcl	1 slte_uns	based (sltep) aligned,
 16    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 16    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 16    13 /**** End of word 1 */
 16    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
 16    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 16    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 16    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
 16    18 	  2 layout_seg	bit (1),			/* mailbox & such */
 16    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
 16    20 	  2 pad1		bit (3),			/* unused */
 16    21 	  2 wired		bit (1),			/* segment is wired if ON */
 16    22 	  2 paged		bit (1),			/* segment is paged if ON */
 16    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
 16    24 	  2 pad3		bit (2),
 16    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 16    26 /**** End of 1st half of word 2 */
 16    27 	  2 pad4		bit (3),
 16    28 	  2 branch_required bit (1),			/* path name supplied if ON */
 16    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 16    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 16    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 16    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 16    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 16    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 16    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 16    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 16    37 /***** End of word 2 */
 16    38 	  2 pad5		bit (6),
 16    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
 16    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
 16    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
 16    42 /***** End of word 3 */
 16    43 	  2 pad7		bit (3),
 16    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
 16    45 	  2 bit_count	fixed bin (24) uns
 16    46 	  )		unaligned;		/* bitcount of segment */
 16    47 
 16    48 dcl	1 slte		based (sltep) aligned,
 16    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 16    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 16    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
 16    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 16    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 16    54 	  2 firmware_seg    bit (1),
 16    55 	  2 layout_seg      bit (1),
 16    56 	  2 breakpointable  bit (1),
 16    57 	  2 pad2		bit (3),
 16    58 	  2 wired		bit (1),			/* segment is wired if ON */
 16    59 	  2 paged		bit (1),			/* segment is paged if ON */
 16    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
 16    61 	  2 pad3		bit (2),
 16    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 16    63 	  2 pad4		bit (3),
 16    64 	  2 branch_required bit (1),			/* path name supplied if ON */
 16    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 16    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 16    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 16    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 16    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 16    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 16    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 16    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 16    73 	  2 pad5		bit (6),
 16    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
 16    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
 16    76 	  2 segno		bit (18),			/* text/link segment number */
 16    77 	  2 pad6		bit (3),
 16    78 	  2 max_length	bit (9),			/* maximum length for segment */
 16    79 	  2 bit_count	bit (24)
 16    80 	  )		unaligned;		/* bitcount of segment */
 16    81 
 16    82 /* END INCLUDE FILE slte.incl.pl1 */
     1502 
     1503  /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 17     2 
 17     3 /* format: off */
 17     4 
 17     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 17     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 17     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 17     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 17     9 
 17    10 
 17    11 /****^  HISTORY COMMENTS:
 17    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 17    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 17    14*     Modified to add constants for the translator_id field in the stack_frame
 17    15*     structure.
 17    16*                                                   END HISTORY COMMENTS */
 17    17 
 17    18 
 17    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 17    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 17    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 17    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 17    23 
 17    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 17    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 17    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 17    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 17    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 17    29 
 17    30 
 17    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 17    32 
 17    33 dcl  stack_frame_min_length fixed bin static init(48);
 17    34 
 17    35 
 17    36 dcl 1 stack_frame based(sp) aligned,
 17    37     2 pointer_registers(0 : 7) ptr,
 17    38     2 prev_sp pointer,
 17    39     2 next_sp pointer,
 17    40     2 return_ptr pointer,
 17    41     2 entry_ptr pointer,
 17    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 17    43     2 arg_ptr pointer,
 17    44     2 static_ptr ptr unaligned,
 17    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 17    46     2 on_unit_relp1 bit(18) unaligned,
 17    47     2 on_unit_relp2 bit(18) unaligned,
 17    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 17    49*						   0 => PL/I version II
 17    50*						   1 => ALM
 17    51*						   2 => PL/I version I   
 17    52*						   3 => signal caller frame
 17    53*						   4 => signaller frame */
 17    54     2 operator_return_offset bit(18) unaligned,
 17    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 17    56     2 a bit(36),					/* accumulator */
 17    57     2 q bit(36),					/* q-register */
 17    58     2 e bit(36),					/* exponent */
 17    59     2 timer bit(27) unaligned,				/* timer */
 17    60     2 pad bit(6) unaligned,
 17    61     2 ring_alarm_reg bit(3) unaligned;
 17    62 
 17    63 
 17    64 dcl 1 stack_frame_flags based(sp) aligned,
 17    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 17    66     2 xx0 bit(22) unal,
 17    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 17    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 17    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 17    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 17    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 17    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 17    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 17    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 17    75     2 xx0a bit(6) unal,
 17    76     2 xx1 fixed bin,
 17    77     2 xx2 fixed bin,
 17    78     2 xx3 bit(25) unal,
 17    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 17    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 17    81     2 xx3a bit(9) unaligned,
 17    82     2 xx4(9) bit(72) aligned,
 17    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 17    84*						*  operator puts a pointer to the base of
 17    85*						*  the calling procedure here. (text base ptr)  */
 17    86     2 xx5 bit(72) aligned,
 17    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 17    88 
 17    89 /* format: on */
 17    90 
 17    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
     1503 
     1504  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
 18     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
 18     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
 18     4 /*	Modified April 1983 by C. Hornig for tasking */
 18     5 
 18     6 /****^  HISTORY COMMENTS:
 18     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
 18     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
 18     9*     added the heap_header_ptr definition.
 18    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
 18    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
 18    12*     Modified to support control point management.  These changes were actually
 18    13*     made in February 1985 by G. Palter.
 18    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
 18    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
 18    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
 18    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
 18    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
 18    19*     (ITS pair).
 18    20*                                                   END HISTORY COMMENTS */
 18    21 
 18    22 /* format: style2 */
 18    23 
 18    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
 18    25 
 18    26      dcl	   1 stack_header	      based (sb) aligned,
 18    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
 18    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
 18    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
 18    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
 18    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
 18    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
 18    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
 18    34 	     2 pad4	      bit (2) unal,
 18    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
 18    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
 18    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
 18    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
 18    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
 18    40 	     2 null_ptr	      ptr,		/*  (16)  */
 18    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
 18    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
 18    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
 18    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
 18    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
 18    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
 18    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
 18    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
 18    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
 18    50 	     2 return_no_pop_op_ptr
 18    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
 18    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
 18    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
 18    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
 18    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
 18    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
 18    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
 18    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
 18    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
 18    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
 18    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
 18    62 	     2 trace,
 18    63 	       3 frames,
 18    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
 18    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
 18    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
 18    67 	     2 pad2	      bit (36),		/*  (61) */
 18    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
 18    69 
 18    70 /*	The following offset refers to a table within the  pl1  operator table.  */
 18    71 
 18    72      dcl	   tv_offset	      fixed bin init (361) internal static;
 18    73 						/* (551) octal */
 18    74 
 18    75 
 18    76 /*	The following constants are offsets within this transfer vector table.  */
 18    77 
 18    78      dcl	   (
 18    79 	   call_offset	      fixed bin init (271),
 18    80 	   push_offset	      fixed bin init (272),
 18    81 	   return_offset	      fixed bin init (273),
 18    82 	   return_no_pop_offset   fixed bin init (274),
 18    83 	   entry_offset	      fixed bin init (275)
 18    84 	   )		      internal static;
 18    85 
 18    86 
 18    87 
 18    88 
 18    89 
 18    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
 18    91*	move the whole stack header should use this overlay.
 18    92**/
 18    93 
 18    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
 18    95 
 18    96 
 18    97 
 18    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
     1504 
     1505  /* BEGIN include file state_equs.incl.pl1 */
 19     2 
 19     3 /* States of aptes, created from alm version be Keith Loepere, November 1983. */
 19     4 
 19     5 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 19     6 
 19     7 dcl  Empty_apte		        bit (18) unal init ("000000"b3) static options (constant);
 19     8 dcl  Running_apte		        bit (18) unal init ("000001"b3) static options (constant);
 19     9 dcl  Ready_apte		        bit (18) unal init ("000002"b3) static options (constant);
 19    10 dcl  Waiting_apte		        bit (18) unal init ("000003"b3) static options (constant);
 19    11 dcl  Blocked_apte		        bit (18) unal init ("000004"b3) static options (constant);
 19    12 dcl  Stopped_apte		        bit (18) unal init ("000005"b3) static options (constant);
 19    13 dcl  Ptlocking_apte		        bit (18) unal init ("000006"b3) static options (constant);
 19    14 
 19    15 
 19    16 /* END include file state_equs.incl.pl1 */
     1505 
     1506  /* BEGIN INCLUDE FILE ... tcm.incl.pl1 ... used to generate tc_data cds */
 20     2 /* NOTE -- This include file has TWO counterparts in ALM: tc_meters.incl.alm and */
 20     3 /* wcte.incl.alm. They cannot be produced with cif, and must be kept up to date manually. */
 20     4 /* Modified 830914 to replace tty_polling_time with opc_polling_time... -E. A. Ranzenbach */
 20     5 /* Modified 1984.05.21 by M. Pandolf to add tc_suspend_lock */
 20     6 /* Modified 1984.11.26 by Keith Loepere for uid_array. */
 20     7 /* Modified 1984.12.06 by Keith Loepere for page create delaying. */
 20     8 
 20     9 dcl  tcmp ptr;
 20    10 
 20    11 dcl 1 tcm aligned based (tcmp),
 20    12     2 tc_suspend_lock like lock,			/* when locked, tc is suspended */
 20    13     2 cid2 fixed bin (18),
 20    14     2 cid3 fixed bin (18),
 20    15     2 cid4 fixed bin (18),
 20    16     2 depth_count fixed bin (18),			/* depth last process run */
 20    17     2 loadings fixed bin (18),			/* number of process loadings */
 20    18 
 20    19     2 blocks fixed bin (18),				/* number of calls to block */
 20    20     2 wakeups fixed bin (18),				/* number of calls to wakeup */
 20    21     2 waits fixed bin (18),				/* number of calls to wait */
 20    22     2 notifies fixed bin (18),			/* number of calls to notify */
 20    23     2 schedulings fixed bin (18),
 20    24     2 interactions fixed bin (18),			/* number of interactive schedulings */
 20    25     2 avequeue fixed bin (35, 18),			/* recent time average of number in queue */
 20    26     2 te_wait fixed bin (18),				/* times te called from wait */
 20    27 
 20    28     2 te_block fixed bin (18),			/* times te updated from block */
 20    29     2 te_i_stop fixed bin (18),			/* times te updated from i_stop */
 20    30     2 te_pre_empt fixed bin (18),			/* times te updated from pre_empt */
 20    31     2 p_interactions fixed bin,			/* times interaction bit turned off because of high priority */
 20    32     2 idle fixed bin (71),				/* total idle time */
 20    33     2 mp_idle fixed bin (71),				/* multi-programming idle */
 20    34 
 20    35     2 nmp_idle fixed bin (71),			/* non-multi-programming idle time */
 20    36     2 zero_idle fixed bin (71),			/* zero idle time */
 20    37     2 last_time fixed bin (71),			/* last time a process was run */
 20    38     2 loop_locks fixed bin (18),			/* times looped on the APT lock */
 20    39     2 loop_lock_time fixed bin (18),			/* time looping on the APT lock */
 20    40     2 ave_eligible fixed bin (35, 18),			/* average length of eligible queue */
 20    41     2 sort_to_elhead fixed bin (18),			/* 0=> no one,1 => int've only, 2 => everybody */
 20    42     2 processor_time fixed bin (71),			/* total processor time on system */
 20    43     2 response_time fixed bin (71),			/* estimate of response time */
 20    44     2 eligible_time fixed bin (71),			/* estimate of eligible time */
 20    45     2 response_count fixed bin,			/* count of response meters */
 20    46     2 eligible_count fixed bin,			/* count of eligible meters */
 20    47     2 quit_counts (0:5) fixed bin,			/* array of buckets indexed by state */
 20    48     2 loading_idle fixed bin (71),			/* loading_idle time */
 20    49     2 delta_vcpu fixed bin (71),			/* delta virtual CPU time for the system */
 20    50     2 post_purge_switch fixed bin,			/* ON if post purging is to be done */
 20    51     2 time_out_severity fixed bin,			/* syserr first arg for notify time outs */
 20    52     2 notify_check fixed bin,				/* obsolete */
 20    53     2 quit_priority fixed bin,			/* factor for scheduler quit response */
 20    54     2 iobm_polling_time fixed bin (71),			/* time to poll iobm */
 20    55     2 end_of_time fixed bin (71),			/* very large time */
 20    56     2 gp_at_notify fixed bin (18),			/* 0 => just do get_idle_processor */
 20    57     2 gp_at_ptlnotify fixed bin (18),			/* 0 => just do get_idle_processor */
 20    58     2 int_q_enabled fixed bin (18),			/* 0 => no intv q in percent mode */
 20    59     2 fnp_buffer_threshold fixed bin (18),		/* if fewer free buffs then stingy alloc strategy */
 20    60 						/* set this to >= half n_ttylines/fnp for safety */
 20    61 
 20    62 /* 100 octal */
 20    63 
 20    64     2 depths (8) fixed bin (18),			/* histogram of run depths */
 20    65     2 tdepths (8) fixed bin (71),			/* histogram of times run per depth */
 20    66     2 pfdepth (8) fixed bin (18),			/* histogram of page faults per depth */
 20    67 
 20    68     2 ptl_not_waits fixed bin (18),			/* times ptl_wait noticed ptl was unlocked */
 20    69     2 gw_gp_window_count fixed bin (18),		/* times window noticed */
 20    70     2 metering_lock fixed bin (18),			/* 0=locked, else unlocked */
 20    71     2 ptl_waits fixed bin (18),			/* num calls to ptl_wait */
 20    72     2 gp_start_count fixed bin (18),			/*  to detect gw_gp window lossage */
 20    73     2 gp_done_count fixed bin (18),
 20    74     2 nto_check_time fixed bin (71),			/* next time at which nto code will be called */
 20    75     2 nto_delta fixed bin (35),			/* microsec between nto checks */
 20    76     2 nto_count fixed bin (18),			/* number of times nto detected */
 20    77     2 tcpu_scheduling fixed bin (18),			/* obsolete				*/
 20    78     2 nto_event bit (36),				/* last event which NTO'd */
 20    79     2 page_notifies fixed bin (18),
 20    80     2 notify_nobody_count fixed bin (18),
 20    81     2 notify_nobody_event bit (36),
 20    82     2 system_type fixed bin,				/* used to be tcm.inter */
 20    83 
 20    84     2 stat (0:15) fixed bin (18),			/* num apte's in each state */
 20    85 
 20    86 /* 200 octal */
 20    87 
 20    88     2 wait (8),
 20    89       3 time fixed bin (18),				/* histogram of page fault waiting times versus did */
 20    90       3 count fixed bin (18),
 20    91 
 20    92     2 ready (8),
 20    93       3 time fixed bin (18),				/* histogram of times in ready queue */
 20    94       3 count fixed bin (18),
 20    95 
 20    96     2 total_pf_time fixed bin (71),			/* total time spent from start to end of
 20    97*						   all page faults */
 20    98     2 total_pf_count fixed bin (18),			/* total number of page faults metered */
 20    99     2 auto_tune_ws fixed bin (18),			/* 0=> dont, atherwise compensate for quantum len */
 20   100     2 ocore_delta fixed bin (18),			/* number of pages reserved for int users */
 20   101     2 ws_sum fixed bin (18),				/* total of eligible's ws_sizes */
 20   102     2 nonidle_force_count fixed bin (18),		/* count of eligibilities forced */
 20   103     2 itt_list_lock bit (36) aligned,			/* Lock on ITT free list */
 20   104     2 cpu_pf_time fixed bin (71),			/* total cpu time spent handling page faults */
 20   105     2 cpu_pf_count fixed bin (18),			/* total count of cpu time meterings */
 20   106     2 special_offsets unaligned,
 20   107       3 apt_offset bit (18),
 20   108       3 pad bit (18),
 20   109     2 getwork_time fixed bin (71),			/* total time spent in getwork */
 20   110     2 getwork_count fixed bin (18),			/* total times through getwork */
 20   111     2 short_pf_count fixed bin (18),			/* number of short page faults */
 20   112     2 interrupt_time fixed bin (71),			/* total time spent in interrupt */
 20   113     2 interrupt_count fixed bin (71),			/* total number of metered interrupts */
 20   114     2 ocore fixed bin (35, 18),			/* fraction of core for int've users */
 20   115     2 pre_empt_flag bit (36) aligned,			/* controls whether preempting at done time */
 20   116     2 cumulative_memory_usage fixed binary (71),		/* total number of memory usage units */
 20   117     2 processor_time_at_define_wc fixed bin (71),		/* value of processor_time when WC's last defined */
 20   118     2 boost_priority fixed bin,			/* number of times priority process given high priority */
 20   119     2 lost_priority fixed bin,			/* number of times priority process lost eligibility */
 20   120     2 total_clock_lag fixed bin (71),			/* sum of all simulated clock delays */
 20   121     2 clock_simulations fixed bin,			/* number of times alarm clock interrupt was simulated */
 20   122     2 max_clock_lag fixed bin,			/* largest simulated alarm clock delay */
 20   123 
 20   124 /* 300 octal */
 20   125 
 20   126     2 pdscopyl fixed bin (18),			/* amount of pds to copy for new process */
 20   127     2 max_hproc_segno fixed bin,			/* largest allowed hardcore segment number */
 20   128     2 prds_length fixed bin (18),			/* length of PRDS */
 20   129     2 pds_length fixed bin (18),			/* length of PDS */
 20   130     2 lock fixed bin (18),				/* process id generator lock */
 20   131     2 id bit (36) aligned,				/* next uid to be added to uid_array */
 20   132     2 system_shutdown fixed bin (18),
 20   133     2 working_set_factor fixed bin (35, 18),		/* working set factor */
 20   134 
 20   135     2 ncpu fixed bin (18),				/* number of processors currently being used */
 20   136     2 last_eligible bit (18),				/* last process to gain eligibility */
 20   137     2 apt_lock fixed bin (35),			/* + write; 0 hidden; -1 unlocked; -(N+1) Nreaders */
 20   138     2 apt_size fixed bin (18),			/* number of APT entries */
 20   139     2 realtime_q aligned like based_sentinel,		/* processes with realtime deadlines */
 20   140     2 aht_size fixed bin (18),			/* APT hash table size */
 20   141     2 itt_size fixed bin (18),			/* number of ITT entries */
 20   142 
 20   143     2 dst_size fixed bin (18),			/* number of allowed DST entries */
 20   144     2 itt_free_list bit (18),				/* pointer to ITT free list */
 20   145     2 used_itt fixed bin (18),			/* number of used ITT entries */
 20   146     2 initializer_id bit (36) aligned,			/* process id of initializer */
 20   147     2 n_eligible fixed bin (18),			/* number of processes eligible */
 20   148     2 max_eligible fixed bin (30),			/* maximum allowed number of eligible processes */
 20   149     2 wait_enable fixed bin (18),			/* turned on when waiting mechanism works */
 20   150     2 apt_entry_size fixed bin (18),			/* size of an APT entry */
 20   151 
 20   152     2 interactive_q aligned like based_sentinel,		/* head of interactive queue */
 20   153     2 dst_ptr ptr,					/* pointer to device signal table */
 20   154     2 old_user ptr,					/* last process to run (apt ptr ) */
 20   155     2 initialize_time fixed bin (71),			/* time of initialization */
 20   156 
 20   157     2 init_event fixed bin (18),			/* wait event during initialization */
 20   158     2 oldt fixed bin (18),				/* timer reading from previous process */
 20   159     2 newt fixed bin (18),				/* timer setting for new process */
 20   160     2 tefirst fixed bin (30),				/* first eligible time */
 20   161     2 telast fixed bin (30),				/* last eligible time */
 20   162     2 timax fixed bin (35),				/* time in queue for lowest level */
 20   163     2 empty_q bit (18),				/* thread of empty APT entries */
 20   164     2 working_set_addend fixed bin (18),		/* additive working set parameter */
 20   165     2 ready_q_head bit (0) aligned,			/* for added segdef */
 20   166     2 eligible_q_head aligned like based_sentinel,	/* head of eligible queue */
 20   167     2 ready_q_tail bit (0) aligned,			/* for added segdef */
 20   168     2 eligible_q_tail aligned like based_sentinel,	/* tail of eligible queue */
 20   169     2 idle_tail aligned like based_sentinel,		/* tail of idle list */
 20   170     2 min_eligible fixed bin (30),
 20   171     2 alarm_timer_list bit (18) aligned,		/* rel pointer to apt entry for next alarm timer */
 20   172     2 guaranteed_elig_inc fixed bin (35),		/* amount of guaranteed eligibility time in microsecs. */
 20   173     2 priority_sched_inc fixed bin (35),		/* amount of block time before process is given priority */
 20   174     2 next_alarm_time fixed bin (71),			/* clock time for next alarm timer */
 20   175     2 priority_sched_time fixed bin (71),		/* time for priority process to be given priority */
 20   176     2 opc_polling_time fixed bin (71),			/* time to poll console DIM */
 20   177     2 disk_polling_time fixed bin (71),			/* time to poll disk DIM */
 20   178     2 tape_polling_time fixed bin (71),			/* time to poll tape DIM */
 20   179     2 imp_polling_time fixed bin (71),			/* time to poll imp */
 20   180     2 imp_polling_lock fixed bin (18),			/* do not poll if lock set */
 20   181     2 max_channels fixed bin (18),			/* num special channels per process */
 20   182 
 20   183 /* 400 octal */
 20   184 
 20   185     2 system_virtual_time fixed bin (71),		/* non-idle virtual time */
 20   186     2 credit_bank fixed bin (71),			/* credits not yet passed out */
 20   187     2 min_wct_index bit (18) aligned,			/* offset of initializer work class table entry */
 20   188     2 max_wct_index bit (18) aligned,			/* offset of highest wcte currently defined */
 20   189     2 delta_vt fixed bin (71),			/* temp used by pxss.compute_virtual_clocks */
 20   190     2 gross_idle_time fixed bin (71),			/* idle time_used_clock */
 20   191     2 credits_per_scatter fixed bin (35),		/* total number of credits awarded at once */
 20   192     2 best_credit_value fixed bin (18),			/* temp for pxss.find_next_eligible */
 20   193     2 define_wc_time fixed bin (71),			/* clock time when workclasses last degined */
 20   194     2 max_batch_elig fixed bin (35),
 20   195     2 num_batch_elig fixed bin (35),
 20   196     2 deadline_mode fixed bin (35),			/* 0=> ti sorts, else deadline sorts */
 20   197     2 credits_scattered fixed bin (35),
 20   198     2 max_max_eligible fixed bin (30),			/* Maximum of maxe */
 20   199     2 max_stopped_stack_0 fixed bin (35),		/* Maximum stack_0's suspended by stopped procs	*/
 20   200     2 stopped_stack_0 fixed bin (35),			/* Number stack_0's suspended by stopped procs	*/
 20   201     2 mos_polling_interval fixed bin (35),		/* for heals */
 20   202     2 mos_polling_time fixed bin (71),			/* for heals */
 20   203     2 vcpu_response_bounds (VCPU_RESPONSE_BOUNDS) fixed bin (35),
 20   204     2 vcpu_response_bounds_size fixed bin (35),
 20   205     2 meter_response_time_calls fixed bin (35),
 20   206     2 meter_response_time_invalid fixed bin (35),
 20   207     2 meter_response_time_overhead fixed bin (71),
 20   208     2 init_wait_time fixed bin (71),			/* used by wait/notify during initialization	*/
 20   209     2 init_wait_timeout fixed bin (71),			/* notify-timeout interval during initialization	*/
 20   210     2 init_timeout_severity fixed bin,			/* notify-timeout severity during initialization	*/
 20   211     2 init_timeout_recurse fixed bin,			/* count of NTO recursion during initialization	*/
 20   212     2 max_timer_register fixed bin (71),		/* max cpu burst = # cpus x pre_empt_sample_time	*/
 20   213     2 pre_empt_sample_time fixed bin (35),		/* tuning parameter - max time between samples	*/
 20   214     2 governing_credit_bank fixed bin (35),		/* used for limiting eligibility on governed work classes*/
 20   215     2 process_initial_quantum fixed bin (35),		/* eligibility quantum first eligibility	*/
 20   216     2 default_procs_required bit (8) aligned,		/* default mask of CPUs required */
 20   217     2 work_class_idle fixed bin (71),			/* idle time due to work class restrictions */
 20   218 
 20   219 /* Tuning Parameters for Stack Truncation */
 20   220 
 20   221     2 stk_truncate bit (1) aligned,
 20   222     2 stk_truncate_always bit (1) aligned,
 20   223     2 stk_trunc_avg_f1 fixed bin (35, 18),
 20   224     2 stk_trunc_avg_f2 fixed bin (35, 18),
 20   225     2 lock_error_severity fixed bin,                        /* syserr severity */
 20   226 
 20   227     2 gv_integration fixed bin (35),			/* Integration interval for governing */
 20   228     2 gv_integration_set bit (1) aligned,		/* ON => gv_integration set by ctp */
 20   229     2 pauses fixed bin (35),				/* Calls to pause (reschedule) */
 20   230     2 volmap_polling_time fixed bin (71),
 20   231     2 next_ring0_timer fixed bin (71),			/* next time that ring 0 timer goes off */
 20   232     2 realtime_io_priority_switch fixed bin,		/* 0 => give I/O interrupt wakeups realtime priotiry */
 20   233     2 realtime_io_deadline fixed bin (35),		/* Delta to clock for I/O realtime deadline */
 20   234     2 realtime_io_quantum fixed bin (35),		/* Quantum for I/O realtime burst */
 20   235     2 realtime_priorities fixed bin (35),		/* Count for metering */
 20   236     2 relinquishes fixed bin (35),			/* Calls to relinquish_priority */
 20   237     2 abort_ips_mask bit (36) aligned,			/* IPS mask for tc_util$check_abort */
 20   238 
 20   239 /* 500 octal */
 20   240 
 20   241     2 uid_array (0:15) bit (36) aligned,		/* array from which a uid is chosen (randomly) */
 20   242     2 pad5 (176) fixed bin (35),			/* room for expansion compatibly		*/
 20   243 
 20   244 /* 1000 octal */
 20   245 
 20   246     2 pad7 (64) fixed bin (35),
 20   247 
 20   248 /* 1100 octal */
 20   249 
 20   250     2 pad6 (8) fixed bin (35),
 20   251     2 work_class_table aligned,			/* array of per workclass information */
 20   252       3 wcte (0:16) aligned like wct_entry,
 20   253 
 20   254 /* 3000 octal */
 20   255 
 20   256     2 apt fixed bin;
 20   257 
 20   258 dcl  wctep ptr;
 20   259 
 20   260 dcl 1 wct_entry aligned based (wctep),			/* Work class entry */
 20   261     2 thread unaligned,				/* Ready list */
 20   262       3 fp bit (18),				/* Head of ready list */
 20   263       3 bp bit (18),				/* Tail of ready list */
 20   264     2 flags unaligned,
 20   265       3 mnbz bit (1),				/* Sentinel bit must not be zero. */
 20   266       3 defined bit (1),
 20   267       3 io_priority bit (1),
 20   268       3 governed bit (1),
 20   269       3 interactive_q bit (1),
 20   270       3 pad bit (31),
 20   271     2 credits fixed bin (35),				/* Current worthiness of group */
 20   272     2 minf fixed bin (35),				/* min fraction of cpu */
 20   273     2 pin_weight fixed bin (35),			/* number of cycles to pin pages */
 20   274     2 eligibilities fixed bin (35),			/* Count of eligibilities awarded */
 20   275     2 cpu_sum fixed bin (71),				/* CPU used by members */
 20   276     2 resp1 fixed bin (71),
 20   277     2 resp2 fixed bin (71),
 20   278     2 quantum1 fixed bin (35),
 20   279     2 quantum2 fixed bin (35),
 20   280     2 rmeter1 fixed bin (71),
 20   281     2 rmeter2 fixed bin (71),
 20   282     2 rcount1 fixed bin (35),
 20   283     2 rcount2 fixed bin (35),
 20   284     2 realtime fixed bin (35),
 20   285     2 purging fixed bin (35),
 20   286     2 maxel fixed bin (35),
 20   287     2 nel fixed bin (35),
 20   288     2 number_thinks fixed bin (35),			/* number times process entered "think" state	*/
 20   289     2 number_queues fixed bin (35),			/* number times process entered "queued" state	*/
 20   290     2 total_think_time fixed bin (71),
 20   291     2 total_queue_time fixed bin (71),
 20   292 
 20   293 /*  The next three arrays  correspond to the array vcpu_response_bounds				*/
 20   294 
 20   295     2 number_processing (VCPU_RESPONSE_BOUNDS+1) fixed bin (35), /* number times entered "processing" state	*/
 20   296     2 total_processing_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
 20   297     2 total_vcpu_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
 20   298     2 maxf fixed bin (35),				/* maximum fraction of cpu time		*/
 20   299     2 governing_credits fixed bin (35),			/* for limiting cpu resources			*/
 20   300     2 pad1 (4) fixed bin (35);
 20   301 	
 20   302 
 20   303 dcl 1 based_sentinel aligned based,			/* format of pxss-style sentinel */
 20   304     2 fp bit (18) unal,
 20   305     2 bp bit (18) unal,
 20   306     2 sentinel bit (36) aligned;
 20   307 
 20   308 dcl VCPU_RESPONSE_BOUNDS fixed bin init (3) int static options (constant);
 20   309 
 20   310 /* END INCLUDE FILE tcm.incl.pl1 */
     1506 
     1507  /* BEGIN include file toehold.incl.pl1 */
 21     2 
 21     3 /* Various reserved entrypoints into the bce toehold.
 21     4*Also, only those things one really needs to know about the toehold.
 21     5*Keith Loepere, October 1983. */
 21     6 
 21     7 /* Exclude prn, prv and pad when converting to alm version. */
 21     8 
 21     9 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 21    10 
 21    11 dcl  1 toe_hold		        aligned based,	/* name so alm likes */
 21    12        2 entry_sequences	        (0:15) bit (72) aligned, /* described below */
 21    13        2 flagbox		        (64) bit (36) aligned,
 21    14        2 pad1		        (48) bit (36) aligned,
 21    15        2 paths		        (4) like io_path,
 21    16        2 n_paths_used	        fixed bin,
 21    17        2 memory_state	        fixed bin,		/* of memory/disk swapping, etc. */
 21    18        2 bce_dbr		        bit (72) aligned,	/* of bce */
 21    19        2 pad2		        (1355) bit (36) aligned,
 21    20        2 multics_state	        aligned like mc_state;
 21    21 
 21    22 dcl  1 io_path		        aligned based,
 21    23        2 pcw		        fixed bin (71) aligned,
 21    24 
 21    25        2 port_number	        fixed bin (3) uns unal, /* these fields form the word that */
 21    26        2 iom_number		        fixed bin (15) uns unal, /* must be changed upon */
 21    27        2 channel_number	        fixed bin unal,	/* reconfiguration of channels */
 21    28 
 21    29        2 pad		        bit (36) aligned;
 21    30 
 21    31 dcl  TOE_HOLD_CRASH_ENTRY	        fixed bin init (0) static options (constant); /* operator causes crash by xed'ind here */
 21    32 dcl  TOE_HOLD_ESD_ENTRY	        fixed bin init (1) static options (constant);
 21    33 dcl  TOE_HOLD_DUMP_ENTRY	        fixed bin init (2) static options (constant); /* place that causes an early dump */
 21    34 dcl  TOE_HOLD_MULTICS_ENTRY	        fixed bin init (3) static options (constant); /* Multics crashes by drl'ing here */
 21    35 dcl  TOE_HOLD_RESTART_ENTRY	        fixed bin init (4) static options (constant); /* bce restarts Multics by drl'ing here */
 21    36 dcl  TOE_HOLD_BOOT_ENTRY	        fixed bin init (5) static options (constant); /* bootload_tape_label starts init by tra'ing here */
 21    37 dcl  TOE_HOLD_BOS_ENTRY	        fixed bin init (12) static options (constant);
 21    38 dcl  TOE_HOLD_BOS_NO_SAVE_ENTRY       fixed bin init (13) static options (constant);
 21    39 dcl  TOE_HOLD_BOS_MULTICS_ENTRY       fixed bin init (14) static options (constant);
 21    40 
 21    41 declare  mc_state_ptr	        ptr;	/* to toehold$.multics_state */
 21    42 declare 1 mc_state		        aligned based (mc_state_ptr),
 21    43        2 mc_		        aligned like mc,		        
 21    44        2 masks		        (16) bit (36) aligned,
 21    45        2 interrupt		        bit (72) aligned,
 21    46        2 mode_reg		        bit (36) aligned,	/* mode_reg and cache_mode_reg form a double word pair */
 21    47        2 cache_mode_reg	        bit (36) aligned,
 21    48        2 dbr		        bit (72) aligned,
 21    49        2 cfg		        bit (72) aligned,
 21    50        2 bar		        bit (36) aligned,
 21    51        2 old_memory_state	        fixed bin,
 21    52        2 pad16		        (6) bit (36) aligned,
 21    53        2 ou_history_registers	        (0: 15) bit (72) aligned,
 21    54        2 cu_history_registers	        (0: 15) bit (72) aligned,
 21    55        2 du_history_registers	        (0: 15) bit (72) aligned,
 21    56        2 apu_history_registers        (0: 15) bit (72) aligned,
 21    57        2 ptwam_ptrs		        (0: 63) bit (36) aligned,	/* word alignment (mod 16, 32) of these am's matters */
 21    58        2 ptwam_regs		        (0: 63) bit (36) aligned,
 21    59        2 sdwam_ptrs		        (0: 63) bit (36) aligned,
 21    60        2 sdwam_regs		        (0: 63) bit (72) aligned;
 21    61 
 21    62 /* values for memory_state */
 21    63 
 21    64 dcl  Initial_undefined	        fixed bin init (0) static options (constant);  /* initial coming to bce */
 21    65 dcl  At_bce__early		        fixed bin init (1) static options (constant);
 21    66 dcl  At_bce__boot		        fixed bin init (2) static options (constant);  /* at bce during cool boot phase */
 21    67 dcl  Multics		        fixed bin init (3) static options (constant);  /* Multics coming up */
 21    68 dcl  Undefined_saving_state	        fixed bin init (4) static options (constant);  /* saving state during coming down */
 21    69 dcl  Undefined_reading_bce	        fixed bin init (5) static options (constant);  /* reading in bce */
 21    70 dcl  At_bce__crash		        fixed bin init (6) static options (constant);  /* disk holds Multics, at bce */
 21    71 dcl  At_bce__shutdown	        fixed bin init (7) static options (constant);  /* disk holds (nothing), coming to bce */
 21    72 dcl  Undefined_continue	        fixed bin init (8) static options (constant);  /* swapping memory back */
 21    73 dcl  Undefined_saving_mem	        fixed bin init (9) static options (constant);
 21    74 
 21    75  /*  */
 22     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 22     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 22     4 /* Modified 07/07/76 by Morris for fault register data */
 22     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 22     6 /* Modified '82 to make values constant */
 22     7 
 22     8 /* words 0-15 pointer registers */
 22     9 
 22    10 dcl  mcp ptr;
 22    11 
 22    12 dcl 1 mc based (mcp) aligned,
 22    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 22    14    (2 regs,					/* registers */
 22    15       3 x (0:7) bit (18),				/* index registers */
 22    16       3 a bit (36),					/* accumulator */
 22    17       3 q bit (36),					/* q-register */
 22    18       3 e bit (8),					/* exponent */
 22    19       3 pad1 bit (28),
 22    20       3 t bit (27),					/* timer register */
 22    21       3 pad2 bit (6),
 22    22       3 ralr bit (3),				/* ring alarm register */
 22    23 
 22    24     2 scu (0:7) bit (36),
 22    25 
 22    26     2 mask bit (72),				/* mem controller mask at time of fault */
 22    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 22    28     2 errcode fixed bin (35),				/* fault handler's error code */
 22    29     2 fim_temp,
 22    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 22    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 22    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 22    33     2 fault_reg bit (36),				/* fault register */
 22    34     2 pad2 bit (1),
 22    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 22    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 22    37     2 fault_time bit (54),				/* time of fault */
 22    38 
 22    39     2 eis_info (0:7) bit (36)) unaligned;
 22    40 
 22    41 
 22    42 dcl (apx fixed bin init (0),
 22    43      abx fixed bin init (1),
 22    44      bpx fixed bin init (2),
 22    45      bbx fixed bin init (3),
 22    46      lpx fixed bin init (4),
 22    47      lbx fixed bin init (5),
 22    48      spx fixed bin init (6),
 22    49      sbx fixed bin init (7)) internal static options (constant);
 22    50 
 22    51 
 22    52 
 22    53 
 22    54 dcl  scup ptr;
 22    55 
 22    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 22    57 
 22    58 
 22    59 /*	WORD (0)		*/
 22    60 
 22    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 22    62       3 prr bit (3),				/* procedure ring register */
 22    63       3 psr bit (15),				/* procedure segment register */
 22    64       3 p bit (1),					/* procedure privileged bit */
 22    65 
 22    66     2 apu,					/* APPENDING UNIT STATUS */
 22    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 22    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 22    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 22    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 22    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 22    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 22    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 22    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 22    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 22    76       3 ptw bit (1),				/* Fetch of PTW */
 22    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 22    78       3 fap bit (1),				/* Fetch of final address paged */
 22    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 22    80       3 fabs bit (1),				/* Fetch of final address absolute */
 22    81 
 22    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 22    83 
 22    84 
 22    85 /*	WORD (1)		*/
 22    86 
 22    87     2 fd,						/* FAULT  DATA */
 22    88       3 iro bit (1),				/* illegal ring order */
 22    89       3 oeb bit (1),				/* out of execute bracket */
 22    90       3 e_off bit (1),				/* no execute */
 22    91       3 orb bit (1),				/* out of read bracket */
 22    92       3 r_off bit (1),				/* no read */
 22    93       3 owb bit (1),				/* out of write bracket */
 22    94       3 w_off bit (1),				/* no write */
 22    95       3 no_ga bit (1),				/* not a gate */
 22    96       3 ocb bit (1),				/* out of call bracket */
 22    97       3 ocall bit (1),				/* outward call */
 22    98       3 boc bit (1),				/* bad outward call */
 22    99       3 inret bit (1),				/* inward return */
 22   100       3 crt bit (1),				/* cross ring transfer */
 22   101       3 ralr bit (1),				/* ring alarm register */
 22   102       3 am_er bit (1),				/* associative memory fault */
 22   103       3 oosb bit (1),				/* out of segment bounds */
 22   104       3 paru bit (1),				/* processor parity upper */
 22   105       3 parl bit (1),				/* processor parity lower */
 22   106       3 onc_1 bit (1),				/* op not complete type 1 */
 22   107       3 onc_2 bit (1),				/* op not complete type 2 */
 22   108 
 22   109     2 port_stat,					/* PORT  STATUS */
 22   110       3 ial bit (4),				/* illegal action lines */
 22   111       3 iac bit (3),				/* illegal action channel */
 22   112       3 con_chan bit (3),				/* connect channel */
 22   113 
 22   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 22   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 22   116 
 22   117 
 22   118 /*	WORD (2)		*/
 22   119 
 22   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 22   121       3 trr bit (3),				/* temporary ring register */
 22   122       3 tsr bit (15),				/* temporary segment register */
 22   123 
 22   124     2 pad2 bit (9),
 22   125 
 22   126     2 cpu_no bit (3),				/* CPU number */
 22   127 
 22   128     2 delta bit (6),				/* tally modification DELTA */
 22   129 
 22   130 
 22   131 /*	WORD (3)		*/
 22   132 
 22   133     2 word3 bit (18),
 22   134 
 22   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 22   136       3 tsna,					/* Word 1 status */
 22   137         4 prn bit (3),				/* Word 1  PR  number */
 22   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 22   139       3 tsnb,					/* Word 2  status */
 22   140         4 prn bit (3),				/* Word 2  PR  number */
 22   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 22   142       3 tsnc,					/* Word 3  status */
 22   143         4 prn bit (3),				/* Word 3  PR  number */
 22   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 22   145 
 22   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 22   147 
 22   148 
 22   149 /* 	WORD (4)		*/
 22   150 
 22   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 22   152 
 22   153     2 ir,						/* INDICATOR  REGISTERS */
 22   154       3 zero bit (1),				/* zero indicator */
 22   155       3 neg bit (1),				/* negative indicator */
 22   156       3 carry bit (1),				/* carryry indicator */
 22   157       3 ovfl bit (1),				/* overflow indicator */
 22   158       3 eovf bit (1),				/* eponent overflow */
 22   159       3 eufl bit (1),				/* exponent underflow */
 22   160       3 oflm bit (1),				/* overflow mask */
 22   161       3 tro bit (1),				/* tally runout */
 22   162       3 par bit (1),				/* parity error */
 22   163       3 parm bit (1),				/* parity mask */
 22   164       3 bm bit (1),					/* ^bar mode */
 22   165       3 tru bit (1),				/* truncation mode */
 22   166       3 mif bit (1),				/* multi-word instruction mode */
 22   167       3 abs bit (1),				/* absolute mode */
 22   168       3 hex bit (1),				/* hexadecimal exponent mode */
 22   169       3 pad bit (3),
 22   170 
 22   171 
 22   172 /*	WORD (5)		*/
 22   173 
 22   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 22   175 
 22   176     2 cu,						/* CONTROL UNIT STATUS */
 22   177       3 rf bit (1),					/* on first cycle of repeat instr */
 22   178       3 rpt bit (1),				/* repeat instruction */
 22   179       3 rd bit (1),					/* repeat double instruction */
 22   180       3 rl bit (1),					/* repeat link instruciton */
 22   181       3 pot bit (1),				/* IT  modification */
 22   182       3 pon bit (1),				/* return type instruction */
 22   183       3 xde bit (1),				/* XDE from Even location */
 22   184       3 xdo bit (1),				/* XDE from Odd  location */
 22   185       3 poa bit (1),				/* operation preparation */
 22   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 22   187       3 its bit (1),				/* ITS modification */
 22   188       3 if bit (1),					/* fault occured during instruction fetch */
 22   189 
 22   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 22   191 
 22   192 
 22   193 /*	WORDS (6,7)	*/
 22   194 
 22   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 22   196 
 22   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 22   198 
 22   199 
 22   200 
 22   201 
 22   202 
 22   203 
 22   204 /*	ALTERNATE   SCU  DECLARATION		*/
 22   205 
 22   206 
 22   207 dcl 1 scux based (scup) aligned,
 22   208 
 22   209    (2 pad0 bit (36),
 22   210 
 22   211     2 fd,						/* GROUP II  FAULT DATA */
 22   212       3 isn bit (1),				/* illegal segment number */
 22   213       3 ioc bit (1),				/* illegal op  code  */
 22   214       3 ia_am bit (1),				/* illegal address - modifier */
 22   215       3 isp bit (1),				/* illegal slave  procedure */
 22   216       3 ipr bit (1),				/* illegal procedure */
 22   217       3 nea bit (1),				/* non existent address */
 22   218       3 oobb bit (1),				/* out of bounds */
 22   219       3 pad bit (29),
 22   220 
 22   221     2 pad2 bit (36),
 22   222 
 22   223     2 pad3a bit (18),
 22   224 
 22   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 22   226       3 prn bit (3),				/* PR  number */
 22   227       3 prv bit (1),				/* PR  valid bit */
 22   228 
 22   229     2 pad3b bit (6)) unaligned,
 22   230 
 22   231     2 pad45 (0:1) bit (36),
 22   232 
 22   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 22   234 
 22   235 
 22   236 
 22   237 /*  END INCLUDE FILE   mc.incl.pl1 */
 21    75 
 21    76 
 21    77 /* END include file toehold.incl.pl1 */
     1507 
     1508      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  1032.9  bce_probe.pl1                     >special_ldd>install>MR12.3-1114>bce_probe.pl1
1490         1    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
1491         2    07/11/84  0937.3  bce_appending_seg_info.incl.pl1   >ldd>include>bce_appending_seg_info.incl.pl1
2-14         3    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
2-15         4    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
1492         5    11/18/84  1346.2  bce_breakpoint_page.incl.pl1      >ldd>include>bce_breakpoint_page.incl.pl1
1493         6    10/21/86  1251.6  bce_subsystem_info_.incl.pl1      >ldd>include>bce_subsystem_info_.incl.pl1
1494         7    07/11/84  0937.3  collection_1_phases.incl.pl1      >ldd>include>collection_1_phases.incl.pl1
1495         8    04/30/87  1513.7  flagbox.incl.pl1                  >ldd>include>flagbox.incl.pl1
1496         9    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
9-142       10    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
1497        11    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
1498        12    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
1499        13    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
1500        14    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
1501        15    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
1502        16    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
1503        17    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
1504        18    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
1505        19    07/11/84  0937.3  state_equs.incl.pl1               >ldd>include>state_equs.incl.pl1
1506        20    01/30/85  1523.9  tcm.incl.pl1                      >ldd>include>tcm.incl.pl1
1507        21    07/11/84  0937.3  toe_hold.incl.pl1                 >ldd>include>toe_hold.incl.pl1
21-75       22    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Absolute                               constant        fixed bin(17,0)          initial dcl 33 ref 678 1071 1189
Accessing_breakpoint_page       001001 constant        char(25)                 initial packed unaligned dcl 34 set ref 690*
Accessing_segment               000774 constant        char(17)                 initial packed unaligned dcl 35 set ref 517* 618*
                                                                                  680* 731* 859* 910* 1198* 1462*
Address_missing                 000770 constant        char(15)                 initial packed unaligned dcl 36 set ref 1098*
Address_type_must_be_virtual    000761 constant        char(28)                 initial packed unaligned dcl 37 set ref 471* 820*
                                                                                  893*
Apte_number_missing             000754 constant        char(19)                 initial packed unaligned dcl 38 set ref 782*
Ascii                                  constant        fixed bin(17,0)          initial dcl 39 ref 580 598 999 1003 1007 1293
BCE_CRASH_INITIALIZATION               constant        fixed bin(17,0)          initial dcl 7-20 ref 303 528
Bad_apte                        000752 constant        char(8)                  initial packed unaligned dcl 40 set ref 792*
Bad_component_name              000745 constant        char(18)                 initial packed unaligned dcl 41 set ref 1160*
Bad_decimal_value               000734 constant        char(17)                 initial packed unaligned dcl 43 set ref 597* 784*
Bad_disk_record                 000741 constant        char(15)                 initial packed unaligned dcl 42 set ref 1219*
Bad_octal_value                 000730 constant        char(15)                 initial packed unaligned dcl 44 set ref 552* 770*
                                                                                  1107*
Bad_page_offset                 000724 constant        char(15)                 initial packed unaligned dcl 45 set ref 650* 1221*
Bad_segment_offset              000717 constant        char(18)                 initial packed unaligned dcl 46 set ref 1166* 1328*
Base10                          001127 constant        fixed bin(17,0)          initial dcl 48 set ref 596* 783* 1334*
Base8                           001130 constant        fixed bin(17,0)          initial dcl 47 set ref 545* 551* 769* 931* 1106*
                                                                                  1152* 1165* 1187* 1218* 1220* 1320* 1327*
Bce_mode                               constant        fixed bin(17,0)          initial dcl 49 ref 304 310 387 388 1248
Break_already_set               000712 constant        char(17)                 initial packed unaligned dcl 50 set ref 486*
Break_mode                             constant        fixed bin(17,0)          initial dcl 51 ref 302 311 395 688
CRASH_INITIALIZATION                   constant        fixed bin(17,0)          initial dcl 7-18 ref 303 528
Crash_mode                             constant        fixed bin(17,0)          initial dcl 52 ref 303 309 320
DRL_1                           016262 constant        bit(36)                  initial dcl 53 ref 504
Decimal                                constant        fixed bin(17,0)          initial dcl 54 ref 583 1008 1336
Disk                                   constant        fixed bin(17,0)          initial dcl 55 ref 649 1073 1222
Dot_must_be_followed_by_plus_or_minus
                                000700 constant        char(37)                 initial packed unaligned dcl 56 set ref 1105*
Empty_apte                             constant        bit(18)                  initial packed unaligned dcl 19-7 ref 792
Function_arg_list_missing       000671 constant        char(25)                 initial packed unaligned dcl 57 set ref 1035*
Function_argument_missing       000662 constant        char(25)                 initial packed unaligned dcl 58 set ref 1050*
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 12-55 ref 1486
Improper_arg_list_end_for_function
                                000651 constant        char(34)                 initial packed unaligned dcl 59 set ref 1047*
Improper_syntax_in_line         000643 constant        char(23)                 initial packed unaligned dcl 60 set ref 442*
Instruction                            constant        fixed bin(17,0)          initial dcl 61 ref 584 1011
Instruction_cannot_be_breakpointed
                                000625 constant        char(34)                 initial packed unaligned dcl 63 set ref 502*
Invalid_word_offset             000636 constant        char(19)                 initial packed unaligned dcl 62 set ref 1125*
Missing_component               000620 constant        char(17)                 initial packed unaligned dcl 64 set ref 1130* 1136*
Missing_equals                  000615 constant        char(9)                  initial packed unaligned dcl 65 set ref 657*
Missing_offset                  000611 constant        char(14)                 initial packed unaligned dcl 66 set ref 1104*
Missing_seg_id                  000605 constant        char(14)                 initial packed unaligned dcl 67 set ref 1127* 1145*
                                                                                  1319*
Missing_value                   000601 constant        char(13)                 initial packed unaligned dcl 68 set ref 1289* 1316*
Missing_word_offset             000574 constant        char(19)                 initial packed unaligned dcl 69 set ref 1129* 1144*
                                                                                  1326*
NOP                                    constant        bit(36)                  initial packed unaligned dcl 70 ref 496
Name                            000573 constant        char(4)                  initial packed unaligned dcl 71 set ref 875*
Name_missing                    000570 constant        char(12)                 initial packed unaligned dcl 72 set ref 871*
No_break_set                    000565 constant        char(12)                 initial packed unaligned dcl 73 set ref 844*
No_current_address              000560 constant        char(18)                 initial packed unaligned dcl 74 set ref 1100*
No_current_break                000554 constant        char(16)                 initial packed unaligned dcl 75 set ref 826*
No_image_to_restart             000547 constant        char(19)                 initial packed unaligned dcl 76 set ref 528*
No_offset_may_be_added_to_register_addresses
                                000534 constant        char(44)                 initial packed unaligned dcl 77 set ref 1102*
No_such_drive                   000530 constant        char(13)                 initial packed unaligned dcl 78 set ref 1234*
Octal                                  constant        fixed bin(17,0)          initial dcl 79 ref 236 236 236 236 236 236 236 236
                                                                                  236 236 236 236 236 236 236 236 236 236 236 585
                                                                                  1009 1118
Offset_makes_address_negative   000520 constant        char(29)                 initial packed unaligned dcl 80 set ref 1110* 1170*
Plus_or_minus_allowed_only_with_an_entry_name
                                000504 constant        char(45)                 initial packed unaligned dcl 81 set ref 1143*
Pointer                                constant        fixed bin(17,0)          initial dcl 82 ref 236 236 236 236 236 236 236 236
                                                                                  587 599 1000 1004 1010 1329
Reading_a_line                  000500 constant        char(14)                 initial packed unaligned dcl 83 set ref 429*
Reading_disk                    000475 constant        char(12)                 initial packed unaligned dcl 84 set ref 652*
Register                               constant        fixed bin(17,0)          initial dcl 85 ref 604 683 1102 1256
Register_address_not_allowed    000466 constant        char(28)                 initial packed unaligned dcl 86 set ref 1248*
Segment_name                    000463 constant        char(12)                 initial packed unaligned dcl 87 set ref 1156* 1323*
Segment_not_breakpointable      000454 constant        char(26)                 initial packed unaligned dcl 88 set ref 477* 837*
                                                                                  1453*
Segment_number_missing          000446 constant        char(22)                 initial packed unaligned dcl 89 set ref 768*
TRA                             000100 automatic       bit(18)                  initial packed unaligned dcl 90 set ref 90* 505 514
Too_many_breakpoints_in_segment 000436 constant        char(31)                 initial packed unaligned dcl 91 set ref 490*
Unexpected_args_follow          000430 constant        char(22)                 initial packed unaligned dcl 92 set ref 961*
Unknown_mode                    000425 constant        char(12)                 initial packed unaligned dcl 93 set ref 590*
Unknown_register                000366 constant        char(16)                 initial packed unaligned dcl 99 set ref 1252*
Unmatched_quotes                000421 constant        char(16)                 initial packed unaligned dcl 94 set ref 1299*
Unrecognizable_address          000413 constant        char(22)                 initial packed unaligned dcl 95 set ref 934* 1194*
Unrecognizable_option           000377 constant        char(21)                 initial packed unaligned dcl 97 set ref 725*
Unrecognizable_request          000405 constant        char(22)                 initial packed unaligned dcl 96 set ref 448*
Unrecognizable_value            000372 constant        char(20)                 initial packed unaligned dcl 98 set ref 1341*
VCPU_RESPONSE_BOUNDS                   constant        fixed bin(17,0)          initial dcl 20-308 ref 790 790 790 790
Values_being_let_too_long       000357 constant        char(25)                 initial packed unaligned dcl 100 set ref 668*
Virtual                                constant        fixed bin(17,0)          initial dcl 101 ref 471 592 674 820 830 893 1072
                                                                                  1173 1196
Writing_disk                    000354 constant        char(12)                 initial packed unaligned dcl 102 set ref 695*
a                      3004     000132 external static bit(36)                  level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  337
a                        24     000176 automatic       bit(36)                  level 4 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 366
a                        24            based           bit(36)                  level 3 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" ref 742 742
absadr                          000010 constant        entry                    external dcl 104 ref 393
addbitno                                               builtin function         dcl 105 ref 999 1000 1001 1016
addcharno                                              builtin function         dcl 106 ref 440 659 1040 1055 1272 1296 1308 1433
addr                                                   builtin function         dcl 107 ref 301 321 322 323 324 325 326 327 328 329
                                                                                  330 331 332 333 334 335 336 337 338 339 340 341
                                                                                  342 343 344 345 346 347 350 351 352 353 354 355
                                                                                  356 357 358 359 360 361 362 363 364 365 366 367
                                                                                  368 369 370 371 372 373 374 375 376 379 380 383
                                                                                  384 393 393 396 396 401 405 425 428 428 428 428
                                                                                  474 475 481 491 492 493 493 499 499 501 501 501
                                                                                  501 514 515 516 516 614 651 651 675 675 679 679
                                                                                  689 689 694 694 727 728 786 789 790 835 836 839
                                                                                  845 847 849 849 853 853 897 942 999 1000 1001 1007
                                                                                  1008 1009 1010 1057 1057 1076 1076 1077 1214 1215
                                                                                  1301 1305 1311 1331 1338 1386 1386 1386 1386 1387
                                                                                  1387 1390 1390 1394 1394 1394 1394 1395 1395 1398
                                                                                  1398 1402 1402 1402 1402 1403 1403 1406 1406 1410
                                                                                  1410 1410 1410 1411 1411 1414 1414 1449 1450 1458
                                                                                  1486 1486 1486 1486
addrel                                                 builtin function         dcl 108 ref 402 484 614 821 1077
address                   4     000144 automatic       structure                level 2 dcl 138
address_offset                         parameter       fixed bin(26,0)          dcl 1063 ref 1061 1071 1072 1073 1073 1077
addwordno                                              builtin function         dcl 109 ref 619
any_breaks                             parameter       bit(1)                   dcl 1440 in procedure "status" set ref 1438 1467*
any_breaks                      003476 automatic       bit(1)                   dcl 924 in begin block on line 922 set ref 940* 944*
                                                                                  947* 948
apt                                    based           fixed bin(17,0)          level 2 dcl 20-11 set ref 790
apte                                   based           structure                level 1 dcl 1-7 ref 790 790 790
apte_num                        003351 automatic       fixed bin(17,0)          dcl 778 set ref 783* 784 790
aptep                           003242 automatic       pointer                  dcl 1-5 set ref 789* 790 790 790 790* 792 794 794
                                                                                  795 795
arg                                    parameter       char                     packed unaligned dcl 1348 in procedure "line_error"
                                                                                  set ref 1364 1369 1372*
arg                                    based           char                     packed unaligned dcl 110 in procedure "bce_probe"
                                                                                  set ref 309 310 311 313*
arg_index                       003544 automatic       fixed bin(17,0)          dcl 1028 in procedure "function" set ref 1038* 1043
                                                                                  1044 1047*
arg_index                       000101 automatic       fixed bin(17,0)          dcl 111 in procedure "bce_probe" set ref 307* 308*
                                                                                  382* 383 383 384 384*
arg_len                         000102 automatic       fixed bin(21,0)          dcl 112 set ref 308* 309 310 311 313 313
arg_list                        000106 automatic       structure                level 1 dcl 115 set ref 1057 1057
arg_list_ptr             16            based           pointer                  level 2 dcl 6-15 set ref 306* 308*
arg_num                         000103 automatic       fixed bin(17,0)          dcl 113 set ref 306* 307
arg_ptr                         000104 automatic       pointer                  dcl 114 in procedure "bce_probe" set ref 308* 309
                                                                                  310 311 313
arg_ptr                  32            based           pointer                  level 2 in structure "stack_frame" dcl 17-36
                                                                                  in procedure "bce_probe" ref 913 913 913 913
arg_ptrs                  2     000106 automatic       pointer                  array level 2 dcl 115 set ref 383* 384*
arg_str_lens                    000130 automatic       fixed bin(17,0)          array dcl 120 set ref 384 1044*
arg_str_ptrs                    000134 automatic       pointer                  array dcl 121 set ref 382 383 1043*
array                    50            based           fixed bin(71,0)          level 2 dcl 13-13 set ref 1215
ascii_value                            based           char(256)                dcl 1280 set ref 1301* 1305* 1311*
aste                                   based           structure                level 1 dcl 3-11
bar                    3070     000132 external static bit(36)                  level 3 in structure "toehold$" dcl 286 in procedure
                                                                                  "bce_probe" set ref 347
bar                      64     000176 automatic       bit(36)                  level 2 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe" set ref 376
based_sentinel                         based           structure                level 1 dcl 20-303
baseptr                                                builtin function         dcl 122 ref 402 484 821 895 896 1331
bce_appending_simulation$get_absolute
                                000012 constant        entry                    external dcl 123 ref 396 1071
bce_appending_simulation$get_virtual
                                000014 constant        entry                    external dcl 124 ref 406 482 493 790 840 1072 1390
                                                                                  1398 1406 1414 1459
bce_appending_simulation$init   000022 constant        entry                    external dcl 127 ref 387
bce_appending_simulation$new_dbr
                                000024 constant        entry                    external dcl 128 ref 1384
bce_appending_simulation$new_segment
                                000026 constant        entry                    external dcl 129 ref 403 479 787 831 1197 1387 1395
                                                                                  1403 1411 1454
bce_appending_simulation$put_absolute
                                000016 constant        entry                    external dcl 125 ref 679 689 849
bce_appending_simulation$put_virtual
                                000020 constant        entry                    external dcl 126 ref 510 516 675 853 856
bce_component_to_wordnum_       000030 constant        entry                    external dcl 130 ref 1159
bce_continue                    000032 constant        entry                    external dcl 131 ref 529
bce_data$get_line               000034 external static entry variable           dcl 132 set ref 428 428 428
bce_display_instruction_        000040 constant        entry                    external dcl 134 ref 1012
bce_display_scu_                000042 constant        entry                    external dcl 135 ref 748
bce_inst_length_                000044 constant        entry                    external dcl 136 ref 499
bce_name_to_segnum_             000046 constant        entry                    external dcl 137 ref 874 933 1155 1322
bce_probe_data                  000144 automatic       structure                level 1 dcl 138
bce_relocate_instruction_       000050 constant        entry                    external dcl 152 ref 501
bce_segnum_to_name_             000052 constant        entry                    external dcl 153 ref 476 772 1469
bce_segptr_to_name_             000054 constant        entry                    external dcl 154 ref 409 519 735 861 914 915 1472
bin                                                    builtin function         dcl 155 ref 402 402 848
bit                                                    builtin function         dcl 156 ref 848
bitnum                          005661 automatic       fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 1443
                                                                                  set ref 1466
bits_left_over                  003315 automatic       fixed bin(17,0)          dcl 563 set ref 611* 619 620 623* 624 625 625 625
bkpt_num                        003452 automatic       fixed bin(17,0)          dcl 811 in begin block on line 809 set ref 842* 842*
                                                                                  844 845
bkpt_num                        003303 automatic       fixed bin(17,0)          dcl 457 in begin block on line 455 set ref 485* 486*
                                                                                  488* 488* 490 491
bkpt_num                        005660 automatic       fixed bin(17,0)          dcl 1441 in procedure "status" set ref 1464* 1465
                                                                                  1472*
bkpt_page                              based           structure                level 1 dcl 5-9
bkpt_page_ptr                   003244 automatic       pointer                  dcl 5-19 set ref 481* 482* 485 486 488 488 490 491
                                                                                  492 510 839* 840* 842 842 844 845 856 1458* 1459*
                                                                                  1464 1465 1472
bkpt_tra_instr                         based           structure                level 1 dcl 458
bkpts                   100            based           structure                array level 2 dcl 5-9 set ref 485 488 488 490 491
                                                                                  842 844 845 1464
breakpoint               43(05)        based           bit(1)                   level 3 in structure "fgbx" packed packed unaligned
                                                                                  dcl 8-24 in procedure "bce_probe" ref 302
breakpoint                             based           structure                level 1 dcl 5-21 in procedure "bce_probe" set ref
                                                                                  406 406 510 510 855* 856 856
breakpoint_absadr               000172 automatic       fixed bin(26,0)          dcl 157 set ref 393* 396* 689* 849*
breakpoint_at                   000174 automatic       pointer                  dcl 158 set ref 394* 402* 403 403 406 406 408* 409*
                                                                                  411* 413* 826 827 846 851*
breakpoint_drl                         based           bit(36)                  level 2 dcl 5-21 set ref 504*
breakpoint_page$                000056 external static fixed bin(17,0)          dcl 159 set ref 393 393
breakpoint_page_buffer          000176 automatic       structure                level 1 dcl 160 set ref 396 396 396 396 689 689 689
                                                                                  689 849 849 849 849
breakpoint_ptr                  003246 automatic       pointer                  dcl 5-28 set ref 405* 406 406 406* 408 491* 492 495
                                                                                  496 501 501 504 505 506 507 508 510 510 510 510*
                                                                                  845* 853 853 855 856 856 856 856*
breakpointable            1(08)        based           bit(1)                   level 2 packed packed unaligned dcl 16-48 ref 477
                                                                                  837 1451
brief                                  parameter       bit(1)                   dcl 1442 ref 1438 1451 1455 1460 1468
buffer                          003554 automatic       bit(36)                  array dcl 1064 in procedure "fetch_" set ref 1076
                                                                                  1076 1077
buffer                    4     001236 automatic       bit(36864)               level 2 in structure "work_area" dcl 294
                                                                                  in procedure "bce_probe" set ref 405 481 614 625
                                                                                  625 651 651 661 662* 668 670* 675 675 679 679 687
                                                                                  694 694 727 839 897 1458
buffer_data_ptr                 003316 automatic       pointer                  dcl 564 set ref 614* 617* 619
cache_mode_reg           61     000176 automatic       bit(36)                  level 2 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe" set ref 374
cache_mode_reg         3063     000132 external static bit(36)                  level 3 in structure "toehold$" dcl 286 in procedure
                                                                                  "bce_probe" set ref 345
code                            000276 automatic       fixed bin(35,0)          dcl 161 in procedure "bce_probe" set ref 306* 307
                                                                                  308* 387* 396* 397 398* 403* 404 406* 407 426* 427
                                                                                  428* 429 429* 479* 480 482* 483 493* 494 501* 502
                                                                                  510* 513 516* 517 517* 545* 546 551* 552 596* 597
                                                                                  617* 618 618* 651* 652 652* 675* 676 679* 680 680*
                                                                                  689* 690 690* 694* 695 695* 730* 731 731* 769* 770
                                                                                  783* 784 787* 788 790* 791 831* 832 840* 841 849*
                                                                                  850 853* 854 856* 859 859* 874* 875 875* 898* 899
                                                                                  909* 910 910* 931* 932 933* 934 1106* 1107 1152*
                                                                                  1153 1155* 1156 1156* 1159* 1160 1160* 1165* 1166
                                                                                  1187* 1188 1197* 1198 1198* 1218* 1219 1220* 1221
                                                                                  1232* 1233 1234* 1320* 1321 1322* 1323 1323* 1327*
                                                                                  1328 1334* 1335 1384* 1385 1387* 1388 1388* 1390*
                                                                                  1391 1391* 1395* 1396 1396* 1398* 1399 1399* 1403*
                                                                                  1404 1404* 1406* 1407 1407* 1411* 1412 1412* 1414*
                                                                                  1415 1415* 1418* 1454* 1455 1459* 1460 1462*
code                                   parameter       fixed bin(35,0)          dcl 1065 in procedure "fetch_" set ref 1061 1071*
                                                                                  1072* 1073* 1076* 1079*
code                                   parameter       fixed bin(35,0)          dcl 1349 in procedure "line_error" ref 1356 1358
                                                                                  1369 1371
com_err_                        000060 constant        entry                    external dcl 162 ref 313 398 1359 1372 1388 1391
                                                                                  1396 1399 1404 1407 1412 1415 1418
component                       005562 automatic       char(32)                 packed unaligned dcl 1088 set ref 1132* 1138* 1147*
                                                                                  1150 1151 1158 1159*
component_delim_pos             005572 automatic       fixed bin(17,0)          dcl 1089 set ref 1121* 1124 1125 1126 1127 1130 1131
                                                                                  1132 1132 1136 1137 1138
crash_definitions_$             000062 external static fixed bin(17,0)          dcl 163 set ref 1402 1402 1402 1402 1406 1406
crash_lot$                      000066 external static fixed bin(17,0)          dcl 165 set ref 1410 1410 1410 1410 1414 1414
crash_name_table$               000064 external static fixed bin(17,0)          dcl 164 set ref 1394 1394 1394 1394 1398 1398
crash_slt$                      000070 external static fixed bin(17,0)          dcl 166 set ref 474 835 942 1386 1386 1386 1386 1390
                                                                                  1390 1449
cu_$arg_count_rel               000072 constant        entry                    external dcl 167 ref 306
cu_$arg_ptr_rel                 000074 constant        entry                    external dcl 168 ref 308
cu_$generate_call               000076 constant        entry                    external dcl 169 ref 1057
current_sp                      003470 automatic       pointer                  dcl 888 set ref 896* 901 901* 903 903 903 906* 909
                                                                                  912* 916 917*
cv_integer_string_check_        000100 constant        entry                    external dcl 170 ref 545 551 596 769 783 931 1106
                                                                                  1152 1165 1187 1218 1220 1320 1327 1334
data                      4     001132 automatic       bit(2304)                level 2 dcl 288 set ref 662 670 1301 1305 1311 1331
                                                                                  1338
data_address                    003320 automatic       fixed bin(26,0)          dcl 565 set ref 609* 610 613 614 617 622* 622
data_area                       003520 automatic       bit(144)                 dcl 972 in procedure "display" set ref 998* 999 1000
                                                                                  1001 1007 1008 1009 1010
data_area                              based           bit(36)                  array dcl 1066 in procedure "fetch_" set ref 1077*
                                                                                  1077
data_area_ptr                   003524 automatic       pointer                  dcl 973 set ref 999* 1000* 1001* 1002 1012*
data_bit_lth                    003526 automatic       fixed bin(24,0)          dcl 979 set ref 992* 996 997 1015* 1015
data_bits_done                         parameter       fixed bin(24,0)          dcl 974 in procedure "display" set ref 968 993*
                                                                                  1018* 1018
data_bits_done                  003321 automatic       fixed bin(24,0)          dcl 566 in begin block on line 561 set ref 606* 620*
                                                                                  623
data_in_ascii                          based           char(1)                  array packed unaligned dcl 975 set ref 1007*
data_in_decimal                        based           fixed bin(35,0)          array dcl 976 set ref 1008*
data_in_octal                          based           bit(36)                  array dcl 977 set ref 1009*
data_in_pointer                        based           pointer                  array dcl 978 set ref 1010*
data_label                      003322 automatic       fixed bin(26,0)          dcl 567 set ref 610* 620* 624* 624
data_length                     003331 automatic       fixed bin(24,0)          dcl 643 in begin block on line 642 set ref 656* 661
                                                                                  662 663* 663 668 670 671* 671 675 675 679 679 684*
                                                                                  684 685 686 687 687
data_length                     003323 automatic       fixed bin(24,0)          dcl 568 in begin block on line 561 set ref 576* 581*
                                                                                  588* 592* 596* 598* 598 599* 599 600* 600 605* 605
                                                                                  606* 612 615 620 621* 621
data_lth                               parameter       fixed bin(18,0)          dcl 1067 set ref 1061 1071* 1072* 1073 1077
data_part_bits                  003324 automatic       fixed bin(24,0)          dcl 569 set ref 615* 616 620 620 621 623
data_part_words                 003325 automatic       fixed bin(18,0)          dcl 570 set ref 613* 615 616* 617* 622 624
data_ptr                               parameter       pointer                  dcl 1068 in procedure "fetch_" set ref 1061 1071*
                                                                                  1072* 1077
data_ptr                        003530 automatic       pointer                  dcl 980 in procedure "display" set ref 994* 1002
                                                                                  1016* 1016
date_time_                      000102 constant        entry                    external dcl 171 ref 750
dbr                    3064     000132 external static bit(72)                  level 3 in structure "toehold$" dcl 286 in procedure
                                                                                  "bce_probe" set ref 346 388
dbr                      62     000176 automatic       bit(72)                  level 2 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe" set ref 375
dbr                      44            based           fixed bin(71,0)          level 2 in structure "apte" dcl 1-7 in procedure
                                                                                  "bce_probe" ref 794 794 795 795
dbr_value                       003312 automatic       bit(72)                  dcl 534 in begin block on line 532 set ref 547* 548*
                                                                                  554* 557*
dbr_value                              parameter       bit(72)                  dcl 1382 in procedure "new_dbr" set ref 1378 1384*
dbr_word                        003314 automatic       fixed bin(35,0)          dcl 535 set ref 545* 548 551* 554
decimal_value                          based           fixed bin(35,0)          dcl 1281 set ref 1338*
default_len              15     000144 automatic       fixed bin(24,0)          level 3 dcl 138 set ref 576 605 684 685 1119* 1255*
default_mode             14     000144 automatic       fixed bin(17,0)          level 3 dcl 138 set ref 575 1118* 1254*
definitions_$                   000104 external static fixed bin(17,0)          dcl 172 set ref 1403 1403
device_type               4            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 14-24 ref
                                                                                  1219 1219
devname                         000106 automatic       char(8)                  packed unaligned dcl 1229 set ref 1231* 1232*
dimension                                              builtin function         dcl 173 ref 382 446 448 485 488 490 495 842 844 1250
                                                                                  1252 1464
disk_name                              based           char                     packed unaligned dcl 1204 set ref 1217 1231 1234*
disk_name_len                          parameter       fixed bin(17,0)          dcl 1205 ref 1202 1217 1231 1234 1234
disk_name_ptr                          parameter       pointer                  dcl 1206 ref 1202 1217 1231 1234
disk_name_pvtx                  000036 constant        entry                    external dcl 133 ref 1232
disk_offset_str                        based           char                     packed unaligned dcl 1207 set ref 1220* 1221*
disk_offset_str_len                    parameter       fixed bin(17,0)          dcl 1208 ref 1202 1220 1220 1221 1221
disk_offset_str_ptr                    parameter       pointer                  dcl 1209 ref 1202 1220 1221
disk_record_str                        based           char                     packed unaligned dcl 1210 set ref 1218* 1219*
disk_record_str_len                    parameter       fixed bin(17,0)          dcl 1211 ref 1202 1218 1218 1219 1219
disk_record_str_ptr                    parameter       pointer                  dcl 1212 ref 1202 1218 1219
display_buffer_ptr              003326 automatic       pointer                  dcl 571 set ref 619* 620*
divide                                                 builtin function         dcl 174 ref 616 619 624 675 675 679 679 1003 1004
                                                                                  1005 1017 1312
e                        26            based           bit(8)                   level 3 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" ref 742 742
e                        26     000176 automatic       bit(8)                   level 4 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 368
e                      3006     000132 external static bit(8)                   level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  339
eis_info                 50            based           bit(36)                  array level 2 packed packed unaligned dcl 22-12 set
                                                                                  ref 757* 757* 757* 757* 757* 757* 757* 757*
eis_len                         003304 automatic       fixed bin(17,0)          dcl 461 set ref 499* 501*
entry_ptr                26            based           pointer                  level 2 dcl 17-36 ref 915 915 915 915
entry_var                              parameter       entry variable           dcl 1029 set ref 1023 1057*
error_name               16     000144 automatic       char(32)                 level 3 packed packed unaligned dcl 138 set ref 476*
                                                                                  477* 490* 517* 618* 652* 680* 695* 731* 837* 859*
                                                                                  910* 1150* 1151* 1191* 1217* 1249* 1453* 1462*
error_table_$bad_arg            000106 external static fixed bin(35,0)          dcl 175 set ref 313* 1079
error_table_$boundviol          000144 external static fixed bin(35,0)          dcl 1069 ref 1073
even_inst                 6            based           bit(36)                  level 2 dcl 22-56 ref 755
examine_mode                    000277 automatic       fixed bin(17,0)          dcl 176 set ref 302* 303* 304* 309* 310* 311* 318*
                                                                                  320 387 388 395 633* 688 1248
ext_fault_reg            46(03) 000176 automatic       bit(15)                  level 3 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 372
ext_fault_reg          3026(03) 000132 external static bit(15)                  level 4 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  343
fault_reg                45     000176 automatic       bit(36)                  level 3 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 371
fault_reg                45            based           bit(36)                  level 2 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" set ref 744
                                                                                  744*
fault_reg              3025     000132 external static bit(36)                  level 4 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  342
fault_time               46(18)        based           bit(54)                  level 2 packed packed unaligned dcl 22-12 set ref
                                                                                  749 750 750 751*
fgbx                                   based           structure                level 1 dcl 8-24
fgbxp                           003252 automatic       pointer                  dcl 8-22 set ref 301* 302
first_init_seg            5            based           fixed bin(18,0)          level 2 dcl 15-13 ref 943
first_rec_num                   000041 constant        fixed bin(17,0)          initial array dcl 9-115 ref 1219
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 15-13 ref 943
fixed                                                  builtin function         dcl 177 ref 738 738 738 738 738 738 738 738 740 740
                                                                                  740 740 740 740 740 740 742 742 742 742 742 742
                                                                                  743 743 750 750 753 753
flagbox$                        000140 external static fixed bin(17,0)          dcl 8-21 set ref 301
flags                     1            based           structure                level 2 packed packed unaligned dcl 1-7
get_ptrs_$given_segno           000110 constant        entry                    external dcl 178 ref 1386 1386 1394 1394 1402 1402
                                                                                  1410 1410
header                                 based           structure                level 2 dcl 5-9
ilc                       4            based           bit(18)                  level 2 packed packed unaligned dcl 22-56 set ref
                                                                                  402 848*
index                                                  builtin function         dcl 179 ref 1121 1298 1317
instr_delta                     003305 automatic       fixed bin(18,0)          dcl 462 set ref 492* 501 515
instr_len                       003306 automatic       fixed bin(17,0)          dcl 463 set ref 499* 500 501* 506
instr_num                       003307 automatic       fixed bin(17,0)          dcl 464 set ref 495* 496*
instr_ptr                       003310 automatic       pointer                  dcl 465 in begin block on line 455 set ref 484* 486
                                                                                  507 519*
instr_ptr                       003454 automatic       pointer                  dcl 812 in begin block on line 809 set ref 815* 821*
                                                                                  825 827* 828 829 842 846 861*
instructions              1            based           bit(36)                  array level 2 dcl 5-21 set ref 492 495 496* 501 501
int_code                        000100 automatic       fixed bin(35,0)          dcl 1350 set ref 1353* 1358* 1359* 1366* 1371* 1372*
io_path                                based           structure                level 1 dcl 21-22
ioa_                            000112 constant        entry                    external dcl 180 ref 318 409 519 542 633 702 703 704
                                                                                  705 706 707 735 737 738 740 742 743 744 747 751
                                                                                  753 756 757 772 794 861 876 906 912 913 914 915
                                                                                  948 1007 1008 1009 1010 1469 1472
item_num                        003532 automatic       fixed bin(17,0)          dcl 981 set ref 1003* 1004* 1005* 1007* 1007 1008*
                                                                                  1008 1009* 1009 1010* 1010 1012* 1013
its                                    based           structure                level 1 dcl 12-5
its_mod                   0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 1483 ref 1486
j                               003333 automatic       fixed bin(17,0)          dcl 715 set ref 733* 734 734 735* 735*
last_init_seg             6            based           fixed bin(18,0)          level 2 dcl 15-13 ref 943
last_segnum               2     000144 automatic       fixed bin(15,0)          level 2 dcl 138 set ref 1384*
last_sp                         003472 automatic       pointer                  dcl 889 set ref 900* 903 903
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 15-13 ref 943
last_sv_rec_num                 000030 constant        fixed bin(18,0)          initial array dcl 9-121 ref 1219
left_from_before                001236 automatic       bit(144)                 level 2 dcl 294 set ref 625 625*
length                                                 builtin function         dcl 181 in procedure "bce_probe" ref 428 428 625 625
                                                                                  661 668
length                    1     001132 automatic       fixed bin(17,0)          level 2 in structure "value" dcl 288 in procedure
                                                                                  "bce_probe" set ref 662 662 663 670 670 671 1294*
                                                                                  1301 1302* 1302 1305 1306* 1306 1311 1312* 1312
                                                                                  1330* 1337*
line                                   based           char                     packed unaligned dcl 182 ref 437 437 468 468 657 665
                                                                                  665 816 816 961 961 1035 1047 1050 1267 1289 1289
                                                                                  1292 1295 1298 1300 1301 1305 1429
line_buffer                     000300 automatic       char(128)                packed unaligned dcl 183 set ref 425 428 428 428 428
line_len                        000340 automatic       fixed bin(17,0)          dcl 184 set ref 416* 418* 424 428* 437 437 439* 439
                                                                                  468 468 468 657 658* 658 665 665 816 816 816 961
                                                                                  961 961 1034 1035 1039* 1039 1046 1047 1050 1054*
                                                                                  1054 1267 1269 1271* 1271 1289 1289 1292 1295
                                                                                  1297* 1297 1298 1300 1301 1305 1309* 1309 1361*
                                                                                  1374* 1429 1430* 1432* 1432
line_ptr                        000342 automatic       pointer                  dcl 185 set ref 425* 437 437 440* 440 468 468 657
                                                                                  659* 659 665 665 816 816 961 961 1035 1040* 1040
                                                                                  1047 1050 1055* 1055 1266 1267 1272* 1272 1289
                                                                                  1289 1292 1295 1296* 1296 1298 1300 1301 1305
                                                                                  1308* 1308 1429 1433* 1433
lock                                   based           structure                level 1 dcl 11-12
long                            003334 automatic       bit(1)                   dcl 716 set ref 721* 723* 732 755
lot$                            000114 external static fixed bin(17,0)          dcl 186 set ref 1411 1411
mc                                     based           structure                level 1 dcl 22-12 set ref 730 730
mc_                             000176 automatic       structure                level 2 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe"
mc_                    2760     000132 external static structure                level 3 in structure "toehold$" dcl 286 in procedure
                                                                                  "bce_probe"
mc_state                               based           structure                level 1 dcl 21-42
mcp                             003274 automatic       pointer                  dcl 22-10 set ref 727* 728 730* 730 730 734 734 738
                                                                                  738 738 738 738 738 738 738 740 740 740 740 740
                                                                                  740 740 740 742 742 742 742 742 742 743 743 743
                                                                                  744 744 748 749 750 750 751 757 757 757 757 757
                                                                                  757 757 757
me                              000352 constant        char(5)                  initial packed unaligned dcl 187 set ref 313* 398*
                                                                                  1359* 1372* 1388* 1391* 1396* 1399* 1404* 1407*
                                                                                  1412* 1415* 1418*
message                                parameter       char                     packed unaligned dcl 1351 set ref 1344 1356 1359*
                                                                                  1364 1369 1372*
min                                                    builtin function         dcl 188 ref 605 615 684 997
mod                                                    builtin function         dcl 189 in procedure "bce_probe" ref 613 614 685 686
                                                                                  999 1000 1001
mod                       1(30)        based           bit(6)                   level 2 in structure "my_ptr_bits" packed packed
                                                                                  unaligned dcl 1483 in procedure "validate_ptr" ref
                                                                                  1486
mode                            003330 automatic       fixed bin(17,0)          dcl 572 in begin block on line 561 set ref 575* 580*
                                                                                  583* 584* 585* 587* 598 599 606* 620*
mode                                   parameter       fixed bin(17,0)          dcl 982 in procedure "display" ref 968 999 1000 1003
                                                                                  1004 1007 1008 1009 1010 1011
mode_reg                 60     000176 automatic       bit(36)                  level 2 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe" set ref 373
mode_reg               3062     000132 external static bit(36)                  level 3 in structure "toehold$" dcl 286 in procedure
                                                                                  "bce_probe" set ref 344
multics_state          2760     000132 external static structure                level 2 dcl 286
my_apte                         003352 automatic       structure                level 1 dcl 779 set ref 789
my_dbr                          000344 automatic       bit(72)                  dcl 190 set ref 388* 389* 390 391* 540* 541* 542*
                                                                                  547 633*
my_initial_dbr                  000346 automatic       bit(72)                  dcl 191 set ref 390* 540
my_ptr                          005670 automatic       pointer                  dcl 1482 set ref 1486* 1487* 1488
my_ptr_bits                            based           structure                level 1 dcl 1483
my_seg_info                     000350 automatic       structure                level 1 dcl 192 set ref 379
my_seg_info_ptr                 000144 automatic       pointer                  level 2 dcl 138 set ref 379* 403* 406* 479* 482*
                                                                                  493* 510* 516* 675* 787* 790* 831* 840* 853* 856*
                                                                                  1072* 1197* 1387* 1390* 1395* 1398* 1403* 1406*
                                                                                  1411* 1414* 1454* 1459*
name_table$                     000116 external static fixed bin(17,0)          dcl 193 set ref 1395 1395
new_segnum                      005573 automatic       fixed bin(15,0)          dcl 1090 set ref 1159* 1161
new_wordnum                     005574 automatic       fixed bin(26,0)          dcl 1091 set ref 1108* 1109* 1110 1111 1159* 1162
next_sp                  22            based           pointer                  level 2 dcl 17-36 ref 917 917
null                                                   builtin function         dcl 194 ref 305 394 411 413 815 825 826 851 1487
num_args                               parameter       fixed bin(17,0)          dcl 1030 ref 1023 1032 1038 1047
number                          005575 automatic       fixed bin(35,0)          dcl 1092 in procedure "get_address" set ref 1106*
                                                                                  1108 1109 1152* 1153 1165* 1166 1168 1170 1171
                                                                                  1187* 1190
number                          005630 automatic       fixed bin(35,0)          dcl 1282 in procedure "get_value" set ref 1327* 1328
                                                                                  1328 1331 1334* 1338
offset                          005576 automatic       char(16)                 packed unaligned dcl 1093 in procedure "get_address"
                                                                                  set ref 1133* 1139* 1148* 1165*
offset                                 based           fixed bin(18,0)          level 2 in structure "bkpt_tra_instr" packed packed
                                                                                  unsigned unaligned dcl 458
                                                                                  in begin block on line 455 set ref 515*
offset_delim_pos                005602 automatic       fixed bin(17,0)          dcl 1094 set ref 1122* 1124 1125 1125 1128 1129 1130
                                                                                  1132 1133 1143 1143 1144 1145 1146 1148 1168
old_instr_buffer                000772 automatic       bit(36)                  array dcl 195 set ref 493 493 493 493 499 499 501
                                                                                  501 508 514 515 516 516
op                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 458 set ref 514*
original_instr            7            based           bit(36)                  level 2 dcl 5-21 set ref 508* 853 853
original_instr_ptr      106            based           pointer                  array level 3 in structure "bkpt_page" packed packed
                                                                                  unaligned dcl 5-9 in procedure "bce_probe" set ref
                                                                                  486 842 1465 1472
original_instr_ptr        6            based           pointer                  level 2 in structure "breakpoint" packed packed
                                                                                  unaligned dcl 5-21 in procedure "bce_probe" set
                                                                                  ref 408 507*
p_data_bit_lth                         parameter       fixed bin(24,0)          dcl 983 ref 968 992
p_data_ptr                             parameter       pointer                  dcl 984 ref 968 994
p_ss_info_ptr                          parameter       pointer                  dcl 196 ref 18 300
p_word_label                           parameter       fixed bin(26,0)          dcl 985 ref 968 995
packed_ptr                      005661 automatic       structure                level 1 dcl 1443 set ref 1465*
pad1                                   based           bit(3)                   level 2 packed packed unaligned dcl 1483 ref 1486
pad2                      0(21)        based           bit(9)                   level 2 packed packed unaligned dcl 1483 ref 1486
pad_descriptors           1     000106 automatic       fixed bin(18,0)          initial level 2 packed packed unsigned unaligned
                                                                                  dcl 115 set ref 115*
partial                                parameter       bit(1)                   dcl 986 ref 968 1006
pc$nullify                      000120 constant        entry                    external dcl 197 ref 1386 1394 1402 1410
pointer_value                          based           pointer                  dcl 1283 set ref 1331*
ppr                                    based           structure                level 2 packed packed unaligned dcl 22-56
prev_sp                         003474 automatic       pointer                  dcl 890 set ref 895* 903 916*
prr                                    based           bit(3)                   level 3 packed packed unaligned dcl 22-56 ref 753
                                                                                  753
prs                    2760     000132 external static pointer                  array level 4 in structure "toehold$" dcl 286
                                                                                  in procedure "bce_probe" set ref 321 322 323 324
                                                                                  325 326 327 328
prs                             000176 automatic       pointer                  array level 3 in structure "breakpoint_page_buffer"
                                                                                  dcl 160 in procedure "bce_probe" set ref 350 351
                                                                                  352 353 354 355 356 357
prs                                    based           pointer                  array level 2 in structure "mc" dcl 22-12
                                                                                  in procedure "bce_probe" ref 734 734
prs                             000342 constant        char(4)                  initial array packed unaligned dcl 198 in procedure
                                                                                  "bce_probe" set ref 735*
psr                       0(03)        based           bit(15)                  level 3 packed packed unaligned dcl 22-56 ref 402
ptr                                                    builtin function         dcl 200 ref 896 1331
ptr_bits                               parameter       bit(72)                  dcl 1484 set ref 1478 1486 1486 1486 1486 1486
ptr_from_mc                     003336 automatic       pointer                  dcl 717 set ref 734* 735* 735*
pvt                                    based           structure                level 1 dcl 13-13
pvt$                            000142 external static fixed bin(17,0)          dcl 13-9 set ref 1214
pvt_array                              based           structure                array level 1 dcl 14-24
pvt_arrayp                      003260 automatic       pointer                  dcl 14-21 set ref 1215* 1219 1219
pvte                                   based           structure                level 1 dcl 14-26
pvtp                            003256 automatic       pointer                  dcl 13-9 set ref 1214* 1215
pvtx                      5     000144 automatic       fixed bin(17,0)          level 3 dcl 138 set ref 651* 694* 1076* 1219 1219
                                                                                  1232*
q                        25     000176 automatic       bit(36)                  level 4 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 367
q                      3005     000132 external static bit(36)                  level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  338
q                        25            based           bit(36)                  level 3 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" ref 742 742
ralr                   3007(33) 000132 external static bit(3)                   level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  341
ralr                     27(33) 000176 automatic       bit(3)                   level 4 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 370
ralr                     27(33)        based           bit(3)                   level 3 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" set ref 743*
read_disk                       000122 constant        entry                    external dcl 201 ref 651 1076
record_num                6     000144 automatic       fixed bin(18,0)          level 3 dcl 138 set ref 651* 694* 1076* 1218* 1219
                                                                                  1219
reg_index                       000100 automatic       fixed bin(17,0)          dcl 1243 set ref 1250* 1250* 1252 1253 1254 1255
reg_lens                        000307 constant        fixed bin(17,0)          initial array dcl 231 ref 1255
reg_modes                       000776 automatic       fixed bin(17,0)          initial array dcl 236 set ref 236* 236* 236* 236*
                                                                                  236* 236* 236* 236* 236* 236* 236* 236* 236* 236*
                                                                                  236* 236* 236* 236* 236* 236* 236* 236* 236* 236*
                                                                                  236* 236* 236* 1254
reg_name                               based           char                     packed unaligned dcl 1244 set ref 1249 1250 1252*
reg_name_len                           parameter       fixed bin(17,0)          dcl 1245 ref 1241 1249 1250 1252 1252
reg_name_ptr                           parameter       pointer                  dcl 1246 ref 1241 1249 1250 1252
reg_names                       000212 constant        char(9)                  initial array packed unaligned dcl 241 ref 1250 1250
                                                                                  1252
reg_ptr                  10     000144 automatic       pointer                  level 3 dcl 138 set ref 606* 687 1253*
reg_ptrs                        001032 automatic       pointer                  array dcl 246 set ref 321* 322* 323* 324* 325* 326*
                                                                                  327* 328* 329* 330* 331* 332* 333* 334* 335* 336*
                                                                                  337* 338* 339* 340* 341* 342* 343* 344* 345* 346*
                                                                                  347* 350* 351* 352* 353* 354* 355* 356* 357* 358*
                                                                                  359* 360* 361* 362* 363* 364* 365* 366* 367* 368*
                                                                                  369* 370* 371* 372* 373* 374* 375* 376* 1253
register                               based           bit                      packed unaligned dcl 644 set ref 687*
regs                   3000     000132 external static structure                level 4 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe"
regs                     20            based           structure                level 2 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe"
regs                     20     000176 automatic       structure                level 3 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
req_index                       001120 automatic       fixed bin(17,0)          dcl 247 set ref 446* 446* 448 448
requests                        000052 constant        char(16)                 initial array packed unaligned dcl 273 ref 446 446
                                                                                  448
return_ptr               24            based           pointer                  level 2 dcl 17-36 ref 914 914 914 914
rtb                      43            based           structure                level 2 dcl 8-24
rtrim                                                  builtin function         dcl 202 ref 1151 1151
sb                              003270 automatic       pointer                  dcl 18-24 set ref 897* 898* 898 898 900 900 901 901
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 22-12 in procedure "bce_probe" set
                                                                                  ref 728
scu                      30     000176 automatic       bit(36)                  array level 3 in structure "breakpoint_page_buffer"
                                                                                  packed packed unaligned dcl 160 in procedure
                                                                                  "bce_probe" set ref 401 847
scu                                    based           structure                level 1 dcl 22-56 in procedure "bce_probe"
scup                            003276 automatic       pointer                  dcl 22-54 set ref 401* 402 402 728* 748* 748 753 753
                                                                                  755 847* 848
sdw_info                               based           structure                level 1 dcl 4-6
sdwi                    414     000350 automatic       structure                level 2 dcl 192
search                                                 builtin function         dcl 275 ref 1122 1267
seek_command                    003254 automatic       bit(6)                   initial array packed unaligned dcl 9-84 set ref
                                                                                  9-84* 9-84* 9-84* 9-84* 9-84* 9-84* 9-84* 9-84*
                                                                                  9-84*
seg                      10            based           structure                array level 2 dcl 15-13 set ref 475 836 1450
seg_id                          005603 automatic       char(32)                 packed unaligned dcl 1095 set ref 1131* 1137* 1146*
                                                                                  1150 1151 1152* 1155* 1159*
seg_id_len                      005631 automatic       fixed bin(17,0)          dcl 1284 set ref 1317* 1318 1319 1320 1320 1322 1322
                                                                                  1326 1327 1327
seg_info                               based           structure                level 1 dcl 2-9
segname                         003456 automatic       char(32)                 packed unaligned dcl 867 set ref 872* 874* 875*
segno                                                  builtin function         dcl 276 ref 403 403 787 787 828 903 903 1386 1386
                                                                                  1386 1386 1387 1387 1394 1394 1394 1394 1395 1395
                                                                                  1402 1402 1402 1402 1403 1403 1410 1410 1410 1410
                                                                                  1411 1411
segnum                    0(06) 005661 automatic       fixed bin(12,0)          level 2 in structure "packed_ptr" packed packed
                                                                                  unsigned unaligned dcl 1443 in procedure "status"
                                                                                  set ref 1466
segnum                   12     000144 automatic       fixed bin(15,0)          level 3 in structure "bce_probe_data" dcl 138
                                                                                  in procedure "bce_probe" set ref 475 476* 479* 484
                                                                                  821 828* 831* 836 895 896 1153* 1155* 1159* 1161*
                                                                                  1197*
segnum                          003466 automatic       fixed bin(15,0)          dcl 868 in begin block on line 865 set ref 874* 876*
segnum                          003350 automatic       fixed bin(15,0)          dcl 765 in begin block on line 763 set ref 769* 772*
segnum                          005632 automatic       fixed bin(15,0)          dcl 1285 in procedure "get_value" set ref 1320*
                                                                                  1322* 1331
segnum                          003477 automatic       fixed bin(15,0)          dcl 925 in begin block on line 922 set ref 928* 931*
                                                                                  933* 941 943* 944* 947*
segnum                                 parameter       fixed bin(15,0)          dcl 1447 in procedure "status" set ref 1438 1450
                                                                                  1454* 1466 1469*
size                                                   builtin function         dcl 277 in procedure "bce_probe" ref 396 396 406 406
                                                                                  493 493 510 510 689 689 730 730 790 790 790 849
                                                                                  849 856 856 898 898 909 909
size                    415     000350 automatic       fixed bin(19,0)          level 3 in structure "my_seg_info" dcl 192
                                                                                  in procedure "bce_probe" set ref 482 492 510 592
                                                                                  840 856 1390 1398 1406 1414 1459
slt                                    based           structure                level 1 dcl 15-13
slt$                            000124 external static fixed bin(17,0)          dcl 278 set ref 380 1387 1387
slte                                   based           structure                level 1 dcl 16-48
sltep                           003264 automatic       pointer                  dcl 16-8 set ref 475* 477 836* 837 1450* 1451
sltp                            003262 automatic       pointer                  dcl 15-7 set ref 380* 474* 475 835* 836 942* 943 943
                                                                                  943 943 1449* 1450
sp                              003266 automatic       pointer                  dcl 17-31 set ref 897* 909* 909 909 913 913 913 913
                                                                                  914 914 914 914 915 915 915 915 917 917
ss_info                                based           structure                level 1 dcl 6-15
ss_info_ptr                     003250 automatic       pointer                  dcl 6-14 set ref 300* 305 306 308
stack_begin_ptr          22            based           pointer                  level 2 dcl 18-26 ref 901 901
stack_end_ptr            24            based           pointer                  level 2 dcl 18-26 ref 900 900
stack_frame                            based           structure                level 1 dcl 17-36 ref 909 909
stack_header                           based           structure                level 1 dcl 18-26 ref 898 898
starting_bit                    003332 automatic       fixed bin(17,0)          dcl 645 set ref 648* 653* 661 662 668 670 685* 686*
                                                                                  687
state                     1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 1-7 ref 792
string                                 based           char                     packed unaligned dcl 279 set ref 446 545* 551* 579
                                                                                  583 584 585 586 592 596* 723 723 769* 783* 872
                                                                                  931* 933* 1099 1105 1105 1106 1106 1108 1121 1122
                                                                                  1131 1132 1133 1137 1138 1143 1143 1146 1148 1168
                                                                                  1179 1179 1183 1187* 1191 1317 1320 1320 1322 1322
                                                                                  1327 1327 1334* 1359*
string_len                      001121 automatic       fixed bin(17,0)          dcl 280 set ref 422* 423 436 446 538 545 545 550 551
                                                                                  551 578 579 583 584 585 586 592 592 596 596 723
                                                                                  723 723 768 769 769 782 783 783 871 872 930 931
                                                                                  931 933 933 964* 1042 1044 1098 1099 1101 1104
                                                                                  1105 1105 1106 1106 1108 1121 1122 1129 1131 1132
                                                                                  1133 1136 1137 1138 1143 1143 1144 1146 1148 1168
                                                                                  1179 1179 1183 1187 1187 1191 1267* 1269 1269*
                                                                                  1270* 1270 1271 1272 1291* 1316 1317 1320 1320
                                                                                  1322 1322 1326 1327 1327 1334 1334 1359 1359 1359
string_ptr                      001122 automatic       pointer                  dcl 281 set ref 446 545 551 579 583 584 585 586 592
                                                                                  596 723 723 769 783 872 931 933 1043 1099 1105
                                                                                  1105 1106 1106 1108 1121 1122 1131 1132 1133 1137
                                                                                  1138 1143 1143 1146 1148 1168 1179 1179 1183 1187
                                                                                  1191 1266* 1317 1320 1320 1322 1322 1327 1327 1334
                                                                                  1359
sub_request_abort_              001124 stack reference condition                dcl 282 ref 417
substr                                                 builtin function         dcl 283 set ref 437 437 468 468 548* 554* 625* 625
                                                                                  657 662* 662 665 665 670* 670 687 755 816 816 961
                                                                                  961 1035 1047 1050 1099 1105 1105 1106 1106 1108
                                                                                  1131 1132 1133 1137 1138 1143 1143 1146 1148 1168
                                                                                  1289 1289 1292 1295 1300 1301* 1301 1305* 1305
                                                                                  1311* 1320 1320 1322 1322 1327 1327
substr_len                      005633 automatic       fixed bin(17,0)          dcl 1286 set ref 1298* 1299 1300 1301 1301 1302 1305
                                                                                  1305 1306 1308 1309
sys_boot_info$bce_dbr           000126 external static bit(72)                  dcl 284 ref 389
sys_info$collection_1_phase     000136 external static fixed bin(17,0)          dcl 7-8 ref 303 303 528 528
t                        27            based           bit(27)                  level 3 in structure "mc" packed packed unaligned
                                                                                  dcl 22-12 in procedure "bce_probe" ref 743 743
t                      3007     000132 external static bit(27)                  level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  340
t                        27     000176 automatic       bit(27)                  level 4 in structure "breakpoint_page_buffer" packed
                                                                                  packed unaligned dcl 160 in procedure "bce_probe"
                                                                                  set ref 369
tag                       0(18) 000106 automatic       bit(18)                  initial level 2 packed packed unaligned dcl 115 set
                                                                                  ref 115*
tc_data$                        000130 external static fixed bin(17,0)          dcl 285 set ref 786
tcm                                    based           structure                level 1 dcl 20-11
tcmp                            003272 automatic       pointer                  dcl 20-9 set ref 786* 787 787 790
this_data_lth                   003533 automatic       fixed bin(17,0)          dcl 988 set ref 997* 999 1000 1001 1002 1002 1003
                                                                                  1004 1005 1006 1013* 1015 1016 1017 1018
time                            003340 automatic       char(32)                 packed unaligned dcl 718 set ref 750* 751*
toe_hold                               based           structure                level 1 dcl 21-11
toehold$                        000132 external static structure                level 1 dcl 286
tra_back                  5(18)        based           bit(18)                  level 2 packed packed unaligned dcl 5-21 set ref
                                                                                  505*
tra_back_offset           5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-21
                                                                                  set ref 506*
twice_num_args                  000106 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 115 set
                                                                                  ref 1032*
type                      4     000144 automatic       fixed bin(17,0)          level 3 in structure "bce_probe_data" dcl 138
                                                                                  in procedure "bce_probe" set ref 381* 471 592 604
                                                                                  649 674 678 683 820 830* 893 1071 1072 1073 1100
                                                                                  1102 1117* 1173* 1189* 1196 1222* 1256* 1419*
type                            001132 automatic       fixed bin(17,0)          level 2 in structure "value" dcl 288 in procedure
                                                                                  "bce_probe" set ref 1293* 1329* 1336*
unspec                                                 builtin function         dcl 287 set ref 488 548 554 734 734 794 794 795 795
                                                                                  855* 900 900 901 901 913 913 913 913 914 914 914
                                                                                  914 915 915 915 915 917 917 1465* 1465 1486*
user_data                              based           bit                      packed unaligned dcl 989 set ref 1002* 1002
value                           001132 automatic       structure                level 1 dcl 288
verify                                                 builtin function         dcl 293 ref 1429
wct_entry                              based           structure                level 1 dcl 20-260
white_len                       005650 automatic       fixed bin(17,0)          dcl 1427 set ref 1429* 1430 1431 1432 1433
word_label                      003534 automatic       fixed bin(26,0)          dcl 990 set ref 995* 1007 1007* 1008 1008* 1009
                                                                                  1009* 1010 1010* 1012* 1017 1017* 1017
wordno                                                 builtin function         dcl 298 ref 406 406 492 492 510 510 748 748 790 829
                                                                                  856 856 901 903 903 903 903 909
wordnum                  13     000144 automatic       fixed bin(26,0)          level 3 dcl 138 set ref 484 492 493* 506 515 516*
                                                                                  592 609 617 650 650 653 675* 679* 748 821 829* 848
                                                                                  853* 896 898 909 1071 1072 1073 1073 1077 1108
                                                                                  1109 1111* 1162* 1164* 1168* 1168 1170 1171* 1171
                                                                                  1190* 1220* 1221
work_area                       001236 automatic       structure                level 1 dcl 294
write_disk                      000134 constant        entry                    external dcl 297 ref 694
x                        20     000176 automatic       bit(18)                  array level 4 in structure "breakpoint_page_buffer"
                                                                                  packed packed unaligned dcl 160 in procedure
                                                                                  "bce_probe" set ref 358 359 360 361 362 363 364
                                                                                  365
x                        20            based           bit(18)                  array level 3 in structure "mc" packed packed
                                                                                  unaligned dcl 22-12 in procedure "bce_probe" ref
                                                                                  738 738 738 738 738 738 738 738 740 740 740 740
                                                                                  740 740 740 740
x                      3000     000132 external static bit(18)                  array level 5 in structure "toehold$" packed packed
                                                                                  unaligned dcl 286 in procedure "bce_probe" set ref
                                                                                  329 330 331 332 333 334 335 336

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
At_bce__boot                           internal static fixed bin(17,0)          initial dcl 21-66
At_bce__crash                          internal static fixed bin(17,0)          initial dcl 21-70
At_bce__early                          internal static fixed bin(17,0)          initial dcl 21-65
At_bce__shutdown                       internal static fixed bin(17,0)          initial dcl 21-71
BKPT_page_sentinel                     internal static char(4)                  initial packed unaligned dcl 5-30
BOOT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 7-11
Blocked_apte                           internal static bit(18)                  initial packed unaligned dcl 19-11
COLLECTION_1_PHASE_NAMES               internal static char(16)                 initial array packed unaligned dcl 7-23
EARLY_INITIALIZATION                   internal static fixed bin(17,0)          initial dcl 7-10
FLAGBOX_SENTINEL                       internal static char(32)                 initial packed unaligned dcl 8-51
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 12-56
Initial_undefined                      internal static fixed bin(17,0)          initial dcl 21-64
MODEL                                  internal static fixed bin(17,0)          initial array dcl 9-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 9-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 9-60
Multics                                internal static fixed bin(17,0)          initial dcl 21-67
Ptlocking_apte                         internal static bit(18)                  initial packed unaligned dcl 19-13
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 17-19
RE_EARLY_INITIALIZATION                internal static fixed bin(17,0)          initial dcl 7-19
Ready_apte                             internal static bit(18)                  initial packed unaligned dcl 19-9
Running_apte                           internal static bit(18)                  initial packed unaligned dcl 19-8
SERVICE_INITIALIZATION                 internal static fixed bin(17,0)          initial dcl 7-12
SHUT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 7-21
Stopped_apte                           internal static bit(18)                  initial packed unaligned dcl 19-12
TOE_HOLD_BOOT_ENTRY                    internal static fixed bin(17,0)          initial dcl 21-36
TOE_HOLD_BOS_ENTRY                     internal static fixed bin(17,0)          initial dcl 21-37
TOE_HOLD_BOS_MULTICS_ENTRY             internal static fixed bin(17,0)          initial dcl 21-39
TOE_HOLD_BOS_NO_SAVE_ENTRY             internal static fixed bin(17,0)          initial dcl 21-38
TOE_HOLD_CRASH_ENTRY                   internal static fixed bin(17,0)          initial dcl 21-31
TOE_HOLD_DUMP_ENTRY                    internal static fixed bin(17,0)          initial dcl 21-33
TOE_HOLD_ESD_ENTRY                     internal static fixed bin(17,0)          initial dcl 21-32
TOE_HOLD_MULTICS_ENTRY                 internal static fixed bin(17,0)          initial dcl 21-34
TOE_HOLD_RESTART_ENTRY                 internal static fixed bin(17,0)          initial dcl 21-35
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 17-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 17-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 17-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 17-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 17-27
Undefined_continue                     internal static fixed bin(17,0)          initial dcl 21-72
Undefined_reading_bce                  internal static fixed bin(17,0)          initial dcl 21-69
Undefined_saving_mem                   internal static fixed bin(17,0)          initial dcl 21-73
Undefined_saving_state                 internal static fixed bin(17,0)          initial dcl 21-68
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 14-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 14-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 14-113
Waiting_apte                           internal static bit(18)                  initial packed unaligned dcl 19-10
abx                                    internal static fixed bin(17,0)          initial dcl 22-42
aclp                                   automatic       pointer                  dcl 15-7
acls                                   based           structure                level 1 dcl 15-45
apx                                    internal static fixed bin(17,0)          initial dcl 22-42
asta                                   based           bit(432)                 array dcl 3-86
aste_part                              based           structure                level 1 dcl 3-89
astep                                  automatic       pointer                  dcl 3-9
bbx                                    internal static fixed bin(17,0)          initial dcl 22-42
bpx                                    internal static fixed bin(17,0)          initial dcl 22-42
bulkdevt                               internal static fixed bin(4,0)           initial dcl 9-43
call_offset                            internal static fixed bin(17,0)          initial dcl 18-78
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 9-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 9-105
dev_time                               internal static float bin(27)            initial array dcl 9-139
device_names                           internal static char(4)                  initial array dcl 9-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 9-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 9-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 9-43
entry_offset                           internal static fixed bin(17,0)          initial dcl 18-78
fips3380devt                           internal static fixed bin(4,0)           initial dcl 9-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 9-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 9-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 9-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 9-69
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 9-124
itp                                    based           structure                level 1 dcl 12-18
itp_unsigned                           based           structure                level 1 dcl 12-43
its_unsigned                           based           structure                level 1 dcl 12-30
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 9-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 9-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 9-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 9-127
lbx                                    internal static fixed bin(17,0)          initial dcl 22-42
lock_ptr                               automatic       pointer                  dcl 11-11
lpx                                    internal static fixed bin(17,0)          initial dcl 22-42
maxdevt                                internal static fixed bin(4,0)           initial dcl 9-43
mc_state_ptr                           automatic       pointer                  dcl 21-41
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 9-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 9-43
name_seg                               based           structure                level 1 dcl 15-26
namep                                  automatic       pointer                  dcl 15-7
names_ptr                              automatic       pointer                  dcl 15-7
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 9-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 9-93
path                                   based           structure                level 1 dcl 15-40
pathp                                  automatic       pointer                  dcl 15-7
push_offset                            internal static fixed bin(17,0)          initial dcl 18-78
pvt$array                              external static fixed bin(17,0)          dcl 14-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 14-19
pvtep                                  automatic       pointer                  dcl 14-22
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 9-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 9-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 9-90
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 18-78
return_offset                          internal static fixed bin(17,0)          initial dcl 18-78
sbx                                    internal static fixed bin(17,0)          initial dcl 22-42
scux                                   based           structure                level 1 dcl 22-207
sdw_info_ptr                           automatic       pointer                  dcl 4-4
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 10-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 10-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 10-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 10-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 10-26
seg_aste                               based           structure                level 1 dcl 3-96
seg_info_ptr                           automatic       pointer                  dcl 2-8
segnam                                 based           structure                level 1 dcl 15-31
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 9-78
slte_uns                               based           structure                level 1 dcl 16-10
spx                                    internal static fixed bin(17,0)          initial dcl 22-42
stack_frame_flags                      based           structure                level 1 dcl 17-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 17-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 18-94
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 9-111
tv_offset                              internal static fixed bin(17,0)          initial dcl 18-72
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 9-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 9-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 10-29
wctep                                  automatic       pointer                  dcl 20-258
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 10-36

NAMES DECLARED BY EXPLICIT CONTEXT.
arg_error                       013711 constant        label                    dcl 1372 ref 1367
arg_list_missing                010722 constant        label                    dcl 1035 ref 1034
arg_missing                     011015 constant        label                    dcl 1050 ref 1042 1046
bad_apte                        006577 constant        label                    dcl 792 ref 788 791
bad_disk_name                   012632 constant        label                    dcl 1234
bad_instr_error                 003610 constant        label                    dcl 502 ref 500
bad_octal                       004162 constant        label                    dcl 552 ref 546
bce_probe                       001634 constant        entry                    external dcl 18
before_bad_access               003731 constant        label                    dcl 517 ref 480 483 494 513
check_no_more_args              010202 constant        entry                    internal dcl 956 ref 472 526 539 556 603 631 700 726
                                                                                  771 785 802 823 873 894 938
disk_address                    012376 constant        entry                    internal dcl 1202 ref 1184 1184
display                         010231 constant        entry                    internal dcl 968 ref 606 620
do_request                      000000 constant        label                    array(24) dcl 451 ref 448 451 523 636 639 710 799
                                                                                  806 880 883
done                            012340 constant        label                    dcl 1196 ref 1101 1112 1175 1181 1185 1192
error                           013565 constant        label                    dcl 1359 ref 1354
fetch_                          011052 constant        entry                    internal dcl 1061 ref 617 730 898 909
finish                          010201 constant        label                    dcl 954 ref 804
function                        010704 constant        entry                    internal dcl 1023 ref 1180 1184
get_address                     011206 constant        entry                    internal dcl 1084 ref 468 574 647 720 819 892
get_string                      013001 constant        entry                    internal dcl 1261 ref 435 537 549 577 591 722 767
                                                                                  781 870 929 1041 1097 1315
get_value                       013034 constant        entry                    internal dcl 1276 ref 660 667
let_bad_access                  005064 constant        label                    dcl 680 ref 676
let_values_too_long             004762 constant        label                    dcl 668 ref 661
line_error                      013531 constant        entry                    internal dcl 1344 ref 442 448 471 486 502 528 552
                                                                                  590 597 650 657 668 725 768 770 782 784 792 820
                                                                                  826 844 871 893 934 961 1035 1047 1050 1098 1100
                                                                                  1102 1104 1105 1107 1110 1125 1127 1129 1130 1136
                                                                                  1143 1144 1145 1166 1170 1194 1248 1289 1299 1316
                                                                                  1319 1326 1328 1341
line_error_arg                  013645 constant        entry                    internal dcl 1364 ref 477 490 837 1219 1221 1252
                                                                                  1453
line_error_arg_code             013667 constant        entry                    internal dcl 1369 ref 517 618 652 680 695 731 859
                                                                                  875 910 1234 1462
line_error_code                 013547 constant        entry                    internal dcl 1356 ref 429 690 1156 1160 1198 1323
lookup_disk                     012603 constant        entry                    internal dcl 1225 ref 1216
new_dbr                         013751 constant        entry                    internal dcl 1378 ref 391 541 557 795
pass_white                      014677 constant        entry                    internal dcl 1423 ref 467 655 664 672 814 927 960
                                                                                  1033 1045 1265 1288
reg_address                     012663 constant        entry                    internal dcl 1241 ref 1180 1180
request_done                    010200 constant        label                    dcl 952 ref 419 520 530 543 558 628 634 697 708 760
                                                                                  773 796 862 877 907 919 949 1362 1375
reset_bad_access                007226 constant        label                    dcl 859 ref 832 841 850 854
stack_bad_access                007561 constant        label                    dcl 910 ref 899
status                          014731 constant        entry                    internal dcl 1438 ref 944 947
status_bad_access               015045 constant        label                    dcl 1462 ref 1455
validate_ptr                    015224 constant        entry                    internal dcl 1478 ref 734 900 901 913 913 914 914
                                                                                  915 915 917

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     17136       17304   16313       17146
Length     20322   16313       146        1002     622           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bce_probe                          3802 external procedure  is an external procedure.  
on unit on line 417                  64 on unit               
begin block on line 455                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 532                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 561                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 642                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 713                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 763                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 776                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 809                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 865                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 886                 begin block         shares stack frame of external procedure bce_probe.  
begin block on line 922                 begin block         shares stack frame of external procedure bce_probe.  
check_no_more_args                      internal procedure  shares stack frame of external procedure bce_probe.  
display                                 internal procedure  shares stack frame of external procedure bce_probe.  
function                                internal procedure  shares stack frame of external procedure bce_probe.  
fetch_                                  internal procedure  shares stack frame of external procedure bce_probe.  
get_address                             internal procedure  shares stack frame of external procedure bce_probe.  
disk_address                        118 internal procedure  is assigned to an entry variable.  
lookup_disk                             internal procedure  shares stack frame of internal procedure disk_address.  
reg_address                          86 internal procedure  is assigned to an entry variable.  
get_string                              internal procedure  shares stack frame of external procedure bce_probe.  
get_value                               internal procedure  shares stack frame of external procedure bce_probe.  
line_error                          108 internal procedure  is called by several nonquick procedures.  
new_dbr                                 internal procedure  shares stack frame of external procedure bce_probe.  
pass_white                              internal procedure  shares stack frame of external procedure bce_probe.  
status                                  internal procedure  shares stack frame of external procedure bce_probe.  
validate_ptr                            internal procedure  shares stack frame of external procedure bce_probe.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bce_probe                000100 TRA                         bce_probe
                         000101 arg_index                   bce_probe
                         000102 arg_len                     bce_probe
                         000103 arg_num                     bce_probe
                         000104 arg_ptr                     bce_probe
                         000106 arg_list                    bce_probe
                         000130 arg_str_lens                bce_probe
                         000134 arg_str_ptrs                bce_probe
                         000144 bce_probe_data              bce_probe
                         000172 breakpoint_absadr           bce_probe
                         000174 breakpoint_at               bce_probe
                         000176 breakpoint_page_buffer      bce_probe
                         000276 code                        bce_probe
                         000277 examine_mode                bce_probe
                         000300 line_buffer                 bce_probe
                         000340 line_len                    bce_probe
                         000342 line_ptr                    bce_probe
                         000344 my_dbr                      bce_probe
                         000346 my_initial_dbr              bce_probe
                         000350 my_seg_info                 bce_probe
                         000772 old_instr_buffer            bce_probe
                         000776 reg_modes                   bce_probe
                         001032 reg_ptrs                    bce_probe
                         001120 req_index                   bce_probe
                         001121 string_len                  bce_probe
                         001122 string_ptr                  bce_probe
                         001132 value                       bce_probe
                         001236 work_area                   bce_probe
                         003242 aptep                       bce_probe
                         003244 bkpt_page_ptr               bce_probe
                         003246 breakpoint_ptr              bce_probe
                         003250 ss_info_ptr                 bce_probe
                         003252 fgbxp                       bce_probe
                         003254 seek_command                bce_probe
                         003256 pvtp                        bce_probe
                         003260 pvt_arrayp                  bce_probe
                         003262 sltp                        bce_probe
                         003264 sltep                       bce_probe
                         003266 sp                          bce_probe
                         003270 sb                          bce_probe
                         003272 tcmp                        bce_probe
                         003274 mcp                         bce_probe
                         003276 scup                        bce_probe
                         003303 bkpt_num                    begin block on line 455
                         003304 eis_len                     begin block on line 455
                         003305 instr_delta                 begin block on line 455
                         003306 instr_len                   begin block on line 455
                         003307 instr_num                   begin block on line 455
                         003310 instr_ptr                   begin block on line 455
                         003312 dbr_value                   begin block on line 532
                         003314 dbr_word                    begin block on line 532
                         003315 bits_left_over              begin block on line 561
                         003316 buffer_data_ptr             begin block on line 561
                         003320 data_address                begin block on line 561
                         003321 data_bits_done              begin block on line 561
                         003322 data_label                  begin block on line 561
                         003323 data_length                 begin block on line 561
                         003324 data_part_bits              begin block on line 561
                         003325 data_part_words             begin block on line 561
                         003326 display_buffer_ptr          begin block on line 561
                         003330 mode                        begin block on line 561
                         003331 data_length                 begin block on line 642
                         003332 starting_bit                begin block on line 642
                         003333 j                           begin block on line 713
                         003334 long                        begin block on line 713
                         003336 ptr_from_mc                 begin block on line 713
                         003340 time                        begin block on line 713
                         003350 segnum                      begin block on line 763
                         003351 apte_num                    begin block on line 776
                         003352 my_apte                     begin block on line 776
                         003452 bkpt_num                    begin block on line 809
                         003454 instr_ptr                   begin block on line 809
                         003456 segname                     begin block on line 865
                         003466 segnum                      begin block on line 865
                         003470 current_sp                  begin block on line 886
                         003472 last_sp                     begin block on line 886
                         003474 prev_sp                     begin block on line 886
                         003476 any_breaks                  begin block on line 922
                         003477 segnum                      begin block on line 922
                         003520 data_area                   display
                         003524 data_area_ptr               display
                         003526 data_bit_lth                display
                         003530 data_ptr                    display
                         003532 item_num                    display
                         003533 this_data_lth               display
                         003534 word_label                  display
                         003544 arg_index                   function
                         003554 buffer                      fetch_
                         005562 component                   get_address
                         005572 component_delim_pos         get_address
                         005573 new_segnum                  get_address
                         005574 new_wordnum                 get_address
                         005575 number                      get_address
                         005576 offset                      get_address
                         005602 offset_delim_pos            get_address
                         005603 seg_id                      get_address
                         005630 number                      get_value
                         005631 seg_id_len                  get_value
                         005632 segnum                      get_value
                         005633 substr_len                  get_value
                         005650 white_len                   pass_white
                         005660 bkpt_num                    status
                         005661 packed_ptr                  status
                         005670 my_ptr                      validate_ptr
disk_address             000106 devname                     lookup_disk
line_error               000100 int_code                    line_error
reg_address              000100 reg_index                   reg_address

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_ne_as             r_ge_a              alloc_char_temp     unpk_to_pk
cat_realloc_chars   call_ent_var        call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
return_mac          tra_ext_1           mdfx1               enable_op           shorten_stack       ext_entry
int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        bce_appending_simulation$get_absolute
bce_appending_simulation$get_virtual                        bce_appending_simulation$init
bce_appending_simulation$new_dbr                            bce_appending_simulation$new_segment
bce_appending_simulation$put_absolute                       bce_appending_simulation$put_virtual
bce_component_to_wordnum_     bce_continue                  bce_display_instruction_      bce_display_scu_
bce_inst_length_              bce_name_to_segnum_           bce_relocate_instruction_     bce_segnum_to_name_
bce_segptr_to_name_           com_err_                      cu_$arg_count_rel             cu_$arg_ptr_rel
cu_$generate_call             cv_integer_string_check_      date_time_                    disk_name_pvtx
get_ptrs_$given_segno         ioa_                          pc$nullify                    read_disk
write_disk

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bce_data$get_line             breakpoint_page$              crash_definitions_$           crash_lot$
crash_name_table$             crash_slt$                    definitions_$                 error_table_$bad_arg
error_table_$boundviol        flagbox$                      lot$                          name_table$
pvt$                          slt$                          sys_boot_info$bce_dbr         sys_info$collection_1_phase
tc_data$                      toehold$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 001631        90 001641       115 001643       236 001647    9   84 001773       300 002062       301 002066
    302 002070       303 002076       304 002106       305 002110       306 002114       307 002126       308 002137
    309 002157       310 002170       311 002177       313 002206       314 002240       316 002241       318 002243
    320 002263       321 002266       322 002272       323 002275       324 002300       325 002303       326 002306
    327 002310       328 002312       329 002314       330 002316       331 002322       332 002324       333 002327
    334 002331       335 002334       336 002336       337 002341       338 002343       339 002345       340 002347
    341 002351       342 002355       343 002357       344 002363       345 002365       346 002367       347 002371
    348 002373       350 002374       351 002376       352 002400       353 002402       354 002404       355 002406
    356 002410       357 002412       358 002414       359 002416       360 002422       361 002424       362 002427
    363 002431       364 002434       365 002436       366 002441       367 002443       368 002445       369 002447
    370 002451       371 002455       372 002457       373 002463       374 002465       375 002467       376 002471
    379 002473       380 002475       381 002500       382 002501       383 002507       384 002515       385 002520
    387 002522       388 002537       389 002550       390 002555       391 002556       393 002560       394 002576
    395 002600       396 002603       397 002624       398 002626       399 002652       401 002653       402 002655
    403 002670       404 002710       405 002712       406 002714       407 002740       408 002742       409 002745
    410 003005       411 003007       412 003011       413 003012       416 003014       417 003015       418 003031
    419 003033       422 003036       423 003037       424 003042       425 003044       426 003046       427 003050
    428 003052       429 003077       430 003115       431 003116       435 003117       436 003120       437 003122
    439 003133       440 003135       441 003140       442 003141       444 003151       446 003152       447 003167
    448 003171       451 003205       467 003206       468 003207       471 003223       472 003236       474 003237
    475 003242       476 003246       477 003272       479 003313       480 003326       481 003330       482 003332
    483 003356       484 003360       485 003367       486 003376       487 003415       488 003417       489 003434
    490 003436       491 003455       492 003462       493 003477       494 003523       495 003525       496 003533
    497 003535       499 003537       500 003554       501 003556       502 003606       504 003620       505 003622
    506 003626       507 003632       508 003634       510 003636       513 003672       514 003674       515 003677
    516 003704       517 003727       519 003751       520 004011       523 004013       526 004014       528 004015
    529 004033       530 004040       537 004041       538 004042       539 004044       540 004045       541 004047
    542 004051       543 004072       545 004073       546 004121       547 004123       548 004125       549 004127
    550 004130       551 004132       552 004160       554 004172       556 004174       557 004175       558 004177
    574 004200       575 004201       576 004203       577 004205       578 004206       579 004210       580 004215
    581 004217       582 004221       583 004222       584 004231       585 004240       586 004247       587 004253
    588 004255       589 004257       590 004260       591 004270       592 004271       596 004310       597 004341
    598 004353       599 004362       600 004370       603 004373       604 004374       605 004377       606 004404
    607 004412       609 004413       610 004415       611 004416       612 004417       613 004422       614 004431
    615 004436       616 004444       617 004447       618 004455       619 004477       620 004506       621 004517
    622 004521       623 004523       624 004526       625 004534       626 004556       628 004557       631 004560
    633 004561       634 004605       636 004606       639 004607       647 004610       648 004611       649 004613
    650 004616       651 004632       652 004651       653 004673       655 004701       656 004702       657 004703
    658 004720       659 004722       660 004726       661 004727       662 004733       663 004741       664 004743
    665 004744       667 004755       668 004756       670 004772       671 005000       672 005002       673 005003
    674 005004       675 005007       676 005033       677 005035       678 005036       679 005040       680 005062
    682 005104       683 005105       684 005107       685 005114       686 005130       687 005140       688 005145
    689 005150       690 005171       692 005207       694 005210       695 005227       697 005251       700 005252
    702 005253       703 005272       704 005306       705 005322       706 005336       707 005352       708 005366
    710 005367       720 005370       721 005371       722 005372       723 005373       725 005411       726 005421
    727 005422       728 005424       730 005426       731 005433       732 005455       733 005457       734 005463
    735 005472       736 005544       737 005547       738 005554       740 005622       742 005670       743 005734
    744 005766       747 006014       748 006033       749 006060       750 006065       751 006104       753 006136
    755 006163       756 006171       757 006205       760 006253       767 006254       768 006255       769 006267
    770 006320       771 006332       772 006333       773 006367       781 006371       782 006372       783 006404
    784 006435       785 006451       786 006452       787 006455       788 006473       789 006475       790 006477
    791 006571       792 006573       794 006607       795 006634       796 006642       799 006643       802 006644
    804 006645       806 006646       814 006647       815 006650       816 006652       819 006665       820 006666
    821 006701       822 006710       823 006711       825 006712       826 006716       827 006732       828 006734
    829 006740       830 006743       831 006745       832 006760       835 006762       836 006765       837 006771
    839 007010       840 007012       841 007036       842 007040       843 007054       844 007056       845 007071
    846 007076       847 007102       848 007104       849 007111       850 007132       851 007134       853 007136
    854 007162       855 007164       856 007170       859 007224       861 007246       862 007306       870 007310
    871 007311       872 007323       873 007330       874 007331       875 007352       876 007374       877 007413
    880 007414       883 007415       892 007416       893 007417       894 007432       895 007433       896 007437
    897 007445       898 007451       899 007460       900 007462       901 007470       902 007501       903 007502
    906 007527       907 007547       909 007550       910 007557       912 007601       913 007624       914 007655
    915 007723       916 007772       917 007775       918 010003       919 010004       927 010005       928 010006
    929 010010       930 010011       931 010013       932 010043       933 010045       934 010071       938 010103
    940 010104       941 010105       942 010107       943 010112       944 010123       945 010127       946 010150
    947 010151       948 010155       949 010177       952 010200       954 010201       956 010202       960 010203
    961 010204       964 010227       965 010230       968 010231       992 010233       993 010235       994 010236
    995 010241       996 010243       997 010246       998 010252       999 010255      1000 010274      1001 010311
   1002 010323      1003 010330      1004 010340      1005 010347      1006 010353      1007 010362      1008 010440
   1009 010512      1010 010567      1011 010644      1012 010646      1013 010661      1015 010664      1016 010666
   1017 010672      1018 010677      1019 010702      1020 010703      1023 010704      1032 010706      1033 010712
   1034 010713      1035 010715      1038 010732      1039 010743      1040 010745      1041 010751      1042 010752
   1043 010754      1044 010760      1045 010763      1046 010764      1047 010766      1049 011007      1050 011010
   1053 011025      1054 011027      1055 011031      1057 011035      1058 011051      1061 011052      1071 011054
   1072 011101      1073 011127      1076 011144      1077 011164      1078 011201      1079 011202      1080 011205
   1084 011206      1097 011207      1098 011210      1099 011222      1100 011227      1101 011241      1102 011244
   1104 011257      1105 011272      1106 011313      1107 011351      1108 011364      1109 011376      1110 011404
   1111 011415      1112 011417      1117 011420      1118 011421      1119 011423      1121 011425      1122 011437
   1124 011451      1125 011456      1126 011473      1127 011475      1128 011507      1129 011511      1130 011523
   1131 011537      1132 011545      1133 011554      1134 011562      1136 011563      1137 011576      1138 011604
   1139 011612      1141 011615      1143 011616      1144 011640      1145 011653      1146 011666      1147 011674
   1148 011677      1150 011705      1151 011715      1152 011767      1153 012014      1155 012021      1156 012042
   1158 012060      1159 012064      1160 012105      1161 012123      1162 012125      1163 012127      1164 012130
   1165 012131      1166 012155      1168 012172      1170 012205      1171 012225      1173 012226      1175 012230
   1179 012231      1180 012241      1181 012250      1183 012251      1184 012255      1185 012264      1187 012265
   1188 012314      1189 012316      1190 012320      1191 012322      1192 012327      1194 012330      1196 012340
   1197 012343      1198 012356      1200 012374      1202 012375      1214 012403      1215 012406      1216 012410
   1217 012411      1218 012421      1219 012454      1220 012514      1221 012551      1222 012577      1223 012602
   1225 012603      1231 012604      1232 012613      1233 012627      1234 012632      1236 012660      1238 012661
   1241 012662      1248 012670      1249 012705      1250 012715      1251 012734      1252 012736      1253 012763
   1254 012771      1255 012774      1256 012776      1257 013000      1261 013001      1265 013002      1266 013003
   1267 013005      1269 013020      1270 013024      1271 013026      1272 013030      1273 013033      1276 013034
   1288 013035      1289 013036      1291 013057      1292 013060      1293 013065      1294 013067      1295 013070
   1296 013075      1297 013100      1298 013102      1299 013114      1300 013125      1301 013133      1302 013144
   1303 013145      1305 013146      1306 013152      1308 013154      1309 013157      1310 013161      1311 013162
   1312 013170      1313 013175      1315 013176      1316 013177      1317 013211      1318 013224      1319 013225
   1320 013237      1321 013277      1322 013302      1323 013333      1326 013352      1327 013365      1328 013424
   1329 013443      1330 013445      1331 013447      1332 013456      1334 013457      1335 013506      1336 013510
   1337 013512      1338 013514      1339 013516      1341 013517      1342 013527      1344 013530      1353 013544
   1354 013545      1356 013546      1358 013562      1359 013565      1361 013637      1362 013641      1364 013644
   1366 013664      1367 013665      1369 013666      1371 013706      1372 013711      1374 013744      1375 013746
   1378 013751      1384 013753      1385 013766      1386 013770      1387 014016      1388 014037      1390 014065
   1391 014111      1394 014142      1395 014170      1396 014211      1398 014243      1399 014267      1402 014320
   1403 014346      1404 014367      1406 014421      1407 014445      1410 014476      1411 014524      1412 014545
   1414 014573      1415 014617      1417 014650      1418 014651      1419 014675      1420 014676      1423 014677
   1429 014700      1430 014714      1431 014717      1432 014721      1433 014725      1435 014730      1438 014731
   1449 014733      1450 014736      1451 014742      1453 014751      1454 014765      1455 015001      1458 015010
   1459 015012      1460 015036      1462 015045      1464 015065      1465 015073      1466 015077      1467 015111
   1468 015113      1469 015116      1470 015153      1472 015155      1473 015220      1474 015221      1475 015223
   1478 015224      1486 015226      1487 015252      1488 015254


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
