	COMPILATION LISTING OF SEGMENT tty_write
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 08/16/90  1222.6 mdt Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(88-06-20,Berno), approve(88-07-13,MCR7928),
       19*     audit(88-06-20,Parisek), install(88-07-19,MR12.2-1061):
       20*     Modified code for implementing the UNCP multiplexer (DSA gateway)
       21*     interface implementation.
       22*  2) change(88-09-28,Brunelle), approve(88-01-26,MCR7813),
       23*     audit(88-10-12,Blair), install(88-10-17,MR12.2-1171):
       24*     Upgrade to TTT_version 4 with c_chars structure changing from 3 to 15
       25*     chars.
       26*  3) change(90-06-26,Schroth), approve(90-07-09,MCR8183),
       27*     audit(90-07-31,WAAnderson), install(90-08-16,MR12.4-1024):
       28*     Changed to ensure that the caller does not block indefinitely when output
       29*     is subdivided and yields no real output (whitespace or edited out), to
       30*     properly set current line counter upon FF or VT, and to free allocated
       31*     buffer chains on crawlout.
       32*                                                   END HISTORY COMMENTS */
       33 
       34 /* format: style4,delnl,insnl,^ifthendo */
       35 tty_write:
       36      proc (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);
       37 						/* tty output conversion */
       38 
       39 
       40 /* 	Date Last Modified and Reason
       41*
       42*   Rewritten 11/3/75 by Robert S. Coren
       43*   Modified 04/22/77 by J. Stern to introduce TCBs and WTCBs
       44*   Modified July 78 by J. Nicholls to use channel_manager to write data out, to allow for implementation of multiplexing
       45*   Modified fall of 1979 by Robert Coren to allocate automatic buffers in begin block
       46*   Modified fall of 1979 by Robert Coren for output flow control
       47*   Modified December 1979 by C. Hornig to fix bug in automatic stack frame allocation
       48*   Modified December 1979 by Robert Coren to fix various bugs
       49*   Call metering added October 1980 by Robert Coren
       50*   White-space bug fixed November 1980 by Robert Coren
       51*   write_set_mark entry added February 1981 by Robert Coren
       52*   Modified March 1981 by Robert Coren to fix bugs with null end-of-page string
       53*   Modified June 1981 by Robert Coren to add write_whole_string entry and keep global call count
       54*   Modified June 1982 by Robert Coren to return MASKED state if appropriate
       55*   Modified November 1982 by Robert Coren to return wtcb.error_code
       56*   Modified October 1983 by E. N. Kittlitz for write_whole_string check longest_possible, not use a_offset
       57*   Modified December 1983 by Robert Coren to set buffer tally before copying user data in case of crawlout
       58*   Report on June 1983 - modifications for the Datanet 7100.f.d.
       59*   Report on April 1984 - modifications for the 10.2 f.d.
       60*   Date of the last modification - 17/04/84  
       61**/
       62 
       63 /* PARAMETERS */
       64 
       65 dcl  twx fixed bin;					/* device index */
       66 dcl  a_readp ptr;					/* pointer to user's data */
       67 dcl  a_offset fixed bin (21);				/* character to offset to add to readp */
       68 dcl  a_nelem fixed bin (21);				/* number of characters supplied */
       69 dcl  a_string char (*);				/* string to output (for write_set_mark entry) */
       70 dcl  a_mark_flag bit (1);				/* whether to set a mark (write_whole_string entry) */
       71 dcl  a_nelemt fixed bin (21);				/* number of characters shipped (OUTPUT) */
       72 dcl  a_state fixed bin;				/* current state of channel (OUTPUT) */
       73 dcl  ercode fixed bin (35);				/* status code (OUTPUT) */
       74 
       75 
       76 /* AUTOMATIC */
       77 
       78 dcl  state fixed bin;
       79 dcl  devx fixed bin;				/* local copy of device index */
       80 dcl  readp ptr;					/* local copy of a_readp */
       81 dcl  offset fixed bin (21);				/* local copy of a_offset */
       82 dcl  nelem fixed bin (21);				/* local copy of a_nelem */
       83 dcl  nelemt fixed bin (21);				/* local copy of a_nelemt */
       84 
       85 dcl  locked_entry bit (1);
       86 dcl  forcesw bit (1);
       87 dcl  mark_entry bit (1);
       88 dcl  whole_string bit (1);
       89 
       90 dcl  ttytp ptr;					/* pointer to tty_tables segment */
       91 dcl  tctp ptr;					/* pointer to TCT table */
       92 dcl  mvtp ptr;					/* pointer to translation table */
       93 dcl  special_ptr ptr;				/* pointer to special chars table */
       94 dcl  delay_ptr ptr;					/* pointer to delay table */
       95 dcl  max_space fixed bin;				/* maximum number of words this guy can have */
       96 dcl  max_chars fixed bin;				/* maximun number of character of output */
       97 dcl  max_chars_in_buf fixed bin;			/* number of characters in maximum-size buffer */
       98 dcl  input_ptr ptr;					/* pointer to user-supplied data */
       99 dcl  final_outp ptr;				/* pointer to where output is to be taken from */
      100 dcl  output_length fixed bin (21);			/* length of actual output in chars */
      101 
      102 dcl  source_ptr ptr;
      103 dcl  source_len fixed bin;
      104 dcl  target_ptr ptr;
      105 dcl  target_len fixed bin;
      106 
      107 dcl  cap_source_ptr ptr;
      108 dcl  cap_target_ptr ptr;
      109 dcl  cap_tab_ptr ptr;
      110 dcl  scanned_len fixed bin;
      111 
      112 dcl  time_spent fixed bin (71);
      113 dcl  start_time fixed bin (71);			/* clock time at entry */
      114 dcl  chars_moved bit (1);
      115 dcl  white_sw bit (1);
      116 dcl  line_count fixed bin;				/* number of lines on page so far */
      117 dcl  col fixed bin;					/* current column position */
      118 dcl  wcol fixed bin;				/* column position after addition of white space */
      119 dcl  oldcol fixed bin;
      120 dcl  old_tally fixed bin;
      121 dcl  seqp ptr;					/* pointer to output sequence */
      122 dcl  i fixed bin;
      123 dcl  xor bit (18);					/* used in switching buffer pointers */
      124 dcl  shift bit (2);
      125 dcl  new_char_count fixed bin;
      126 dcl  old_head fixed bin (18);				/* old value of wtcb.write_first */
      127 dcl  old_tail fixed bin (18);				/* old value of wtcb.write_last */
      128 dcl  old_end_frame bit (1);				/* old value of wtcb.end_frame */
      129 dcl  break_length fixed bin;				/* no. of characters before end-of-page */
      130 dcl  break_flag bit (1) aligned;			/* indicates presence of end_of_page */
      131 dcl  null_for_eop bit (1);				/* indicates sending NUL character to force end-of-page */
      132 dcl  n_delays fixed bin;
      133 dcl  back_chars fixed bin;				/* no. of characters required for backward carriage motion */
      134 dcl  forward_chars fixed bin;				/* no. of characters required for forward carriage motion */
      135 dcl  horiz float bin;
      136 dcl  vert fixed bin;
      137 dcl  ll fixed bin;					/* number of output characters on current line */
      138 dcl  escape_index fixed bin;				/* index of output escape sequence */
      139 
      140 dcl  headp ptr;
      141 dcl  send bit (1);
      142 dcl  new_head fixed bin;
      143 dcl  n_pages fixed bin;
      144 dcl  lastp ptr;
      145 
      146 dcl  bufp ptr;
      147 dcl  prevp ptr;
      148 dcl  buf_size fixed bin;
      149 dcl  orig_buf_size fixed bin;
      150 dcl  reached_needed bit (1);
      151 dcl  new_buffer_count fixed bin;
      152 dcl  first_buffer bit (1);
      153 dcl  old_lastp ptr;
      154 dcl  words_needed fixed bin;
      155 dcl  new_bufp ptr;
      156 dcl  new_buf fixed bin;
      157 dcl  chars_in_buf fixed bin;
      158 dcl  lchar fixed bin;
      159 dcl  old_char_count fixed bin;
      160 dcl  nchars fixed bin;
      161 dcl  cur_space fixed bin;
      162 dcl  cur_chain_len fixed bin;
      163 dcl  end_chain bit (1);
      164 dcl  uncp_flag bit (1);				/* designate UNCP mpx */
      165 
      166 dcl  1 util aligned,				/* structure passed to tty_util_ subroutines */
      167        2 stringp ptr,
      168        2 stringl fixed bin,
      169        2 ctally fixed bin,
      170        2 tablep ptr,				/* pointer to translation table */
      171        2 indicator fixed bin,				/* returned by tty_util_$find_char */
      172        2 pad (3) fixed bin;				/* workspace used by tty_util_ */
      173 
      174 dcl  1 illegal_char_args aligned,
      175        2 ic_stringp ptr,
      176        2 ic_stringl fixed bin,
      177        2 ic_tally fixed bin,
      178        2 pad fixed bin,
      179        2 found_flag bit (1) aligned,
      180        2 pad2 (4) fixed bin;
      181 
      182 dcl  auto_buf_len fixed bin;				/* internal buffer length */
      183 dcl  allocated_buffers bit(1);			/* on if buffers have been obtained */
      184 
      185 /* INTERNAL STATIC */
      186 
      187 dcl  NOT_INTERESTING fixed bin int static options (constant) init (0);
      188 dcl  NEW_LINE fixed bin int static options (constant) init (1);
      189 dcl  CARRIAGE_RETURN fixed bin int static options (constant) init (2);
      190 dcl  TAB_MULTIPLE_SPACE fixed bin int static options (constant) init (3);
      191 dcl  BACK_SPACE fixed bin int static options (constant) init (4);
      192 dcl  VERTICAL_TAB fixed bin int static options (constant) init (5);
      193 dcl  FORM_FEED fixed bin int static options (constant) init (6);
      194 dcl  OCTAL_ESCAPE fixed bin int static options (constant) init (7);
      195 dcl  RED_SHIFT fixed bin int static options (constant) init (8);
      196 dcl  BLACK_SHIFT fixed bin int static options (constant) init (9);
      197 dcl  INSERT_NO_COUNT fixed bin int static options (constant) init (10);
      198 dcl  INSERT_NO_COUNT_2 fixed bin int static options (constant) init (11);
      199 dcl  SKIP fixed bin int static options (constant) init (12);
      200 dcl  SPECIAL_ESCAPE fixed bin int static options (constant) init (16);
      201 
      202 dcl  HUNG_UP fixed bin int static options (constant) init (1);
      203 dcl  LISTENING fixed bin int static options (constant) init (2);
      204 dcl  DIALED_UP fixed bin int static options (constant) init (5);
      205 dcl  MASKED_STATE fixed bin int static options (constant) init (-1);
      206 
      207 dcl  max_chain_len fixed bin int static init (16) options (constant);
      208 dcl  reduction_factor float bin int static init (0.8) options (constant);
      209 						/* for allowing for growth of user's string */
      210 dcl  ascii_escape_octal bit (9) int static options (constant) init ("033"b3);
      211 dcl  ascii_escape_char char (1) based (addr (ascii_escape_octal));
      212 dcl  escape_char char (1) int static init ("\") options (constant);
      213 dcl  backspace char (1) int static init ("") options (constant);
      214 						/* backspace */
      215 dcl  space char (1) int static init (" ") options (constant);
      216 dcl  tab char (1) int static init ("	") options (constant);
      217 						/* horizontal tab */
      218 dcl  carriage_return char (1) int static init ("") /* carriage return */ options (constant);
      219 dcl  nl char (1) int static options (constant) init ("
      220 ");						/* line feed */
      221 
      222 dcl  num_array (0:7) char (1) int static options (constant) init ("0", "1", "2", "3", "4", "5", "6", "7");
      223 						/* for octal escapes */
      224 dcl  eop_sentinel_octal fixed bin (9) unsigned int static init (011111111b) options (constant);
      225 						/* i.e., 377(8) */
      226 dcl  eop_sentinel char (1);
      227 dcl  cont_char char (1) int static init ("c") options (constant);
      228 dcl  shifter (16) bit (1) int static options (constant) init ("0"b, (2) (1)"1"b, (13) (1)"0"b);
      229 dcl  delay_char fixed bin int static options (constant) init (0);
      230 dcl  upper_shift fixed bin int static options (constant) init (28);
      231 						/* i.e., 34(8) */
      232 dcl  lower_shift fixed bin int static options (constant) init (31);
      233 						/* i.e., 37(8) */
      234 
      235 dcl  lower_to_caps_edited (128) bit (9) int static options (constant)
      236 	init ("000"b3, "001"b3, "002"b3, "003"b3, "004"b3, "005"b3, "006"b3, "007"b3, "010"b3, "011"b3, "012"b3,
      237 	"013"b3, "014"b3, "015"b3, "016"b3, "017"b3, "020"b3, "021"b3, "022"b3, "023"b3, "024"b3, "025"b3, "026"b3,
      238 	"027"b3, "030"b3, "031"b3, "032"b3, "033"b3, "034"b3, "035"b3, "036"b3, "037"b3, "040"b3, "041"b3, "042"b3,
      239 	"043"b3, "044"b3, "045"b3, "046"b3, "047"b3, "050"b3, "051"b3, "052"b3, "053"b3, "054"b3, "055"b3, "056"b3,
      240 	"057"b3, "060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3, "070"b3, "071"b3, "072"b3,
      241 	"073"b3, "074"b3, "075"b3, "076"b3, "077"b3, "100"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3,
      242 	"107"b3, "110"b3, "111"b3, "112"b3, "113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3,
      243 	"123"b3, "124"b3, "125"b3, "126"b3, "127"b3, "130"b3, "131"b3, "132"b3, "133"b3, "134"b3, "135"b3, "136"b3,
      244 	"137"b3, "140"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3, "107"b3, "110"b3, "111"b3, "112"b3,
      245 	"113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3, "123"b3, "124"b3, "125"b3, "126"b3,
      246 	"127"b3, "130"b3, "131"b3, "132"b3, "173"b3, "174"b3, "175"b3, "176"b3, "177"b3);
      247 
      248 dcl  lower_to_caps_nonedited (128) bit (9) int static options (constant)
      249 	init ("000"b3, "001"b3, "002"b3, "003"b3, "004"b3, "005"b3, "006"b3, "007"b3, "010"b3, "011"b3, "012"b3,
      250 	"013"b3, "014"b3, "015"b3, "016"b3, "017"b3, "020"b3, "021"b3, "022"b3, "023"b3, "024"b3, "025"b3, "026"b3,
      251 	"027"b3, "030"b3, "031"b3, "032"b3, "033"b3, "034"b3, "035"b3, "036"b3, "037"b3, "040"b3, "041"b3, "042"b3,
      252 	"043"b3, "044"b3, "045"b3, "046"b3, "047"b3, "050"b3, "051"b3, "052"b3, "053"b3, "054"b3, "055"b3, "056"b3,
      253 	"057"b3, "060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3, "070"b3, "071"b3, "072"b3,
      254 	"073"b3, "074"b3, "075"b3, "076"b3, "077"b3, "100"b3, "501"b3, "502"b3, "503"b3, "504"b3, "505"b3, "506"b3,
      255 	"507"b3, "510"b3, "511"b3, "512"b3, "513"b3, "514"b3, "515"b3, "516"b3, "517"b3, "520"b3, "521"b3, "522"b3,
      256 	"523"b3, "524"b3, "525"b3, "526"b3, "527"b3, "530"b3, "531"b3, "532"b3, "133"b3, "134"b3, "135"b3, "136"b3,
      257 	"137"b3, "140"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3, "107"b3, "110"b3, "111"b3, "112"b3,
      258 	"113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3, "123"b3, "124"b3, "125"b3, "126"b3,
      259 	"127"b3, "130"b3, "131"b3, "132"b3, "173"b3, "174"b3, "175"b3, "176"b3, "177"b3);
      260 
      261 /* The following declaration is hopefully temporary until prefix characters are encoded in conversion tables */
      262 
      263 dcl  prefix char (1) int static init (">") options (constant);
      264 						/* = 076 = 2741 prefix character */
      265 
      266 declare LONGEST_POSSIBLE_STRING fixed bin init (8128) int static options (constant);
      267 
      268 /* ENTRIES */
      269 
      270 dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      271 dcl  tty_lock$lock_channel entry (fixed bin, fixed bin (35)),
      272      tty_lock$unlock_channel entry (fixed bin);
      273 
      274 dcl  tty_index$initialize_tcb entry (ptr, ptr);
      275 dcl  tty_util_$mvt entry (ptr);
      276 dcl  tty_util_$scm entry (ptr);
      277 dcl  tty_util_$find_char entry (ptr);
      278 dcl  tty_util_$illegal_char entry (ptr);
      279 
      280 
      281 /* BASED */
      282 
      283 dcl  1 mvt_args aligned based (addr (util)),		/* overlay of tty_util_ structure used for mvt entry */
      284        2 stringptr ptr,
      285        2 stringlen fixed bin,
      286        2 pad fixed bin,
      287        2 tablep ptr,
      288        2 targetp ptr;
      289 
      290 dcl  1 scm_args aligned based (addr (util)),		/* overlay of util structure used for scm entry */
      291        2 stringptr ptr,
      292        2 stringlen fixed bin,
      293        2 scm_tally fixed bin,
      294        2 search_mask bit (2) aligned,
      295        2 found_flag bit (1) aligned;
      296 
      297 dcl  based_onechar char (1) based;
      298 dcl  based_chars (0:1) char (1) based unal;		/* used for bumping string pointers */
      299 
      300 dcl  output_chars char (output_length) based;
      301 dcl  tally_chars char (ctally) based;
      302 dcl  chars_to_copy char (nchars) based;
      303 
      304 dcl  1 seq based aligned like c_chars;				/* template of special chars sequence */
      305 
      306 /* EXTERNAL STATIC */
      307 
      308 dcl  tty_tables$ ext static;
      309 dcl  error_table_$improper_data_format fixed bin (35) ext static;
      310 dcl  error_table_$invalid_device fixed bin (35) ext static;
      311 dcl  error_table_$io_no_permission fixed bin (35) ext static;
      312 dcl  error_table_$line_status_pending fixed bin (35) ext static;
      313 dcl  error_table_$noalloc fixed bin (35) ext static;
      314 dcl  error_table_$bad_arg fixed bin (35) ext static;
      315 dcl  error_table_$bigarg fixed bin (35) ext static;
      316 dcl  pds$processid bit (36) ext static;
      317 
      318 
      319 dcl  (addr, bin, bool, byte, clock, divide, fixed, float, hbound, index, length, max,
      320      min, mod, null, ptr, rank, rel, reverse, string, substr, unspec) builtin;
      321 
      322 dcl  cleanup condition;
      323 
  1     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
  1     2 
  1     3 /* tty_ conversion tables */
  1     4 /* Created 11/3/75 by Robert S. Coren */
  1     5 /* Info structures added 5/19/77 by Robert S. Coren */
  1     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
  1     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
  1     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
  1     9 
  1    10 
  1    11 /****^  HISTORY COMMENTS:
  1    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
  1    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
  1    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
  1    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
  1    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
  1    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
  1    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
  1    19*     SPECIAL_INFO_STRUCT_VERSION_1.
  1    20*                                                   END HISTORY COMMENTS */
  1    21 
  1    22 
  1    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  1    24 
  1    25 
  1    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
  1    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
  1    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  1    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
  1    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  1    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  1    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  1    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
  1    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
  1    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
  1    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
  1    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  1    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
  1    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  1    40 						/* use in ^edited mode */
  1    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  1    42 						/* use in edited mode */
  1    43 	  2 input_escapes	     aligned,
  1    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
  1    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
  1    46 						/* escape sequence characters */
  1    47 	  2 input_results	     aligned,
  1    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
  1    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
  1    50 						/* results of escape sequences */
  1    51 
  1    52 
  1    53      dcl	c_chars_ptr	     ptr;
  1    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
  1    55 	  2 count		     fixed bin (8) unaligned,
  1    56 	  2 chars		     (15) char (1) unaligned;
  1    57 
  1    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
  1    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
  1    60 
  1    61 
  1    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
  1    63 	  2 value		     (0:255) fixed bin (8) unal;
  1    64 
  1    65 
  1    66      dcl	1 delay		     based aligned,		/* delay counts for output */
  1    67 	  2 vert_nl	     fixed bin,
  1    68 	  2 horz_nl	     float bin,
  1    69 	  2 const_tab	     fixed bin,
  1    70 	  2 var_tab	     float bin,
  1    71 	  2 backspace	     fixed bin,
  1    72 	  2 vt_ff		     fixed bin;
  1    73 
  1    74 /* info structures used with orders */
  1    75 
  1    76      dcl	1 special_chars_struc    aligned based,
  1    77 	  2 version	     fixed bin,
  1    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
  1    79 	  2 special_chars,				/* same as level-1 above */
  1    80 						/* has to be spelled out instead of using like */
  1    81 						/* because of refer options */
  1    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
  1    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  1    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
  1    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  1    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  1    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  1    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
  1    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
  1    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
  1    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
  1    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  1    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
  1    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  1    95 						/* use in ^edited mode */
  1    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  1    97 						/* use in edited mode */
  1    98 	    3 input_escapes	     aligned,
  1    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
  1   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
  1   101 						/* escape sequence characters */
  1   102 	    3 input_results	     aligned,
  1   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
  1   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
  1   105 						/* results of escape sequences */
  1   106 
  1   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
  1   108 	  2 version	     fixed bin,
  1   109 	  2 default	     fixed bin,		/* as above */
  1   110 	  2 cv_trans	     like cv_trans;
  1   111 
  1   112      dcl	1 delay_struc	     aligned based,
  1   113 	  2 version	     fixed bin,
  1   114 	  2 default	     fixed bin,		/* as above */
  1   115 	  2 delay		     like delay;
  1   116 
  1   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
  1   118 	  2 version	     char (8),
  1   119 	  2 area_ptr	     pointer,
  1   120 	  2 table_ptr	     pointer;
  1   121 
  1   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
  1   123 			     char (8) int static options (constant) init ("sisv1000");
  1   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
  1   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
  1   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
  1   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
  1   128 
  1   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
  1   130 						/* indexed by version number */
  1   131 
  1   132 
  1   133 /* values for input and output conversion tables */
  1   134 
  1   135      dcl	(
  1   136 	INPUT_CONVERT_ORDINARY   init (0),
  1   137 	INPUT_CONVERT_BREAK	     init (1),
  1   138 	INPUT_CONVERT_ESCAPE     init (2),
  1   139 	INPUT_CONVERT_DISCARD    init (3),
  1   140 	INPUT_CONVERT_FORMFEED   init (4),
  1   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
  1   142 			     init (5),
  1   143 	INPUT_CONVERT_DSA_CR_PROCESSING
  1   144 			     init (6)
  1   145 	)		     fixed bin (8) unaligned internal static options (constant);
  1   146 
  1   147      dcl	(
  1   148 	OUTPUT_CONVERT_ORDINARY  init (0),
  1   149 	OUTPUT_CONVERT_NEWLINE   init (1),
  1   150 	OUTPUT_CONVERT_CR	     init (2),
  1   151 	OUTPUT_CONVERT_HT	     init (3),
  1   152 	OUTPUT_CONVERT_BS	     init (4),
  1   153 	OUTPUT_CONVERT_VT	     init (5),
  1   154 	OUTPUT_CONVERT_FF	     init (6),
  1   155 	OUTPUT_CONVERT_OCTAL     init (7),
  1   156 	OUTPUT_CONVERT_RRS	     init (8),
  1   157 	OUTPUT_CONVERT_BRS	     init (9),
  1   158 	OUTPUT_CONVERT_NO_MOTION init (10),
  1   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
  1   160 			     init (11),
  1   161 	OUTPUT_CONVERT_DONT_SEND init (12),
  1   162 	OUTPUT_CONVERT_NOT_USED_13
  1   163 			     init (13),
  1   164 	OUTPUT_CONVERT_NOT_USED_14
  1   165 			     init (14),
  1   166 	OUTPUT_CONVERT_NOT_USED_15
  1   167 			     init (15),
  1   168 	OUTPUT_CONVERT_NOT_USED_16
  1   169 			     init (16),
  1   170 	OUTPUT_CONVERT_FIRST_SPECIAL
  1   171 			     init (17)
  1   172 	)		     fixed bin (8) unaligned internal static options (constant);
  1   173 
  1   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
      324 
      325 
  2     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      326 
      327 
  4     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  4     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  4     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  4     9*     implementation.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  4    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  4    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  4    17**/
  4    18 
  4    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  4    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  4    21 
  4    22 
  4    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  4    24     2 next bit (18),				/* foward pointer to next free block */
  4    25     2 size fixed bin;				/* number of words in this block */
  4    26 
  4    27 
  4    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  4    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  4    30     2 flags unaligned,
  4    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  4    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  4    33       3 break bit (1) unaligned,			/* buffer contains break character */
  4    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  4    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  4    36       3 pad bit (1) unaligned,
  4    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  4    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  4    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  4    40 
  4    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  4    42 
  4    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  4    44 
  4    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      328 
  5     1 /*  BEGIN INCLUDE FILE ... wtcb.incl.pl1 */
  5     2 						                                                                                                              
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  5     6*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  5     7*     Add data needed for the uncp multiplexer (DSA gateway) interface
  5     8*     implementation.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /*
  5    13*   Moved from tty_buf.incl.pl1 Aug 78 by J. Nicholls plus changes for ring 0 demultiplexing
  5    14*   Error code added Nov. 1982 by Robert Coren
  5    15*   Modified December 1984 by Robert Coren to invent "more_flags" structure and
  5    16*    its first flag, line_status_disabled
  5    17*   Reported modifications for the DN7100 interim in August 85.
  5    18**/
  5    19 
  5    20 dcl  wtcbp ptr;					/* pointer to head of wtcb */
  5    21 
  5    22 dcl 1 wtcb based (wtcbp) aligned,			/* wired terminal control block */
  5    23     2 hevent fixed bin (71) aligned,			/* event channel for hangup/dialup signal */
  5    24     2 event fixed bin (71) aligned,			/* users event channel, for uproc */
  5    25 
  5    26     2 line_status bit (72) aligned,			/* actual line status sent by fnp */
  5    27 
  5    28     2 tcb_ptr ptr unal,				/* pointer to tcb */
  5    29     2 pad1 fixed bin (35),				/* formerly time dialedup */
  5    30 
  5    31     2 hproc bit (36) aligned,				/* boss processid */
  5    32     2 uproc bit (36) aligned,				/* tty user processid */
  5    33 
  5    34     2 baud_rate fixed bin (18) unal uns,		/* baud rate of this line */
  5    35     2 line_type fixed bin (18) unal uns,		/* line type for line protocol */
  5    36 
  5    37     2 flags unaligned,
  5    38       3 listen bit (1) unaligned,			/* if on, listen for dialups */
  5    39       3 dialed bit (1) unaligned,			/* if on, line is dialed up */
  5    40       3 send_output bit (1) unaligned,			/* on if DN355 requested more output */
  5    41 
  5    42       3 qenable bit (1) unaligned,			/* if on, signal quits */
  5    43       3 qflag bit (1) unaligned,			/* on after quit, causes writes to be ignored */
  5    44       3 end_frame bit (1) unaligned,			/* write chain fills ards frame */
  5    45 
  5    46       3 notify_reqd bit (1) unaligned,			/* if on, do notify after unlocking lock */
  5    47       3 work_reqd bit (1) unaligned,			/* if on, call dn355 before returning */
  5    48       3 dialing bit (1) unaligned,			/* if on, 355 is dialing a phone number */
  5    49 
  5    50       3 dial_status_valid bit (1) unaligned,		/* if on, dial_status_code is valid */
  5    51       3 input_available bit (1) unaligned,		/* input for this device is waiting in wired space */
  5    52       3 tcb_initialized bit (1) unaligned,		/* if on, tcb has been initialized */
  5    53 
  5    54       3 wflag bit (1) unaligned,			/* process blocked on output */
  5    55       3 rflag bit (1) unaligned,			/* process blocked on input */
  5    56       3 wru bit (1) unaligned,			/* reading answerback */
  5    57 
  5    58       3 hndlquit bit (1) unaligned,			/* on if in hndlquit mode */
  5    59       3 count_lines bit (1) unaligned,			/* on if tcb.linemax > 0 */
  5    60       3 line_status_present bit (1) unaligned,		/* fnp has sent line status */
  5    61 
  5    62       3 sync_line bit (1) unaligned,			/* channel is synchronous line type */
  5    63       3 breakall bit (1) unaligned,			/* channel is in breakall mode */
  5    64       3 scroll bit (1) unaligned,			/* channel is in scroll mode */
  5    65 
  5    66       3 negotiating_echo bit (1) unaligned,		/* ring zero to echo chars. */
  5    67       3 wake_tbl bit (1) unaligned,			/* on if in wake_tbl mode */
  5    68       3 allow_wakeup bit (1) unaligned,			/* on to allow input wakeup in wake_tbl mode */
  5    69 
  5    70       3 receive_mode_device bit (1) unaligned,		/* device must be told to enter receive mode */
  5    71       3 mark_set bit (1) unal,			/* write_with_mark call outstanding */
  5    72       3 masked bit (1) unal,				/* channel masked by FNP */
  5    73 
  5    74     2 dial_status_code fixed bin (8) unaligned,		/* code returned by 355 after dialing a phone number */
  5    75 
  5    76     2 fblock fixed bin (17) unaligned,			/* oldest read pointer, block */
  5    77     2 lblock fixed bin (17) unaligned,			/* newest read block */
  5    78 
  5    79     2 fchar fixed bin (9) unsigned unaligned,		/* first block char index */
  5    80     2 actline fixed bin (9) unsigned unaligned,		/* line number of current line */
  5    81     2 actcol fixed bin (9) unsigned unaligned,		/* tty column position */
  5    82     2 nramsgs fixed bin (9) unsigned unaligned,		/* current number of read-ahead msgs */
  5    83 
  5    84     2 write_first fixed bin (17) unaligned,		/* first write block */
  5    85     2 write_last fixed bin (17) unaligned,		/* last write block */
  5    86     2 write_cnt fixed bin (17) unaligned,		/* count of chars in write chain */
  5    87     2 white_col fixed bin (17) unaligned,		/* column position resulting from trailing white space */
  5    88 
  5    89     2 max_buf_size fixed bin (9) unal uns,		/* maximum-size buffer to be allocated for this channel */
  5    90     2 buffer_pad fixed bin (9) unal uns,		/* amount of pad to be left in output buffers */
  5    91     2 devx fixed bin (17) unaligned,			/* index into lct of channel's entry */
  5    92     2 echdp bit (18) unaligned,			/* echo negotiation data ptr */
  5    93     2 waketp bit (18) unaligned,			/* wakeup table offset */
  5    94     2 prompt_len fixed bin (8) unaligned,		/* number of chars in prompt string */
  5    95     2 prompt char (3) unaligned,			/* text of prompt message */
  5    96     2 line_delimiter char (1) unal,			/* line delimiter for tty_read parse */
  5    97     2 more_flags unaligned,				/* in addition to flags (above) */
  5    98       3 line_status_disabled bit (1) unaligned,		/* "1"b => don't relay line_status interrupts */
  5    99     2 send_turn bit (1) unal,				/* For the Dn7100 interim */
  5   100     2 pad bit (25) unal,
  5   101     2 error_code fixed bin (35),			/* error code returned by channel_manager to tty_interrupt */
  5   102     2 pad2 bit (36);
  5   103 
  5   104 /* Ends on doubleword boundary */
  5   105 
  5   106 /* END INCLUDE FILE ... wtcb.incl.pl1 */
      329 
      330 
  6     1 /* BEGIN INCLUDE FILE ... tcb.incl.pl1 */
  6     2 
  6     3 /* Date Last Modified and Reason
  6     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  6     5*   Modified 2/6/78 by Robert Coren to add input_msg_size
  6     6*   Modified 4/18/78 by Robert Coren to add framing_chars
  6     7*   Modified 8/31/78 by J. Nicholls to add scroll mode
  6     8*   Extracted 9/12/78 by J. Stern from tty_data.incl.pl1
  6     9*   Modified Oct.1979 by Robert Coren to expand to 36 possible modes
  6    10*   Modified 1/21/80 by Robert Coren to add no_outp, oddp, & eight_bit modes
  6    11*   Modified 10/08/80 by Robert Coren to add meters for tty_read & tty_write
  6    12*   Modified: 10 November 1980 by G. Palter to add can_type and explicit padding
  6    13*   Modified 12/04/80 by Robert Coren to add saved copy of meters
  6    14*   Modified 2/24/81 by Robert Coren to add time spent in tty_read and _write
  6    15*   Modified April 1981 by Robert Coren to add time last dialed up
  6    16**/
  6    17 
  6    18 dcl  tcbp ptr;
  6    19 
  6    20 dcl 1 tcb based (tcbp) aligned,			/* declaration of per terminal control block */
  6    21 
  6    22     2 terminal_type char (32) unaligned,		/* terminal type name */
  6    23     2 tables,
  6    24       3 input_mvtrp bit (18) unaligned,			/* rel pointer to current input mvt table */
  6    25       3 output_mvtrp bit (18) unaligned,		/* rel pointer to current output mvt table */
  6    26       3 input_tctrp bit (18) unaligned,			/* rel pointer to current input tct table */
  6    27       3 output_tctrp bit (18) unaligned,		/* rel pointer to current output tct table */
  6    28       3 specialrp bit (18) unaligned,			/* rel pointer to current special chars table */
  6    29       3 delayrp bit (18) unaligned,			/* rel pointer to current delay table */
  6    30     2 default_tables,
  6    31       3 df_input_mvtrp bit (18) unaligned,		/* rel pointer to default input mvt table */
  6    32       3 df_output_mvtrp bit (18) unaligned,		/* rel pointer to default output mvt table */
  6    33       3 df_input_tctrp bit (18) unaligned,		/* rel pointer to default input tct table */
  6    34       3 df_output_tctrp bit (18) unaligned,		/* rel pointer to default output tct table */
  6    35       3 df_specialrp bit (18) unaligned,		/* rel pointer to default special chars table */
  6    36       3 df_delayrp bit (18) unaligned,			/* rel pointer to default delay table */
  6    37     2 special_input_chars unaligned,
  6    38       3 erase char (1) unaligned,			/* erase character */
  6    39       3 kill char (1) unaligned,			/* kill character */
  6    40     2 old_type fixed bin (17) unaligned,		/* old terminal type number */
  6    41 
  6    42     2 modes unaligned,				/* modes set by order call */
  6    43       3 edited bit (1) unaligned,			/* edited output mode */
  6    44       3 tabm bit (1) unaligned,			/* insert output tabs mode */
  6    45       3 canm bit (1) unaligned,			/* do canonical form conversion */
  6    46 
  6    47       3 escm bit (1) unaligned,			/* do input escape conversions */
  6    48       3 erklm bit (1) unaligned,			/* do erase kill processing */
  6    49       3 rawim bit (1) unaligned,			/* don't convert input */
  6    50 
  6    51       3 rawom bit (1) unaligned,			/* don't convert output */
  6    52       3 redm bit (1) unaligned,			/* has red-shift function */
  6    53       3 vertsp bit (1) unaligned,			/* send real ff's and vt's if on, else escape them */
  6    54 
  6    55       3 echo_cr bit (1) unaligned,			/* echo carriage returns */
  6    56       3 echo_lf bit (1) unaligned,			/* echo line feeds */
  6    57       3 echo_tab bit (1) unaligned,			/* echo tabs */
  6    58 
  6    59       3 hndlquit bit (1) unaligned,			/* cr's on quit */
  6    60       3 full_duplex bit (1) unaligned,			/* xmit and receive simultaneously */
  6    61       3 echoplex bit (1) unaligned,			/* echo input characters on terminal */
  6    62 
  6    63       3 upper_case bit (1) unaligned,			/* map lower-case output into upper-case */
  6    64       3 replay bit (1) unaligned,			/* replay interrupted input */
  6    65       3 polite bit (1) unaligned,			/* output must start at left margin */
  6    66 
  6    67       3 control bit (1) unaligned,			/* accept control characters */
  6    68       3 blk_xfer bit (1) unaligned,			/* block transfer or "frame" mode */
  6    69       3 breakall bit (1) unaligned,			/* break on all characters */
  6    70 
  6    71       3 scroll bit (1) unaligned,			/* scroll mode for crt terminals */
  6    72       3 prefixnl bit (1) unaligned,			/* prefix output iwth nl when input interrupted */
  6    73       3 wake_tbl bit (1) unaligned,			/* input wakeups determined by wakeup table */
  6    74 
  6    75       3 iflow bit (1) unaligned,			/* input flow control */
  6    76       3 oflow bit (1) unaligned,			/* output flow control */
  6    77       3 no_outp bit (1) unaligned,			/* don't generate output parity */
  6    78 
  6    79       3 eight_bit bit (1) unaligned,			/* don't strip input parity */
  6    80       3 odd_parity bit (1) unaligned,			/* generate odd parity (if any) */
  6    81 
  6    82       3 modes_pad bit (7) unaligned,
  6    83 
  6    84     2 id char (4) unaligned,				/* terminal id */
  6    85 
  6    86     2 colmax fixed bin (8) unaligned,			/* current maximum number of columns */
  6    87     2 linemax fixed bin (8) unaligned,			/* current maximum number of lines/frame */
  6    88     2 wrt_lchar fixed bin (17) unaligned,		/* char within last write block */
  6    89 
  6    90     2 input_msg_size fixed bin,			/* maximum input message size in chars */
  6    91     2 framing_chars unaligned,
  6    92       3 frame_begin char (1) unaligned,			/* frame-begin character */
  6    93       3 frame_end char (1) unaligned,			/* frame-end character */
  6    94     2 max_output_block fixed bin (18) unsigned unaligned,	/* maximum size of output block in block_acknowledge */
  6    95 
  6    96     2 input_suspend_seq unaligned,			/* sequence for input suspension */
  6    97       3 count fixed bin (9) unsigned,
  6    98       3 chars char (3),
  6    99     2 input_resume_seq unaligned,			/* likewise for input resumption */
  6   100       3 count fixed bin (9) unsigned,
  6   101       3 chars char (3),
  6   102 
  6   103     2 output_suspend_etb_seq unaligned,			/* sequence for output suspension or end_of_block */
  6   104       3 count fixed bin (9) unsigned,
  6   105       3 chars char (3),
  6   106     2 output_resume_ack_seq unaligned,			/* likewise for resumption or ack */
  6   107       3 count fixed bin (9) unsigned,
  6   108       3 chars char (3),
  6   109 
  6   110     2 flags unaligned,				/* tty dim flag bits */
  6   111       3 breakall_enabled bit (1) unaligned,		/* channel is permitted to use breakall mode */
  6   112       3 dont_count_next bit (1) unaligned,		/* next output character is escaped */
  6   113       3 keyboard_locking bit (1) unaligned,		/* ON if doing keybd locking for ASCIi line type */
  6   114       3 no_printer_off bit (1) unaligned,		/* reject printer_off/printer_on orders */
  6   115       3 break_char_pending bit (1) unaligned,		/* break character is in preconverted buffer */
  6   116       3 uproc_attached bit (1) unaligned,		/* user process has attached device */
  6   117       3 block_acknowledge bit (1) unaligned,		/* block acknowledgement output protocol */
  6   118       3 flags_pad bit (27) unaligned,
  6   119 
  6   120     2 actshift bit (2) unaligned,			/* tty shift, 00 none, 01 lower, 10 upper, 11 unknown */
  6   121 
  6   122     2 cumulative_meters,				/* continuously running meters */
  6   123       3 read_calls fixed bin (35),			/* number of calls to tty_read */
  6   124       3 write_calls fixed bin (35),			/* number of calls to tty_write */
  6   125       3 read_chars fixed bin (35),			/* after conversion */
  6   126       3 write_chars fixed bin (35),			/* before conversion */
  6   127       3 read_time fixed bin (71),			/* total time spent in tty_read */
  6   128       3 write_time fixed bin (71),			/* total time spent in tty_write */
  6   129     2 saved_meters like tcb.cumulative_meters,		/* meters saved at last dialup */
  6   130 
  6   131     2 can_type fixed binary (9) unaligned unsigned,	/* type of canonicalization to use on this channel */
  6   132     2 pad1 bit (27) unaligned,			/* to word boundary */
  6   133     2 time_dialed fixed bin (71);			/* clock time of last copy_meters order */
  6   134 
  6   135 /* END INCLUDE FILE ... tcb.incl.pl1 */
      331 
      332 
  7     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  7     2 
  7     3 /* Created by J. Stern 7/26/78 */
  7     4 /* Metering information added by C. Hornig, March 1980. */
  7     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  7     6 
  7     7 dcl  lctp ptr;					/* ptr to logical channel table */
  7     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  7     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  7    10 
  7    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  7    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  7    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  7    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  7    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  7    16     2 pad (11) fixed bin,
  7    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  7    18 
  7    19 
  7    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  7    21     2 lock bit (36),				/* channel lock */
  7    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  7    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  7    24     2 flags unal,
  7    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  7    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  7    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  7    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  7    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  7    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  7    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  7    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  7    33       3 trace bit (1) unal,				/* ON to trace this channel */
  7    34       3 unused bit (1) unal,
  7    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  7    36     2 major_channel_info,
  7    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  7    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  7    39     2 queue_entries,
  7    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  7    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  7    42     2 word_counts,
  7    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  7    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  7    45 
  7    46     2 meters,
  7    47       3 in_bytes fixed bin (35),
  7    48       3 out_bytes fixed bin (35),
  7    49       3 in,
  7    50         4 calls fixed bin (35),
  7    51         4 interrupts fixed bin (35),
  7    52         4 call_time fixed bin (71),
  7    53         4 interrupt_time fixed bin (71),
  7    54       3 out like lcte.meters.in,
  7    55       3 control like lcte.meters.in,
  7    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  7    57 
  7    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  7    59 
  7    60     2 pad (3) fixed bin (35);
  7    61 
  7    62 
  7    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  7    64 
  7    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  7    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  7    67 
  7    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  7    69 
  7    70 
  7    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      333 
      334 
  8     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  8     2 
  8     3 /* This include file declares all the entries in tty_space_man and defines the constants
  8     4**  to be used for the flags argument
  8     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  8     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  8     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  8     8**/
  8     9 
  8    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  8    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  8    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  8    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  8    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  8    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  8    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  8    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  8    18 dcl  tty_space_man$needs_space entry (fixed bin);
  8    19 
  8    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  8    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  8    22 
  8    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      335 
      336 
  9     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  9     2 
  9     3 /* Created 8/25/78 by J. Stern */
  9     4 
  9     5 
  9     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  9     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  9     8 
  9     9 /* call channel_manager$write (devx, output_ptr, code) */
  9    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  9    11 
  9    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  9    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  9    14 
  9    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  9    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  9    17 
  9    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  9    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  9    20 
  9    21 /* call channel_manager$get_modes (devx, modes, code) */
  9    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  9    23 
  9    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  9    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  9    26 
  9    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  9    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  9    29 
  9    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  9    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  9    32 
  9    33 
  9    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      337 
 10     1 /* Begin include file ..... multiplexer_types.incl.pl1 */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(89-03-20,Parisek), approve(89-06-01,MCR8110),
 10     7*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
 10     8*     Add support of protocol mpx.
 10     9*                                                   END HISTORY COMMENTS */
 10    10 
 10    11 
 10    12 /* This include file defines known multiplexer types */
 10    13 /* Prepared August 1978 by Larry Johnson */
 10    14 /* Changed April 1979 to rename the fnp multiplexer mcs */
 10    15 
 10    16 dcl (TTY_MPX init (0),				/* nonmultiplexed channel */
 10    17      MCS_MPX init (1),				/* FNP running MCS */
 10    18      USER1_MPX init (2),				/* a range of values for user defined multiplexers */
 10    19      USER2_MPX init (3),
 10    20      USER3_MPX init (4),
 10    21      USER4_MPX init (5),
 10    22      USER5_MPX init (6),
 10    23      IBM3270_MPX init (7),				/* IBM 3270 display terminal controller */
 10    24      VIP7760_MPX init (8),				/* Honeywell VIP 7760 terminal controller */
 10    25      STY_MPX init (9),				/* Software Terminal Facility */
 10    26      LAP_MPX init (10),				/* Link Access Protocol (X.25 level 2) */
 10    27      X25_MPX init (11),				/* CCITT X.25 level 3 */
 10    28      HASP_MPX init (12),				/* HASP RJE protocol */
 10    29      UNCP_MPX init (13),				/* DSA protocol */
 10    30      SYSTEM2_MPX init (14),
 10    31      SYSTEM1_MPX init (15),
 10    32      PROTOCOL_MPX init (16))				/* TCP/IP network X.25 protocol */
 10    33      int static options (constant);
 10    34 
 10    35 dcl  mpx_types (0:16) char (32) int static options (constant) init (
 10    36      "tty", "mcs", "user1", "user2", "user3", "user4", "user5", "ibm3270",
 10    37      "vip7760", "sty", "lap", "x25", "hasp", "uncp", "system2", "system1",
 10    38      "protocol");
 10    39 
 10    40 dcl  mpx_special_lock (0:16) bit (1) int static options (constant) init (
 10    41      "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
 10    42      "0"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b);
 10    43 
 10    44 /* End include file ..... multiplexer_types.incl.pl1 */
      338 
 11     1 /*	BEGIN INCLUDE FILE ... net_event_message.incl.pl1 */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(86-07-30,Kissel), approve(86-07-30,MCR7475), audit(86-08-04,Coren),
 11     5*     install(86-10-09,MR12.0-1181):
 11     6*     This include file was formerly tty_event_message.incl.pl1.  It has been
 11     7*     updated with different fields and new constants, and renamed to
 11     8*     net_event_message.incl.pl1
 11     9*  2) change(87-04-20,GDixon), approve(87-07-13,MCR7694),
 11    10*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
 11    11*     Add NETWORK_TYPE_VALUES array.
 11    12*                                                   END HISTORY COMMENTS */
 11    13 
 11    14 /*	describes event message passed with wakeups from the tty DIM */
 11    15 /*	Created 5/24/76 by Robert S. Coren */
 11    16 
 11    17 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */
 11    18 
 11    19 dcl  net_event_message_arg	       fixed bin (71);	/* For calling IPC */
 11    20 dcl  NET_EVENT_MESSAGE_VERSION_1     bit (2) internal static options (constant) init ("10"b);
 11    21 
 11    22 dcl  1 net_event_message	       aligned based (addr (net_event_message_arg)),
 11    23        2 version		       bit (2) unaligned,	/* Currently version 1 */
 11    24        2 reason		       bit (16) unaligned,	/* Additional info about the event */
 11    25        2 pad		       bit (6) unaligned,	/* Must be zero */
 11    26        2 network_type	       fixed bin (4) unsigned unaligned,
 11    27 						/* See below for constants */
 11    28        2 type		       fixed bin (8) unsigned unaligned,
 11    29 						/* Type of interrupt, see below */
 11    30        2 handle		       fixed bin (35) aligned;/* Caller's handle (devx for MCS, handle for DSA) */
 11    31 
 11    32 /* Network type constants */
 11    33 
 11    34 dcl  MCS_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (0);
 11    35 dcl  DSA_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (1);
 11    36 dcl  MOWSE_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (2);
 11    37 
 11    38 dcl  NETWORK_TYPE_VALUES (0:2) char(8) varying int static options(constant) init(
 11    39 	"MCS",
 11    40 	"DSA",
 11    41 	"MOWSE");
 11    42 
 11    43 
 11    44 /* MCS event message type constants */
 11    45 
 11    46 dcl  MAX_MCS_EVENT_MSG_TYPE	       fixed bin internal static options (constant) init (8);
 11    47 
 11    48 dcl  MCS_UNSPECIFIED_MSG	       fixed bin internal static options (constant) init (0);
 11    49 						/* used for "start" order, etc. */
 11    50 dcl  MCS_DIALUP_MSG		       fixed bin internal static options (constant) init (1);
 11    51 						/* dialup */
 11    52 dcl  MCS_HANGUP_MSG		       fixed bin internal static options (constant) init (2);
 11    53 						/* hangup */
 11    54 dcl  MCS_DIALOUT_MSG	       fixed bin internal static options (constant) init (3);
 11    55 						/* dialout status returned */
 11    56 dcl  MCS_QUIT_MSG		       fixed bin internal static options (constant) init (4);
 11    57 						/* quit */
 11    58 dcl  MCS_READ_MSG		       fixed bin internal static options (constant) init (5);
 11    59 						/* input arrived */
 11    60 dcl  MCS_WRITE_MSG		       fixed bin internal static options (constant) init (6);
 11    61 						/* output completed */
 11    62 dcl  MCS_LINE_STATUS_MSG	       fixed bin internal static options (constant) init (7);
 11    63 						/* control tables sent status */
 11    64 dcl  MCS_MASKED_MSG		       fixed bin internal static options (constant) init (8);
 11    65 						/* channel masked by FNP */
 11    66 
 11    67 dcl  MCS_MSG_TYPE_TO_PNAME	       (0:8) char (20) internal static options (constant) init ("unspecified",
 11    68 						/*  0 */
 11    69 			       "dialup",		/*  1 */
 11    70 			       "hangup",		/*  2 */
 11    71 			       "dialout status",	/*  3 */
 11    72 			       "quit",		/*  4 */
 11    73 			       "read",		/*  5 */
 11    74 			       "write",		/*  6 */
 11    75 			       "line status",	/*  7 */
 11    76 			       "masked");		/*  8 */
 11    77 
 11    78 /* DSA event message type constants */
 11    79 
 11    80 dcl  MAX_DSA_EVENT_MSG_TYPE	       fixed bin internal static options (constant) init (19);
 11    81 
 11    82 dcl  DSA_UNSPECIFIED_MSG	       fixed bin (8) uns internal static options (constant) init (0);
 11    83 dcl  DSA_ATTENTION_MSG	       fixed bin (8) uns internal static options (constant) init (1);
 11    84 dcl  DSA_DATA_ATTENTION_MSG	       fixed bin (8) uns internal static options (constant) init (2);
 11    85 dcl  DSA_DEMAND_RELEASE_SRU_MSG      fixed bin (8) uns internal static options (constant) init (3);
 11    86 dcl  DSA_DEMAND_TURN_MSG	       fixed bin (8) uns internal static options (constant) init (4);
 11    87 dcl  DSA_DEMAND_TURN_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (5);
 11    88 dcl  DSA_PURGE_MSG		       fixed bin (8) uns internal static options (constant) init (6);
 11    89 dcl  DSA_RECOVER_MSG	       fixed bin (8) uns internal static options (constant) init (7);
 11    90 dcl  DSA_RECOVER_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (8);
 11    91 dcl  DSA_RELEASE_SRU_MSG	       fixed bin (8) uns internal static options (constant) init (9);
 11    92 dcl  DSA_RESUME_MSG		       fixed bin (8) uns internal static options (constant) init (10);
 11    93 dcl  DSA_RESUME_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (11);
 11    94 dcl  DSA_SUSPEND_MSG	       fixed bin (8) uns internal static options (constant) init (12);
 11    95 dcl  DSA_SUSPEND_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (13);
 11    96 dcl  DSA_TERM_ABNORMAL_MSG	       fixed bin (8) uns internal static options (constant) init (14);
 11    97 dcl  DSA_ESTABLISHMENT_MSG	       fixed bin (8) uns internal static options (constant) init (15);
 11    98 dcl  DSA_TERMINATED_MSG	       fixed bin (8) uns internal static options (constant) init (16);
 11    99 dcl  DSA_USER_UNASSIGN_MSG	       fixed bin (8) uns internal static options (constant) init (17);
 11   100 dcl  DSA_DATA_INPUT_MSG	       fixed bin (8) uns internal static options (constant) init (18);
 11   101 dcl  DSA_DATA_OUTPUT_MSG	       fixed bin (8) uns internal static options (constant) init (19);
 11   102 
 11   103 dcl  DSA_MSG_TYPE_TO_PNAME	       (0:19) char (20) internal static options (constant) init ("unspecified",
 11   104 						/*  0 */
 11   105 			       "attention",		/*  1 */
 11   106 			       "data_attention",	/*  2 */
 11   107 			       "demand_release_sru",	/*  3 */
 11   108 			       "demand_turn",	/*  4 */
 11   109 			       "demand_turn_ack",	/*  5 */
 11   110 			       "purge",		/*  6 */
 11   111 			       "recover",		/*  7 */
 11   112 			       "recover_ack",	/*  8 */
 11   113 			       "release_sru",	/*  9 */
 11   114 			       "resume",		/* 10 */
 11   115 			       "resume_ack",	/* 11 */
 11   116 			       "suspend",		/* 12 */
 11   117 			       "suspend_ack",	/* 13 */
 11   118 			       "terminate_abnormal",	/* 14 */
 11   119 			       "establishment",	/* 15 */
 11   120 			       "terminated",	/* 16 */
 11   121 			       "user_unassign",	/* 17 */
 11   122 			       "data input",	/* 18 */
 11   123 			       "data output");	/* 19 */
 11   124 
 11   125 /*	END INCLUDE FILE ... net_event_message.incl.pl1 */
      339 
      340 
      341 	locked_entry = "0"b;
      342 	forcesw = "0"b;				/* normal call, check buffer limit */
      343 	go to join;
      344 
      345 /* privileged entry to bypass buffer limit check - thru hphcs_ - used by answering service */
      346 
      347 tty_write_force:
      348      entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);
      349 
      350 	locked_entry = "0"b;
      351 	go to force_join;
      352 
      353 
      354 /* entry used to write whole output string or nothing, and optionally set a mark */
      355 
      356 tty_write_whole_string:
      357      entry (twx, a_string, a_mark_flag, a_nelemt, a_state, ercode);
      358 
      359 	locked_entry, forcesw = "0"b;
      360 	mark_entry = a_mark_flag;
      361 	whole_string = "1"b;
      362 	go to set_nelem;
      363 
      364 
      365 /* entry used when sending prompts and questions to distinguish between type-ahead and response */
      366 
      367 tty_write_set_mark:
      368      entry (twx, a_string, a_nelemt, a_state, ercode);
      369 
      370 	whole_string, locked_entry, forcesw = "0"b;
      371 	mark_entry = "1"b;
      372 set_nelem:
      373 	nelem = length (a_string);
      374 	offset = 0;
      375 	readp = addr (a_string);
      376 	go to mark_join;
      377 
      378 
      379 
      380 /* special internally-known entry which is called with channel already locked */
      381 
      382 locked:
      383      entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);
      384 
      385 	locked_entry = "1"b;			/* mark it as this entry so we don't lock/unlock */
      386 
      387 force_join:
      388 	forcesw = "1"b;
      389 
      390 join:
      391 	nelem = a_nelem;
      392 	readp = a_readp;
      393 	whole_string, mark_entry = "0"b;
      394 	offset = a_offset;
      395 
      396 mark_join:
      397 	start_time = clock ();
      398 	nelemt = 0;
      399 	a_nelemt = 0;
      400 	a_state = 0;
      401 	ercode = 0;
      402 	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf, tty_data */
      403 
      404 	devx = twx;				/* copy device index */
      405 	lctp = tty_buf.lct_ptr;			/* init pointer to lct */
      406 	if devx < 1 | devx > lct.max_no_lctes
      407 	then do;
      408 	     ercode = error_table_$invalid_device;
      409 	     return;
      410 	end;
      411 
      412 	uncp_flag = is_parent_mpx (UNCP_MPX);
      413 
      414 	if ^locked_entry
      415 	then do;
      416 	     call tty_lock$lock_channel (devx, ercode);	/* lock the channel lock */
      417 	     if ercode ^= 0
      418 	     then return;
      419 	end;
      420 
      421 	allocated_buffers = "0"b;
      422 	on cleanup
      423 	begin;
      424 	     if allocated_buffers
      425 	     then do;
      426 		allocated_buffers = "0"b;		/* don't try again */
      427 		call free_buffers;
      428 	     end;
      429 	     if ^locked_entry
      430 	     then call tty_lock$unlock_channel (devx);
      431 	end;					/* cleanup block */
      432 
      433 	lctep = addr (lct.lcte_array (devx));		/* get entry of interest */
      434 	if lcte.channel_type ^= TTY_MPX		/* not our type */
      435 	then do;
      436 no_permission:
      437 	     ercode = error_table_$io_no_permission;
      438 	     go to unlock;
      439 	end;
      440 
      441 	wtcbp = lcte.data_base_ptr;			/* get pointers to control blocks */
      442 	tcbp = wtcb.tcb_ptr;			/* get tcb pointer */
      443 	if ^wtcb.tcb_initialized
      444 	then call tty_index$initialize_tcb (wtcbp, tcbp);
      445 
      446 	if pds$processid ^= wtcb.hproc
      447 	then if (pds$processid ^= wtcb.uproc) | ^tcb.uproc_attached
      448 	     then go to no_permission;
      449 
      450 	if wtcb.flags.dialed
      451 	then state = DIALED_UP;
      452 	else if wtcb.flags.listen
      453 	then state = LISTENING;
      454 	else if wtcb.flags.masked
      455 	then state = MASKED_STATE;
      456 	else state = HUNG_UP;
      457 
      458 	if state ^= DIALED_UP
      459 	then do;
      460 	     if pds$processid = wtcb.hproc
      461 	     then a_state = state;
      462 	     go to no_permission;
      463 	end;
      464 
      465 	a_state = state;
      466 
      467 	if wtcb.flags.line_status_present
      468 	then do;
      469 	     ercode = error_table_$line_status_pending;
      470 	     go to unlock;
      471 	end;
      472 
      473 	if wtcb.error_code ^= 0
      474 	then do;
      475 	     ercode = wtcb.error_code;
      476 	     wtcb.error_code = 0;
      477 	     go to unlock;
      478 	end;
      479 
      480 	if nelem < 0
      481 	then do;
      482 	     ercode = error_table_$bad_arg;
      483 	     go to unlock;
      484 	end;
      485 						/* Added for the Datanet 7100. */
      486 	if uncp_flag then do;
      487 	     if readp = addr (wtcb.prompt)
      488 		then do;
      489 		wtcb.send_turn = "1"b;
      490 		if nelem = 0
      491 		     then do;
      492 		     if wtcb.write_last ^= 0
      493 			then do;
      494 			blockp = ptr (ttybp, wtcb.write_last);
      495 			buffer.turn = "1"b;
      496 			wtcb.send_turn = "0"b;
      497 		     end;
      498 		end;
      499 	     end;
      500 	end;
      501 
      502 	ercode = 0;
      503 	if nelem = 0
      504 	then go to all_done;
      505 
      506 	eop_sentinel = byte (eop_sentinel_octal);
      507 
      508 	if ^tcb.modes.rawom				/* if we're interested in conversion */
      509 	then do;
      510 	     ttytp = addr (tty_tables$);
      511 	     if tcb.output_tctrp = ""b
      512 	     then tctp = null;
      513 	     else tctp = ptr (ttytp, tcb.output_tctrp);
      514 	     if tcb.output_mvtrp = ""b
      515 	     then mvtp = null;
      516 	     else mvtp = ptr (ttytp, tcb.output_mvtrp);
      517 	     if tcb.specialrp = ""b
      518 	     then special_ptr = null;
      519 	     else special_ptr = ptr (ttytp, tcb.specialrp);
      520 	     if tcb.delayrp = ""b
      521 	     then delay_ptr = null;
      522 	     else delay_ptr = ptr (ttytp, tcb.delayrp);
      523 	end;
      524 
      525 /**/
      526 /* calculate number of buffers line is allowed to have */
      527 
      528 	if forcesw
      529 	then max_space = tty_buf.bleft - 32;		/* force entry can have as many as it needs */
      530 	else do;
      531 	     cur_space = 0;
      532 	     cur_chain_len = 0;
      533 	     if wtcb.write_first ^= 0
      534 	     then do;
      535 		blockp = ptr (ttybp, wtcb.write_first);
      536 		end_chain = "0"b;
      537 		do while (^end_chain);
      538 		     cur_space = cur_space + 16 * (buffer.size_code + 1);
      539 		     cur_chain_len = cur_chain_len + 1;
      540 		     if buffer.next = 0
      541 		     then end_chain = "1"b;
      542 		     else blockp = ptr (ttybp, buffer.next);
      543 		end;
      544 	     end;
      545 	     max_space =
      546 		min (divide (tty_buf.bleft, output_bpart, 17, 0) - cur_space,
      547 		(max_chain_len - cur_chain_len) * (wtcb.max_buf_size - 1));
      548 	end;
      549 
      550 	max_chars_in_buf = 4 * (wtcb.max_buf_size - 1) - wtcb.buffer_pad;
      551 
      552 	if max_space <= 0
      553 	then 
      554 NO_SPACE_WRITE_NOTHING:
      555 	do;
      556 	     nelemt = 0;
      557 	     go to nothing_written;
      558 	end;					/* otherwise only certain fraction can be allocated */
      559 
      560 	max_chars = min (4 * max_space, LONGEST_POSSIBLE_STRING);	/* don't overflow tty_buf or the stack */
      561 
      562 /* Determine good sizes for internal automatic buffers for the duration of this call */
      563 /* max_chars takes account of all policy limitations */
      564 
      565 	auto_buf_len = min (max_chars, 512 + 2 * nelem);	/* leave lots of leeway */
      566 	max_chars = auto_buf_len;
      567 	if whole_string & nelem > max_chars		/* can't possibly take all of this */
      568 	then do;
      569 	     if nelem <= LONGEST_POSSIBLE_STRING
      570 	     then go to NO_SPACE_WRITE_NOTHING;
      571 	     ercode = error_table_$bigarg;
      572 	     go to unlock;
      573 	end;
      574 
      575 	begin;					/* giant begin block */
      576 
      577 dcl  buffer_1 char (auto_buf_len) aligned;		/* first internal workspace buffer */
      578 dcl  buffer_2 char (auto_buf_len) aligned;		/* second internal workspace buffer */
      579 
      580 	     input_ptr = readp;
      581 	     input_ptr = addr (input_ptr -> based_chars (offset));
      582 
      583 	     nelemt = -1;				/* to indicate first time around */
      584 
      585 restart:						/* come here if we have to start over */
      586 	     if tcb.modes.rawom			/* raw output, simple */
      587 	     then do;
      588 		final_outp = input_ptr;		/* copy straight from user's data */
      589 		if nelemt < 0			/* i.e. not restart */
      590 		then nelemt = min (nelem, max_chars);
      591 		output_length = nelemt;
      592 	     end;
      593 
      594 	     else do;				/* else we must massage the input */
      595 		if nelemt < 0			/* if not already set */
      596 		then nelemt = min (nelem, fixed (reduction_factor * max_chars));
      597 
      598 		line_count = wtcb.actline;
      599 		col = wtcb.actcol;
      600 		wcol = wtcb.white_col;
      601 
      602 		final_outp, source_ptr = input_ptr;	/* to begin with */
      603 		source_len = nelemt;
      604 		target_ptr = addr (buffer_1);
      605 		target_len = 0;
      606 
      607 		if tcb.modes.upper_case
      608 		then call convert_to_upper_case;	/* translate lower-case to caps? */
      609 
      610 /* ** FORMATTING ** */
      611 
      612 		if tctp ^= null			/* must have output conversion table */
      613 		     & special_ptr ^= null		/* and special chars table too */
      614 		then do;
      615 		     target_len = 0;		/* initially */
      616 		     chars_moved = "0"b;
      617 		     white_sw = (wcol ^= col);	/* depends on whether there's white space left from last call */
      618 
      619 		     final_outp = target_ptr;		/* where we expect stuff to end up */
      620 
      621 		     if tcb.linemax > 0
      622 		     then do;
      623 			if line_count >= tcb.linemax	/* did input cause EOP condition ? */
      624 			then do;			/* yes, write eop sequence now */
      625 			     seqp = addr (special_ptr -> special_chars.end_of_page);
      626 			     if seqp -> seq.count > 0	/* must have something to write */
      627 			     then do;
      628 				call insert_sequence ("0"b);
      629 				call insert_char (eop_sentinel);
      630 				line_count = 0;
      631 			     end;
      632 			end;
      633 		     end;
      634 
      635 		     util.tablep = tctp;		/* formatting table */
      636 		     util.stringp = source_ptr;
      637 		     util.stringl = source_len;
      638 
      639 		     do while (util.stringl > 0);	/* main formatting loop */
      640 
      641 			oldcol = col;
      642 			call tty_util_$find_char (addr (util));
      643 						/* find next interesting character */
      644 
      645 			call move_formated_chars;
      646 
      647 			if ^white_sw
      648 			then wcol = col;		/* so next white-space calculation will be right */
      649 
      650 		     end;				/* end of formatting loop */
      651 
      652 		     if white_sw			/* take care of trailing white space */
      653 		     then if nelemt = nelem		/* if output really ends in white space */
      654 			then call insert_white;
      655 			else if target_len = 0	/* only white? */
      656 			     then call insert_white;	/* expand it */
      657 
      658 		end;
      659 
      660 		else target_len = source_len;		/* no conversion performed */
      661 
      662 		if mvtp ^= null
      663 		then call translation;		/* translation required */
      664 
      665 		output_length = target_len;
      666 	     end;					/* end of all conversion phases */
      667 
      668 /* ****ALLOCATE BUFFERS AND PASS OUTPUT ON*** */
      669 
      670 	     new_char_count, new_buffer_count = 0;
      671 
      672 	     if output_length > 0			/* assuming there's anything left after conversion */
      673 	     then do;
      674 		first_buffer = "1"b;
      675 		old_end_frame = wtcb.end_frame;
      676 
      677 		if wtcb.write_last = 0
      678 		then do;
      679 		     send = "1"b;			/* there's nothing ahead of it, so we'll send it on */
      680 		     old_head, old_tail = 0;
      681 		end;
      682 
      683 		else do;				/* save information about old chain */
      684 		     lastp, old_lastp = ptr (ttybp, wtcb.write_last);
      685 		     send = "0"b;			/* we'll just hang on to this */
      686 		     old_head = wtcb.write_first;
      687 		     old_tail = wtcb.write_last;
      688 		end;
      689 
      690 		n_pages = 0;
      691 		headp = null;
      692 		new_head = 0;
      693 		allocated_buffers = "1"b;		/* crawlout can now safely free them */
      694 
      695 		do while (output_length > 0);		/* copy for as long as necessary */
      696 		     n_pages = n_pages + 1;
      697 
      698 		     if tcb.modes.rawom		/* if raw mode don't check for end of page */
      699 		     then go to no_break;
      700 
      701 		     break_length = index (final_outp -> output_chars, eop_sentinel) - 1;
      702 						/* look for page break */
      703 		     if break_length < 0
      704 		     then do;
      705 no_break:
      706 			break_flag = "0"b;		/* no end-of-page markers */
      707 			break_length = output_length;
      708 		     end;
      709 
      710 		     else do;
      711 			break_flag = "1"b;
      712 			if break_length = 0
      713 			then do;			/* eop sentinel was first thing */
      714 			     final_outp -> based_chars (0) = byte (delay_char);
      715 						/* send out a NUL because we have to send something to alert lower level */
      716 			     break_length = 1;
      717 			     null_for_eop = "1"b;
      718 			end;
      719 			else null_for_eop = "0"b;
      720 		     end;
      721 
      722 		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
      723 						/* new buffer at every end-of-block */
      724 		     then break_length = min (break_length, tcb.max_output_block);
      725 
      726 		     output_length = output_length - break_length;
      727 
      728 		     do while (break_length > 0);
      729 
      730 /* do we have a buffer with room in it? */
      731 
      732 			if wtcb.write_last = 0
      733 			then go to get_new_buf;
      734 			if lastp -> buffer.tally < max_chars_in_buf & ^lastp -> buffer.flags.end_of_page
      735 			     & ^(tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0)
      736 			then do;
      737 			     lchar = lastp -> buffer.tally;
      738 
      739 /* make new buffer as big as appropriate */
      740 
      741 			     buf_size, orig_buf_size = 16 * (lastp -> buffer.size_code + 1);
      742 			     reached_needed = "0"b;	/* assume not yet reached appropriate size */
      743 			     do while (^reached_needed);
      744 				chars_in_buf = 4 * (buf_size - 1) - wtcb.buffer_pad;
      745 				if lchar + break_length <= chars_in_buf
      746 						/* room in this buffer for rest of output */
      747 				     | chars_in_buf = max_chars_in_buf
      748 						/* or we've already reached maximum allowable size */
      749 				then reached_needed = "1"b;
      750 				else buf_size = buf_size + 16;
      751 						/* try next size */
      752 			     end;
      753 
      754 			     if buf_size ^= orig_buf_size
      755 						/* if we need a new size */
      756 			     then do;		/* get new buffer, and copy contents of old one */
      757 				call tty_space_man$get_buffer (devx, buf_size, OUTPUT, new_bufp);
      758 				if new_bufp ^= null /* only do this if we could get it, of course */
      759 				then do;
      760 				     nchars = lastp -> buffer.tally;
      761 				     source_ptr = addr (lastp -> buffer.chars (0));
      762 				     target_ptr = addr (new_bufp -> buffer.chars (0));
      763 				     target_ptr -> chars_to_copy = source_ptr -> chars_to_copy;
      764 				     new_bufp -> buffer.tally = lastp -> buffer.tally;
      765 				     wtcb.write_last = bin (rel (new_bufp), 18);
      766 						/* this will now be end of chain */
      767 
      768 						/* Add for the Datanet 7100. */
      769 				     if uncp_flag then new_bufp -> buffer.turn = lastp -> buffer.turn;
      770 						/* copy turn flag into new buffer */
      771 
      772 /* thread new buffer onto end of chain in place of old one */
      773 
      774 				     prevp = ptr (ttybp, wtcb.write_first);
      775 						/* start at head */
      776 				     if prevp = lastp
      777 						/* is it tail also? */
      778 				     then wtcb.write_first = wtcb.write_last;
      779 						/* that's simple */
      780 				     else do;	/* else we'll scan the chain */
      781 					do prevp = prevp repeat ptr (ttybp, prevp -> buffer.next)
      782 					     while (prevp -> buffer.next ^= bin (rel (lastp), 18)
      783 					     & prevp -> buffer.next ^= 0);
      784 					end;
      785 					prevp -> buffer.next = wtcb.write_last;
      786 						/* found the next-to-last one */
      787 				     end;
      788 
      789 				     call tty_space_man$free_buffer (devx, OUTPUT, lastp);
      790 						/* give the old one back */
      791 				     lastp = new_bufp;
      792 
      793 				     if first_buffer
      794 				     then do;
      795 					old_lastp = lastp;
      796 					old_tail = wtcb.write_last;
      797 					if wtcb.write_first = wtcb.write_last
      798 					then old_head = wtcb.write_first;
      799 				     end;
      800 				end;
      801 
      802 				else chars_in_buf = 4 * (orig_buf_size - 1) - wtcb.buffer_pad;
      803 						/* couldn't get bigger buffer, use original size */
      804 			     end;
      805 
      806 			     bufp = addr (lastp -> buffer.chars (lchar));
      807 			     old_char_count = lastp -> buffer.tally;
      808 			     nchars = min (break_length, chars_in_buf - lchar);
      809 			end;
      810 
      811 			else do;			/* no, we'll have to get one */
      812 get_new_buf:
      813 			     words_needed =
      814 				max (16,
      815 				min (wtcb.max_buf_size,
      816 				16 * divide (break_length + wtcb.buffer_pad + 67, 64, 17, 0)));
      817 			     call tty_space_man$get_buffer (devx, words_needed, OUTPUT, new_bufp);
      818 			     if new_bufp = null	/* couldn't get the space */
      819 			     then go to free_and_try_again;
      820 			     new_buf = bin (rel (new_bufp), 18);
      821 			     chars_in_buf = 4 * (words_needed - 1) - wtcb.buffer_pad;
      822 
      823 			     if first_buffer
      824 			     then do;
      825 				new_head = new_buf;
      826 				first_buffer = "0"b;
      827 			     end;
      828 
      829 			     new_buffer_count = new_buffer_count + 1;
      830 			     lchar = 0;
      831 			     if wtcb.write_last ^= 0	/* chain already abuilding */
      832 			     then lastp -> buffer.next = new_buf;
      833 			     else wtcb.write_first = new_buf;
      834 
      835 			     wtcb.write_last = new_buf;
      836 						/* in any case */
      837 			     lastp = new_bufp;
      838 			     string (lastp -> buffer.flags) = "0"b;
      839 
      840 			     old_char_count = 0;
      841 			     bufp = addr (lastp -> buffer.chars (0));
      842 			     nchars = min (break_length, chars_in_buf);
      843 			end;
      844 
      845 			lastp -> buffer.tally = old_char_count + nchars;
      846 			lastp -> buffer.flags.break = "0"b;
      847 						/* not at end of user data */
      848 			bufp -> chars_to_copy = final_outp -> chars_to_copy;
      849 						/* put characters in buffer */
      850 			final_outp = addr (final_outp -> based_chars (nchars));
      851 			new_char_count = new_char_count + nchars;
      852 			break_length = break_length - nchars;
      853 
      854 						/* Add for the Datanet 7100. */
      855 			if uncp_flag then do;
      856 			     if break_length = 0
      857 				then do;
      858 				lastp -> buffer.turn = wtcb.send_turn;
      859 				wtcb.send_turn = "0"b;
      860 			     end;
      861 			end;
      862 		     end;
      863 
      864 
      865 		     if break_flag			/* did we stop because of end-of-page? */
      866 		     then do;
      867 			lastp -> buffer.flags.end_of_page = "1"b;
      868 			if ^null_for_eop		/* if we haven't laready skipped over sentinel */
      869 			then do;
      870 			     final_outp = addr (final_outp -> based_chars (1));
      871 						/* skip over sentinel */
      872 			     output_length = output_length - 1;
      873 			end;
      874 		     end;
      875 
      876 		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
      877 		     then do;			/* insert end_of_block char */
      878 			if lastp -> buffer.tally < chars_in_buf
      879 						/* it'll fit in last buffer */
      880 			then do;
      881 			     lastp -> buffer.chars (lastp -> buffer.tally) =
      882 				substr (tcb.output_suspend_etb_seq.chars, 1, 1);
      883 			     lastp -> buffer.tally = lastp -> buffer.tally + 1;
      884 			end;
      885 
      886 			else do;			/* unfortunately, we have to allocate a whole buffer for this char */
      887 			     call tty_space_man$get_buffer (devx, 16, OUTPUT, new_bufp);
      888 			     if new_bufp = null
      889 			     then go to free_and_try_again;
      890 			     string (new_bufp -> buffer.flags) = "0"b;
      891 			     new_bufp -> buffer.tally = 1;
      892 			     new_bufp -> buffer.chars (0) = substr (tcb.output_suspend_etb_seq.chars, 1, 1);
      893 			     wtcb.write_last, lastp -> buffer.next = bin (rel (new_bufp), 18);
      894 			     lastp = new_bufp;
      895 			end;
      896 		     end;
      897 		end;				/* end of buffer-allocation loop */
      898 
      899 		if nelem = nelemt
      900 		then do;
      901 		     lastp -> buffer.flags.break = "1"b;/* end of user data */
      902 		     lastp -> buffer.flags.mark = mark_entry;
      903 		end;
      904 
      905 		if send & wtcb.send_output		/* if this is first new output, we'll pass it on */
      906 		then do;
      907 		     if n_pages > 1
      908 		     then do;			/* peel off first page if there's more than one */
      909 			blockp = ptr (ttybp, wtcb.write_first);
      910 
      911 			do while (^buffer.end_of_page & buffer.next ^= 0);
      912 						/* find last buffer of page */
      913 			     blockp = ptr (ttybp, buffer.next);
      914 			end;
      915 
      916 			lastp = blockp;		/* this is it */
      917 		     end;
      918 
      919 		     else lastp = ptr (ttybp, wtcb.write_last);
      920 						/* if only 1 page, last buffer is last buffer of page */
      921 		     if mark_entry
      922 		     then wtcb.mark_set = lastp -> buffer.mark;
      923 						/* we're sending the mark now */
      924 		     new_head = lastp -> buffer.next;	/* this will be the head of the remaining chain (if any) */
      925 		     headp = ptr (ttybp, wtcb.write_first);
      926 		     wtcb.write_first = lastp -> buffer.next;
      927 						/* update wtcb pointers now (we'll restore them if necessary) */
      928 		     if wtcb.write_first = 0
      929 		     then wtcb.write_last = 0;	/* ensure consistency always */
      930 		     lastp -> buffer.next = 0;	/* break the chain at page end */
      931 		     wtcb.end_frame = lastp -> buffer.end_of_page;
      932 
      933 		     call channel_manager$write (devx, headp, ercode);
      934 		     if ercode = error_table_$noalloc
      935 		     then do;
      936 			nelemt = 0;		/* this means they couldn't take it at all */
      937 			call free_buffers;
      938 			go to nothing_written;
      939 		     end;
      940 		     else do;
      941 			if ercode ^= 0
      942 			then do;
      943 			     call free_buffers;	/* get rid of anything we've got left (it's unwritable) */
      944 			     if wtcb.write_first ^= 0 /* and I mean ANYTHING */
      945 			     then do;
      946 				call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, wtcb.write_first));
      947 				wtcb.write_first, wtcb.write_last = 0;
      948 				wtcb.mark_set = "0"b;
      949 						/* all bets are off */
      950 			     end;
      951 			end;
      952 
      953 			else if headp ^= null
      954 			then do;			/* didn't take it all */
      955 			     wtcb.write_first = bin (rel (headp));
      956 			     blockp = headp;
      957 			     do while (buffer.next ^= 0);
      958 						/* find end of returned chain */
      959 				blockp = ptr (ttybp, buffer.next);
      960 			     end;
      961 
      962 			     buffer.next = new_head;	/* hook it back on */
      963 			     if wtcb.write_last = 0	/* sent all we had */
      964 			     then wtcb.write_last = bin (rel (blockp));
      965 						/* this is now end of the chain */
      966 
      967 			     if mark_entry
      968 			     then wtcb.mark_set = "0"b;
      969 						/* override any previously-set mark */
      970 			end;
      971 			wtcb.send_output = "0"b;	/* no more till he asks for it */
      972 		     end;
      973 		end;
      974 	     end;
      975 
      976 	     if ^tcb.modes.rawom
      977 	     then do;				/* only if messed around with it */
      978 		wtcb.actcol = col;
      979 		wtcb.actline = line_count;
      980 		wtcb.white_col = wcol;
      981 	     end;
      982 
      983 	     if nelemt < nelem
      984 	     then do;				/* we couldn't get them all out this time */
      985 		i = (nelem - nelemt);		/* approximate num of chars left to output */
      986 		if tty_buf.minbuf = 0 | tty_buf.minbuf > i
      987 		then tty_buf.minbuf = i;		/* if new minimum, set it */
      988 
      989 		tty_buf.totbuf = tty_buf.totbuf + i;	/* set blocked-for-write meters  */
      990 		tty_buf.nblocked = tty_buf.nblocked + 1;
      991 
      992 		/*** If we did not consume all of our caller's output but
      993*		generated no output, ensure that the process sees a wakeup
      994*		so that the rest of the output will be handled. */
      995 		
      996 		if wtcb.send_output			/* nothing in progress */
      997 		then do;
      998 		     unspec (net_event_message) = "0"b;
      999 		     net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
     1000 		     net_event_message.network_type = MCS_NETWORK_TYPE;
     1001 		     net_event_message.handle = devx;
     1002 		     net_event_message.type = MCS_WRITE_MSG;
     1003 		     call pxss$ring_0_wakeup (wtcb.uproc, wtcb.event, net_event_message_arg, (0));
     1004 		     wtcb.wflag = "0"b;
     1005 		end;
     1006 		else wtcb.flags.wflag = "1"b;		/* so wakeup will happen when write completes */
     1007 	     end;
     1008 
     1009 	     tcb.cumulative_meters.write_chars = tcb.cumulative_meters.write_chars + nelemt;
     1010 	     tcb.cumulative_meters.write_calls = tcb.cumulative_meters.write_calls + 1;
     1011 	     tty_buf.write_calls = tty_buf.write_calls + 1;
     1012 	     tty_buf.noutchars = tty_buf.noutchars + nelemt;
     1013 						/* keep count of output chars per type */
     1014 	     tty_buf.nrawwrite = tty_buf.nrawwrite + new_char_count;
     1015 	     go to all_done;
     1016 
     1017 free_and_try_again:					/* here if we or next level couldn't allocate buffers */
     1018 	     call free_buffers;
     1019 	     tty_buf.output_buffer_overflow = tty_buf.output_buffer_overflow + 1;
     1020 try_again:					/* here if we overflowed internal buffer space */
     1021 	     if whole_string			/* mustn't subdivide caller's string */
     1022 	     then do;
     1023 		nelemt = 0;
     1024 		go to nothing_written;
     1025 	     end;
     1026 
     1027 	     tty_buf.output_restart = tty_buf.output_restart + 1;
     1028 
     1029 	     nelemt = divide (nelemt, 2, 18, 0);	/* cut in half to try again */
     1030 	     if nelemt > 0				/* does that leave us anything to process? */
     1031 	     then go to restart;
     1032 	     else go to nothing_written;
     1033 
     1034 
     1035 
     1036 /* *** ERROR BRANCH FOR FAULTY TABLE VALUES *** */
     1037 
     1038 table_error:
     1039 	     ercode = error_table_$improper_data_format;
     1040 	     go to unlock;
     1041 
     1042 /* ***********INTERNAL PROCEDURES********* */
     1043 
     1044 copy_chars:
     1045      proc;
     1046 
     1047 /* This procedure copies ctally characters form source_ptr to target_ptr */
     1048 
     1049 	target_len = target_len + ctally;
     1050 	if target_len > max_chars			/* check for overflow */
     1051 	then go to try_again;
     1052 
     1053 	target_ptr -> tally_chars = source_ptr -> tally_chars;
     1054 
     1055 	source_ptr = addr (source_ptr -> based_chars (ctally));
     1056 						/* bump pointers */
     1057 	target_ptr = addr (target_ptr -> based_chars (ctally));
     1058 	return;
     1059 
     1060      end /* copy_chars */;
     1061 
     1062 insert_char:
     1063      proc (one_char);
     1064 
     1065 /* This procedure places a single character in the output string */
     1066 
     1067 dcl  one_char char (1);
     1068 
     1069 	target_len = target_len + 1;
     1070 	if target_len > max_chars			/* mustn't overflow buffer space */
     1071 	then go to try_again;
     1072 
     1073 	target_ptr -> based_onechar = one_char;
     1074 	target_ptr = addr (target_ptr -> based_chars (1));
     1075 	return;
     1076 
     1077      end /* insert_char */;
     1078 
     1079 insert_delays:
     1080      proc (ndelays);
     1081 
     1082 /* This procedure inserts a specified number of delay characters into the output */
     1083 
     1084 dcl  ndelays fixed bin;
     1085 dcl  i fixed bin;
     1086 
     1087 	if ndelays <= 0
     1088 	then return;				/* nothing to do */
     1089 
     1090 	target_len = target_len + ndelays;
     1091 	if target_len > max_chars			/* red warning */
     1092 	then go to try_again;			/* tough */
     1093 
     1094 	do i = 0 to ndelays - 1;			/* remember based_chars starts at 0 */
     1095 	     target_ptr -> based_chars (i) = byte (delay_char);
     1096 	end;
     1097 
     1098 	target_ptr = addr (target_ptr -> based_chars (ndelays));
     1099 						/* bump pointer */
     1100 	return;
     1101 
     1102      end /* insert_delays */;
     1103 
     1104 insert_sequence:
     1105      proc (a_col_sw);
     1106 
     1107 /* This procedure inserts the character sequence pointed to by seqp */
     1108 /* col_sw tells whether or not to check for overflowing line-length */
     1109 
     1110 dcl  a_col_sw bit (1) aligned;
     1111 dcl  col_sw bit (1) aligned;
     1112 dcl  i fixed bin;
     1113 dcl  auto_len fixed bin;
     1114 
     1115 	col_sw = a_col_sw;
     1116 	c_chars_ptr = seqp;				/* make compiler happy */
     1117 	auto_len = seqp -> seq.count;			/* copy sequence length into automatic */
     1118 	if auto_len = 0
     1119 	then return;				/* no sequence */
     1120 
     1121 	if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)/* probably not a real sequence */
     1122 	then go to table_error;
     1123 
     1124 	target_len = target_len + auto_len;
     1125 	if target_len > max_chars
     1126 	then go to try_again;
     1127 
     1128 	if seqp -> seq.chars (1) = ascii_escape_char
     1129 	then col_sw = "0"b;				/* if escape sequence, best not to mess with the columns */
     1130 	do i = 1 to auto_len;
     1131 	     if col_sw				/* do we care about column position? */
     1132 	     then do;				/* yes */
     1133 		if seqp -> seq.chars (i) = backspace	/* back up with delays in this case */
     1134 		then do;
     1135 		     col = max (0, col - 1);
     1136 		     if delay_ptr ^= null
     1137 		     then call insert_delays (delay_ptr -> delay.backspace);
     1138 		end;
     1139 
     1140 		else if rank (seqp -> seq.chars (i)) < 32
     1141 		then ;				/* if so, then probably doesn't move carriage */
     1142 						/* adding 0 is just as good as + 1 when we don't know what
     1143*						   the chars really do to the terminal */
     1144 
     1145 		else do;
     1146 		     if ((tcb.colmax > 0) & (col >= tcb.colmax))
     1147 		     then call insert_nl ("1"b);
     1148 		     col = col + 1;
     1149 		end;
     1150 	     end;
     1151 
     1152 	     target_ptr -> based_onechar = seqp -> seq.chars (i);
     1153 	     target_ptr = addr (target_ptr -> based_chars (1));
     1154 						/* bump pointer */
     1155 	end;
     1156 
     1157 	return;
     1158 
     1159      end /* insert_sequence */;
     1160 
     1161 insert_white:
     1162      proc;
     1163 
     1164 /* this procedure puts white space into the output string */
     1165 
     1166 	if wcol ^= col				/* make sure we're not already where we belong */
     1167 	then do;
     1168 	     if tcb.colmax > 0
     1169 	     then do while (wcol > tcb.colmax);		/* put in any necessary new-lines */
     1170 		call insert_nl ("1"b);
     1171 		oldcol = 2;
     1172 		wcol = wcol - tcb.colmax + 2;
     1173 	     end;
     1174 
     1175 	     if wcol < col				/* we're going to have to back up */
     1176 	     then if wcol = 0			/* that one's easy */
     1177 		then call insert_cr;		/* just put in carriage return */
     1178 
     1179 		else if special_ptr -> special_chars.cr_seq.count > 0
     1180 		then do;				/* figure out which way to back up */
     1181 		     back_chars = col - wcol;		/* that's how many backspaces it would take */
     1182 		     if back_chars <= 6		/* in this case don't bother calculating other */
     1183 		     then forward_chars = back_chars;	/* to make sure test will fail */
     1184 		     else if tcb.modes.tabm
     1185 		     then forward_chars = divide (wcol, 10, 17, 0) + mod (wcol, 10) + 1;
     1186 						/* tabs + spaces + cr */
     1187 		     else forward_chars = wcol + 1;	/* spaces + cr */
     1188 
     1189 		     if back_chars - forward_chars > 6 | special_ptr -> special_chars.bs_seq.count = 0
     1190 						/* no backspace available */
     1191 		     then call insert_cr;		/* thereby setting col to 0, we'll do forward later */
     1192 		     else call insert_bs (back_chars);	/* put in necessary number of backspaces */
     1193 		end;
     1194 
     1195 		else call insert_bs (col - wcol);
     1196 
     1197 	     if wcol > col				/* we have to go forward */
     1198 	     then do;
     1199 		if tcb.modes.tabm			/* might we use tabs? */
     1200 		then do;
     1201 		     do while (wcol - col > 10);	/* tabs are relevant */
     1202 			call insert_tab;		/* will update col */
     1203 		     end;
     1204 
     1205 		     if mod (wcol, 10) <= mod (col, 10) /* room for another tab */
     1206 		     then call insert_tab;
     1207 		end;
     1208 
     1209 		do col = col by 1 while (col < wcol);
     1210 		     call insert_char (space);	/* put in spaces as required */
     1211 		end;
     1212 	     end;
     1213 	end;
     1214 
     1215 	oldcol = wcol;
     1216 	white_sw = "0"b;				/* we've done it now */
     1217 	return;
     1218 
     1219      end /* insert_white */;
     1220 
     1221 insert_nl:
     1222      proc (esc_sw);
     1223 
     1224 /* This procedure inserts new-line sequences in the output string */
     1225 /* esc_sw indicates whether a "\c" sequence should be added */
     1226 
     1227 dcl  esc_sw bit (1) aligned;
     1228 dcl  delay_before bit (1) aligned;
     1229 dcl  eop_sw bit (1) aligned;
     1230 dcl  eop_seqp ptr;
     1231 dcl  seqp ptr;
     1232 dcl  based_target_chars char (target_len) based;
     1233 
     1234 	eop_sw = "0"b;
     1235 	eop_seqp = null;
     1236 
     1237 	if tcb.linemax > 0
     1238 	then do;
     1239 	     line_count = line_count + 1;
     1240 	     eop_sw = (line_count >= tcb.linemax);
     1241 	     if eop_sw
     1242 	     then do;
     1243 		eop_seqp = addr (special_ptr -> special_chars.end_of_page);
     1244 		if eop_seqp -> seq.count = 0		/* null end-of-page sequence */
     1245 		then eop_seqp = null;
     1246 		line_count = 0;
     1247 	     end;
     1248 	end;
     1249 
     1250 	if eop_sw & (eop_seqp = null)			/* omit end-of-page marker and put sentinel before newline */
     1251 	then do;
     1252 	     if target_len = 0			/* don't let sentinel be first thing in output */
     1253 	     then call insert_char (byte (delay_char));	/* so insert a NUL */
     1254 	     call insert_char (eop_sentinel);
     1255 	end;
     1256 
     1257 	else do;
     1258 	     seqp = addr (special_ptr -> special_chars.nl_seq);
     1259 						/* this is the sequence we will use */
     1260 
     1261 	     if delay_ptr ^= null			/* delays needed */
     1262 	     then do;
     1263 		horiz = delay_ptr -> delay.horz_nl;
     1264 		vert = delay_ptr -> delay.vert_nl;
     1265 
     1266 		if vert < 0			/* special */
     1267 		then do;				/* means minimum line length */
     1268 		     ll = index (reverse (final_outp -> based_target_chars), nl) - 1;
     1269 						/* find latest nl */
     1270 		     if ll < 0
     1271 		     then ll = target_len;
     1272 		     n_delays = max (0, -vert - ll);
     1273 
     1274 		     delay_before = "1"b;		/* put delays before sequence */
     1275 		end;
     1276 
     1277 		else do;				/* normal delays */
     1278 		     delay_before = "0"b;		/* delays after nl */
     1279 		     n_delays = vert + fixed (float (col) * horiz, 17, 0);
     1280 		end;
     1281 	     end;
     1282 
     1283 	     else n_delays = 0;
     1284 
     1285 	     if delay_before			/* do it now */
     1286 	     then if n_delays > 0			/* if at all */
     1287 		then call insert_delays (n_delays);
     1288 
     1289 	     call insert_sequence_internal;		/* put in the sequence */
     1290 
     1291 	     if ^delay_before
     1292 	     then if n_delays > 0
     1293 		then call insert_delays (n_delays);
     1294 
     1295 	     if eop_sw
     1296 	     then do;
     1297 		seqp = eop_seqp;
     1298 		call insert_sequence_internal;	/* put in end-of-page warning */
     1299 		call insert_char (eop_sentinel);	/* put in sentinel for copying phase */
     1300 	     end;
     1301 	end;
     1302 
     1303 	if esc_sw					/* was this nl because of line overflow? */
     1304 	then do;
     1305 	     call insert_char (escape_char);
     1306 	     call insert_char (cont_char);
     1307 	     col = 2;
     1308 	end;
     1309 
     1310 	else col = 0;
     1311 
     1312 	return;
     1313 
     1314 insert_sequence_internal:
     1315 	proc;
     1316 
     1317 /* this is an internal procedure in insert_nl because if insert_nl calls */
     1318 /* insert_sequence both procedures become non-quick
     1319*   because insert_sequence has the potential to call insert_nl, thus they
     1320*   would be recursive and by definition recursion is reason for being non-quick
     1321**/
     1322 
     1323 dcl  i fixed bin;
     1324 dcl  auto_len fixed bin;
     1325 
     1326 	     c_chars_ptr = seqp;			/* make compiler happy */
     1327 	     auto_len = seqp -> seq.count;		/* copy sequence length into automatic */
     1328 	     if auto_len = 0
     1329 	     then return;				/* no sequence */
     1330 
     1331 	     if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)	/* probably not a real sequence */
     1332 	     then go to table_error;
     1333 
     1334 	     target_len = target_len + auto_len;
     1335 	     if target_len > max_chars
     1336 	     then go to try_again;
     1337 
     1338 	     do i = 1 to auto_len;
     1339 		target_ptr -> based_chars (i - 1) = seqp -> seq.chars (i);
     1340 	     end;
     1341 
     1342 	     target_ptr = addr (target_ptr -> based_chars (auto_len));
     1343 						/* bump pointer */
     1344 	     return;
     1345 
     1346 	end /* insert_sequence_internal */;
     1347 
     1348      end /* insert_nl */;
     1349 
     1350 insert_cr:
     1351      proc;
     1352 
     1353 /* This procedure inserts a carriage return */
     1354 
     1355 	if col = 0
     1356 	then return;				/* no need */
     1357 
     1358 	seqp = addr (special_ptr -> special_chars.cr_seq);
     1359 	if seqp -> seq.count = 0
     1360 	then call insert_bs (col);			/* if cr not implemented, use backspaces */
     1361 
     1362 	else do;
     1363 	     call insert_sequence ("0"b);
     1364 	     if delay_ptr ^= null
     1365 	     then if delay_ptr -> delay.horz_nl ^= 0
     1366 		then call insert_delays (
     1367 			max (delay_ptr -> delay.horz_nl * col + max (0, delay_ptr -> delay.vert_nl), 1));
     1368 
     1369 	     col = 0;
     1370 	end;
     1371 
     1372 	return;
     1373 
     1374      end /* insert_cr */;
     1375 
     1376 insert_bs:
     1377      proc (how_many);
     1378 
     1379 /* This procedure inserts a specified number of backspaces in the output string */
     1380 
     1381 dcl  how_many fixed bin;
     1382 dcl  count fixed bin;
     1383 dcl  i fixed bin;
     1384 dcl  bs_char char (1);
     1385 dcl  new_col fixed bin;
     1386 
     1387 	count = min (how_many, col);
     1388 	if count <= 0
     1389 	then return;
     1390 
     1391 	seqp = addr (special_ptr -> special_chars.bs_seq);
     1392 	if seqp -> seq.count = 0			/* no backspace for this terminal */
     1393 	then do;
     1394 	     new_col = col - count;
     1395 	     seqp = addr (special_ptr -> special_chars.cr_seq);
     1396 						/* do carriage return, then forward space */
     1397 	     if seqp -> seq.count = 0
     1398 	     then return;				/* nothing to do here */
     1399 	     call insert_sequence ("0"b);
     1400 	     if delay_ptr ^= null
     1401 	     then if delay_ptr -> delay.horz_nl ^= 0
     1402 		then if delay_ptr -> delay.vert_nl >= 0
     1403 		     then call insert_delays (max (fixed (delay_ptr -> delay.horz_nl * float (col), 17, 0), 1));
     1404 
     1405 	     col = 0;
     1406 	     if new_col = 0
     1407 	     then return;				/* all done */
     1408 
     1409 	     if tcb.modes.tabm			/* use tabs if appropriate */
     1410 	     then do;
     1411 		do while (new_col - col >= 10);
     1412 		     call insert_tab;
     1413 		end;
     1414 
     1415 		if mod (new_col, 10) < mod (col, 10)	/* room for another */
     1416 		then call insert_tab;
     1417 	     end;
     1418 
     1419 	     do col = col by 1 while (col < new_col);
     1420 		call insert_char (space);		/* fill it up with spaces */
     1421 	     end;
     1422 
     1423 	     return;
     1424 	end;
     1425 
     1426 	if seqp -> seq.count > 1			/* not simply backspace */
     1427 	then do i = 1 to count;
     1428 	     call insert_sequence ("0"b);		/* we will have to handle the column position our self */
     1429 	     col = max (0, col - 1);			/* and we will do it here for a back space */
     1430 	end;
     1431 
     1432 	else do;					/* backspace itself, deal with delays */
     1433 	     if delay_ptr = null
     1434 	     then n_delays = 0;
     1435 	     else n_delays = delay_ptr -> delay.backspace;
     1436 
     1437 	     bs_char = seqp -> seq.chars (1);
     1438 
     1439 	     if n_delays > 0			/* normal delay timing */
     1440 	     then do i = 1 to count;
     1441 		call insert_delays (n_delays);
     1442 		call insert_char (bs_char);
     1443 	     end;
     1444 
     1445 	     else do;
     1446 		if n_delays < 0			/* this means timing for overstrike */
     1447 		then if -n_delays > count		/* so multiple backspaces can count instead of delays */
     1448 		     then call insert_delays (-n_delays - count);
     1449 
     1450 		target_len = target_len + count;
     1451 		if target_len > max_chars		/* we will blow the buffer */
     1452 		then go to try_again;
     1453 
     1454 		do i = 1 to count;
     1455 		     target_ptr -> based_chars (i - 1) = bs_char;
     1456 		end;
     1457 
     1458 		target_ptr = addr (target_ptr -> based_chars (count));
     1459 	     end;
     1460 
     1461 	     col = col - count;			/* we backed up */
     1462 	end;
     1463 
     1464 	return;
     1465 
     1466      end /* insert_bs */;
     1467 
     1468 insert_tab:
     1469      proc;
     1470 
     1471 /* this procedure inserts a horizontal tab */
     1472 
     1473 dcl  i fixed bin;
     1474 dcl  count fixed bin;
     1475 
     1476 	count = 10 - mod (col, 10);
     1477 
     1478 	if count = 1				/* no point putting in tab for one space */
     1479 	then call insert_char (space);
     1480 
     1481 	else do;
     1482 	     if tcb.modes.tabm & special_ptr -> special_chars.tab_seq.count > 0
     1483 						/* tabs are real */
     1484 	     then do;
     1485 		call insert_char (tab);
     1486 		if delay_ptr ^= null
     1487 		then do;
     1488 		     n_delays =
     1489 			delay_ptr -> delay.const_tab + fixed (delay_ptr -> delay.var_tab * float (count), 17, 0);
     1490 		     if n_delays > 0
     1491 		     then call insert_delays (n_delays);
     1492 		end;
     1493 	     end;
     1494 
     1495 	     else do;				/* must simulate with spaces */
     1496 		target_len = target_len + count;
     1497 		if target_len > max_chars
     1498 		then go to try_again;		/* we can't let this happen */
     1499 
     1500 		do i = 1 to count;
     1501 		     target_ptr -> based_chars (i - 1) = space;
     1502 		end;
     1503 
     1504 		target_ptr = addr (target_ptr -> based_chars (count));
     1505 	     end;
     1506 	end;
     1507 
     1508 	col = col + count;
     1509 	return;
     1510 
     1511      end /* insert_tab */;
     1512 
     1513 translation:
     1514      proc;
     1515 
     1516 /* This procedure does a character translation of the output buffer using a move and translate operation */
     1517 
     1518 	source_ptr, util.stringp = final_outp;		/* we'll start picking up where final stuff was left */
     1519 
     1520 	if final_outp = addr (buffer_1)		/* use the buffer not already occupied */
     1521 	then target_ptr = addr (buffer_2);
     1522 	else target_ptr = addr (buffer_1);
     1523 
     1524 	util.stringl = target_len;
     1525 	util.tablep = mvtp;
     1526 	mvt_args.targetp = target_ptr;
     1527 	call tty_util_$mvt (addr (util));		/* do the translation itself */
     1528 
     1529 	final_outp = target_ptr;			/* now */
     1530 
     1531 	if shifter (wtcb.line_type)			/* do we have to put in case shifts? */
     1532 	then do;
     1533 	     source_ptr, util.stringp = target_ptr;	/* we'll have to move again, probably */
     1534 	     xor = bool (rel (addr (buffer_1)), rel (addr (buffer_2)), "0110"b);
     1535 						/* use to switch buffers */
     1536 	     target_ptr, final_outp = ptr (target_ptr, bool (xor, rel (target_ptr), "0110"b));
     1537 
     1538 	     shift = "01"b;				/* new write chain starts in lower also */
     1539 
     1540 	     scm_args.search_mask = bool (shift, "11"b, "0110"b);
     1541 						/* look for opposite shift */
     1542 	     call tty_util_$scm (addr (util));
     1543 
     1544 	     if ^scm_args.found_flag			/* no shift changes at all */
     1545 	     then final_outp = source_ptr;		/* we won't move anything */
     1546 	     else do;
     1547 		target_len = 0;
     1548 		if ctally > 0			/* move characters to left of found shift */
     1549 		then call copy_chars;
     1550 
     1551 		do while (scm_args.found_flag);
     1552 		     if ctally = 0
     1553 		     then call insert_shift;
     1554 		     else do;
     1555 			i = -1;			/* necessary to fool compiler */
     1556 			if target_ptr -> based_chars (i) ^= prefix
     1557 			then call insert_shift;
     1558 
     1559 			else do;			/* previous char was prefix, mustn't shift */
     1560 			     call insert_char (source_ptr -> based_chars (0));
     1561 						/* put unshifted char in */
     1562 			     stringp, source_ptr = addr (source_ptr -> based_chars (1));
     1563 						/* skip over it */
     1564 			     stringl = stringl - 1;
     1565 			end;
     1566 		     end;
     1567 
     1568 		     call tty_util_$scm (addr (util));
     1569 		     if ctally > 0
     1570 		     then call copy_chars;		/* move any we scanned over */
     1571 		end;
     1572 
     1573 		if shift = "10"b			/* if we ended up in upper */
     1574 		then call insert_char (byte (lower_shift));
     1575 						/* change to lower */
     1576 		tcb.actshift = "01"b;
     1577 	     end;
     1578 	end;
     1579 
     1580 	return;
     1581 
     1582      end translation;				/* end of translation phase */
     1583 
     1584 insert_shift:
     1585      proc;
     1586 
     1587 /*  This procedure inserts the proper shift character into the stream for an IBM 2741 like shift device */
     1588 
     1589 	if shift = "01"b				/* we were in lower case */
     1590 	then call insert_char (byte (upper_shift));	/* put in upper shift */
     1591 	else call insert_char (byte (lower_shift));	/* or lower, as the case may be */
     1592 
     1593 	scm_args.search_mask = shift;			/* switch to look for other shift */
     1594 	shift = bool (shift, "11"b, "0110"b);
     1595 
     1596 	return;
     1597 
     1598      end insert_shift;
     1599 
     1600 convert_to_upper_case:
     1601      proc;
     1602 
     1603 /*
     1604*   This procedure takes a string from buffer 1 and sets up the necessary variables
     1605*   and the translates the stream into uper case characters in buffer 2 using the
     1606*   move and translate operation.  The characters may either be edited
     1607*   or not. (i.e. true upper case has an escape before it or not)
     1608**/
     1609 
     1610 
     1611 	target_ptr = addr (buffer_2);
     1612 	chars_moved = "0"b;
     1613 
     1614 	if tcb.modes.edited
     1615 	then cap_tab_ptr = addr (lower_to_caps_edited);
     1616 	else cap_tab_ptr = addr (lower_to_caps_nonedited);
     1617 
     1618 /* we'll have to be careful to step over characters greater than 177 */
     1619 
     1620 	cap_source_ptr, ic_stringp = source_ptr;
     1621 	cap_target_ptr = addr (buffer_1);
     1622 	ic_stringl = source_len;
     1623 	illegal_char_args.found_flag = "1"b;		/* so "while" will work at least once */
     1624 	scanned_len = 0;
     1625 
     1626 	do while (illegal_char_args.found_flag & ic_stringl > 0);
     1627 	     call tty_util_$illegal_char (addr (illegal_char_args));
     1628 						/* look for funny character */
     1629 
     1630 /* now just scan the string up to the character found (if any) */
     1631 
     1632 	     if illegal_char_args.ic_tally > 0		/* if there's a string to scan */
     1633 	     then do;
     1634 		util.stringp = cap_source_ptr;
     1635 		util.stringl = ic_tally;
     1636 		util.tablep = cap_tab_ptr;
     1637 
     1638 		mvt_args.targetp = cap_target_ptr;
     1639 		call tty_util_$mvt (addr (util));
     1640 
     1641 		if ^tcb.modes.edited
     1642 		then do;				/* in ^edited mode, must insert escapes */
     1643 		     source_ptr, util.stringp = cap_target_ptr;
     1644 		     scm_args.search_mask = "10"b;	/* look for chars with high-order bit on */
     1645 		     scm_args.found_flag = "1"b;	/* so "while" will work right */
     1646 
     1647 		     do while (scm_args.found_flag);
     1648 			call tty_util_$scm (addr (util));
     1649 			if scm_args.found_flag	/* found a capital */
     1650 			then do;
     1651 			     if ^chars_moved	/* first time we've had to move any */
     1652 			     then do;
     1653 				ctally = ctally + scanned_len;
     1654 						/* take the ones we skipped before */
     1655 				source_ptr = addr (buffer_1);
     1656 						/* have to pick up all chars so far */
     1657 			     end;
     1658 
     1659 			     if ctally > 0
     1660 			     then call copy_chars;	/* copy all chars left of it */
     1661 			     call insert_char (escape_char);
     1662 
     1663 			     source_len = source_len + 1;
     1664 						/* we've added a character to be scanned */
     1665 			     chars_moved = "1"b;
     1666 			     unspec (util.stringp -> based_onechar) =
     1667 				unspec (util.stringp -> based_onechar) & "011111111"b;
     1668 						/* turn off high-order bit */
     1669 			end;
     1670 
     1671 			else if chars_moved		/* we didn't find one, did we move any chars? */
     1672 			then call copy_chars;	/* move the rest */
     1673 
     1674 		     end;
     1675 		end;				/* through looking for caps */
     1676 	     end;
     1677 
     1678 	     if illegal_char_args.found_flag
     1679 	     then do;				/* if we've had to stop for high-order bits at all */
     1680 
     1681 		if chars_moved			/* we've had to copy for escapes */
     1682 		then call insert_char (cap_source_ptr -> based_chars (ic_tally));
     1683 						/* copy untouched funny char */
     1684 
     1685 		else cap_target_ptr -> based_chars (ic_tally) = cap_source_ptr -> based_chars (ic_tally);
     1686 
     1687 		scanned_len = scanned_len + ic_tally + 1;
     1688 
     1689 /* adjust pointers to start looking after it */
     1690 
     1691 		ic_stringp, cap_source_ptr = addr (cap_source_ptr -> based_chars (ic_tally + 1));
     1692 		cap_target_ptr = addr (cap_target_ptr -> based_chars (ic_tally + 1));
     1693 		ic_stringl = ic_stringl - 1;
     1694 	     end;
     1695 	end;
     1696 
     1697 	if chars_moved				/* have to adjust some pointers */
     1698 	then do;
     1699 	     source_ptr = addr (buffer_2);		/* chars are in buffer_2 now */
     1700 	     target_ptr = addr (buffer_1);
     1701 	end;
     1702 	else source_ptr = addr (buffer_1);		/* make sure this gets set */
     1703 
     1704 	return;
     1705 
     1706      end convert_to_upper_case;
     1707 
     1708 move_formated_chars:
     1709      proc;
     1710 
     1711 /*
     1712*   This procedure is called to move chars to a different
     1713*   buffer when some reformating is necessary due to the encountering of some
     1714*   special characters in the present buffer
     1715**/
     1716 
     1717 
     1718 	chars_moved = "1"b;				/* we'll have to do some moving */
     1719 
     1720 	if ctally > 0				/* we have some uninteresting ones to pick up */
     1721 	then do;
     1722 	     if white_sw
     1723 	     then call insert_white;			/* pick up any outstanding white space */
     1724 	     col = col + ctally;
     1725 	     if tcb.dont_count_next			/* first char doesn't count */
     1726 	     then do;
     1727 		col = col - 1;
     1728 		tcb.dont_count_next = "0"b;
     1729 	     end;
     1730 	     if ((tcb.colmax > 0) & (col > tcb.colmax))
     1731 	     then call wrap_lines;
     1732 	     else do;				/* wrap_lines would this for us */
     1733 		call copy_chars;
     1734 		wcol = col;
     1735 	     end;
     1736 	end;
     1737 
     1738 	else if tcb.dont_count_next			/* we're supposed to swallow first char whole */
     1739 	then do;
     1740 	     ctally = 1;				/* get it */
     1741 	     call copy_chars;
     1742 
     1743 	     if indicator = 3 | indicator = 7		/* we're still pointing at it */
     1744 	     then do;
     1745 		stringp = addr (stringp -> based_chars (1));
     1746 						/* bump pointer */
     1747 		stringl = stringl - 1;		/* decrement length */
     1748 	     end;
     1749 
     1750 	     indicator = NOT_INTERESTING;		/* don't do anything else about this char */
     1751 	end;
     1752 
     1753 /* now examine indicator */
     1754 
     1755 	if indicator = NOT_INTERESTING		/* no interesting characters */
     1756 	then if white_sw
     1757 	     then call insert_white;			/* add white space if necessary */
     1758 	     else ;				/* otherwise go around again */
     1759 
     1760 	else if indicator = NEW_LINE			/* new-line */
     1761 	then do;
     1762 	     white_sw = "0"b;			/* throw away any outstanding white space */
     1763 	     call insert_nl ("0"b);			/* put the nl in */
     1764 	end;
     1765 
     1766 	else if indicator = CARRIAGE_RETURN		/* carriage return */
     1767 	then do;
     1768 	     white_sw = "1"b;			/* we'll process this later as white space */
     1769 	     wcol = 0;				/* taking us to column zero */
     1770 	end;
     1771 
     1772 	else if indicator = TAB_MULTIPLE_SPACE		/* tab or multiple blanks */
     1773 	then call scan_white ("0"b);
     1774 
     1775 	else if indicator = BACK_SPACE		/* backspace */
     1776 	then do;
     1777 	     wcol = max (0, wcol - 1);		/* back up the "white" column */
     1778 	     call scan_white ("1"b);
     1779 
     1780 	end;
     1781 
     1782 	else if indicator = VERTICAL_TAB | indicator = FORM_FEED
     1783 						/* vertical tab or form-feed */
     1784 	then if tcb.modes.vertsp			/* if we're processing such */
     1785 	     then do;
     1786 		if indicator = VERTICAL_TAB		/* vertical tab */
     1787 		then do;
     1788 		     if tcb.linemax > 0		/* if we're counting lines */
     1789 		     then do;
     1790 			line_count = line_count + 10 - mod (line_count, 10);
     1791 						/* next vt stop */
     1792 			if line_count >= tcb.linemax	/* over to new page */
     1793 			then do;
     1794 			     seqp = addr (special_ptr -> special_chars.end_of_page);
     1795 			     call insert_sequence ("0"b);
     1796 						/* mark end-of-page if necessary */
     1797 			     call insert_char (eop_sentinel);
     1798 			     line_count = 0;
     1799 			end;
     1800 		     end;
     1801 		     seqp = addr (special_ptr -> special_chars.vt_seq);
     1802 		end;
     1803 
     1804 		else do;				/* else it is a form feed */
     1805 		     if tcb.linemax > 0
     1806 		     then do;			/* if we care about page length */
     1807 			seqp = addr (special_ptr -> special_chars.end_of_page);
     1808 			call insert_sequence ("0"b);
     1809 			call insert_char (eop_sentinel);
     1810 		     end;
     1811 		     line_count = 0;
     1812 		     seqp = addr (special_ptr -> special_chars.ff_seq);
     1813 		end;
     1814 
     1815 		call insert_sequence ("0"b);
     1816 		if delay_ptr ^= null
     1817 		then call insert_delays (delay_ptr -> delay.vt_ff);
     1818 
     1819 		col = 0;				/* implied new-line always */
     1820 		white_sw = "0"b;
     1821 	     end;
     1822 
     1823 	     else if ^tcb.modes.edited		/* we'll have to escape it */
     1824 	     then do;
     1825 		i = -1;				/* so compiler won't complain */
     1826 		stringp = addr (stringp -> based_chars (i));
     1827 						/* back up by one */
     1828 		stringl = stringl + 1;
     1829 		call octal_escape;
     1830 	     end;
     1831 	     else ;
     1832 
     1833 	else if indicator = OCTAL_ESCAPE		/* octal escape */
     1834 	then call octal_escape;
     1835 
     1836 	else if indicator = RED_SHIFT | indicator = BLACK_SHIFT
     1837 						/* ribbon shift */
     1838 	then if tcb.modes.redm			/* if this is interesting */
     1839 	     then do;
     1840 		if white_sw
     1841 		then call insert_white;		/* if video terminal this is noticable */
     1842 		if indicator = RED_SHIFT
     1843 		then seqp = addr (special_ptr -> special_chars.red_ribbon_shift);
     1844 		else seqp = addr (special_ptr -> special_chars.black_ribbon_shift);
     1845 
     1846 		call insert_sequence ("0"b);
     1847 	     end;
     1848 	     else ;
     1849 
     1850 	else if indicator = INSERT_NO_COUNT		/* insert without counting column position */
     1851 	then do;
     1852 	     if white_sw
     1853 	     then call insert_white;
     1854 	     ctally = 1;
     1855 	     call copy_chars;
     1856 	end;
     1857 
     1858 	else if indicator = INSERT_NO_COUNT_2		/* neither this char nor next one affects column position */
     1859 	then do;
     1860 	     if white_sw
     1861 	     then call insert_white;
     1862 	     ctally = min (stringl + 1, 2);		/* copy this one and next (if present) */
     1863 	     call copy_chars;
     1864 
     1865 	     if ctally = 2				/* get them both */
     1866 	     then do;
     1867 		stringp = addr (stringp -> based_chars (1));
     1868 						/* bump past escaped char */
     1869 		stringl = stringl - 1;
     1870 	     end;
     1871 
     1872 	     else tcb.dont_count_next = "1"b;		/* wasn't a next one, catch it next time */
     1873 	end;
     1874 
     1875 	else if indicator = SKIP			/* ignore this one entirely */
     1876 	then ;
     1877 
     1878 	else if indicator > SPECIAL_ESCAPE
     1879 	then do;					/* special escape sequence */
     1880 	     escape_index = indicator - 16;
     1881 	     if escape_index > special_ptr -> special_chars.escape_length
     1882 						/* not a good index */
     1883 	     then go to table_error;
     1884 
     1885 	     if white_sw
     1886 	     then call insert_white;
     1887 	     if tcb.modes.edited
     1888 	     then seqp = addr (special_ptr -> special_chars.edited_escapes (escape_index));
     1889 	     else seqp = addr (special_ptr -> special_chars.not_edited_escapes (escape_index));
     1890 
     1891 	     call insert_sequence ("1"b);
     1892 	end;
     1893 
     1894 	else go to table_error;			/* invalid indicator */
     1895 
     1896 	if stringl > 0				/* if we're going around again */
     1897 	then source_ptr = stringp;			/* update source pointer */
     1898 
     1899 	return;
     1900 
     1901      end move_formated_chars;
     1902 
     1903 wrap_lines:
     1904      proc;
     1905 
     1906 /*
     1907*   This procedure is called when the output line exceeds the maximum number
     1908*   of columns we think the device has
     1909**/
     1910 
     1911 	if tcb.colmax < 1
     1912 	then return;				/* we should not have come here */
     1913 	do while (col > tcb.colmax);			/* did we go over end of line? */
     1914 	     old_tally = ctally;
     1915 	     ctally = max (0, tcb.colmax - oldcol);	/* move first chunk */
     1916 	     if ctally > 0
     1917 	     then call copy_chars;
     1918 	     call insert_nl ("1"b);			/* insert new-line and continuation marker */
     1919 
     1920 	     ctally = old_tally - ctally;
     1921 	     oldcol = 2;
     1922 	     col = col + ctally;
     1923 	end;
     1924 
     1925 	if ctally > 0				/* any more chars to copy? */
     1926 	then call copy_chars;			/* do it */
     1927 	wcol = col;				/* further white space will start here */
     1928 
     1929 	return;
     1930 
     1931      end wrap_lines;
     1932 
     1933 
     1934 scan_white:
     1935      proc (advanced);
     1936 
     1937 /*
     1938*   This procedure is called when it is necessary to deside what to do with characters
     1939*   that only move the carriage's column position.  It then updates the appropriate
     1940*   pointers or white space counters
     1941**/
     1942 
     1943 dcl  advanced bit (1) parameter;			/* indicates whether pointer has been advanced over first white character */
     1944 dcl  done bit (1);
     1945 dcl  first_time bit (1);
     1946 
     1947 	done = "0"b;
     1948 	first_time = "1"b;
     1949 	white_sw = "1"b;
     1950 	do while (util.stringl > 0 & ^done);
     1951 	     if stringp -> based_onechar = backspace
     1952 	     then wcol = max (0, wcol - 1);
     1953 
     1954 	     else if stringp -> based_onechar = space
     1955 	     then wcol = wcol + 1;
     1956 
     1957 	     else if stringp -> based_onechar = tab
     1958 	     then wcol = wcol + 10 - mod (wcol, 10);	/* to next tab stop */
     1959 
     1960 	     else if stringp -> based_onechar = carriage_return
     1961 	     then wcol = 0;
     1962 
     1963 	     else done = "1"b;
     1964 
     1965 	     if ^done | (first_time & ^advanced)	/* in case first character wasn't really whitespace */
     1966 	     then do;				/* we want to advance pointer anyway */
     1967 		stringp = addr (stringp -> based_chars (1));
     1968 						/* bump stringp by one char */
     1969 		stringl = stringl - 1;
     1970 		first_time = "0"b;
     1971 	     end;
     1972 	end;
     1973 	return;
     1974 
     1975      end scan_white;
     1976 
     1977 octal_escape:
     1978      proc;
     1979 
     1980 /*
     1981*   This procedure is called when a character is encountered that is meaningless
     1982*   to the device, so it is printed in the form of escapeXXX (i.e. \014)
     1983**/
     1984 	if ^tcb.modes.edited
     1985 	then do;
     1986 	     if white_sw
     1987 	     then call insert_white;			/* insert any outstanding white space */
     1988 	     if ((tcb.colmax > 0) & (col >= tcb.colmax))	/* in case we went off end of line */
     1989 	     then call insert_nl ("1"b);
     1990 
     1991 	     call insert_char (escape_char);		/* put escape in */
     1992 	     col = col + 1;
     1993 
     1994 	     do i = 1 to 9 by 3;
     1995 		if ((tcb.colmax > 0) & (col >= tcb.colmax))
     1996 						/* if we go off end of line */
     1997 		then call insert_nl ("1"b);		/* put in nl and continuation marker */
     1998 
     1999 		call insert_char (num_array (fixed (substr (unspec (stringp -> based_onechar), i, 3), 3)));
     2000 		col = col + 1;
     2001 	     end;
     2002 	end;
     2003 
     2004 	stringp = addr (stringp -> based_chars (1));	/* bump over escaped character */
     2005 	stringl = stringl - 1;
     2006      end octal_escape;
     2007 
     2008 	end /* giant begin block */;
     2009 
     2010 all_done:
     2011 	a_nelemt = nelemt;				/* return number of chars processed */
     2012 
     2013 						/* Add for the Datanet 7100. */
     2014 	if uncp_flag then do;
     2015 	     if wtcb.send_turn
     2016 		then do;
     2017 		if ^wtcb.flags.wru			/* if not reading answerback  */
     2018 		     then if wtcb.receive_mode_device	/* must we tell multiplexer to turn line around? */
     2019 		     then do;
     2020 			call channel_manager$control (devx, "enter_receive", null, ercode);
     2021 						/* yes, do it */
     2022 			wtcb.send_turn = "0"b;
     2023 		     end;
     2024 		     else ;
     2025 		     else wtcb.flags.wru = "0"b;	/* won't be reading answerback again */
     2026 	     end;
     2027 	end;
     2028 
     2029 unlock:
     2030 	time_spent = clock () - start_time;
     2031 	tcb.cumulative_meters.write_time = tcb.cumulative_meters.write_time + time_spent;
     2032 	tty_buf.write_time = tty_buf.write_time + time_spent;
     2033 	if ^locked_entry
     2034 	then call tty_lock$unlock_channel (devx);	/* unlock channel lock if necessary */
     2035 
     2036 	return;
     2037 
     2038 nothing_written:
     2039 	if wtcb.send_output
     2040 	then call tty_space_man$needs_space (devx);	/* make sure space happens anyway */
     2041 	else wtcb.wflag = "1"b;
     2042 	ercode = 0;
     2043 	go to all_done;				/* exit */
     2044 
     2045 free_buffers:
     2046      proc;
     2047 
     2048 /* procedure to free any buffers we allocated but can't use */
     2049 
     2050 	if headp ^= null				/* we'd peeled off a page */
     2051 	then do;					/* Add for the Datanet 7100. */
     2052 	     if uncp_flag then wtcb.send_turn = lastp -> buffer.turn;
     2053 	     call tty_space_man$free_chain (devx, OUTPUT, headp);
     2054 	end;
     2055 	if new_head ^= 0
     2056 	then call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, new_head));
     2057 
     2058 	wtcb.end_frame = old_end_frame;
     2059 	wtcb.write_first = old_head;			/* back to how we were when we came in */
     2060 	wtcb.write_last = old_tail;
     2061 	if wtcb.write_last ^= 0
     2062 	then ptr (ttybp, wtcb.write_last) -> buffer.next = 0;
     2063 
     2064 	return;
     2065      end /* free_buffers */;
     2066 
     2067 
     2068 is_parent_mpx:					/* Check for match of channel's parent mpx type and input mpx type */
     2069      proc (parent_mpx_type) returns (bit (1));
     2070 
     2071 dcl parent_mpx_type fixed bin;
     2072 dcl temp_lctep ptr;
     2073      
     2074 	lctep = addr (lct.lcte_array (devx));
     2075 	if lcte.major_channel_devx ^= 0 then do;
     2076 	     temp_lctep = addr (lct.lcte_array (lcte.major_channel_devx));
     2077 	     if temp_lctep->lcte.channel_type = parent_mpx_type then return ("1"b);
     2078 	end;
     2079 	else if lcte.channel_type = parent_mpx_type then return ("1"b);
     2080 	return ("0"b);
     2081      end is_parent_mpx;
     2082 
     2083      end /* tty_write */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/16/90  1222.6  tty_write.pl1                     >spec>install>1024>tty_write.pl1
324          1    10/18/88  1310.6  tty_convert.incl.pl1              >ldd>include>tty_convert.incl.pl1
326          2    01/06/85  1522.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
2-152        3    01/06/85  1522.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
328          4    07/21/88  2136.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
329          5    07/21/88  2136.0  wtcb.incl.pl1                     >ldd>include>wtcb.incl.pl1
331          6    06/18/81  1000.8  tcb.incl.pl1                      >ldd>include>tcb.incl.pl1
333          7    11/08/82  1105.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
335          8    06/18/81  1000.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
337          9    05/06/80  1058.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
338         10    10/26/89  2111.9  multiplexer_types.incl.pl1        >ldd>include>multiplexer_types.incl.pl1
339         11    08/06/87  1013.5  net_event_message.incl.pl1        >ldd>include>net_event_message.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BACK_SPACE                             constant        fixed bin(17,0)          initial dcl 191 ref 1775
BLACK_SHIFT                            constant        fixed bin(17,0)          initial dcl 196 ref 1836
CARRIAGE_RETURN                        constant        fixed bin(17,0)          initial dcl 189 ref 1766
DIALED_UP                              constant        fixed bin(17,0)          initial dcl 204 ref 450 458
FORM_FEED                              constant        fixed bin(17,0)          initial dcl 193 ref 1782
HUNG_UP                                constant        fixed bin(17,0)          initial dcl 202 ref 456
INSERT_NO_COUNT                        constant        fixed bin(17,0)          initial dcl 197 ref 1850
INSERT_NO_COUNT_2                      constant        fixed bin(17,0)          initial dcl 198 ref 1858
LISTENING                              constant        fixed bin(17,0)          initial dcl 203 ref 452
LONGEST_POSSIBLE_STRING                constant        fixed bin(17,0)          initial dcl 266 ref 560 569
MASKED_STATE                           constant        fixed bin(17,0)          initial dcl 205 ref 454
MCS_NETWORK_TYPE                       constant        fixed bin(4,0)           initial unsigned dcl 11-34 ref 1000
MCS_WRITE_MSG                          constant        fixed bin(17,0)          initial dcl 11-60 ref 1002
NET_EVENT_MESSAGE_VERSION_1            constant        bit(2)                   initial packed unaligned dcl 11-20 ref 999
NEW_LINE                               constant        fixed bin(17,0)          initial dcl 188 ref 1760
NOT_INTERESTING                        constant        fixed bin(17,0)          initial dcl 187 ref 1750 1755
OCTAL_ESCAPE                           constant        fixed bin(17,0)          initial dcl 194 ref 1833
OUTPUT                          000114 constant        bit(1)                   initial packed unaligned dcl 8-21 set ref 757* 789*
                                                                                  817* 887* 946* 2053* 2055*
RED_SHIFT                              constant        fixed bin(17,0)          initial dcl 195 ref 1836 1842
SKIP                                   constant        fixed bin(17,0)          initial dcl 199 ref 1875
SPECIAL_ESCAPE                         constant        fixed bin(17,0)          initial dcl 200 ref 1878
TAB_MULTIPLE_SPACE                     constant        fixed bin(17,0)          initial dcl 190 ref 1772
TTY_MPX                                constant        fixed bin(17,0)          initial dcl 10-16 ref 434
UNCP_MPX                        000000 constant        fixed bin(17,0)          initial dcl 10-16 set ref 412*
VERTICAL_TAB                           constant        fixed bin(17,0)          initial dcl 192 ref 1782 1786
a_col_sw                               parameter       bit(1)                   dcl 1110 ref 1104 1115
a_mark_flag                            parameter       bit(1)                   packed unaligned dcl 70 ref 356 360
a_nelem                                parameter       fixed bin(21,0)          dcl 68 ref 35 347 382 390
a_nelemt                               parameter       fixed bin(21,0)          dcl 71 set ref 35 347 356 367 382 399* 2010*
a_offset                               parameter       fixed bin(21,0)          dcl 67 ref 35 347 382 394
a_readp                                parameter       pointer                  dcl 66 ref 35 347 382 392
a_state                                parameter       fixed bin(17,0)          dcl 72 set ref 35 347 356 367 382 400* 460* 465*
a_string                               parameter       char                     packed unaligned dcl 69 set ref 356 367 372 375
actcol                   15(18)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  set ref 599 978*
actline                  15(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  set ref 598 979*
actshift                 30(34)        based           bit(2)                   level 2 packed packed unaligned dcl 6-20 set ref
                                                                                  1576*
addr                                                   builtin function         dcl 319 ref 375 402 433 487 510 581 604 625 642 642
                                                                                  761 762 806 841 850 870 998 999 1000 1001 1002
                                                                                  1055 1057 1074 1098 1128 1153 1243 1258 1342 1358
                                                                                  1391 1395 1458 1504 1520 1520 1522 1526 1527 1527
                                                                                  1534 1534 1540 1542 1542 1544 1551 1562 1568 1568
                                                                                  1593 1611 1614 1616 1621 1627 1627 1638 1639 1639
                                                                                  1644 1645 1647 1648 1648 1649 1655 1691 1692 1699
                                                                                  1700 1702 1745 1794 1801 1807 1812 1826 1842 1844
                                                                                  1867 1887 1889 1967 2004 2074 2076
advanced                               parameter       bit(1)                   packed unaligned dcl 1943 ref 1934 1965
allocated_buffers               000307 automatic       bit(1)                   packed unaligned dcl 183 set ref 421* 424 426* 693*
ascii_escape_char                      based           char(1)                  packed unaligned dcl 211 ref 1128
ascii_escape_octal              000107 constant        bit(9)                   initial packed unaligned dcl 210 set ref 1128
auto_buf_len                    000306 automatic       fixed bin(17,0)          dcl 182 set ref 565* 566 577 578
auto_len                        000177 automatic       fixed bin(17,0)          dcl 1324 in procedure "insert_sequence_internal" set
                                                                                  ref 1327* 1328 1331 1331 1334 1338 1342
auto_len                        000144 automatic       fixed bin(17,0)          dcl 1113 in procedure "insert_sequence" set ref
                                                                                  1117* 1118 1121 1121 1124 1130
back_chars                      000211 automatic       fixed bin(17,0)          dcl 133 set ref 1181* 1182 1182 1189 1192*
backspace                 4            based           fixed bin(17,0)          level 2 in structure "delay" dcl 1-66 in procedure
                                                                                  "tty_write" set ref 1136* 1435
backspace                              constant        char(1)                  initial packed unaligned dcl 213 in procedure
                                                                                  "tty_write" ref 1133 1951
based_chars                            based           char(1)                  array packed unaligned dcl 298 set ref 581 714* 850
                                                                                  870 1055 1057 1074 1095* 1098 1153 1339* 1342
                                                                                  1455* 1458 1501* 1504 1556 1560* 1562 1681* 1685*
                                                                                  1685 1691 1692 1745 1826 1867 1967 2004
based_onechar                          based           char(1)                  packed unaligned dcl 297 set ref 1073* 1152* 1666*
                                                                                  1666 1951 1954 1957 1960 1999
based_target_chars                     based           char                     packed unaligned dcl 1232 ref 1268
bin                                                    builtin function         dcl 319 ref 765 781 820 893 955 963
black_ribbon_shift       44            based           structure                level 2 dcl 1-26 set ref 1844
bleft                     3            based           fixed bin(18,0)          level 2 dcl 2-35 ref 528 545
block_acknowledge        30(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 722 734
                                                                                  876
blockp                          000324 automatic       pointer                  dcl 4-19 set ref 494* 495 535* 538 540 542* 542 909*
                                                                                  911 911 913* 913 916 956* 957 959* 959 962 963
bool                                                   builtin function         dcl 319 ref 1534 1536 1540 1594
break                     0(20)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref
                                                                                  846* 901*
break_flag                      000206 automatic       bit(1)                   dcl 130 set ref 705* 711* 865
break_length                    000205 automatic       fixed bin(17,0)          dcl 129 set ref 701* 703 707* 712 716* 722* 722 726
                                                                                  728 745 808 812 842 852* 852 856
bs_char                         000220 automatic       char(1)                  packed unaligned dcl 1384 set ref 1437* 1442* 1455
bs_seq                   10            based           structure                level 2 dcl 1-26 set ref 1391
buf_size                        000234 automatic       fixed bin(17,0)          dcl 148 set ref 741* 744 750* 750 754 757*
buffer                                 based           structure                level 1 dcl 4-28
buffer_1                        000100 automatic       char                     dcl 577 set ref 604 1520 1522 1534 1621 1655 1700
                                                                                  1702
buffer_2                        000100 automatic       char                     dcl 578 set ref 1520 1534 1611 1699
buffer_pad               20(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  ref 550 744 802 812 821
bufp                            000230 automatic       pointer                  dcl 146 set ref 806* 841* 848
byte                                                   builtin function         dcl 319 ref 506 714 1095 1252 1252 1573 1573 1589
                                                                                  1589 1591 1591
c_chars                                based           structure                level 1 dcl 1-54
c_chars_ptr                     000320 automatic       pointer                  dcl 1-53 set ref 1116* 1121 1326* 1331
cap_source_ptr                  000150 automatic       pointer                  dcl 107 set ref 1620* 1634 1681 1685 1691 1691*
cap_tab_ptr                     000154 automatic       pointer                  dcl 109 set ref 1614* 1616* 1636
cap_target_ptr                  000152 automatic       pointer                  dcl 108 set ref 1621* 1638 1643 1685 1692* 1692
carriage_return                        constant        char(1)                  initial packed unaligned dcl 218 ref 1960
channel_manager$control         000066 constant        entry                    external dcl 9-13 ref 2020
channel_manager$write           000064 constant        entry                    external dcl 9-10 ref 933
channel_type              2            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 7-20 ref 434
                                                                                  2077 2079
chars                     0(09)        based           char(1)                  array level 2 in structure "seq" packed packed
                                                                                  unaligned dcl 304 in procedure "tty_write" ref
                                                                                  1128 1133 1140 1152 1339 1437
chars                    26(09)        based           char(3)                  level 3 in structure "tcb" packed packed unaligned
                                                                                  dcl 6-20 in procedure "tty_write" ref 881 892
chars                     0(09)        based           char(1)                  array level 2 in structure "c_chars" packed packed
                                                                                  unaligned dcl 1-54 in procedure "tty_write" ref
                                                                                  1121 1331
chars                     1            based           char(1)                  array level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 4-28 in procedure "tty_write" set
                                                                                  ref 761 762 806 841 881* 892*
chars_in_buf                    000251 automatic       fixed bin(17,0)          dcl 157 set ref 744* 745 745 802* 808 821* 842 878
chars_moved                     000164 automatic       bit(1)                   packed unaligned dcl 114 set ref 616* 1612* 1651
                                                                                  1665* 1671 1681 1697 1718*
chars_to_copy                          based           char                     packed unaligned dcl 302 set ref 763* 763 848* 848
cleanup                         000312 stack reference condition                dcl 322 ref 422
clock                                                  builtin function         dcl 319 ref 396 2029
col                             000167 automatic       fixed bin(17,0)          dcl 117 set ref 599* 617 641 647 978 1135* 1135 1146
                                                                                  1148* 1148 1166 1175 1181 1195 1197 1201 1205
                                                                                  1209* 1209 1209* 1279 1307* 1310* 1355 1359* 1364
                                                                                  1364 1369* 1387 1394 1400 1400 1405* 1411 1415
                                                                                  1419* 1419 1419* 1429* 1429 1461* 1461 1476 1508*
                                                                                  1508 1724* 1724 1727* 1727 1730 1734 1819* 1913
                                                                                  1922* 1922 1927 1988 1992* 1992 1995 2000* 2000
col_sw                          000142 automatic       bit(1)                   dcl 1111 set ref 1115* 1128* 1131
colmax                   21            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-20 ref 1146
                                                                                  1146 1168 1168 1172 1730 1730 1911 1913 1915 1988
                                                                                  1988 1995 1995
const_tab                 2            based           fixed bin(17,0)          level 2 dcl 1-66 ref 1488
cont_char                       000101 constant        char(1)                  initial packed unaligned dcl 227 set ref 1306*
count                     4            based           fixed bin(8,0)           level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 1-26 in procedure "tty_write" set
                                                                                  ref 1179
count                    10            based           fixed bin(8,0)           level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 1-26 in procedure "tty_write" set
                                                                                  ref 1189
count                           000235 automatic       fixed bin(17,0)          dcl 1474 in procedure "insert_tab" set ref 1476*
                                                                                  1478 1488 1496 1500 1504 1508
count                                  based           fixed bin(8,0)           level 2 in structure "seq" packed packed unaligned
                                                                                  dcl 304 in procedure "tty_write" ref 626 1117 1244
                                                                                  1327 1359 1392 1397 1426
count                           000216 automatic       fixed bin(17,0)          dcl 1382 in procedure "insert_bs" set ref 1387* 1388
                                                                                  1394 1426 1439 1446 1446 1450 1454 1458 1461
count                    14            based           fixed bin(8,0)           level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 1-26 in procedure "tty_write" ref
                                                                                  1482
cr_seq                    4            based           structure                level 2 dcl 1-26 set ref 1358 1395
ctally                    3     000262 automatic       fixed bin(17,0)          level 2 dcl 166 set ref 1049 1053 1053 1055 1057
                                                                                  1548 1552 1569 1653* 1653 1659 1720 1724 1740*
                                                                                  1854* 1862* 1865 1914 1915* 1916 1920* 1920 1922
                                                                                  1925
cumulative_meters        32            based           structure                level 2 dcl 6-20
cur_chain_len                   000256 automatic       fixed bin(17,0)          dcl 162 set ref 532* 539* 539 545
cur_space                       000255 automatic       fixed bin(17,0)          dcl 161 set ref 531* 538* 538 545
cv_trans                               based           structure                level 1 dcl 1-62
data_base_ptr             1            based           pointer                  level 2 packed packed unaligned dcl 7-20 ref 441
delay                                  based           structure                level 1 dcl 1-66
delay_before                    000162 automatic       bit(1)                   dcl 1228 set ref 1274* 1278* 1285 1291
delay_char                             constant        fixed bin(17,0)          initial dcl 229 ref 714 1095 1252 1252
delay_ptr                       000124 automatic       pointer                  dcl 94 set ref 520* 522* 1136 1136 1261 1263 1264
                                                                                  1364 1364 1364 1364 1364 1364 1400 1400 1400 1400
                                                                                  1400 1433 1435 1486 1488 1488 1816 1816
delayrp                  12(18)        based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 520 522
devx                            000101 automatic       fixed bin(17,0)          dcl 79 set ref 404* 406 406 416* 429* 433 757* 789*
                                                                                  817* 887* 933* 946* 1001 2020* 2033* 2038* 2053*
                                                                                  2055* 2074
dialed                   13(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 450
divide                                                 builtin function         dcl 319 ref 545 812 1029 1184
done                            000304 automatic       bit(1)                   packed unaligned dcl 1944 set ref 1947* 1950 1963*
                                                                                  1965
dont_count_next          30(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 set ref
                                                                                  1725 1728* 1738 1872*
edited                   17            based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 1614
                                                                                  1641 1823 1887 1984
edited_escapes                         based           structure                array level 2 dcl 1-26 set ref 1887
end_chain                       000257 automatic       bit(1)                   packed unaligned dcl 163 set ref 536* 537 540*
end_frame                13(05)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 675
                                                                                  931* 2058*
end_of_page               0(18)        based           bit(1)                   level 3 in structure "buffer" packed packed
                                                                                  unaligned dcl 4-28 in procedure "tty_write" set
                                                                                  ref 734 867* 911 931
end_of_page              50            based           structure                level 2 in structure "special_chars" dcl 1-26
                                                                                  in procedure "tty_write" set ref 625 1243 1794
                                                                                  1807
eop_sentinel                    000310 automatic       char(1)                  packed unaligned dcl 226 set ref 506* 629* 701 1254*
                                                                                  1299* 1797* 1809*
eop_sentinel_octal                     constant        fixed bin(9,0)           initial unsigned dcl 224 ref 506
eop_seqp                        000164 automatic       pointer                  dcl 1230 set ref 1235* 1243* 1244 1244* 1250 1297
eop_sw                          000163 automatic       bit(1)                   dcl 1229 set ref 1234* 1240* 1241 1250 1295
ercode                                 parameter       fixed bin(35,0)          dcl 73 set ref 35 347 356 367 382 401* 408* 416* 417
                                                                                  436* 469* 475* 482* 502* 571* 933* 934 941 1038*
                                                                                  2020* 2042*
error_code               24            based           fixed bin(35,0)          level 2 dcl 5-22 set ref 473 475 476*
error_table_$bad_arg            000044 external static fixed bin(35,0)          dcl 314 ref 482
error_table_$bigarg             000046 external static fixed bin(35,0)          dcl 315 ref 571
error_table_$improper_data_format
                                000032 external static fixed bin(35,0)          dcl 309 ref 1038
error_table_$invalid_device     000034 external static fixed bin(35,0)          dcl 310 ref 408
error_table_$io_no_permission   000036 external static fixed bin(35,0)          dcl 311 ref 436
error_table_$line_status_pending
                                000040 external static fixed bin(35,0)          dcl 312 ref 469
error_table_$noalloc            000042 external static fixed bin(35,0)          dcl 313 ref 934
esc_sw                                 parameter       bit(1)                   dcl 1227 ref 1221 1303
escape_char                     000106 constant        char(1)                  initial packed unaligned dcl 212 set ref 1305* 1661*
                                                                                  1991*
escape_index                    000216 automatic       fixed bin(17,0)          dcl 138 set ref 1880* 1881 1887 1889
escape_length            54            based           fixed bin(17,0)          level 2 dcl 1-26 ref 1881 1887
event                     2            based           fixed bin(71,0)          level 2 dcl 5-22 set ref 1003*
ff_seq                   24            based           structure                level 2 dcl 1-26 set ref 1812
final_outp                      000134 automatic       pointer                  dcl 99 set ref 588* 602* 619* 701 714 848 850* 850
                                                                                  870* 870 1268 1518 1520 1529* 1536* 1544*
first_buffer                    000240 automatic       bit(1)                   packed unaligned dcl 152 set ref 674* 793 823 826*
first_time                      000305 automatic       bit(1)                   packed unaligned dcl 1945 set ref 1948* 1965 1970*
fixed                                                  builtin function         dcl 319 ref 595 1279 1400 1400 1488 1999
flags                    13            based           structure                level 2 in structure "wtcb" packed packed unaligned
                                                                                  dcl 5-22 in procedure "tty_write"
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 4-28 in procedure "tty_write" set
                                                                                  ref 838* 890*
flags                    30            based           structure                level 2 in structure "tcb" packed packed unaligned
                                                                                  dcl 6-20 in procedure "tty_write"
float                                                  builtin function         dcl 319 ref 1279 1400 1400 1488
forcesw                         000110 automatic       bit(1)                   packed unaligned dcl 86 set ref 342* 359* 370* 387*
                                                                                  528
forward_chars                   000212 automatic       fixed bin(17,0)          dcl 134 set ref 1182* 1184* 1187* 1189
found_flag                5     000274 automatic       bit(1)                   level 2 in structure "illegal_char_args" dcl 174
                                                                                  in procedure "tty_write" set ref 1623* 1626 1678
found_flag                5            based           bit(1)                   level 2 in structure "scm_args" dcl 290 in procedure
                                                                                  "tty_write" set ref 1544 1551 1645* 1647 1649
handle                    1            based           fixed bin(35,0)          level 2 dcl 11-22 set ref 1001*
hbound                                                 builtin function         dcl 319 ref 1121 1331
hc_fast_lock                           based           structure                level 1 dcl 3-10
headp                           000220 automatic       pointer                  dcl 140 set ref 691* 925* 933* 953 955 956 2050
                                                                                  2053*
horiz                           000213 automatic       float bin(27)            dcl 135 set ref 1263* 1279
horz_nl                   1            based           float bin(27)            level 2 dcl 1-66 ref 1263 1364 1364 1364 1400 1400
                                                                                  1400
how_many                               parameter       fixed bin(17,0)          dcl 1381 ref 1376 1387
hproc                    10            based           bit(36)                  level 2 dcl 5-22 ref 446 460
i                               000176 automatic       fixed bin(17,0)          dcl 122 in procedure "tty_write" set ref 985* 986
                                                                                  986 989 1555* 1556 1825* 1826 1994* 1999*
i                               000234 automatic       fixed bin(17,0)          dcl 1473 in procedure "insert_tab" set ref 1500*
                                                                                  1501*
i                               000176 automatic       fixed bin(17,0)          dcl 1323 in procedure "insert_sequence_internal" set
                                                                                  ref 1338* 1339 1339*
i                               000132 automatic       fixed bin(17,0)          dcl 1085 in procedure "insert_delays" set ref 1094*
                                                                                  1095*
i                               000217 automatic       fixed bin(17,0)          dcl 1383 in procedure "insert_bs" set ref 1426*
                                                                                  1439* 1454* 1455*
i                               000143 automatic       fixed bin(17,0)          dcl 1112 in procedure "insert_sequence" set ref
                                                                                  1130* 1133 1140 1152*
ic_stringl                2     000274 automatic       fixed bin(17,0)          level 2 dcl 174 set ref 1622* 1626 1693* 1693
ic_stringp                      000274 automatic       pointer                  level 2 dcl 174 set ref 1620* 1691*
ic_tally                  3     000274 automatic       fixed bin(17,0)          level 2 dcl 174 set ref 1632 1635 1681 1685 1685
                                                                                  1687 1691 1692
illegal_char_args               000274 automatic       structure                level 1 dcl 174 set ref 1627 1627
in                       30            based           structure                array level 4 in structure "lct" dcl 7-11
                                                                                  in procedure "tty_write"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 7-68
                                                                                  in procedure "tty_write"
in                       10            based           structure                level 3 in structure "lcte" dcl 7-20 in procedure
                                                                                  "tty_write"
index                                                  builtin function         dcl 319 ref 701 1268
indicator                 6     000262 automatic       fixed bin(17,0)          level 2 dcl 166 set ref 1743 1743 1750* 1755 1760
                                                                                  1766 1772 1775 1782 1782 1786 1833 1836 1836 1842
                                                                                  1850 1858 1875 1878 1880
input_ptr                       000132 automatic       pointer                  dcl 98 set ref 580* 581* 581 588 602
lastp                           000226 automatic       pointer                  dcl 144 set ref 684* 734 734 737 741 760 761 764 769
                                                                                  776 781 789* 791* 795 806 807 831 837* 838 841 845
                                                                                  846 858 867 878 881 881 883 883 893 894* 901 902
                                                                                  916* 919* 921 924 926 930 931 2052
lchar                           000252 automatic       fixed bin(17,0)          dcl 158 set ref 737* 745 806 808 830*
lct                                    based           structure                level 1 dcl 7-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 405
lcte                                   based           structure                level 1 dcl 7-20
lcte_array               20            based           structure                array level 2 dcl 7-11 set ref 433 2074 2076
lctep                           000334 automatic       pointer                  dcl 7-8 set ref 433* 434 441 2074* 2075 2076 2079
lctp                            000332 automatic       pointer                  dcl 7-7 set ref 405* 406 433 2074 2076
length                                                 builtin function         dcl 319 ref 372
line_count                      000166 automatic       fixed bin(17,0)          dcl 116 set ref 598* 623 630* 979 1239* 1239 1240
                                                                                  1246* 1790* 1790 1790 1792 1798* 1811*
line_status_present      13(17)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 467
line_type                12(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  ref 1531
linemax                  21(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-20 ref 621 623
                                                                                  1237 1240 1788 1792 1805
listen                   13            based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 452
ll                              000215 automatic       fixed bin(17,0)          dcl 137 set ref 1268* 1270 1270* 1272
locked_entry                    000107 automatic       bit(1)                   packed unaligned dcl 85 set ref 341* 350* 359* 370*
                                                                                  385* 414 429 2033
lower_shift                            constant        fixed bin(17,0)          initial dcl 232 ref 1573 1573 1591 1591
lower_to_caps_edited            000041 constant        bit(9)                   initial array packed unaligned dcl 235 set ref 1614
lower_to_caps_nonedited         000001 constant        bit(9)                   initial array packed unaligned dcl 248 set ref 1616
major_channel_devx        3            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 7-20 ref 2075
                                                                                  2076
major_channel_info        3            based           structure                level 2 dcl 7-20
mark                      0(21)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref
                                                                                  902* 921
mark_entry                      000111 automatic       bit(1)                   packed unaligned dcl 87 set ref 360* 371* 393* 902
                                                                                  921 967
mark_set                 13(25)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref
                                                                                  921* 948* 967*
masked                   13(26)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 454
max                                                    builtin function         dcl 319 ref 812 1135 1272 1364 1364 1364 1364 1400
                                                                                  1400 1429 1777 1915 1951
max_buf_size             20            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  ref 545 550 812
max_chain_len                          constant        fixed bin(17,0)          initial dcl 207 ref 545
max_chars                       000127 automatic       fixed bin(17,0)          dcl 96 set ref 560* 565 566* 567 589 595 1050 1070
                                                                                  1091 1125 1335 1451 1497
max_chars_in_buf                000130 automatic       fixed bin(17,0)          dcl 97 set ref 550* 734 745
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 7-11 ref 406
max_output_block         23(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-20
                                                                                  ref 722 722 734 876
max_space                       000126 automatic       fixed bin(17,0)          dcl 95 set ref 528* 545* 552 560
meters                    6            based           structure                level 2 in structure "lcte" dcl 7-20 in procedure
                                                                                  "tty_write"
meters                   26            based           structure                array level 3 in structure "lct" dcl 7-11
                                                                                  in procedure "tty_write"
min                                                    builtin function         dcl 319 ref 545 560 565 589 595 722 808 812 842 1387
                                                                                  1862
minbuf                   16            based           fixed bin(18,0)          level 2 dcl 2-35 set ref 986 986 986*
mod                                                    builtin function         dcl 319 ref 1184 1205 1205 1415 1415 1476 1790 1957
modes                    17            based           structure                level 2 packed packed unaligned dcl 6-20
mvt_args                               based           structure                level 1 dcl 283
mvtp                            000120 automatic       pointer                  dcl 92 set ref 514* 516* 662 1525
n_delays                        000210 automatic       fixed bin(17,0)          dcl 132 set ref 1272* 1279* 1283* 1285 1285* 1291
                                                                                  1291* 1433* 1435* 1439 1441* 1446 1446 1446 1488*
                                                                                  1490 1490*
n_pages                         000224 automatic       fixed bin(17,0)          dcl 143 set ref 690* 696* 696 907
nblocked                 15            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 990* 990
nchars                          000254 automatic       fixed bin(17,0)          dcl 160 set ref 760* 763 763 808* 842* 845 848 848
                                                                                  850 851 852
ndelays                                parameter       fixed bin(17,0)          dcl 1084 ref 1079 1087 1090 1094 1098
nelem                           000105 automatic       fixed bin(21,0)          dcl 82 set ref 372* 390* 480 490 503 565 567 569 589
                                                                                  595 652 899 983 985
nelemt                          000106 automatic       fixed bin(21,0)          dcl 83 set ref 398* 556* 583* 589 589* 591 595 595*
                                                                                  603 652 899 936* 983 985 1009 1012 1023* 1029*
                                                                                  1029 1030 2010
net_event_message                      based           structure                level 1 dcl 11-22 set ref 998*
net_event_message_arg           000336 automatic       fixed bin(71,0)          dcl 11-19 set ref 998 999 1000 1001 1002 1003*
network_type              0(24)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 11-22
                                                                                  set ref 1000*
new_buf                         000250 automatic       fixed bin(17,0)          dcl 156 set ref 820* 825 831 833 835
new_buffer_count                000237 automatic       fixed bin(17,0)          dcl 151 set ref 670* 829* 829
new_bufp                        000246 automatic       pointer                  dcl 155 set ref 757* 758 762 764 765 769 791 817*
                                                                                  818 820 837 887* 888 890 891 892 893 894
new_char_count                  000201 automatic       fixed bin(17,0)          dcl 125 set ref 670* 851* 851 1014
new_col                         000221 automatic       fixed bin(17,0)          dcl 1385 set ref 1394* 1406 1411 1415 1419
new_head                        000223 automatic       fixed bin(17,0)          dcl 142 set ref 692* 825* 924* 962 2055 2055 2055
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-28
                                                                                  set ref 540 542 781 781 784 785* 831* 893* 911 913
                                                                                  924 926 930* 957 959 962* 2061*
nl                                     constant        char(1)                  initial packed unaligned dcl 219 ref 1268
nl_seq                                 based           structure                level 2 dcl 1-26 set ref 1258
not_edited_escapes       55            based           structure                array level 2 dcl 1-26 set ref 1889
noutchars                13            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 1012* 1012
nrawwrite                11            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 1014* 1014
null                                                   builtin function         dcl 319 ref 511 514 517 520 612 612 662 691 758 818
                                                                                  888 953 1136 1235 1244 1250 1261 1364 1400 1433
                                                                                  1486 1816 2020 2020 2050
null_for_eop                    000207 automatic       bit(1)                   packed unaligned dcl 131 set ref 717* 719* 868
num_array                       000102 constant        char(1)                  initial array packed unaligned dcl 222 set ref 1999*
offset                          000104 automatic       fixed bin(21,0)          dcl 81 set ref 374* 394* 581
oflow                    17(25)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 722 734
                                                                                  876
old_char_count                  000253 automatic       fixed bin(17,0)          dcl 159 set ref 807* 840* 845
old_end_frame                   000204 automatic       bit(1)                   packed unaligned dcl 128 set ref 675* 2058
old_head                        000202 automatic       fixed bin(18,0)          dcl 126 set ref 680* 686* 797* 2059
old_lastp                       000242 automatic       pointer                  dcl 153 set ref 684* 795*
old_tail                        000203 automatic       fixed bin(18,0)          dcl 127 set ref 680* 687* 796* 2060
old_tally                       000172 automatic       fixed bin(17,0)          dcl 120 set ref 1914* 1920
oldcol                          000171 automatic       fixed bin(17,0)          dcl 119 set ref 641* 1171* 1215* 1915 1921*
one_char                               parameter       char(1)                  packed unaligned dcl 1067 ref 1062 1073
orig_buf_size                   000235 automatic       fixed bin(17,0)          dcl 149 set ref 741* 754 802
output_bpart                           constant        fixed bin(18,0)          initial dcl 2-19 ref 545
output_buffer_overflow
                         23            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 1019* 1019
output_chars                           based           char                     packed unaligned dcl 300 ref 701
output_length                   000136 automatic       fixed bin(21,0)          dcl 100 set ref 591* 665* 672 695 701 707 726* 726
                                                                                  872* 872
output_mvtrp             10(18)        based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 514 516
output_restart           22            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 1027* 1027
output_suspend_etb_seq
                         26            based           structure                level 2 packed packed unaligned dcl 6-20
output_tctrp             11(18)        based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 511 513
parent_mpx_type                        parameter       fixed bin(17,0)          dcl 2071 ref 2068 2077 2079
pds$processid                   000050 external static bit(36)                  packed unaligned dcl 316 ref 446 446 460
prefix                          006476 constant        char(1)                  initial packed unaligned dcl 263 ref 1556
prevp                           000232 automatic       pointer                  dcl 147 set ref 774* 776 781* 781 781 781* 784 785
prompt                   22(09)        based           char(3)                  level 2 packed packed unaligned dcl 5-22 set ref 487
ptr                                                    builtin function         dcl 319 ref 494 513 516 519 522 535 542 684 774 784
                                                                                  909 913 919 925 946 946 959 1536 2055 2055 2061
pxss$ring_0_wakeup              000010 constant        entry                    external dcl 270 ref 1003
rank                                                   builtin function         dcl 319 ref 1140
rawom                    17(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 508 585
                                                                                  698 976
reached_needed                  000236 automatic       bit(1)                   packed unaligned dcl 150 set ref 742* 743 745*
readp                           000102 automatic       pointer                  dcl 80 set ref 375* 392* 487 580
receive_mode_device      13(24)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 2017
red_ribbon_shift         40            based           structure                level 2 dcl 1-26 set ref 1842
redm                     17(07)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 1836
reduction_factor                000110 constant        float bin(27)            initial dcl 208 ref 595
rel                                                    builtin function         dcl 319 ref 765 781 820 893 955 963 1534 1534 1536
reverse                                                builtin function         dcl 319 ref 1268
scanned_len                     000156 automatic       fixed bin(17,0)          dcl 110 set ref 1624* 1653 1687* 1687
scm_args                               based           structure                level 1 dcl 290
search_mask               4            based           bit(2)                   level 2 dcl 290 set ref 1540* 1593* 1644*
send                            000222 automatic       bit(1)                   packed unaligned dcl 141 set ref 679* 685* 905
send_output              13(02)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 905
                                                                                  971* 996 2038
send_turn                23(10)        based           bit(1)                   level 2 packed packed unaligned dcl 5-22 set ref
                                                                                  489* 496* 858 859* 2015 2022* 2052*
seq                                    based           structure                level 1 dcl 304
seqp                            000166 automatic       pointer                  dcl 1231 in procedure "insert_nl" set ref 1258*
                                                                                  1297* 1326 1327 1339
seqp                            000174 automatic       pointer                  dcl 121 in procedure "tty_write" set ref 625* 626
                                                                                  1116 1117 1128 1133 1140 1152 1358* 1359 1391*
                                                                                  1392 1395* 1397 1426 1437 1794* 1801* 1807* 1812*
                                                                                  1842* 1844* 1887* 1889*
shift                           000200 automatic       bit(2)                   packed unaligned dcl 124 set ref 1538* 1540 1573
                                                                                  1589 1593 1594* 1594
shifter                                constant        bit(1)                   initial array packed unaligned dcl 228 ref 1531
size_code                 0(24)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 4-28
                                                                                  ref 538 741
source_len                      000142 automatic       fixed bin(17,0)          dcl 103 set ref 603* 637 660 1622 1663* 1663
source_ptr                      000140 automatic       pointer                  dcl 102 set ref 602* 636 761* 763 1053 1055* 1055
                                                                                  1518* 1533* 1544 1560 1562 1562* 1620 1643* 1655*
                                                                                  1699* 1702* 1896*
space                           000105 constant        char(1)                  initial packed unaligned dcl 215 set ref 1210* 1420*
                                                                                  1478* 1501 1954
special_chars                          based           structure                level 1 dcl 1-26
special_ptr                     000122 automatic       pointer                  dcl 93 set ref 517* 519* 612 625 1179 1189 1243 1258
                                                                                  1358 1391 1395 1482 1794 1801 1807 1812 1842 1844
                                                                                  1881 1887 1889
specialrp                12            based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 517 519
start_time                      000162 automatic       fixed bin(71,0)          dcl 113 set ref 396* 2029
state                           000100 automatic       fixed bin(17,0)          dcl 78 set ref 450* 452* 454* 456* 458 460 465
string                                                 builtin function         dcl 319 set ref 838* 890*
stringl                   2     000262 automatic       fixed bin(17,0)          level 2 dcl 166 set ref 637* 639 1524* 1564* 1564
                                                                                  1635* 1747* 1747 1828* 1828 1862 1869* 1869 1896
                                                                                  1950 1969* 1969 2005* 2005
stringp                         000262 automatic       pointer                  level 2 dcl 166 set ref 636* 1518* 1533* 1562* 1634*
                                                                                  1643* 1666 1666 1745* 1745 1826* 1826 1867* 1867
                                                                                  1896 1951 1954 1957 1960 1967* 1967 1999 2004*
                                                                                  2004
substr                                                 builtin function         dcl 319 ref 881 892 1999
tab                             000104 constant        char(1)                  initial packed unaligned dcl 216 set ref 1485* 1957
tab_seq                  14            based           structure                level 2 dcl 1-26
tablep                    4     000262 automatic       pointer                  level 2 dcl 166 set ref 635* 1525* 1636*
tables                   10            based           structure                level 2 dcl 6-20
tabm                     17(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 1184
                                                                                  1199 1409 1482
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 4-28
                                                                                  set ref 734 737 760 764* 764 807 845* 878 881 883*
                                                                                  883 891*
tally_chars                            based           char                     packed unaligned dcl 301 set ref 1053* 1053
target_len                      000146 automatic       fixed bin(17,0)          dcl 105 set ref 605* 615* 655 660* 665 1049* 1049
                                                                                  1050 1069* 1069 1070 1090* 1090 1091 1124* 1124
                                                                                  1125 1252 1268 1270 1334* 1334 1335 1450* 1450
                                                                                  1451 1496* 1496 1497 1524 1547*
target_ptr                      000144 automatic       pointer                  dcl 104 set ref 604* 619 762* 763 1053 1057* 1057
                                                                                  1073 1074* 1074 1095 1098* 1098 1152 1153* 1153
                                                                                  1339 1342* 1342 1455 1458* 1458 1501 1504* 1504
                                                                                  1520* 1522* 1526 1529 1533 1536 1536 1536* 1556
                                                                                  1611* 1700*
targetp                   6            based           pointer                  level 2 dcl 283 set ref 1526* 1638*
tcb                                    based           structure                level 1 dcl 6-20
tcb_initialized          13(11)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 443
tcb_ptr                   6            based           pointer                  level 2 packed packed unaligned dcl 5-22 ref 442
tcbp                            000330 automatic       pointer                  dcl 6-18 set ref 442* 443* 446 508 511 513 514 516
                                                                                  517 519 520 522 585 607 621 623 698 722 722 722
                                                                                  722 734 734 734 876 876 876 881 892 976 1009 1009
                                                                                  1010 1010 1146 1146 1168 1168 1172 1184 1199 1237
                                                                                  1240 1409 1482 1576 1614 1641 1725 1728 1730 1730
                                                                                  1738 1782 1788 1792 1805 1823 1836 1872 1887 1911
                                                                                  1913 1915 1984 1988 1988 1995 1995 2031 2031
tctp                            000116 automatic       pointer                  dcl 91 set ref 511* 513* 612 635
temp_lctep                      000354 automatic       pointer                  dcl 2072 set ref 2076* 2077
time_spent                      000160 automatic       fixed bin(71,0)          dcl 112 set ref 2029* 2031 2032
totbuf                   17            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 989* 989
tty_buf                                based           structure                level 1 dcl 2-35
tty_buf$                        000052 external static fixed bin(17,0)          dcl 2-19 set ref 402
tty_index$initialize_tcb        000016 constant        entry                    external dcl 274 ref 443
tty_lock$lock_channel           000012 constant        entry                    external dcl 271 ref 416
tty_lock$unlock_channel         000014 constant        entry                    external dcl 271 ref 429 2033
tty_space_man$free_buffer       000056 constant        entry                    external dcl 8-14 ref 789
tty_space_man$free_chain        000060 constant        entry                    external dcl 8-16 ref 946 2053 2055
tty_space_man$get_buffer        000054 constant        entry                    external dcl 8-13 ref 757 817 887
tty_space_man$needs_space       000062 constant        entry                    external dcl 8-18 ref 2038
tty_tables$                     000030 external static fixed bin(17,0)          dcl 308 set ref 510
tty_util_$find_char             000024 constant        entry                    external dcl 277 ref 642
tty_util_$illegal_char          000026 constant        entry                    external dcl 278 ref 1627
tty_util_$mvt                   000020 constant        entry                    external dcl 275 ref 1527 1639
tty_util_$scm                   000022 constant        entry                    external dcl 276 ref 1542 1568 1648
ttybp                           000322 automatic       pointer                  dcl 2-19 set ref 402* 405 494 528 535 542 545 684
                                                                                  774 784 909 913 919 925 946 946 959 986 986 986
                                                                                  989 989 990 990 1011 1011 1012 1012 1014 1014 1019
                                                                                  1019 1027 1027 2032 2032 2055 2055 2061
ttytp                           000114 automatic       pointer                  dcl 90 set ref 510* 513 516 519 522
turn                      0(22)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref
                                                                                  495* 769* 769 858* 2052
twx                                    parameter       fixed bin(17,0)          dcl 65 ref 35 347 356 367 382 404
type                      0(28)        based           fixed bin(8,0)           level 2 packed packed unsigned unaligned dcl 11-22
                                                                                  set ref 1002*
uncp_flag                       000260 automatic       bit(1)                   packed unaligned dcl 164 set ref 412* 486 769 855
                                                                                  2014 2052
unspec                                                 builtin function         dcl 319 set ref 998* 1666* 1666 1999
upper_case               17(15)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 607
upper_shift                            constant        fixed bin(17,0)          initial dcl 230 ref 1589 1589
uproc                    11            based           bit(36)                  level 2 dcl 5-22 set ref 446 1003*
uproc_attached           30(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 446
util                            000262 automatic       structure                level 1 dcl 166 set ref 642 642 1526 1527 1527 1540
                                                                                  1542 1542 1544 1551 1568 1568 1593 1638 1639 1639
                                                                                  1644 1645 1647 1648 1648 1649
var_tab                   3            based           float bin(27)            level 2 dcl 1-66 ref 1488
version                                based           bit(2)                   level 2 packed packed unaligned dcl 11-22 set ref
                                                                                  999*
vert                            000214 automatic       fixed bin(17,0)          dcl 136 set ref 1264* 1266 1272 1279
vert_nl                                based           fixed bin(17,0)          level 2 dcl 1-66 ref 1264 1364 1364 1400
vertsp                   17(08)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 1782
vt_ff                     5            based           fixed bin(17,0)          level 2 dcl 1-66 set ref 1816*
vt_seq                   20            based           structure                level 2 dcl 1-26 set ref 1801
wcol                            000170 automatic       fixed bin(17,0)          dcl 118 set ref 600* 617 647* 980 1166 1168 1172*
                                                                                  1172 1175 1175 1181 1184 1184 1187 1195 1197 1201
                                                                                  1205 1209 1215 1734* 1769* 1777* 1777 1927* 1951*
                                                                                  1951 1954* 1954 1957* 1957 1957 1960*
wflag                    13(12)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref
                                                                                  1004* 1006* 2041*
white_col                17(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 set ref 600
                                                                                  980*
white_sw                        000165 automatic       bit(1)                   packed unaligned dcl 115 set ref 617* 647 652 1216*
                                                                                  1722 1755 1762* 1768* 1820* 1840 1852 1860 1885
                                                                                  1949* 1986
whole_string                    000112 automatic       bit(1)                   packed unaligned dcl 88 set ref 361* 370* 393* 567
                                                                                  1020
words_needed                    000244 automatic       fixed bin(17,0)          dcl 154 set ref 812* 817* 821
write_calls              33            based           fixed bin(35,0)          level 3 in structure "tcb" dcl 6-20 in procedure
                                                                                  "tty_write" set ref 1010* 1010
write_calls              31            based           fixed bin(35,0)          level 2 in structure "tty_buf" dcl 2-35 in procedure
                                                                                  "tty_write" set ref 1011* 1011
write_chars              35            based           fixed bin(35,0)          level 3 dcl 6-20 set ref 1009* 1009
write_first              16            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 set ref 533
                                                                                  535 686 774 776* 797 797 833* 909 925 926* 928 944
                                                                                  946 946 947* 955* 2059*
write_last               16(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 set ref 492
                                                                                  494 677 684 687 732 765* 776 785 796 797 831 835*
                                                                                  893* 919 928* 947* 963 963* 2060* 2061 2061
write_time               26            based           fixed bin(71,0)          level 2 in structure "tty_buf" dcl 2-35 in procedure
                                                                                  "tty_write" set ref 2032* 2032
write_time               40            based           fixed bin(71,0)          level 3 in structure "tcb" dcl 6-20 in procedure
                                                                                  "tty_write" set ref 2031* 2031
wru                      13(14)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref
                                                                                  2017 2025*
wtcb                                   based           structure                level 1 dcl 5-22
wtcbp                           000326 automatic       pointer                  dcl 5-20 set ref 441* 442 443 443* 446 446 450 452
                                                                                  454 460 467 473 475 476 487 489 492 494 496 533
                                                                                  535 545 550 550 598 599 600 675 677 684 686 687
                                                                                  732 744 765 774 776 776 785 796 797 797 797 802
                                                                                  812 812 821 831 833 835 858 859 893 905 909 919
                                                                                  921 925 926 928 928 931 944 946 946 947 947 948
                                                                                  955 963 963 967 971 978 979 980 996 1003 1003 1004
                                                                                  1006 1531 2015 2017 2017 2022 2025 2038 2041 2052
                                                                                  2058 2059 2060 2061 2061
xor                             000177 automatic       bit(18)                  packed unaligned dcl 123 set ref 1534* 1536

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CV_TRANS_SIZE                          internal static fixed bin(17,0)          initial array dcl 1-129
CV_TRANS_VERSION                       internal static fixed bin(17,0)          initial dcl 1-127
DELAY_VERSION                          internal static fixed bin(17,0)          initial dcl 1-126
DSA_ATTENTION_MSG                      internal static fixed bin(8,0)           initial unsigned dcl 11-83
DSA_DATA_ATTENTION_MSG                 internal static fixed bin(8,0)           initial unsigned dcl 11-84
DSA_DATA_INPUT_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 11-100
DSA_DATA_OUTPUT_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-101
DSA_DEMAND_RELEASE_SRU_MSG             internal static fixed bin(8,0)           initial unsigned dcl 11-85
DSA_DEMAND_TURN_ACK_MSG                internal static fixed bin(8,0)           initial unsigned dcl 11-87
DSA_DEMAND_TURN_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-86
DSA_ESTABLISHMENT_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 11-97
DSA_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 11-103
DSA_NETWORK_TYPE                       internal static fixed bin(4,0)           initial unsigned dcl 11-35
DSA_PURGE_MSG                          internal static fixed bin(8,0)           initial unsigned dcl 11-88
DSA_RECOVER_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-90
DSA_RECOVER_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 11-89
DSA_RELEASE_SRU_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-91
DSA_RESUME_ACK_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 11-93
DSA_RESUME_MSG                         internal static fixed bin(8,0)           initial unsigned dcl 11-92
DSA_SUSPEND_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-95
DSA_SUSPEND_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 11-94
DSA_TERMINATED_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 11-98
DSA_TERM_ABNORMAL_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 11-96
DSA_UNSPECIFIED_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 11-82
DSA_USER_UNASSIGN_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 11-99
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
HASP_MPX                               internal static fixed bin(17,0)          initial dcl 10-16
IBM3270_MPX                            internal static fixed bin(17,0)          initial dcl 10-16
INPUT                                  internal static bit(1)                   initial packed unaligned dcl 8-20
INPUT_CONVERT_BREAK                    internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_DISCARD                  internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_DSA_CR_PROCESSING        internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_ESCAPE                   internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_FORMFEED                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_ORDINARY                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_PRECEDENCE_DISCARD       internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
LAP_MPX                                internal static fixed bin(17,0)          initial dcl 10-16
MAX_DSA_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 11-80
MAX_MCS_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 11-46
MCS_DIALOUT_MSG                        internal static fixed bin(17,0)          initial dcl 11-54
MCS_DIALUP_MSG                         internal static fixed bin(17,0)          initial dcl 11-50
MCS_HANGUP_MSG                         internal static fixed bin(17,0)          initial dcl 11-52
MCS_LINE_STATUS_MSG                    internal static fixed bin(17,0)          initial dcl 11-62
MCS_MASKED_MSG                         internal static fixed bin(17,0)          initial dcl 11-64
MCS_MPX                                internal static fixed bin(17,0)          initial dcl 10-16
MCS_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 11-67
MCS_QUIT_MSG                           internal static fixed bin(17,0)          initial dcl 11-56
MCS_READ_MSG                           internal static fixed bin(17,0)          initial dcl 11-58
MCS_UNSPECIFIED_MSG                    internal static fixed bin(17,0)          initial dcl 11-48
MOWSE_NETWORK_TYPE                     internal static fixed bin(4,0)           initial unsigned dcl 11-36
NETWORK_TYPE_VALUES                    internal static varying char(8)          initial array dcl 11-38
OUTPUT_CONVERT_BRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_BS                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_CR                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_DONT_SEND               internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_FF                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_FIRST_SPECIAL           internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_HT                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NEWLINE                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_13             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_14             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_15             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_16             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NO_MOTION               internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_OCTAL                   internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_ORDINARY                internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_PRECEDENCE_NO_MOTION    internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_RRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_VT                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
PROTOCOL_MPX                           internal static fixed bin(17,0)          initial dcl 10-16
SPECIAL_INFO_STRUCT_VERSION_1          internal static char(8)                  initial packed unaligned dcl 1-122
SPECIAL_VERSION                        internal static fixed bin(17,0)          initial dcl 1-124
SPECIAL_VERSION_2                      internal static fixed bin(17,0)          initial dcl 1-125
STY_MPX                                internal static fixed bin(17,0)          initial dcl 10-16
SYSTEM1_MPX                            internal static fixed bin(17,0)          initial dcl 10-16
SYSTEM2_MPX                            internal static fixed bin(17,0)          initial dcl 10-16
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
USER1_MPX                              internal static fixed bin(17,0)          initial dcl 10-16
USER2_MPX                              internal static fixed bin(17,0)          initial dcl 10-16
USER3_MPX                              internal static fixed bin(17,0)          initial dcl 10-16
USER4_MPX                              internal static fixed bin(17,0)          initial dcl 10-16
USER5_MPX                              internal static fixed bin(17,0)          initial dcl 10-16
VIP7760_MPX                            internal static fixed bin(17,0)          initial dcl 10-16
X25_MPX                                internal static fixed bin(17,0)          initial dcl 10-16
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
bsizec                                 internal static fixed bin(17,0)          initial dcl 2-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
channel_manager$check_modes     000000 constant        entry                    external dcl 9-19
channel_manager$get_modes       000000 constant        entry                    external dcl 9-22
channel_manager$interrupt       000000 constant        entry                    external dcl 9-25
channel_manager$interrupt_later 000000 constant        entry                    external dcl 9-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 9-31
channel_manager$read            000000 constant        entry                    external dcl 9-7
channel_manager$set_modes       000000 constant        entry                    external dcl 9-16
cv_trans_struc                         based           structure                level 1 dcl 1-107
delay_struc                            based           structure                level 1 dcl 1-112
free_block                             based           structure                level 1 dcl 4-23
free_blockp                            automatic       pointer                  dcl 4-20
get_special_info_struc                 based           structure                level 1 dcl 1-117
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
lcnt                                   based           structure                level 1 dcl 7-65
lcntp                                  automatic       pointer                  dcl 7-63
lct_size                               automatic       fixed bin(17,0)          dcl 7-9
lock_ptr                               automatic       pointer                  dcl 3-9
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 4-43
mpx_special_lock                       internal static bit(1)                   initial array packed unaligned dcl 10-40
mpx_types                              internal static char(32)                 initial array packed unaligned dcl 10-35
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
saved_meters                           based           structure                level 1 dcl 7-68
sc_escape_len                          automatic       fixed bin(17,0)          dcl 1-58
sc_input_escape_len                    automatic       fixed bin(17,0)          dcl 1-59
special_chars_struc                    based           structure                level 1 dcl 1-76
tty_ev                                 internal static fixed bin(17,0)          initial dcl 2-19
tty_space_man$free_space        000000 constant        entry                    external dcl 8-12
tty_space_man$get_chain         000000 constant        entry                    external dcl 8-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 8-11
tty_space_man$get_space         000000 constant        entry                    external dcl 8-10
tty_space_man$switch_chain      000000 constant        entry                    external dcl 8-17

NAMES DECLARED BY EXPLICIT CONTEXT.
NO_SPACE_WRITE_NOTHING          001015 constant        label                    dcl 552 ref 569
all_done                        006047 constant        label                    dcl 2010 ref 503 1015 2043
convert_to_upper_case           004635 constant        entry                    internal dcl 1600 ref 607
copy_chars                      002752 constant        entry                    internal dcl 1044 ref 1548 1569 1659 1671 1733 1741
                                                                                  1855 1863 1916 1925
force_join                      000331 constant        label                    dcl 387 ref 351
free_and_try_again              002712 constant        label                    dcl 1017 ref 818 888
free_buffers                    006174 constant        entry                    internal dcl 2045 ref 427 937 943 1017
get_new_buf                     001770 constant        label                    dcl 812 ref 732
insert_bs                       003765 constant        entry                    internal dcl 1376 ref 1192 1195 1359
insert_char                     002776 constant        entry                    internal dcl 1062 ref 629 1210 1252 1254 1299 1305
                                                                                  1306 1420 1442 1478 1485 1560 1573 1589 1591 1661
                                                                                  1681 1797 1809 1991 1999
insert_cr                       003703 constant        entry                    internal dcl 1350 ref 1175 1189
insert_delays                   003017 constant        entry                    internal dcl 1079 ref 1136 1285 1291 1364 1400 1441
                                                                                  1446 1490 1816
insert_nl                       003423 constant        entry                    internal dcl 1221 ref 1146 1170 1763 1918 1988 1995
insert_sequence                 003063 constant        entry                    internal dcl 1104 ref 628 1363 1399 1428 1795 1808
                                                                                  1815 1846 1891
insert_sequence_internal        003636 constant        entry                    internal dcl 1314 ref 1289 1298
insert_shift                    004607 constant        entry                    internal dcl 1584 ref 1552 1556
insert_tab                      004257 constant        entry                    internal dcl 1468 ref 1202 1205 1412 1415
insert_white                    003223 constant        entry                    internal dcl 1161 ref 652 655 1722 1755 1840 1852
                                                                                  1860 1885 1986
is_parent_mpx                   006275 constant        entry                    internal dcl 2068 ref 412
join                            000333 constant        label                    dcl 390 ref 343
locked                          000313 constant        entry                    external dcl 382
mark_join                       000345 constant        label                    dcl 396 ref 376
move_formated_chars             005100 constant        entry                    internal dcl 1708 ref 645
no_break                        001414 constant        label                    dcl 705 ref 698
no_permission                   000462 constant        label                    dcl 436 ref 446 462
nothing_written                 006153 constant        label                    dcl 2038 ref 557 938 1024 1032
octal_escape                    005743 constant        entry                    internal dcl 1977 ref 1829 1833
restart                         001101 constant        label                    dcl 585 ref 1030
scan_white                      005641 constant        entry                    internal dcl 1934 ref 1772 1778
set_nelem                       000302 constant        label                    dcl 372 ref 362
table_error                     002742 constant        label                    dcl 1038 ref 1121 1331 1878 1881
translation                     004367 constant        entry                    internal dcl 1513 ref 662
try_again                       002722 constant        label                    dcl 1020 ref 1050 1070 1091 1125 1335 1451 1497
tty_write                       000144 constant        entry                    external dcl 35
tty_write_force                 000165 constant        entry                    external dcl 347
tty_write_set_mark              000253 constant        entry                    external dcl 367
tty_write_whole_string          000211 constant        entry                    external dcl 356
unlock                          006127 constant        label                    dcl 2029 ref 438 470 477 483 572 1040
wrap_lines                      005563 constant        entry                    internal dcl 1903 ref 1730

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7052        7142    6501        7062
Length      7612    6501        70         433     351           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tty_write                           269 external procedure  is an external procedure.  
on unit on line 422                  68 on unit               
begin block on line 575             326 begin block         uses auto adjustable storage.  
copy_chars                              internal procedure  shares stack frame of begin block on line 575.  
insert_char                             internal procedure  shares stack frame of begin block on line 575.  
insert_delays                           internal procedure  shares stack frame of begin block on line 575.  
insert_sequence                         internal procedure  shares stack frame of begin block on line 575.  
insert_white                            internal procedure  shares stack frame of begin block on line 575.  
insert_nl                               internal procedure  shares stack frame of begin block on line 575.  
insert_sequence_internal                internal procedure  shares stack frame of begin block on line 575.  
insert_cr                               internal procedure  shares stack frame of begin block on line 575.  
insert_bs                               internal procedure  shares stack frame of begin block on line 575.  
insert_tab                              internal procedure  shares stack frame of begin block on line 575.  
translation                             internal procedure  shares stack frame of begin block on line 575.  
insert_shift                            internal procedure  shares stack frame of begin block on line 575.  
convert_to_upper_case                   internal procedure  shares stack frame of begin block on line 575.  
move_formated_chars                     internal procedure  shares stack frame of begin block on line 575.  
wrap_lines                              internal procedure  shares stack frame of begin block on line 575.  
scan_white                              internal procedure  shares stack frame of begin block on line 575.  
octal_escape                            internal procedure  shares stack frame of begin block on line 575.  
free_buffers                         75 internal procedure  is called by several nonquick procedures.  
is_parent_mpx                           internal procedure  shares stack frame of external procedure tty_write.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 575  000100 buffer_1                    begin block on line 575
                         000100 buffer_2                    begin block on line 575
                         000132 i                           insert_delays
                         000142 col_sw                      insert_sequence
                         000143 i                           insert_sequence
                         000144 auto_len                    insert_sequence
                         000162 delay_before                insert_nl
                         000163 eop_sw                      insert_nl
                         000164 eop_seqp                    insert_nl
                         000166 seqp                        insert_nl
                         000176 i                           insert_sequence_internal
                         000177 auto_len                    insert_sequence_internal
                         000216 count                       insert_bs
                         000217 i                           insert_bs
                         000220 bs_char                     insert_bs
                         000221 new_col                     insert_bs
                         000234 i                           insert_tab
                         000235 count                       insert_tab
                         000304 done                        scan_white
                         000305 first_time                  scan_white
tty_write                000100 state                       tty_write
                         000101 devx                        tty_write
                         000102 readp                       tty_write
                         000104 offset                      tty_write
                         000105 nelem                       tty_write
                         000106 nelemt                      tty_write
                         000107 locked_entry                tty_write
                         000110 forcesw                     tty_write
                         000111 mark_entry                  tty_write
                         000112 whole_string                tty_write
                         000114 ttytp                       tty_write
                         000116 tctp                        tty_write
                         000120 mvtp                        tty_write
                         000122 special_ptr                 tty_write
                         000124 delay_ptr                   tty_write
                         000126 max_space                   tty_write
                         000127 max_chars                   tty_write
                         000130 max_chars_in_buf            tty_write
                         000132 input_ptr                   tty_write
                         000134 final_outp                  tty_write
                         000136 output_length               tty_write
                         000140 source_ptr                  tty_write
                         000142 source_len                  tty_write
                         000144 target_ptr                  tty_write
                         000146 target_len                  tty_write
                         000150 cap_source_ptr              tty_write
                         000152 cap_target_ptr              tty_write
                         000154 cap_tab_ptr                 tty_write
                         000156 scanned_len                 tty_write
                         000160 time_spent                  tty_write
                         000162 start_time                  tty_write
                         000164 chars_moved                 tty_write
                         000165 white_sw                    tty_write
                         000166 line_count                  tty_write
                         000167 col                         tty_write
                         000170 wcol                        tty_write
                         000171 oldcol                      tty_write
                         000172 old_tally                   tty_write
                         000174 seqp                        tty_write
                         000176 i                           tty_write
                         000177 xor                         tty_write
                         000200 shift                       tty_write
                         000201 new_char_count              tty_write
                         000202 old_head                    tty_write
                         000203 old_tail                    tty_write
                         000204 old_end_frame               tty_write
                         000205 break_length                tty_write
                         000206 break_flag                  tty_write
                         000207 null_for_eop                tty_write
                         000210 n_delays                    tty_write
                         000211 back_chars                  tty_write
                         000212 forward_chars               tty_write
                         000213 horiz                       tty_write
                         000214 vert                        tty_write
                         000215 ll                          tty_write
                         000216 escape_index                tty_write
                         000220 headp                       tty_write
                         000222 send                        tty_write
                         000223 new_head                    tty_write
                         000224 n_pages                     tty_write
                         000226 lastp                       tty_write
                         000230 bufp                        tty_write
                         000232 prevp                       tty_write
                         000234 buf_size                    tty_write
                         000235 orig_buf_size               tty_write
                         000236 reached_needed              tty_write
                         000237 new_buffer_count            tty_write
                         000240 first_buffer                tty_write
                         000242 old_lastp                   tty_write
                         000244 words_needed                tty_write
                         000246 new_bufp                    tty_write
                         000250 new_buf                     tty_write
                         000251 chars_in_buf                tty_write
                         000252 lchar                       tty_write
                         000253 old_char_count              tty_write
                         000254 nchars                      tty_write
                         000255 cur_space                   tty_write
                         000256 cur_chain_len               tty_write
                         000257 end_chain                   tty_write
                         000260 uncp_flag                   tty_write
                         000262 util                        tty_write
                         000274 illegal_char_args           tty_write
                         000306 auto_buf_len                tty_write
                         000307 allocated_buffers           tty_write
                         000310 eop_sentinel                tty_write
                         000320 c_chars_ptr                 tty_write
                         000322 ttybp                       tty_write
                         000324 blockp                      tty_write
                         000326 wtcbp                       tty_write
                         000330 tcbp                        tty_write
                         000332 lctp                        tty_write
                         000334 lctep                       tty_write
                         000336 net_event_message_arg       tty_write
                         000354 temp_lctep                  is_parent_mpx

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_ne_as             r_le_a              enter_begin_block   call_ext_out_desc   call_ext_out
call_int_other      return_mac          fl2_to_fx1          tra_ext_1           alloc_auto_adj      mdfx1
enable_op           ext_entry           ext_entry_desc      int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$control       channel_manager$write         pxss$ring_0_wakeup            tty_index$initialize_tcb
tty_lock$lock_channel         tty_lock$unlock_channel       tty_space_man$free_buffer     tty_space_man$free_chain
tty_space_man$get_buffer      tty_space_man$needs_space     tty_util_$find_char           tty_util_$illegal_char
tty_util_$mvt                 tty_util_$scm

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bigarg           error_table_$improper_data_format
error_table_$invalid_device   error_table_$io_no_permission error_table_$line_status_pending
error_table_$noalloc          pds$processid                 tty_buf$                      tty_tables$


CONSTANTS
006345  aa     777767777777

006346  aa     000002000000
006347  aa     000000000000
006350  aa     600000000041
006351  aa     000477000000

006352  aa     000002000000
006353  aa     000000000000
006354  aa     600000000041
006355  aa     000474000000

006356  aa     000002000000
006357  aa     000000000000
006360  aa     600000000041
006361  aa     000464000000

006362  aa     577777777777

006364  aa     000002000000
006365  aa     000000000000
006366  aa     600000000041
006367  aa     000446000000

006370  aa     000002000000
006371  aa     000000000000
006372  aa     600000000041
006373  aa     000431000000

006374  aa     000002000000
006375  aa     000000000000
006376  ta     000104000000
006377  aa     000000000000

006400  aa     000002000000
006401  aa     000000000000
006402  aa     600000000041
006403  aa     000220000000

006404  aa     000002000000
006405  aa     000000000000
006406  aa     600000000041
006407  aa     000400000000

006410  aa     000002000000
006411  aa     000000000000
006412  aa     600000000041
006413  aa     000401000000

006414  aa     000002000000
006415  aa     000000000000
006416  aa     600000000041
006417  aa     000376000000

006420  aa     000002000000
006421  aa     000000000000
006422  ta     000101000000
006423  aa     000000000000

006424  aa     000002000000
006425  aa     000000000000
006426  ta     000106000000
006427  aa     000000000000

006430  aa     000002000000
006431  aa     000000000000
006432  aa     600000000041
006433  aa     000360000000

006434  aa     000002000000
006435  aa     000000000000
006436  ta     000105000000
006437  aa     000000000000

006440  aa     000002000000
006441  aa     000000000000
006442  aa     600000000041
006443  aa     000351000000

006444  aa     000002000000
006445  aa     000000000000
006446  aa     600000000041
006447  aa     000350000000

006450  aa     000002000000
006451  aa     000000000000
006452  aa     600000000041
006453  aa     000340000000

006454  aa     777737777777

006455  aa     677777777777

006456  aa     777777775777

006457  aa     777777677777

006460  aa     777777007777

006462  aa     000002000000
006463  aa     000000000000
006464  aa     600000000041
006465  aa     000316000000

006466  aa     777577777777

006470  aa     000004000000
006471  aa     000000000000
006472  ta     000000000000
006473  aa     000000000000
006474  aa     600000000041
006475  aa     000260000000

000000  aa     000000000015

006476  aa  076 000 000 000	>

000001  aa     000001002003
000002  aa     004005006007
000003  aa     010011012013
000004  aa     014015016017
000005  aa     020021022023
000006  aa     024025026027
000007  aa     030031032033
000010  aa     034035036037
000011  aa     040041042043
000012  aa     044045046047
000013  aa     050051052053
000014  aa     054055056057
000015  aa     060061062063
000016  aa     064065066067
000017  aa     070071072073
000020  aa     074075076077
000021  aa     100501502503
000022  aa     504505506507
000023  aa     510511512513
000024  aa     514515516517
000025  aa     520521522523
000026  aa     524525526527
000027  aa     530531532133
000030  aa     134135136137
000031  aa     140101102103
000032  aa     104105106107
000033  aa     110111112113
000034  aa     114115116117
000035  aa     120121122123
000036  aa     124125126127
000037  aa     130131132173
000040  aa     174175176177

000041  aa     000001002003
000042  aa     004005006007
000043  aa     010011012013
000044  aa     014015016017
000045  aa     020021022023
000046  aa     024025026027
000047  aa     030031032033
000050  aa     034035036037
000051  aa     040041042043
000052  aa     044045046047
000053  aa     050051052053
000054  aa     054055056057
000055  aa     060061062063
000056  aa     064065066067
000057  aa     070071072073
000060  aa     074075076077
000061  aa     100101102103
000062  aa     104105106107
000063  aa     110111112113
000064  aa     114115116117
000065  aa     120121122123
000066  aa     124125126127
000067  aa     130131132133
000070  aa     134135136137
000071  aa     140101102103
000072  aa     104105106107
000073  aa     110111112113
000074  aa     114115116117
000075  aa     120121122123
000076  aa     124125126127
000077  aa     130131132173
000100  aa     174175176177

000101  aa  143 000 000 000	c

000102  aa  060 061 062 063	0123
000103  aa  064 065 066 067	4567

000104  aa  011 000 000 000		

000105  aa  040 000 000 000	 

000106  aa  134 000 000 000	\

000107  aa     033000000000

000110  aa     000631463146

006477  aa     300000000000

006500  aa     000000000012

000111  aa     514000000001

000112  aa     526000000001

000113  aa     524000000015

000114  aa     400000000000

000115  aa     404000000043

000116  aa     516000000001

000117  aa     526077777777

000120  aa     404000000025

000121  aa     464000000000

000122  aa     404000000021

000124  aa     000000000000
000125  aa     000000000000

000126  aa     077777000043
000127  aa     000001000000

000130  aa  143 154 145 141	clea
000131  aa  156 165 160 000	nup

000132  aa  145 156 164 145	ente
000133  aa  162 137 162 145	r_re
000134  aa  143 145 151 166	ceiv
000135  aa  145 000 000 000	e

BEGIN PROCEDURE tty_write
ENTRY TO tty_write                                          STATEMENT 1 ON LINE 35
tty_write:
     proc (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);

000136  at     000007000122
000137  tt     000121000120
000140  tt     000120000120
000141  tt     000122000115
000142  ta     000136000000
000143  da     000273300000
000144  aa   000420 6270 00	eax7 	272
000145  aa  7 00034 3521 20	epp2 	pr7|28,*
000146  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000147  aa     000016000000
000150  aa     000000000000
000151  aa  6 00032 3735 20	epp7 	pr6|26,*
000152  aa  7 00012 3715 20	epp5 	pr7|10,*
000153  aa  6 00340 6515 00	spri5	pr6|224
000154  aa  7 00014 3535 20	epp3 	pr7|12,*
000155  aa  6 00342 2535 00	spri3	pr6|226
000156  aa  7 00016 3515 20	epp1 	pr7|14,*
000157  aa  6 00344 2515 00	spri1	pr6|228
						STATEMENT 1 ON LINE 341
	locked_entry = "0"b;

000160  aa  6 00107 4501 00	stz  	pr6|71		locked_entry
						STATEMENT 1 ON LINE 342
	forcesw = "0"b;

000161  aa  6 00110 4501 00	stz  	pr6|72		forcesw
						STATEMENT 1 ON LINE 343
	go to join;

000162  aa   000151 7100 04	tra  	105,ic		000333
ENTRY TO tty_write_force                                    STATEMENT 1 ON LINE 347
tty_write_force:
     entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);

000163  ta     000136000000
000164  da     000302300000
000165  aa   000420 6270 00	eax7 	272
000166  aa  7 00034 3521 20	epp2 	pr7|28,*
000167  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000170  aa     000016000000
000171  aa     000000000000
000172  aa  6 00032 3735 20	epp7 	pr6|26,*
000173  aa  7 00012 3715 20	epp5 	pr7|10,*
000174  aa  6 00340 6515 00	spri5	pr6|224
000175  aa  7 00014 3535 20	epp3 	pr7|12,*
000176  aa  6 00342 2535 00	spri3	pr6|226
000177  aa  7 00016 3515 20	epp1 	pr7|14,*
000200  aa  6 00344 2515 00	spri1	pr6|228
						STATEMENT 1 ON LINE 350
	locked_entry = "0"b;

000201  aa  6 00107 4501 00	stz  	pr6|71		locked_entry
						STATEMENT 1 ON LINE 351
	go to force_join;

000202  aa   000127 7100 04	tra  	87,ic		000331
ENTRY TO tty_write_whole_string                             STATEMENT 1 ON LINE 356
tty_write_whole_string:
     entry (twx, a_string, a_mark_flag, a_nelemt, a_state, ercode);

000203  at     000006000122
000204  tt     000117000116
000205  tt     000120000122
000206  ta     000115000000
000207  ta     000203000000
000210  da     000313300000
000211  aa   000420 6270 00	eax7 	272
000212  aa  7 00034 3521 20	epp2 	pr7|28,*
000213  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000214  aa     000014000000
000215  aa     000000000000
000216  aa  6 00042 3735 20	epp7 	pr6|34,*
000217  aa  7 00002 2361 20	ldq  	pr7|2,*
000220  aa   000002 6040 04	tmi  	2,ic		000222
000221  aa   777777 3760 07	anq  	262143,dl
000222  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000223  aa  6 00356 7561 00	stq  	pr6|238
000224  aa  6 00032 3715 20	epp5 	pr6|26,*
000225  aa  5 00010 3535 20	epp3 	pr5|8,*
000226  aa  6 00340 2535 00	spri3	pr6|224
000227  aa  5 00012 3515 20	epp1 	pr5|10,*
000230  aa  6 00342 2515 00	spri1	pr6|226
000231  aa  5 00014 3735 20	epp7 	pr5|12,*
000232  aa  6 00344 6535 00	spri7	pr6|228
						STATEMENT 1 ON LINE 359
	locked_entry, forcesw = "0"b;

000233  aa  6 00107 4501 00	stz  	pr6|71		locked_entry
000234  aa  6 00110 4501 00	stz  	pr6|72		forcesw
						STATEMENT 1 ON LINE 360
	mark_entry = a_mark_flag;

000235  aa  6 00111 4501 00	stz  	pr6|73		mark_entry
000236  aa  6 00032 3735 20	epp7 	pr6|26,*
000237  aa  7 00006 3715 20	epp5 	pr7|6,*
000240  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000241  aa  5 00000 00 0001	descb	pr5|0,1		a_mark_flag
000242  aa  6 00111 00 0001	descb	pr6|73,1		mark_entry
						STATEMENT 1 ON LINE 361
	whole_string = "1"b;

000243  aa   400000 2350 03	lda  	131072,du
000244  aa  6 00112 7551 00	sta  	pr6|74		whole_string
						STATEMENT 1 ON LINE 362
	go to set_nelem;

000245  aa   000035 7100 04	tra  	29,ic		000302
ENTRY TO tty_write_set_mark                                 STATEMENT 1 ON LINE 367
tty_write_set_mark:
     entry (twx, a_string, a_nelemt, a_state, ercode);

000246  at     000005000122
000247  tt     000117000120
000250  tt     000122000115
000251  ta     000246000000
000252  da     000323300000
000253  aa   000420 6270 00	eax7 	272
000254  aa  7 00034 3521 20	epp2 	pr7|28,*
000255  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000256  aa     000012000000
000257  aa     000000000000
000260  aa  6 00042 3735 20	epp7 	pr6|34,*
000261  aa  7 00002 2361 20	ldq  	pr7|2,*
000262  aa   000002 6040 04	tmi  	2,ic		000264
000263  aa   777777 3760 07	anq  	262143,dl
000264  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000265  aa  6 00356 7561 00	stq  	pr6|238
000266  aa  6 00032 3715 20	epp5 	pr6|26,*
000267  aa  5 00006 3535 20	epp3 	pr5|6,*
000270  aa  6 00340 2535 00	spri3	pr6|224
000271  aa  5 00010 3515 20	epp1 	pr5|8,*
000272  aa  6 00342 2515 00	spri1	pr6|226
000273  aa  5 00012 3735 20	epp7 	pr5|10,*
000274  aa  6 00344 6535 00	spri7	pr6|228
						STATEMENT 1 ON LINE 370
	whole_string, locked_entry, forcesw = "0"b;

000275  aa  6 00112 4501 00	stz  	pr6|74		whole_string
000276  aa  6 00107 4501 00	stz  	pr6|71		locked_entry
000277  aa  6 00110 4501 00	stz  	pr6|72		forcesw
						STATEMENT 1 ON LINE 371
	mark_entry = "1"b;

000300  aa   400000 2350 03	lda  	131072,du
000301  aa  6 00111 7551 00	sta  	pr6|73		mark_entry
						STATEMENT 1 ON LINE 372
set_nelem:
	nelem = length (a_string);

000302  aa  6 00356 2361 00	ldq  	pr6|238
000303  aa  6 00105 7561 00	stq  	pr6|69		nelem
						STATEMENT 1 ON LINE 374
	offset = 0;

000304  aa  6 00104 4501 00	stz  	pr6|68		offset
						STATEMENT 1 ON LINE 375
	readp = addr (a_string);

000305  aa  6 00032 3735 20	epp7 	pr6|26,*
000306  aa  7 00004 3521 20	epp2 	pr7|4,*		a_string
000307  aa  6 00102 2521 00	spri2	pr6|66		readp
						STATEMENT 1 ON LINE 376
	go to mark_join;

000310  aa   000035 7100 04	tra  	29,ic		000345
ENTRY TO locked                                             STATEMENT 1 ON LINE 382
locked:
     entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);

000311  ta     000136000000
000312  da     000330300000
000313  aa   000420 6270 00	eax7 	272
000314  aa  7 00034 3521 20	epp2 	pr7|28,*
000315  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000316  aa     000016000000
000317  aa     000000000000
000320  aa  6 00032 3735 20	epp7 	pr6|26,*
000321  aa  7 00012 3715 20	epp5 	pr7|10,*
000322  aa  6 00340 6515 00	spri5	pr6|224
000323  aa  7 00014 3535 20	epp3 	pr7|12,*
000324  aa  6 00342 2535 00	spri3	pr6|226
000325  aa  7 00016 3515 20	epp1 	pr7|14,*
000326  aa  6 00344 2515 00	spri1	pr6|228
						STATEMENT 1 ON LINE 385
	locked_entry = "1"b;

000327  aa   400000 2350 03	lda  	131072,du
000330  aa  6 00107 7551 00	sta  	pr6|71		locked_entry
						STATEMENT 1 ON LINE 387
force_join:
	forcesw = "1"b;

000331  aa   400000 2350 03	lda  	131072,du
000332  aa  6 00110 7551 00	sta  	pr6|72		forcesw
						STATEMENT 1 ON LINE 390
join:
	nelem = a_nelem;

000333  aa  6 00032 3735 20	epp7 	pr6|26,*
000334  aa  7 00010 2361 20	ldq  	pr7|8,*		a_nelem
000335  aa  6 00105 7561 00	stq  	pr6|69		nelem
						STATEMENT 1 ON LINE 392
	readp = a_readp;

000336  aa  7 00004 3715 20	epp5 	pr7|4,*		a_readp
000337  aa  5 00000 3715 20	epp5 	pr5|0,*		a_readp
000340  aa  6 00102 6515 00	spri5	pr6|66		readp
						STATEMENT 1 ON LINE 393
	whole_string, mark_entry = "0"b;

000341  aa  6 00112 4501 00	stz  	pr6|74		whole_string
000342  aa  6 00111 4501 00	stz  	pr6|73		mark_entry
						STATEMENT 1 ON LINE 394
	offset = a_offset;

000343  aa  7 00006 2361 20	ldq  	pr7|6,*		a_offset
000344  aa  6 00104 7561 00	stq  	pr6|68		offset
						STATEMENT 1 ON LINE 396
mark_join:
	start_time = clock ();

000345  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
000346  aa  6 00162 7571 00	staq 	pr6|114		start_time
						STATEMENT 1 ON LINE 398
	nelemt = 0;

000347  aa  6 00106 4501 00	stz  	pr6|70		nelemt
						STATEMENT 1 ON LINE 399
	a_nelemt = 0;

000350  aa  6 00340 4501 20	stz  	pr6|224,*		a_nelemt
						STATEMENT 1 ON LINE 400
	a_state = 0;

000351  aa  6 00342 4501 20	stz  	pr6|226,*		a_state
						STATEMENT 1 ON LINE 401
	ercode = 0;

000352  aa  6 00344 4501 20	stz  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 402
	ttybp = addr (tty_buf$);

000353  aa  6 00044 3701 20	epp4 	pr6|36,*
000354  la  4 00052 3735 20	epp7 	pr4|42,*		tty_buf$
000355  aa  6 00322 6535 00	spri7	pr6|210		ttybp
						STATEMENT 1 ON LINE 404
	devx = twx;

000356  aa  6 00032 3715 20	epp5 	pr6|26,*
000357  aa  5 00002 2361 20	ldq  	pr5|2,*		twx
000360  aa  6 00101 7561 00	stq  	pr6|65		devx
						STATEMENT 1 ON LINE 405
	lctp = tty_buf.lct_ptr;

000361  aa  7 00006 3535 20	epp3 	pr7|6,*		tty_buf.lct_ptr
000362  aa  6 00332 2535 00	spri3	pr6|218		lctp
						STATEMENT 1 ON LINE 406
	if devx < 1 | devx > lct.max_no_lctes
	then do;

000363  aa   000001 1160 07	cmpq 	1,dl
000364  aa   000003 6040 04	tmi  	3,ic		000367
000365  aa  3 00000 1161 00	cmpq 	pr3|0		lct.max_no_lctes
000366  aa   000004 6044 04	tmoz 	4,ic		000372
						STATEMENT 1 ON LINE 408
	     ercode = error_table_$invalid_device;

000367  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$invalid_device
000370  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 409
	     return;

000371  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 410
	end;

						STATEMENT 1 ON LINE 412
	uncp_flag = is_parent_mpx (UNCP_MPX);

000372  aa   006076 3520 04	epp2 	3134,ic		006470 = 000004000000
000373  aa   005702 6700 04	tsp4 	3010,ic		006275
						STATEMENT 1 ON LINE 414
	if ^locked_entry
	then do;

000374  aa  6 00107 2351 00	lda  	pr6|71		locked_entry
000375  aa   000014 6010 04	tnz  	12,ic		000411
						STATEMENT 1 ON LINE 416
	     call tty_lock$lock_channel (devx, ercode);

000376  aa  6 00101 3521 00	epp2 	pr6|65		devx
000377  aa  6 00362 2521 00	spri2	pr6|242
000400  aa  6 00344 3521 20	epp2 	pr6|228,*		ercode
000401  aa  6 00364 2521 00	spri2	pr6|244
000402  aa  6 00360 6211 00	eax1 	pr6|240
000403  aa   010000 4310 07	fld  	4096,dl
000404  aa  6 00044 3701 20	epp4 	pr6|36,*
000405  la  4 00012 3521 20	epp2 	pr4|10,*		tty_lock$lock_channel
000406  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 417
	     if ercode ^= 0
	     then return;

000407  aa  6 00344 2361 20	ldq  	pr6|228,*		ercode
000410  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 419
	end;

						STATEMENT 1 ON LINE 421
	allocated_buffers = "0"b;

000411  aa  6 00307 4501 00	stz  	pr6|199		allocated_buffers
						STATEMENT 1 ON LINE 422
	on cleanup
	begin;

000412  aa   000007 7260 07	lxl6 	7,dl
000413  aa   777515 3520 04	epp2 	-179,ic		000130 = 143154145141
000414  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000415  aa   000004 7100 04	tra  	4,ic		000421
000416  aa     000312000000
000417  aa   000033 7100 04	tra  	27,ic		000452
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 422
	on cleanup
	begin;

000420  da     000336200000
000421  aa   000120 6270 00	eax7 	80
000422  aa  7 00034 3521 20	epp2 	pr7|28,*
000423  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000424  aa     000000000000
000425  aa     000000000000
						STATEMENT 1 ON LINE 424
	     if allocated_buffers
	     then do;

000426  aa  6 00040 3735 20	epp7 	pr6|32,*
000427  aa  7 00307 2351 00	lda  	pr7|199		allocated_buffers
000430  aa   000007 6000 04	tze  	7,ic		000437
						STATEMENT 1 ON LINE 426
		allocated_buffers = "0"b;

000431  aa  7 00307 4501 00	stz  	pr7|199		allocated_buffers
						STATEMENT 1 ON LINE 427
		call free_buffers;

000432  aa   000001 7270 07	lxl7 	1,dl
000433  aa  6 00056 6211 00	eax1 	pr6|46
000434  aa   000000 4310 07	fld  	0,dl
000435  aa   005537 3520 04	epp2 	2911,ic		006174 = 000120627000
000436  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 428
	     end;

						STATEMENT 1 ON LINE 429
	     if ^locked_entry
	     then call tty_lock$unlock_channel (devx);

000437  aa  6 00040 3735 20	epp7 	pr6|32,*
000440  aa  7 00107 2351 00	lda  	pr7|71		locked_entry
000441  aa   000010 6010 04	tnz  	8,ic		000451
000442  aa  7 00101 3521 00	epp2 	pr7|65		devx
000443  aa  6 00102 2521 00	spri2	pr6|66
000444  aa  6 00100 6211 00	eax1 	pr6|64
000445  aa   004000 4310 07	fld  	2048,dl
000446  aa  6 00044 3701 20	epp4 	pr6|36,*
000447  la  4 00014 3521 20	epp2 	pr4|12,*		tty_lock$unlock_channel
000450  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 431
	end;

000451  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 433
	lctep = addr (lct.lcte_array (devx));

000452  aa  6 00101 2361 00	ldq  	pr6|65		devx
000453  aa   000005 7360 00	qls  	5
000454  aa  6 00332 3735 20	epp7 	pr6|218,*		lctp
000455  aa  7 77760 3735 06	epp7 	pr7|-16,ql	lct.lcte_array
000456  aa  6 00334 6535 00	spri7	pr6|220		lctep
						STATEMENT 1 ON LINE 434
	if lcte.channel_type ^= TTY_MPX		/* not our type */
	then do;

000457  aa  7 00002 2351 00	lda  	pr7|2		lcte.channel_type
000460  aa   000077 7330 00	lrs  	63
000461  aa   000005 6000 04	tze  	5,ic		000466
						STATEMENT 1 ON LINE 436
no_permission:
	     ercode = error_table_$io_no_permission;

000462  aa  6 00044 3701 20	epp4 	pr6|36,*
000463  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$io_no_permission
000464  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 438
	     go to unlock;

000465  aa   005442 7100 04	tra  	2850,ic		006127
						STATEMENT 1 ON LINE 439
	end;

						STATEMENT 1 ON LINE 441
	wtcbp = lcte.data_base_ptr;

000466  aa  7 00001 7651 00	lprp5	pr7|1		lcte.data_base_ptr
000467  aa  6 00326 6515 00	spri5	pr6|214		wtcbp
						STATEMENT 1 ON LINE 442
	tcbp = wtcb.tcb_ptr;

000470  aa  5 00006 7631 00	lprp3	pr5|6		wtcb.tcb_ptr
000471  aa  6 00330 2535 00	spri3	pr6|216		tcbp
						STATEMENT 1 ON LINE 443
	if ^wtcb.tcb_initialized
	then call tty_index$initialize_tcb (wtcbp, tcbp);

000472  aa  5 00013 2351 00	lda  	pr5|11		wtcb.tcb_initialized
000473  aa   000100 3150 03	cana 	64,du
000474  aa   000012 6010 04	tnz  	10,ic		000506
000475  aa  6 00326 3521 00	epp2 	pr6|214		wtcbp
000476  aa  6 00362 2521 00	spri2	pr6|242
000477  aa  6 00330 3521 00	epp2 	pr6|216		tcbp
000500  aa  6 00364 2521 00	spri2	pr6|244
000501  aa  6 00360 6211 00	eax1 	pr6|240
000502  aa   010000 4310 07	fld  	4096,dl
000503  aa  6 00044 3701 20	epp4 	pr6|36,*
000504  la  4 00016 3521 20	epp2 	pr4|14,*		tty_index$initialize_tcb
000505  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 446
	if pds$processid ^= wtcb.hproc
	then if (pds$processid ^= wtcb.uproc) | ^tcb.uproc_attached
	     then go to no_permission;

000506  aa  6 00044 3701 20	epp4 	pr6|36,*
000507  la  4 00050 2351 20	lda  	pr4|40,*		pds$processid
000510  aa  6 00326 3735 20	epp7 	pr6|214,*		wtcbp
000511  aa  7 00010 1151 00	cmpa 	pr7|8		wtcb.hproc
000512  aa   000007 6000 04	tze  	7,ic		000521
000513  aa  7 00011 1151 00	cmpa 	pr7|9		wtcb.uproc
000514  aa   777746 6010 04	tnz  	-26,ic		000462
000515  aa  6 00330 3715 20	epp5 	pr6|216,*		tcbp
000516  aa  5 00030 2351 00	lda  	pr5|24		tcb.uproc_attached
000517  aa   010000 3150 03	cana 	4096,du
000520  aa   777742 6000 04	tze  	-30,ic		000462
						STATEMENT 1 ON LINE 450
	if wtcb.flags.dialed
	then state = DIALED_UP;

000521  aa  7 00013 2351 00	lda  	pr7|11		wtcb.dialed
000522  aa   200000 3150 03	cana 	65536,du
000523  aa   000004 6000 04	tze  	4,ic		000527
000524  aa   000005 2360 07	ldq  	5,dl
000525  aa  6 00100 7561 00	stq  	pr6|64		state
000526  aa   000017 7100 04	tra  	15,ic		000545
						STATEMENT 1 ON LINE 452
	else if wtcb.flags.listen
	then state = LISTENING;

000527  aa  7 00013 2351 00	lda  	pr7|11		wtcb.listen
000530  aa   400000 3150 03	cana 	131072,du
000531  aa   000004 6000 04	tze  	4,ic		000535
000532  aa   000002 2360 07	ldq  	2,dl
000533  aa  6 00100 7561 00	stq  	pr6|64		state
000534  aa   000011 7100 04	tra  	9,ic		000545
						STATEMENT 1 ON LINE 454
	else if wtcb.flags.masked
	then state = MASKED_STATE;

000535  aa  7 00013 2351 00	lda  	pr7|11		wtcb.masked
000536  aa   001000 3150 07	cana 	512,dl
000537  aa   000004 6000 04	tze  	4,ic		000543
000540  aa   000001 3360 07	lcq  	1,dl
000541  aa  6 00100 7561 00	stq  	pr6|64		state
000542  aa   000003 7100 04	tra  	3,ic		000545
						STATEMENT 1 ON LINE 456
	else state = HUNG_UP;

000543  aa   000001 2360 07	ldq  	1,dl
000544  aa  6 00100 7561 00	stq  	pr6|64		state
						STATEMENT 1 ON LINE 458
	if state ^= DIALED_UP
	then do;

000545  aa   000005 1160 07	cmpq 	5,dl
000546  aa   000006 6000 04	tze  	6,ic		000554
						STATEMENT 1 ON LINE 460
	     if pds$processid = wtcb.hproc
	     then a_state = state;

000547  la  4 00050 2351 20	lda  	pr4|40,*		pds$processid
000550  aa  7 00010 1151 00	cmpa 	pr7|8		wtcb.hproc
000551  aa   777711 6010 04	tnz  	-55,ic		000462
000552  aa  6 00342 7561 20	stq  	pr6|226,*		a_state
						STATEMENT 1 ON LINE 462
	     go to no_permission;

000553  aa   777707 7100 04	tra  	-57,ic		000462
						STATEMENT 1 ON LINE 463
	end;

						STATEMENT 1 ON LINE 465
	a_state = state;

000554  aa  6 00342 7561 20	stq  	pr6|226,*		a_state
						STATEMENT 1 ON LINE 467
	if wtcb.flags.line_status_present
	then do;

000555  aa  7 00013 2351 00	lda  	pr7|11		wtcb.line_status_present
000556  aa   000001 3150 03	cana 	1,du
000557  aa   000004 6000 04	tze  	4,ic		000563
						STATEMENT 1 ON LINE 469
	     ercode = error_table_$line_status_pending;

000560  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$line_status_pending
000561  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 470
	     go to unlock;

000562  aa   005345 7100 04	tra  	2789,ic		006127
						STATEMENT 1 ON LINE 471
	end;

						STATEMENT 1 ON LINE 473
	if wtcb.error_code ^= 0
	then do;

000563  aa  7 00024 2361 00	ldq  	pr7|20		wtcb.error_code
000564  aa   000004 6000 04	tze  	4,ic		000570
						STATEMENT 1 ON LINE 475
	     ercode = wtcb.error_code;

000565  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 476
	     wtcb.error_code = 0;

000566  aa  7 00024 4501 00	stz  	pr7|20		wtcb.error_code
						STATEMENT 1 ON LINE 477
	     go to unlock;

000567  aa   005340 7100 04	tra  	2784,ic		006127
						STATEMENT 1 ON LINE 478
	end;

						STATEMENT 1 ON LINE 480
	if nelem < 0
	then do;

000570  aa  6 00105 2361 00	ldq  	pr6|69		nelem
000571  aa   000004 6050 04	tpl  	4,ic		000575
						STATEMENT 1 ON LINE 482
	     ercode = error_table_$bad_arg;

000572  la  4 00044 2361 20	ldq  	pr4|36,*		error_table_$bad_arg
000573  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 483
	     go to unlock;

000574  aa   005333 7100 04	tra  	2779,ic		006127
						STATEMENT 1 ON LINE 484
	end;

						STATEMENT 1 ON LINE 486
	if uncp_flag then do;

000575  aa  6 00260 2351 00	lda  	pr6|176		uncp_flag
000576  aa   400000 3150 03	cana 	131072,du
000577  aa   000031 6000 04	tze  	25,ic		000630
						STATEMENT 1 ON LINE 487
	     if readp = addr (wtcb.prompt)
		then do;

000600  aa   000001 7270 07	lxl7 	1,dl
000601  aa  7 00022 3521 00	epp2 	pr7|18		wtcb.prompt
000602  aa  2 00000 5005 17	a9bd 	pr2|0,7
000603  aa  6 00366 2521 00	spri2	pr6|246
000604  aa  6 00366 2371 00	ldaq 	pr6|246
000605  aa  6 00102 6771 00	eraq 	pr6|66		readp
000606  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000607  aa   000021 6010 04	tnz  	17,ic		000630
						STATEMENT 1 ON LINE 489
		wtcb.send_turn = "1"b;

000610  aa   000200 2350 03	lda  	128,du
000611  aa  7 00023 2551 00	orsa 	pr7|19		wtcb.send_turn
						STATEMENT 1 ON LINE 490
		if nelem = 0
		     then do;

000612  aa  6 00105 2361 00	ldq  	pr6|69		nelem
000613  aa   000015 6010 04	tnz  	13,ic		000630
						STATEMENT 1 ON LINE 492
		     if wtcb.write_last ^= 0
			then do;

000614  aa  7 00016 2351 00	lda  	pr7|14		wtcb.write_last
000615  aa   000022 7350 00	als  	18
000616  aa   000066 7330 00	lrs  	54
000617  aa  6 00357 7561 00	stq  	pr6|239		wtcb.write_last
000620  aa   000010 6000 04	tze  	8,ic		000630
						STATEMENT 1 ON LINE 494
			blockp = ptr (ttybp, wtcb.write_last);

000621  aa  6 00322 3515 20	epp1 	pr6|210,*		ttybp
000622  aa   000000 3114 06	eawp1	0,ql
000623  aa  6 00324 2515 00	spri1	pr6|212		blockp
						STATEMENT 1 ON LINE 495
			buffer.turn = "1"b;

000624  aa   020000 2350 07	lda  	8192,dl
000625  aa  1 00000 2551 00	orsa 	pr1|0		buffer.turn
						STATEMENT 1 ON LINE 496
			wtcb.send_turn = "0"b;

000626  aa   005640 2350 04	lda  	2976,ic		006466 = 777577777777
000627  aa  7 00023 3551 00	ansa 	pr7|19		wtcb.send_turn
						STATEMENT 1 ON LINE 497
		     end;

						STATEMENT 1 ON LINE 498
		end;

						STATEMENT 1 ON LINE 499
	     end;

						STATEMENT 1 ON LINE 500
	end;

						STATEMENT 1 ON LINE 502
	ercode = 0;

000630  aa  6 00344 4501 20	stz  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 503
	if nelem = 0
	then go to all_done;

000631  aa  6 00105 2361 00	ldq  	pr6|69		nelem
000632  aa   005215 6000 04	tze  	2701,ic		006047
						STATEMENT 1 ON LINE 506
	eop_sentinel = byte (eop_sentinel_octal);

000633  aa   000377 2360 07	ldq  	255,dl
000634  aa   000077 7370 00	lls  	63
000635  aa  6 00310 7551 00	sta  	pr6|200		eop_sentinel
						STATEMENT 1 ON LINE 508
	if ^tcb.modes.rawom				/* if we're interested in conversion */
	then do;

000636  aa  6 00330 3715 20	epp5 	pr6|216,*		tcbp
000637  aa  5 00017 2351 00	lda  	pr5|15		tcb.rawom
000640  aa   004000 3150 03	cana 	2048,du
000641  aa   000053 6010 04	tnz  	43,ic		000714
						STATEMENT 1 ON LINE 510
	     ttytp = addr (tty_tables$);

000642  la  4 00030 3535 20	epp3 	pr4|24,*		tty_tables$
000643  aa  6 00114 2535 00	spri3	pr6|76		ttytp
						STATEMENT 1 ON LINE 511
	     if tcb.output_tctrp = ""b
	     then tctp = null;

000644  aa  5 00011 2351 00	lda  	pr5|9		tcb.output_tctrp
000645  aa   000022 7350 00	als  	18
000646  aa  6 00357 7551 00	sta  	pr6|239		tcb.output_tctrp
000647  aa   000004 6010 04	tnz  	4,ic		000653
000650  aa   777256 2370 04	ldaq 	-338,ic		000126 = 077777000043 000001000000
000651  aa  6 00116 7571 00	staq 	pr6|78		tctp
000652  aa   000004 7100 04	tra  	4,ic		000656
						STATEMENT 1 ON LINE 513
	     else tctp = ptr (ttytp, tcb.output_tctrp);

000653  aa  3 00000 3521 00	epp2 	pr3|0
000654  aa   000000 3120 01	eawp2	0,au
000655  aa  6 00116 2521 00	spri2	pr6|78		tctp
						STATEMENT 1 ON LINE 514
	     if tcb.output_mvtrp = ""b
	     then mvtp = null;

000656  aa  5 00010 2351 00	lda  	pr5|8		tcb.output_mvtrp
000657  aa   000022 7350 00	als  	18
000660  aa  6 00357 7551 00	sta  	pr6|239		tcb.output_mvtrp
000661  aa   000004 6010 04	tnz  	4,ic		000665
000662  aa   777244 2370 04	ldaq 	-348,ic		000126 = 077777000043 000001000000
000663  aa  6 00120 7571 00	staq 	pr6|80		mvtp
000664  aa   000004 7100 04	tra  	4,ic		000670
						STATEMENT 1 ON LINE 516
	     else mvtp = ptr (ttytp, tcb.output_mvtrp);

000665  aa  3 00000 3521 00	epp2 	pr3|0
000666  aa   000000 3120 01	eawp2	0,au
000667  aa  6 00120 2521 00	spri2	pr6|80		mvtp
						STATEMENT 1 ON LINE 517
	     if tcb.specialrp = ""b
	     then special_ptr = null;

000670  aa  5 00012 2351 00	lda  	pr5|10		tcb.specialrp
000671  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000672  aa  6 00357 7551 00	sta  	pr6|239		tcb.specialrp
000673  aa   000004 6010 04	tnz  	4,ic		000677
000674  aa   777232 2370 04	ldaq 	-358,ic		000126 = 077777000043 000001000000
000675  aa  6 00122 7571 00	staq 	pr6|82		special_ptr
000676  aa   000004 7100 04	tra  	4,ic		000702
						STATEMENT 1 ON LINE 519
	     else special_ptr = ptr (ttytp, tcb.specialrp);

000677  aa  3 00000 3521 00	epp2 	pr3|0
000700  aa   000000 3120 01	eawp2	0,au
000701  aa  6 00122 2521 00	spri2	pr6|82		special_ptr
						STATEMENT 1 ON LINE 520
	     if tcb.delayrp = ""b
	     then delay_ptr = null;

000702  aa  5 00012 2351 00	lda  	pr5|10		tcb.delayrp
000703  aa   000022 7350 00	als  	18
000704  aa  6 00357 7551 00	sta  	pr6|239		tcb.delayrp
000705  aa   000004 6010 04	tnz  	4,ic		000711
000706  aa   777220 2370 04	ldaq 	-368,ic		000126 = 077777000043 000001000000
000707  aa  6 00124 7571 00	staq 	pr6|84		delay_ptr
000710  aa   000004 7100 04	tra  	4,ic		000714
						STATEMENT 1 ON LINE 522
	     else delay_ptr = ptr (ttytp, tcb.delayrp);

000711  aa  3 00000 3521 00	epp2 	pr3|0
000712  aa   000000 3120 01	eawp2	0,au
000713  aa  6 00124 2521 00	spri2	pr6|84		delay_ptr
						STATEMENT 1 ON LINE 523
	end;

						STATEMENT 1 ON LINE 528
	if forcesw
	then max_space = tty_buf.bleft - 32;

000714  aa  6 00110 2351 00	lda  	pr6|72		forcesw
000715  aa   000006 6000 04	tze  	6,ic		000723
000716  aa  6 00322 3535 20	epp3 	pr6|210,*		ttybp
000717  aa  3 00003 2361 00	ldq  	pr3|3		tty_buf.bleft
000720  aa   000040 1760 07	sbq  	32,dl
000721  aa  6 00126 7561 00	stq  	pr6|86		max_space
000722  aa   000057 7100 04	tra  	47,ic		001001
						STATEMENT 1 ON LINE 530
	else do;

						STATEMENT 1 ON LINE 531
	     cur_space = 0;

000723  aa  6 00255 4501 00	stz  	pr6|173		cur_space
						STATEMENT 1 ON LINE 532
	     cur_chain_len = 0;

000724  aa  6 00256 4501 00	stz  	pr6|174		cur_chain_len
						STATEMENT 1 ON LINE 533
	     if wtcb.write_first ^= 0
	     then do;

000725  aa  7 00016 2351 00	lda  	pr7|14		wtcb.write_first
000726  aa   000066 7330 00	lrs  	54
000727  aa   000031 6000 04	tze  	25,ic		000760
						STATEMENT 1 ON LINE 535
		blockp = ptr (ttybp, wtcb.write_first);

000730  aa  6 00322 3521 20	epp2 	pr6|210,*		ttybp
000731  aa   000000 3120 06	eawp2	0,ql
000732  aa  6 00324 2521 00	spri2	pr6|212		blockp
						STATEMENT 1 ON LINE 536
		end_chain = "0"b;

000733  aa  6 00257 4501 00	stz  	pr6|175		end_chain
						STATEMENT 1 ON LINE 537
		do while (^end_chain);

000734  aa  6 00257 2351 00	lda  	pr6|175		end_chain
000735  aa   000023 6010 04	tnz  	19,ic		000760
						STATEMENT 1 ON LINE 538
		     cur_space = cur_space + 16 * (buffer.size_code + 1);

000736  aa  6 00324 2351 20	lda  	pr6|212,*		buffer.size_code
000737  aa   000030 7350 00	als  	24
000740  aa   000105 7730 00	lrl  	69
000741  aa   000001 0760 07	adq  	1,dl
000742  aa   000004 7360 00	qls  	4
000743  aa  6 00255 0561 00	asq  	pr6|173		cur_space
						STATEMENT 1 ON LINE 539
		     cur_chain_len = cur_chain_len + 1;

000744  aa  6 00256 0541 00	aos  	pr6|174		cur_chain_len
						STATEMENT 1 ON LINE 540
		     if buffer.next = 0
		     then end_chain = "1"b;

000745  aa  6 00324 2351 20	lda  	pr6|212,*		buffer.next
000746  aa   000066 7730 00	lrl  	54
000747  aa  6 00357 7561 00	stq  	pr6|239		buffer.next
000750  aa   000004 6010 04	tnz  	4,ic		000754
000751  aa   400000 2350 03	lda  	131072,du
000752  aa  6 00257 7551 00	sta  	pr6|175		end_chain
000753  aa   777761 7100 04	tra  	-15,ic		000734
						STATEMENT 1 ON LINE 542
		     else blockp = ptr (ttybp, buffer.next);

000754  aa  6 00322 3521 20	epp2 	pr6|210,*		ttybp
000755  aa   000000 3120 06	eawp2	0,ql
000756  aa  6 00324 2521 00	spri2	pr6|212		blockp
						STATEMENT 1 ON LINE 543
		end;

000757  aa   777755 7100 04	tra  	-19,ic		000734
						STATEMENT 1 ON LINE 544
	     end;

						STATEMENT 1 ON LINE 545
	     max_space =
		min (divide (tty_buf.bleft, output_bpart, 17, 0) - cur_space,
		(max_chain_len - cur_chain_len) * (wtcb.max_buf_size - 1));

000760  aa  6 00326 3735 20	epp7 	pr6|214,*		wtcbp
000761  aa  7 00020 2351 00	lda  	pr7|16		wtcb.max_buf_size
000762  aa   000077 7730 00	lrl  	63
000763  aa   000001 1760 07	sbq  	1,dl
000764  aa  6 00357 7561 00	stq  	pr6|239
000765  aa   000020 2360 07	ldq  	16,dl
000766  aa  6 00256 1761 00	sbq  	pr6|174		cur_chain_len
000767  aa  6 00357 4021 00	mpy  	pr6|239
000770  aa  6 00357 7561 00	stq  	pr6|239
000771  aa  6 00322 3715 20	epp5 	pr6|210,*		ttybp
000772  aa  5 00003 2361 00	ldq  	pr5|3		tty_buf.bleft
000773  aa   000004 5060 07	div  	4,dl
000774  aa  6 00255 1761 00	sbq  	pr6|173		cur_space
000775  aa  6 00357 1161 00	cmpq 	pr6|239
000776  aa   000002 6040 04	tmi  	2,ic		001000
000777  aa  6 00357 2361 00	ldq  	pr6|239
001000  aa  6 00126 7561 00	stq  	pr6|86		max_space
						STATEMENT 1 ON LINE 548
	end;

						STATEMENT 1 ON LINE 550
	max_chars_in_buf = 4 * (wtcb.max_buf_size - 1) - wtcb.buffer_pad;

001001  aa  7 00020 2351 00	lda  	pr7|16		wtcb.buffer_pad
001002  aa   000011 7350 00	als  	9
001003  aa   000077 7730 00	lrl  	63
001004  aa  6 00357 7561 00	stq  	pr6|239		wtcb.buffer_pad
001005  aa  7 00020 2351 00	lda  	pr7|16		wtcb.max_buf_size
001006  aa   000077 7730 00	lrl  	63
001007  aa   000001 1760 07	sbq  	1,dl
001010  aa   000002 7360 00	qls  	2
001011  aa  6 00357 1761 00	sbq  	pr6|239		wtcb.buffer_pad
001012  aa  6 00130 7561 00	stq  	pr6|88		max_chars_in_buf
						STATEMENT 1 ON LINE 552
	if max_space <= 0
	then 
NO_SPACE_WRITE_NOTHING:
	do;

001013  aa  6 00126 2361 00	ldq  	pr6|86		max_space
001014  aa   000003 6054 04	tpnz 	3,ic		001017
						STATEMENT 1 ON LINE 556
	     nelemt = 0;

001015  aa  6 00106 4501 00	stz  	pr6|70		nelemt
						STATEMENT 1 ON LINE 557
	     go to nothing_written;

001016  aa   005135 7100 04	tra  	2653,ic		006153
						STATEMENT 1 ON LINE 558
	end;

						STATEMENT 1 ON LINE 560
	max_chars = min (4 * max_space, LONGEST_POSSIBLE_STRING);

001017  aa   000002 7360 00	qls  	2
001020  aa   017700 1160 07	cmpq 	8128,dl
001021  aa   000002 6040 04	tmi  	2,ic		001023
001022  aa   017700 2360 07	ldq  	8128,dl
001023  aa  6 00127 7561 00	stq  	pr6|87		max_chars
						STATEMENT 1 ON LINE 565
	auto_buf_len = min (max_chars, 512 + 2 * nelem);

001024  aa  6 00105 2361 00	ldq  	pr6|69		nelem
001025  aa   000001 7360 00	qls  	1
001026  aa   001000 0760 07	adq  	512,dl
001027  aa  6 00127 1161 00	cmpq 	pr6|87		max_chars
001030  aa   000002 6040 04	tmi  	2,ic		001032
001031  aa  6 00127 2361 00	ldq  	pr6|87		max_chars
001032  aa  6 00306 7561 00	stq  	pr6|198		auto_buf_len
						STATEMENT 1 ON LINE 566
	max_chars = auto_buf_len;

001033  aa  6 00127 7561 00	stq  	pr6|87		max_chars
						STATEMENT 1 ON LINE 567
	if whole_string & nelem > max_chars		/* can't possibly take all of this */
	then do;

001034  aa  6 00112 2351 00	lda  	pr6|74		whole_string
001035  aa   000012 6000 04	tze  	10,ic		001047
001036  aa  6 00105 1161 00	cmpq 	pr6|69		nelem
001037  aa   000010 6050 04	tpl  	8,ic		001047
						STATEMENT 1 ON LINE 569
	     if nelem <= LONGEST_POSSIBLE_STRING
	     then go to NO_SPACE_WRITE_NOTHING;

001040  aa  6 00105 2361 00	ldq  	pr6|69		nelem
001041  aa   017700 1160 07	cmpq 	8128,dl
001042  aa   777753 6044 04	tmoz 	-21,ic		001015
						STATEMENT 1 ON LINE 571
	     ercode = error_table_$bigarg;

001043  aa  6 00044 3701 20	epp4 	pr6|36,*
001044  la  4 00046 2361 20	ldq  	pr4|38,*		error_table_$bigarg
001045  aa  6 00344 7561 20	stq  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 572
	     go to unlock;

001046  aa   005061 7100 04	tra  	2609,ic		006127
						STATEMENT 1 ON LINE 573
	end;

						STATEMENT 1 ON LINE 575
	begin;

001047  aa   000520 6270 00	eax7 	336
001050  aa  0 00614 2721 00	tsp2 	pr0|396		enter_begin_block
001051  aa     000000000000
BEGIN BLOCK  1
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 577
001052  aa  6 00040 3735 20	epp7 	pr6|32,*
001053  aa  7 00306 2361 00	ldq  	pr7|198		auto_buf_len
001054  aa  6 00100 7561 00	stq  	pr6|64
001055  aa   000003 0760 07	adq  	3,dl
001056  aa   000002 7320 00	qrs  	2
001057  aa  6 00101 7561 00	stq  	pr6|65
001060  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
001061  aa  6 00102 2521 00	spri2	pr6|66
						STATEMENT 1 ON LINE 578
001062  aa  7 00306 2361 00	ldq  	pr7|198		auto_buf_len
001063  aa  6 00104 7561 00	stq  	pr6|68
001064  aa   000003 0760 07	adq  	3,dl
001065  aa   000002 7320 00	qrs  	2
001066  aa  6 00105 7561 00	stq  	pr6|69
001067  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
001070  aa  6 00106 2521 00	spri2	pr6|70
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 580
	     input_ptr = readp;

001071  aa  7 00102 3715 20	epp5 	pr7|66,*		readp
001072  aa  7 00132 6515 00	spri5	pr7|90		input_ptr
						STATEMENT 1 ON LINE 581
	     input_ptr = addr (input_ptr -> based_chars (offset));

001073  aa  7 00104 2351 00	lda  	pr7|68		offset
001074  aa  7 00132 3521 20	epp2 	pr7|90,*		based_chars
001075  aa  2 00000 5005 05	a9bd 	pr2|0,al
001076  aa  7 00132 2521 00	spri2	pr7|90		input_ptr
						STATEMENT 1 ON LINE 583
	     nelemt = -1;

001077  aa   000001 3360 07	lcq  	1,dl
001100  aa  7 00106 7561 00	stq  	pr7|70		nelemt
						STATEMENT 1 ON LINE 585
restart:						/* come here if we have to start over */
	     if tcb.modes.rawom			/* raw output, simple */
	     then do;

001101  aa  6 00040 3735 20	epp7 	pr6|32,*
001102  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
001103  aa  5 00017 2351 00	lda  	pr5|15		tcb.rawom
001104  aa   004000 3150 03	cana 	2048,du
001105  aa   000014 6000 04	tze  	12,ic		001121
						STATEMENT 1 ON LINE 588
		final_outp = input_ptr;

001106  aa  7 00132 3535 20	epp3 	pr7|90,*		input_ptr
001107  aa  7 00134 2535 00	spri3	pr7|92		final_outp
						STATEMENT 1 ON LINE 589
		if nelemt < 0			/* i.e. not restart */
		then nelemt = min (nelem, max_chars);

001110  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
001111  aa   000006 6050 04	tpl  	6,ic		001117
001112  aa  7 00105 2361 00	ldq  	pr7|69		nelem
001113  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
001114  aa   000002 6040 04	tmi  	2,ic		001116
001115  aa  7 00127 2361 00	ldq  	pr7|87		max_chars
001116  aa  7 00106 7561 00	stq  	pr7|70		nelemt
						STATEMENT 1 ON LINE 591
		output_length = nelemt;

001117  aa  7 00136 7561 00	stq  	pr7|94		output_length
						STATEMENT 1 ON LINE 592
	     end;

001120  aa   000201 7100 04	tra  	129,ic		001321
						STATEMENT 1 ON LINE 594
	     else do;

						STATEMENT 1 ON LINE 595
		if nelemt < 0			/* if not already set */
		then nelemt = min (nelem, fixed (reduction_factor * max_chars));

001121  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
001122  aa   000011 6050 04	tpl  	9,ic		001133
001123  aa  7 00127 2361 00	ldq  	pr7|87		max_chars
001124  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
001125  aa   776763 4610 04	fmp  	-525,ic		000110 = 000631463146
001126  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
001127  aa  7 00105 1161 00	cmpq 	pr7|69		nelem
001130  aa   000002 6040 04	tmi  	2,ic		001132
001131  aa  7 00105 2361 00	ldq  	pr7|69		nelem
001132  aa  7 00106 7561 00	stq  	pr7|70		nelemt
						STATEMENT 1 ON LINE 598
		line_count = wtcb.actline;

001133  aa  7 00326 3535 20	epp3 	pr7|214,*		wtcbp
001134  aa  3 00015 2351 00	lda  	pr3|13		wtcb.actline
001135  aa   000011 7350 00	als  	9
001136  aa   000077 7730 00	lrl  	63
001137  aa  7 00166 7561 00	stq  	pr7|118		line_count
						STATEMENT 1 ON LINE 599
		col = wtcb.actcol;

001140  aa  3 00015 2351 00	lda  	pr3|13		wtcb.actcol
001141  aa   000022 7350 00	als  	18
001142  aa   000077 7730 00	lrl  	63
001143  aa  7 00167 7561 00	stq  	pr7|119		col
						STATEMENT 1 ON LINE 600
		wcol = wtcb.white_col;

001144  aa  3 00017 2351 00	lda  	pr3|15		wtcb.white_col
001145  aa   000022 7350 00	als  	18
001146  aa   000066 7330 00	lrs  	54
001147  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 602
		final_outp, source_ptr = input_ptr;

001150  aa  7 00132 3515 20	epp1 	pr7|90,*		input_ptr
001151  aa  7 00134 2515 00	spri1	pr7|92		final_outp
001152  aa  7 00140 2515 00	spri1	pr7|96		source_ptr
						STATEMENT 1 ON LINE 603
		source_len = nelemt;

001153  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
001154  aa  7 00142 7561 00	stq  	pr7|98		source_len
						STATEMENT 1 ON LINE 604
		target_ptr = addr (buffer_1);

001155  aa  6 00102 3715 20	epp5 	pr6|66,*		buffer_1
001156  aa  7 00144 6515 00	spri5	pr7|100		target_ptr
						STATEMENT 1 ON LINE 605
		target_len = 0;

001157  aa  7 00146 4501 00	stz  	pr7|102		target_len
						STATEMENT 1 ON LINE 607
		if tcb.modes.upper_case
		then call convert_to_upper_case;

001160  aa  7 00330 3535 20	epp3 	pr7|216,*		tcbp
001161  aa  3 00017 2351 00	lda  	pr3|15		tcb.upper_case
001162  aa   000004 3150 03	cana 	4,du
001163  aa   000002 6000 04	tze  	2,ic		001165
001164  aa   003451 6700 04	tsp4 	1833,ic		004635
						STATEMENT 1 ON LINE 612
		if tctp ^= null			/* must have output conversion table */
		     & special_ptr ^= null		/* and special chars table too */
		then do;

001165  aa  6 00040 3735 20	epp7 	pr6|32,*
001166  aa  7 00116 2371 00	ldaq 	pr7|78		tctp
001167  aa   776737 6770 04	eraq 	-545,ic		000126 = 077777000043 000001000000
001170  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001171  aa   000115 6000 04	tze  	77,ic		001306
001172  aa  7 00122 2371 00	ldaq 	pr7|82		special_ptr
001173  aa   776733 6770 04	eraq 	-549,ic		000126 = 077777000043 000001000000
001174  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001175  aa   000111 6000 04	tze  	73,ic		001306
						STATEMENT 1 ON LINE 615
		     target_len = 0;

001176  aa  7 00146 4501 00	stz  	pr7|102		target_len
						STATEMENT 1 ON LINE 616
		     chars_moved = "0"b;

001177  aa  7 00164 4501 00	stz  	pr7|116		chars_moved
						STATEMENT 1 ON LINE 617
		     white_sw = (wcol ^= col);

001200  aa  7 00170 2361 00	ldq  	pr7|120		wcol
001201  aa  7 00167 1161 00	cmpq 	pr7|119		col
001202  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001203  aa  7 00165 7551 00	sta  	pr7|117		white_sw
						STATEMENT 1 ON LINE 619
		     final_outp = target_ptr;

001204  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
001205  aa  7 00134 6515 00	spri5	pr7|92		final_outp
						STATEMENT 1 ON LINE 621
		     if tcb.linemax > 0
		     then do;

001206  aa  7 00330 3535 20	epp3 	pr7|216,*		tcbp
001207  aa  3 00021 2351 00	lda  	pr3|17		tcb.linemax
001210  aa   000011 7350 00	als  	9
001211  aa   000077 7330 00	lrs  	63
001212  aa   000026 6044 04	tmoz 	22,ic		001240
						STATEMENT 1 ON LINE 623
			if line_count >= tcb.linemax	/* did input cause EOP condition ? */
			then do;

001213  aa  7 00166 1161 00	cmpq 	pr7|118		line_count
001214  aa   000024 6054 04	tpnz 	20,ic		001240
						STATEMENT 1 ON LINE 625
			     seqp = addr (special_ptr -> special_chars.end_of_page);

001215  aa  7 00122 3515 20	epp1 	pr7|82,*		special_ptr
001216  aa  1 00050 3515 00	epp1 	pr1|40		special_chars.end_of_page
001217  aa  7 00174 2515 00	spri1	pr7|124		seqp
						STATEMENT 1 ON LINE 626
			     if seqp -> seq.count > 0	/* must have something to write */
			     then do;

001220  aa  1 00000 2351 00	lda  	pr1|0		seq.count
001221  aa   000077 7330 00	lrs  	63
001222  aa   000016 6044 04	tmoz 	14,ic		001240
						STATEMENT 1 ON LINE 628
				call insert_sequence ("0"b);

001223  aa   000000 2350 07	lda  	0,dl
001224  aa  6 00316 7551 00	sta  	pr6|206
001225  aa   005235 3520 04	epp2 	2717,ic		006462 = 000002000000
001226  aa   001635 6700 04	tsp4 	925,ic		003063
						STATEMENT 1 ON LINE 629
				call insert_char (eop_sentinel);

001227  aa  6 00040 3735 20	epp7 	pr6|32,*
001230  aa  7 00310 3521 00	epp2 	pr7|200		eop_sentinel
001231  aa  6 00322 2521 00	spri2	pr6|210
001232  aa  6 00320 3521 00	epp2 	pr6|208
001233  aa   004000 4310 07	fld  	2048,dl
001234  aa  2 00000 7571 00	staq 	pr2|0
001235  aa   001541 6700 04	tsp4 	865,ic		002776
						STATEMENT 1 ON LINE 630
				line_count = 0;

001236  aa  6 00040 3735 20	epp7 	pr6|32,*
001237  aa  7 00166 4501 00	stz  	pr7|118		line_count
						STATEMENT 1 ON LINE 631
			     end;

						STATEMENT 1 ON LINE 632
			end;

						STATEMENT 1 ON LINE 633
		     end;

						STATEMENT 1 ON LINE 635
		     util.tablep = tctp;

001240  aa  7 00116 3715 20	epp5 	pr7|78,*		tctp
001241  aa  7 00266 6515 00	spri5	pr7|182		util.tablep
						STATEMENT 1 ON LINE 636
		     util.stringp = source_ptr;

001242  aa  7 00140 3535 20	epp3 	pr7|96,*		source_ptr
001243  aa  7 00262 2535 00	spri3	pr7|178		util.stringp
						STATEMENT 1 ON LINE 637
		     util.stringl = source_len;

001244  aa  7 00142 2361 00	ldq  	pr7|98		source_len
001245  aa  7 00264 7561 00	stq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 639
		     do while (util.stringl > 0);

001246  aa  6 00040 3735 20	epp7 	pr6|32,*
001247  aa  7 00264 2361 00	ldq  	pr7|180		util.stringl
001250  aa   000023 6044 04	tmoz 	19,ic		001273
						STATEMENT 1 ON LINE 641
			oldcol = col;

001251  aa  7 00167 2361 00	ldq  	pr7|119		col
001252  aa  7 00171 7561 00	stq  	pr7|121		oldcol
						STATEMENT 1 ON LINE 642
			call tty_util_$find_char (addr (util));

001253  aa  7 00262 3715 00	epp5 	pr7|178		util
001254  aa  6 00314 6515 00	spri5	pr6|204
001255  aa  6 00314 3521 00	epp2 	pr6|204
001256  aa  6 00322 2521 00	spri2	pr6|210
001257  aa  6 00320 6211 00	eax1 	pr6|208
001260  aa   004000 4310 07	fld  	2048,dl
001261  aa  6 00044 3701 20	epp4 	pr6|36,*
001262  la  4 00024 3521 20	epp2 	pr4|20,*		tty_util_$find_char
001263  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 645
			call move_formated_chars;

001264  aa   003614 6700 04	tsp4 	1932,ic		005100
						STATEMENT 1 ON LINE 647
			if ^white_sw
			then wcol = col;

001265  aa  6 00040 3735 20	epp7 	pr6|32,*
001266  aa  7 00165 2351 00	lda  	pr7|117		white_sw
001267  aa   777757 6010 04	tnz  	-17,ic		001246
001270  aa  7 00167 2361 00	ldq  	pr7|119		col
001271  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 650
		     end;

001272  aa   777754 7100 04	tra  	-20,ic		001246
						STATEMENT 1 ON LINE 652
		     if white_sw			/* take care of trailing white space */
		     then if nelemt = nelem		/* if output really ends in white space */
			then call insert_white;

001273  aa  7 00165 2351 00	lda  	pr7|117		white_sw
001274  aa   000014 6000 04	tze  	12,ic		001310
001275  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
001276  aa  7 00105 1161 00	cmpq 	pr7|69		nelem
001277  aa   000003 6010 04	tnz  	3,ic		001302
001300  aa   001723 6700 04	tsp4 	979,ic		003223
001301  aa   000007 7100 04	tra  	7,ic		001310
						STATEMENT 1 ON LINE 655
			else if target_len = 0	/* only white? */
			     then call insert_white;

001302  aa  7 00146 2361 00	ldq  	pr7|102		target_len
001303  aa   000005 6010 04	tnz  	5,ic		001310
001304  aa   001717 6700 04	tsp4 	975,ic		003223
						STATEMENT 1 ON LINE 658
		end;

001305  aa   000003 7100 04	tra  	3,ic		001310
						STATEMENT 1 ON LINE 660
		else target_len = source_len;

001306  aa  7 00142 2361 00	ldq  	pr7|98		source_len
001307  aa  7 00146 7561 00	stq  	pr7|102		target_len
						STATEMENT 1 ON LINE 662
		if mvtp ^= null
		then call translation;

001310  aa  6 00040 3735 20	epp7 	pr6|32,*
001311  aa  7 00120 2371 00	ldaq 	pr7|80		mvtp
001312  aa   776614 6770 04	eraq 	-628,ic		000126 = 077777000043 000001000000
001313  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001314  aa   000002 6000 04	tze  	2,ic		001316
001315  aa   003052 6700 04	tsp4 	1578,ic		004367
						STATEMENT 1 ON LINE 665
		output_length = target_len;

001316  aa  6 00040 3735 20	epp7 	pr6|32,*
001317  aa  7 00146 2361 00	ldq  	pr7|102		target_len
001320  aa  7 00136 7561 00	stq  	pr7|94		output_length
						STATEMENT 1 ON LINE 666
	     end;

						STATEMENT 1 ON LINE 670
	     new_char_count, new_buffer_count = 0;

001321  aa  7 00201 4501 00	stz  	pr7|129		new_char_count
001322  aa  7 00237 4501 00	stz  	pr7|159		new_buffer_count
						STATEMENT 1 ON LINE 672
	     if output_length > 0			/* assuming there's anything left after conversion */
	     then do;

001323  aa  7 00136 2361 00	ldq  	pr7|94		output_length
001324  aa   001222 6044 04	tmoz 	658,ic		002546
						STATEMENT 1 ON LINE 674
		first_buffer = "1"b;

001325  aa   400000 2350 03	lda  	131072,du
001326  aa  7 00240 7551 00	sta  	pr7|160		first_buffer
						STATEMENT 1 ON LINE 675
		old_end_frame = wtcb.end_frame;

001327  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001330  aa  5 00013 2351 00	lda  	pr5|11		wtcb.end_frame
001331  aa   000005 7350 00	als  	5
001332  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001333  aa  7 00204 7551 00	sta  	pr7|132		old_end_frame
						STATEMENT 1 ON LINE 677
		if wtcb.write_last = 0
		then do;

001334  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
001335  aa   000022 7350 00	als  	18
001336  aa   000066 7330 00	lrs  	54
001337  aa  6 00317 7561 00	stq  	pr6|207		wtcb.write_last
001340  aa   000006 6010 04	tnz  	6,ic		001346
						STATEMENT 1 ON LINE 679
		     send = "1"b;

001341  aa   400000 2350 03	lda  	131072,du
001342  aa  7 00222 7551 00	sta  	pr7|146		send
						STATEMENT 1 ON LINE 680
		     old_head, old_tail = 0;

001343  aa  7 00202 4501 00	stz  	pr7|130		old_head
001344  aa  7 00203 4501 00	stz  	pr7|131		old_tail
						STATEMENT 1 ON LINE 681
		end;

001345  aa   000017 7100 04	tra  	15,ic		001364
						STATEMENT 1 ON LINE 683
		else do;

						STATEMENT 1 ON LINE 684
		     lastp, old_lastp = ptr (ttybp, wtcb.write_last);

001346  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
001347  aa   000000 3120 06	eawp2	0,ql
001350  aa  6 00314 2521 00	spri2	pr6|204
001351  aa  7 00226 2521 00	spri2	pr7|150		lastp
001352  aa  7 00242 2521 00	spri2	pr7|162		old_lastp
						STATEMENT 1 ON LINE 685
		     send = "0"b;

001353  aa  7 00222 4501 00	stz  	pr7|146		send
						STATEMENT 1 ON LINE 686
		     old_head = wtcb.write_first;

001354  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001355  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_first
001356  aa   000066 7330 00	lrs  	54
001357  aa  7 00202 7561 00	stq  	pr7|130		old_head
						STATEMENT 1 ON LINE 687
		     old_tail = wtcb.write_last;

001360  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
001361  aa   000022 7350 00	als  	18
001362  aa   000066 7330 00	lrs  	54
001363  aa  7 00203 7561 00	stq  	pr7|131		old_tail
						STATEMENT 1 ON LINE 688
		end;

						STATEMENT 1 ON LINE 690
		n_pages = 0;

001364  aa  7 00224 4501 00	stz  	pr7|148		n_pages
						STATEMENT 1 ON LINE 691
		headp = null;

001365  aa   776541 2370 04	ldaq 	-671,ic		000126 = 077777000043 000001000000
001366  aa  7 00220 7571 00	staq 	pr7|144		headp
						STATEMENT 1 ON LINE 692
		new_head = 0;

001367  aa  7 00223 4501 00	stz  	pr7|147		new_head
						STATEMENT 1 ON LINE 693
		allocated_buffers = "1"b;

001370  aa   400000 2350 03	lda  	131072,du
001371  aa  7 00307 7551 00	sta  	pr7|199		allocated_buffers
						STATEMENT 1 ON LINE 695
		do while (output_length > 0);

001372  aa  6 00040 3735 20	epp7 	pr6|32,*
001373  aa  7 00136 2361 00	ldq  	pr7|94		output_length
001374  aa   000670 6044 04	tmoz 	440,ic		002264
						STATEMENT 1 ON LINE 696
		     n_pages = n_pages + 1;

001375  aa  7 00224 0541 00	aos  	pr7|148		n_pages
						STATEMENT 1 ON LINE 698
		     if tcb.modes.rawom		/* if raw mode don't check for end of page */
		     then go to no_break;

001376  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
001377  aa  5 00017 2351 00	lda  	pr5|15		tcb.rawom
001400  aa   004000 3150 03	cana 	2048,du
001401  aa   000013 6010 04	tnz  	11,ic		001414
						STATEMENT 1 ON LINE 701
		     break_length = index (final_outp -> output_chars, eop_sentinel) - 1;

001402  aa  7 00134 3535 20	epp3 	pr7|92,*		final_outp
001403  aa  000 100 124 540	scm  	(pr,rl),(pr),mask(000)
001404  aa  3 00000 00 0006	desc9a	pr3|0,ql		output_chars
001405  aa  7 00310 00 0001	desc9a	pr7|200,1		eop_sentinel
001406  aa  6 00056 0001 00	arg  	pr6|46
001407  aa  6 00056 2361 00	ldq  	pr6|46
001410  aa   000002 6070 04	ttf  	2,ic		001412
001411  aa   000001 3360 07	lcq  	1,dl
001412  aa  7 00205 7561 00	stq  	pr7|133		break_length
						STATEMENT 1 ON LINE 703
		     if break_length < 0
		     then do;

001413  aa   000005 6050 04	tpl  	5,ic		001420
						STATEMENT 1 ON LINE 705
no_break:
			break_flag = "0"b;

001414  aa  7 00206 4501 00	stz  	pr7|134		break_flag
						STATEMENT 1 ON LINE 707
			break_length = output_length;

001415  aa  7 00136 2361 00	ldq  	pr7|94		output_length
001416  aa  7 00205 7561 00	stq  	pr7|133		break_length
						STATEMENT 1 ON LINE 708
		     end;

001417  aa   000021 7100 04	tra  	17,ic		001440
						STATEMENT 1 ON LINE 710
		     else do;

						STATEMENT 1 ON LINE 711
			break_flag = "1"b;

001420  aa   400000 2350 03	lda  	131072,du
001421  aa  7 00206 7551 00	sta  	pr7|134		break_flag
						STATEMENT 1 ON LINE 712
			if break_length = 0
			then do;

001422  aa  7 00205 2361 00	ldq  	pr7|133		break_length
001423  aa   000014 6010 04	tnz  	12,ic		001437
						STATEMENT 1 ON LINE 714
			     final_outp -> based_chars (0) = byte (delay_char);

001424  aa   000000 2360 07	ldq  	0,dl
001425  aa   000077 7370 00	lls  	63
001426  aa  6 00056 7551 00	sta  	pr6|46
001427  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001430  aa  6 00056 00 0001	desc9a	pr6|46,1
001431  aa  3 00000 00 0001	desc9a	pr3|0,1		based_chars
						STATEMENT 1 ON LINE 716
			     break_length = 1;

001432  aa   000001 2360 07	ldq  	1,dl
001433  aa  7 00205 7561 00	stq  	pr7|133		break_length
						STATEMENT 1 ON LINE 717
			     null_for_eop = "1"b;

001434  aa   400000 2350 03	lda  	131072,du
001435  aa  7 00207 7551 00	sta  	pr7|135		null_for_eop
						STATEMENT 1 ON LINE 718
			end;

001436  aa   000002 7100 04	tra  	2,ic		001440
						STATEMENT 1 ON LINE 719
			else null_for_eop = "0"b;

001437  aa  7 00207 4501 00	stz  	pr7|135		null_for_eop
						STATEMENT 1 ON LINE 720
		     end;

						STATEMENT 1 ON LINE 722
		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
						/* new buffer at every end-of-block */
		     then break_length = min (break_length, tcb.max_output_block);

001440  aa  5 00023 2361 00	ldq  	pr5|19		tcb.max_output_block
001441  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001442  aa  6 00317 7561 00	stq  	pr6|207		tcb.max_output_block
001443  aa  5 00030 2351 00	lda  	pr5|24		tcb.block_acknowledge
001444  aa   004000 3150 03	cana 	2048,du
001445  aa   000012 6000 04	tze  	10,ic		001457
001446  aa  5 00017 2351 00	lda  	pr5|15		tcb.oflow
001447  aa   002000 3150 07	cana 	1024,dl
001450  aa   000007 6000 04	tze  	7,ic		001457
001451  aa  6 00317 2361 00	ldq  	pr6|207		tcb.max_output_block
001452  aa   000005 6044 04	tmoz 	5,ic		001457
001453  aa  7 00205 1161 00	cmpq 	pr7|133		break_length
001454  aa   000002 6040 04	tmi  	2,ic		001456
001455  aa  7 00205 2361 00	ldq  	pr7|133		break_length
001456  aa  7 00205 7561 00	stq  	pr7|133		break_length
						STATEMENT 1 ON LINE 726
		     output_length = output_length - break_length;

001457  aa  7 00205 3361 00	lcq  	pr7|133		break_length
001460  aa  7 00136 0561 00	asq  	pr7|94		output_length
						STATEMENT 1 ON LINE 728
		     do while (break_length > 0);

001461  aa   000000 0110 03	nop  	0,du
001462  aa  6 00040 3735 20	epp7 	pr6|32,*
001463  aa  7 00205 2361 00	ldq  	pr7|133		break_length
001464  aa   000466 6044 04	tmoz 	310,ic		002152
						STATEMENT 1 ON LINE 732
			if wtcb.write_last = 0
			then go to get_new_buf;

001465  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001466  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
001467  aa   000022 7350 00	als  	18
001470  aa   000066 7330 00	lrs  	54
001471  aa   000277 6000 04	tze  	191,ic		001770
						STATEMENT 1 ON LINE 734
			if lastp -> buffer.tally < max_chars_in_buf & ^lastp -> buffer.flags.end_of_page
			     & ^(tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0)
			then do;

001472  aa  7 00226 2361 20	ldq  	pr7|150,*		buffer.tally
001473  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001474  aa  6 00317 7561 00	stq  	pr6|207		buffer.tally
001475  aa  7 00130 1161 00	cmpq 	pr7|88		max_chars_in_buf
001476  aa   000272 6050 04	tpl  	186,ic		001770
001477  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.end_of_page
001500  aa   400000 3150 07	cana 	131072,dl
001501  aa   000267 6010 04	tnz  	183,ic		001770
001502  aa  7 00330 3535 20	epp3 	pr7|216,*		tcbp
001503  aa  3 00030 2351 00	lda  	pr3|24		tcb.block_acknowledge
001504  aa   004000 3150 03	cana 	2048,du
001505  aa   000007 6000 04	tze  	7,ic		001514
001506  aa  3 00017 2351 00	lda  	pr3|15		tcb.oflow
001507  aa   002000 3150 07	cana 	1024,dl
001510  aa   000004 6000 04	tze  	4,ic		001514
001511  aa  3 00023 2361 00	ldq  	pr3|19		tcb.max_output_block
001512  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001513  aa   000255 6054 04	tpnz 	173,ic		001770
						STATEMENT 1 ON LINE 737
			     lchar = lastp -> buffer.tally;

001514  aa  6 00317 2361 00	ldq  	pr6|207		buffer.tally
001515  aa  7 00252 7561 00	stq  	pr7|170		lchar
						STATEMENT 1 ON LINE 741
			     buf_size, orig_buf_size = 16 * (lastp -> buffer.size_code + 1);

001516  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.size_code
001517  aa   000030 7350 00	als  	24
001520  aa   000105 7730 00	lrl  	69
001521  aa   000001 0760 07	adq  	1,dl
001522  aa   000004 7360 00	qls  	4
001523  aa  7 00234 7561 00	stq  	pr7|156		buf_size
001524  aa  7 00235 7561 00	stq  	pr7|157		orig_buf_size
						STATEMENT 1 ON LINE 742
			     reached_needed = "0"b;

001525  aa  7 00236 4501 00	stz  	pr7|158		reached_needed
						STATEMENT 1 ON LINE 743
			     do while (^reached_needed);

001526  aa  6 00040 3735 20	epp7 	pr6|32,*
001527  aa  7 00236 2351 00	lda  	pr7|158		reached_needed
001530  aa   000030 6010 04	tnz  	24,ic		001560
						STATEMENT 1 ON LINE 744
				chars_in_buf = 4 * (buf_size - 1) - wtcb.buffer_pad;

001531  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001532  aa  5 00020 2351 00	lda  	pr5|16		wtcb.buffer_pad
001533  aa   000011 7350 00	als  	9
001534  aa   000077 7730 00	lrl  	63
001535  aa  6 00317 7561 00	stq  	pr6|207		wtcb.buffer_pad
001536  aa  7 00234 2361 00	ldq  	pr7|156		buf_size
001537  aa   000001 1760 07	sbq  	1,dl
001540  aa   000002 7360 00	qls  	2
001541  aa  6 00317 1761 00	sbq  	pr6|207		wtcb.buffer_pad
001542  aa  7 00251 7561 00	stq  	pr7|169		chars_in_buf
						STATEMENT 1 ON LINE 745
				if lchar + break_length <= chars_in_buf
						/* room in this buffer for rest of output */
				     | chars_in_buf = max_chars_in_buf
						/* or we've already reached maximum allowable size */
				then reached_needed = "1"b;

001543  aa  7 00252 2361 00	ldq  	pr7|170		lchar
001544  aa  7 00205 0761 00	adq  	pr7|133		break_length
001545  aa  7 00251 1161 00	cmpq 	pr7|169		chars_in_buf
001546  aa   000004 6044 04	tmoz 	4,ic		001552
001547  aa  7 00251 2361 00	ldq  	pr7|169		chars_in_buf
001550  aa  7 00130 1161 00	cmpq 	pr7|88		max_chars_in_buf
001551  aa   000004 6010 04	tnz  	4,ic		001555
001552  aa   400000 2350 03	lda  	131072,du
001553  aa  7 00236 7551 00	sta  	pr7|158		reached_needed
001554  aa   777752 7100 04	tra  	-22,ic		001526
						STATEMENT 1 ON LINE 750
				else buf_size = buf_size + 16;

001555  aa   000020 2360 07	ldq  	16,dl
001556  aa  7 00234 0561 00	asq  	pr7|156		buf_size
						STATEMENT 1 ON LINE 752
			     end;

001557  aa   777747 7100 04	tra  	-25,ic		001526
						STATEMENT 1 ON LINE 754
			     if buf_size ^= orig_buf_size
						/* if we need a new size */
			     then do;

001560  aa  7 00234 2361 00	ldq  	pr7|156		buf_size
001561  aa  7 00235 1161 00	cmpq 	pr7|157		orig_buf_size
001562  aa   000166 6000 04	tze  	118,ic		001750
						STATEMENT 1 ON LINE 757
				call tty_space_man$get_buffer (devx, buf_size, OUTPUT, new_bufp);

001563  aa  7 00101 3521 00	epp2 	pr7|65		devx
001564  aa  6 00330 2521 00	spri2	pr6|216
001565  aa  7 00234 3521 00	epp2 	pr7|156		buf_size
001566  aa  6 00332 2521 00	spri2	pr6|218
001567  aa   776325 3520 04	epp2 	-811,ic		000114 = 400000000000
001570  aa  6 00334 2521 00	spri2	pr6|220
001571  aa  7 00246 3521 00	epp2 	pr7|166		new_bufp
001572  aa  6 00336 2521 00	spri2	pr6|222
001573  aa  6 00326 6211 00	eax1 	pr6|214
001574  aa   020000 4310 07	fld  	8192,dl
001575  aa  6 00044 3701 20	epp4 	pr6|36,*
001576  la  4 00054 3521 20	epp2 	pr4|44,*		tty_space_man$get_buffer
001577  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 758
				if new_bufp ^= null /* only do this if we could get it, of course */
				then do;

001600  aa  6 00040 3735 20	epp7 	pr6|32,*
001601  aa  7 00246 2371 00	ldaq 	pr7|166		new_bufp
001602  aa   776324 6770 04	eraq 	-812,ic		000126 = 077777000043 000001000000
001603  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001604  aa   000132 6000 04	tze  	90,ic		001736
						STATEMENT 1 ON LINE 760
				     nchars = lastp -> buffer.tally;

001605  aa  7 00226 2361 20	ldq  	pr7|150,*		buffer.tally
001606  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001607  aa  7 00254 7561 00	stq  	pr7|172		nchars
						STATEMENT 1 ON LINE 761
				     source_ptr = addr (lastp -> buffer.chars (0));

001610  aa  7 00226 3715 20	epp5 	pr7|150,*		lastp
001611  aa  5 00001 3715 00	epp5 	pr5|1		buffer.chars
001612  aa  7 00140 6515 00	spri5	pr7|96		source_ptr
						STATEMENT 1 ON LINE 762
				     target_ptr = addr (new_bufp -> buffer.chars (0));

001613  aa  7 00246 3535 20	epp3 	pr7|166,*		new_bufp
001614  aa  3 00001 3535 00	epp3 	pr3|1		buffer.chars
001615  aa  7 00144 2535 00	spri3	pr7|100		target_ptr
						STATEMENT 1 ON LINE 763
				     target_ptr -> chars_to_copy = source_ptr -> chars_to_copy;

001616  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001617  aa  5 00000 00 0006	desc9a	pr5|0,ql		chars_to_copy
001620  aa  3 00000 00 0006	desc9a	pr3|0,ql		chars_to_copy
						STATEMENT 1 ON LINE 764
				     new_bufp -> buffer.tally = lastp -> buffer.tally;

001621  aa  7 00246 3515 20	epp1 	pr7|166,*		buffer.tally
001622  aa  1 00000 5521 04	stbq 	pr1|0,04		buffer.tally
						STATEMENT 1 ON LINE 765
				     wtcb.write_last = bin (rel (new_bufp), 18);

001623  aa  7 00246 6351 20	eaa  	pr7|166,*		new_bufp
001624  aa   000066 7730 00	lrl  	54
001625  aa  7 00326 3515 20	epp1 	pr7|214,*		wtcbp
001626  aa  1 00016 5521 14	stbq 	pr1|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 769
				     if uncp_flag then new_bufp -> buffer.turn = lastp -> buffer.turn;

001627  aa  7 00260 2351 00	lda  	pr7|176		uncp_flag
001630  aa   400000 3150 03	cana 	131072,du
001631  aa   000005 6000 04	tze  	5,ic		001636
001632  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.turn
001633  aa  7 00246 6751 20	era  	pr7|166,*		buffer.turn
001634  aa   020000 3750 07	ana  	8192,dl
001635  aa  7 00246 6551 20	ersa 	pr7|166,*		buffer.turn
						STATEMENT 1 ON LINE 774
				     prevp = ptr (ttybp, wtcb.write_first);

001636  aa  1 00016 2351 00	lda  	pr1|14		wtcb.write_first
001637  aa   000066 7330 00	lrs  	54
001640  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
001641  aa   000000 3120 06	eawp2	0,ql
001642  aa  7 00232 2521 00	spri2	pr7|154		prevp
						STATEMENT 1 ON LINE 776
				     if prevp = lastp
						/* is it tail also? */
				     then wtcb.write_first = wtcb.write_last;

001643  aa  7 00232 2371 00	ldaq 	pr7|154		prevp
001644  aa  7 00226 6771 00	eraq 	pr7|150		lastp
001645  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001646  aa   000005 6010 04	tnz  	5,ic		001653
001647  aa  1 00016 2351 00	lda  	pr1|14		wtcb.write_last
001650  aa   000022 7350 00	als  	18
001651  aa  1 00016 5511 60	stba 	pr1|14,60		wtcb.write_first
001652  aa   000025 7100 04	tra  	21,ic		001677
						STATEMENT 1 ON LINE 780
				     else do;

						STATEMENT 1 ON LINE 781
					do prevp = prevp repeat ptr (ttybp, prevp -> buffer.next)
					     while (prevp -> buffer.next ^= bin (rel (lastp), 18)
					     & prevp -> buffer.next ^= 0);

001653  aa  7 00232 2521 00	spri2	pr7|154		prevp
001654  aa  6 00040 3735 20	epp7 	pr6|32,*
001655  aa  7 00232 2351 20	lda  	pr7|154,*		buffer.next
001656  aa   000066 7730 00	lrl  	54
001657  aa  6 00317 7561 00	stq  	pr6|207		buffer.next
001660  aa  7 00226 6351 20	eaa  	pr7|150,*		lastp
001661  aa   000066 7730 00	lrl  	54
001662  aa  6 00317 1161 00	cmpq 	pr6|207		buffer.next
001663  aa   000007 6000 04	tze  	7,ic		001672
001664  aa  6 00317 2361 00	ldq  	pr6|207		buffer.next
001665  aa   000005 6000 04	tze  	5,ic		001672
						STATEMENT 1 ON LINE 784
					end;

001666  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
001667  aa   000000 3120 06	eawp2	0,ql
001670  aa  7 00232 2521 00	spri2	pr7|154		prevp
001671  aa   777763 7100 04	tra  	-13,ic		001654
						STATEMENT 1 ON LINE 785
					prevp -> buffer.next = wtcb.write_last;

001672  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001673  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
001674  aa   000022 7350 00	als  	18
001675  aa  7 00232 3535 20	epp3 	pr7|154,*		buffer.next
001676  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 787
				     end;

						STATEMENT 1 ON LINE 789
				     call tty_space_man$free_buffer (devx, OUTPUT, lastp);

001677  aa  7 00101 3521 00	epp2 	pr7|65		devx
001700  aa  6 00330 2521 00	spri2	pr6|216
001701  aa   776213 3520 04	epp2 	-885,ic		000114 = 400000000000
001702  aa  6 00332 2521 00	spri2	pr6|218
001703  aa  7 00226 3521 00	epp2 	pr7|150		lastp
001704  aa  6 00334 2521 00	spri2	pr6|220
001705  aa  6 00326 6211 00	eax1 	pr6|214
001706  aa   014000 4310 07	fld  	6144,dl
001707  aa  6 00044 3701 20	epp4 	pr6|36,*
001710  la  4 00056 3521 20	epp2 	pr4|46,*		tty_space_man$free_buffer
001711  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 791
				     lastp = new_bufp;

001712  aa  6 00040 3735 20	epp7 	pr6|32,*
001713  aa  7 00246 3735 20	epp7 	pr7|166,*		new_bufp
001714  aa  6 00040 3715 20	epp5 	pr6|32,*
001715  aa  5 00226 6535 00	spri7	pr5|150		lastp
						STATEMENT 1 ON LINE 793
				     if first_buffer
				     then do;

001716  aa  5 00240 2351 00	lda  	pr5|160		first_buffer
001717  aa   000031 6000 04	tze  	25,ic		001750
						STATEMENT 1 ON LINE 795
					old_lastp = lastp;

001720  aa  5 00226 3735 20	epp7 	pr5|150,*		lastp
001721  aa  5 00242 6535 00	spri7	pr5|162		old_lastp
						STATEMENT 1 ON LINE 796
					old_tail = wtcb.write_last;

001722  aa  5 00326 3535 20	epp3 	pr5|214,*		wtcbp
001723  aa  3 00016 2351 00	lda  	pr3|14		wtcb.write_last
001724  aa   000022 7350 00	als  	18
001725  aa   000066 7330 00	lrs  	54
001726  aa  5 00203 7561 00	stq  	pr5|131		old_tail
						STATEMENT 1 ON LINE 797
					if wtcb.write_first = wtcb.write_last
					then old_head = wtcb.write_first;

001727  aa  3 00016 2351 00	lda  	pr3|14		wtcb.write_first
001730  aa  6 00317 7561 00	stq  	pr6|207		wtcb.write_last
001731  aa   000066 7330 00	lrs  	54
001732  aa  6 00317 1161 00	cmpq 	pr6|207		wtcb.write_last
001733  aa   000015 6010 04	tnz  	13,ic		001750
001734  aa  5 00202 7561 00	stq  	pr5|130		old_head
						STATEMENT 1 ON LINE 799
				     end;

						STATEMENT 1 ON LINE 800
				end;

001735  aa   000013 7100 04	tra  	11,ic		001750
						STATEMENT 1 ON LINE 802
				else chars_in_buf = 4 * (orig_buf_size - 1) - wtcb.buffer_pad;

001736  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
001737  aa  5 00020 2351 00	lda  	pr5|16		wtcb.buffer_pad
001740  aa   000011 7350 00	als  	9
001741  aa   000077 7730 00	lrl  	63
001742  aa  6 00317 7561 00	stq  	pr6|207		wtcb.buffer_pad
001743  aa  7 00235 2361 00	ldq  	pr7|157		orig_buf_size
001744  aa   000001 1760 07	sbq  	1,dl
001745  aa   000002 7360 00	qls  	2
001746  aa  6 00317 1761 00	sbq  	pr6|207		wtcb.buffer_pad
001747  aa  7 00251 7561 00	stq  	pr7|169		chars_in_buf
						STATEMENT 1 ON LINE 804
			     end;

						STATEMENT 1 ON LINE 806
			     bufp = addr (lastp -> buffer.chars (lchar));

001750  aa  6 00040 3735 20	epp7 	pr6|32,*
001751  aa  7 00252 7271 00	lxl7 	pr7|170		lchar
001752  aa  7 00226 3715 20	epp5 	pr7|150,*		lastp
001753  aa  5 00001 3521 00	epp2 	pr5|1		buffer.chars
001754  aa  2 00000 5005 17	a9bd 	pr2|0,7
001755  aa  7 00230 2521 00	spri2	pr7|152		bufp
						STATEMENT 1 ON LINE 807
			     old_char_count = lastp -> buffer.tally;

001756  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
001757  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001760  aa  7 00253 7561 00	stq  	pr7|171		old_char_count
						STATEMENT 1 ON LINE 808
			     nchars = min (break_length, chars_in_buf - lchar);

001761  aa  7 00251 2361 00	ldq  	pr7|169		chars_in_buf
001762  aa  7 00252 1761 00	sbq  	pr7|170		lchar
001763  aa  7 00205 1161 00	cmpq 	pr7|133		break_length
001764  aa   000002 6040 04	tmi  	2,ic		001766
001765  aa  7 00205 2361 00	ldq  	pr7|133		break_length
001766  aa  7 00254 7561 00	stq  	pr7|172		nchars
						STATEMENT 1 ON LINE 809
			end;

001767  aa   000123 7100 04	tra  	83,ic		002112
						STATEMENT 1 ON LINE 811
			else do;

						STATEMENT 1 ON LINE 812
get_new_buf:
			     words_needed =
				max (16,
				min (wtcb.max_buf_size,
				16 * divide (break_length + wtcb.buffer_pad + 67, 64, 17, 0)));

001770  aa  5 00020 2351 00	lda  	pr5|16		wtcb.buffer_pad
001771  aa   000011 7350 00	als  	9
001772  aa   000077 7730 00	lrl  	63
001773  aa  7 00205 0761 00	adq  	pr7|133		break_length
001774  aa   000103 0760 07	adq  	67,dl
001775  aa   000100 5060 07	div  	64,dl
001776  aa   000004 7360 00	qls  	4
001777  aa  6 00317 7561 00	stq  	pr6|207
002000  aa  5 00020 2351 00	lda  	pr5|16		wtcb.max_buf_size
002001  aa   000077 7730 00	lrl  	63
002002  aa  6 00317 1161 00	cmpq 	pr6|207
002003  aa   000002 6040 04	tmi  	2,ic		002005
002004  aa  6 00317 2361 00	ldq  	pr6|207
002005  aa   000020 1160 07	cmpq 	16,dl
002006  aa   000002 6050 04	tpl  	2,ic		002010
002007  aa   000020 2360 07	ldq  	16,dl
002010  aa  7 00244 7561 00	stq  	pr7|164		words_needed
						STATEMENT 1 ON LINE 817
			     call tty_space_man$get_buffer (devx, words_needed, OUTPUT, new_bufp);

002011  aa  7 00101 3521 00	epp2 	pr7|65		devx
002012  aa  6 00330 2521 00	spri2	pr6|216
002013  aa  7 00244 3521 00	epp2 	pr7|164		words_needed
002014  aa  6 00332 2521 00	spri2	pr6|218
002015  aa   776077 3520 04	epp2 	-961,ic		000114 = 400000000000
002016  aa  6 00334 2521 00	spri2	pr6|220
002017  aa  7 00246 3521 00	epp2 	pr7|166		new_bufp
002020  aa  6 00336 2521 00	spri2	pr6|222
002021  aa  6 00326 6211 00	eax1 	pr6|214
002022  aa   020000 4310 07	fld  	8192,dl
002023  aa  6 00044 3701 20	epp4 	pr6|36,*
002024  la  4 00054 3521 20	epp2 	pr4|44,*		tty_space_man$get_buffer
002025  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 818
			     if new_bufp = null	/* couldn't get the space */
			     then go to free_and_try_again;

002026  aa  6 00040 3735 20	epp7 	pr6|32,*
002027  aa  7 00246 2371 00	ldaq 	pr7|166		new_bufp
002030  aa   776076 6770 04	eraq 	-962,ic		000126 = 077777000043 000001000000
002031  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002032  aa   000660 6000 04	tze  	432,ic		002712
						STATEMENT 1 ON LINE 820
			     new_buf = bin (rel (new_bufp), 18);

002033  aa  7 00246 6351 20	eaa  	pr7|166,*		new_bufp
002034  aa   000066 7730 00	lrl  	54
002035  aa  7 00250 7561 00	stq  	pr7|168		new_buf
						STATEMENT 1 ON LINE 821
			     chars_in_buf = 4 * (words_needed - 1) - wtcb.buffer_pad;

002036  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002037  aa  5 00020 2351 00	lda  	pr5|16		wtcb.buffer_pad
002040  aa   000011 7350 00	als  	9
002041  aa   000077 7730 00	lrl  	63
002042  aa  6 00317 7561 00	stq  	pr6|207		wtcb.buffer_pad
002043  aa  7 00244 2361 00	ldq  	pr7|164		words_needed
002044  aa   000001 1760 07	sbq  	1,dl
002045  aa   000002 7360 00	qls  	2
002046  aa  6 00317 1761 00	sbq  	pr6|207		wtcb.buffer_pad
002047  aa  7 00251 7561 00	stq  	pr7|169		chars_in_buf
						STATEMENT 1 ON LINE 823
			     if first_buffer
			     then do;

002050  aa  7 00240 2351 00	lda  	pr7|160		first_buffer
002051  aa   000004 6000 04	tze  	4,ic		002055
						STATEMENT 1 ON LINE 825
				new_head = new_buf;

002052  aa  7 00250 2361 00	ldq  	pr7|168		new_buf
002053  aa  7 00223 7561 00	stq  	pr7|147		new_head
						STATEMENT 1 ON LINE 826
				first_buffer = "0"b;

002054  aa  7 00240 4501 00	stz  	pr7|160		first_buffer
						STATEMENT 1 ON LINE 827
			     end;

						STATEMENT 1 ON LINE 829
			     new_buffer_count = new_buffer_count + 1;

002055  aa  7 00237 0541 00	aos  	pr7|159		new_buffer_count
						STATEMENT 1 ON LINE 830
			     lchar = 0;

002056  aa  7 00252 4501 00	stz  	pr7|170		lchar
						STATEMENT 1 ON LINE 831
			     if wtcb.write_last ^= 0	/* chain already abuilding */
			     then lastp -> buffer.next = new_buf;

002057  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
002060  aa   000022 7350 00	als  	18
002061  aa   000066 7330 00	lrs  	54
002062  aa   000006 6000 04	tze  	6,ic		002070
002063  aa  7 00250 2361 00	ldq  	pr7|168		new_buf
002064  aa   000066 7370 00	lls  	54
002065  aa  7 00226 3535 20	epp3 	pr7|150,*		buffer.next
002066  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
002067  aa   000004 7100 04	tra  	4,ic		002073
						STATEMENT 1 ON LINE 833
			     else wtcb.write_first = new_buf;

002070  aa  7 00250 2361 00	ldq  	pr7|168		new_buf
002071  aa   000066 7370 00	lls  	54
002072  aa  5 00016 5511 60	stba 	pr5|14,60		wtcb.write_first
						STATEMENT 1 ON LINE 835
			     wtcb.write_last = new_buf;

002073  aa  7 00250 2361 00	ldq  	pr7|168		new_buf
002074  aa  5 00016 5521 14	stbq 	pr5|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 837
			     lastp = new_bufp;

002075  aa  7 00246 3535 20	epp3 	pr7|166,*		new_bufp
002076  aa  7 00226 2535 00	spri3	pr7|150		lastp
						STATEMENT 1 ON LINE 838
			     string (lastp -> buffer.flags) = "0"b;

002077  aa   004361 2350 04	lda  	2289,ic		006460 = 777777007777
002100  aa  7 00226 3551 20	ansa 	pr7|150,*
						STATEMENT 1 ON LINE 840
			     old_char_count = 0;

002101  aa  7 00253 4501 00	stz  	pr7|171		old_char_count
						STATEMENT 1 ON LINE 841
			     bufp = addr (lastp -> buffer.chars (0));

002102  aa  7 00226 3715 20	epp5 	pr7|150,*		lastp
002103  aa  5 00001 3715 00	epp5 	pr5|1		buffer.chars
002104  aa  7 00230 6515 00	spri5	pr7|152		bufp
						STATEMENT 1 ON LINE 842
			     nchars = min (break_length, chars_in_buf);

002105  aa  7 00205 2361 00	ldq  	pr7|133		break_length
002106  aa  7 00251 1161 00	cmpq 	pr7|169		chars_in_buf
002107  aa   000002 6040 04	tmi  	2,ic		002111
002110  aa  7 00251 2361 00	ldq  	pr7|169		chars_in_buf
002111  aa  7 00254 7561 00	stq  	pr7|172		nchars
						STATEMENT 1 ON LINE 843
			end;

						STATEMENT 1 ON LINE 845
			lastp -> buffer.tally = old_char_count + nchars;

002112  aa  7 00253 0761 00	adq  	pr7|171		old_char_count
002113  aa  7 00226 3715 20	epp5 	pr7|150,*		buffer.tally
002114  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 846
			lastp -> buffer.flags.break = "0"b;

002115  aa   004342 2350 04	lda  	2274,ic		006457 = 777777677777
002116  aa  7 00226 3551 20	ansa 	pr7|150,*		buffer.break
						STATEMENT 1 ON LINE 848
			bufp -> chars_to_copy = final_outp -> chars_to_copy;

002117  aa  7 00230 3715 20	epp5 	pr7|152,*		bufp
002120  aa  7 00134 3535 20	epp3 	pr7|92,*		final_outp
002121  aa  7 00254 7271 00	lxl7 	pr7|172		nchars
002122  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002123  aa  3 00000 00 0017	desc9a	pr3|0,x7		chars_to_copy
002124  aa  5 00000 00 0017	desc9a	pr5|0,x7		chars_to_copy
						STATEMENT 1 ON LINE 850
			final_outp = addr (final_outp -> based_chars (nchars));

002125  aa  3 00000 3521 00	epp2 	pr3|0		based_chars
002126  aa  2 00000 5005 17	a9bd 	pr2|0,7
002127  aa  7 00134 2521 00	spri2	pr7|92		final_outp
						STATEMENT 1 ON LINE 851
			new_char_count = new_char_count + nchars;

002130  aa  7 00254 2361 00	ldq  	pr7|172		nchars
002131  aa  7 00201 0561 00	asq  	pr7|129		new_char_count
						STATEMENT 1 ON LINE 852
			break_length = break_length - nchars;

002132  aa  7 00254 3361 00	lcq  	pr7|172		nchars
002133  aa  7 00205 0561 00	asq  	pr7|133		break_length
						STATEMENT 1 ON LINE 855
			if uncp_flag then do;

002134  aa  7 00260 2351 00	lda  	pr7|176		uncp_flag
002135  aa   400000 3150 03	cana 	131072,du
002136  aa   777324 6000 04	tze  	-300,ic		001462
						STATEMENT 1 ON LINE 856
			     if break_length = 0
				then do;

002137  aa  7 00205 2361 00	ldq  	pr7|133		break_length
002140  aa   777322 6010 04	tnz  	-302,ic		001462
						STATEMENT 1 ON LINE 858
				lastp -> buffer.turn = wtcb.send_turn;

002141  aa  7 00326 3535 20	epp3 	pr7|214,*		wtcbp
002142  aa  3 00023 2351 00	lda  	pr3|19		wtcb.send_turn
002143  aa   000014 7710 00	arl  	12
002144  aa  7 00226 6751 20	era  	pr7|150,*		buffer.turn
002145  aa   020000 3750 07	ana  	8192,dl
002146  aa  7 00226 6551 20	ersa 	pr7|150,*		buffer.turn
						STATEMENT 1 ON LINE 859
				wtcb.send_turn = "0"b;

002147  aa   004317 2350 04	lda  	2255,ic		006466 = 777577777777
002150  aa  3 00023 3551 00	ansa 	pr3|19		wtcb.send_turn
						STATEMENT 1 ON LINE 860
			     end;

						STATEMENT 1 ON LINE 861
			end;

						STATEMENT 1 ON LINE 862
		     end;

002151  aa   777311 7100 04	tra  	-311,ic		001462
						STATEMENT 1 ON LINE 865
		     if break_flag			/* did we stop because of end-of-page? */
		     then do;

002152  aa  7 00206 2351 00	lda  	pr7|134		break_flag
002153  aa   000013 6000 04	tze  	11,ic		002166
						STATEMENT 1 ON LINE 867
			lastp -> buffer.flags.end_of_page = "1"b;

002154  aa   400000 2350 07	lda  	131072,dl
002155  aa  7 00226 2551 20	orsa 	pr7|150,*		buffer.end_of_page
						STATEMENT 1 ON LINE 868
			if ^null_for_eop		/* if we haven't laready skipped over sentinel */
			then do;

002156  aa  7 00207 2351 00	lda  	pr7|135		null_for_eop
002157  aa   000007 6010 04	tnz  	7,ic		002166
						STATEMENT 1 ON LINE 870
			     final_outp = addr (final_outp -> based_chars (1));

002160  aa   000001 7270 07	lxl7 	1,dl
002161  aa  7 00134 3521 20	epp2 	pr7|92,*		based_chars
002162  aa  2 00000 5005 17	a9bd 	pr2|0,7
002163  aa  7 00134 2521 00	spri2	pr7|92		final_outp
						STATEMENT 1 ON LINE 872
			     output_length = output_length - 1;

002164  aa   000001 3360 07	lcq  	1,dl
002165  aa  7 00136 0561 00	asq  	pr7|94		output_length
						STATEMENT 1 ON LINE 873
			end;

						STATEMENT 1 ON LINE 874
		     end;

						STATEMENT 1 ON LINE 876
		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
		     then do;

002166  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
002167  aa  5 00030 2351 00	lda  	pr5|24		tcb.block_acknowledge
002170  aa   004000 3150 03	cana 	2048,du
002171  aa   777201 6000 04	tze  	-383,ic		001372
002172  aa  5 00017 2351 00	lda  	pr5|15		tcb.oflow
002173  aa   002000 3150 07	cana 	1024,dl
002174  aa   777176 6000 04	tze  	-386,ic		001372
002175  aa  5 00023 2361 00	ldq  	pr5|19		tcb.max_output_block
002176  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
002177  aa   777173 6044 04	tmoz 	-389,ic		001372
						STATEMENT 1 ON LINE 878
			if lastp -> buffer.tally < chars_in_buf
						/* it'll fit in last buffer */
			then do;

002200  aa  7 00226 2361 20	ldq  	pr7|150,*		buffer.tally
002201  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002202  aa  6 00317 7561 00	stq  	pr6|207		buffer.tally
002203  aa  7 00251 1161 00	cmpq 	pr7|169		chars_in_buf
002204  aa   000011 6050 04	tpl  	9,ic		002215
						STATEMENT 1 ON LINE 881
			     lastp -> buffer.chars (lastp -> buffer.tally) =
				substr (tcb.output_suspend_etb_seq.chars, 1, 1);

002205  aa   000000 6270 06	eax7 	0,ql
002206  aa  7 00226 3535 20	epp3 	pr7|150,*		lastp
002207  aa  040 117 100 500	mlr  	(pr),(pr,x7),fill(040)
002210  aa  5 00026 20 0001	desc9a	pr5|22(1),1	tcb.chars
002211  aa  3 00001 00 0001	desc9a	pr3|1,1		buffer.chars
						STATEMENT 1 ON LINE 883
			     lastp -> buffer.tally = lastp -> buffer.tally + 1;

002212  aa   000001 0760 07	adq  	1,dl
002213  aa  3 00000 5521 04	stbq 	pr3|0,04		buffer.tally
						STATEMENT 1 ON LINE 884
			end;

002214  aa   777156 7100 04	tra  	-402,ic		001372
						STATEMENT 1 ON LINE 886
			else do;

						STATEMENT 1 ON LINE 887
			     call tty_space_man$get_buffer (devx, 16, OUTPUT, new_bufp);

002215  aa   000020 2360 07	ldq  	16,dl
002216  aa  6 00317 7561 00	stq  	pr6|207
002217  aa  7 00101 3521 00	epp2 	pr7|65		devx
002220  aa  6 00330 2521 00	spri2	pr6|216
002221  aa  6 00317 3521 00	epp2 	pr6|207
002222  aa  6 00332 2521 00	spri2	pr6|218
002223  aa   775671 3520 04	epp2 	-1095,ic		000114 = 400000000000
002224  aa  6 00334 2521 00	spri2	pr6|220
002225  aa  7 00246 3521 00	epp2 	pr7|166		new_bufp
002226  aa  6 00336 2521 00	spri2	pr6|222
002227  aa  6 00326 6211 00	eax1 	pr6|214
002230  aa   020000 4310 07	fld  	8192,dl
002231  aa  6 00044 3701 20	epp4 	pr6|36,*
002232  la  4 00054 3521 20	epp2 	pr4|44,*		tty_space_man$get_buffer
002233  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 888
			     if new_bufp = null
			     then go to free_and_try_again;

002234  aa  6 00040 3735 20	epp7 	pr6|32,*
002235  aa  7 00246 2371 00	ldaq 	pr7|166		new_bufp
002236  aa   775670 6770 04	eraq 	-1096,ic		000126 = 077777000043 000001000000
002237  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002240  aa   000452 6000 04	tze  	298,ic		002712
						STATEMENT 1 ON LINE 890
			     string (new_bufp -> buffer.flags) = "0"b;

002241  aa   004217 2350 04	lda  	2191,ic		006460 = 777777007777
002242  aa  7 00246 3551 20	ansa 	pr7|166,*
						STATEMENT 1 ON LINE 891
			     new_bufp -> buffer.tally = 1;

002243  aa   000001 2350 07	lda  	1,dl
002244  aa  7 00246 3715 20	epp5 	pr7|166,*		buffer.tally
002245  aa  5 00000 5511 04	stba 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 892
			     new_bufp -> buffer.chars (0) = substr (tcb.output_suspend_etb_seq.chars, 1, 1);

002246  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
002247  aa  5 00026 2351 00	lda  	pr5|22		tcb.chars
002250  aa   000011 7350 00	als  	9
002251  aa  7 00246 3535 20	epp3 	pr7|166,*		new_bufp
002252  aa  3 00001 5511 40	stba 	pr3|1,40		buffer.chars
						STATEMENT 1 ON LINE 893
			     wtcb.write_last, lastp -> buffer.next = bin (rel (new_bufp), 18);

002253  aa  3 00000 6351 00	eaa  	pr3|0		new_bufp
002254  aa   000066 7730 00	lrl  	54
002255  aa  7 00326 3515 20	epp1 	pr7|214,*		wtcbp
002256  aa  1 00016 5521 14	stbq 	pr1|14,14		wtcb.write_last
002257  aa   000066 7370 00	lls  	54
002260  aa  7 00226 3715 20	epp5 	pr7|150,*		buffer.next
002261  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 894
			     lastp = new_bufp;

002262  aa  7 00226 2535 00	spri3	pr7|150		lastp
						STATEMENT 1 ON LINE 895
			end;

						STATEMENT 1 ON LINE 896
		     end;

						STATEMENT 1 ON LINE 897
		end;

002263  aa   777107 7100 04	tra  	-441,ic		001372
						STATEMENT 1 ON LINE 899
		if nelem = nelemt
		then do;

002264  aa  7 00105 2361 00	ldq  	pr7|69		nelem
002265  aa  7 00106 1161 00	cmpq 	pr7|70		nelemt
002266  aa   000010 6010 04	tnz  	8,ic		002276
						STATEMENT 1 ON LINE 901
		     lastp -> buffer.flags.break = "1"b;

002267  aa   100000 2350 07	lda  	32768,dl
002270  aa  7 00226 2551 20	orsa 	pr7|150,*		buffer.break
						STATEMENT 1 ON LINE 902
		     lastp -> buffer.flags.mark = mark_entry;

002271  aa  7 00111 2351 00	lda  	pr7|73		mark_entry
002272  aa   000025 7710 00	arl  	21
002273  aa  7 00226 6751 20	era  	pr7|150,*		buffer.mark
002274  aa   040000 3750 07	ana  	16384,dl
002275  aa  7 00226 6551 20	ersa 	pr7|150,*		buffer.mark
						STATEMENT 1 ON LINE 903
		end;

						STATEMENT 1 ON LINE 905
		if send & wtcb.send_output		/* if this is first new output, we'll pass it on */
		then do;

002276  aa  7 00222 2351 00	lda  	pr7|146		send
002277  aa   000247 6000 04	tze  	167,ic		002546
002300  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002301  aa  5 00013 2351 00	lda  	pr5|11		wtcb.send_output
002302  aa   100000 3150 03	cana 	32768,du
002303  aa   000243 6000 04	tze  	163,ic		002546
						STATEMENT 1 ON LINE 907
		     if n_pages > 1
		     then do;

002304  aa  7 00224 2361 00	ldq  	pr7|148		n_pages
002305  aa   000001 1160 07	cmpq 	1,dl
002306  aa   000026 6044 04	tmoz 	22,ic		002334
						STATEMENT 1 ON LINE 909
			blockp = ptr (ttybp, wtcb.write_first);

002307  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_first
002310  aa   000066 7330 00	lrs  	54
002311  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002312  aa   000000 3120 06	eawp2	0,ql
002313  aa  7 00324 2521 00	spri2	pr7|212		blockp
						STATEMENT 1 ON LINE 911
			do while (^buffer.end_of_page & buffer.next ^= 0);

002314  aa  6 00040 3735 20	epp7 	pr6|32,*
002315  aa  7 00324 2351 20	lda  	pr7|212,*		buffer.next
002316  aa   000066 7730 00	lrl  	54
002317  aa  6 00317 7561 00	stq  	pr6|207		buffer.next
002320  aa  7 00324 2351 20	lda  	pr7|212,*		buffer.end_of_page
002321  aa   400000 3150 07	cana 	131072,dl
002322  aa   000007 6010 04	tnz  	7,ic		002331
002323  aa  6 00317 2361 00	ldq  	pr6|207		buffer.next
002324  aa   000005 6000 04	tze  	5,ic		002331
						STATEMENT 1 ON LINE 913
			     blockp = ptr (ttybp, buffer.next);

002325  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002326  aa   000000 3120 06	eawp2	0,ql
002327  aa  7 00324 2521 00	spri2	pr7|212		blockp
						STATEMENT 1 ON LINE 914
			end;

002330  aa   777764 7100 04	tra  	-12,ic		002314
						STATEMENT 1 ON LINE 916
			lastp = blockp;

002331  aa  7 00324 3715 20	epp5 	pr7|212,*		blockp
002332  aa  7 00226 6515 00	spri5	pr7|150		lastp
						STATEMENT 1 ON LINE 917
		     end;

002333  aa   000007 7100 04	tra  	7,ic		002342
						STATEMENT 1 ON LINE 919
		     else lastp = ptr (ttybp, wtcb.write_last);

002334  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_last
002335  aa   000022 7350 00	als  	18
002336  aa   000066 7330 00	lrs  	54
002337  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002340  aa   000000 3120 06	eawp2	0,ql
002341  aa  7 00226 2521 00	spri2	pr7|150		lastp
						STATEMENT 1 ON LINE 921
		     if mark_entry
		     then wtcb.mark_set = lastp -> buffer.mark;

002342  aa  7 00111 2351 00	lda  	pr7|73		mark_entry
002343  aa   000007 6000 04	tze  	7,ic		002352
002344  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.mark
002345  aa   000004 7710 00	arl  	4
002346  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002347  aa  5 00013 6751 00	era  	pr5|11		wtcb.mark_set
002350  aa   002000 3750 07	ana  	1024,dl
002351  aa  5 00013 6551 00	ersa 	pr5|11		wtcb.mark_set
						STATEMENT 1 ON LINE 924
		     new_head = lastp -> buffer.next;

002352  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.next
002353  aa   000066 7730 00	lrl  	54
002354  aa  7 00223 7561 00	stq  	pr7|147		new_head
						STATEMENT 1 ON LINE 925
		     headp = ptr (ttybp, wtcb.write_first);

002355  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002356  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_first
002357  aa   000066 7330 00	lrs  	54
002360  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002361  aa   000000 3120 06	eawp2	0,ql
002362  aa  7 00220 2521 00	spri2	pr7|144		headp
						STATEMENT 1 ON LINE 926
		     wtcb.write_first = lastp -> buffer.next;

002363  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.next
002364  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002365  aa  5 00016 5511 60	stba 	pr5|14,60		wtcb.write_first
						STATEMENT 1 ON LINE 928
		     if wtcb.write_first = 0
		     then wtcb.write_last = 0;

002366  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_first
002367  aa   000066 7330 00	lrs  	54
002370  aa   000003 6010 04	tnz  	3,ic		002373
002371  aa   000000 2350 03	lda  	0,du
002372  aa  5 00016 5511 14	stba 	pr5|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 930
		     lastp -> buffer.next = 0;

002373  aa   000000 2350 07	lda  	0,dl
002374  aa  7 00226 3535 20	epp3 	pr7|150,*		buffer.next
002375  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 931
		     wtcb.end_frame = lastp -> buffer.end_of_page;

002376  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.end_of_page
002377  aa   000015 7350 00	als  	13
002400  aa  5 00013 6751 00	era  	pr5|11		wtcb.end_frame
002401  aa   010000 3750 03	ana  	4096,du
002402  aa  5 00013 6551 00	ersa 	pr5|11		wtcb.end_frame
						STATEMENT 1 ON LINE 933
		     call channel_manager$write (devx, headp, ercode);

002403  aa  7 00101 3521 00	epp2 	pr7|65		devx
002404  aa  6 00330 2521 00	spri2	pr6|216
002405  aa  7 00220 3521 00	epp2 	pr7|144		headp
002406  aa  6 00332 2521 00	spri2	pr6|218
002407  aa  7 00344 3521 20	epp2 	pr7|228,*		ercode
002410  aa  6 00334 2521 00	spri2	pr6|220
002411  aa  6 00326 6211 00	eax1 	pr6|214
002412  aa   014000 4310 07	fld  	6144,dl
002413  aa  6 00044 3701 20	epp4 	pr6|36,*
002414  la  4 00064 3521 20	epp2 	pr4|52,*		channel_manager$write
002415  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 934
		     if ercode = error_table_$noalloc
		     then do;

002416  aa  6 00040 3735 20	epp7 	pr6|32,*
002417  aa  7 00344 2361 20	ldq  	pr7|228,*		ercode
002420  aa  6 00044 3701 20	epp4 	pr6|36,*
002421  la  4 00042 1161 20	cmpq 	pr4|34,*		error_table_$noalloc
002422  aa   000012 6010 04	tnz  	10,ic		002434
						STATEMENT 1 ON LINE 936
			nelemt = 0;

002423  aa  7 00106 4501 00	stz  	pr7|70		nelemt
						STATEMENT 1 ON LINE 937
			call free_buffers;

002424  aa   000001 7270 07	lxl7 	1,dl
002425  aa  6 00056 6211 00	eax1 	pr6|46
002426  aa   000000 4310 07	fld  	0,dl
002427  aa   003545 3520 04	epp2 	1893,ic		006174 = 000120627000
002430  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 938
			go to nothing_written;

002431  aa   003522 3520 04	epp2 	1874,ic		006153 = 600326373520
002432  aa   000001 7270 07	lxl7 	1,dl
002433  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 939
		     end;

						STATEMENT 1 ON LINE 940
		     else do;

						STATEMENT 1 ON LINE 941
			if ercode ^= 0
			then do;

002434  aa  7 00344 2361 20	ldq  	pr7|228,*		ercode
002435  aa   000042 6000 04	tze  	34,ic		002477
						STATEMENT 1 ON LINE 943
			     call free_buffers;

002436  aa   000001 7270 07	lxl7 	1,dl
002437  aa  6 00056 6211 00	eax1 	pr6|46
002440  aa   000000 4310 07	fld  	0,dl
002441  aa   003533 3520 04	epp2 	1883,ic		006174 = 000120627000
002442  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 944
			     if wtcb.write_first ^= 0 /* and I mean ANYTHING */
			     then do;

002443  aa  6 00040 3735 20	epp7 	pr6|32,*
002444  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002445  aa  5 00016 2351 00	lda  	pr5|14		wtcb.write_first
002446  aa   000066 7330 00	lrs  	54
002447  aa   000074 6000 04	tze  	60,ic		002543
						STATEMENT 1 ON LINE 946
				call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, wtcb.write_first));

002450  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002451  aa   000000 3120 06	eawp2	0,ql
002452  aa  6 00314 2521 00	spri2	pr6|204
002453  aa  7 00101 3521 00	epp2 	pr7|65		devx
002454  aa  6 00330 2521 00	spri2	pr6|216
002455  aa   775437 3520 04	epp2 	-1249,ic		000114 = 400000000000
002456  aa  6 00332 2521 00	spri2	pr6|218
002457  aa  6 00314 3521 00	epp2 	pr6|204
002460  aa  6 00334 2521 00	spri2	pr6|220
002461  aa  6 00326 6211 00	eax1 	pr6|214
002462  aa   014000 4310 07	fld  	6144,dl
002463  aa  6 00044 3701 20	epp4 	pr6|36,*
002464  la  4 00060 3521 20	epp2 	pr4|48,*		tty_space_man$free_chain
002465  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 947
				wtcb.write_first, wtcb.write_last = 0;

002466  aa   000000 2350 07	lda  	0,dl
002467  aa  6 00040 3735 20	epp7 	pr6|32,*
002470  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002471  aa  5 00016 5511 60	stba 	pr5|14,60		wtcb.write_first
002472  aa   000022 7710 00	arl  	18
002473  aa  5 00016 5511 14	stba 	pr5|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 948
				wtcb.mark_set = "0"b;

002474  aa   003762 2350 04	lda  	2034,ic		006456 = 777777775777
002475  aa  5 00013 3551 00	ansa 	pr5|11		wtcb.mark_set
						STATEMENT 1 ON LINE 950
			     end;

						STATEMENT 1 ON LINE 951
			end;

002476  aa   000045 7100 04	tra  	37,ic		002543
						STATEMENT 1 ON LINE 953
			else if headp ^= null
			then do;

002477  aa  7 00220 2371 00	ldaq 	pr7|144		headp
002500  aa   775426 6770 04	eraq 	-1258,ic		000126 = 077777000043 000001000000
002501  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002502  aa   000041 6000 04	tze  	33,ic		002543
						STATEMENT 1 ON LINE 955
			     wtcb.write_first = bin (rel (headp));

002503  aa  7 00220 6351 20	eaa  	pr7|144,*		headp
002504  aa   000066 7730 00	lrl  	54
002505  aa   000066 7370 00	lls  	54
002506  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002507  aa  5 00016 5511 60	stba 	pr5|14,60		wtcb.write_first
						STATEMENT 1 ON LINE 956
			     blockp = headp;

002510  aa  7 00220 3535 20	epp3 	pr7|144,*		headp
002511  aa  7 00324 2535 00	spri3	pr7|212		blockp
						STATEMENT 1 ON LINE 957
			     do while (buffer.next ^= 0);

002512  aa  6 00040 3735 20	epp7 	pr6|32,*
002513  aa  7 00324 2351 20	lda  	pr7|212,*		buffer.next
002514  aa   000066 7730 00	lrl  	54
002515  aa  6 00317 7561 00	stq  	pr6|207		buffer.next
002516  aa   000005 6000 04	tze  	5,ic		002523
						STATEMENT 1 ON LINE 959
				blockp = ptr (ttybp, buffer.next);

002517  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
002520  aa   000000 3120 06	eawp2	0,ql
002521  aa  7 00324 2521 00	spri2	pr7|212		blockp
						STATEMENT 1 ON LINE 960
			     end;

002522  aa   777770 7100 04	tra  	-8,ic		002512
						STATEMENT 1 ON LINE 962
			     buffer.next = new_head;

002523  aa  7 00223 2361 00	ldq  	pr7|147		new_head
002524  aa   000066 7370 00	lls  	54
002525  aa  7 00324 3715 20	epp5 	pr7|212,*		buffer.next
002526  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 963
			     if wtcb.write_last = 0	/* sent all we had */
			     then wtcb.write_last = bin (rel (blockp));

002527  aa  7 00326 3535 20	epp3 	pr7|214,*		wtcbp
002530  aa  3 00016 2351 00	lda  	pr3|14		wtcb.write_last
002531  aa   000022 7350 00	als  	18
002532  aa   000066 7330 00	lrs  	54
002533  aa   000004 6010 04	tnz  	4,ic		002537
002534  aa  7 00324 6351 20	eaa  	pr7|212,*		blockp
002535  aa   000066 7730 00	lrl  	54
002536  aa  3 00016 5521 14	stbq 	pr3|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 967
			     if mark_entry
			     then wtcb.mark_set = "0"b;

002537  aa  7 00111 2351 00	lda  	pr7|73		mark_entry
002540  aa   000003 6000 04	tze  	3,ic		002543
002541  aa   003715 2350 04	lda  	1997,ic		006456 = 777777775777
002542  aa  3 00013 3551 00	ansa 	pr3|11		wtcb.mark_set
						STATEMENT 1 ON LINE 970
			end;

						STATEMENT 1 ON LINE 971
			wtcb.send_output = "0"b;

002543  aa   003712 2350 04	lda  	1994,ic		006455 = 677777777777
002544  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002545  aa  5 00013 3551 00	ansa 	pr5|11		wtcb.send_output
						STATEMENT 1 ON LINE 972
		     end;

						STATEMENT 1 ON LINE 973
		end;

						STATEMENT 1 ON LINE 974
	     end;

						STATEMENT 1 ON LINE 976
	     if ^tcb.modes.rawom
	     then do;

002546  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
002547  aa  5 00017 2351 00	lda  	pr5|15		tcb.rawom
002550  aa   004000 3150 03	cana 	2048,du
002551  aa   000012 6010 04	tnz  	10,ic		002563
						STATEMENT 1 ON LINE 978
		wtcb.actcol = col;

002552  aa  7 00167 2361 00	ldq  	pr7|119		col
002553  aa   000055 7370 00	lls  	45
002554  aa  7 00326 3535 20	epp3 	pr7|214,*		wtcbp
002555  aa  3 00015 5511 10	stba 	pr3|13,10		wtcb.actcol
						STATEMENT 1 ON LINE 979
		wtcb.actline = line_count;

002556  aa  7 00166 2361 00	ldq  	pr7|118		line_count
002557  aa   000066 7370 00	lls  	54
002560  aa  3 00015 5511 20	stba 	pr3|13,20		wtcb.actline
						STATEMENT 1 ON LINE 980
		wtcb.white_col = wcol;

002561  aa  7 00170 2361 00	ldq  	pr7|120		wcol
002562  aa  3 00017 5521 14	stbq 	pr3|15,14		wtcb.white_col
						STATEMENT 1 ON LINE 981
	     end;

						STATEMENT 1 ON LINE 983
	     if nelemt < nelem
	     then do;

002563  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
002564  aa  7 00105 1161 00	cmpq 	pr7|69		nelem
002565  aa   000074 6050 04	tpl  	60,ic		002661
						STATEMENT 1 ON LINE 985
		i = (nelem - nelemt);

002566  aa  7 00105 2361 00	ldq  	pr7|69		nelem
002567  aa  7 00106 1761 00	sbq  	pr7|70		nelemt
002570  aa  7 00176 7561 00	stq  	pr7|126		i
						STATEMENT 1 ON LINE 986
		if tty_buf.minbuf = 0 | tty_buf.minbuf > i
		then tty_buf.minbuf = i;

002571  aa  7 00322 3535 20	epp3 	pr7|210,*		ttybp
002572  aa  3 00016 2361 00	ldq  	pr3|14		tty_buf.minbuf
002573  aa   000003 6000 04	tze  	3,ic		002576
002574  aa  7 00176 1161 00	cmpq 	pr7|126		i
002575  aa   000003 6044 04	tmoz 	3,ic		002600
002576  aa  7 00176 2361 00	ldq  	pr7|126		i
002577  aa  3 00016 7561 00	stq  	pr3|14		tty_buf.minbuf
						STATEMENT 1 ON LINE 989
		tty_buf.totbuf = tty_buf.totbuf + i;

002600  aa  3 00017 2351 00	lda  	pr3|15		tty_buf.totbuf
002601  aa   000044 7330 00	lrs  	36
002602  aa  7 00176 0331 00	adl  	pr7|126		i
002603  aa  3 00017 7561 00	stq  	pr3|15		tty_buf.totbuf
						STATEMENT 1 ON LINE 990
		tty_buf.nblocked = tty_buf.nblocked + 1;

002604  aa  3 00015 2351 00	lda  	pr3|13		tty_buf.nblocked
002605  aa   000044 7330 00	lrs  	36
002606  aa   000001 0330 07	adl  	1,dl
002607  aa  3 00015 7561 00	stq  	pr3|13		tty_buf.nblocked
						STATEMENT 1 ON LINE 996
		if wtcb.send_output			/* nothing in progress */
		then do;

002610  aa  7 00326 3515 20	epp1 	pr7|214,*		wtcbp
002611  aa  1 00013 2351 00	lda  	pr1|11		wtcb.send_output
002612  aa   100000 3150 03	cana 	32768,du
002613  aa   000044 6000 04	tze  	36,ic		002657
						STATEMENT 1 ON LINE 998
		     unspec (net_event_message) = "0"b;

002614  aa   775310 2370 04	ldaq 	-1336,ic		000124 = 000000000000 000000000000
002615  aa  7 00336 7571 00	staq 	pr7|222
						STATEMENT 1 ON LINE 999
		     net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;

002616  aa   400000 2350 03	lda  	131072,du
002617  aa  7 00336 6751 00	era  	pr7|222		net_event_message.version
002620  aa  0 00004 3751 00	ana  	pr0|4		= 600000000000
002621  aa  7 00336 6551 00	ersa 	pr7|222		net_event_message.version
						STATEMENT 1 ON LINE 1000
		     net_event_message.network_type = MCS_NETWORK_TYPE;

002622  aa   000000 2350 03	lda  	0,du
002623  aa  7 00336 6751 00	era  	pr7|222		net_event_message.network_type
002624  aa   007400 3750 07	ana  	3840,dl
002625  aa  7 00336 6551 00	ersa 	pr7|222		net_event_message.network_type
						STATEMENT 1 ON LINE 1001
		     net_event_message.handle = devx;

002626  aa  7 00101 2361 00	ldq  	pr7|65		devx
002627  aa  7 00337 7561 00	stq  	pr7|223		net_event_message.handle
						STATEMENT 1 ON LINE 1002
		     net_event_message.type = MCS_WRITE_MSG;

002630  aa   000006 2350 07	lda  	6,dl
002631  aa  7 00336 6751 00	era  	pr7|222		net_event_message.type
002632  aa   000377 3750 07	ana  	255,dl
002633  aa  7 00336 6551 00	ersa 	pr7|222		net_event_message.type
						STATEMENT 1 ON LINE 1003
		     call pxss$ring_0_wakeup (wtcb.uproc, wtcb.event, net_event_message_arg, (0));

002634  aa  6 00317 4501 00	stz  	pr6|207
002635  aa  1 00011 3521 00	epp2 	pr1|9		wtcb.uproc
002636  aa  6 00330 2521 00	spri2	pr6|216
002637  aa  1 00002 3521 00	epp2 	pr1|2		wtcb.event
002640  aa  6 00332 2521 00	spri2	pr6|218
002641  aa  7 00336 3521 00	epp2 	pr7|222		net_event_message_arg
002642  aa  6 00334 2521 00	spri2	pr6|220
002643  aa  6 00317 3521 00	epp2 	pr6|207
002644  aa  6 00336 2521 00	spri2	pr6|222
002645  aa  6 00326 6211 00	eax1 	pr6|214
002646  aa   020000 4310 07	fld  	8192,dl
002647  aa  6 00044 3701 20	epp4 	pr6|36,*
002650  la  4 00010 3521 20	epp2 	pr4|8,*		pxss$ring_0_wakeup
002651  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1004
		     wtcb.wflag = "0"b;

002652  aa   003602 2350 04	lda  	1922,ic		006454 = 777737777777
002653  aa  6 00040 3735 20	epp7 	pr6|32,*
002654  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
002655  aa  5 00013 3551 00	ansa 	pr5|11		wtcb.wflag
						STATEMENT 1 ON LINE 1005
		end;

002656  aa   000003 7100 04	tra  	3,ic		002661
						STATEMENT 1 ON LINE 1006
		else wtcb.flags.wflag = "1"b;

002657  aa   000040 2350 03	lda  	32,du
002660  aa  1 00013 2551 00	orsa 	pr1|11		wtcb.wflag
						STATEMENT 1 ON LINE 1007
	     end;

						STATEMENT 1 ON LINE 1009
	     tcb.cumulative_meters.write_chars = tcb.cumulative_meters.write_chars + nelemt;

002661  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
002662  aa  5 00035 2351 00	lda  	pr5|29		tcb.write_chars
002663  aa   000044 7330 00	lrs  	36
002664  aa  7 00106 0331 00	adl  	pr7|70		nelemt
002665  aa  5 00035 7561 00	stq  	pr5|29		tcb.write_chars
						STATEMENT 1 ON LINE 1010
	     tcb.cumulative_meters.write_calls = tcb.cumulative_meters.write_calls + 1;

002666  aa  5 00033 2351 00	lda  	pr5|27		tcb.write_calls
002667  aa   000044 7330 00	lrs  	36
002670  aa   000001 0330 07	adl  	1,dl
002671  aa  5 00033 7561 00	stq  	pr5|27		tcb.write_calls
						STATEMENT 1 ON LINE 1011
	     tty_buf.write_calls = tty_buf.write_calls + 1;

002672  aa  7 00322 3535 20	epp3 	pr7|210,*		ttybp
002673  aa  3 00031 2351 00	lda  	pr3|25		tty_buf.write_calls
002674  aa   000044 7330 00	lrs  	36
002675  aa   000001 0330 07	adl  	1,dl
002676  aa  3 00031 7561 00	stq  	pr3|25		tty_buf.write_calls
						STATEMENT 1 ON LINE 1012
	     tty_buf.noutchars = tty_buf.noutchars + nelemt;

002677  aa  3 00013 2351 00	lda  	pr3|11		tty_buf.noutchars
002700  aa   000044 7330 00	lrs  	36
002701  aa  7 00106 0331 00	adl  	pr7|70		nelemt
002702  aa  3 00013 7561 00	stq  	pr3|11		tty_buf.noutchars
						STATEMENT 1 ON LINE 1014
	     tty_buf.nrawwrite = tty_buf.nrawwrite + new_char_count;

002703  aa  3 00011 2351 00	lda  	pr3|9		tty_buf.nrawwrite
002704  aa   000044 7330 00	lrs  	36
002705  aa  7 00201 0331 00	adl  	pr7|129		new_char_count
002706  aa  3 00011 7561 00	stq  	pr3|9		tty_buf.nrawwrite
						STATEMENT 1 ON LINE 1015
	     go to all_done;

002707  aa   003140 3520 04	epp2 	1632,ic		006047 = 600106236100
002710  aa   000001 7270 07	lxl7 	1,dl
002711  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 1017
free_and_try_again:					/* here if we or next level couldn't allocate buffers */
	     call free_buffers;

002712  aa   000001 7270 07	lxl7 	1,dl
002713  aa  6 00056 6211 00	eax1 	pr6|46
002714  aa   000000 4310 07	fld  	0,dl
002715  aa   003257 3520 04	epp2 	1711,ic		006174 = 000120627000
002716  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 1019
	     tty_buf.output_buffer_overflow = tty_buf.output_buffer_overflow + 1;

002717  aa  6 00040 3735 20	epp7 	pr6|32,*
002720  aa  7 00322 3715 20	epp5 	pr7|210,*		ttybp
002721  aa  5 00023 0541 00	aos  	pr5|19		tty_buf.output_buffer_overflow
						STATEMENT 1 ON LINE 1020
try_again:					/* here if we overflowed internal buffer space */
	     if whole_string			/* mustn't subdivide caller's string */
	     then do;

002722  aa  6 00040 3735 20	epp7 	pr6|32,*
002723  aa  7 00112 2351 00	lda  	pr7|74		whole_string
002724  aa   000005 6000 04	tze  	5,ic		002731
						STATEMENT 1 ON LINE 1023
		nelemt = 0;

002725  aa  7 00106 4501 00	stz  	pr7|70		nelemt
						STATEMENT 1 ON LINE 1024
		go to nothing_written;

002726  aa   003225 3520 04	epp2 	1685,ic		006153 = 600326373520
002727  aa   000001 7270 07	lxl7 	1,dl
002730  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 1025
	     end;

						STATEMENT 1 ON LINE 1027
	     tty_buf.output_restart = tty_buf.output_restart + 1;

002731  aa  7 00322 3715 20	epp5 	pr7|210,*		ttybp
002732  aa  5 00022 0541 00	aos  	pr5|18		tty_buf.output_restart
						STATEMENT 1 ON LINE 1029
	     nelemt = divide (nelemt, 2, 18, 0);

002733  aa  7 00106 2361 00	ldq  	pr7|70		nelemt
002734  aa   000002 5060 07	div  	2,dl
002735  aa  7 00106 7561 00	stq  	pr7|70		nelemt
						STATEMENT 1 ON LINE 1030
	     if nelemt > 0				/* does that leave us anything to process? */
	     then go to restart;

002736  aa   776143 6054 04	tpnz 	-925,ic		001101
						STATEMENT 1 ON LINE 1032
	     else go to nothing_written;

002737  aa   003214 3520 04	epp2 	1676,ic		006153 = 600326373520
002740  aa   000001 7270 07	lxl7 	1,dl
002741  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 1038
table_error:
	     ercode = error_table_$improper_data_format;

002742  aa  6 00044 3701 20	epp4 	pr6|36,*
002743  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$improper_data_format
002744  aa  6 00040 3735 20	epp7 	pr6|32,*
002745  aa  7 00344 7561 20	stq  	pr7|228,*		ercode
						STATEMENT 1 ON LINE 1040
	     go to unlock;

002746  aa   003161 3520 04	epp2 	1649,ic		006127 = 001435700100
002747  aa   000001 7270 07	lxl7 	1,dl
002750  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 2008
	end /* giant begin block */;

002751  aa   003076 7100 04	tra  	1598,ic		006047
BEGIN PROCEDURE copy_chars
ENTRY TO copy_chars                                         STATEMENT 1 ON LINE 1044
copy_chars:
     proc;

002752  aa  6 00110 6501 00	spri4	pr6|72
						STATEMENT 1 ON LINE 1049
	target_len = target_len + ctally;

002753  aa  6 00040 3735 20	epp7 	pr6|32,*
002754  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
002755  aa  7 00146 0561 00	asq  	pr7|102		target_len
						STATEMENT 1 ON LINE 1050
	if target_len > max_chars			/* check for overflow */
	then go to try_again;

002756  aa  7 00146 2361 00	ldq  	pr7|102		target_len
002757  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
002760  aa   777742 6054 04	tpnz 	-30,ic		002722
						STATEMENT 1 ON LINE 1053
	target_ptr -> tally_chars = source_ptr -> tally_chars;

002761  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
002762  aa  7 00140 3535 20	epp3 	pr7|96,*		source_ptr
002763  aa  7 00265 7271 00	lxl7 	pr7|181		util.ctally
002764  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002765  aa  3 00000 00 0017	desc9a	pr3|0,x7		tally_chars
002766  aa  5 00000 00 0017	desc9a	pr5|0,x7		tally_chars
						STATEMENT 1 ON LINE 1055
	source_ptr = addr (source_ptr -> based_chars (ctally));

002767  aa  3 00000 3521 00	epp2 	pr3|0		based_chars
002770  aa  2 00000 5005 17	a9bd 	pr2|0,7
002771  aa  7 00140 2521 00	spri2	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1057
	target_ptr = addr (target_ptr -> based_chars (ctally));

002772  aa  5 00000 3521 00	epp2 	pr5|0		based_chars
002773  aa  2 00000 5005 17	a9bd 	pr2|0,7
002774  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1058
	return;

002775  aa  6 00110 6101 00	rtcd 	pr6|72
						STATEMENT 1 ON LINE 1060
     end /* copy_chars */;

  END PROCEDURE copy_chars
BEGIN PROCEDURE insert_char
ENTRY TO insert_char                                        STATEMENT 1 ON LINE 1062
insert_char:
     proc (one_char);

002776  aa  6 00116 6501 00	spri4	pr6|78
002777  aa  6 00120 2521 00	spri2	pr6|80
						STATEMENT 1 ON LINE 1069
	target_len = target_len + 1;

003000  aa  6 00040 3735 20	epp7 	pr6|32,*
003001  aa  7 00146 0541 00	aos  	pr7|102		target_len
						STATEMENT 1 ON LINE 1070
	if target_len > max_chars			/* mustn't overflow buffer space */
	then go to try_again;

003002  aa  7 00146 2361 00	ldq  	pr7|102		target_len
003003  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
003004  aa   777716 6054 04	tpnz 	-50,ic		002722
						STATEMENT 1 ON LINE 1073
	target_ptr -> based_onechar = one_char;

003005  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
003006  aa  2 00002 3535 20	epp3 	pr2|2,*
003007  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
003010  aa  3 00000 00 0001	desc9a	pr3|0,1		one_char
003011  aa  5 00000 00 0001	desc9a	pr5|0,1		based_onechar
						STATEMENT 1 ON LINE 1074
	target_ptr = addr (target_ptr -> based_chars (1));

003012  aa   000001 7270 07	lxl7 	1,dl
003013  aa  5 00000 3521 00	epp2 	pr5|0		based_chars
003014  aa  2 00000 5005 17	a9bd 	pr2|0,7
003015  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1075
	return;

003016  aa  6 00116 6101 00	rtcd 	pr6|78
						STATEMENT 1 ON LINE 1077
     end /* insert_char */;

  END PROCEDURE insert_char
BEGIN PROCEDURE insert_delays
ENTRY TO insert_delays                                      STATEMENT 1 ON LINE 1079
insert_delays:
     proc (ndelays);

003017  aa  6 00124 6501 00	spri4	pr6|84
003020  aa  6 00126 2521 00	spri2	pr6|86
						STATEMENT 1 ON LINE 1087
	if ndelays <= 0
	then return;

003021  aa  2 00002 2361 20	ldq  	pr2|2,*		ndelays
003022  aa   000002 6054 04	tpnz 	2,ic		003024
003023  aa  6 00124 6101 00	rtcd 	pr6|84
						STATEMENT 1 ON LINE 1090
	target_len = target_len + ndelays;

003024  aa  6 00040 3735 20	epp7 	pr6|32,*
003025  aa  7 00146 0561 00	asq  	pr7|102		target_len
						STATEMENT 1 ON LINE 1091
	if target_len > max_chars			/* red warning */
	then go to try_again;

003026  aa  7 00146 2361 00	ldq  	pr7|102		target_len
003027  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
003030  aa   777672 6054 04	tpnz 	-70,ic		002722
						STATEMENT 1 ON LINE 1094
	do i = 0 to ndelays - 1;

003031  aa  2 00002 2361 20	ldq  	pr2|2,*		ndelays
003032  aa   000001 1760 07	sbq  	1,dl
003033  aa  6 00133 7561 00	stq  	pr6|91
003034  aa  6 00132 4501 00	stz  	pr6|90		i
003035  aa   000000 0110 03	nop  	0,du
003036  aa  6 00132 2361 00	ldq  	pr6|90		i
003037  aa  6 00133 1161 00	cmpq 	pr6|91
003040  aa   000014 6054 04	tpnz 	12,ic		003054
						STATEMENT 1 ON LINE 1095
	     target_ptr -> based_chars (i) = byte (delay_char);

003041  aa   000000 2360 07	ldq  	0,dl
003042  aa   000077 7370 00	lls  	63
003043  aa  6 00056 7551 00	sta  	pr6|46
003044  aa  6 00040 3735 20	epp7 	pr6|32,*
003045  aa  6 00132 7271 00	lxl7 	pr6|90		i
003046  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
003047  aa  040 117 100 500	mlr  	(pr),(pr,x7),fill(040)
003050  aa  6 00056 00 0001	desc9a	pr6|46,1
003051  aa  5 00000 00 0001	desc9a	pr5|0,1		based_chars
						STATEMENT 1 ON LINE 1096
	end;

003052  aa  6 00132 0541 00	aos  	pr6|90		i
003053  aa   777763 7100 04	tra  	-13,ic		003036
						STATEMENT 1 ON LINE 1098
	target_ptr = addr (target_ptr -> based_chars (ndelays));

003054  aa  6 00126 3735 20	epp7 	pr6|86,*
003055  aa  7 00002 7271 20	lxl7 	pr7|2,*		ndelays
003056  aa  6 00040 3715 20	epp5 	pr6|32,*
003057  aa  5 00144 3521 20	epp2 	pr5|100,*		based_chars
003060  aa  2 00000 5005 17	a9bd 	pr2|0,7
003061  aa  5 00144 2521 00	spri2	pr5|100		target_ptr
						STATEMENT 1 ON LINE 1100
	return;

003062  aa  6 00124 6101 00	rtcd 	pr6|84
						STATEMENT 1 ON LINE 1102
     end /* insert_delays */;

  END PROCEDURE insert_delays
BEGIN PROCEDURE insert_sequence
ENTRY TO insert_sequence                                    STATEMENT 1 ON LINE 1104
insert_sequence:
     proc (a_col_sw);

003063  aa  6 00134 6501 00	spri4	pr6|92
003064  aa  6 00136 2521 00	spri2	pr6|94
						STATEMENT 1 ON LINE 1115
	col_sw = a_col_sw;

003065  aa  2 00002 2351 20	lda  	pr2|2,*		a_col_sw
003066  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003067  aa  6 00142 7551 00	sta  	pr6|98		col_sw
						STATEMENT 1 ON LINE 1116
	c_chars_ptr = seqp;

003070  aa  6 00040 3735 20	epp7 	pr6|32,*
003071  aa  7 00174 3735 20	epp7 	pr7|124,*		seqp
003072  aa  6 00040 3715 20	epp5 	pr6|32,*
003073  aa  5 00320 6535 00	spri7	pr5|208		c_chars_ptr
						STATEMENT 1 ON LINE 1117
	auto_len = seqp -> seq.count;

003074  aa  7 00000 2351 00	lda  	pr7|0		seq.count
003075  aa   000077 7330 00	lrs  	63
003076  aa  6 00144 7561 00	stq  	pr6|100		auto_len
						STATEMENT 1 ON LINE 1118
	if auto_len = 0
	then return;

003077  aa   000002 6010 04	tnz  	2,ic		003101
003100  aa  6 00134 6101 00	rtcd 	pr6|92
						STATEMENT 1 ON LINE 1121
	if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)/* probably not a real sequence */
	then go to table_error;

003101  aa   777641 6040 04	tmi  	-95,ic		002742
003102  aa   000017 1160 07	cmpq 	15,dl
003103  aa   777637 6054 04	tpnz 	-97,ic		002742
						STATEMENT 1 ON LINE 1124
	target_len = target_len + auto_len;

003104  aa  5 00146 0561 00	asq  	pr5|102		target_len
						STATEMENT 1 ON LINE 1125
	if target_len > max_chars
	then go to try_again;

003105  aa  5 00146 2361 00	ldq  	pr5|102		target_len
003106  aa  5 00127 1161 00	cmpq 	pr5|87		max_chars
003107  aa   777613 6054 04	tpnz 	-117,ic		002722
						STATEMENT 1 ON LINE 1128
	if seqp -> seq.chars (1) = ascii_escape_char
	then col_sw = "0"b;

003110  aa   774777 2350 04	lda  	-1537,ic		000107 = 033000000000
003111  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003112  aa  6 00340 7551 00	sta  	pr6|224		ascii_escape_char
003113  aa  7 00000 2351 00	lda  	pr7|0		seq.chars
003114  aa   000011 7350 00	als  	9
003115  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003116  aa  6 00340 1151 00	cmpa 	pr6|224		ascii_escape_char
003117  aa   000002 6010 04	tnz  	2,ic		003121
003120  aa  6 00142 4501 00	stz  	pr6|98		col_sw
						STATEMENT 1 ON LINE 1130
	do i = 1 to auto_len;

003121  aa  6 00144 2361 00	ldq  	pr6|100		auto_len
003122  aa  6 00145 7561 00	stq  	pr6|101
003123  aa   000001 2360 07	ldq  	1,dl
003124  aa  6 00143 7561 00	stq  	pr6|99		i
003125  aa   000000 0110 03	nop  	0,du
003126  aa  6 00143 2361 00	ldq  	pr6|99		i
003127  aa  6 00145 1161 00	cmpq 	pr6|101
003130  aa   000072 6054 04	tpnz 	58,ic		003222
						STATEMENT 1 ON LINE 1131
	     if col_sw				/* do we care about column position? */
	     then do;

003131  aa  6 00142 2351 00	lda  	pr6|98		col_sw
003132  aa   000053 6000 04	tze  	43,ic		003205
						STATEMENT 1 ON LINE 1133
		if seqp -> seq.chars (i) = backspace	/* back up with delays in this case */
		then do;

003133  aa  6 00040 3735 20	epp7 	pr6|32,*
003134  aa  7 00174 3715 20	epp5 	pr7|124,*		seqp
003135  aa  000 100 100 506	mlr  	(pr,ql),(pr),fill(000)
003136  aa  5 00000 00 0001	desc9a	pr5|0,1		seq.chars
003137  aa  6 00340 00 0004	desc9a	pr6|224,4		seq.chars
003140  aa  6 00340 2351 00	lda  	pr6|224		seq.chars
003141  aa   010000 1150 03	cmpa 	4096,du
003142  aa   000023 6010 04	tnz  	19,ic		003165
						STATEMENT 1 ON LINE 1135
		     col = max (0, col - 1);

003143  aa  7 00167 2361 00	ldq  	pr7|119		col
003144  aa   000001 1760 07	sbq  	1,dl
003145  aa   000000 1160 07	cmpq 	0,dl
003146  aa   000002 6050 04	tpl  	2,ic		003150
003147  aa   000000 2360 07	ldq  	0,dl
003150  aa  7 00167 7561 00	stq  	pr7|119		col
						STATEMENT 1 ON LINE 1136
		     if delay_ptr ^= null
		     then call insert_delays (delay_ptr -> delay.backspace);

003151  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
003152  aa   774754 6770 04	eraq 	-1556,ic		000126 = 077777000043 000001000000
003153  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003154  aa   000031 6000 04	tze  	25,ic		003205
003155  aa  7 00124 3535 20	epp3 	pr7|84,*		delay_ptr
003156  aa  3 00004 3521 00	epp2 	pr3|4		delay.backspace
003157  aa  6 00344 2521 00	spri2	pr6|228
003160  aa  6 00342 3521 00	epp2 	pr6|226
003161  aa   004000 4310 07	fld  	2048,dl
003162  aa  2 00000 7571 00	staq 	pr2|0
003163  aa   777634 6700 04	tsp4 	-100,ic		003017
						STATEMENT 1 ON LINE 1138
		end;

003164  aa   000021 7100 04	tra  	17,ic		003205
						STATEMENT 1 ON LINE 1140
		else if rank (seqp -> seq.chars (i)) < 32
		then ;

003165  aa   000077 7730 00	lrl  	63
003166  aa   000040 1160 07	cmpq 	32,dl
003167  aa   000002 6050 04	tpl  	2,ic		003171
003170  aa   000015 7100 04	tra  	13,ic		003205
						STATEMENT 1 ON LINE 1145
		else do;

						STATEMENT 1 ON LINE 1146
		     if ((tcb.colmax > 0) & (col >= tcb.colmax))
		     then call insert_nl ("1"b);

003171  aa  7 00330 3535 20	epp3 	pr7|216,*		tcbp
003172  aa  3 00021 2351 00	lda  	pr3|17		tcb.colmax
003173  aa   000077 7330 00	lrs  	63
003174  aa   000007 6044 04	tmoz 	7,ic		003203
003175  aa  7 00167 1161 00	cmpq 	pr7|119		col
003176  aa   000005 6054 04	tpnz 	5,ic		003203
003177  aa   400000 2350 03	lda  	131072,du
003200  aa  6 00340 7551 00	sta  	pr6|224
003201  aa   003247 3520 04	epp2 	1703,ic		006450 = 000002000000
003202  aa   000221 6700 04	tsp4 	145,ic		003423
						STATEMENT 1 ON LINE 1148
		     col = col + 1;

003203  aa  6 00040 3735 20	epp7 	pr6|32,*
003204  aa  7 00167 0541 00	aos  	pr7|119		col
						STATEMENT 1 ON LINE 1149
		end;

						STATEMENT 1 ON LINE 1150
	     end;

						STATEMENT 1 ON LINE 1152
	     target_ptr -> based_onechar = seqp -> seq.chars (i);

003205  aa  6 00040 3735 20	epp7 	pr6|32,*
003206  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
003207  aa  6 00143 7271 00	lxl7 	pr6|99		i
003210  aa  7 00174 3535 20	epp3 	pr7|124,*		seqp
003211  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
003212  aa  3 00000 00 0001	desc9a	pr3|0,1		seq.chars
003213  aa  5 00000 00 0001	desc9a	pr5|0,1		based_onechar
						STATEMENT 1 ON LINE 1153
	     target_ptr = addr (target_ptr -> based_chars (1));

003214  aa   000001 7260 07	lxl6 	1,dl
003215  aa  5 00000 3521 00	epp2 	pr5|0		based_chars
003216  aa  2 00000 5005 16	a9bd 	pr2|0,6
003217  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1155
	end;

003220  aa  6 00143 0541 00	aos  	pr6|99		i
003221  aa   777705 7100 04	tra  	-59,ic		003126
						STATEMENT 1 ON LINE 1157
	return;

003222  aa  6 00134 6101 00	rtcd 	pr6|92
						STATEMENT 1 ON LINE 1159
     end /* insert_sequence */;

  END PROCEDURE insert_sequence
BEGIN PROCEDURE insert_white
ENTRY TO insert_white                                       STATEMENT 1 ON LINE 1161
insert_white:
     proc;

003223  aa  6 00146 6501 00	spri4	pr6|102
						STATEMENT 1 ON LINE 1166
	if wcol ^= col				/* make sure we're not already where we belong */
	then do;

003224  aa  6 00040 3735 20	epp7 	pr6|32,*
003225  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003226  aa  7 00167 1161 00	cmpq 	pr7|119		col
003227  aa   000170 6000 04	tze  	120,ic		003417
						STATEMENT 1 ON LINE 1168
	     if tcb.colmax > 0
	     then do while (wcol > tcb.colmax);

003230  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
003231  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
003232  aa   000077 7330 00	lrs  	63
003233  aa   000027 6044 04	tmoz 	23,ic		003262
003234  aa  6 00040 3735 20	epp7 	pr6|32,*
003235  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
003236  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
003237  aa   000077 7330 00	lrs  	63
003240  aa  7 00170 1161 00	cmpq 	pr7|120		wcol
003241  aa   000021 6050 04	tpl  	17,ic		003262
						STATEMENT 1 ON LINE 1170
		call insert_nl ("1"b);

003242  aa   400000 2350 03	lda  	131072,du
003243  aa  6 00350 7551 00	sta  	pr6|232
003244  aa   003200 3520 04	epp2 	1664,ic		006444 = 000002000000
003245  aa   000156 6700 04	tsp4 	110,ic		003423
						STATEMENT 1 ON LINE 1171
		oldcol = 2;

003246  aa   000002 2360 07	ldq  	2,dl
003247  aa  6 00040 3735 20	epp7 	pr6|32,*
003250  aa  7 00171 7561 00	stq  	pr7|121		oldcol
						STATEMENT 1 ON LINE 1172
		wcol = wcol - tcb.colmax + 2;

003251  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
003252  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
003253  aa   000077 7330 00	lrs  	63
003254  aa  6 00350 7561 00	stq  	pr6|232		tcb.colmax
003255  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003256  aa  6 00350 1761 00	sbq  	pr6|232		tcb.colmax
003257  aa   000002 0760 07	adq  	2,dl
003260  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 1173
	     end;

003261  aa   777753 7100 04	tra  	-21,ic		003234
						STATEMENT 1 ON LINE 1175
	     if wcol < col				/* we're going to have to back up */
	     then if wcol = 0			/* that one's easy */
		then call insert_cr;

003262  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003263  aa  7 00167 1161 00	cmpq 	pr7|119		col
003264  aa   000065 6050 04	tpl  	53,ic		003351
003265  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003266  aa   000003 6010 04	tnz  	3,ic		003271
003267  aa   000414 6700 04	tsp4 	268,ic		003703
003270  aa   000061 7100 04	tra  	49,ic		003351
						STATEMENT 1 ON LINE 1179
		else if special_ptr -> special_chars.cr_seq.count > 0
		then do;

003271  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
003272  aa  3 00004 2351 00	lda  	pr3|4		special_chars.count
003273  aa   000077 7330 00	lrs  	63
003274  aa   000050 6044 04	tmoz 	40,ic		003344
						STATEMENT 1 ON LINE 1181
		     back_chars = col - wcol;

003275  aa  7 00167 2361 00	ldq  	pr7|119		col
003276  aa  7 00170 1761 00	sbq  	pr7|120		wcol
003277  aa  7 00211 7561 00	stq  	pr7|137		back_chars
						STATEMENT 1 ON LINE 1182
		     if back_chars <= 6		/* in this case don't bother calculating other */
		     then forward_chars = back_chars;

003300  aa   000006 1160 07	cmpq 	6,dl
003301  aa   000003 6054 04	tpnz 	3,ic		003304
003302  aa  7 00212 7561 00	stq  	pr7|138		forward_chars
003303  aa   000021 7100 04	tra  	17,ic		003324
						STATEMENT 1 ON LINE 1184
		     else if tcb.modes.tabm
		     then forward_chars = divide (wcol, 10, 17, 0) + mod (wcol, 10) + 1;

003304  aa  5 00017 2351 00	lda  	pr5|15		tcb.tabm
003305  aa   200000 3150 03	cana 	65536,du
003306  aa   000013 6000 04	tze  	11,ic		003321
003307  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003310  aa   003170 3520 04	epp2 	1656,ic		006500 = 000000000012
003311  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
003312  aa  6 00350 7561 00	stq  	pr6|232
003313  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003314  aa  2 00000 5061 00	div  	pr2|0
003315  aa  6 00350 0761 00	adq  	pr6|232
003316  aa   000001 0760 07	adq  	1,dl
003317  aa  7 00212 7561 00	stq  	pr7|138		forward_chars
003320  aa   000004 7100 04	tra  	4,ic		003324
						STATEMENT 1 ON LINE 1187
		     else forward_chars = wcol + 1;

003321  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003322  aa   000001 0760 07	adq  	1,dl
003323  aa  7 00212 7561 00	stq  	pr7|138		forward_chars
						STATEMENT 1 ON LINE 1189
		     if back_chars - forward_chars > 6 | special_ptr -> special_chars.bs_seq.count = 0
						/* no backspace available */
		     then call insert_cr;

003324  aa  7 00211 2361 00	ldq  	pr7|137		back_chars
003325  aa  7 00212 1761 00	sbq  	pr7|138		forward_chars
003326  aa   000006 1160 07	cmpq 	6,dl
003327  aa   000004 6054 04	tpnz 	4,ic		003333
003330  aa  3 00010 2351 00	lda  	pr3|8		special_chars.count
003331  aa   000077 7330 00	lrs  	63
003332  aa   000003 6010 04	tnz  	3,ic		003335
003333  aa   000350 6700 04	tsp4 	232,ic		003703
003334  aa   000015 7100 04	tra  	13,ic		003351
						STATEMENT 1 ON LINE 1192
		     else call insert_bs (back_chars);

003335  aa  7 00211 3521 00	epp2 	pr7|137		back_chars
003336  aa  6 00354 2521 00	spri2	pr6|236
003337  aa  6 00352 3521 00	epp2 	pr6|234
003340  aa   004000 4310 07	fld  	2048,dl
003341  aa  2 00000 7571 00	staq 	pr2|0
003342  aa   000423 6700 04	tsp4 	275,ic		003765
						STATEMENT 1 ON LINE 1193
		end;

003343  aa   000006 7100 04	tra  	6,ic		003351
						STATEMENT 1 ON LINE 1195
		else call insert_bs (col - wcol);

003344  aa  7 00167 2361 00	ldq  	pr7|119		col
003345  aa  7 00170 1761 00	sbq  	pr7|120		wcol
003346  aa  6 00351 7561 00	stq  	pr6|233
003347  aa   003071 3520 04	epp2 	1593,ic		006440 = 000002000000
003350  aa   000415 6700 04	tsp4 	269,ic		003765
						STATEMENT 1 ON LINE 1197
	     if wcol > col				/* we have to go forward */
	     then do;

003351  aa  6 00040 3735 20	epp7 	pr6|32,*
003352  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003353  aa  7 00167 1161 00	cmpq 	pr7|119		col
003354  aa   000043 6044 04	tmoz 	35,ic		003417
						STATEMENT 1 ON LINE 1199
		if tcb.modes.tabm			/* might we use tabs? */
		then do;

003355  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
003356  aa  5 00017 2351 00	lda  	pr5|15		tcb.tabm
003357  aa   200000 3150 03	cana 	65536,du
003360  aa   000022 6000 04	tze  	18,ic		003402
						STATEMENT 1 ON LINE 1201
		     do while (wcol - col > 10);

003361  aa   000000 0110 03	nop  	0,du
003362  aa  6 00040 3735 20	epp7 	pr6|32,*
003363  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003364  aa  7 00167 1761 00	sbq  	pr7|119		col
003365  aa   000012 1160 07	cmpq 	10,dl
003366  aa   000003 6044 04	tmoz 	3,ic		003371
						STATEMENT 1 ON LINE 1202
			call insert_tab;

003367  aa   000670 6700 04	tsp4 	440,ic		004257
						STATEMENT 1 ON LINE 1203
		     end;

003370  aa   777772 7100 04	tra  	-6,ic		003362
						STATEMENT 1 ON LINE 1205
		     if mod (wcol, 10) <= mod (col, 10) /* room for another tab */
		     then call insert_tab;

003371  aa  7 00167 2361 00	ldq  	pr7|119		col
003372  aa   003106 3520 04	epp2 	1606,ic		006500 = 000000000012
003373  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
003374  aa  6 00351 7561 00	stq  	pr6|233
003375  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003376  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
003377  aa  6 00351 1161 00	cmpq 	pr6|233
003400  aa   000002 6054 04	tpnz 	2,ic		003402
003401  aa   000656 6700 04	tsp4 	430,ic		004257
						STATEMENT 1 ON LINE 1207
		end;

						STATEMENT 1 ON LINE 1209
		do col = col by 1 while (col < wcol);

003402  aa  6 00040 3735 20	epp7 	pr6|32,*
003403  aa  7 00167 2361 00	ldq  	pr7|119		col
003404  aa  7 00167 7561 00	stq  	pr7|119		col
003405  aa   000000 0110 03	nop  	0,du
003406  aa  6 00040 3735 20	epp7 	pr6|32,*
003407  aa  7 00167 2361 00	ldq  	pr7|119		col
003410  aa  7 00170 1161 00	cmpq 	pr7|120		wcol
003411  aa   000006 6050 04	tpl  	6,ic		003417
						STATEMENT 1 ON LINE 1210
		     call insert_char (space);

003412  aa   003022 3520 04	epp2 	1554,ic		006434 = 000002000000
003413  aa   777363 6700 04	tsp4 	-269,ic		002776
						STATEMENT 1 ON LINE 1211
		end;

003414  aa  6 00040 3735 20	epp7 	pr6|32,*
003415  aa  7 00167 0541 00	aos  	pr7|119		col
003416  aa   777770 7100 04	tra  	-8,ic		003406
						STATEMENT 1 ON LINE 1212
	     end;

						STATEMENT 1 ON LINE 1213
	end;

						STATEMENT 1 ON LINE 1215
	oldcol = wcol;

003417  aa  7 00170 2361 00	ldq  	pr7|120		wcol
003420  aa  7 00171 7561 00	stq  	pr7|121		oldcol
						STATEMENT 1 ON LINE 1216
	white_sw = "0"b;

003421  aa  7 00165 4501 00	stz  	pr7|117		white_sw
						STATEMENT 1 ON LINE 1217
	return;

003422  aa  6 00146 6101 00	rtcd 	pr6|102
						STATEMENT 1 ON LINE 1219
     end /* insert_white */;

  END PROCEDURE insert_white
BEGIN PROCEDURE insert_nl
ENTRY TO insert_nl                                          STATEMENT 1 ON LINE 1221
insert_nl:
     proc (esc_sw);

003423  aa  6 00154 6501 00	spri4	pr6|108
003424  aa  6 00156 2521 00	spri2	pr6|110
						STATEMENT 1 ON LINE 1234
	eop_sw = "0"b;

003425  aa  6 00163 4501 00	stz  	pr6|115		eop_sw
						STATEMENT 1 ON LINE 1235
	eop_seqp = null;

003426  aa   774500 2370 04	ldaq 	-1728,ic		000126 = 077777000043 000001000000
003427  aa  6 00164 7571 00	staq 	pr6|116		eop_seqp
						STATEMENT 1 ON LINE 1237
	if tcb.linemax > 0
	then do;

003430  aa  6 00040 3735 20	epp7 	pr6|32,*
003431  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
003432  aa  5 00021 2351 00	lda  	pr5|17		tcb.linemax
003433  aa   000011 7350 00	als  	9
003434  aa   000077 7330 00	lrs  	63
003435  aa  6 00360 7561 00	stq  	pr6|240		tcb.linemax
003436  aa   000017 6044 04	tmoz 	15,ic		003455
						STATEMENT 1 ON LINE 1239
	     line_count = line_count + 1;

003437  aa  7 00166 0541 00	aos  	pr7|118		line_count
						STATEMENT 1 ON LINE 1240
	     eop_sw = (line_count >= tcb.linemax);

003440  aa  7 00166 1161 00	cmpq 	pr7|118		line_count
003441  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
003442  aa  6 00163 7551 00	sta  	pr6|115		eop_sw
						STATEMENT 1 ON LINE 1241
	     if eop_sw
	     then do;

003443  aa   000012 6000 04	tze  	10,ic		003455
						STATEMENT 1 ON LINE 1243
		eop_seqp = addr (special_ptr -> special_chars.end_of_page);

003444  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
003445  aa  3 00050 3535 00	epp3 	pr3|40		special_chars.end_of_page
003446  aa  6 00164 2535 00	spri3	pr6|116		eop_seqp
						STATEMENT 1 ON LINE 1244
		if eop_seqp -> seq.count = 0		/* null end-of-page sequence */
		then eop_seqp = null;

003447  aa  3 00000 2351 00	lda  	pr3|0		seq.count
003450  aa   000077 7330 00	lrs  	63
003451  aa   000003 6010 04	tnz  	3,ic		003454
003452  aa   774454 2370 04	ldaq 	-1748,ic		000126 = 077777000043 000001000000
003453  aa  6 00164 7571 00	staq 	pr6|116		eop_seqp
						STATEMENT 1 ON LINE 1246
		line_count = 0;

003454  aa  7 00166 4501 00	stz  	pr7|118		line_count
						STATEMENT 1 ON LINE 1247
	     end;

						STATEMENT 1 ON LINE 1248
	end;

						STATEMENT 1 ON LINE 1250
	if eop_sw & (eop_seqp = null)			/* omit end-of-page marker and put sentinel before newline */
	then do;

003455  aa  6 00163 2351 00	lda  	pr6|115		eop_sw
003456  aa   000024 6000 04	tze  	20,ic		003502
003457  aa  6 00164 2371 00	ldaq 	pr6|116		eop_seqp
003460  aa   774446 6770 04	eraq 	-1754,ic		000126 = 077777000043 000001000000
003461  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003462  aa   000020 6010 04	tnz  	16,ic		003502
						STATEMENT 1 ON LINE 1252
	     if target_len = 0			/* don't let sentinel be first thing in output */
	     then call insert_char (byte (delay_char));

003463  aa  7 00146 2361 00	ldq  	pr7|102		target_len
003464  aa   000006 6010 04	tnz  	6,ic		003472
003465  aa   000000 2360 07	ldq  	0,dl
003466  aa   000077 7370 00	lls  	63
003467  aa  6 00360 7551 00	sta  	pr6|240
003470  aa   002740 3520 04	epp2 	1504,ic		006430 = 000002000000
003471  aa   777305 6700 04	tsp4 	-315,ic		002776
						STATEMENT 1 ON LINE 1254
	     call insert_char (eop_sentinel);

003472  aa  6 00040 3735 20	epp7 	pr6|32,*
003473  aa  7 00310 3521 00	epp2 	pr7|200		eop_sentinel
003474  aa  6 00364 2521 00	spri2	pr6|244
003475  aa  6 00362 3521 00	epp2 	pr6|242
003476  aa   004000 4310 07	fld  	2048,dl
003477  aa  2 00000 7571 00	staq 	pr2|0
003500  aa   777276 6700 04	tsp4 	-322,ic		002776
						STATEMENT 1 ON LINE 1255
	end;

003501  aa   000116 7100 04	tra  	78,ic		003617
						STATEMENT 1 ON LINE 1257
	else do;

						STATEMENT 1 ON LINE 1258
	     seqp = addr (special_ptr -> special_chars.nl_seq);

003502  aa  7 00122 3535 20	epp3 	pr7|82,*		special_chars.nl_seq
003503  aa  6 00166 2535 00	spri3	pr6|118		seqp
						STATEMENT 1 ON LINE 1261
	     if delay_ptr ^= null			/* delays needed */
	     then do;

003504  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
003505  aa   774421 6770 04	eraq 	-1775,ic		000126 = 077777000043 000001000000
003506  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003507  aa   000045 6000 04	tze  	37,ic		003554
						STATEMENT 1 ON LINE 1263
		horiz = delay_ptr -> delay.horz_nl;

003510  aa  7 00124 3515 20	epp1 	pr7|84,*		delay_ptr
003511  aa  1 00001 4311 00	fld  	pr1|1		delay.horz_nl
003512  aa  7 00213 4551 00	fst  	pr7|139		horiz
						STATEMENT 1 ON LINE 1264
		vert = delay_ptr -> delay.vert_nl;

003513  aa  1 00000 2361 00	ldq  	pr1|0		delay.vert_nl
003514  aa  7 00214 7561 00	stq  	pr7|140		vert
						STATEMENT 1 ON LINE 1266
		if vert < 0			/* special */
		then do;

003515  aa   000027 6050 04	tpl  	23,ic		003544
						STATEMENT 1 ON LINE 1268
		     ll = index (reverse (final_outp -> based_target_chars), nl) - 1;

003516  aa  7 00134 3715 20	epp5 	pr7|92,*		final_outp
003517  aa  7 00146 7271 00	lxl7 	pr7|102		target_len
003520  aa  000 003 125 540	scmr 	(pr,rl),(du),mask(000)
003521  aa  5 00000 00 0017	desc9a	pr5|0,x7		based_target_chars
003522  aa   012000 00 0001	desc9a	5120,1
003523  aa  6 00056 0001 00	arg  	pr6|46
003524  aa  6 00056 2361 00	ldq  	pr6|46
003525  aa   000002 6070 04	ttf  	2,ic		003527
003526  aa   000001 3360 07	lcq  	1,dl
003527  aa  7 00215 7561 00	stq  	pr7|141		ll
						STATEMENT 1 ON LINE 1270
		     if ll < 0
		     then ll = target_len;

003530  aa   000003 6050 04	tpl  	3,ic		003533
003531  aa  7 00146 2361 00	ldq  	pr7|102		target_len
003532  aa  7 00215 7561 00	stq  	pr7|141		ll
						STATEMENT 1 ON LINE 1272
		     n_delays = max (0, -vert - ll);

003533  aa  7 00214 3361 00	lcq  	pr7|140		vert
003534  aa  7 00215 1761 00	sbq  	pr7|141		ll
003535  aa   000000 1160 07	cmpq 	0,dl
003536  aa   000002 6050 04	tpl  	2,ic		003540
003537  aa   000000 2360 07	ldq  	0,dl
003540  aa  7 00210 7561 00	stq  	pr7|136		n_delays
						STATEMENT 1 ON LINE 1274
		     delay_before = "1"b;

003541  aa   400000 2350 03	lda  	131072,du
003542  aa  6 00162 7551 00	sta  	pr6|114		delay_before
						STATEMENT 1 ON LINE 1275
		end;

003543  aa   000012 7100 04	tra  	10,ic		003555
						STATEMENT 1 ON LINE 1277
		else do;

						STATEMENT 1 ON LINE 1278
		     delay_before = "0"b;

003544  aa  6 00162 4501 00	stz  	pr6|114		delay_before
						STATEMENT 1 ON LINE 1279
		     n_delays = vert + fixed (float (col) * horiz, 17, 0);

003545  aa  7 00167 2361 00	ldq  	pr7|119		col
003546  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003547  aa  7 00213 4611 00	fmp  	pr7|139		horiz
003550  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
003551  aa  7 00214 0761 00	adq  	pr7|140		vert
003552  aa  7 00210 7561 00	stq  	pr7|136		n_delays
						STATEMENT 1 ON LINE 1280
		end;

						STATEMENT 1 ON LINE 1281
	     end;

003553  aa   000002 7100 04	tra  	2,ic		003555
						STATEMENT 1 ON LINE 1283
	     else n_delays = 0;

003554  aa  7 00210 4501 00	stz  	pr7|136		n_delays
						STATEMENT 1 ON LINE 1285
	     if delay_before			/* do it now */
	     then if n_delays > 0			/* if at all */
		then call insert_delays (n_delays);

003555  aa  6 00162 2351 00	lda  	pr6|114		delay_before
003556  aa   000011 6000 04	tze  	9,ic		003567
003557  aa  7 00210 2361 00	ldq  	pr7|136		n_delays
003560  aa   000007 6044 04	tmoz 	7,ic		003567
003561  aa  7 00210 3521 00	epp2 	pr7|136		n_delays
003562  aa  6 00364 2521 00	spri2	pr6|244
003563  aa  6 00362 3521 00	epp2 	pr6|242
003564  aa   004000 4310 07	fld  	2048,dl
003565  aa  2 00000 7571 00	staq 	pr2|0
003566  aa   777231 6700 04	tsp4 	-359,ic		003017
						STATEMENT 1 ON LINE 1289
	     call insert_sequence_internal;

003567  aa   000047 6700 04	tsp4 	39,ic		003636
						STATEMENT 1 ON LINE 1291
	     if ^delay_before
	     then if n_delays > 0
		then call insert_delays (n_delays);

003570  aa  6 00162 2351 00	lda  	pr6|114		delay_before
003571  aa   000012 6010 04	tnz  	10,ic		003603
003572  aa  6 00040 3735 20	epp7 	pr6|32,*
003573  aa  7 00210 2361 00	ldq  	pr7|136		n_delays
003574  aa   000007 6044 04	tmoz 	7,ic		003603
003575  aa  7 00210 3521 00	epp2 	pr7|136		n_delays
003576  aa  6 00364 2521 00	spri2	pr6|244
003577  aa  6 00362 3521 00	epp2 	pr6|242
003600  aa   004000 4310 07	fld  	2048,dl
003601  aa  2 00000 7571 00	staq 	pr2|0
003602  aa   777215 6700 04	tsp4 	-371,ic		003017
						STATEMENT 1 ON LINE 1295
	     if eop_sw
	     then do;

003603  aa  6 00163 2351 00	lda  	pr6|115		eop_sw
003604  aa   000013 6000 04	tze  	11,ic		003617
						STATEMENT 1 ON LINE 1297
		seqp = eop_seqp;

003605  aa  6 00164 3735 20	epp7 	pr6|116,*		eop_seqp
003606  aa  6 00166 6535 00	spri7	pr6|118		seqp
						STATEMENT 1 ON LINE 1298
		call insert_sequence_internal;

003607  aa   000027 6700 04	tsp4 	23,ic		003636
						STATEMENT 1 ON LINE 1299
		call insert_char (eop_sentinel);

003610  aa  6 00040 3735 20	epp7 	pr6|32,*
003611  aa  7 00310 3521 00	epp2 	pr7|200		eop_sentinel
003612  aa  6 00364 2521 00	spri2	pr6|244
003613  aa  6 00362 3521 00	epp2 	pr6|242
003614  aa   004000 4310 07	fld  	2048,dl
003615  aa  2 00000 7571 00	staq 	pr2|0
003616  aa   777160 6700 04	tsp4 	-400,ic		002776
						STATEMENT 1 ON LINE 1300
	     end;

						STATEMENT 1 ON LINE 1301
	end;

						STATEMENT 1 ON LINE 1303
	if esc_sw					/* was this nl because of line overflow? */
	then do;

003617  aa  6 00156 3735 20	epp7 	pr6|110,*
003620  aa  7 00002 2351 20	lda  	pr7|2,*		esc_sw
003621  aa   400000 3150 03	cana 	131072,du
003622  aa   000011 6000 04	tze  	9,ic		003633
						STATEMENT 1 ON LINE 1305
	     call insert_char (escape_char);

003623  aa   002601 3520 04	epp2 	1409,ic		006424 = 000002000000
003624  aa   777152 6700 04	tsp4 	-406,ic		002776
						STATEMENT 1 ON LINE 1306
	     call insert_char (cont_char);

003625  aa   002573 3520 04	epp2 	1403,ic		006420 = 000002000000
003626  aa   777150 6700 04	tsp4 	-408,ic		002776
						STATEMENT 1 ON LINE 1307
	     col = 2;

003627  aa   000002 2360 07	ldq  	2,dl
003630  aa  6 00040 3735 20	epp7 	pr6|32,*
003631  aa  7 00167 7561 00	stq  	pr7|119		col
						STATEMENT 1 ON LINE 1308
	end;

003632  aa   000003 7100 04	tra  	3,ic		003635
						STATEMENT 1 ON LINE 1310
	else col = 0;

003633  aa  6 00040 3715 20	epp5 	pr6|32,*
003634  aa  5 00167 4501 00	stz  	pr5|119		col
						STATEMENT 1 ON LINE 1312
	return;

003635  aa  6 00154 6101 00	rtcd 	pr6|108
						STATEMENT 1 ON LINE 1348
     end /* insert_nl */;

BEGIN PROCEDURE insert_sequence_internal
ENTRY TO insert_sequence_internal                           STATEMENT 1 ON LINE 1314
insert_sequence_internal:
	proc;

003636  aa  6 00170 6501 00	spri4	pr6|120
						STATEMENT 1 ON LINE 1326
	     c_chars_ptr = seqp;

003637  aa  6 00166 3735 20	epp7 	pr6|118,*		seqp
003640  aa  6 00040 3715 20	epp5 	pr6|32,*
003641  aa  5 00320 6535 00	spri7	pr5|208		c_chars_ptr
						STATEMENT 1 ON LINE 1327
	     auto_len = seqp -> seq.count;

003642  aa  7 00000 2351 00	lda  	pr7|0		seq.count
003643  aa   000077 7330 00	lrs  	63
003644  aa  6 00177 7561 00	stq  	pr6|127		auto_len
						STATEMENT 1 ON LINE 1328
	     if auto_len = 0
	     then return;

003645  aa   000002 6010 04	tnz  	2,ic		003647
003646  aa  6 00170 6101 00	rtcd 	pr6|120
						STATEMENT 1 ON LINE 1331
	     if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)	/* probably not a real sequence */
	     then go to table_error;

003647  aa   777073 6040 04	tmi  	-453,ic		002742
003650  aa   000017 1160 07	cmpq 	15,dl
003651  aa   777071 6054 04	tpnz 	-455,ic		002742
						STATEMENT 1 ON LINE 1334
	     target_len = target_len + auto_len;

003652  aa  5 00146 0561 00	asq  	pr5|102		target_len
						STATEMENT 1 ON LINE 1335
	     if target_len > max_chars
	     then go to try_again;

003653  aa  5 00146 2361 00	ldq  	pr5|102		target_len
003654  aa  5 00127 1161 00	cmpq 	pr5|87		max_chars
003655  aa   777045 6054 04	tpnz 	-475,ic		002722
						STATEMENT 1 ON LINE 1338
	     do i = 1 to auto_len;

003656  aa  6 00177 2361 00	ldq  	pr6|127		auto_len
003657  aa  6 00200 7561 00	stq  	pr6|128
003660  aa   000001 2360 07	ldq  	1,dl
003661  aa  6 00176 7561 00	stq  	pr6|126		i
003662  aa  6 00176 2361 00	ldq  	pr6|126		i
003663  aa  6 00200 1161 00	cmpq 	pr6|128
003664  aa   000011 6054 04	tpnz 	9,ic		003675
						STATEMENT 1 ON LINE 1339
		target_ptr -> based_chars (i - 1) = seqp -> seq.chars (i);

003665  aa  6 00040 3735 20	epp7 	pr6|32,*
003666  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
003667  aa  6 00166 3535 20	epp3 	pr6|118,*		seqp
003670  aa  040 106 100 506	mlr  	(pr,ql),(pr,ql),fill(040)
003671  aa  3 00000 00 0001	desc9a	pr3|0,1		seq.chars
003672  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	based_chars
						STATEMENT 1 ON LINE 1340
	     end;

003673  aa  6 00176 0541 00	aos  	pr6|126		i
003674  aa   777766 7100 04	tra  	-10,ic		003662
						STATEMENT 1 ON LINE 1342
	     target_ptr = addr (target_ptr -> based_chars (auto_len));

003675  aa  6 00040 3735 20	epp7 	pr6|32,*
003676  aa  6 00177 7271 00	lxl7 	pr6|127		auto_len
003677  aa  7 00144 3521 20	epp2 	pr7|100,*		based_chars
003700  aa  2 00000 5005 17	a9bd 	pr2|0,7
003701  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1344
	     return;

003702  aa  6 00170 6101 00	rtcd 	pr6|120
						STATEMENT 1 ON LINE 1346
	end /* insert_sequence_internal */;

  END PROCEDURE insert_sequence_internal
  END PROCEDURE insert_nl
BEGIN PROCEDURE insert_cr
ENTRY TO insert_cr                                          STATEMENT 1 ON LINE 1350
insert_cr:
     proc;

003703  aa  6 00202 6501 00	spri4	pr6|130
						STATEMENT 1 ON LINE 1355
	if col = 0
	then return;

003704  aa  6 00040 3735 20	epp7 	pr6|32,*
003705  aa  7 00167 2361 00	ldq  	pr7|119		col
003706  aa   000002 6010 04	tnz  	2,ic		003710
003707  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 1358
	seqp = addr (special_ptr -> special_chars.cr_seq);

003710  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
003711  aa  5 00004 3715 00	epp5 	pr5|4		special_chars.cr_seq
003712  aa  7 00174 6515 00	spri5	pr7|124		seqp
						STATEMENT 1 ON LINE 1359
	if seqp -> seq.count = 0
	then call insert_bs (col);

003713  aa  5 00000 2351 00	lda  	pr5|0		seq.count
003714  aa   000077 7330 00	lrs  	63
003715  aa   000010 6010 04	tnz  	8,ic		003725
003716  aa  7 00167 3521 00	epp2 	pr7|119		col
003717  aa  6 00372 2521 00	spri2	pr6|250
003720  aa  6 00370 3521 00	epp2 	pr6|248
003721  aa   004000 4310 07	fld  	2048,dl
003722  aa  2 00000 7571 00	staq 	pr2|0
003723  aa   000042 6700 04	tsp4 	34,ic		003765
003724  aa   000040 7100 04	tra  	32,ic		003764
						STATEMENT 1 ON LINE 1362
	else do;

						STATEMENT 1 ON LINE 1363
	     call insert_sequence ("0"b);

003725  aa   000000 2350 07	lda  	0,dl
003726  aa  6 00376 7551 00	sta  	pr6|254
003727  aa   002465 3520 04	epp2 	1333,ic		006414 = 000002000000
003730  aa   777133 6700 04	tsp4 	-421,ic		003063
						STATEMENT 1 ON LINE 1364
	     if delay_ptr ^= null
	     then if delay_ptr -> delay.horz_nl ^= 0
		then call insert_delays (
			max (delay_ptr -> delay.horz_nl * col + max (0, delay_ptr -> delay.vert_nl), 1));

003731  aa  6 00040 3735 20	epp7 	pr6|32,*
003732  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
003733  aa   774173 6770 04	eraq 	-1925,ic		000126 = 077777000043 000001000000
003734  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003735  aa   000025 6000 04	tze  	21,ic		003762
003736  aa  7 00124 3715 20	epp5 	pr7|84,*		delay_ptr
003737  aa  5 00001 4311 00	fld  	pr5|1		delay.horz_nl
003740  aa   000022 6000 04	tze  	18,ic		003762
003741  aa   000000 2360 07	ldq  	0,dl
003742  aa  5 00000 1161 00	cmpq 	pr5|0		delay.vert_nl
003743  aa   000002 6050 04	tpl  	2,ic		003745
003744  aa  5 00000 2361 00	ldq  	pr5|0		delay.vert_nl
003745  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003746  aa  6 00377 4551 00	fst  	pr6|255
003747  aa  7 00167 2361 00	ldq  	pr7|119		col
003750  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
003751  aa  5 00001 4611 00	fmp  	pr5|1		delay.horz_nl
003752  aa  6 00377 4751 00	fad  	pr6|255
003753  aa   002400 5150 03	fcmp 	1280,du
003754  aa   000002 6050 04	tpl  	2,ic		003756
003755  aa   002400 4310 03	fld  	1280,du
003756  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
003757  aa  6 00376 7561 00	stq  	pr6|254
003760  aa   002434 3520 04	epp2 	1308,ic		006414 = 000002000000
003761  aa   777036 6700 04	tsp4 	-482,ic		003017
						STATEMENT 1 ON LINE 1369
	     col = 0;

003762  aa  6 00040 3735 20	epp7 	pr6|32,*
003763  aa  7 00167 4501 00	stz  	pr7|119		col
						STATEMENT 1 ON LINE 1370
	end;

						STATEMENT 1 ON LINE 1372
	return;

003764  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 1374
     end /* insert_cr */;

  END PROCEDURE insert_cr
BEGIN PROCEDURE insert_bs
ENTRY TO insert_bs                                          STATEMENT 1 ON LINE 1376
insert_bs:
     proc (how_many);

003765  aa  6 00210 6501 00	spri4	pr6|136
003766  aa  6 00212 2521 00	spri2	pr6|138
						STATEMENT 1 ON LINE 1387
	count = min (how_many, col);

003767  aa  2 00002 2361 20	ldq  	pr2|2,*		how_many
003770  aa  6 00040 3735 20	epp7 	pr6|32,*
003771  aa  7 00167 1161 00	cmpq 	pr7|119		col
003772  aa   000002 6040 04	tmi  	2,ic		003774
003773  aa  7 00167 2361 00	ldq  	pr7|119		col
003774  aa  6 00216 7561 00	stq  	pr6|142		count
						STATEMENT 1 ON LINE 1388
	if count <= 0
	then return;

003775  aa  6 00216 2361 00	ldq  	pr6|142		count
003776  aa   000002 6054 04	tpnz 	2,ic		004000
003777  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 1391
	seqp = addr (special_ptr -> special_chars.bs_seq);

004000  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
004001  aa  5 00010 3715 00	epp5 	pr5|8		special_chars.bs_seq
004002  aa  7 00174 6515 00	spri5	pr7|124		seqp
						STATEMENT 1 ON LINE 1392
	if seqp -> seq.count = 0			/* no backspace for this terminal */
	then do;

004003  aa  5 00000 2351 00	lda  	pr5|0		seq.count
004004  aa   000077 7330 00	lrs  	63
004005  aa  6 00400 7561 00	stq  	pr6|256		seq.count
004006  aa   000112 6010 04	tnz  	74,ic		004120
						STATEMENT 1 ON LINE 1394
	     new_col = col - count;

004007  aa  7 00167 2361 00	ldq  	pr7|119		col
004010  aa  6 00216 1761 00	sbq  	pr6|142		count
004011  aa  6 00221 7561 00	stq  	pr6|145		new_col
						STATEMENT 1 ON LINE 1395
	     seqp = addr (special_ptr -> special_chars.cr_seq);

004012  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
004013  aa  3 00004 3535 00	epp3 	pr3|4		special_chars.cr_seq
004014  aa  7 00174 2535 00	spri3	pr7|124		seqp
						STATEMENT 1 ON LINE 1397
	     if seqp -> seq.count = 0
	     then return;

004015  aa  3 00000 2351 00	lda  	pr3|0		seq.count
004016  aa   000077 7330 00	lrs  	63
004017  aa   000002 6010 04	tnz  	2,ic		004021
004020  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 1399
	     call insert_sequence ("0"b);

004021  aa   000000 2350 07	lda  	0,dl
004022  aa  6 00401 7551 00	sta  	pr6|257
004023  aa   002365 3520 04	epp2 	1269,ic		006410 = 000002000000
004024  aa   777037 6700 04	tsp4 	-481,ic		003063
						STATEMENT 1 ON LINE 1400
	     if delay_ptr ^= null
	     then if delay_ptr -> delay.horz_nl ^= 0
		then if delay_ptr -> delay.vert_nl >= 0
		     then call insert_delays (max (fixed (delay_ptr -> delay.horz_nl * float (col), 17, 0), 1));

004025  aa  6 00040 3735 20	epp7 	pr6|32,*
004026  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
004027  aa   774077 6770 04	eraq 	-1985,ic		000126 = 077777000043 000001000000
004030  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004031  aa   000020 6000 04	tze  	16,ic		004051
004032  aa  7 00124 3715 20	epp5 	pr7|84,*		delay_ptr
004033  aa  5 00001 4311 00	fld  	pr5|1		delay.horz_nl
004034  aa   000015 6000 04	tze  	13,ic		004051
004035  aa  5 00000 2361 00	ldq  	pr5|0		delay.vert_nl
004036  aa   000013 6040 04	tmi  	11,ic		004051
004037  aa  7 00167 2361 00	ldq  	pr7|119		col
004040  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
004041  aa  5 00001 4611 00	fmp  	pr5|1		delay.horz_nl
004042  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
004043  aa   000001 1160 07	cmpq 	1,dl
004044  aa   000002 6050 04	tpl  	2,ic		004046
004045  aa   000001 2360 07	ldq  	1,dl
004046  aa  6 00401 7561 00	stq  	pr6|257
004047  aa   002341 3520 04	epp2 	1249,ic		006410 = 000002000000
004050  aa   776747 6700 04	tsp4 	-537,ic		003017
						STATEMENT 1 ON LINE 1405
	     col = 0;

004051  aa  6 00040 3735 20	epp7 	pr6|32,*
004052  aa  7 00167 4501 00	stz  	pr7|119		col
						STATEMENT 1 ON LINE 1406
	     if new_col = 0
	     then return;

004053  aa  6 00221 2361 00	ldq  	pr6|145		new_col
004054  aa   000002 6010 04	tnz  	2,ic		004056
004055  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 1409
	     if tcb.modes.tabm			/* use tabs if appropriate */
	     then do;

004056  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
004057  aa  5 00017 2351 00	lda  	pr5|15		tcb.tabm
004060  aa   200000 3150 03	cana 	65536,du
004061  aa   000021 6000 04	tze  	17,ic		004102
						STATEMENT 1 ON LINE 1411
		do while (new_col - col >= 10);

004062  aa  6 00221 2361 00	ldq  	pr6|145		new_col
004063  aa  6 00040 3735 20	epp7 	pr6|32,*
004064  aa  7 00167 1761 00	sbq  	pr7|119		col
004065  aa   000012 1160 07	cmpq 	10,dl
004066  aa   000003 6040 04	tmi  	3,ic		004071
						STATEMENT 1 ON LINE 1412
		     call insert_tab;

004067  aa   000170 6700 04	tsp4 	120,ic		004257
						STATEMENT 1 ON LINE 1413
		end;

004070  aa   777772 7100 04	tra  	-6,ic		004062
						STATEMENT 1 ON LINE 1415
		if mod (new_col, 10) < mod (col, 10)	/* room for another */
		then call insert_tab;

004071  aa  7 00167 2361 00	ldq  	pr7|119		col
004072  aa   002406 3520 04	epp2 	1286,ic		006500 = 000000000012
004073  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
004074  aa  6 00401 7561 00	stq  	pr6|257
004075  aa  6 00221 2361 00	ldq  	pr6|145		new_col
004076  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
004077  aa  6 00401 1161 00	cmpq 	pr6|257
004100  aa   000002 6050 04	tpl  	2,ic		004102
004101  aa   000156 6700 04	tsp4 	110,ic		004257
						STATEMENT 1 ON LINE 1417
	     end;

						STATEMENT 1 ON LINE 1419
	     do col = col by 1 while (col < new_col);

004102  aa  6 00040 3735 20	epp7 	pr6|32,*
004103  aa  7 00167 2361 00	ldq  	pr7|119		col
004104  aa  7 00167 7561 00	stq  	pr7|119		col
004105  aa   000000 0110 03	nop  	0,du
004106  aa  6 00040 3735 20	epp7 	pr6|32,*
004107  aa  7 00167 2361 00	ldq  	pr7|119		col
004110  aa  6 00221 1161 00	cmpq 	pr6|145		new_col
004111  aa   000006 6050 04	tpl  	6,ic		004117
						STATEMENT 1 ON LINE 1420
		call insert_char (space);

004112  aa   002322 3520 04	epp2 	1234,ic		006434 = 000002000000
004113  aa   776663 6700 04	tsp4 	-589,ic		002776
						STATEMENT 1 ON LINE 1421
	     end;

004114  aa  6 00040 3735 20	epp7 	pr6|32,*
004115  aa  7 00167 0541 00	aos  	pr7|119		col
004116  aa   777770 7100 04	tra  	-8,ic		004106
						STATEMENT 1 ON LINE 1423
	     return;

004117  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 1424
	end;

						STATEMENT 1 ON LINE 1426
	if seqp -> seq.count > 1			/* not simply backspace */
	then do i = 1 to count;

004120  aa   000001 1160 07	cmpq 	1,dl
004121  aa   000026 6044 04	tmoz 	22,ic		004147
004122  aa  6 00216 2361 00	ldq  	pr6|142		count
004123  aa  6 00222 7561 00	stq  	pr6|146
004124  aa   000001 2360 07	ldq  	1,dl
004125  aa  6 00217 7561 00	stq  	pr6|143		i
004126  aa  6 00217 2361 00	ldq  	pr6|143		i
004127  aa  6 00222 1161 00	cmpq 	pr6|146
004130  aa   000126 6054 04	tpnz 	86,ic		004256
						STATEMENT 1 ON LINE 1428
	     call insert_sequence ("0"b);

004131  aa   000000 2350 07	lda  	0,dl
004132  aa  6 00400 7551 00	sta  	pr6|256
004133  aa   002251 3520 04	epp2 	1193,ic		006404 = 000002000000
004134  aa   776727 6700 04	tsp4 	-553,ic		003063
						STATEMENT 1 ON LINE 1429
	     col = max (0, col - 1);

004135  aa  6 00040 3735 20	epp7 	pr6|32,*
004136  aa  7 00167 2361 00	ldq  	pr7|119		col
004137  aa   000001 1760 07	sbq  	1,dl
004140  aa   000000 1160 07	cmpq 	0,dl
004141  aa   000002 6050 04	tpl  	2,ic		004143
004142  aa   000000 2360 07	ldq  	0,dl
004143  aa  7 00167 7561 00	stq  	pr7|119		col
						STATEMENT 1 ON LINE 1430
	end;

004144  aa  6 00217 0541 00	aos  	pr6|143		i
004145  aa   777761 7100 04	tra  	-15,ic		004126
004146  aa   000110 7100 04	tra  	72,ic		004256
						STATEMENT 1 ON LINE 1432
	else do;

						STATEMENT 1 ON LINE 1433
	     if delay_ptr = null
	     then n_delays = 0;

004147  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
004150  aa   773756 6770 04	eraq 	-2066,ic		000126 = 077777000043 000001000000
004151  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004152  aa   000003 6010 04	tnz  	3,ic		004155
004153  aa  7 00210 4501 00	stz  	pr7|136		n_delays
004154  aa   000004 7100 04	tra  	4,ic		004160
						STATEMENT 1 ON LINE 1435
	     else n_delays = delay_ptr -> delay.backspace;

004155  aa  7 00124 3535 20	epp3 	pr7|84,*		delay_ptr
004156  aa  3 00004 2361 00	ldq  	pr3|4		delay.backspace
004157  aa  7 00210 7561 00	stq  	pr7|136		n_delays
						STATEMENT 1 ON LINE 1437
	     bs_char = seqp -> seq.chars (1);

004160  aa  5 00000 2351 00	lda  	pr5|0		seq.chars
004161  aa   000011 7350 00	als  	9
004162  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
004163  aa  6 00220 7551 00	sta  	pr6|144		bs_char
						STATEMENT 1 ON LINE 1439
	     if n_delays > 0			/* normal delay timing */
	     then do i = 1 to count;

004164  aa  7 00210 2361 00	ldq  	pr7|136		n_delays
004165  aa   000024 6044 04	tmoz 	20,ic		004211
004166  aa  6 00216 2361 00	ldq  	pr6|142		count
004167  aa  6 00223 7561 00	stq  	pr6|147
004170  aa   000001 2360 07	ldq  	1,dl
004171  aa  6 00217 7561 00	stq  	pr6|143		i
004172  aa  6 00217 2361 00	ldq  	pr6|143		i
004173  aa  6 00223 1161 00	cmpq 	pr6|147
004174  aa   000057 6054 04	tpnz 	47,ic		004253
						STATEMENT 1 ON LINE 1441
		call insert_delays (n_delays);

004175  aa  6 00040 3735 20	epp7 	pr6|32,*
004176  aa  7 00210 3521 00	epp2 	pr7|136		n_delays
004177  aa  6 00404 2521 00	spri2	pr6|260
004200  aa  6 00402 3521 00	epp2 	pr6|258
004201  aa   004000 4310 07	fld  	2048,dl
004202  aa  2 00000 7571 00	staq 	pr2|0
004203  aa   776614 6700 04	tsp4 	-628,ic		003017
						STATEMENT 1 ON LINE 1442
		call insert_char (bs_char);

004204  aa   002174 3520 04	epp2 	1148,ic		006400 = 000002000000
004205  aa   776571 6700 04	tsp4 	-647,ic		002776
						STATEMENT 1 ON LINE 1443
	     end;

004206  aa  6 00217 0541 00	aos  	pr6|143		i
004207  aa   777763 7100 04	tra  	-13,ic		004172
004210  aa   000043 7100 04	tra  	35,ic		004253
						STATEMENT 1 ON LINE 1445
	     else do;

						STATEMENT 1 ON LINE 1446
		if n_delays < 0			/* this means timing for overstrike */
		then if -n_delays > count		/* so multiple backspaces can count instead of delays */
		     then call insert_delays (-n_delays - count);

004211  aa   000010 6050 04	tpl  	8,ic		004221
004212  aa  7 00210 3361 00	lcq  	pr7|136		n_delays
004213  aa  6 00216 1161 00	cmpq 	pr6|142		count
004214  aa   000005 6044 04	tmoz 	5,ic		004221
004215  aa  6 00216 1761 00	sbq  	pr6|142		count
004216  aa  6 00400 7561 00	stq  	pr6|256
004217  aa   002165 3520 04	epp2 	1141,ic		006404 = 000002000000
004220  aa   776577 6700 04	tsp4 	-641,ic		003017
						STATEMENT 1 ON LINE 1450
		target_len = target_len + count;

004221  aa  6 00216 2361 00	ldq  	pr6|142		count
004222  aa  6 00040 3735 20	epp7 	pr6|32,*
004223  aa  7 00146 0561 00	asq  	pr7|102		target_len
						STATEMENT 1 ON LINE 1451
		if target_len > max_chars		/* we will blow the buffer */
		then go to try_again;

004224  aa  7 00146 2361 00	ldq  	pr7|102		target_len
004225  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
004226  aa   776474 6054 04	tpnz 	-708,ic		002722
						STATEMENT 1 ON LINE 1454
		do i = 1 to count;

004227  aa  6 00216 2361 00	ldq  	pr6|142		count
004230  aa  6 00224 7561 00	stq  	pr6|148
004231  aa   000001 2360 07	ldq  	1,dl
004232  aa  6 00217 7561 00	stq  	pr6|143		i
004233  aa   000000 0110 03	nop  	0,du
004234  aa  6 00217 2361 00	ldq  	pr6|143		i
004235  aa  6 00224 1161 00	cmpq 	pr6|148
004236  aa   000010 6054 04	tpnz 	8,ic		004246
						STATEMENT 1 ON LINE 1455
		     target_ptr -> based_chars (i - 1) = bs_char;

004237  aa  6 00040 3735 20	epp7 	pr6|32,*
004240  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
004241  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
004242  aa  6 00220 00 0001	desc9a	pr6|144,1		bs_char
004243  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	based_chars
						STATEMENT 1 ON LINE 1456
		end;

004244  aa  6 00217 0541 00	aos  	pr6|143		i
004245  aa   777767 7100 04	tra  	-9,ic		004234
						STATEMENT 1 ON LINE 1458
		target_ptr = addr (target_ptr -> based_chars (count));

004246  aa  6 00040 3735 20	epp7 	pr6|32,*
004247  aa  6 00216 7271 00	lxl7 	pr6|142		count
004250  aa  7 00144 3521 20	epp2 	pr7|100,*		based_chars
004251  aa  2 00000 5005 17	a9bd 	pr2|0,7
004252  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1459
	     end;

						STATEMENT 1 ON LINE 1461
	     col = col - count;

004253  aa  6 00216 3361 00	lcq  	pr6|142		count
004254  aa  6 00040 3735 20	epp7 	pr6|32,*
004255  aa  7 00167 0561 00	asq  	pr7|119		col
						STATEMENT 1 ON LINE 1462
	end;

						STATEMENT 1 ON LINE 1464
	return;

004256  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 1466
     end /* insert_bs */;

  END PROCEDURE insert_bs
BEGIN PROCEDURE insert_tab
ENTRY TO insert_tab                                         STATEMENT 1 ON LINE 1468
insert_tab:
     proc;

004257  aa  6 00226 6501 00	spri4	pr6|150
						STATEMENT 1 ON LINE 1476
	count = 10 - mod (col, 10);

004260  aa  6 00040 3735 20	epp7 	pr6|32,*
004261  aa  7 00167 2361 00	ldq  	pr7|119		col
004262  aa   002216 3520 04	epp2 	1166,ic		006500 = 000000000012
004263  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
004264  aa  6 00410 7561 00	stq  	pr6|264
004265  aa  2 00000 2361 00	ldq  	pr2|0
004266  aa  6 00410 1761 00	sbq  	pr6|264
004267  aa  6 00235 7561 00	stq  	pr6|157		count
						STATEMENT 1 ON LINE 1478
	if count = 1				/* no point putting in tab for one space */
	then call insert_char (space);

004270  aa   000001 1160 07	cmpq 	1,dl
004271  aa   000004 6010 04	tnz  	4,ic		004275
004272  aa   002142 3520 04	epp2 	1122,ic		006434 = 000002000000
004273  aa   776503 6700 04	tsp4 	-701,ic		002776
004274  aa   000067 7100 04	tra  	55,ic		004363
						STATEMENT 1 ON LINE 1481
	else do;

						STATEMENT 1 ON LINE 1482
	     if tcb.modes.tabm & special_ptr -> special_chars.tab_seq.count > 0
						/* tabs are real */
	     then do;

004275  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
004276  aa  5 00017 2351 00	lda  	pr5|15		tcb.tabm
004277  aa   200000 3150 03	cana 	65536,du
004300  aa   000033 6000 04	tze  	27,ic		004333
004301  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
004302  aa  3 00014 2351 00	lda  	pr3|12		special_chars.count
004303  aa   000077 7330 00	lrs  	63
004304  aa   000027 6044 04	tmoz 	23,ic		004333
						STATEMENT 1 ON LINE 1485
		call insert_char (tab);

004305  aa   002067 3520 04	epp2 	1079,ic		006374 = 000002000000
004306  aa   776470 6700 04	tsp4 	-712,ic		002776
						STATEMENT 1 ON LINE 1486
		if delay_ptr ^= null
		then do;

004307  aa  6 00040 3735 20	epp7 	pr6|32,*
004310  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
004311  aa   773615 6770 04	eraq 	-2163,ic		000126 = 077777000043 000001000000
004312  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004313  aa   000050 6000 04	tze  	40,ic		004363
						STATEMENT 1 ON LINE 1488
		     n_delays =
			delay_ptr -> delay.const_tab + fixed (delay_ptr -> delay.var_tab * float (count), 17, 0);

004314  aa  6 00235 2361 00	ldq  	pr6|157		count
004315  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
004316  aa  7 00124 3715 20	epp5 	pr7|84,*		delay_ptr
004317  aa  5 00003 4611 00	fmp  	pr5|3		delay.var_tab
004320  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
004321  aa  5 00002 0761 00	adq  	pr5|2		delay.const_tab
004322  aa  7 00210 7561 00	stq  	pr7|136		n_delays
						STATEMENT 1 ON LINE 1490
		     if n_delays > 0
		     then call insert_delays (n_delays);

004323  aa   000040 6044 04	tmoz 	32,ic		004363
004324  aa  7 00210 3521 00	epp2 	pr7|136		n_delays
004325  aa  6 00414 2521 00	spri2	pr6|268
004326  aa  6 00412 3521 00	epp2 	pr6|266
004327  aa   004000 4310 07	fld  	2048,dl
004330  aa  2 00000 7571 00	staq 	pr2|0
004331  aa   776466 6700 04	tsp4 	-714,ic		003017
						STATEMENT 1 ON LINE 1492
		end;

						STATEMENT 1 ON LINE 1493
	     end;

004332  aa   000031 7100 04	tra  	25,ic		004363
						STATEMENT 1 ON LINE 1495
	     else do;

						STATEMENT 1 ON LINE 1496
		target_len = target_len + count;

004333  aa  6 00235 2361 00	ldq  	pr6|157		count
004334  aa  7 00146 0561 00	asq  	pr7|102		target_len
						STATEMENT 1 ON LINE 1497
		if target_len > max_chars
		then go to try_again;

004335  aa  7 00146 2361 00	ldq  	pr7|102		target_len
004336  aa  7 00127 1161 00	cmpq 	pr7|87		max_chars
004337  aa   776363 6054 04	tpnz 	-781,ic		002722
						STATEMENT 1 ON LINE 1500
		do i = 1 to count;

004340  aa  6 00235 2361 00	ldq  	pr6|157		count
004341  aa  6 00236 7561 00	stq  	pr6|158
004342  aa   000001 2360 07	ldq  	1,dl
004343  aa  6 00234 7561 00	stq  	pr6|156		i
004344  aa  6 00234 2361 00	ldq  	pr6|156		i
004345  aa  6 00236 1161 00	cmpq 	pr6|158
004346  aa   000010 6054 04	tpnz 	8,ic		004356
						STATEMENT 1 ON LINE 1501
		     target_ptr -> based_chars (i - 1) = space;

004347  aa  6 00040 3735 20	epp7 	pr6|32,*
004350  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
004351  aa  040 106 100 400	mlr  	(),(pr,ql),fill(040)
004352  aa   000000 00 0000	desc9a	0,0
004353  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	based_chars
						STATEMENT 1 ON LINE 1502
		end;

004354  aa  6 00234 0541 00	aos  	pr6|156		i
004355  aa   777767 7100 04	tra  	-9,ic		004344
						STATEMENT 1 ON LINE 1504
		target_ptr = addr (target_ptr -> based_chars (count));

004356  aa  6 00040 3735 20	epp7 	pr6|32,*
004357  aa  6 00235 7271 00	lxl7 	pr6|157		count
004360  aa  7 00144 3521 20	epp2 	pr7|100,*		based_chars
004361  aa  2 00000 5005 17	a9bd 	pr2|0,7
004362  aa  7 00144 2521 00	spri2	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1505
	     end;

						STATEMENT 1 ON LINE 1506
	end;

						STATEMENT 1 ON LINE 1508
	col = col + count;

004363  aa  6 00235 2361 00	ldq  	pr6|157		count
004364  aa  6 00040 3735 20	epp7 	pr6|32,*
004365  aa  7 00167 0561 00	asq  	pr7|119		col
						STATEMENT 1 ON LINE 1509
	return;

004366  aa  6 00226 6101 00	rtcd 	pr6|150
						STATEMENT 1 ON LINE 1511
     end /* insert_tab */;

  END PROCEDURE insert_tab
BEGIN PROCEDURE translation
ENTRY TO translation                                        STATEMENT 1 ON LINE 1513
translation:
     proc;

004367  aa  6 00240 6501 00	spri4	pr6|160
						STATEMENT 1 ON LINE 1518
	source_ptr, util.stringp = final_outp;

004370  aa  6 00040 3735 20	epp7 	pr6|32,*
004371  aa  7 00134 3735 20	epp7 	pr7|92,*		final_outp
004372  aa  6 00040 3715 20	epp5 	pr6|32,*
004373  aa  5 00140 6535 00	spri7	pr5|96		source_ptr
004374  aa  5 00262 6535 00	spri7	pr5|178		util.stringp
						STATEMENT 1 ON LINE 1520
	if final_outp = addr (buffer_1)		/* use the buffer not already occupied */
	then target_ptr = addr (buffer_2);

004375  aa  6 00102 3535 20	epp3 	pr6|66,*		buffer_1
004376  aa  6 00420 2535 00	spri3	pr6|272
004377  aa  6 00420 2371 00	ldaq 	pr6|272
004400  aa  5 00134 6771 00	eraq 	pr5|92		final_outp
004401  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004402  aa   000004 6010 04	tnz  	4,ic		004406
004403  aa  6 00106 3515 20	epp1 	pr6|70,*		buffer_2
004404  aa  5 00144 2515 00	spri1	pr5|100		target_ptr
004405  aa   000003 7100 04	tra  	3,ic		004410
						STATEMENT 1 ON LINE 1522
	else target_ptr = addr (buffer_1);

004406  aa  6 00102 3515 20	epp1 	pr6|66,*		buffer_1
004407  aa  5 00144 2515 00	spri1	pr5|100		target_ptr
						STATEMENT 1 ON LINE 1524
	util.stringl = target_len;

004410  aa  5 00146 2361 00	ldq  	pr5|102		target_len
004411  aa  5 00264 7561 00	stq  	pr5|180		util.stringl
						STATEMENT 1 ON LINE 1525
	util.tablep = mvtp;

004412  aa  5 00120 3735 20	epp7 	pr5|80,*		mvtp
004413  aa  5 00266 6535 00	spri7	pr5|182		util.tablep
						STATEMENT 1 ON LINE 1526
	mvt_args.targetp = target_ptr;

004414  aa  5 00270 2515 00	spri1	pr5|184		mvt_args.targetp
						STATEMENT 1 ON LINE 1527
	call tty_util_$mvt (addr (util));

004415  aa  5 00262 3735 00	epp7 	pr5|178		util
004416  aa  6 00422 6535 00	spri7	pr6|274
004417  aa  6 00422 3521 00	epp2 	pr6|274
004420  aa  6 00426 2521 00	spri2	pr6|278
004421  aa  6 00424 6211 00	eax1 	pr6|276
004422  aa   004000 4310 07	fld  	2048,dl
004423  aa  6 00044 3701 20	epp4 	pr6|36,*
004424  la  4 00020 3521 20	epp2 	pr4|16,*		tty_util_$mvt
004425  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1529
	final_outp = target_ptr;

004426  aa  6 00040 3735 20	epp7 	pr6|32,*
004427  aa  7 00144 3735 20	epp7 	pr7|100,*		target_ptr
004430  aa  6 00040 3715 20	epp5 	pr6|32,*
004431  aa  5 00134 6535 00	spri7	pr5|92		final_outp
						STATEMENT 1 ON LINE 1531
	if shifter (wtcb.line_type)			/* do we have to put in case shifts? */
	then do;

004432  aa  5 00326 3535 20	epp3 	pr5|214,*		wtcbp
004433  aa  3 00012 7271 00	lxl7 	pr3|10		wtcb.line_type
004434  aa   002043 3514 04	epp1 	1059,ic		006477 = 300000000000
004435  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
004436  aa  1 77777 70 0001	descb	pr1|-1(35),1	shifter
004437  aa   000000 00 0000	descb	0,0
004440  aa   000146 6000 04	tze  	102,ic		004606
						STATEMENT 1 ON LINE 1533
	     source_ptr, util.stringp = target_ptr;

004441  aa  5 00140 6535 00	spri7	pr5|96		source_ptr
004442  aa  5 00262 6535 00	spri7	pr5|178		util.stringp
						STATEMENT 1 ON LINE 1534
	     xor = bool (rel (addr (buffer_1)), rel (addr (buffer_2)), "0110"b);

004443  aa  6 00106 3535 20	epp3 	pr6|70,*		buffer_2
004444  aa  3 00000 6351 00	eaa  	pr3|0
004445  aa  6 00430 7551 00	sta  	pr6|280
004446  aa  6 00102 3515 20	epp1 	pr6|66,*		buffer_1
004447  aa  1 00000 6351 00	eaa  	pr1|0
004450  aa  6 00430 6751 00	era  	pr6|280
004451  aa  5 00177 7551 00	sta  	pr5|127		xor
						STATEMENT 1 ON LINE 1536
	     target_ptr, final_outp = ptr (target_ptr, bool (xor, rel (target_ptr), "0110"b));

004452  aa  5 00144 6351 20	eaa  	pr5|100,*		target_ptr
004453  aa  5 00177 6751 00	era  	pr5|127		xor
004454  aa  5 00144 3521 20	epp2 	pr5|100,*		target_ptr
004455  aa   000000 3120 01	eawp2	0,au
004456  aa  6 00422 2521 00	spri2	pr6|274
004457  aa  5 00144 2521 00	spri2	pr5|100		target_ptr
004460  aa  5 00134 2521 00	spri2	pr5|92		final_outp
						STATEMENT 1 ON LINE 1538
	     shift = "01"b;

004461  aa   200000 2350 03	lda  	65536,du
004462  aa  5 00200 7551 00	sta  	pr5|128		shift
						STATEMENT 1 ON LINE 1540
	     scm_args.search_mask = bool (shift, "11"b, "0110"b);

004463  aa   600000 6750 03	era  	196608,du
004464  aa  5 00266 7551 00	sta  	pr5|182		scm_args.search_mask
						STATEMENT 1 ON LINE 1542
	     call tty_util_$scm (addr (util));

004465  aa  5 00262 3735 00	epp7 	pr5|178		util
004466  aa  6 00422 6535 00	spri7	pr6|274
004467  aa  6 00422 3521 00	epp2 	pr6|274
004470  aa  6 00426 2521 00	spri2	pr6|278
004471  aa  6 00424 6211 00	eax1 	pr6|276
004472  aa   004000 4310 07	fld  	2048,dl
004473  aa  6 00044 3701 20	epp4 	pr6|36,*
004474  la  4 00022 3521 20	epp2 	pr4|18,*		tty_util_$scm
004475  aa  6 00432 2515 00	spri1	pr6|282
004476  aa  6 00434 2535 00	spri3	pr6|284
004477  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1544
	     if ^scm_args.found_flag			/* no shift changes at all */
	     then final_outp = source_ptr;

004500  aa  6 00040 3735 20	epp7 	pr6|32,*
004501  aa  7 00267 2351 00	lda  	pr7|183		scm_args.found_flag
004502  aa   000004 6010 04	tnz  	4,ic		004506
004503  aa  7 00140 3715 20	epp5 	pr7|96,*		source_ptr
004504  aa  7 00134 6515 00	spri5	pr7|92		final_outp
004505  aa   000101 7100 04	tra  	65,ic		004606
						STATEMENT 1 ON LINE 1546
	     else do;

						STATEMENT 1 ON LINE 1547
		target_len = 0;

004506  aa  7 00146 4501 00	stz  	pr7|102		target_len
						STATEMENT 1 ON LINE 1548
		if ctally > 0			/* move characters to left of found shift */
		then call copy_chars;

004507  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
004510  aa   000002 6044 04	tmoz 	2,ic		004512
004511  aa   776241 6700 04	tsp4 	-863,ic		002752
						STATEMENT 1 ON LINE 1551
		do while (scm_args.found_flag);

004512  aa  6 00040 3735 20	epp7 	pr6|32,*
004513  aa  7 00267 2351 00	lda  	pr7|183		scm_args.found_flag
004514  aa   000054 6000 04	tze  	44,ic		004570
						STATEMENT 1 ON LINE 1552
		     if ctally = 0
		     then call insert_shift;

004515  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
004516  aa   000003 6010 04	tnz  	3,ic		004521
004517  aa   000070 6700 04	tsp4 	56,ic		004607
004520  aa   000031 7100 04	tra  	25,ic		004551
						STATEMENT 1 ON LINE 1554
		     else do;

						STATEMENT 1 ON LINE 1555
			i = -1;

004521  aa   000001 3360 07	lcq  	1,dl
004522  aa  7 00176 7561 00	stq  	pr7|126		i
						STATEMENT 1 ON LINE 1556
			if target_ptr -> based_chars (i) ^= prefix
			then call insert_shift;

004523  aa  7 00144 3715 20	epp5 	pr7|100,*		target_ptr
004524  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
004525  aa  5 00000 00 0001	desc9a	pr5|0,1		based_chars
004526  aa   001752 00 0001	desc9a	1002,1		006476 = 076000000000
004527  aa   000003 6000 04	tze  	3,ic		004532
004530  aa   000057 6700 04	tsp4 	47,ic		004607
004531  aa   000020 7100 04	tra  	16,ic		004551
						STATEMENT 1 ON LINE 1559
			else do;

						STATEMENT 1 ON LINE 1560
			     call insert_char (source_ptr -> based_chars (0));

004532  aa  7 00140 3521 20	epp2 	pr7|96,*		based_chars
004533  aa  6 00440 2521 00	spri2	pr6|288
004534  aa  6 00436 3521 00	epp2 	pr6|286
004535  aa   004000 4310 07	fld  	2048,dl
004536  aa  2 00000 7571 00	staq 	pr2|0
004537  aa   776237 6700 04	tsp4 	-865,ic		002776
						STATEMENT 1 ON LINE 1562
			     stringp, source_ptr = addr (source_ptr -> based_chars (1));

004540  aa  6 00040 3735 20	epp7 	pr6|32,*
004541  aa   000001 7270 07	lxl7 	1,dl
004542  aa  7 00140 3521 20	epp2 	pr7|96,*		based_chars
004543  aa  2 00000 5005 17	a9bd 	pr2|0,7
004544  aa  6 00422 2521 00	spri2	pr6|274
004545  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
004546  aa  7 00140 2521 00	spri2	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1564
			     stringl = stringl - 1;

004547  aa   000001 3360 07	lcq  	1,dl
004550  aa  7 00264 0561 00	asq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1565
			end;

						STATEMENT 1 ON LINE 1566
		     end;

						STATEMENT 1 ON LINE 1568
		     call tty_util_$scm (addr (util));

004551  aa  6 00040 3735 20	epp7 	pr6|32,*
004552  aa  7 00262 3735 00	epp7 	pr7|178		util
004553  aa  6 00444 6535 00	spri7	pr6|292
004554  aa  6 00444 3521 00	epp2 	pr6|292
004555  aa  6 00426 2521 00	spri2	pr6|278
004556  aa  6 00424 6211 00	eax1 	pr6|276
004557  aa   004000 4310 07	fld  	2048,dl
004560  aa  6 00044 3701 20	epp4 	pr6|36,*
004561  la  4 00022 3521 20	epp2 	pr4|18,*		tty_util_$scm
004562  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1569
		     if ctally > 0
		     then call copy_chars;

004563  aa  6 00040 3735 20	epp7 	pr6|32,*
004564  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
004565  aa   777725 6044 04	tmoz 	-43,ic		004512
004566  aa   776164 6700 04	tsp4 	-908,ic		002752
						STATEMENT 1 ON LINE 1571
		end;

004567  aa   777723 7100 04	tra  	-45,ic		004512
						STATEMENT 1 ON LINE 1573
		if shift = "10"b			/* if we ended up in upper */
		then call insert_char (byte (lower_shift));

004570  aa  7 00200 2351 00	lda  	pr7|128		shift
004571  aa   400000 1150 03	cmpa 	131072,du
004572  aa   000006 6010 04	tnz  	6,ic		004600
004573  aa   000037 2360 07	ldq  	31,dl
004574  aa   000077 7370 00	lls  	63
004575  aa  6 00431 7551 00	sta  	pr6|281
004576  aa   001572 3520 04	epp2 	890,ic		006370 = 000002000000
004577  aa   776177 6700 04	tsp4 	-897,ic		002776
						STATEMENT 1 ON LINE 1576
		tcb.actshift = "01"b;

004600  aa   000001 2350 07	lda  	1,dl
004601  aa  6 00040 3735 20	epp7 	pr6|32,*
004602  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
004603  aa  5 00030 6751 00	era  	pr5|24		tcb.actshift
004604  aa   000003 3750 07	ana  	3,dl
004605  aa  5 00030 6551 00	ersa 	pr5|24		tcb.actshift
						STATEMENT 1 ON LINE 1577
	     end;

						STATEMENT 1 ON LINE 1578
	end;

						STATEMENT 1 ON LINE 1580
	return;

004606  aa  6 00240 6101 00	rtcd 	pr6|160
						STATEMENT 1 ON LINE 1582
     end translation;

  END PROCEDURE translation
BEGIN PROCEDURE insert_shift
ENTRY TO insert_shift                                       STATEMENT 1 ON LINE 1584
insert_shift:
     proc;

004607  aa  6 00246 6501 00	spri4	pr6|166
						STATEMENT 1 ON LINE 1589
	if shift = "01"b				/* we were in lower case */
	then call insert_char (byte (upper_shift));

004610  aa  6 00040 3735 20	epp7 	pr6|32,*
004611  aa  7 00200 2351 00	lda  	pr7|128		shift
004612  aa   200000 1150 03	cmpa 	65536,du
004613  aa   000007 6010 04	tnz  	7,ic		004622
004614  aa   000034 2360 07	ldq  	28,dl
004615  aa   000077 7370 00	lls  	63
004616  aa  6 00446 7551 00	sta  	pr6|294
004617  aa   001545 3520 04	epp2 	869,ic		006364 = 000002000000
004620  aa   776156 6700 04	tsp4 	-914,ic		002776
004621  aa   000006 7100 04	tra  	6,ic		004627
						STATEMENT 1 ON LINE 1591
	else call insert_char (byte (lower_shift));

004622  aa   000037 2360 07	ldq  	31,dl
004623  aa   000077 7370 00	lls  	63
004624  aa  6 00446 7551 00	sta  	pr6|294
004625  aa   001537 3520 04	epp2 	863,ic		006364 = 000002000000
004626  aa   776150 6700 04	tsp4 	-920,ic		002776
						STATEMENT 1 ON LINE 1593
	scm_args.search_mask = shift;

004627  aa  6 00040 3735 20	epp7 	pr6|32,*
004630  aa  7 00200 2351 00	lda  	pr7|128		shift
004631  aa  7 00266 7551 00	sta  	pr7|182		scm_args.search_mask
						STATEMENT 1 ON LINE 1594
	shift = bool (shift, "11"b, "0110"b);

004632  aa   600000 2350 03	lda  	196608,du
004633  aa  7 00200 6551 00	ersa 	pr7|128		shift
						STATEMENT 1 ON LINE 1596
	return;

004634  aa  6 00246 6101 00	rtcd 	pr6|166
						STATEMENT 1 ON LINE 1598
     end insert_shift;

  END PROCEDURE insert_shift
BEGIN PROCEDURE convert_to_upper_case
ENTRY TO convert_to_upper_case                              STATEMENT 1 ON LINE 1600
convert_to_upper_case:
     proc;

004635  aa  6 00254 6501 00	spri4	pr6|172
						STATEMENT 1 ON LINE 1611
	target_ptr = addr (buffer_2);

004636  aa  6 00106 3735 20	epp7 	pr6|70,*		buffer_2
004637  aa  6 00040 3715 20	epp5 	pr6|32,*
004640  aa  5 00144 6535 00	spri7	pr5|100		target_ptr
						STATEMENT 1 ON LINE 1612
	chars_moved = "0"b;

004641  aa  5 00164 4501 00	stz  	pr5|116		chars_moved
						STATEMENT 1 ON LINE 1614
	if tcb.modes.edited
	then cap_tab_ptr = addr (lower_to_caps_edited);

004642  aa  5 00330 3535 20	epp3 	pr5|216,*		tcbp
004643  aa  3 00017 2351 00	lda  	pr3|15		tcb.edited
004644  aa   400000 3150 03	cana 	131072,du
004645  aa   000004 6000 04	tze  	4,ic		004651
004646  aa   773173 3514 04	epp1 	-2437,ic		000041 = 000001002003
004647  aa  5 00154 2515 00	spri1	pr5|108		cap_tab_ptr
004650  aa   000003 7100 04	tra  	3,ic		004653
						STATEMENT 1 ON LINE 1616
	else cap_tab_ptr = addr (lower_to_caps_nonedited);

004651  aa   773130 3514 04	epp1 	-2472,ic		000001 = 000001002003
004652  aa  5 00154 2515 00	spri1	pr5|108		cap_tab_ptr
						STATEMENT 1 ON LINE 1620
	cap_source_ptr, ic_stringp = source_ptr;

004653  aa  5 00140 3535 20	epp3 	pr5|96,*		source_ptr
004654  aa  5 00150 2535 00	spri3	pr5|104		cap_source_ptr
004655  aa  5 00274 2535 00	spri3	pr5|188		illegal_char_args.ic_stringp
						STATEMENT 1 ON LINE 1621
	cap_target_ptr = addr (buffer_1);

004656  aa  6 00102 3515 20	epp1 	pr6|66,*		buffer_1
004657  aa  5 00152 2515 00	spri1	pr5|106		cap_target_ptr
						STATEMENT 1 ON LINE 1622
	ic_stringl = source_len;

004660  aa  5 00142 2361 00	ldq  	pr5|98		source_len
004661  aa  5 00276 7561 00	stq  	pr5|190		illegal_char_args.ic_stringl
						STATEMENT 1 ON LINE 1623
	illegal_char_args.found_flag = "1"b;

004662  aa   400000 2350 03	lda  	131072,du
004663  aa  5 00301 7551 00	sta  	pr5|193		illegal_char_args.found_flag
						STATEMENT 1 ON LINE 1624
	scanned_len = 0;

004664  aa  5 00156 4501 00	stz  	pr5|110		scanned_len
						STATEMENT 1 ON LINE 1626
	do while (illegal_char_args.found_flag & ic_stringl > 0);

004665  aa   000000 0110 03	nop  	0,du
004666  aa  6 00040 3735 20	epp7 	pr6|32,*
004667  aa  7 00301 2351 00	lda  	pr7|193		illegal_char_args.found_flag
004670  aa   000176 6000 04	tze  	126,ic		005066
004671  aa  7 00276 2361 00	ldq  	pr7|190		illegal_char_args.ic_stringl
004672  aa   000174 6044 04	tmoz 	124,ic		005066
						STATEMENT 1 ON LINE 1627
	     call tty_util_$illegal_char (addr (illegal_char_args));

004673  aa  7 00274 3715 00	epp5 	pr7|188		illegal_char_args
004674  aa  6 00450 6515 00	spri5	pr6|296
004675  aa  6 00450 3521 00	epp2 	pr6|296
004676  aa  6 00454 2521 00	spri2	pr6|300
004677  aa  6 00452 6211 00	eax1 	pr6|298
004700  aa   004000 4310 07	fld  	2048,dl
004701  aa  6 00044 3701 20	epp4 	pr6|36,*
004702  la  4 00026 3521 20	epp2 	pr4|22,*		tty_util_$illegal_char
004703  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1632
	     if illegal_char_args.ic_tally > 0		/* if there's a string to scan */
	     then do;

004704  aa  6 00040 3735 20	epp7 	pr6|32,*
004705  aa  7 00277 2361 00	ldq  	pr7|191		illegal_char_args.ic_tally
004706  aa   000113 6044 04	tmoz 	75,ic		005021
						STATEMENT 1 ON LINE 1634
		util.stringp = cap_source_ptr;

004707  aa  7 00150 3715 20	epp5 	pr7|104,*		cap_source_ptr
004710  aa  7 00262 6515 00	spri5	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1635
		util.stringl = ic_tally;

004711  aa  7 00264 7561 00	stq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1636
		util.tablep = cap_tab_ptr;

004712  aa  7 00154 3535 20	epp3 	pr7|108,*		cap_tab_ptr
004713  aa  7 00266 2535 00	spri3	pr7|182		util.tablep
						STATEMENT 1 ON LINE 1638
		mvt_args.targetp = cap_target_ptr;

004714  aa  7 00152 3515 20	epp1 	pr7|106,*		cap_target_ptr
004715  aa  7 00270 2515 00	spri1	pr7|184		mvt_args.targetp
						STATEMENT 1 ON LINE 1639
		call tty_util_$mvt (addr (util));

004716  aa  7 00262 3715 00	epp5 	pr7|178		util
004717  aa  6 00450 6515 00	spri5	pr6|296
004720  aa  6 00450 3521 00	epp2 	pr6|296
004721  aa  6 00454 2521 00	spri2	pr6|300
004722  aa  6 00452 6211 00	eax1 	pr6|298
004723  aa   004000 4310 07	fld  	2048,dl
004724  aa  6 00044 3701 20	epp4 	pr6|36,*
004725  la  4 00020 3521 20	epp2 	pr4|16,*		tty_util_$mvt
004726  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1641
		if ^tcb.modes.edited
		then do;

004727  aa  6 00040 3735 20	epp7 	pr6|32,*
004730  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
004731  aa  5 00017 2351 00	lda  	pr5|15		tcb.edited
004732  aa   400000 3150 03	cana 	131072,du
004733  aa   000066 6010 04	tnz  	54,ic		005021
						STATEMENT 1 ON LINE 1643
		     source_ptr, util.stringp = cap_target_ptr;

004734  aa  7 00152 3535 20	epp3 	pr7|106,*		cap_target_ptr
004735  aa  7 00140 2535 00	spri3	pr7|96		source_ptr
004736  aa  7 00262 2535 00	spri3	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1644
		     scm_args.search_mask = "10"b;

004737  aa   400000 2350 03	lda  	131072,du
004740  aa  7 00266 7551 00	sta  	pr7|182		scm_args.search_mask
						STATEMENT 1 ON LINE 1645
		     scm_args.found_flag = "1"b;

004741  aa   400000 2350 03	lda  	131072,du
004742  aa  7 00267 7551 00	sta  	pr7|183		scm_args.found_flag
						STATEMENT 1 ON LINE 1647
		     do while (scm_args.found_flag);

004743  aa   000000 0110 03	nop  	0,du
004744  aa  6 00040 3735 20	epp7 	pr6|32,*
004745  aa  7 00267 2351 00	lda  	pr7|183		scm_args.found_flag
004746  aa   000053 6000 04	tze  	43,ic		005021
						STATEMENT 1 ON LINE 1648
			call tty_util_$scm (addr (util));

004747  aa  7 00262 3715 00	epp5 	pr7|178		util
004750  aa  6 00450 6515 00	spri5	pr6|296
004751  aa  6 00450 3521 00	epp2 	pr6|296
004752  aa  6 00454 2521 00	spri2	pr6|300
004753  aa  6 00452 6211 00	eax1 	pr6|298
004754  aa   004000 4310 07	fld  	2048,dl
004755  aa  6 00044 3701 20	epp4 	pr6|36,*
004756  la  4 00022 3521 20	epp2 	pr4|18,*		tty_util_$scm
004757  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1649
			if scm_args.found_flag	/* found a capital */
			then do;

004760  aa  6 00040 3735 20	epp7 	pr6|32,*
004761  aa  7 00267 2351 00	lda  	pr7|183		scm_args.found_flag
004762  aa   000033 6000 04	tze  	27,ic		005015
						STATEMENT 1 ON LINE 1651
			     if ^chars_moved	/* first time we've had to move any */
			     then do;

004763  aa  7 00164 2351 00	lda  	pr7|116		chars_moved
004764  aa   000005 6010 04	tnz  	5,ic		004771
						STATEMENT 1 ON LINE 1653
				ctally = ctally + scanned_len;

004765  aa  7 00156 2361 00	ldq  	pr7|110		scanned_len
004766  aa  7 00265 0561 00	asq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1655
				source_ptr = addr (buffer_1);

004767  aa  6 00102 3715 20	epp5 	pr6|66,*		buffer_1
004770  aa  7 00140 6515 00	spri5	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1657
			     end;

						STATEMENT 1 ON LINE 1659
			     if ctally > 0
			     then call copy_chars;

004771  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
004772  aa   000002 6044 04	tmoz 	2,ic		004774
004773  aa   775757 6700 04	tsp4 	-1041,ic		002752
						STATEMENT 1 ON LINE 1661
			     call insert_char (escape_char);

004774  aa   001430 3520 04	epp2 	792,ic		006424 = 000002000000
004775  aa   776001 6700 04	tsp4 	-1023,ic		002776
						STATEMENT 1 ON LINE 1663
			     source_len = source_len + 1;

004776  aa  6 00040 3735 20	epp7 	pr6|32,*
004777  aa  7 00142 0541 00	aos  	pr7|98		source_len
						STATEMENT 1 ON LINE 1665
			     chars_moved = "1"b;

005000  aa   400000 2350 03	lda  	131072,du
005001  aa  7 00164 7551 00	sta  	pr7|116		chars_moved
						STATEMENT 1 ON LINE 1666
			     unspec (util.stringp -> based_onechar) =
				unspec (util.stringp -> based_onechar) & "011111111"b;

005002  aa  7 00262 3715 20	epp5 	pr7|178,*		util.stringp
005003  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
005004  aa  5 00000 00 0011	descb	pr5|0,9
005005  aa  6 00056 00 0044	descb	pr6|46,36
005006  aa  6 00056 2351 00	lda  	pr6|46
005007  aa   377000 3750 03	ana  	130560,du
005010  aa  6 00056 7551 00	sta  	pr6|46
005011  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
005012  aa  6 00056 00 0011	descb	pr6|46,9
005013  aa  5 00000 00 0011	descb	pr5|0,9
						STATEMENT 1 ON LINE 1669
			end;

005014  aa   777730 7100 04	tra  	-40,ic		004744
						STATEMENT 1 ON LINE 1671
			else if chars_moved		/* we didn't find one, did we move any chars? */
			then call copy_chars;

005015  aa  7 00164 2351 00	lda  	pr7|116		chars_moved
005016  aa   777726 6000 04	tze  	-42,ic		004744
005017  aa   775733 6700 04	tsp4 	-1061,ic		002752
						STATEMENT 1 ON LINE 1674
		     end;

005020  aa   777724 7100 04	tra  	-44,ic		004744
						STATEMENT 1 ON LINE 1675
		end;

						STATEMENT 1 ON LINE 1676
	     end;

						STATEMENT 1 ON LINE 1678
	     if illegal_char_args.found_flag
	     then do;

005021  aa  7 00301 2351 00	lda  	pr7|193		illegal_char_args.found_flag
005022  aa   777644 6000 04	tze  	-92,ic		004666
						STATEMENT 1 ON LINE 1681
		if chars_moved			/* we've had to copy for escapes */
		then call insert_char (cap_source_ptr -> based_chars (ic_tally));

005023  aa  7 00164 2351 00	lda  	pr7|116		chars_moved
005024  aa   000012 6000 04	tze  	10,ic		005036
005025  aa  7 00277 7271 00	lxl7 	pr7|191		illegal_char_args.ic_tally
005026  aa  7 00150 3521 20	epp2 	pr7|104,*		based_chars
005027  aa  2 00000 5005 17	a9bd 	pr2|0,7
005030  aa  6 00460 2521 00	spri2	pr6|304
005031  aa  6 00456 3521 00	epp2 	pr6|302
005032  aa   004000 4310 07	fld  	2048,dl
005033  aa  2 00000 7571 00	staq 	pr2|0
005034  aa   775742 6700 04	tsp4 	-1054,ic		002776
005035  aa   000007 7100 04	tra  	7,ic		005044
						STATEMENT 1 ON LINE 1685
		else cap_target_ptr -> based_chars (ic_tally) = cap_source_ptr -> based_chars (ic_tally);

005036  aa  7 00277 7271 00	lxl7 	pr7|191		illegal_char_args.ic_tally
005037  aa  7 00152 3715 20	epp5 	pr7|106,*		cap_target_ptr
005040  aa  7 00150 3535 20	epp3 	pr7|104,*		cap_source_ptr
005041  aa  040 117 100 517	mlr  	(pr,x7),(pr,x7),fill(040)
005042  aa  3 00000 00 0001	desc9a	pr3|0,1		based_chars
005043  aa  5 00000 00 0001	desc9a	pr5|0,1		based_chars
						STATEMENT 1 ON LINE 1687
		scanned_len = scanned_len + ic_tally + 1;

005044  aa  6 00040 3735 20	epp7 	pr6|32,*
005045  aa  7 00156 2361 00	ldq  	pr7|110		scanned_len
005046  aa  7 00277 0761 00	adq  	pr7|191		illegal_char_args.ic_tally
005047  aa   000001 0760 07	adq  	1,dl
005050  aa  7 00156 7561 00	stq  	pr7|110		scanned_len
						STATEMENT 1 ON LINE 1691
		ic_stringp, cap_source_ptr = addr (cap_source_ptr -> based_chars (ic_tally + 1));

005051  aa  7 00277 2351 00	lda  	pr7|191		illegal_char_args.ic_tally
005052  aa   000001 0750 07	ada  	1,dl
005053  aa  7 00150 3521 20	epp2 	pr7|104,*		based_chars
005054  aa  2 00000 5005 05	a9bd 	pr2|0,al
005055  aa  6 00450 2521 00	spri2	pr6|296
005056  aa  7 00274 2521 00	spri2	pr7|188		illegal_char_args.ic_stringp
005057  aa  7 00150 2521 00	spri2	pr7|104		cap_source_ptr
						STATEMENT 1 ON LINE 1692
		cap_target_ptr = addr (cap_target_ptr -> based_chars (ic_tally + 1));

005060  aa  7 00152 3521 20	epp2 	pr7|106,*		based_chars
005061  aa  2 00000 5005 05	a9bd 	pr2|0,al
005062  aa  7 00152 2521 00	spri2	pr7|106		cap_target_ptr
						STATEMENT 1 ON LINE 1693
		ic_stringl = ic_stringl - 1;

005063  aa   000001 3360 07	lcq  	1,dl
005064  aa  7 00276 0561 00	asq  	pr7|190		illegal_char_args.ic_stringl
						STATEMENT 1 ON LINE 1694
	     end;

						STATEMENT 1 ON LINE 1695
	end;

005065  aa   777601 7100 04	tra  	-127,ic		004666
						STATEMENT 1 ON LINE 1697
	if chars_moved				/* have to adjust some pointers */
	then do;

005066  aa  7 00164 2351 00	lda  	pr7|116		chars_moved
005067  aa   000006 6000 04	tze  	6,ic		005075
						STATEMENT 1 ON LINE 1699
	     source_ptr = addr (buffer_2);

005070  aa  6 00106 3715 20	epp5 	pr6|70,*		buffer_2
005071  aa  7 00140 6515 00	spri5	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1700
	     target_ptr = addr (buffer_1);

005072  aa  6 00102 3535 20	epp3 	pr6|66,*		buffer_1
005073  aa  7 00144 2535 00	spri3	pr7|100		target_ptr
						STATEMENT 1 ON LINE 1701
	end;

005074  aa   000003 7100 04	tra  	3,ic		005077
						STATEMENT 1 ON LINE 1702
	else source_ptr = addr (buffer_1);

005075  aa  6 00102 3715 20	epp5 	pr6|66,*		buffer_1
005076  aa  7 00140 6515 00	spri5	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1704
	return;

005077  aa  6 00254 6101 00	rtcd 	pr6|172
						STATEMENT 1 ON LINE 1706
     end convert_to_upper_case;

  END PROCEDURE convert_to_upper_case
BEGIN PROCEDURE move_formated_chars
ENTRY TO move_formated_chars                                STATEMENT 1 ON LINE 1708
move_formated_chars:
     proc;

005100  aa  6 00262 6501 00	spri4	pr6|178
						STATEMENT 1 ON LINE 1718
	chars_moved = "1"b;

005101  aa   400000 2350 03	lda  	131072,du
005102  aa  6 00040 3735 20	epp7 	pr6|32,*
005103  aa  7 00164 7551 00	sta  	pr7|116		chars_moved
						STATEMENT 1 ON LINE 1720
	if ctally > 0				/* we have some uninteresting ones to pick up */
	then do;

005104  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005105  aa   000034 6044 04	tmoz 	28,ic		005141
						STATEMENT 1 ON LINE 1722
	     if white_sw
	     then call insert_white;

005106  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005107  aa   000002 6000 04	tze  	2,ic		005111
005110  aa   776113 6700 04	tsp4 	-949,ic		003223
						STATEMENT 1 ON LINE 1724
	     col = col + ctally;

005111  aa  6 00040 3735 20	epp7 	pr6|32,*
005112  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005113  aa  7 00167 0561 00	asq  	pr7|119		col
						STATEMENT 1 ON LINE 1725
	     if tcb.dont_count_next			/* first char doesn't count */
	     then do;

005114  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005115  aa  5 00030 2351 00	lda  	pr5|24		tcb.dont_count_next
005116  aa   200000 3150 03	cana 	65536,du
005117  aa   000005 6000 04	tze  	5,ic		005124
						STATEMENT 1 ON LINE 1727
		col = col - 1;

005120  aa   000001 3360 07	lcq  	1,dl
005121  aa  7 00167 0561 00	asq  	pr7|119		col
						STATEMENT 1 ON LINE 1728
		tcb.dont_count_next = "0"b;

005122  aa   001240 2350 04	lda  	672,ic		006362 = 577777777777
005123  aa  5 00030 3551 00	ansa 	pr5|24		tcb.dont_count_next
						STATEMENT 1 ON LINE 1729
	     end;

						STATEMENT 1 ON LINE 1730
	     if ((tcb.colmax > 0) & (col > tcb.colmax))
	     then call wrap_lines;

005124  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
005125  aa   000077 7330 00	lrs  	63
005126  aa  6 00464 7561 00	stq  	pr6|308		tcb.colmax
005127  aa   000005 6044 04	tmoz 	5,ic		005134
005130  aa  7 00167 1161 00	cmpq 	pr7|119		col
005131  aa   000003 6050 04	tpl  	3,ic		005134
005132  aa   000431 6700 04	tsp4 	281,ic		005563
005133  aa   000033 7100 04	tra  	27,ic		005166
						STATEMENT 1 ON LINE 1732
	     else do;

						STATEMENT 1 ON LINE 1733
		call copy_chars;

005134  aa   775616 6700 04	tsp4 	-1138,ic		002752
						STATEMENT 1 ON LINE 1734
		wcol = col;

005135  aa  6 00040 3735 20	epp7 	pr6|32,*
005136  aa  7 00167 2361 00	ldq  	pr7|119		col
005137  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 1735
	     end;

						STATEMENT 1 ON LINE 1736
	end;

005140  aa   000026 7100 04	tra  	22,ic		005166
						STATEMENT 1 ON LINE 1738
	else if tcb.dont_count_next			/* we're supposed to swallow first char whole */
	then do;

005141  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005142  aa  5 00030 2351 00	lda  	pr5|24		tcb.dont_count_next
005143  aa   200000 3150 03	cana 	65536,du
005144  aa   000022 6000 04	tze  	18,ic		005166
						STATEMENT 1 ON LINE 1740
	     ctally = 1;

005145  aa   000001 2360 07	ldq  	1,dl
005146  aa  7 00265 7561 00	stq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1741
	     call copy_chars;

005147  aa   775603 6700 04	tsp4 	-1149,ic		002752
						STATEMENT 1 ON LINE 1743
	     if indicator = 3 | indicator = 7		/* we're still pointing at it */
	     then do;

005150  aa  6 00040 3735 20	epp7 	pr6|32,*
005151  aa  7 00270 2361 00	ldq  	pr7|184		util.indicator
005152  aa   000003 1160 07	cmpq 	3,dl
005153  aa   000003 6000 04	tze  	3,ic		005156
005154  aa   000007 1160 07	cmpq 	7,dl
005155  aa   000007 6010 04	tnz  	7,ic		005164
						STATEMENT 1 ON LINE 1745
		stringp = addr (stringp -> based_chars (1));

005156  aa   000001 7270 07	lxl7 	1,dl
005157  aa  7 00262 3521 20	epp2 	pr7|178,*		based_chars
005160  aa  2 00000 5005 17	a9bd 	pr2|0,7
005161  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1747
		stringl = stringl - 1;

005162  aa   000001 3360 07	lcq  	1,dl
005163  aa  7 00264 0561 00	asq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1748
	     end;

						STATEMENT 1 ON LINE 1750
	     indicator = NOT_INTERESTING;

005164  aa   000000 2360 07	ldq  	0,dl
005165  aa  7 00270 7561 00	stq  	pr7|184		util.indicator
						STATEMENT 1 ON LINE 1751
	end;

						STATEMENT 1 ON LINE 1755
	if indicator = NOT_INTERESTING		/* no interesting characters */
	then if white_sw
	     then call insert_white;

005166  aa  6 00040 3735 20	epp7 	pr6|32,*
005167  aa  7 00270 2361 00	ldq  	pr7|184		util.indicator
005170  aa   000005 6010 04	tnz  	5,ic		005175
005171  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005172  aa   000363 6000 04	tze  	243,ic		005555
005173  aa   776030 6700 04	tsp4 	-1000,ic		003223
						STATEMENT 1 ON LINE 1758
	     else ;

005174  aa   000361 7100 04	tra  	241,ic		005555
						STATEMENT 1 ON LINE 1760
	else if indicator = NEW_LINE			/* new-line */
	then do;

005175  aa   000001 1160 07	cmpq 	1,dl
005176  aa   000007 6010 04	tnz  	7,ic		005205
						STATEMENT 1 ON LINE 1762
	     white_sw = "0"b;

005177  aa  7 00165 4501 00	stz  	pr7|117		white_sw
						STATEMENT 1 ON LINE 1763
	     call insert_nl ("0"b);

005200  aa   000000 2350 07	lda  	0,dl
005201  aa  6 00464 7551 00	sta  	pr6|308
005202  aa   001154 3520 04	epp2 	620,ic		006356 = 000002000000
005203  aa   776220 6700 04	tsp4 	-880,ic		003423
						STATEMENT 1 ON LINE 1764
	end;

005204  aa   000351 7100 04	tra  	233,ic		005555
						STATEMENT 1 ON LINE 1766
	else if indicator = CARRIAGE_RETURN		/* carriage return */
	then do;

005205  aa   000002 1160 07	cmpq 	2,dl
005206  aa   000005 6010 04	tnz  	5,ic		005213
						STATEMENT 1 ON LINE 1768
	     white_sw = "1"b;

005207  aa   400000 2350 03	lda  	131072,du
005210  aa  7 00165 7551 00	sta  	pr7|117		white_sw
						STATEMENT 1 ON LINE 1769
	     wcol = 0;

005211  aa  7 00170 4501 00	stz  	pr7|120		wcol
						STATEMENT 1 ON LINE 1770
	end;

005212  aa   000343 7100 04	tra  	227,ic		005555
						STATEMENT 1 ON LINE 1772
	else if indicator = TAB_MULTIPLE_SPACE		/* tab or multiple blanks */
	then call scan_white ("0"b);

005213  aa   000003 1160 07	cmpq 	3,dl
005214  aa   000006 6010 04	tnz  	6,ic		005222
005215  aa   000000 2350 07	lda  	0,dl
005216  aa  6 00464 7551 00	sta  	pr6|308
005217  aa   001137 3520 04	epp2 	607,ic		006356 = 000002000000
005220  aa   000421 6700 04	tsp4 	273,ic		005641
005221  aa   000334 7100 04	tra  	220,ic		005555
						STATEMENT 1 ON LINE 1775
	else if indicator = BACK_SPACE		/* backspace */
	then do;

005222  aa   000004 1160 07	cmpq 	4,dl
005223  aa   000014 6010 04	tnz  	12,ic		005237
						STATEMENT 1 ON LINE 1777
	     wcol = max (0, wcol - 1);

005224  aa  7 00170 2361 00	ldq  	pr7|120		wcol
005225  aa   000001 1760 07	sbq  	1,dl
005226  aa   000000 1160 07	cmpq 	0,dl
005227  aa   000002 6050 04	tpl  	2,ic		005231
005230  aa   000000 2360 07	ldq  	0,dl
005231  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 1778
	     call scan_white ("1"b);

005232  aa   400000 2350 03	lda  	131072,du
005233  aa  6 00464 7551 00	sta  	pr6|308
005234  aa   001122 3520 04	epp2 	594,ic		006356 = 000002000000
005235  aa   000404 6700 04	tsp4 	260,ic		005641
						STATEMENT 1 ON LINE 1780
	end;

005236  aa   000317 7100 04	tra  	207,ic		005555
						STATEMENT 1 ON LINE 1782
	else if indicator = VERTICAL_TAB | indicator = FORM_FEED
						/* vertical tab or form-feed */
	then if tcb.modes.vertsp			/* if we're processing such */
	     then do;

005237  aa   000005 1160 07	cmpq 	5,dl
005240  aa   000003 6000 04	tze  	3,ic		005243
005241  aa   000006 1160 07	cmpq 	6,dl
005242  aa   000140 6010 04	tnz  	96,ic		005402
005243  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005244  aa  5 00017 2351 00	lda  	pr5|15		tcb.vertsp
005245  aa   001000 3150 03	cana 	512,du
005246  aa   000121 6000 04	tze  	81,ic		005367
						STATEMENT 1 ON LINE 1786
		if indicator = VERTICAL_TAB		/* vertical tab */
		then do;

005247  aa   000005 1160 07	cmpq 	5,dl
005250  aa   000044 6010 04	tnz  	36,ic		005314
						STATEMENT 1 ON LINE 1788
		     if tcb.linemax > 0		/* if we're counting lines */
		     then do;

005251  aa  5 00021 2351 00	lda  	pr5|17		tcb.linemax
005252  aa   000011 7350 00	als  	9
005253  aa   000077 7330 00	lrs  	63
005254  aa   000034 6044 04	tmoz 	28,ic		005310
						STATEMENT 1 ON LINE 1790
			line_count = line_count + 10 - mod (line_count, 10);

005255  aa  6 00464 7561 00	stq  	pr6|308		tcb.linemax
005256  aa  7 00166 2361 00	ldq  	pr7|118		line_count
005257  aa   001221 3520 04	epp2 	657,ic		006500 = 000000000012
005260  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005261  aa  6 00465 7561 00	stq  	pr6|309
005262  aa  7 00166 2361 00	ldq  	pr7|118		line_count
005263  aa  2 00000 0761 00	adq  	pr2|0
005264  aa  6 00465 1761 00	sbq  	pr6|309
005265  aa  7 00166 7561 00	stq  	pr7|118		line_count
						STATEMENT 1 ON LINE 1792
			if line_count >= tcb.linemax	/* over to new page */
			then do;

005266  aa  6 00464 1161 00	cmpq 	pr6|308		tcb.linemax
005267  aa   000021 6040 04	tmi  	17,ic		005310
						STATEMENT 1 ON LINE 1794
			     seqp = addr (special_ptr -> special_chars.end_of_page);

005270  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
005271  aa  3 00050 3535 00	epp3 	pr3|40		special_chars.end_of_page
005272  aa  7 00174 2535 00	spri3	pr7|124		seqp
						STATEMENT 1 ON LINE 1795
			     call insert_sequence ("0"b);

005273  aa   000000 2350 07	lda  	0,dl
005274  aa  6 00464 7551 00	sta  	pr6|308
005275  aa   001061 3520 04	epp2 	561,ic		006356 = 000002000000
005276  aa   775565 6700 04	tsp4 	-1163,ic		003063
						STATEMENT 1 ON LINE 1797
			     call insert_char (eop_sentinel);

005277  aa  6 00040 3735 20	epp7 	pr6|32,*
005300  aa  7 00310 3521 00	epp2 	pr7|200		eop_sentinel
005301  aa  6 00470 2521 00	spri2	pr6|312
005302  aa  6 00466 3521 00	epp2 	pr6|310
005303  aa   004000 4310 07	fld  	2048,dl
005304  aa  2 00000 7571 00	staq 	pr2|0
005305  aa   775471 6700 04	tsp4 	-1223,ic		002776
						STATEMENT 1 ON LINE 1798
			     line_count = 0;

005306  aa  6 00040 3735 20	epp7 	pr6|32,*
005307  aa  7 00166 4501 00	stz  	pr7|118		line_count
						STATEMENT 1 ON LINE 1799
			end;

						STATEMENT 1 ON LINE 1800
		     end;

						STATEMENT 1 ON LINE 1801
		     seqp = addr (special_ptr -> special_chars.vt_seq);

005310  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
005311  aa  5 00020 3715 00	epp5 	pr5|16		special_chars.vt_seq
005312  aa  7 00174 6515 00	spri5	pr7|124		seqp
						STATEMENT 1 ON LINE 1802
		end;

005313  aa   000030 7100 04	tra  	24,ic		005343
						STATEMENT 1 ON LINE 1804
		else do;

						STATEMENT 1 ON LINE 1805
		     if tcb.linemax > 0
		     then do;

005314  aa  5 00021 2351 00	lda  	pr5|17		tcb.linemax
005315  aa   000011 7350 00	als  	9
005316  aa   000077 7330 00	lrs  	63
005317  aa   000017 6044 04	tmoz 	15,ic		005336
						STATEMENT 1 ON LINE 1807
			seqp = addr (special_ptr -> special_chars.end_of_page);

005320  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
005321  aa  3 00050 3535 00	epp3 	pr3|40		special_chars.end_of_page
005322  aa  7 00174 2535 00	spri3	pr7|124		seqp
						STATEMENT 1 ON LINE 1808
			call insert_sequence ("0"b);

005323  aa   000000 2350 07	lda  	0,dl
005324  aa  6 00464 7551 00	sta  	pr6|308
005325  aa   001031 3520 04	epp2 	537,ic		006356 = 000002000000
005326  aa   775535 6700 04	tsp4 	-1187,ic		003063
						STATEMENT 1 ON LINE 1809
			call insert_char (eop_sentinel);

005327  aa  6 00040 3735 20	epp7 	pr6|32,*
005330  aa  7 00310 3521 00	epp2 	pr7|200		eop_sentinel
005331  aa  6 00470 2521 00	spri2	pr6|312
005332  aa  6 00466 3521 00	epp2 	pr6|310
005333  aa   004000 4310 07	fld  	2048,dl
005334  aa  2 00000 7571 00	staq 	pr2|0
005335  aa   775441 6700 04	tsp4 	-1247,ic		002776
						STATEMENT 1 ON LINE 1810
		     end;

						STATEMENT 1 ON LINE 1811
		     line_count = 0;

005336  aa  6 00040 3735 20	epp7 	pr6|32,*
005337  aa  7 00166 4501 00	stz  	pr7|118		line_count
						STATEMENT 1 ON LINE 1812
		     seqp = addr (special_ptr -> special_chars.ff_seq);

005340  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
005341  aa  5 00024 3715 00	epp5 	pr5|20		special_chars.ff_seq
005342  aa  7 00174 6515 00	spri5	pr7|124		seqp
						STATEMENT 1 ON LINE 1813
		end;

						STATEMENT 1 ON LINE 1815
		call insert_sequence ("0"b);

005343  aa   000000 2350 07	lda  	0,dl
005344  aa  6 00464 7551 00	sta  	pr6|308
005345  aa   001011 3520 04	epp2 	521,ic		006356 = 000002000000
005346  aa   775515 6700 04	tsp4 	-1203,ic		003063
						STATEMENT 1 ON LINE 1816
		if delay_ptr ^= null
		then call insert_delays (delay_ptr -> delay.vt_ff);

005347  aa  6 00040 3735 20	epp7 	pr6|32,*
005350  aa  7 00124 2371 00	ldaq 	pr7|84		delay_ptr
005351  aa   772555 6770 04	eraq 	-2707,ic		000126 = 077777000043 000001000000
005352  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005353  aa   000010 6000 04	tze  	8,ic		005363
005354  aa  7 00124 3715 20	epp5 	pr7|84,*		delay_ptr
005355  aa  5 00005 3521 00	epp2 	pr5|5		delay.vt_ff
005356  aa  6 00470 2521 00	spri2	pr6|312
005357  aa  6 00466 3521 00	epp2 	pr6|310
005360  aa   004000 4310 07	fld  	2048,dl
005361  aa  2 00000 7571 00	staq 	pr2|0
005362  aa   775435 6700 04	tsp4 	-1251,ic		003017
						STATEMENT 1 ON LINE 1819
		col = 0;

005363  aa  6 00040 3735 20	epp7 	pr6|32,*
005364  aa  7 00167 4501 00	stz  	pr7|119		col
						STATEMENT 1 ON LINE 1820
		white_sw = "0"b;

005365  aa  7 00165 4501 00	stz  	pr7|117		white_sw
						STATEMENT 1 ON LINE 1821
	     end;

005366  aa   000167 7100 04	tra  	119,ic		005555
						STATEMENT 1 ON LINE 1823
	     else if ^tcb.modes.edited		/* we'll have to escape it */
	     then do;

005367  aa  5 00017 2351 00	lda  	pr5|15		tcb.edited
005370  aa   400000 3150 03	cana 	131072,du
005371  aa   000164 6010 04	tnz  	116,ic		005555
						STATEMENT 1 ON LINE 1825
		i = -1;

005372  aa   000001 3360 07	lcq  	1,dl
005373  aa  7 00176 7561 00	stq  	pr7|126		i
						STATEMENT 1 ON LINE 1826
		stringp = addr (stringp -> based_chars (i));

005374  aa  7 00262 3521 20	epp2 	pr7|178,*		based_chars
005375  aa  2 00000 5005 06	a9bd 	pr2|0,ql
005376  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1828
		stringl = stringl + 1;

005377  aa  7 00264 0541 00	aos  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1829
		call octal_escape;

005400  aa   000343 6700 04	tsp4 	227,ic		005743
						STATEMENT 1 ON LINE 1830
	     end;

						STATEMENT 1 ON LINE 1831
	else if indicator = OCTAL_ESCAPE		/* octal escape */
	then call octal_escape;

005401  aa   000154 7100 04	tra  	108,ic		005555
						STATEMENT 1 ON LINE 1833
	else if indicator = OCTAL_ESCAPE		/* octal escape */
	then call octal_escape;

005402  aa   000007 1160 07	cmpq 	7,dl
005403  aa   000003 6010 04	tnz  	3,ic		005406
005404  aa   000337 6700 04	tsp4 	223,ic		005743
005405  aa   000150 7100 04	tra  	104,ic		005555
						STATEMENT 1 ON LINE 1836
	else if indicator = RED_SHIFT | indicator = BLACK_SHIFT
						/* ribbon shift */
	then if tcb.modes.redm			/* if this is interesting */
	     then do;

005406  aa   000010 1160 07	cmpq 	8,dl
005407  aa   000003 6000 04	tze  	3,ic		005412
005410  aa   000011 1160 07	cmpq 	9,dl
005411  aa   000030 6010 04	tnz  	24,ic		005441
005412  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005413  aa  5 00017 2351 00	lda  	pr5|15		tcb.redm
005414  aa   002000 3150 03	cana 	1024,du
005415  aa   000140 6000 04	tze  	96,ic		005555
						STATEMENT 1 ON LINE 1840
		if white_sw
		then call insert_white;

005416  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005417  aa   000002 6000 04	tze  	2,ic		005421
005420  aa   775603 6700 04	tsp4 	-1149,ic		003223
						STATEMENT 1 ON LINE 1842
		if indicator = RED_SHIFT
		then seqp = addr (special_ptr -> special_chars.red_ribbon_shift);

005421  aa  6 00040 3735 20	epp7 	pr6|32,*
005422  aa  7 00270 2361 00	ldq  	pr7|184		util.indicator
005423  aa   000010 1160 07	cmpq 	8,dl
005424  aa   000005 6010 04	tnz  	5,ic		005431
005425  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
005426  aa  5 00040 3715 00	epp5 	pr5|32		special_chars.red_ribbon_shift
005427  aa  7 00174 6515 00	spri5	pr7|124		seqp
005430  aa   000004 7100 04	tra  	4,ic		005434
						STATEMENT 1 ON LINE 1844
		else seqp = addr (special_ptr -> special_chars.black_ribbon_shift);

005431  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
005432  aa  5 00044 3715 00	epp5 	pr5|36		special_chars.black_ribbon_shift
005433  aa  7 00174 6515 00	spri5	pr7|124		seqp
						STATEMENT 1 ON LINE 1846
		call insert_sequence ("0"b);

005434  aa   000000 2350 07	lda  	0,dl
005435  aa  6 00464 7551 00	sta  	pr6|308
005436  aa   000720 3520 04	epp2 	464,ic		006356 = 000002000000
005437  aa   775424 6700 04	tsp4 	-1260,ic		003063
						STATEMENT 1 ON LINE 1847
	     end;

						STATEMENT 1 ON LINE 1848
	     else ;

005440  aa   000115 7100 04	tra  	77,ic		005555
						STATEMENT 1 ON LINE 1850
	else if indicator = INSERT_NO_COUNT		/* insert without counting column position */
	then do;

005441  aa   000012 1160 07	cmpq 	10,dl
005442  aa   000011 6010 04	tnz  	9,ic		005453
						STATEMENT 1 ON LINE 1852
	     if white_sw
	     then call insert_white;

005443  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005444  aa   000002 6000 04	tze  	2,ic		005446
005445  aa   775556 6700 04	tsp4 	-1170,ic		003223
						STATEMENT 1 ON LINE 1854
	     ctally = 1;

005446  aa   000001 2360 07	ldq  	1,dl
005447  aa  6 00040 3735 20	epp7 	pr6|32,*
005450  aa  7 00265 7561 00	stq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1855
	     call copy_chars;

005451  aa   775301 6700 04	tsp4 	-1343,ic		002752
						STATEMENT 1 ON LINE 1856
	end;

005452  aa   000103 7100 04	tra  	67,ic		005555
						STATEMENT 1 ON LINE 1858
	else if indicator = INSERT_NO_COUNT_2		/* neither this char nor next one affects column position */
	then do;

005453  aa   000013 1160 07	cmpq 	11,dl
005454  aa   000033 6010 04	tnz  	27,ic		005507
						STATEMENT 1 ON LINE 1860
	     if white_sw
	     then call insert_white;

005455  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005456  aa   000002 6000 04	tze  	2,ic		005460
005457  aa   775544 6700 04	tsp4 	-1180,ic		003223
						STATEMENT 1 ON LINE 1862
	     ctally = min (stringl + 1, 2);

005460  aa  6 00040 3735 20	epp7 	pr6|32,*
005461  aa  7 00264 2361 00	ldq  	pr7|180		util.stringl
005462  aa   000001 0760 07	adq  	1,dl
005463  aa   000002 1160 07	cmpq 	2,dl
005464  aa   000002 6040 04	tmi  	2,ic		005466
005465  aa   000002 2360 07	ldq  	2,dl
005466  aa  7 00265 7561 00	stq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1863
	     call copy_chars;

005467  aa   775263 6700 04	tsp4 	-1357,ic		002752
						STATEMENT 1 ON LINE 1865
	     if ctally = 2				/* get them both */
	     then do;

005470  aa  6 00040 3735 20	epp7 	pr6|32,*
005471  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005472  aa   000002 1160 07	cmpq 	2,dl
005473  aa   000010 6010 04	tnz  	8,ic		005503
						STATEMENT 1 ON LINE 1867
		stringp = addr (stringp -> based_chars (1));

005474  aa   000001 7270 07	lxl7 	1,dl
005475  aa  7 00262 3521 20	epp2 	pr7|178,*		based_chars
005476  aa  2 00000 5005 17	a9bd 	pr2|0,7
005477  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1869
		stringl = stringl - 1;

005500  aa   000001 3360 07	lcq  	1,dl
005501  aa  7 00264 0561 00	asq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1870
	     end;

005502  aa   000053 7100 04	tra  	43,ic		005555
						STATEMENT 1 ON LINE 1872
	     else tcb.dont_count_next = "1"b;

005503  aa   200000 2350 03	lda  	65536,du
005504  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005505  aa  5 00030 2551 00	orsa 	pr5|24		tcb.dont_count_next
						STATEMENT 1 ON LINE 1873
	end;

005506  aa   000047 7100 04	tra  	39,ic		005555
						STATEMENT 1 ON LINE 1875
	else if indicator = SKIP			/* ignore this one entirely */
	then ;

005507  aa   000014 1160 07	cmpq 	12,dl
005510  aa   000002 6010 04	tnz  	2,ic		005512
005511  aa   000044 7100 04	tra  	36,ic		005555
						STATEMENT 1 ON LINE 1878
	else if indicator > SPECIAL_ESCAPE
	then do;

005512  aa   000020 1160 07	cmpq 	16,dl
005513  aa   775227 6044 04	tmoz 	-1385,ic		002742
						STATEMENT 1 ON LINE 1880
	     escape_index = indicator - 16;

005514  aa   000020 1760 07	sbq  	16,dl
005515  aa  7 00216 7561 00	stq  	pr7|142		escape_index
						STATEMENT 1 ON LINE 1881
	     if escape_index > special_ptr -> special_chars.escape_length
						/* not a good index */
	     then go to table_error;

005516  aa  7 00122 3715 20	epp5 	pr7|82,*		special_ptr
005517  aa  5 00054 1161 00	cmpq 	pr5|44		special_chars.escape_length
005520  aa   775222 6054 04	tpnz 	-1390,ic		002742
						STATEMENT 1 ON LINE 1885
	     if white_sw
	     then call insert_white;

005521  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005522  aa   000002 6000 04	tze  	2,ic		005524
005523  aa   775500 6700 04	tsp4 	-1216,ic		003223
						STATEMENT 1 ON LINE 1887
	     if tcb.modes.edited
	     then seqp = addr (special_ptr -> special_chars.edited_escapes (escape_index));

005524  aa  6 00040 3735 20	epp7 	pr6|32,*
005525  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005526  aa  5 00017 2351 00	lda  	pr5|15		tcb.edited
005527  aa   400000 3150 03	cana 	131072,du
005530  aa   000014 6000 04	tze  	12,ic		005544
005531  aa  7 00216 2361 00	ldq  	pr7|142		escape_index
005532  aa   000002 7360 00	qls  	2
005533  aa  6 00464 7561 00	stq  	pr6|308
005534  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
005535  aa  3 00054 2361 00	ldq  	pr3|44		special_chars.escape_length
005536  aa   000002 7360 00	qls  	2
005537  aa   000055 0760 07	adq  	45,dl
005540  aa  6 00464 0761 00	adq  	pr6|308
005541  aa  3 77774 3515 06	epp1 	pr3|-4,ql		special_chars.edited_escapes
005542  aa  7 00174 2515 00	spri1	pr7|124		seqp
005543  aa   000006 7100 04	tra  	6,ic		005551
						STATEMENT 1 ON LINE 1889
	     else seqp = addr (special_ptr -> special_chars.not_edited_escapes (escape_index));

005544  aa  7 00216 2361 00	ldq  	pr7|142		escape_index
005545  aa   000002 7360 00	qls  	2
005546  aa  7 00122 3535 20	epp3 	pr7|82,*		special_ptr
005547  aa  3 00051 3535 06	epp3 	pr3|41,ql		special_chars.not_edited_escapes
005550  aa  7 00174 2535 00	spri3	pr7|124		seqp
						STATEMENT 1 ON LINE 1891
	     call insert_sequence ("1"b);

005551  aa   400000 2350 03	lda  	131072,du
005552  aa  6 00464 7551 00	sta  	pr6|308
005553  aa   000603 3520 04	epp2 	387,ic		006356 = 000002000000
005554  aa   775307 6700 04	tsp4 	-1337,ic		003063
						STATEMENT 1 ON LINE 1892
	end;

						STATEMENT 1 ON LINE 1896
	if stringl > 0				/* if we're going around again */
	then source_ptr = stringp;

005555  aa  6 00040 3735 20	epp7 	pr6|32,*
005556  aa  7 00264 2361 00	ldq  	pr7|180		util.stringl
005557  aa   000003 6044 04	tmoz 	3,ic		005562
005560  aa  7 00262 3715 20	epp5 	pr7|178,*		util.stringp
005561  aa  7 00140 6515 00	spri5	pr7|96		source_ptr
						STATEMENT 1 ON LINE 1899
	return;

005562  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 1901
     end move_formated_chars;

  END PROCEDURE move_formated_chars
BEGIN PROCEDURE wrap_lines
ENTRY TO wrap_lines                                         STATEMENT 1 ON LINE 1903
wrap_lines:
     proc;

005563  aa  6 00270 6501 00	spri4	pr6|184
						STATEMENT 1 ON LINE 1911
	if tcb.colmax < 1
	then return;

005564  aa  6 00040 3735 20	epp7 	pr6|32,*
005565  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005566  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
005567  aa   000077 7330 00	lrs  	63
005570  aa   000001 1160 07	cmpq 	1,dl
005571  aa   000002 6050 04	tpl  	2,ic		005573
005572  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1913
	do while (col > tcb.colmax);

005573  aa   000000 0110 03	nop  	0,du
005574  aa  6 00040 3735 20	epp7 	pr6|32,*
005575  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005576  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
005577  aa   000077 7330 00	lrs  	63
005600  aa  6 00474 7561 00	stq  	pr6|316		tcb.colmax
005601  aa  7 00167 1161 00	cmpq 	pr7|119		col
005602  aa   000030 6050 04	tpl  	24,ic		005632
						STATEMENT 1 ON LINE 1914
	     old_tally = ctally;

005603  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005604  aa  7 00172 7561 00	stq  	pr7|122		old_tally
						STATEMENT 1 ON LINE 1915
	     ctally = max (0, tcb.colmax - oldcol);

005605  aa  6 00474 2361 00	ldq  	pr6|316		tcb.colmax
005606  aa  7 00171 1761 00	sbq  	pr7|121		oldcol
005607  aa   000000 1160 07	cmpq 	0,dl
005610  aa   000002 6050 04	tpl  	2,ic		005612
005611  aa   000000 2360 07	ldq  	0,dl
005612  aa  7 00265 7561 00	stq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1916
	     if ctally > 0
	     then call copy_chars;

005613  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005614  aa   000002 6044 04	tmoz 	2,ic		005616
005615  aa   775135 6700 04	tsp4 	-1443,ic		002752
						STATEMENT 1 ON LINE 1918
	     call insert_nl ("1"b);

005616  aa   400000 2350 03	lda  	131072,du
005617  aa  6 00474 7551 00	sta  	pr6|316
005620  aa   000532 3520 04	epp2 	346,ic		006352 = 000002000000
005621  aa   775602 6700 04	tsp4 	-1150,ic		003423
						STATEMENT 1 ON LINE 1920
	     ctally = old_tally - ctally;

005622  aa  6 00040 3735 20	epp7 	pr6|32,*
005623  aa  7 00172 2361 00	ldq  	pr7|122		old_tally
005624  aa  7 00265 1561 00	ssq  	pr7|181		util.ctally
						STATEMENT 1 ON LINE 1921
	     oldcol = 2;

005625  aa   000002 2360 07	ldq  	2,dl
005626  aa  7 00171 7561 00	stq  	pr7|121		oldcol
						STATEMENT 1 ON LINE 1922
	     col = col + ctally;

005627  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005630  aa  7 00167 0561 00	asq  	pr7|119		col
						STATEMENT 1 ON LINE 1923
	end;

005631  aa   777743 7100 04	tra  	-29,ic		005574
						STATEMENT 1 ON LINE 1925
	if ctally > 0				/* any more chars to copy? */
	then call copy_chars;

005632  aa  7 00265 2361 00	ldq  	pr7|181		util.ctally
005633  aa   000002 6044 04	tmoz 	2,ic		005635
005634  aa   775116 6700 04	tsp4 	-1458,ic		002752
						STATEMENT 1 ON LINE 1927
	wcol = col;

005635  aa  6 00040 3735 20	epp7 	pr6|32,*
005636  aa  7 00167 2361 00	ldq  	pr7|119		col
005637  aa  7 00170 7561 00	stq  	pr7|120		wcol
						STATEMENT 1 ON LINE 1929
	return;

005640  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1931
     end wrap_lines;

  END PROCEDURE wrap_lines
BEGIN PROCEDURE scan_white
ENTRY TO scan_white                                         STATEMENT 1 ON LINE 1934
scan_white:
     proc (advanced);

005641  aa  6 00276 6501 00	spri4	pr6|190
005642  aa  6 00300 2521 00	spri2	pr6|192
						STATEMENT 1 ON LINE 1947
	done = "0"b;

005643  aa  6 00304 4501 00	stz  	pr6|196		done
						STATEMENT 1 ON LINE 1948
	first_time = "1"b;

005644  aa   400000 2350 03	lda  	131072,du
005645  aa  6 00305 7551 00	sta  	pr6|197		first_time
						STATEMENT 1 ON LINE 1949
	white_sw = "1"b;

005646  aa  6 00040 3735 20	epp7 	pr6|32,*
005647  aa  7 00165 7551 00	sta  	pr7|117		white_sw
						STATEMENT 1 ON LINE 1950
	do while (util.stringl > 0 & ^done);

005650  aa  6 00040 3735 20	epp7 	pr6|32,*
005651  aa  7 00264 2361 00	ldq  	pr7|180		util.stringl
005652  aa   000070 6044 04	tmoz 	56,ic		005742
005653  aa  6 00304 2351 00	lda  	pr6|196		done
005654  aa   000066 6010 04	tnz  	54,ic		005742
						STATEMENT 1 ON LINE 1951
	     if stringp -> based_onechar = backspace
	     then wcol = max (0, wcol - 1);

005655  aa  7 00262 3715 20	epp5 	pr7|178,*		util.stringp
005656  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
005657  aa  5 00000 00 0001	desc9a	pr5|0,1		based_onechar
005660  aa  6 00475 00 0004	desc9a	pr6|317,4		based_onechar
005661  aa  6 00475 2351 00	lda  	pr6|317		based_onechar
005662  aa   010000 1150 03	cmpa 	4096,du
005663  aa   000010 6010 04	tnz  	8,ic		005673
005664  aa  7 00170 2361 00	ldq  	pr7|120		wcol
005665  aa   000001 1760 07	sbq  	1,dl
005666  aa   000000 1160 07	cmpq 	0,dl
005667  aa   000002 6050 04	tpl  	2,ic		005671
005670  aa   000000 2360 07	ldq  	0,dl
005671  aa  7 00170 7561 00	stq  	pr7|120		wcol
005672  aa   000026 7100 04	tra  	22,ic		005720
						STATEMENT 1 ON LINE 1954
	     else if stringp -> based_onechar = space
	     then wcol = wcol + 1;

005673  aa   040000 1150 03	cmpa 	16384,du
005674  aa   000003 6010 04	tnz  	3,ic		005677
005675  aa  7 00170 0541 00	aos  	pr7|120		wcol
005676  aa   000022 7100 04	tra  	18,ic		005720
						STATEMENT 1 ON LINE 1957
	     else if stringp -> based_onechar = tab
	     then wcol = wcol + 10 - mod (wcol, 10);

005677  aa   011000 1150 03	cmpa 	4608,du
005700  aa   000012 6010 04	tnz  	10,ic		005712
005701  aa  7 00170 2361 00	ldq  	pr7|120		wcol
005702  aa   000576 3520 04	epp2 	382,ic		006500 = 000000000012
005703  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005704  aa  6 00476 7561 00	stq  	pr6|318
005705  aa  7 00170 2361 00	ldq  	pr7|120		wcol
005706  aa  2 00000 0761 00	adq  	pr2|0
005707  aa  6 00476 1761 00	sbq  	pr6|318
005710  aa  7 00170 7561 00	stq  	pr7|120		wcol
005711  aa   000007 7100 04	tra  	7,ic		005720
						STATEMENT 1 ON LINE 1960
	     else if stringp -> based_onechar = carriage_return
	     then wcol = 0;

005712  aa   015000 1150 03	cmpa 	6656,du
005713  aa   000003 6010 04	tnz  	3,ic		005716
005714  aa  7 00170 4501 00	stz  	pr7|120		wcol
005715  aa   000003 7100 04	tra  	3,ic		005720
						STATEMENT 1 ON LINE 1963
	     else done = "1"b;

005716  aa   400000 2350 03	lda  	131072,du
005717  aa  6 00304 7551 00	sta  	pr6|196		done
						STATEMENT 1 ON LINE 1965
	     if ^done | (first_time & ^advanced)	/* in case first character wasn't really whitespace */
	     then do;

005720  aa  6 00304 2351 00	lda  	pr6|196		done
005721  aa   000011 6000 04	tze  	9,ic		005732
005722  aa  6 00305 2351 00	lda  	pr6|197		first_time
005723  aa   777725 6000 04	tze  	-43,ic		005650
005724  aa  6 00300 3535 20	epp3 	pr6|192,*
005725  aa  3 00002 3515 20	epp1 	pr3|2,*
005726  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
005727  aa  1 00000 00 0001	descb	pr1|0,1		advanced
005730  aa   000000 00 0000	descb	0,0
005731  aa   777717 6010 04	tnz  	-49,ic		005650
						STATEMENT 1 ON LINE 1967
		stringp = addr (stringp -> based_chars (1));

005732  aa   000001 7270 07	lxl7 	1,dl
005733  aa  5 00000 3521 00	epp2 	pr5|0		based_chars
005734  aa  2 00000 5005 17	a9bd 	pr2|0,7
005735  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
						STATEMENT 1 ON LINE 1969
		stringl = stringl - 1;

005736  aa   000001 3360 07	lcq  	1,dl
005737  aa  7 00264 0561 00	asq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 1970
		first_time = "0"b;

005740  aa  6 00305 4501 00	stz  	pr6|197		first_time
						STATEMENT 1 ON LINE 1971
	     end;

						STATEMENT 1 ON LINE 1972
	end;

005741  aa   777707 7100 04	tra  	-57,ic		005650
						STATEMENT 1 ON LINE 1973
	return;

005742  aa  6 00276 6101 00	rtcd 	pr6|190
						STATEMENT 1 ON LINE 1975
     end scan_white;

  END PROCEDURE scan_white
BEGIN PROCEDURE octal_escape
ENTRY TO octal_escape                                       STATEMENT 1 ON LINE 1977
octal_escape:
     proc;

005743  aa  6 00306 6501 00	spri4	pr6|198
						STATEMENT 1 ON LINE 1984
	if ^tcb.modes.edited
	then do;

005744  aa  6 00040 3735 20	epp7 	pr6|32,*
005745  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005746  aa  5 00017 2351 00	lda  	pr5|15		tcb.edited
005747  aa   400000 3150 03	cana 	131072,du
005750  aa   000070 6010 04	tnz  	56,ic		006040
						STATEMENT 1 ON LINE 1986
	     if white_sw
	     then call insert_white;

005751  aa  7 00165 2351 00	lda  	pr7|117		white_sw
005752  aa   000002 6000 04	tze  	2,ic		005754
005753  aa   775250 6700 04	tsp4 	-1368,ic		003223
						STATEMENT 1 ON LINE 1988
	     if ((tcb.colmax > 0) & (col >= tcb.colmax))	/* in case we went off end of line */
	     then call insert_nl ("1"b);

005754  aa  6 00040 3735 20	epp7 	pr6|32,*
005755  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
005756  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
005757  aa   000077 7330 00	lrs  	63
005760  aa   000007 6044 04	tmoz 	7,ic		005767
005761  aa  7 00167 1161 00	cmpq 	pr7|119		col
005762  aa   000005 6054 04	tpnz 	5,ic		005767
005763  aa   400000 2350 03	lda  	131072,du
005764  aa  6 00477 7551 00	sta  	pr6|319
005765  aa   000361 3520 04	epp2 	241,ic		006346 = 000002000000
005766  aa   775435 6700 04	tsp4 	-1251,ic		003423
						STATEMENT 1 ON LINE 1991
	     call insert_char (escape_char);

005767  aa   000435 3520 04	epp2 	285,ic		006424 = 000002000000
005770  aa   775006 6700 04	tsp4 	-1530,ic		002776
						STATEMENT 1 ON LINE 1992
	     col = col + 1;

005771  aa  6 00040 3735 20	epp7 	pr6|32,*
005772  aa  7 00167 0541 00	aos  	pr7|119		col
						STATEMENT 1 ON LINE 1994
	     do i = 1 to 9 by 3;

005773  aa   000001 2360 07	ldq  	1,dl
005774  aa  7 00176 7561 00	stq  	pr7|126		i
005775  aa   000000 0110 03	nop  	0,du
005776  aa  6 00040 3735 20	epp7 	pr6|32,*
005777  aa  7 00176 2361 00	ldq  	pr7|126		i
006000  aa   000011 1160 07	cmpq 	9,dl
006001  aa   000037 6054 04	tpnz 	31,ic		006040
						STATEMENT 1 ON LINE 1995
		if ((tcb.colmax > 0) & (col >= tcb.colmax))
						/* if we go off end of line */
		then call insert_nl ("1"b);

006002  aa  7 00330 3715 20	epp5 	pr7|216,*		tcbp
006003  aa  5 00021 2351 00	lda  	pr5|17		tcb.colmax
006004  aa   000077 7330 00	lrs  	63
006005  aa   000007 6044 04	tmoz 	7,ic		006014
006006  aa  7 00167 1161 00	cmpq 	pr7|119		col
006007  aa   000005 6054 04	tpnz 	5,ic		006014
006010  aa   400000 2350 03	lda  	131072,du
006011  aa  6 00477 7551 00	sta  	pr6|319
006012  aa   000334 3520 04	epp2 	220,ic		006346 = 000002000000
006013  aa   775410 6700 04	tsp4 	-1272,ic		003423
						STATEMENT 1 ON LINE 1999
		call insert_char (num_array (fixed (substr (unspec (stringp -> based_onechar), i, 3), 3)));

006014  aa  6 00040 3735 20	epp7 	pr6|32,*
006015  aa  7 00176 7271 00	lxl7 	pr7|126		i
006016  aa  7 00262 3715 20	epp5 	pr7|178,*		util.stringp
006017  aa  003 100 060 517	csl  	(pr,x7),(pr),fill(0),bool(move)
006020  aa  5 77777 70 0003	descb	pr5|-1(35),3
006021  aa  6 00056 00 0044	descb	pr6|46,36
006022  aa  6 00056 2351 00	lda  	pr6|46
006023  aa   000105 7730 00	lrl  	69
006024  ta   000102 3520 00	epp2 	66
006025  aa  2 00000 5005 06	a9bd 	pr2|0,ql
006026  aa  6 00502 2521 00	spri2	pr6|322
006027  aa  6 00500 3521 00	epp2 	pr6|320
006030  aa   004000 4310 07	fld  	2048,dl
006031  aa  2 00000 7571 00	staq 	pr2|0
006032  aa   774744 6700 04	tsp4 	-1564,ic		002776
						STATEMENT 1 ON LINE 2000
		col = col + 1;

006033  aa  6 00040 3735 20	epp7 	pr6|32,*
006034  aa  7 00167 0541 00	aos  	pr7|119		col
						STATEMENT 1 ON LINE 2001
	     end;

006035  aa   000003 2360 07	ldq  	3,dl
006036  aa  7 00176 0561 00	asq  	pr7|126		i
006037  aa   777737 7100 04	tra  	-33,ic		005776
						STATEMENT 1 ON LINE 2002
	end;

						STATEMENT 1 ON LINE 2004
	stringp = addr (stringp -> based_chars (1));

006040  aa   000001 7270 07	lxl7 	1,dl
006041  aa  7 00262 3521 20	epp2 	pr7|178,*		based_chars
006042  aa  2 00000 5005 17	a9bd 	pr2|0,7
006043  aa  7 00262 2521 00	spri2	pr7|178		util.stringp
						STATEMENT 1 ON LINE 2005
	stringl = stringl - 1;

006044  aa   000001 3360 07	lcq  	1,dl
006045  aa  7 00264 0561 00	asq  	pr7|180		util.stringl
						STATEMENT 1 ON LINE 2006
     end octal_escape;

006046  aa  6 00306 6101 00	rtcd 	pr6|198
  END PROCEDURE octal_escape
  END BLOCK  1
						STATEMENT 1 ON LINE 2010
all_done:
	a_nelemt = nelemt;

006047  aa  6 00106 2361 00	ldq  	pr6|70		nelemt
006050  aa  6 00340 7561 20	stq  	pr6|224,*		a_nelemt
						STATEMENT 1 ON LINE 2014
	if uncp_flag then do;

006051  aa  6 00260 2351 00	lda  	pr6|176		uncp_flag
006052  aa   400000 3150 03	cana 	131072,du
006053  aa   000054 6000 04	tze  	44,ic		006127
						STATEMENT 1 ON LINE 2015
	     if wtcb.send_turn
		then do;

006054  aa  6 00326 3735 20	epp7 	pr6|214,*		wtcbp
006055  aa  7 00023 2351 00	lda  	pr7|19		wtcb.send_turn
006056  aa   000200 3150 03	cana 	128,du
006057  aa   000050 6000 04	tze  	40,ic		006127
						STATEMENT 1 ON LINE 2017
		if ^wtcb.flags.wru			/* if not reading answerback  */
		     then if wtcb.receive_mode_device	/* must we tell multiplexer to turn line around? */
		     then do;

006060  aa  7 00013 2351 00	lda  	pr7|11		wtcb.wru
006061  aa   000010 3150 03	cana 	8,du
006062  aa   000043 6010 04	tnz  	35,ic		006125
006063  aa  7 00013 2351 00	lda  	pr7|11		wtcb.receive_mode_device
006064  aa   004000 3150 07	cana 	2048,dl
006065  aa   000042 6000 04	tze  	34,ic		006127
						STATEMENT 1 ON LINE 2020
			call channel_manager$control (devx, "enter_receive", null, ercode);

006066  aa   772044 2370 04	ldaq 	-3036,ic		000132 = 145156164145 162137162145
006067  aa  6 00360 7571 00	staq 	pr6|240
006070  aa   772044 2370 04	ldaq 	-3036,ic		000134 = 143145151166 145000000000
006071  aa  6 00362 7571 00	staq 	pr6|242
006072  aa   772034 3714 24	epp5 	-3044,ic*
006073  aa  6 00370 6515 00	spri5	pr6|248
006074  aa  6 00101 3521 00	epp2 	pr6|65		devx
006075  aa  6 00374 2521 00	spri2	pr6|252
006076  aa  6 00360 3521 00	epp2 	pr6|240
006077  aa  6 00376 2521 00	spri2	pr6|254
006100  aa  6 00370 3521 00	epp2 	pr6|248
006101  aa  6 00400 2521 00	spri2	pr6|256
006102  aa  6 00344 3521 20	epp2 	pr6|228,*		ercode
006103  aa  6 00402 2521 00	spri2	pr6|258
006104  aa   772016 3520 04	epp2 	-3058,ic		000122 = 404000000021
006105  aa  6 00404 2521 00	spri2	pr6|260
006106  aa   772005 3520 04	epp2 	-3067,ic		000113 = 524000000015
006107  aa  6 00406 2521 00	spri2	pr6|262
006110  aa   772011 3520 04	epp2 	-3063,ic		000121 = 464000000000
006111  aa  6 00410 2521 00	spri2	pr6|264
006112  aa   772003 3520 04	epp2 	-3069,ic		000115 = 404000000043
006113  aa  6 00412 2521 00	spri2	pr6|266
006114  aa  6 00372 6211 00	eax1 	pr6|250
006115  aa   020000 4310 07	fld  	8192,dl
006116  aa  6 00044 3701 20	epp4 	pr6|36,*
006117  la  4 00066 3521 20	epp2 	pr4|54,*		channel_manager$control
006120  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2022
			wtcb.send_turn = "0"b;

006121  aa   000345 2350 04	lda  	229,ic		006466 = 777577777777
006122  aa  6 00326 3735 20	epp7 	pr6|214,*		wtcbp
006123  aa  7 00023 3551 00	ansa 	pr7|19		wtcb.send_turn
						STATEMENT 1 ON LINE 2023
		     end;

						STATEMENT 1 ON LINE 2024
		     else ;

006124  aa   000003 7100 04	tra  	3,ic		006127
						STATEMENT 1 ON LINE 2025
		     else wtcb.flags.wru = "0"b;

006125  aa   000220 2350 04	lda  	144,ic		006345 = 777767777777
006126  aa  7 00013 3551 00	ansa 	pr7|11		wtcb.wru
						STATEMENT 1 ON LINE 2026
	     end;

						STATEMENT 1 ON LINE 2027
	end;

						STATEMENT 1 ON LINE 2029
unlock:
	time_spent = clock () - start_time;

006127  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
006130  aa  6 00162 1771 00	sbaq 	pr6|114		start_time
006131  aa  6 00160 7571 00	staq 	pr6|112		time_spent
						STATEMENT 1 ON LINE 2031
	tcb.cumulative_meters.write_time = tcb.cumulative_meters.write_time + time_spent;

006132  aa  6 00330 3735 20	epp7 	pr6|216,*		tcbp
006133  aa  7 00040 0771 00	adaq 	pr7|32		tcb.write_time
006134  aa  7 00040 7571 00	staq 	pr7|32		tcb.write_time
						STATEMENT 1 ON LINE 2032
	tty_buf.write_time = tty_buf.write_time + time_spent;

006135  aa  6 00322 3715 20	epp5 	pr6|210,*		ttybp
006136  aa  5 00026 2371 00	ldaq 	pr5|22		tty_buf.write_time
006137  aa  6 00160 0771 00	adaq 	pr6|112		time_spent
006140  aa  5 00026 7571 00	staq 	pr5|22		tty_buf.write_time
						STATEMENT 1 ON LINE 2033
	if ^locked_entry
	then call tty_lock$unlock_channel (devx);

006141  aa  6 00107 2351 00	lda  	pr6|71		locked_entry
006142  aa   000010 6010 04	tnz  	8,ic		006152
006143  aa  6 00101 3521 00	epp2 	pr6|65		devx
006144  aa  6 00362 2521 00	spri2	pr6|242
006145  aa  6 00360 6211 00	eax1 	pr6|240
006146  aa   004000 4310 07	fld  	2048,dl
006147  aa  6 00044 3701 20	epp4 	pr6|36,*
006150  la  4 00014 3521 20	epp2 	pr4|12,*		tty_lock$unlock_channel
006151  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2036
	return;

006152  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2038
nothing_written:
	if wtcb.send_output
	then call tty_space_man$needs_space (devx);

006153  aa  6 00326 3735 20	epp7 	pr6|214,*		wtcbp
006154  aa  7 00013 2351 00	lda  	pr7|11		wtcb.send_output
006155  aa   100000 3150 03	cana 	32768,du
006156  aa   000011 6000 04	tze  	9,ic		006167
006157  aa  6 00101 3521 00	epp2 	pr6|65		devx
006160  aa  6 00362 2521 00	spri2	pr6|242
006161  aa  6 00360 6211 00	eax1 	pr6|240
006162  aa   004000 4310 07	fld  	2048,dl
006163  aa  6 00044 3701 20	epp4 	pr6|36,*
006164  la  4 00062 3521 20	epp2 	pr4|50,*		tty_space_man$needs_space
006165  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
006166  aa   000003 7100 04	tra  	3,ic		006171
						STATEMENT 1 ON LINE 2041
	else wtcb.wflag = "1"b;

006167  aa   000040 2350 03	lda  	32,du
006170  aa  7 00013 2551 00	orsa 	pr7|11		wtcb.wflag
						STATEMENT 1 ON LINE 2042
	ercode = 0;

006171  aa  6 00344 4501 20	stz  	pr6|228,*		ercode
						STATEMENT 1 ON LINE 2043
	go to all_done;

006172  aa   777655 7100 04	tra  	-83,ic		006047
						STATEMENT 1 ON LINE 2083
     end /* tty_write */;

BEGIN PROCEDURE free_buffers
ENTRY TO free_buffers                                       STATEMENT 1 ON LINE 2045
free_buffers:
     proc;

006173  da     000345200000
006174  aa   000120 6270 00	eax7 	80
006175  aa  7 00034 3521 20	epp2 	pr7|28,*
006176  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
006177  aa     000000000000
006200  aa     000000000000
						STATEMENT 1 ON LINE 2050
	if headp ^= null				/* we'd peeled off a page */
	then do;

006201  aa  6 00040 3735 20	epp7 	pr6|32,*
006202  aa  7 00220 2371 00	ldaq 	pr7|144		headp
006203  aa   771723 6770 04	eraq 	-3117,ic		000126 = 077777000043 000001000000
006204  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006205  aa   000024 6000 04	tze  	20,ic		006231
						STATEMENT 1 ON LINE 2052
	     if uncp_flag then wtcb.send_turn = lastp -> buffer.turn;

006206  aa  7 00260 2351 00	lda  	pr7|176		uncp_flag
006207  aa   400000 3150 03	cana 	131072,du
006210  aa   000007 6000 04	tze  	7,ic		006217
006211  aa  7 00226 2351 20	lda  	pr7|150,*		buffer.turn
006212  aa   000014 7350 00	als  	12
006213  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
006214  aa  5 00023 6751 00	era  	pr5|19		wtcb.send_turn
006215  aa   000200 3750 03	ana  	128,du
006216  aa  5 00023 6551 00	ersa 	pr5|19		wtcb.send_turn
						STATEMENT 1 ON LINE 2053
	     call tty_space_man$free_chain (devx, OUTPUT, headp);

006217  aa  7 00101 3521 00	epp2 	pr7|65		devx
006220  aa  6 00102 2521 00	spri2	pr6|66
006221  aa   771673 3520 04	epp2 	-3141,ic		000114 = 400000000000
006222  aa  6 00104 2521 00	spri2	pr6|68
006223  aa  7 00220 3521 00	epp2 	pr7|144		headp
006224  aa  6 00106 2521 00	spri2	pr6|70
006225  aa  6 00100 6211 00	eax1 	pr6|64
006226  aa   014000 4310 07	fld  	6144,dl
006227  la  4 00060 3521 20	epp2 	pr4|48,*		tty_space_man$free_chain
006230  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2054
	end;

						STATEMENT 1 ON LINE 2055
	if new_head ^= 0
	then call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, new_head));

006231  aa  6 00040 3735 20	epp7 	pr6|32,*
006232  aa  7 00223 2361 00	ldq  	pr7|147		new_head
006233  aa   000017 6000 04	tze  	15,ic		006252
006234  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
006235  aa   000000 3120 06	eawp2	0,ql
006236  aa  6 00110 2521 00	spri2	pr6|72
006237  aa  7 00101 3521 00	epp2 	pr7|65		devx
006240  aa  6 00102 2521 00	spri2	pr6|66
006241  aa   771653 3520 04	epp2 	-3157,ic		000114 = 400000000000
006242  aa  6 00104 2521 00	spri2	pr6|68
006243  aa  6 00110 3521 00	epp2 	pr6|72
006244  aa  6 00106 2521 00	spri2	pr6|70
006245  aa  6 00100 6211 00	eax1 	pr6|64
006246  aa   014000 4310 07	fld  	6144,dl
006247  aa  6 00044 3701 20	epp4 	pr6|36,*
006250  la  4 00060 3521 20	epp2 	pr4|48,*		tty_space_man$free_chain
006251  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2058
	wtcb.end_frame = old_end_frame;

006252  aa  6 00040 3735 20	epp7 	pr6|32,*
006253  aa  7 00204 2351 00	lda  	pr7|132		old_end_frame
006254  aa   000005 7710 00	arl  	5
006255  aa  7 00326 3715 20	epp5 	pr7|214,*		wtcbp
006256  aa  5 00013 6751 00	era  	pr5|11		wtcb.end_frame
006257  aa   010000 3750 03	ana  	4096,du
006260  aa  5 00013 6551 00	ersa 	pr5|11		wtcb.end_frame
						STATEMENT 1 ON LINE 2059
	wtcb.write_first = old_head;

006261  aa  7 00202 2361 00	ldq  	pr7|130		old_head
006262  aa   000066 7370 00	lls  	54
006263  aa  5 00016 5511 60	stba 	pr5|14,60		wtcb.write_first
						STATEMENT 1 ON LINE 2060
	wtcb.write_last = old_tail;

006264  aa  7 00203 2361 00	ldq  	pr7|131		old_tail
006265  aa  5 00016 5521 14	stbq 	pr5|14,14		wtcb.write_last
						STATEMENT 1 ON LINE 2061
	if wtcb.write_last ^= 0
	then ptr (ttybp, wtcb.write_last) -> buffer.next = 0;

006266  aa  6 00112 7561 00	stq  	pr6|74		wtcb.write_last
006267  aa   000005 6000 04	tze  	5,ic		006274
006270  aa  7 00322 3521 20	epp2 	pr7|210,*		ttybp
006271  aa   000000 3120 06	eawp2	0,ql
006272  aa   000000 2350 07	lda  	0,dl
006273  aa  2 00000 5511 60	stba 	pr2|0,60		buffer.next
						STATEMENT 1 ON LINE 2064
	return;

006274  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2065
     end /* free_buffers */;

  END PROCEDURE free_buffers
BEGIN PROCEDURE is_parent_mpx
ENTRY TO is_parent_mpx                                      STATEMENT 1 ON LINE 2068
is_parent_mpx:					/* Check for match of channel's parent mpx type and input mpx type */
     proc (parent_mpx_type) returns (bit (1));

006275  aa  6 00346 6501 00	spri4	pr6|230
006276  aa  6 00350 2521 00	spri2	pr6|232
						STATEMENT 1 ON LINE 2074
	lctep = addr (lct.lcte_array (devx));

006277  aa  6 00101 2361 00	ldq  	pr6|65		devx
006300  aa   000005 7360 00	qls  	5
006301  aa  6 00332 3735 20	epp7 	pr6|218,*		lctp
006302  aa  7 77760 3735 06	epp7 	pr7|-16,ql	lct.lcte_array
006303  aa  6 00334 6535 00	spri7	pr6|220		lctep
						STATEMENT 1 ON LINE 2075
	if lcte.major_channel_devx ^= 0 then do;

006304  aa  7 00003 2351 00	lda  	pr7|3		lcte.major_channel_devx
006305  aa   000066 7330 00	lrs  	54
006306  aa  6 00414 7561 00	stq  	pr6|268		lcte.major_channel_devx
006307  aa   000017 6000 04	tze  	15,ic		006326
						STATEMENT 1 ON LINE 2076
	     temp_lctep = addr (lct.lcte_array (lcte.major_channel_devx));

006310  aa   000005 7360 00	qls  	5
006311  aa  6 00332 3715 20	epp5 	pr6|218,*		lctp
006312  aa  5 77760 3715 06	epp5 	pr5|-16,ql	lct.lcte_array
006313  aa  6 00354 6515 00	spri5	pr6|236		temp_lctep
						STATEMENT 1 ON LINE 2077
	     if temp_lctep->lcte.channel_type = parent_mpx_type then return ("1"b);

006314  aa  5 00002 2351 00	lda  	pr5|2		lcte.channel_type
006315  aa   000077 7330 00	lrs  	63
006316  aa  2 00002 1161 20	cmpq 	pr2|2,*		parent_mpx_type
006317  aa   000020 6010 04	tnz  	16,ic		006337
006320  aa  2 00004 3535 20	epp3 	pr2|4,*
006321  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
006322  aa   000000 00 0000	descb	0,0
006323  aa  3 00000 00 0001	descb	pr3|0,1
006324  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 2078
	end;

006325  aa   000012 7100 04	tra  	10,ic		006337
						STATEMENT 1 ON LINE 2079
	else if lcte.channel_type = parent_mpx_type then return ("1"b);

006326  aa  7 00002 2351 00	lda  	pr7|2		lcte.channel_type
006327  aa   000077 7330 00	lrs  	63
006330  aa  2 00002 1161 20	cmpq 	pr2|2,*		parent_mpx_type
006331  aa   000006 6010 04	tnz  	6,ic		006337
006332  aa  2 00004 3715 20	epp5 	pr2|4,*
006333  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
006334  aa   000000 00 0000	descb	0,0
006335  aa  5 00000 00 0001	descb	pr5|0,1
006336  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 2080
	return ("0"b);

006337  aa  6 00350 3735 20	epp7 	pr6|232,*
006340  aa  7 00004 3715 20	epp5 	pr7|4,*
006341  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
006342  aa   000000 00 0000	descb	0,0
006343  aa  5 00000 00 0001	descb	pr5|0,1
006344  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 2081
     end is_parent_mpx;

  END PROCEDURE is_parent_mpx
  END PROCEDURE tty_write


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
