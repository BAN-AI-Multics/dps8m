	COMPILATION LISTING OF SEGMENT tape_mult_close_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1005.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
       14 tape_mult_close_:
       15      procedure;
       16 
       17 /*	This program is part of the Multics standard tape I/O module, tape_mult_.
       18*   *
       19*   *	Created on 10/28/74 by Bill Silver.
       20*   *      Modified 07/02/81 by J. A. Bush for bootable tape labels
       21*   *	Modified 01/16/82 by J. A. Bush to process the "error_tally" att desc arg
       22*   *      Modified 8/82 by S. Krupp for change from tdcm_ to tape_ioi_ interface.
       23*   *
       24*   *	This program implements the iox_$close entry point.
       25*   *	We must prepare the tape and all of our info for the tape to be opened
       26*   *	again.  When closing the tape we must do the following:
       27*   *	     1.  Rewind the tape reel.  When opening a tape it must be at BOT.
       28*   *	     2.  Close the I/O control block.
       29*   *	When closing a tape that has been opened for writing we must first perform the
       30*   *	following additional steps:
       31*   *	     1.  Write out all currently buffered output data.
       32*   *	     2.  Write an EOF record.
       33*   *	     3.  Write an End of Reel record.  This contains all PAD characters.
       34*   *	     4.  Write two EOF records.
       35*   *	When writing this end of tape information we must ignore all device_end errors.
       36**/
       37 
       38 
       39 /*		ARGUMENTS			*/
       40 
       41 dcl	arg_error_code	   fixed bin (35),		/* (O) Standard system error code. */
       42 	arg_iocb_ptr	   ptr;			/* (I) Pointer to I/O control block. */
       43 
       44 
       45 /*		AUTOMATIC  DATA		*/
       46 
       47 dcl	eot_flag		   bit (1),		/* ON => tape at End of Tape. */
       48 	error_code	   fixed bin (35),		/* Standard system error code. */
       49 	i		   fixed bin,
       50 	iocb_ptr		   ptr,			/* Pointer to I/O control block. */
       51 	put_hdr		   bit (1) aligned,
       52 	rx		   fixed bin,
       53 	save_code		   fixed bin (35),		/* Used to play with error code. */
       54 	tioi_id		   bit (36) aligned;	/* Id of tape_ioi_ activation. */
       55 
       56 dcl	1 auto_error_tally	   aligned like tec;	/* Keeps track of number of errors. */
       57 
       58 /*		INTERNAL STATIC DATA	*/
       59 
       60 dcl	pad_char		   bit (9) aligned internal static init ("111111111"b);
       61 						/*		EXTERNAL ENTRIES		*/
       62 
       63 dcl	(addr, hbound, null, string)
       64 			   builtin;
       65 
       66 dcl	error_table_$device_end
       67 			   fixed bin (35) external;
       68 dcl	error_table_$device_parity
       69 			   fixed bin (35) external;
       70 
       71 dcl	iox_$err_not_open	   entry options (variable),
       72 	iox_$propagate	   entry (ptr),
       73 	ioa_		   entry options (variable),
       74 	tape_mult_detach_$detach
       75 			   entry (ptr, fixed bin (35)),
       76 	tape_mult_open_$open   entry (ptr, fixed bin, bit (1), fixed bin (35)),
       77 	tape_mult_util_$wait_for_write
       78 			   entry (bit (36) aligned, fixed bin, fixed bin (35)),
       79 	tape_mult_write_$flush entry (ptr, fixed bin (35)),
       80 	tape_mult_write_$eof   entry (ptr, fixed bin (35)),
       81 	tape_mult_write_$record
       82 			   entry (ptr, ptr, fixed bin, fixed bin (35));
       83 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     3*      version number to IOX2. */
  1     4 /* format: style2 */
  1     5 
  1     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     7 	     2 version	      character (4) aligned,	/* IOX2 */
  1     8 	     2 name	      char (32),		/* I/O name of this block. */
  1     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    17 						/* open(p,mode,not_used,s) */
  1    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    24 						/* put_chars(p,bufptr,buflen,s) */
  1    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    26 						/* modes(p,newmode,oldmode,s) */
  1    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    28 						/* position(p,u1,u2,s) */
  1    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    30 						/* control(p,order,infptr,s) */
  1    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* write_record(p,bufptr,buflen,s) */
  1    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    36 						/* rewrite_record(p,bufptr,buflen,s) */
  1    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* seek_key(p,key,len,s) */
  1    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    41 						/* read_key(p,key,len,s) */
  1    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  1    43 						/* read_length(p,len,s) */
  1    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    45 						/* open_file(p,mode,desc,not_used,s) */
  1    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    47 						/* close_file(p,desc,s) */
  1    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  1    49 						/* detach(p,desc,s) */
  1    50 
  1    51      declare iox_$iocb_version_sentinel
  1    52 			      character (4) aligned external static;
  1    53 
  1    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
       84 
       85 
  2     1 /*	Begin  include file ... tmdb.incl.pl1
  2     2*   *
  2     3*   *	Created by  Bill Silver  on 10/20/74
  2     4*   *	Modified by J. A. Bush 12/30/80 for bootable tape labels
  2     5*   *	Modified by J. A. Bush 12/15/81 for re-write of read error recovery
  2     6*   *      Modified 8/82 by S.Krupp for change from tdcm_ to tape_ioi_
  2     7*   *	This include file describes the work variables used by the Multics standard
  2     8*   *	tape I/O module, tape_mult_.  This include file must be used with the include
  2     9*   *	file:  mstr.incl.pl1
  2    10**/
  2    11 
  2    12 
  2    13 /****^  HISTORY COMMENTS:
  2    14*  1) change(86-10-13,GWMay), approve(86-10-13,MCR7552),
  2    15*     audit(86-10-13,Martinson), install(86-10-20,MR12.0-1189):
  2    16*     added fields to the tmdb structure that will add support for the use of
  2    17*     rcp in determining the density and format of a tape.
  2    18*                                                   END HISTORY COMMENTS */
  2    19 
  2    20 
  2    21 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  2    22 dcl	tmdb_ptr		   ptr;			/* Pointer to tape_mult_ data block. */
  2    23 
  2    24 dcl	1 tmdb		   based (tmdb_ptr) aligned,	/* tape_mult_ data block. */
  2    25 	  2 attach,				/* Attach description. */
  2    26 	    3 length	   fixed bin,		/* Actual length of attach description. */
  2    27 	    3 description	   char (64),		/* Attach description string. */
  2    28 	  2 open,					/* Open description. */
  2    29 	    3 length	   fixed bin,		/* Actual length of open description. */
  2    30 	    3 description	   char (32),		/* Open description string. */
  2    31 	  2 opt,					/* Attach options. */
  2    32 	    3 flags,				/* Flags set from user input and options. */
  2    33 	    ( 4 com_err	   bit (1),		/* ON => call com_err_ if there is an error. */
  2    34 	      4 ring	   bit (1),		/* ON => use writ ring,  OFF => no write ring. */
  2    35 	      4 system	   bit (1),		/* ON => user wants to be a system process. */
  2    36 	      4 err_tal	   bit (1),		/* ON => user wants error report */
  2    37 	      4 begin	   bit (1),		/* ON => begin processing tape */
  2    38 	      4 write_sw	   bit (1),		/* ON => write allowed */
  2    39 	      4 async_sw	   bit (1)		/* ON => user is prepared for errors to imply that previous put_chars failed. */
  2    40 	      )		   unaligned,		/* ON => user wants error tally displayed on closing */
  2    41 	    3 reel_name	   char (32) unal,		/* Tape reel slot ID. */
  2    42 	    3 volume_set_id	   char (32) unal,		/* volume set name */
  2    43 	    3 mount_mode	   char (7),		/* Mount mode: "writing" or "reading". */
  2    44 	    3 tracks	   fixed bin,		/* Either 9 or 7. */
  2    45 	    3 density	   fixed bin,		/* Either 1600 or 800. */
  2    46 	    3 tbpp	   ptr,			/* If not null, ptr to temp seg containing boot program */
  2    47 	    3 blp		   ptr,			/* Ptr to buffer containing boot label record (READ ONLY) */
  2    48 	    3 speed	   bit (36),		/* bits are 75, 125, 200 ips */
  2    49 	    3 comment	   char (64),		/* User comment to operator. */
  2    50 	  2 head		   like mstr_header,	/* Dummy tape record header. */
  2    51 	  2 trail		   like mstr_trailer,	/* Dummy tape record trailer. */
  2    52 	  2 work,					/* Work variables used. */
  2    53 	    3 flags,				/* Flags we need that aren't in head.flags. */
  2    54 	    ( 4 eod	   bit (1),		/* ON => end of good data. */
  2    55 	      4 eof	   bit (1),		/* ON => End of File. */
  2    56 	      4 bot	   bit (1),		/* ON => beginning of tape */
  2    57 	      4 retry_read	   bit (1),		/* ON => try reread recovery */
  2    58 	      4 read_fwd	   bit (1),		/* ON => want to read forward (recovery) */
  2    59                 4 fatal_read_error bit (1),                 /* ON => read error recovery failed. */
  2    60 	      4 data_loss  bit (1)			/* ON => read something, but with evidence that we lost something */
  2    61 	      )		   unaligned,
  2    62 	    3 rcp_id	   bit (36),		/* Id of current tape drive attachment */
  2    63 	    3 tioi_id	   bit (36),		/* Id of current tape_ioi_ activation */
  2    64 	    3 label_uid	   bit (72),		/* Unique ID of label record. */
  2    65 	    3 label_version	   fixed bin,		/* version of label, returned on read */
  2    66 	    3 output_mode	   fixed bin,		/* output mode tape was written with */
  2    67 	    3 buf_pos	   fixed bin,		/* Current position within current bufffer. */
  2    68 	    3 curr_buf	   ptr,			/* Current buffer being processed. */
  2    69 	    3 next_buf	   ptr,			/* Next buffer to be processed. */
  2    70 	    3 rec_length	   fixed bin (21),		/* Length of data record in characters. */
  2    71 	    3 n_full	   fixed bin,		/* Number of buffers ready to write. */
  2    72 	    3 n_recs_to_eof	   fixed bin,		/* Num recs to write pre eof mark. */
  2    73 	    3 n_bufs	   fixed bin,		/* Total number of buffers. */
  2    74 	    3 bufs_per_subset  fixed bin,		/* Number of buffers per subset. */
  2    75 	    3 buf_len	   fixed bin (21),		/* Length of a buffer. */
  2    76 	    3 buffer	   (8) ptr,		/* Pointers to a subset of I/O buffers. */
  2    77 	  2 meters,
  2    78 	    3 fwd_rd_recovery  fixed bin,
  2    79 	    3 reposition_recovery
  2    80 			   fixed bin,
  2    81             2 channels,
  2    82 	    3 rcp              fixed bin(71),		/* Regular, used by rcp. */
  2    83 	    3 ioi		   fixed bin(71),		/* Fast, used by ioi. */
  2    84 	  2 buffer	   (1040) fixed bin (35),	/* Work buffer (currently used for label I/O). */
  2    85 	  2 volume_density     fixed bin,                 /* either the input from -den or the value     */
  2    86 	    
  2    87 						/* returned by rcp_$check_attach in tape_info  */
  2    88             2 volume_format      char (16);		/* determined by rcp_		       */
  2    89 /*	End of include file ... tmdb.incl.pl1	*/
       86 
       87 
  3     1 
  3     2 /* Begin include file ...... mstr.incl.pl1 */
  3     3 /* Modified 2/11/74 by N. I. Morris */
  3     4 /* Modified 12/30/80 by J. A. Bush for bootable tape labels */
  3     5 /* Modified 12/14/82 by J. A. Bush to add version number to the record header */
  3     6 
  3     7 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  3     8 dcl	mstrp		   ptr;			/* pointer to MST record */
  3     9 
  3    10 dcl	1 mstr		   based (mstrp) aligned,	/* Multics standard tape mstr */
  3    11 	  2 head		   like mstr_header,	/* tape record header */
  3    12 	  2 data		   bit (36864 refer (mstr.head.data_bit_len)),
  3    13 						/* record body */
  3    14 	  2 trail		   like mstr_trailer;	/* record trailer */
  3    15 
  3    16 dcl	1 mst_label	   based (mstrp) aligned,	/* bootable label structure */
  3    17 	  2 xfer_vector	   (4),			/* bootload interrupt transfer vector */
  3    18 	    3 lda_instr	   bit (36),		/* this will be a "LDA 4" instruction */
  3    19 	    3 tra_instr	   bit (36),		/* a "TRA" instruction to start of boot pgm */
  3    20 	  2 head		   like mstr_header,	/* standard record header */
  3    21 	  2 vid		   like volume_identifier,	/* tape volume info */
  3    22 	  2 fv_overlay	   (0:31),		/* overlay for fault vectors  when tape booted */
  3    23 	    3 scu_instr	   bit (36),		/* an "SCU" instruction to address of fault_data */
  3    24 	    3 dis_instr	   bit (36),		/* a "DIS" instruction, with Y field = to its own addr */
  3    25 	  2 fault_data	   (8) bit (36),		/* SCU data for unexpected faults goes here */
  3    26 	  2 boot_pgm_path	   char (168) unaligned,	/* path name of boot program */
  3    27 	  2 userid	   char (32) unaligned,	/* Storage for Person.Project.Instance of creator of tape */
  3    28 	  2 label_version	   fixed bin,		/* defined by LABEL_VERSION constant below */
  3    29 	  2 output_mode	   fixed bin,		/* mode in which tape was written with */
  3    30 	  2 boot_pgm_len	   fixed bin,		/* length in words of boot program */
  3    31 	  2 copyright	   char (56),		/* Protection notice goes here if boot pgm is written */
  3    32 	  2 pad		   (13) bit (36),		/* pad out to 192 (300 octal) */
  3    33 	  2 boot_pgm	   (0 refer (mst_label.boot_pgm_len)) bit (36),
  3    34 						/* boot program */
  3    35 	  2 trail		   like mstr_trailer;	/* standard record trailer */
  3    36 
  3    37 dcl	1 mstr_header	   based aligned,		/* Multics standard tape record header */
  3    38 	( 2 c1		   bit (36),		/* constant = 670314355245(8) */
  3    39 	  2 uid		   bit (72),		/* unique ID */
  3    40 	  2 rec_within_file	   fixed bin (17),		/* phys. rec. # within phys. file */
  3    41 	  2 phy_file	   fixed bin (17),		/* phys. file # on phys. tape */
  3    42 	  2 data_bits_used	   fixed bin (17),		/* # of bits of data in record */
  3    43 	  2 data_bit_len	   fixed bin (17),		/* bit length of data space */
  3    44 	  2 flags,				/* record flags */
  3    45 	    3 admin	   bit (1),		/* admin record flag */
  3    46 	    3 label	   bit (1),		/* label record flag */
  3    47 	    3 eor		   bit (1),		/* end-of-reel record flag */
  3    48 	    3 pad1	   bit (11),
  3    49 	    3 set		   bit (1),		/* ON if any of following items set */
  3    50 	    3 repeat	   bit (1),		/* repeated record flag */
  3    51 	    3 padded	   bit (1),		/* record contains padding flag */
  3    52 	    3 eot		   bit (1),		/* EOT reflector encountered flag */
  3    53 	    3 drain	   bit (1),		/* synchronous write flag */
  3    54 	    3 continue	   bit (1),		/* continue on next reel flag */
  3    55 	    3 pad2	   bit (4),
  3    56 	  2 header_version	   fixed bin (3) unsigned,	/* current header version number */
  3    57 	  2 repeat_count	   fixed bin (8),		/* repetition count */
  3    58 	  2 checksum	   bit (36),		/* checksum of header and trailer */
  3    59 	  2 c2		   bit (36)
  3    60 	  )		   unal;			/* constant = 512556146073(8) */
  3    61 
  3    62 dcl	1 mstr_trailer	   based aligned,		/* Multics standard tape record trailer */
  3    63 	( 2 c1		   bit (36),		/* constant = 107463422532(8) */
  3    64 	  2 uid		   bit (72),		/* unique ID (matches header) */
  3    65 	  2 tot_data_bits	   fixed bin (35),		/* total data bits written on logical tape */
  3    66 	  2 pad_pattern	   bit (36),		/* padding pattern */
  3    67 	  2 reel_num	   fixed bin (11),		/* reel sequence # */
  3    68 	  2 tot_file	   fixed bin (23),		/* phys. file number */
  3    69 	  2 tot_rec	   fixed bin (35),		/* phys. record # for logical tape */
  3    70 	  2 c2		   bit (36)
  3    71 	  )		   unal;			/* constant = 265221631704(8) */
  3    72 
  3    73 dcl	1 volume_identifier	   based aligned,		/* tape volume info */
  3    74 	( 2 installation_id	   char (32),		/* installation that created tape */
  3    75 	  2 tape_reel_id	   char (32),		/* tape reel name */
  3    76 	  2 volume_set_id	   char (32)
  3    77 	  )		   unaligned;		/* name of the volume set */
  3    78 
  3    79 dcl	(
  3    80 	header_c1		   init ("670314355245"b3),
  3    81 	header_c2		   init ("512556146073"b3),
  3    82 	trailer_c1	   init ("107463422532"b3),
  3    83 	trailer_c2	   init ("265221631704"b3),
  3    84 	label_c1		   init ("000004235000"b3)
  3    85 	)		   bit (36) static;
  3    86 
  3    87 dcl	LABEL_VERSION	   fixed bin static options (constant) init (3);
  3    88 						/* current label version */
  3    89 dcl	HEADER_VERSION	   fixed bin static options (constant) init (1);
  3    90 						/* current header version */
  3    91 
  3    92 /* End of include file ...... mstr.incl.pl1 */
  3    93 
       88 
       89 
  4     1 /*  START OF:	tape_ioi_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /* Written 22 April 1982 by Chris Jones */
  4     4 /* Modified September 1983 by Chris Jones for reserve_buffer and release_buffer */
  4     5 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  4     6 
  4     7 /* call   tape_ioi_$activate     (rsc_ptr, tioi_info_ptr, tioi_id, code); */
  4     8 dcl	tape_ioi_$activate	   entry (ptr, ptr, bit (36) aligned, fixed bin (35));
  4     9 
  4    10 /* call   tape_ioi_$allocate_buffers (tioi_id, req_length, req_number, act_length, act_number, buffer_ptrs, code); */
  4    11 dcl	tape_ioi_$allocate_buffers
  4    12 			   entry (bit (36) aligned, fixed bin (21), fixed bin, fixed bin (21), fixed bin,
  4    13 			   dim (*) ptr, fixed bin (35));
  4    14 
  4    15 /* call   tape_ioi_$allocate_work_area (tioi_id, req_size, act_size, work_area_ptr, code); */
  4    16 dcl	tape_ioi_$allocate_work_area
  4    17 			   entry (bit (36) aligned, fixed bin (19), fixed bin (19), ptr, fixed bin (35));
  4    18 
  4    19 /* call   tape_ioi_$buffer_status (tioi_id, buffer_ptr, tbs_ptr, code); */
  4    20 dcl	tape_ioi_$buffer_status
  4    21 			   entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  4    22 
  4    23 /* call   tape_ioi_$check_order  (tioi_id, ocount, rx, code); */
  4    24 dcl	tape_ioi_$check_order  entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
  4    25 
  4    26 /* call   tape_ioi_$check_read   (tioi_id, buffer_ptr, data_len, rx, code); */
  4    27 dcl	tape_ioi_$check_read   entry (bit (36) aligned, ptr, fixed bin (21), fixed bin, fixed bin (35));
  4    28 
  4    29 /* call   tape_ioi_$check_write  (tioi_id, buffer_ptr, rx, code); */
  4    30 dcl	tape_ioi_$check_write  entry (bit (36) aligned, ptr, fixed bin, fixed bin (35));
  4    31 
  4    32 /* call   tape_ioi_$deactivate   (tioi_id, error_ptr, code); */
  4    33 dcl	tape_ioi_$deactivate   entry (bit (36) aligned, ptr, fixed bin (35));
  4    34 
  4    35 /* call   tape_ioi_$deallocate   (tioi_id, code); */
  4    36 dcl	tape_ioi_$deallocate   entry (bit (36) aligned, fixed bin (35));
  4    37 
  4    38 /* call   tape_ioi_$deallocate_buffers   (tioi_id, code); */
  4    39 dcl	tape_ioi_$deallocate_buffers
  4    40 			   entry (bit (36) aligned, fixed bin (35));
  4    41 
  4    42 /* call   tape_ioi_$get_mode     (tioi_id, mode, data_ptr, code); */
  4    43 dcl	tape_ioi_$get_mode	   entry (bit (36) aligned, char (*), ptr, fixed bin (35));
  4    44 
  4    45 /* call	tape_ioi_$get_statistics (tioi_id, tec_ptr, code); */
  4    46 dcl	tape_ioi_$get_statistics
  4    47 			   entry (bit (36) aligned, ptr, fixed bin (35));
  4    48 
  4    49 /* call   tape_ioi_$hardware_status (tioi_id, ths_ptr, code); */
  4    50 dcl	tape_ioi_$hardware_status
  4    51 			   entry (bit (36) aligned, ptr, fixed bin (35));
  4    52 
  4    53 /* call   tape_ioi_$list_buffers (tioi_id, state, buffer_ptrs, num_buffers, code); */
  4    54 dcl	tape_ioi_$list_buffers entry (bit (36) aligned, fixed bin, dim (*) ptr, fixed bin, fixed bin (35));
  4    55 
  4    56 /* call   tape_ioi_$order        (tioi_id, order, count, data_ptr, ocount, rx, code); */
  4    57 dcl	tape_ioi_$order	   entry (bit (36) aligned, char (4), fixed bin, ptr, fixed bin, fixed bin, fixed bin (35));
  4    58 
  4    59 /* call   tape_ioi_$queue_order  (tioi_id, order, count, data_ptr, code); */
  4    60 dcl	tape_ioi_$queue_order  entry (bit (36) aligned, char (4), fixed bin, ptr, fixed bin (35));
  4    61 
  4    62 /* call   tape_ioi_$queue_read   (tioi_id, buffer_ptr, code); */
  4    63 dcl	tape_ioi_$queue_read   entry (bit (36) aligned, ptr, fixed bin (35));
  4    64 
  4    65 /* call   tape_ioi_$queue_write  (tioi_id, buffer_ptr, data_len, code); */
  4    66 dcl	tape_ioi_$queue_write  entry (bit (36) aligned, ptr, fixed bin (21), fixed bin (35));
  4    67 
  4    68 /* call   tape_ioi_$read         (tioi_id, buffer_ptr, data_len, rx, code); */
  4    69 dcl	tape_ioi_$read	   entry (bit (36) aligned, ptr, fixed bin (21), fixed bin, fixed bin (35));
  4    70 
  4    71 /* call	tape_ioi_$release_buffer (tioi_id, buffer_ptr, code); */
  4    72 dcl	tape_ioi_$release_buffer
  4    73 			   entry (bit (36) aligned, ptr, fixed bin (35));
  4    74 
  4    75 /* call	tape_ioi_$reserve_buffer (tioi_id, buffer_ptr, code); */
  4    76 dcl	tape_ioi_$reserve_buffer
  4    77 			   entry (bit (36) aligned, ptr, fixed bin (35));
  4    78 
  4    79 /* call	tape_ioi_$reset_statistics (tioi_id, code); */
  4    80 dcl	tape_ioi_$reset_statistics
  4    81 			   entry (bit (36) aligned, fixed bin (35));
  4    82 
  4    83 /* call   tape_ioi_$set_buffer_ready (tioi_id, buffer_ptr, code); */
  4    84 dcl	tape_ioi_$set_buffer_ready
  4    85 			   entry (bit (36) aligned, ptr, fixed bin (35));
  4    86 
  4    87 /* call   tape_ioi_$set_mode     (tioi_id, mode, data_ptr, code); */
  4    88 dcl	tape_ioi_$set_mode	   entry (bit (36) aligned, char (*), ptr, fixed bin (35));
  4    89 
  4    90 /* call   tape_ioi_$stop_tape    (tioi_id, count, rx, code); */
  4    91 dcl	tape_ioi_$stop_tape	   entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
  4    92 
  4    93 /* call   tape_ioi_$write        (tioi_id, write_buffer_ptrs, data_len, buffer_ptr, rx, code); */
  4    94 dcl	tape_ioi_$write	   entry (bit (36) aligned, (*) ptr, fixed bin (21), ptr, fixed bin, fixed bin (35));
  4    95 
  4    96 /*  END OF:	tape_ioi_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       90 
       91 
  5     1 /*  START OF:	tape_ioi_error_counts.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 /* Written 22 April 1982 by Chris Jones */
  5     3 
  5     4 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  5     5 dcl	tape_ioi_error_counts_ptr
  5     6 			   ptr;
  5     7 
  5     8 dcl	1 tec		   based (tape_ioi_error_counts_ptr) aligned,
  5     9 	  2 version	   char (8),
  5    10 	  2 reads		   like tec_entry,
  5    11 	  2 successful_retry_strategy
  5    12 			   (7) fixed bin (35),
  5    13 	  2 writes	   like tec_entry,
  5    14 	  2 orders	   like tec_entry;
  5    15 
  5    16 dcl	1 tec_entry	   based aligned,
  5    17 	  2 total		   fixed bin (35),
  5    18 	  2 errors	   fixed bin (35);
  5    19 
  5    20 dcl	TEC_VERSION_1	   char (8) aligned internal static options (constant) init ("TECV001");
  5    21 
  5    22 dcl	TEC_VERSION	   char (8) aligned internal static options (constant) init ("TECV001");
  5    23 
  5    24 /*  END OF:	tape_ioi_error_counts.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       92 
       93 
       94 close:
       95      entry (arg_iocb_ptr, arg_error_code);
       96 
       97 	iocb_ptr = arg_iocb_ptr;			/* Copy argument. */
       98 
       99 	iocb_ptr = iocb_ptr -> iocb.actual_iocb_ptr;	/* Initialize pointers. */
      100 	tmdb_ptr = iocb_ptr -> iocb.attach_data_ptr;
      101 	tioi_id = tmdb.tioi_id;
      102 	error_code = 0;
      103 
      104 	if tmdb.open.description = "stream_input" then do;
      105 	     call STOP_TAPE (error_code);
      106 	     if error_code ^= 0 then
      107 		go to REWIND;
      108 	     if tmdb.opt.flags.err_tal		/* user wants error recovery tally */
      109 	     then do;
      110 		auto_error_tally.version = TEC_VERSION_1;
      111 		call tape_ioi_$get_statistics (tioi_id, addr (auto_error_tally), error_code);
      112 		if error_code ^= 0 then
      113 		     call ioa_ ("Unable to get error statistics for tape volume ^a", tmdb.opt.reel_name);
      114 		else do;
      115 		     call ioa_ ("^/Error statistics for tape volume ^a:^/", tmdb.opt.reel_name);
      116 		     call ioa_ ("Total tape errors:^-^d", auto_error_tally.reads.errors);
      117 		     put_hdr = "0"b;
      118 		     do i = 1 to hbound (auto_error_tally.successful_retry_strategy, 1);
      119 			if auto_error_tally.successful_retry_strategy (i) ^= 0 then do;
      120 			     if ^put_hdr then do;
      121 				put_hdr = "1"b;
      122 				call ioa_ ("Successful error recovery by backspace/re-read record:^/");
      123 			     end;
      124 			     call ioa_ ("With ^2d retries:^-^d", i, auto_error_tally.successful_retry_strategy (i));
      125 			end;
      126 		     end;
      127 		     if tmdb.meters.fwd_rd_recovery ^= 0 then do;
      128 			call ioa_ ("Successful error recovery by reading re-written record:");
      129 			call ioa_ ("^2-^d", tmdb.meters.fwd_rd_recovery);
      130 		     end;
      131 		     if tmdb.meters.reposition_recovery ^= 0 then do;
      132 			call ioa_ ("Successful error recovery by repositioning and re-reading:");
      133 			call ioa_ ("^2-^d", tmdb.meters.reposition_recovery);
      134 		     end;
      135 		end;
      136 	     end;
      137 	     goto REWIND;				/* If reading nothing to do to close. */
      138 	end;
      139 
      140 	call tape_mult_write_$flush (tmdb_ptr, error_code);
      141 						/* Ignore error, just try to close. */
      142 
      143 	call FIX_HEADER_AND_TRAILER (error_code);
      144 	if error_code ^= 0 then
      145 	     go to REWIND;
      146 
      147 	if tmdb.head.rec_within_file ^= -1		/* If we haven't just written an EOF. */
      148 	then do;
      149 	     call tape_mult_write_$eof (tmdb_ptr, error_code);
      150 	     if ^(error_code = 0 | error_code = error_table_$device_end) then
      151 		goto REWIND;
      152 	end;
      153 
      154 	if tmdb.head.flags.eot			/* Are we at the End of Tape? */
      155 	then eot_flag = "1"b;
      156 	else eot_flag = "0"b;
      157 
      158 	string (tmdb.head.flags) = "0"b;		/* Turn OFF all flags. */
      159 
      160 	tmdb.head.flags.set, tmdb.head.flags.eot = eot_flag;
      161 						/* Set EOT flag if appropriate. */
      162 	tmdb.head.flags.admin, tmdb.head.flags.eor = "1"b;/* Turn ON  End of Reel  flag. */
      163 	call tape_mult_write_$record (tmdb_ptr, addr (pad_char), 1, error_code);
      164 	if ^(error_code = 0 | error_code = error_table_$device_end) then
      165 	     goto REWIND;
      166 
      167 	do i = 1 to 2;				/* Write two EOF records at end of tape. */
      168 	     call tape_mult_write_$eof (tmdb_ptr, error_code);
      169 	     if ^(error_code = 0 | error_code = error_table_$device_end) then
      170 		goto REWIND;
      171 	end;
      172 
      173 	error_code = 0;				/* Getting this far => no error. */
      174 
      175 REWIND:						/* A closed tape reel should be rewound. */
      176 	string (tmdb.head.flags) = "0"b;		/* Make sure all flags are OFF. */
      177 
      178 	if error_code ^= 0 then
      179 	     call STOP_TAPE ((0));
      180 
      181 	call tape_ioi_$deallocate_buffers (tioi_id, save_code);
      182 	if error_code = 0 then
      183 	     error_code = save_code;
      184 	call tape_ioi_$order (tioi_id, "rew", 1, (null), (0), (0), save_code);
      185 						/* issue rewind order, but don't bother to wait. */
      186 	if error_code = 0				/* Use first error_code. */
      187 	then error_code = save_code;
      188 
      189 /*	Now we must fill in the I/O control block to indicate that it is closed.
      190**/
      191 	iocb_ptr -> iocb.open_descrip_ptr = null ();
      192 	iocb_ptr -> iocb.detach_iocb = tape_mult_detach_$detach;
      193 	iocb_ptr -> iocb.open = tape_mult_open_$open;
      194 	iocb_ptr -> iocb.close, iocb_ptr -> iocb.put_chars, iocb_ptr -> iocb.get_chars = iox_$err_not_open;
      195 
      196 	call iox_$propagate (iocb_ptr);		/* Propagate changes to the I/O control block. */
      197 
      198 	arg_error_code = error_code;			/* Return our error code. */
      199 
      200 
      201 STOP_TAPE:
      202      proc (code);
      203 
      204 dcl	code		   fixed bin (35);
      205 
      206 	code = 0;
      207 
      208 	call tape_ioi_$stop_tape (tioi_id, (0), rx, code);
      209 	if rx ^= 0 then do;
      210 	     if code = 0 then
      211 		code = error_table_$device_parity;
      212 	end;
      213 
      214      end STOP_TAPE;
      215 
      216 /* This procedure is used to find the last good buffer written after a
      217*   write error occured in the last subset.  We must do this because counters
      218*   in the eor record must be in line with those of the last good record written. */
      219 
      220 FIX_HEADER_AND_TRAILER:
      221      proc (error_code);
      222 
      223 dcl	error_code	   fixed bin (35);
      224 dcl	n_ready_buffers	   fixed bin;
      225 dcl	READY_BUFS	   fixed bin init (1);
      226 dcl	ready_buffers	   (tmdb.work.n_bufs) ptr;
      227 dcl	rx		   fixed bin;
      228 
      229 	error_code = 0;
      230 
      231 	call tape_mult_util_$wait_for_write (tioi_id, rx, error_code);
      232 	if rx ^= 0 then do;
      233 	     if error_code = 0 then
      234 		error_code = error_table_$device_parity;
      235 	     return;
      236 	end;
      237 
      238 	call tape_ioi_$list_buffers (tioi_id, READY_BUFS, ready_buffers, n_ready_buffers, error_code);
      239 	if error_code ^= 0 then
      240 	     return;
      241 
      242 	if n_ready_buffers = 0 then
      243 	     return;
      244 
      245 	mstrp = ready_buffers (n_ready_buffers);
      246 
      247 	if mstr.trail.tot_rec = tmdb.trail.tot_rec then
      248 	     return;				/* We are ok. */
      249 
      250 /* We are not ok, counts must be reset so that they are consistent.
      251*   This is because some error occured that caused us to abort writing. */
      252 
      253 	tmdb.head = mstr.head;
      254 	tmdb.trail = mstr.trail;
      255 
      256 	tmdb.work.buf_pos, tmdb.work.n_full = 0;
      257 
      258 	call STOP_TAPE (error_code);
      259 
      260      end FIX_HEADER_AND_TRAILER;
      261 
      262      end tape_mult_close_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0812.6  tape_mult_close_.pl1              >spec>install>1112>tape_mult_close_.pl1
84           1    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
86           2    10/21/86  1251.7  tmdb.incl.pl1                     >ldd>include>tmdb.incl.pl1
88           3    12/20/82  1113.8  mstr.incl.pl1                     >ldd>include>mstr.incl.pl1
90           4    09/16/83  1110.4  tape_ioi_dcls.incl.pl1            >ldd>include>tape_ioi_dcls.incl.pl1
92           5    12/01/82  1039.8  tape_ioi_error_counts.incl.pl1    >ldd>include>tape_ioi_error_counts.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
READY_BUFS                      000101 automatic       fixed bin(17,0)          initial dcl 225 set ref 225* 238*
TEC_VERSION_1                   000000 constant        char(8)                  initial dcl 5-20 ref 110
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-6 ref 99
addr                                                   builtin function         dcl 63 ref 111 111 163 163
admin                   112            based           bit(1)                   level 4 packed packed unaligned dcl 2-24 set ref
                                                                                  162*
arg_error_code                         parameter       fixed bin(35,0)          dcl 41 set ref 94 198*
arg_iocb_ptr                           parameter       pointer                  dcl 41 ref 94 97
attach_data_ptr          16            based           pointer                  level 2 dcl 1-6 ref 100
auto_error_tally                000112 automatic       structure                level 1 dcl 56 set ref 111 111
buf_pos                 135            based           fixed bin(17,0)          level 3 dcl 2-24 set ref 256*
close                    36            based           entry variable           level 2 dcl 1-6 set ref 194*
code                                   parameter       fixed bin(35,0)          dcl 204 set ref 201 206* 208* 210 210*
data_bit_len              4(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-10 ref 247 254
description              22            based           char(32)                 level 3 dcl 2-24 ref 104
detach_iocb              26            based           entry variable           level 2 dcl 1-6 set ref 192*
eor                     112(02)        based           bit(1)                   level 4 packed packed unaligned dcl 2-24 set ref
                                                                                  162*
eot                     112(17)        based           bit(1)                   level 4 packed packed unaligned dcl 2-24 set ref 154
                                                                                  160*
eot_flag                        000100 automatic       bit(1)                   packed unaligned dcl 47 set ref 154* 156* 160
err_tal                  32(03)        based           bit(1)                   level 4 packed packed unaligned dcl 2-24 ref 108
error_code                             parameter       fixed bin(35,0)          dcl 223 in procedure "FIX_HEADER_AND_TRAILER" set
                                                                                  ref 220 229* 231* 233 233* 238* 239 258*
error_code                      000101 automatic       fixed bin(35,0)          dcl 47 in procedure "tape_mult_close_" set ref 102*
                                                                                  105* 106 111* 112 140* 143* 144 149* 150 150 163*
                                                                                  164 164 168* 169 169 173* 178 182 182* 186 186*
                                                                                  198
error_table_$device_end         000012 external static fixed bin(35,0)          dcl 66 ref 150 164 169
error_table_$device_parity      000014 external static fixed bin(35,0)          dcl 68 ref 210 233
errors                    3     000112 automatic       fixed bin(35,0)          level 3 dcl 56 set ref 116*
flags                    32            based           structure                level 3 in structure "tmdb" dcl 2-24 in procedure
                                                                                  "tape_mult_close_"
flags                   112            based           structure                level 3 in structure "tmdb" packed packed unaligned
                                                                                  dcl 2-24 in procedure "tape_mult_close_" set ref
                                                                                  158* 175*
fwd_rd_recovery         170            based           fixed bin(17,0)          level 3 dcl 2-24 set ref 127 129*
get_chars                46            based           entry variable           level 2 dcl 1-6 set ref 194*
hbound                                                 builtin function         dcl 63 ref 118
head                    105            based           structure                level 2 in structure "tmdb" dcl 2-24 in procedure
                                                                                  "tape_mult_close_" set ref 253*
head                                   based           structure                level 2 in structure "mstr" dcl 3-10 in procedure
                                                                                  "tape_mult_close_" ref 253
i                               000102 automatic       fixed bin(17,0)          dcl 47 set ref 118* 119 124* 124* 167*
ioa_                            000022 constant        entry                    external dcl 71 ref 112 115 116 122 124 128 129 132
                                                                                  133
iocb                                   based           structure                level 1 dcl 1-6
iocb_ptr                        000104 automatic       pointer                  dcl 47 set ref 97* 99* 99 100 191 192 193 194 194
                                                                                  194 196*
iox_$err_not_open               000016 constant        entry                    external dcl 71 ref 194
iox_$propagate                  000020 constant        entry                    external dcl 71 ref 196
meters                  170            based           structure                level 2 dcl 2-24
mstr                                   based           structure                level 1 dcl 3-10
mstr_header                            based           structure                level 1 dcl 3-37
mstr_trailer                           based           structure                level 1 dcl 3-62
mstrp                           000134 automatic       pointer                  dcl 3-8 set ref 245* 247 253 254
n_bufs                  145            based           fixed bin(17,0)          level 3 dcl 2-24 ref 226
n_full                  143            based           fixed bin(17,0)          level 3 dcl 2-24 set ref 256*
n_ready_buffers                 000100 automatic       fixed bin(17,0)          dcl 224 set ref 238* 242 245
null                                                   builtin function         dcl 63 ref 184 191
open                     21            based           structure                level 2 in structure "tmdb" dcl 2-24 in procedure
                                                                                  "tape_mult_close_"
open                     32            based           entry variable           level 2 in structure "iocb" dcl 1-6 in procedure
                                                                                  "tape_mult_close_" set ref 193*
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-6 set ref 191*
opt                      32            based           structure                level 2 dcl 2-24
pad_char                        000010 internal static bit(9)                   initial dcl 60 set ref 163 163
put_chars                52            based           entry variable           level 2 dcl 1-6 set ref 194*
put_hdr                         000106 automatic       bit(1)                   dcl 47 set ref 117* 120 121*
reads                     2     000112 automatic       structure                level 2 dcl 56
ready_buffers                   000102 automatic       pointer                  array dcl 226 set ref 238* 245
rec_within_file         110            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 2-24 set ref 147
reel_name                33            based           char(32)                 level 3 packed packed unaligned dcl 2-24 set ref
                                                                                  112* 115*
reposition_recovery     171            based           fixed bin(17,0)          level 3 dcl 2-24 set ref 131 133*
rx                              000107 automatic       fixed bin(17,0)          dcl 47 in procedure "tape_mult_close_" set ref 208*
                                                                                  209
rx                              000102 automatic       fixed bin(17,0)          dcl 227 in procedure "FIX_HEADER_AND_TRAILER" set
                                                                                  ref 231* 232
save_code                       000110 automatic       fixed bin(35,0)          dcl 47 set ref 181* 182 184* 186
set                     112(14)        based           bit(1)                   level 4 packed packed unaligned dcl 2-24 set ref
                                                                                  160*
string                                                 builtin function         dcl 63 set ref 158* 175*
successful_retry_strategy
                          4     000112 automatic       fixed bin(35,0)          array level 2 dcl 56 set ref 118 119 124*
tape_ioi_$deallocate_buffers    000040 constant        entry                    external dcl 4-39 ref 181
tape_ioi_$get_statistics        000042 constant        entry                    external dcl 4-46 ref 111
tape_ioi_$list_buffers          000044 constant        entry                    external dcl 4-54 ref 238
tape_ioi_$order                 000046 constant        entry                    external dcl 4-57 ref 184
tape_ioi_$stop_tape             000050 constant        entry                    external dcl 4-91 ref 208
tape_mult_detach_$detach        000024 constant        entry                    external dcl 71 ref 192
tape_mult_open_$open            000026 constant        entry                    external dcl 71 ref 193
tape_mult_util_$wait_for_write  000030 constant        entry                    external dcl 71 ref 231
tape_mult_write_$eof            000034 constant        entry                    external dcl 71 ref 149 168
tape_mult_write_$flush          000032 constant        entry                    external dcl 71 ref 140
tape_mult_write_$record         000036 constant        entry                    external dcl 71 ref 163
tec                                    based           structure                level 1 dcl 5-8
tec_entry                              based           structure                level 1 dcl 5-16
tioi_id                         000111 automatic       bit(36)                  dcl 47 in procedure "tape_mult_close_" set ref 101*
                                                                                  111* 181* 184* 208* 231* 238*
tioi_id                 130            based           bit(36)                  level 3 in structure "tmdb" dcl 2-24 in procedure
                                                                                  "tape_mult_close_" ref 101
tmdb                                   based           structure                level 1 dcl 2-24
tmdb_ptr                        000132 automatic       pointer                  dcl 2-22 set ref 100* 101 104 108 112 115 127 129
                                                                                  131 133 140* 147 149* 154 158 160 160 162 162 163*
                                                                                  168* 175 226 247 253 254 256 256
tot_rec                                based           fixed bin(35,0)          level 3 in structure "mstr" packed packed unaligned
                                                                                  dcl 3-10 in procedure "tape_mult_close_" ref 247
tot_rec                 123            based           fixed bin(35,0)          level 3 in structure "tmdb" packed packed unaligned
                                                                                  dcl 2-24 in procedure "tape_mult_close_" set ref
                                                                                  247
trail                                  based           structure                level 2 in structure "mstr" dcl 3-10 in procedure
                                                                                  "tape_mult_close_" ref 254
trail                   115            based           structure                level 2 in structure "tmdb" dcl 2-24 in procedure
                                                                                  "tape_mult_close_" set ref 254*
version                         000112 automatic       char(8)                  level 2 dcl 56 set ref 110*
volume_identifier                      based           structure                level 1 dcl 3-73
work                    126            based           structure                level 2 dcl 2-24

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HEADER_VERSION                         internal static fixed bin(17,0)          initial dcl 3-89
LABEL_VERSION                          internal static fixed bin(17,0)          initial dcl 3-87
TEC_VERSION                            internal static char(8)                  initial dcl 5-22
header_c1                              internal static bit(36)                  initial packed unaligned dcl 3-79
header_c2                              internal static bit(36)                  initial packed unaligned dcl 3-79
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-51
label_c1                               internal static bit(36)                  initial packed unaligned dcl 3-79
mst_label                              based           structure                level 1 dcl 3-16
tape_ioi_$activate              000000 constant        entry                    external dcl 4-8
tape_ioi_$allocate_buffers      000000 constant        entry                    external dcl 4-11
tape_ioi_$allocate_work_area    000000 constant        entry                    external dcl 4-16
tape_ioi_$buffer_status         000000 constant        entry                    external dcl 4-20
tape_ioi_$check_order           000000 constant        entry                    external dcl 4-24
tape_ioi_$check_read            000000 constant        entry                    external dcl 4-27
tape_ioi_$check_write           000000 constant        entry                    external dcl 4-30
tape_ioi_$deactivate            000000 constant        entry                    external dcl 4-33
tape_ioi_$deallocate            000000 constant        entry                    external dcl 4-36
tape_ioi_$get_mode              000000 constant        entry                    external dcl 4-43
tape_ioi_$hardware_status       000000 constant        entry                    external dcl 4-50
tape_ioi_$queue_order           000000 constant        entry                    external dcl 4-60
tape_ioi_$queue_read            000000 constant        entry                    external dcl 4-63
tape_ioi_$queue_write           000000 constant        entry                    external dcl 4-66
tape_ioi_$read                  000000 constant        entry                    external dcl 4-69
tape_ioi_$release_buffer        000000 constant        entry                    external dcl 4-72
tape_ioi_$reserve_buffer        000000 constant        entry                    external dcl 4-76
tape_ioi_$reset_statistics      000000 constant        entry                    external dcl 4-80
tape_ioi_$set_buffer_ready      000000 constant        entry                    external dcl 4-84
tape_ioi_$set_mode              000000 constant        entry                    external dcl 4-88
tape_ioi_$write                 000000 constant        entry                    external dcl 4-94
tape_ioi_error_counts_ptr              automatic       pointer                  dcl 5-5
trailer_c1                             internal static bit(36)                  initial packed unaligned dcl 3-79
trailer_c2                             internal static bit(36)                  initial packed unaligned dcl 3-79

NAMES DECLARED BY EXPLICIT CONTEXT.
FIX_HEADER_AND_TRAILER          001053 constant        entry                    internal dcl 220 ref 143
REWIND                          000656 constant        label                    dcl 175 ref 106 137 144 150 164 169
STOP_TAPE                       001013 constant        entry                    internal dcl 201 ref 105 178 258
close                           000162 constant        entry                    external dcl 94
tape_mult_close_                000150 constant        entry                    external dcl 14

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1500        1552    1233        1510
Length      2054    1233        52         266     244           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_mult_close_                    182 external procedure  is an external procedure.  
STOP_TAPE                            76 internal procedure  is called by several nonquick procedures.  
FIX_HEADER_AND_TRAILER              107 internal procedure  uses auto adjustable storage.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 pad_char                    tape_mult_close_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
FIX_HEADER_AND_TRAILER   000100 n_ready_buffers             FIX_HEADER_AND_TRAILER
                         000101 READY_BUFS                  FIX_HEADER_AND_TRAILER
                         000102 ready_buffers               FIX_HEADER_AND_TRAILER
                         000102 rx                          FIX_HEADER_AND_TRAILER
tape_mult_close_         000100 eot_flag                    tape_mult_close_
                         000101 error_code                  tape_mult_close_
                         000102 i                           tape_mult_close_
                         000104 iocb_ptr                    tape_mult_close_
                         000106 put_hdr                     tape_mult_close_
                         000107 rx                          tape_mult_close_
                         000110 save_code                   tape_mult_close_
                         000111 tioi_id                     tape_mult_close_
                         000112 auto_error_tally            tape_mult_close_
                         000132 tmdb_ptr                    tape_mult_close_
                         000134 mstrp                       tape_mult_close_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          alloc_auto_adj
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          iox_$err_not_open             iox_$propagate                tape_ioi_$deallocate_buffers
tape_ioi_$get_statistics      tape_ioi_$list_buffers        tape_ioi_$order               tape_ioi_$stop_tape
tape_mult_detach_$detach      tape_mult_open_$open          tape_mult_util_$wait_for_write
tape_mult_write_$eof          tape_mult_write_$flush        tape_mult_write_$record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$device_end       error_table_$device_parity




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000147        94 000155        97 000167        99 000173       100 000175       101 000177       102 000201
    104 000202       105 000206       106 000214       108 000216       110 000222       111 000224       112 000241
    115 000265       116 000306       117 000326       118 000327       119 000335       120 000337       121 000341
    122 000343       124 000357       126 000404       127 000406       128 000411       129 000425       131 000445
    132 000450       133 000464       137 000504       140 000505       143 000515       144 000523       147 000525
    149 000532       150 000543       154 000550       156 000557       158 000560       160 000562       162 000575
    163 000601       164 000622       167 000627       168 000635       169 000646       171 000653       173 000655
    175 000656       178 000661       181 000672       182 000703       184 000707       186 000742       191 000746
    192 000751       193 000756       194 000761       196 001000       198 001006       262 001011       201 001012
    206 001020       208 001022       209 001040       210 001043       214 001051       220 001052       225 001060
    226 001062       238 001072       229 001102       231 001104       232 001116       233 001120       235 001126
    238 001127       239 001161       242 001164       245 001166       247 001173       253 001205       254 001210
    256 001215       258 001217       260 001226


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
