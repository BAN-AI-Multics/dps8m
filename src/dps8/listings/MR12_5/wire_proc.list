	COMPILATION LISTING OF SEGMENT wire_proc
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1026.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 wire_proc: proc (wireptr, code);
       13 
       14 /* This procedure is used to temporarily wire down a hardcore procedure and its linkage
       15*   section.  It is assumed that ALL such wiring/unwiring is done by calls to this
       16*   procedure.   A data base in the SST header is used to prevent conflicts between different
       17*   processes wiring/unwiring tha same segment, and between calls for procedures contained
       18*   in the same bound segment.  Linkage segments may be in a combined linkage
       19*   segment.  It is assumed that no procedure or linkage has segment number of zero.
       20*
       21*   Coded September 1970 by Roger R. Schell
       22*   09/10/72, RB Snyder for follow-on
       23*   09/18/74, SH Webber to repair locking problems.
       24*   08/03/76, N. I. Morris to fix bug referencing linkage header
       25*   04/06/81, W. Olin Sibert, for ADP conversion, stacq builtin
       26*   10/12/83, Keith Loepere, for paged unpaged segments.
       27*   */
       28 
       29 	dcl     wireptr		 ptr parameter;	/* pointer to the procedure to be wired */
       30 	dcl     code		 fixed bin (35) parameter; /* an error code that is returned to caller */
       31 
       32 	dcl     linkno		 fixed bin (18);	/* segment number of linkage */
       33 	dcl     linkoff		 fixed bin (18);	/* offset of our linkage */
       34 	dcl     segno		 fixed bin (18);	/* segment number of procedure */
       35 	dcl     tseg		 fixed bin (18);	/* segment number temporary */
       36 
       37 	dcl     sdwp		 pointer;		/* Must declare here, 'cause include file can't */
       38 	dcl     callptr		 pointer;		/* pointer into calling procedure */
       39 	dcl     freep		 pointer;		/* pointer to a free entry */
       40 	dcl     ip		 pointer;		/* pointer to entry of current index */
       41 	dcl     linkptr		 pointer;		/* pointer to start of linkage */
       42 
       43 	dcl     fp		 fixed bin;	/* first page being wired */
       44 	dcl     freei		 fixed bin;	/* index of a free entry */
       45 	dcl     i			 fixed bin;	/* loop index */
       46 	dcl     lp		 fixed bin;	/* last page being wired */
       47 	dcl     np		 fixed bin;	/* number of pages being wired */
       48 	dcl     size		 fixed bin;	/* size of array of entries */
       49 	dcl     temp_fp		 fixed bin;	/* temporary */
       50 	dcl     temp_lp		 fixed bin;	/* temporary */
       51 	dcl     increment		 fixed bin;	/* incrementing value for count of wiring */
       52 
       53 	dcl     wire_call		 bit (1) aligned;	/* flag on if this was a call to wire */
       54 	dcl     repeated_call	 bit (1) aligned;	/* on if are other outstanding calls */
       55 	dcl     locked		 bit (1) aligned;	/* flag used during locking process */
       56 
       57 	dcl     pds$process_id	 bit (36) aligned external static; /* id for locking */
       58 	dcl     dseg$		 (0:1023) fixed bin (71) aligned external static;
       59 	dcl     unpaged_page_tables$	 external;
       60 
       61 	dcl     sys_info$system_type	 fixed bin external static;
       62 	dcl     sst$wire_proc_data	 bit (36) aligned external static;
       63 	dcl     sst$temp_w_event	 bit (36) aligned external static;
       64 
       65 	dcl     1 lot$		 aligned like lot external static;
       66 
       67 	dcl     error_table_$nolinkag	 fixed bin (35) external static; /* error code for no entry in lot */
       68 
       69 	dcl     pxss$wait		 entry;
       70 	dcl     pxss$addevent	 entry (bit (36) aligned);
       71 	dcl     pxss$delevent	 entry (bit (36) aligned);
       72 	dcl     pxss$notify		 entry (bit (36) aligned);
       73 	dcl     get_ptrs_$given_segno	 entry (fixed bin (18)) returns (ptr); /* gets astep for a segment number */
       74 	dcl     pc_wired$wire_wait	 entry (ptr, fixed bin, fixed bin); /* to read into core and wire pages */
       75 	dcl     pc_wired$unwire	 entry (ptr, fixed bin, fixed bin); /* unwire pages */
       76 	dcl     syserr		 entry options (variable); /* prints error message and crashes system */
       77 	dcl     wired_utility_$caller	 entry () returns (ptr); /* procedure to get pointer to our caller */
       78 
       79 	dcl     (addr, baseptr, bin, divide, hbound, max, null, ptr, stac, stacq) builtin;
       80 
       81 /*  */
       82 
       83 	wire_call = "1"b;				/* primary entry is a call to wire */
       84 	increment = 1;				/* add to count for wire call */
       85 	goto join_not_me;
       86 
       87 
       88 wire_proc$unwire_proc: entry (wireptr, code);		/* entry to unwire specified procedure */
       89 
       90 	wire_call = "0"b;				/* Unwiring. */
       91 	increment = -1;				/* Decrement counts */
       92 
       93 join_not_me:
       94 	code = 0;					/* initialize error code to no error */
       95 	callptr = wireptr;				/* copy argument */
       96 	go to join;				/* join common code */
       97 
       98 
       99 wire_proc$wire_me: entry ();				/* entry to wire the caller */
      100 
      101 	wire_call = "1"b;				/* primary entry is a call to wire */
      102 	increment = 1;				/* when wiring we add 1 to counts */
      103 	goto join_me;
      104 
      105 
      106 wire_proc$unwire_me: entry ();			/* entry to unwire the caller */
      107 
      108 	wire_call = "0"b;				/* Unwiring. */
      109 	increment = -1;				/* Decrement counts */
      110 
      111 join_me:	callptr = wired_utility_$caller ();		/* get pointer to our caller */
      112 						/* and fall through to common code */
      113 
      114 join:	wpdp = addr (sst$wire_proc_data);		/* get pointer to data for wire_proc */
      115 	upt_ptr = addr (unpaged_page_tables$);
      116 
      117 	segno = bin (baseno (callptr), 18);		/* get caller's segment number */
      118 
      119 	locked = stac (addr (wpd.temp_w_lock), pds$process_id); /* try to lock */
      120 	do while (^locked);
      121 	     call pxss$addevent (sst$temp_w_event);	/* tell TC event to wait on */
      122 	     locked = stac (addr (wpd.temp_w_lock), pds$process_id); /* try to lock again */
      123 	     if ^locked then call pxss$wait;		/* still locked, wait for it */
      124 	     else call pxss$delevent (sst$temp_w_event);	/* locked, clean un unnecessary addevent */
      125 	end;
      126 	size = wpd.temp_w_max;			/* find how far we must search for a match */
      127 	repeated_call = "0"b;			/* initialize */
      128 	freei = hbound (wpd.temp_w, 1) + 1;		/* initialize to null value -- max of 7 entries */
      129 	twep = null;				/* initialize */
      130 	do i = size + 1 to 1 by -1;			/* search for the entry we will use */
      131 	     ip = addr (wpd.temp_w (i));		/* get pointer to current entry */
      132 	     tseg = bin (ip -> twe.segno, 18);		/* find who owns this entry */
      133 	     if tseg = segno			/* is it us? */
      134 	     then do;
      135 		     twep = ip;			/* remember that this is our entry */
      136 		     if wire_call			/* check if wire/unwire call */
      137 		     then repeated_call = "1"b;	/* this is repeated call to wire */
      138 		     else if bin (twe.count, 18) ^= 1	/* for unwire, check number of calls outstanding */
      139 		     then repeated_call = "1"b;	/* there are other outstanding calls */
      140 		end;
      141 	     if tseg = 0				/* check for free entry */
      142 	     then do;				/* rememper the free entry */
      143 		     freep = ip;			/* remember the free index */
      144 		     freei = i;
      145 		end;
      146 	end;
      147 
      148 	linkno = binary (baseno (lot$.lp (segno)), 18);	/* get linkage segment number */
      149 	if linkno = 0				/* check for segment that is not valid */
      150 	then code = error_table_$nolinkag;		/* return error code */
      151 	else do;					/* there is a linkage segment */
      152 		if ^repeated_call			/* check if wired state is already set up */
      153 		then do;
      154 			if twep = null		/* check if we already have an entry */
      155 			then do;			/* this is the first request to wire procedure */
      156 				linkoff = binary (rel (lot$.lp (segno)), 18); /* get linkage starting offset */
      157 				linkptr = ptr (baseptr (linkno), linkoff); /* make pointer to linkage header */
      158 				if freei > hbound (wpd.temp_w, 1) /* make certain end of array not passed */
      159 				then call syserr (1, "wire_proc: too many temp wired segments."); /* crash */
      160 				else wpd.temp_w_max = max (size, freei); /* update count of wired segs */
      161 				twep = freep;	/* use a free entry */
      162 
      163 				twe.seg_w = check_unpaged (addr (dseg$ (segno))); /* unpaged is always wired */
      164 				twe.link_w = check_unpaged (addr (dseg$ (linkno))); /* remember linkage wired */
      165 
      166 				twe.segno = bit (segno, 18); /* fill in our segment number */
      167 				twe.linkno = bit (linkno, 18); /* and for our linkage */
      168 				twe.flp = bit (divide (linkoff, 1024, 8, 0), 8); /* compute the first link page */
      169 						/* compute last page from link length */
      170 				temp_lp = linkoff - 1 + bin (linkptr -> header.block_length, 18);
      171 				twe.llp = bit (divide (temp_lp, 1024, 8, 0), 8);
      172 			     end;
      173 
      174 			if ^twe.link_w		/* check if linkage was initially wired */
      175 			then do;			/* linkage is not initially wired */
      176 				fp, temp_fp = bin (bin (twe.flp, 8), 17); /* get first page number in linkage */
      177 				lp, temp_lp = bin (bin (twe.llp, 8), 17); /* and last page */
      178 				do i = 1 to size;	/* check for overlap of linkage pages */
      179 				     ip = addr (wpd.temp_w (i)); /* get pointer to entry */
      180 				     if ip ^= twep	/* skip our own entry */
      181 				     then if linkno = bin (ip -> twe.linkno, 18) /* if same linkage segment */
      182 					then if fp = bin (ip -> twe.llp, 8) /* check for conflict with our first page */
      183 					     then fp = temp_fp + 1; /* this page is taken care of by someone else */
      184 					     else if lp = bin (ip -> twe.flp, 8) /* check for conflict with our last page */
      185 					     then lp = temp_lp - 1; /* taken care of , so we skip last page */
      186 				end;
      187 
      188 				if fp <= lp	/* check if all linkage pages already wired */
      189 				then do;
      190 					astep = get_ptrs_$given_segno (linkno); /* get AST pointer for linkage segment */
      191 					np = lp - fp + 1; /* compute number of pages */
      192 					if wire_call /* check if wire or unwire */
      193 					then call pc_wired$wire_wait (astep, fp, np); /* wire down linkage pages */
      194 					else call pc_wired$unwire (astep, fp, np); /* unwire linkage pages */
      195 				     end;
      196 			     end;
      197 
      198 			if ^twe.seg_w		/* check if procedure was initially wired */
      199 			then do;
      200 				astep = get_ptrs_$given_segno (segno); /* get AST pointer for procedure segment */
      201 				if wire_call	/* check if wire or unwire */
      202 				then call pc_wired$wire_wait (astep, 0, -1); /* wire all pages of procedure */
      203 				else call pc_wired$unwire (astep, 0, -1); /* unwire all pages of procedure */
      204 			     end;
      205 
      206 			if ^wire_call		/* check if we just unwired */
      207 			then do;			/* if unwired, then release our entry */
      208 				twe.segno = (18)"0"b; /* clear procedure segment number */
      209 				twe.linkno = (18)"0"b; /* and linkage segment number */
      210 				if twep = addr (wpd.temp_w (size)) /* check if we have the last entry */
      211 				then wpd.temp_w_max = size - 1; /* reduce count of active entry max */
      212 			     end;
      213 		     end;
      214 
      215 /* bump counter of outstanding calls */
      216 		twe.count = bit (bin (bin (twe.count, 18) + increment, 18), 18);
      217 	     end;
      218 	if stacq (wpd.temp_w_lock, "0"b, pds$process_id) then call pxss$notify (sst$temp_w_event);
      219 	else call syserr (1, "wire_proc: lock not locked");
      220 	return;
      221 
      222 check_unpaged: proc (sdw_ptr) returns (bit (1) aligned);
      223 
      224 /* See if the sdw pointed to is unpaged (not page control paged) */
      225 
      226 	dcl     sdw_ptr		 pointer;
      227 
      228 	if sys_info$system_type = ADP_SYSTEM then	/* Examine the appropriate SDW */
      229 	     return ((bin (sdw_ptr -> adp_sdw.add, 26) < upt.sst_absloc)
      230 		| (upt.sst_last_loc < bin (sdw_ptr -> adp_sdw.add, 26)));
      231 	else
      232 	     return ((bin (sdw_ptr -> l68_sdw.add, 24) < upt.sst_absloc)
      233 		| (upt.sst_last_loc < bin (sdw_ptr -> l68_sdw.add, 24)));
      234      end;
      235  
  1     2 /* Begin include file ...... wire_proc_data.incl.pl1
  1     3*	Extracted from sst.incl.pl1 8/3/76 by Noel I. Morris */
  1     4 
  1     5 dcl  wpdp ptr;					/* pointer to data */
  1     6 
  1     7 dcl 1 wpd based (wpdp) aligned,
  1     8     2 temp_w_lock bit (36),				/* lock for the temp wired procedure info */
  1     9     2 temp_w_max fixed bin (17),			/* the maximum index currently in use */
  1    10     2 temp_w (7) like twe;				/* one two word entry per temp wired procedure */
  1    11 
  1    12 dcl  twep ptr;					/* pointer to table entry */
  1    13 
  1    14 dcl 1 twe based (twep) aligned,			/* entry for temp wired procedure */
  1    15    (2 segno bit (18),				/* segment number that is temp wired */
  1    16     2 count bit (18),				/* count of number of outstanding wire calls */
  1    17     2 linkno bit (18),				/* segment number of the linkage segment */
  1    18     2 flp bit (8),					/* first page of linkage segment for this procedure */
  1    19     2 llp bit (8),					/* last page of linkage segment for this procedure */
  1    20     2 link_w bit (1),				/* bit is on if linkage is permanently wired */
  1    21     2 seg_w bit (1)) unaligned;			/* bit is on if procedure is permanently wired */
  1    22 
  1    23 /* End of include file ...... wire_proc_data.incl.pl1 */
  1    24 
      235 
      236  /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  2     2 
  2     3 /* Last Modified (Date and Reason):
  2     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  2     5*   6/75 by S.Webber to comment existing structures better
  2     6*   9/77 by M. Weaver to add run_depth to link
  2     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  2     8**/
  2     9 
  2    10 /* format: style3 */
  2    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  2    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  2    13 	  2 ringno	bit (3) unal,
  2    14 	  2 mbz		bit (6) unal,
  2    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  2    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  2    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  2    18 	  2 mbz2		bit (12) unal,
  2    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  2    20 
  2    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  2    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  2    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  2    24 
  2    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  2    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  2    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  2    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  2    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  2    30 
  2    31 dcl	1 header		based aligned,		/* linkage block header */
  2    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  2    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  2    34 	  2 original_linkage_ptr
  2    35 			ptr unal,			/* pointer to linkage section in object segment */
  2    36 	  2 unused	bit (72),
  2    37 	  2 stats,
  2    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  2    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  2    40 	    3 segment_number
  2    41 			bit (18) unal,		/* text segment number associated with this section */
  2    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  2    43 
  2    44 dcl	1 linkage_header_flags
  2    45 			aligned based,		/* overlay of def_ptr for flags */
  2    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  2    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  2    48 	  2 perprocess_static
  2    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  2    50 	  2 pad2		bit (6) unaligned;
  2    51 
  2    52 dcl	1 virgin_linkage_header
  2    53 			aligned based,		/* template for linkage header in object segment */
  2    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  2    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  2    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  2    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  2    58 	  2 filled_in_later bit (144),
  2    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  2    60 	  2 linkage_section_lng
  2    61 			bit (18) unaligned,		/* length of linkage section */
  2    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  2    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  2    64 
  2    65 
  2    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  2    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  2    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  2    69 
  2    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  2    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  2    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  2    73 
  2    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
      236 
      237  /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  3     2 /* modified by M. Weaver 3/77 */
  3     3 
  3     4 dcl  lotp ptr;
  3     5 
  3     6 dcl 1 lot based (lotp) aligned,
  3     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  3     8 
  3     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  3    10 						/* lot fault has fault code = 0 and offset = 0 */
  3    11 
  3    12 dcl  isotp ptr;
  3    13 dcl 1 isot based (isotp) aligned,
  3    14     2 isp (0:9999) ptr unaligned;
  3    15 
  3    16 dcl 1 isot1 (0 :9999) aligned based,
  3    17     2 flags unaligned,
  3    18       3 fault bit (2) unaligned,
  3    19       3 system bit (1) unaligned,
  3    20       3 mbz bit (6) unaligned,
  3    21     2 fault_code fixed bin (8) unaligned,
  3    22     2 static_offset bit (18) unaligned;
  3    23 
  3    24 
  3    25 /* END INCLUDE FILE  lot.incl.pl1 */
      237 
      238  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  4     2 
  4     3 /* Template for an AST entry. Length = 12 words. */
  4     4 
  4     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  4     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  4     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  4     8 
  4     9 dcl  astep ptr;
  4    10 
  4    11 dcl 1 aste based (astep) aligned,
  4    12 
  4    13     (2 fp bit (18),					/* forward  used list rel pointer */
  4    14     2 bp bit (18),					/* backward used list rel pointer */
  4    15 
  4    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  4    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  4    18 
  4    19     2 strp bit (18),				/* rel pointer to process trailer */
  4    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  4    21 
  4    22     2 uid bit (36),					/* segment unique id */
  4    23 
  4    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  4    25     2 pvtx fixed bin (8),				/* physical volume table index */
  4    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    27 
  4    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  4    29     2 init bit (1),					/* used bit - insure 1 lap */
  4    30     2 gtus bit (1),					/* global transparent usage switch */
  4    31     2 gtms bit (1),					/* global transparent modified switch */
  4    32     2 hc bit (1),					/* hard core segment */
  4    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  4    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  4    35     2 write_access_on bit (1),			/* any sdw allows write access */
  4    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  4    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  4    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  4    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  4    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  4    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  4    42     2 pad1 bit (2),					/* OO */
  4    43     2 dius bit (1),					/* dumper in use switch */
  4    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  4    45     2 dmpr_pad bit (1),
  4    46     2 ehs bit (1),					/* entry hold switch */
  4    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  4    48     2 dirsw bit (1),				/* directory switch */
  4    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  4    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  4    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  4    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  4    53 
  4    54     2 dtu bit (36),					/* date and time segment last used */
  4    55 
  4    56     2 dtm bit (36),					/* date and time segment last modified */
  4    57 
  4    58 
  4    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  4    60 
  4    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  4    62 
  4    63     2 csl bit (9),					/* current segment length in 1024 words units */
  4    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  4    65     2 fms bit (1),					/* file modified switch */
  4    66     2 npfs bit (1),					/* no page fault switch */
  4    67     2 gtpd bit (1),					/* global transparent paging device switch */
  4    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  4    69     2 per_process bit (1),				/* use master quota for this entry */
  4    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  4    71     2 pad2 bit (2),
  4    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  4    73     2 np bit (9),					/* number of pages in core */
  4    74 
  4    75 
  4    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  4    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  4    78     2 damaged bit (1),				/* PC declared segment unusable */
  4    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  4    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  4    81     2 pad3 bit (6),					/* OOOOOOOOO */
  4    82     2 ptsi bit (2),					/* page table size index */
  4    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  4    84 
  4    85 
  4    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  4    87 
  4    88 
  4    89 dcl 1 aste_part aligned based (astep),
  4    90 
  4    91     2 one bit (36) unaligned,				/* fp and bp */
  4    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  4    93     2 three bit (8) unaligned;			/* ptsi and marker */
  4    94 
  4    95 
  4    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  4    97     2 pad1 bit (8*36),
  4    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  4    99     2 pad2 bit (3*36);
  4   100 
  4   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      238 
      239  /* BEGIN INCLUDE FILE ... system_types.incl.pl1 ... 03/23/81 ... W. Olin Sibert */
  5     2 
  5     3 dcl  L68_SYSTEM	fixed bin (17) internal static options (constant) init (1);
  5     4 dcl  ADP_SYSTEM	fixed bin (17) internal static options (constant) init (2);
  5     5 
  5     6 dcl  SYSTEM_TYPE_NAME (2) char (8) internal static options (constant) init
  5     7     ("Level68", "ADP");
  5     8 
  5     9 /* END INCLUDE FILE ... system_types.incl.pl1 */
      239 
      240  /* BEGIN INCLUDE FILE ... sdw.l68.incl.pl1 ... Updated for ADP conversion 03/01/81 */
  6     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  6     3 
  6     4 dcl 1 l68_sdw based (sdwp) aligned,			/* Level 68 Segment Descriptor Word */
  6     5 
  6     6    (2 add bit (24), 				/* main memory address of page table */
  6     7     2 rings,					/* ring brackets for the segment */
  6     8       3 r1 bit (3),
  6     9       3 r2 bit (3),
  6    10       3 r3 bit (3),
  6    11     2 valid bit (1),				/* directed fault bit (0 => fault) */
  6    12     2 df_no bit (2),				/* directed fault number */
  6    13 
  6    14     2 pad1 bit (1),
  6    15     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  6    16     2 access,					/* access bits */
  6    17       3 read bit (1),				/* read permission bit */
  6    18       3 execute bit (1),				/* execute permission bit */
  6    19       3 write bit (1),				/* write permission bit */
  6    20       3 privileged bit (1),				/* privileged bit */
  6    21     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  6    22     2 not_a_gate bit (1),				/* if this is 0 the entry bound is checked by hardware */
  6    23     2 cache bit (1),				/* cache enable bit */
  6    24     2 entry_bound bit (14)) unaligned;			/* entry bound */
  6    25 
  6    26 /* END INCLUDE FILE ... sdw.l68.incl.pl1 */
      240 
      241  /* BEGIN INCLUDE FILE ... sdw.adp.incl.pl1 ... 01/16/81, for ADP conversion */
  7     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  7     3 
  7     4 dcl 1 adp_sdw based (sdwp) aligned,			/* ADP Segment Descriptor Word */
  7     5 
  7     6    (2 add bit (26), 				/* Page table address */
  7     7     2 valid bit (1),				/* "1"b => SDW is valid */
  7     8     2 rings,					/* Ring brackets */
  7     9       3 r1 bit (3),
  7    10       3 r2 bit (3),
  7    11       3 r3 bit (3),
  7    12 
  7    13     2 bound bit (14),				/* Bound of segment, in 16 word blocks */
  7    14     2 pad1 bit (2),
  7    15     2 entry_bound bit (14),				/* Gate entry bound */
  7    16     2 access,					/* Access permission bits */
  7    17       3 read bit (1),
  7    18       3 execute bit (1),
  7    19       3 write bit (1),
  7    20       3 privileged bit (1),
  7    21     2 unpaged bit (1),				/* "1"b => segment is unpaged */
  7    22     2 not_a_gate bit (1)) unaligned;			/* "0"b => entry bound is checked by hardware */
  7    23 
  7    24 /* END INCLUDE FILE sdw.adp.incl.pl1 */
      241 
      242  /* BEGIN include file unpaged_page_tables.incl.pl1 */
  8     2 
  8     3 /* This include file describes the segments unpaged_page_tables and
  8     4*int_unpaged_page_tables.  These segments contain the page tables for
  8     5*segments that are paged and wired, those segments previously called
  8     6*unpaged.
  8     7*
  8     8*Written September 15, 1983 by Keith Loepere. */
  8     9 
  8    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  8    11 
  8    12 dcl  upt_ptr		        ptr;
  8    13 dcl  1 upt		        aligned based (upt_ptr),
  8    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
  8    15        2 sst_last_loc	        fixed bin (26),
  8    16        2 upt_absloc		        fixed bin (26),
  8    17        2 upt_last_loc	        fixed bin (26),
  8    18        2 iupt_absloc	        fixed bin (26),
  8    19        2 iupt_last_loc	        fixed bin (26),
  8    20 
  8    21        2 current_length	        fixed bin,		/* number of words currently used */
  8    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
  8    23        2 first_entry	        like upt_entry;
  8    24 
  8    25 dcl  upt_entry_ptr		        ptr;
  8    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
  8    27        2 size		        fixed bin,		/* number of page table words allocated */
  8    28        2 segno		        fixed bin,		/* of hardcore segment */
  8    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
  8    30 
  8    31 /* END include file unpaged_page_tables.incl.pl1 */
      242 
      243 /*  */
      244 
      245 /* BEGIN MESSAGE DOCUMENTATION
      246*
      247*   Message:
      248*   wire_proc: too many temp wired segments.
      249*
      250*   S: $crash
      251*
      252*   T: $run
      253*
      254*   M: A request has been made to the supervisor to temp-wire an
      255*   eighth hardcore segment. Only seven are allowed. Temp-wiring is used for
      256*   supervisor programs, not I/O buffers.
      257*   $err
      258*
      259*   A: $recover
      260*   $boot_tape
      261*
      262*   Message:
      263*   wire_proc: lock not locked
      264*
      265*   S: $crash
      266*
      267*   T: $run
      268*
      269*   M: The lock on temp-wiring in the SST was found unlocked at the time
      270*   an attempt was made to unlock it.  The SST may be damaged.
      271*   $err
      272*
      273*   A: $recover
      274*
      275*   END MESSAGE DOCUMENTATION */
      276      end wire_proc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.5  wire_proc.pl1                     >special_ldd>install>MR12.3-1114>wire_proc.pl1
235          1    09/14/76  0802.8  wire_proc_data.incl.pl1           >ldd>include>wire_proc_data.incl.pl1
236          2    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
237          3    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
238          4    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
239          5    06/19/81  2115.0  system_types.incl.pl1             >ldd>include>system_types.incl.pl1
240          6    03/27/82  0429.8  sdw.l68.incl.pl1                  >ldd>include>sdw.l68.incl.pl1
241          7    03/27/82  0429.8  sdw.adp.incl.pl1                  >ldd>include>sdw.adp.incl.pl1
242          8    07/11/84  0937.3  unpaged_page_tables.incl.pl1      >ldd>include>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADP_SYSTEM                             constant        fixed bin(17,0)          initial dcl 5-4 ref 228
add                                    based           bit(26)                  level 2 in structure "adp_sdw" packed packed
                                                                                  unaligned dcl 7-4 in procedure "wire_proc" ref 228
                                                                                  228
add                                    based           bit(24)                  level 2 in structure "l68_sdw" packed packed
                                                                                  unaligned dcl 6-4 in procedure "wire_proc" ref 231
                                                                                  231
addr                                                   builtin function         dcl 79 ref 114 115 119 122 131 163 163 164 164 179
                                                                                  210
adp_sdw                                based           structure                level 1 dcl 7-4
astep                           000134 automatic       pointer                  dcl 4-9 set ref 190* 192* 194* 200* 201* 203*
baseptr                                                builtin function         dcl 79 ref 157
bin                                                    builtin function         dcl 79 ref 117 132 138 170 176 176 177 177 180 180
                                                                                  184 216 216 228 228 231 231
block_length              6(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-31 ref 170
callptr                         000104 automatic       pointer                  dcl 38 set ref 95* 111* 117
code                                   parameter       fixed bin(35,0)          dcl 30 set ref 12 88 93* 149*
count                     0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-14 set ref 138
                                                                                  216* 216
divide                                                 builtin function         dcl 79 ref 168 171
dseg$                           000012 external static fixed bin(71,0)          array dcl 58 set ref 163 163 164 164
error_table_$nolinkag           000026 external static fixed bin(35,0)          dcl 67 ref 149
flp                       1(18)        based           bit(8)                   level 2 packed packed unaligned dcl 1-14 set ref
                                                                                  168* 176 184
fp                              000114 automatic       fixed bin(17,0)          dcl 43 set ref 176* 180 180* 188 191 192* 194*
freei                           000115 automatic       fixed bin(17,0)          dcl 44 set ref 128* 144* 158 160
freep                           000106 automatic       pointer                  dcl 39 set ref 143* 161
get_ptrs_$given_segno           000040 constant        entry                    external dcl 73 ref 190 200
hbound                                                 builtin function         dcl 79 ref 128 158
header                                 based           structure                level 1 dcl 2-31
i                               000116 automatic       fixed bin(17,0)          dcl 45 set ref 130* 131 144* 178* 179*
increment                       000124 automatic       fixed bin(17,0)          dcl 51 set ref 84* 91* 102* 109* 216
ip                              000110 automatic       pointer                  dcl 40 set ref 131* 132 135 143 179* 180 180 180 184
l68_sdw                                based           structure                level 1 dcl 6-4
link_w                    1(34)        based           bit(1)                   level 2 packed packed unaligned dcl 1-14 set ref
                                                                                  164* 174
linkno                    1            based           bit(18)                  level 2 in structure "twe" packed packed unaligned
                                                                                  dcl 1-14 in procedure "wire_proc" set ref 167* 180
                                                                                  209*
linkno                          000100 automatic       fixed bin(18,0)          dcl 32 in procedure "wire_proc" set ref 148* 149 157
                                                                                  164 164 167 180 190*
linkoff                         000101 automatic       fixed bin(18,0)          dcl 33 set ref 156* 157 168 170
linkptr                         000112 automatic       pointer                  dcl 41 set ref 157* 170
llp                       1(26)        based           bit(8)                   level 2 packed packed unaligned dcl 1-14 set ref
                                                                                  171* 177 180
locked                          000127 automatic       bit(1)                   dcl 55 set ref 119* 120 122* 123
lot                                    based           structure                level 1 dcl 3-6
lot$                            000024 external static structure                level 1 dcl 65
lp                              000117 automatic       fixed bin(17,0)          dcl 46 in procedure "wire_proc" set ref 177* 184
                                                                                  184* 188 191
lp                              000024 external static pointer                  array level 2 in structure "lot$" packed packed
                                                                                  unaligned dcl 65 in procedure "wire_proc" ref 148
                                                                                  156
max                                                    builtin function         dcl 79 ref 160
np                              000120 automatic       fixed bin(17,0)          dcl 47 set ref 191* 192* 194*
null                                                   builtin function         dcl 79 ref 129 154
pc_wired$unwire                 000044 constant        entry                    external dcl 75 ref 194 203
pc_wired$wire_wait              000042 constant        entry                    external dcl 74 ref 192 201
pds$process_id                  000010 external static bit(36)                  dcl 57 ref 119 122 218
ptr                                                    builtin function         dcl 79 ref 157
pxss$addevent                   000032 constant        entry                    external dcl 70 ref 121
pxss$delevent                   000034 constant        entry                    external dcl 71 ref 124
pxss$notify                     000036 constant        entry                    external dcl 72 ref 218
pxss$wait                       000030 constant        entry                    external dcl 69 ref 123
repeated_call                   000126 automatic       bit(1)                   dcl 54 set ref 127* 136* 138* 152
sdw_ptr                                parameter       pointer                  dcl 226 ref 222 228 228 231 231
seg_w                     1(35)        based           bit(1)                   level 2 packed packed unaligned dcl 1-14 set ref
                                                                                  163* 198
segno                                  based           bit(18)                  level 2 in structure "twe" packed packed unaligned
                                                                                  dcl 1-14 in procedure "wire_proc" set ref 132 166*
                                                                                  208*
segno                           000102 automatic       fixed bin(18,0)          dcl 34 in procedure "wire_proc" set ref 117* 133 148
                                                                                  156 163 163 166 200*
size                            000121 automatic       fixed bin(17,0)          dcl 48 set ref 126* 130 160 178 210 210
sst$temp_w_event                000022 external static bit(36)                  dcl 63 set ref 121* 124* 218*
sst$wire_proc_data              000020 external static bit(36)                  dcl 62 set ref 114
sst_absloc                             based           fixed bin(26,0)          level 2 dcl 8-13 ref 228 231
sst_last_loc              1            based           fixed bin(26,0)          level 2 dcl 8-13 ref 228 231
stac                                                   builtin function         dcl 79 ref 119 122
stacq                                                  builtin function         dcl 79 ref 218
stats                     6            based           structure                level 2 dcl 2-31
sys_info$system_type            000016 external static fixed bin(17,0)          dcl 61 ref 228
syserr                          000046 constant        entry                    external dcl 76 ref 158 219
temp_fp                         000122 automatic       fixed bin(17,0)          dcl 49 set ref 176* 180
temp_lp                         000123 automatic       fixed bin(17,0)          dcl 50 set ref 170* 171 177* 184
temp_w                    2            based           structure                array level 2 dcl 1-7 set ref 128 131 158 179 210
temp_w_lock                            based           bit(36)                  level 2 dcl 1-7 set ref 119 122 218
temp_w_max                1            based           fixed bin(17,0)          level 2 dcl 1-7 set ref 126 160* 210*
tseg                            000103 automatic       fixed bin(18,0)          dcl 35 set ref 132* 133 141
twe                                    based           structure                level 1 dcl 1-14
twep                            000132 automatic       pointer                  dcl 1-12 set ref 129* 135* 138 154 161* 163 164 166
                                                                                  167 168 171 174 176 177 180 198 208 209 210 216
                                                                                  216
unpaged_page_tables$            000014 external static fixed bin(17,0)          dcl 59 set ref 115
upt                                    based           structure                level 1 dcl 8-13
upt_entry                              based           structure                level 1 dcl 8-26
upt_ptr                         000136 automatic       pointer                  dcl 8-12 set ref 115* 228 228 231 231
wire_call                       000125 automatic       bit(1)                   dcl 53 set ref 83* 90* 101* 108* 136 192 201 206
wired_utility_$caller           000050 constant        entry                    external dcl 77 ref 111
wireptr                                parameter       pointer                  dcl 29 ref 12 88 95
wpd                                    based           structure                level 1 dcl 1-7
wpdp                            000130 automatic       pointer                  dcl 1-5 set ref 114* 119 122 126 128 131 158 160 179
                                                                                  210 210 218

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
L68_SYSTEM                             internal static fixed bin(17,0)          initial dcl 5-3
SYSTEM_TYPE_NAME                       internal static char(8)                  initial array packed unaligned dcl 5-6
asta                                   based           bit(432)                 array dcl 4-86
aste                                   based           structure                level 1 dcl 4-11
aste_part                              based           structure                level 1 dcl 4-89
exp_word                               based           structure                level 1 dcl 2-21
isot                                   based           structure                level 1 dcl 3-13
isot1                                  based           structure                array level 1 dcl 3-16
isotp                                  automatic       pointer                  dcl 3-12
link                                   based           structure                level 1 dcl 2-11
linkage_header_flags                   based           structure                level 1 dcl 2-44
lot_fault                              internal static bit(36)                  initial dcl 3-9
lotp                                   automatic       pointer                  dcl 3-4
name                                   based           structure                level 1 dcl 2-70
sdwp                                   automatic       pointer                  dcl 37
seg_aste                               based           structure                level 1 dcl 4-96
trap_word                              based           structure                level 1 dcl 2-66
type_pair                              based           structure                level 1 dcl 2-25
upt_entry_ptr                          automatic       pointer                  dcl 8-25
virgin_linkage_header                  based           structure                level 1 dcl 2-52

NAMES DECLARED BY EXPLICIT CONTEXT.
check_unpaged                   000747 constant        entry                    internal dcl 222 ref 163 164
join                            000122 constant        label                    dcl 114 ref 96
join_me                         000113 constant        label                    dcl 111 ref 103
join_not_me                     000061 constant        label                    dcl 93 ref 85
wire_proc                       000035 constant        entry                    external dcl 12
wire_proc$unwire_me             000103 constant        entry                    external dcl 106
wire_proc$unwire_proc           000051 constant        entry                    external dcl 88
wire_proc$wire_me               000070 constant        entry                    external dcl 99

NAMES DECLARED BY CONTEXT OR IMPLICATION.
baseno                                                 builtin function         ref 117 148
binary                                                 builtin function         ref 148 156
bit                                                    builtin function         ref 166 167 168 171 216
rel                                                    builtin function         ref 156

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1302        1354    1014        1312
Length      1730    1014        52         337     265           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
wire_proc                           140 external procedure  is an external procedure.  
check_unpaged                           internal procedure  shares stack frame of external procedure wire_proc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
wire_proc                000100 linkno                      wire_proc
                         000101 linkoff                     wire_proc
                         000102 segno                       wire_proc
                         000103 tseg                        wire_proc
                         000104 callptr                     wire_proc
                         000106 freep                       wire_proc
                         000110 ip                          wire_proc
                         000112 linkptr                     wire_proc
                         000114 fp                          wire_proc
                         000115 freei                       wire_proc
                         000116 i                           wire_proc
                         000117 lp                          wire_proc
                         000120 np                          wire_proc
                         000121 size                        wire_proc
                         000122 temp_fp                     wire_proc
                         000123 temp_lp                     wire_proc
                         000124 increment                   wire_proc
                         000125 wire_call                   wire_proc
                         000126 repeated_call               wire_proc
                         000127 locked                      wire_proc
                         000130 wpdp                        wire_proc
                         000132 twep                        wire_proc
                         000134 astep                       wire_proc
                         000136 upt_ptr                     wire_proc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               call_ext_out_desc   call_ext_out        return_mac          stac_mac
ext_entry           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_ptrs_$given_segno         pc_wired$unwire               pc_wired$wire_wait            pxss$addevent
pxss$delevent                 pxss$notify                   pxss$wait                     syserr
wired_utility_$caller

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         error_table_$nolinkag         lot$                          pds$process_id
sst$temp_w_event              sst$wire_proc_data            sys_info$system_type          unpaged_page_tables$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000031        83 000042        84 000044        85 000046        88 000047        90 000056        91 000057
     93 000061        95 000063        96 000066        99 000067       101 000075       102 000077       103 000101
    106 000102       108 000110       109 000111       111 000113       114 000122       115 000125       117 000127
    119 000133       120 000141       121 000144       122 000153       123 000162       124 000170       125 000176
    126 000177       127 000202       128 000203       129 000205       130 000207       131 000215       132 000220
    133 000223       135 000225       136 000226       138 000233       141 000241       143 000243       144 000244
    146 000246       148 000251       149 000257       152 000265       154 000267       156 000273       157 000276
    158 000305       160 000333       161 000340       163 000342       164 000360       166 000376       167 000403
    168 000410       170 000422       171 000432       174 000443       176 000447       177 000454       178 000461
    179 000471       180 000474       184 000515       186 000525       188 000527       190 000532       191 000543
    192 000547       194 000565       198 000600       200 000604       201 000615       203 000636       206 000654
    208 000656       209 000660       210 000662       216 000676       218 000710       219 000725       220 000746
    222 000747       228 000751       231 000771


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
