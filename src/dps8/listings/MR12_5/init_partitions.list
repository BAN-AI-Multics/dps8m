	COMPILATION LISTING OF SEGMENT init_partitions
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0954.1 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style2 */
       10 
       11 init_partitions:
       12      proc ();
       13 
       14 /* format: off */
       15 
       16 /* *	This procedure reads all the PART cards in the config deck, checks them against
       17*   *	pack labels, 
       18*   *	This used to be in init_pvt.
       19*   *
       20*   *	11/28/80, W. Olin Sibert
       21*   *      7/82 BIM remove fixed bin (9), merge with stocks etc. 
       22*   *         and flush wired_hardcore_data stuff.
       23*   *	'82 for english error codes
       24*   */
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(86-01-15,Fawcett), approve(86-04-11,MCR7383),
       28*     audit(86-07-07,GDixon), install(86-07-17,MR12.0-1097):
       29*     Change the format of part card for subvolumes.
       30*  2) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
       31*     audit(86-06-10,Martinson), install(86-07-17,MR12.0-1091):
       32*     Correct error message documentation.
       33*  3) change(88-03-05,Beattie), approve(88-05-31,MCR7864),
       34*     audit(88-05-13,Brunelle), install(88-05-31,MR12.2-1046):
       35*     Initialize pointer to pvte earlier so error messages will work.
       36*                                                   END HISTORY COMMENTS */
       37 
       38 /* format: on */
       39 
       40 	dcl     P99		 picture "99" based;
       41 	dcl     pvtx		 fixed bin;
       42 	dcl     part_id		 char (4) aligned;	/* System-defined name of partition */
       43 	dcl     part_name		 char (4) aligned;	/* Name of partition to use on this pack */
       44 	dcl     part_idx		 fixed bin;
       45 	dcl     code		 fixed bin (35);
       46 	dcl     problem		 char (64);
       47 	dcl     drive_no		 fixed bin;
       48 	dcl     sv_no		 fixed bin;
       49 	dcl     sv_idx		 fixed bin;
       50 	dcl     label_buffer	 (512) fixed bin (71) automatic;
       51 						/* Buffer for label reading */
       52 
       53 	dcl     config_$find	 entry (char (4) aligned, pointer);
       54 	dcl     read_disk_label	 entry (fixed bin, ptr, char (*), fixed bin (35));
       55 	dcl     syserr		 entry options (variable);
       56 	dcl     syserr$error_code	 entry options (variable);
       57 
       58 	dcl     VALID_NUMBERS	 char (10) int static options (constant) init ("0123456789");
       59 	dcl     WHOAMI		 char (32) internal static options (constant) init ("init_partitions:");
       60 
       61 	dcl     (addr, bin, convert, index, null, rtrim, substr, verify)
       62 				 builtin;
       63 
       64 
       65 	labelp = addr (label_buffer);
       66 	pvtp = addr (pvt$);
       67 	pvt_arrayp = addr (pvt.array);
       68 
       69 	part_cardp = null ();
       70 GET_NEXT_PART_CARD:
       71 	call config_$find (PART_CARD_WORD, part_cardp);
       72 	if part_cardp = null ()
       73 	then goto FOUND_ALL_PART_CARDS;		/* All done */
       74 
       75 	part_id = part_card.name;			/* Find out which partition this is defining */
       76 
       77 	if part_card.n_fields = 4
       78 	then part_name = part_card.real_name;		/* Possibly the partition being defined actually */
       79 						/* has a different name, so check first */
       80 	else part_name = part_id;			/* But if none specified, then it's the same as the ID */
       81 
       82 	if part_card.n_fields > 4
       83 	then call syserr (BEEP, "^a Ignoring ""^a ^d."" on ^a part card.", WHOAMI, cold_part_card.highlow,
       84 		cold_part_card.nrec, part_id);	/* Complain if this is a leftover cold boot card */
       85 
       86 	sv_idx = verify (rtrim (part_card.drive), VALID_NUMBERS);
       87 						/* check for non-numeric character */
       88 	if sv_idx = 0
       89 	then do;					/* non-subvolume device */
       90 		drive_no = bin (part_card.drive, 17);
       91 		sv_no = -1;
       92 	     end;
       93 	else if sv_idx > 1
       94 	then do;					/* possible subvolume device */
       95 		drive_no = bin (substr (part_card.drive, 1, sv_idx - 1), 17);
       96 		sv_no = index (valid_sv_string, substr (rtrim (part_card.drive), sv_idx)) - 1;
       97 		if sv_no = -1			/* bad subvolume indicator */
       98 		then goto invalid_drive;
       99 	     end;
      100 	else do;					/* no valid drive number */
      101 invalid_drive:
      102 		call syserr (CRASH, "^a: Invalid device, ^a_^a, on ^a part card.", WHOAMI, part_card.subsystem,
      103 		     part_card.drive, part_id);
      104 		goto GET_NEXT_PART_CARD;		/* In case someone types GO */
      105 	     end;
      106 
      107 	do pvtx = 1 to pvt.n_entries
      108 	     while (pvt_array (pvtx).devname ^= part_card.subsystem | pvt_array (pvtx).logical_area_number ^= drive_no
      109 	     | pvt_array (pvtx).sv_num ^= sv_no);	/* Now, try to find the right volume */
      110 	end;
      111 
      112 	if pvtx > pvt.n_entries
      113 	then do;					/* Sorry, not there */
      114 		call syserr (CRASH, "^a Unable to locate ^a_^a for ^a partition.", WHOAMI, part_card.subsystem,
      115 		     part_card.drive, part_id);
      116 		goto GET_NEXT_PART_CARD;		/* In case someone types GO */
      117 	     end;
      118 
      119 READ_LABEL:
      120 	call read_disk_label (pvtx, labelp, problem, code);
      121 	if code ^= 0
      122 	then do;
      123 		call syserr$error_code (CRASH, code, "Error reading ^a_^a label. ^a", WHOAMI, part_card.subsystem,
      124 		     part_card.drive, problem);
      125 		goto READ_LABEL;			/* retry label read if GO typed */
      126 	     end;
      127 
      128 	pvtep = addr (pvt_array (pvtx));
      129 
      130 	if label.nparts = 0
      131 	then do;
      132 		call syserr (CRASH, "^a There are no partitions in the label for ^a_^a^[^a^;^s^] (pvtx ^d).", WHOAMI,
      133 		     pvte.devname, convert (P99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pvtx);
      134 		goto GET_NEXT_PART_CARD;		/* In case someone types GO */
      135 	     end;
      136 
      137 	do part_idx = 1 to label.nparts while (part_name ^= label.parts (part_idx).part);
      138 						/* Search the label for the one we want */
      139 	end;
      140 
      141 	if part_idx > label.nparts
      142 	then do;
      143 		call syserr (CRASH, "^a part ^a^[ for part ^a^;^s^] not in label of ^a_^a^[^a^;^s^] (pvtx ^d)",
      144 		     WHOAMI, part_name, (part_name ^= part_id), part_id, pvte.devname,
      145 		     convert (P99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pvtx);
      146 		goto GET_NEXT_PART_CARD;		/* In case someone types GO */
      147 	     end;
      148 
      149 	pvte.permanent = "1"b;			/* Protect it against demounting */
      150 
      151 	goto GET_NEXT_PART_CARD;
      152 
      153 
      154 /* We come here when all is done. By rights, we ought to complain about missing
      155*   required partitions here, but that logic isn't designed yet.
      156*   */
      157 
      158 FOUND_ALL_PART_CARDS:
      159 	return;					/* All done */
      160 
  1     1 /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
  1     2 
  1     3 
  1     4 /* The physical volume table (PVT) is a wired-down table.
  1     5*   It has one entry for each spindle present, be it for
  1     6*   Storage System or "I/O" use.
  1     7**/
  1     8 
  1     9      dcl	   pvt$		      ext,
  1    10 	   pvtp		      ptr;
  1    11 
  1    12 
  1    13      dcl	   1 pvt		      based (pvtp) aligned,
  1    14 
  1    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
  1    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
  1    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
  1    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
  1    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
  1    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
  1    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
  1    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
  1    23 
  1    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
  1    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
  1    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
  1    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
  1    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
  1    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
  1    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
  1    31 
  1    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
  1    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
  1    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
  1    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  1    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  1    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
  1    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
  1    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
  1    40 
  1    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
  1    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
  1    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
  1    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
  1    45 
  1    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
  1    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
  1    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
  1    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
  1    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
  1    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
  1    52 	     2 pad (2) bit (36) aligned,
  1    53 
  1    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
  1    55 
  1    56 
  1    57 
  1    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      161 
      162 
  2     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  2     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2     8*     Add the support for subvolumes
  2     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  2    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  2    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2    14*     Added inconsistent_dbm bit for determining the status of volume
  2    15*     dumper bit maps.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18      dcl	   pvt$array	      aligned external;
  2    19      dcl	   pvt$max_n_entries      fixed bin external;
  2    20 
  2    21      dcl	   pvt_arrayp	      ptr;
  2    22      dcl	   pvtep		      ptr;
  2    23 
  2    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  2    25 
  2    26      dcl	   1 pvte		      based (pvtep) aligned,
  2    27 
  2    28 	     2 pvid	      bit (36),		/* physical volume ID */
  2    29 
  2    30 	     2 lvid	      bit (36),		/* logical volume ID */
  2    31 
  2    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  2    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  2    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  2    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  2    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  2    37 	     2 pad3	      bit (2) unaligned,
  2    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  2    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  2    40 
  2    41 
  2    42 
  2    43 	     2 devname	      char (4),		/* device name */
  2    44 
  2    45 	     (2 device_type	      fixed bin (8),	/* device type */
  2    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  2    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  2    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  2    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  2    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  2    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  2    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  2    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  2    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  2    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  2    56 	     2 scav_check_address
  2    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  2    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  2    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  2    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  2    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  2    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  2    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  2    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  2    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  2    66 
  2    67 
  2    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  2    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  2    70 
  2    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  2    72 
  2    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  2    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  2    75 
  2    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  2    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  2    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  2    79 	     2 records_per_cyl    fixed bin,
  2    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  2    81 	     2 sv_name            char (2) aligned,
  2    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  2    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  2    84 
  2    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  2    86 	     2 pad2	      bit (18) unaligned,
  2    87 
  2    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  2    89 
  2    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  2    91 
  2    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  2    93 
  2    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  2    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  2    96 
  2    97 
  2    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  2    99 
  2   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  2   101 
  2   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  2   103 
  2   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  2   105 
  2   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  2   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  2   108 
  2   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  2   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  2   111 
  2   112 
  2   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  2   114 	   VOLMAP_ASYNC_READ      init (1),
  2   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  2   116 
  2   117 
  2   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      163 
      164 
  3     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  3     6*     Add support for FIPS
  3     7*     3380.
  3     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  3     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  3    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  3    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  3    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  3    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 /* Modified 5/19/76 by N. I. Morris */
  3    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  3    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  3    19 /* Modified '82 by BIM for needs_alt_part */
  3    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  3    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  3    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  3    23*   volmap and record stock can be expanded. */
  3    24 
  3    25 /*
  3    26********************************************************************************
  3    27**							        *
  3    28**                           WARNING:                                          *
  3    29**							        *
  3    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  3    31**   type is added.						        *
  3    32**							        *
  3    33**   There are other include files that contain arrays indexed by the device   *
  3    34**   index obtained by references to MODELX or MODELN in this include file.    *
  3    35**   These must be modified when a new device type is added:		        *
  3    36**   disk_pack.incl.pl1					        *
  3    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  3    38**							        *
  3    39********************************************************************************
  3    40**/
  3    41 
  3    42 
  3    43 dcl (maxdevt init (9),				/* maximum legal devt */
  3    44      bulkdevt init (1),				/* bulk store devt */
  3    45      msu0500devt init (2),				/* MSU0500 device type */
  3    46      msu0451devt init (3),				/* MSU0451 device type */
  3    47      msu0450devt init (3),				/* MSU0450 device type */
  3    48      msu0400devt init (4),				/* MSU0400 device type */
  3    49      dsu191devt init (4),				/* DSU191 device type */
  3    50      dsu190devt init (5),				/* DSU190 device type */
  3    51      dsu181devt init (6),				/* DSU181 device type */
  3    52      msu0501devt init (7),				/* MSU0501 device type */
  3    53      fips3380devt init (8),				/* 3380D FIPS device type */
  3    54      fips3381devt init (9)				/* 3380E FIPS device type */
  3    55      ) fixed bin (4) static options (constant);
  3    56 
  3    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  3    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  3    59 
  3    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  3    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  3    62 
  3    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  3    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  3    65 
  3    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  3    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  3    68 
  3    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  3    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  3    71 
  3    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  3    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  3    74 
  3    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  3    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    77 
  3    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  3    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  3    80 
  3    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  3    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    83 
  3    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  3    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  3    86 
  3    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  3    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  3    89 
  3    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  3    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  3    92 
  3    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  3    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  3    95 
  3    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  3    97      ("abc");
  3    98 
  3    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  3   100      init ("a","b","c");
  3   101 
  3   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  3   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  3   104 
  3   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  3   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  3   107 
  3   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  3   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  3   110 
  3   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  3   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  3   113 
  3   114 
  3   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  3   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   117 
  3   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  3   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  3   120 
  3   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  3   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  3   123 
  3   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  3   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   126 
  3   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  3   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  3   129 
  3   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  3   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  3   132 
  3   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  3   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  3   135 
  3   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  3   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  3   138 
  3   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  3   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  3   141 
  4     1 /* Begin fs_dev_types_sector.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  4     7*     Add the sector differance for devices that do 64 word IO and devices that
  4     8*     do 512 word IO.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  4    12*	 need all the data in fs_dev_types. This is also included in
  4    13*	 fs_dev_types.incl.pl1  */
  4    14 
  4    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  4    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  4    17 
  4    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  4    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  4    20 
  4    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  4    22  /* table of # of sectors per record on each device */
  4    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  4    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    25 
  4    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  4    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    28 	
  4    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  4    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  4    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    32 
  4    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  4    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  4    35 
  4    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  4    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  4    38 
  4    39 /* End fs_dev_types_sector.incl.pl1 */
  4    40 
  3   142 
  3   143 
  3   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      165 
      166 
  5     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  5     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     6*     Add the subvolume info.
  5     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5     9*     Added inconsistent_dbm bit used to determine consistency of volume
  5    10*     dumper bit maps.
  5    11*                                                   END HISTORY COMMENTS */
  5    12 
  5    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  5    14 /* Note: fsout_vol clears pad fields before writing the label */
  5    15 
  5    16 dcl  labelp ptr;
  5    17 
  5    18 dcl 1 label based (labelp) aligned,
  5    19 
  5    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  5    21 
  5    22     2 gcos (5*64) fixed bin,
  5    23 
  5    24 /* Now we have the Multics label */
  5    25 
  5    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  5    27     2 version fixed bin,				/* Version 1 */
  5    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  5    29     2 pv_name char (32),				/* Physical volume name. */
  5    30     2 lv_name char (32),				/* Name of logical volume for pack */
  5    31     2 pvid bit (36),				/* Unique ID of this pack */
  5    32     2 lvid bit (36),				/* unique ID of its logical vol */
  5    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  5    34     2 time_registered fixed bin (71),			/* time imported to system */
  5    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  5    36     2 vol_size fixed bin,				/* total size of volume, in records */
  5    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  5    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  5    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  5    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  5    41     2 flagpad bit (33) unal,
  5    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  5    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  5    44     2 password bit (72),				/* not yet used */
  5    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  5    46     2 this_sv fixed bin,				/* what subvolume number it is */
  5    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  5    48     2 pad1 (13) fixed bin,
  5    49     2 time_mounted fixed bin (71),			/* time mounted */
  5    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  5    51 
  5    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  5    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  5    54* */
  5    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  5    56     2 pad6 fixed bin,				
  5    57 
  5    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  5    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  5    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  5    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  5    62     2 pad1a (2) fixed bin,
  5    63     2 err_hist_size fixed bin,			/* size of pack error history */
  5    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  5    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  5    66     2 pad2 (40) fixed bin,
  5    67     2 root,
  5    68       3 here bit (1),				/* TRUE if the root is on this pack */
  5    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  5    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  5    71       3 pad7 bit (1) aligned,				
  5    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  5    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  5    74       3 esd_state fixed bin,				/* State of esd */
  5    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  5    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  5    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  5    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  5    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  5    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  5    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  5    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  5    83     2 pad3 (52) fixed bin,
  5    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  5    85     2 parts (47),
  5    86       3 part char (4),				/* Name of partition */
  5    87       3 frec fixed bin,				/* First record */
  5    88       3 nrec fixed bin,				/* Number of records */
  5    89       3 pad5 fixed bin,
  5    90     2 pad4 (5*64) fixed bin;
  5    91 
  5    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  5    93 
  5    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      167 
      168 
  6     1 /* BEGIN INCLUDE FILE ... config_part_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  6     7*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  6     8*     Change the drive dcl from fixed bin to char (4) for subvolume support.
  6     9*  2) change(87-05-07,Fawcett), approve(87-05-07,MCR7676),
  6    10*     audit(87-05-11,Beattie), install(87-07-15,MR12.1-1041):
  6    11*     Change drive element in cold_part_card from fixed bin to char (4), this
  6    12*     was an oversight in MCR7383.
  6    13*                                                   END HISTORY COMMENTS */
  6    14 
  6    15 
  6    16 dcl  part_cardp pointer;				/* pointer to PART card */
  6    17 
  6    18 dcl 1 part_card aligned based (part_cardp),		/* PART card declaration */
  6    19     2 word char (4),				/* "part" */
  6    20     2 name char (4),				/* Name of partition */
  6    21     2 subsystem char (4),				/* Disk subsystem name */
  6    22     2 drive char (4),				/* Drive number / subvol */
  6    23     2 real_name char (4),				/* Real name of partition on volume (optional) */
  6    24 
  6    25     2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  6    26 
  6    27     2 type_word aligned,
  6    28       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  6    29       3 pad1 bit (4) unaligned,
  6    30       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  6    31 
  6    32 dcl 1 cold_part_card aligned based (part_cardp),		/* PART card declaration for cold boot */
  6    33     2 word char (4),				/* "part" */
  6    34     2 name char (4),				/* Name of partition */
  6    35     2 subsystem char (4),				/* Disk subsystem name */
  6    36     2 drive char (4),				/* Drive number */
  6    37     2 highlow char (4),				/* Where to put it: "high" or "low" */
  6    38     2 nrec fixed bin,				/* Number of records to be allocated */
  6    39 
  6    40     2 pad (9) bit (36) aligned,			/* Pad to 15 fields */
  6    41 
  6    42     2 type_word aligned,
  6    43       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  6    44       3 pad1 bit (4) unaligned,
  6    45       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  6    46 
  6    47 dcl  PART_CARD_WORD char (4) aligned internal static options (constant) init ("part");
  6    48 
  6    49 /* END INCLUDE FILE ... config_part_card.incl.pl1 */
      169 
      170 
  7     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  7     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  7     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  7     4 
  7     5 /* This include file has an ALM version.  Keep 'em in sync! */
  7     6 
  7     7 dcl (
  7     8 
  7     9 /* The following constants define the message action codes.  This indicates
  7    10*how a message is to be handled.  */
  7    11 
  7    12      SYSERR_CRASH_SYSTEM	init (1),			
  7    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  7    14 
  7    15      SYSERR_TERMINATE_PROCESS	init (2),
  7    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  7    17 
  7    18      SYSERR_PRINT_WITH_ALARM	init (3),
  7    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  7    20 
  7    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  7    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  7    23 
  7    24      SYSERR_LOG_OR_PRINT	init (4),
  7    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  7    26 
  7    27      SYSERR_LOG_OR_DISCARD	init (5),
  7    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  7    29 
  7    30 
  7    31 /* The following constants are added to the normal severities to indicate
  7    32*different sorting classes of messages.  */
  7    33 
  7    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  7    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  7    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  7    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  7    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  7    39 	) fixed bin internal static options (constant);
  7    40 
  7    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      171 
      172 
      173 /* BEGIN MESSAGE DOCUMENTATION
      174*
      175*Message:
      176*init_partitions: Ignoring COLD_SPEC on PART_NAME part card.
      177*
      178*S:     $beep
      179*
      180*T:     $init
      181*
      182*M:     Cold boot partition specifications were found for partition
      183*PART_NAME, and will be ignored.
      184*
      185*Message:
      186*init_partitions: Invalid device, DISK_DRIVE, on PART_NAME part card.
      187*
      188*S:     $crash
      189*
      190*T:     $init
      191*
      192*M:     An invalid drive definition has been found for the PART_NAME
      193*part card.
      194*
      195*A:     Fix PART card.
      196*
      197*Message:
      198*init_partitions: Unable to locate DISK_DRIVE for PART_NAME partition.
      199*
      200*S:     $crash
      201*
      202*T:     $init
      203*
      204*M:     Partition PART_NAME is specified in the config deck for a non
      205*existent DISK_DRIVE.
      206*
      207*A:     Fix PART and/or PRPH DSK cards.
      208*
      209*Message:
      210*init_partitions: Error reading DISK_DRIVE label. PROBLEM ERROR_MESSAGE
      211*
      212*S:     $crash
      213*
      214*T:     $init
      215*
      216*M:     An error has been detected attempting to read the label
      217*of DISK_DRIVE.
      218*
      219*A:     Correct problem and type "go" to retry the read.
      220*
      221*Message:
      222*init_partition: There are no partitions in the label for DISK_DRIVE (pvtx PVTX).
      223*
      224*S:    $crash
      225*
      226*T:    $init
      227*
      228*M:    DISK_DRIVE has been specified on a part card, but has no partitions
      229*defined in its label.
      230*
      231*A:    Fix the config deck.
      232*
      233*Message:
      234*init_partition: part PART_NAME not in label of DISK_DRIVE (pvtx PVTX).
      235*
      236*S:    $crash
      237*
      238*T:    $init
      239*
      240*M:    A PART card specified DISK_DRIVE as the location of partition PART_NAME,
      241*but the label of DISK_DRIVE does not define it.
      242*
      243*A:    Fix the config deck.
      244*
      245*Message:
      246*init_partition: part PART_NAME for part PART_ID not in label of DISK_DRIVE (pvtx PVTX).
      247*
      248*S:    $crash
      249*
      250*T:    $init
      251*
      252*M:    A PART card specified DISK_DRIVE as the location of partition PART_NAME,
      253*but the label of DISK_DRIVE does not define it.
      254*
      255*A:    Fix the config deck.
      256*
      257*END MESSAGE DOCUMENTATION */
      258 
      259      end init_partitions;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0815.8  init_partitions.pl1               >spec>install>1112>init_partitions.pl1
161          1    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
163          2    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
165          3    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
3-142        4    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
167          5    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
169          6    07/17/87  0546.8  config_part_card.incl.pl1         >ldd>include>config_part_card.incl.pl1
171          7    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BEEP                            000000 constant        fixed bin(17,0)          initial dcl 7-7 set ref 82*
CRASH                           000034 constant        fixed bin(17,0)          initial dcl 7-7 set ref 101* 114* 123* 132* 143*
P99                                    based           picture(2)               packed unaligned dcl 40 ref 132 132 143 143
PART_CARD_WORD                  000001 constant        char(4)                  initial dcl 6-47 set ref 70*
VALID_NUMBERS                   000013 constant        char(10)                 initial packed unaligned dcl 58 ref 86
WHOAMI                          000003 constant        char(32)                 initial packed unaligned dcl 59 set ref 82* 101*
                                                                                  114* 123* 132* 143*
addr                                                   builtin function         dcl 61 ref 65 66 67 128
array                    50            based           fixed bin(71,0)          level 2 dcl 1-13 set ref 67
bin                                                    builtin function         dcl 61 ref 90 95
code                            000104 automatic       fixed bin(35,0)          dcl 45 set ref 119* 121 123*
cold_part_card                         based           structure                level 1 dcl 6-32
config_$find                    000010 constant        entry                    external dcl 53 ref 70
convert                                                builtin function         dcl 61 ref 132 132 143 143
devname                   3            based           char(4)                  array level 2 in structure "pvt_array" dcl 2-24
                                                                                  in procedure "init_partitions" set ref 107
devname                   3            based           char(4)                  level 2 in structure "pvte" dcl 2-26 in procedure
                                                                                  "init_partitions" set ref 132* 143*
drive                     3            based           char(4)                  level 2 dcl 6-18 set ref 86 90 95 96 101* 114* 123*
drive_no                        000125 automatic       fixed bin(17,0)          dcl 47 set ref 90* 95* 107
highlow                   4            based           char(4)                  level 2 dcl 6-32 set ref 82*
index                                                  builtin function         dcl 61 ref 96
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-26 set ref
                                                                                  132* 143*
label                                  based           structure                level 1 dcl 5-18
label_buffer                    000130 automatic       fixed bin(71,0)          array dcl 50 set ref 65
labelp                          002140 automatic       pointer                  dcl 5-16 set ref 65* 119* 130 137 137 141
logical_area_number       4(09)        based           fixed bin(8,0)           array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 2-24 in procedure "init_partitions"
                                                                                  set ref 107
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 2-26 in procedure "init_partitions" ref 132
                                                                                  132 143 143
n_entries                              based           fixed bin(17,0)          level 2 dcl 1-13 ref 107 112
n_fields                 17(32)        based           fixed bin(4,0)           level 3 packed packed unsigned unaligned dcl 6-18
                                                                                  ref 77 82
name                      1            based           char(4)                  level 2 dcl 6-18 ref 75
nparts                 1003            based           fixed bin(17,0)          level 2 dcl 5-18 ref 130 137 141
nrec                      5            based           fixed bin(17,0)          level 2 dcl 6-32 set ref 82*
null                                                   builtin function         dcl 61 ref 69 72
part                   1004            based           char(4)                  array level 3 dcl 5-18 ref 137
part_card                              based           structure                level 1 dcl 6-18
part_cardp                      002142 automatic       pointer                  dcl 6-16 set ref 69* 70* 72 75 77 77 82 82 82 86 90
                                                                                  95 96 101 101 107 114 114 123 123
part_id                         000101 automatic       char(4)                  dcl 42 set ref 75* 80 82* 101* 114* 143 143*
part_idx                        000103 automatic       fixed bin(17,0)          dcl 44 set ref 137* 137* 141
part_name                       000102 automatic       char(4)                  dcl 43 set ref 77* 80* 137 143* 143
parts                  1004            based           structure                array level 2 dcl 5-18
permanent                 4(20)        based           bit(1)                   level 2 packed packed unaligned dcl 2-26 set ref
                                                                                  149*
problem                         000105 automatic       char(64)                 packed unaligned dcl 46 set ref 119* 123*
pvt                                    based           structure                level 1 dcl 1-13
pvt$                            000020 external static fixed bin(17,0)          dcl 1-9 set ref 66
pvt_array                              based           structure                array level 1 dcl 2-24 set ref 128
pvt_arrayp                      002132 automatic       pointer                  dcl 2-21 set ref 67* 107 107 107 128
pvte                                   based           structure                level 1 dcl 2-26
pvtep                           002134 automatic       pointer                  dcl 2-22 set ref 128* 132 132 132 132 132 143 143
                                                                                  143 143 143 149
pvtp                            002130 automatic       pointer                  dcl 1-9 set ref 66* 67 107 112
pvtx                            000100 automatic       fixed bin(17,0)          dcl 41 set ref 107* 107 107 107* 112 119* 128 132*
                                                                                  143*
read_disk_label                 000012 constant        entry                    external dcl 54 ref 119
real_name                 4            based           char(4)                  level 2 dcl 6-18 ref 77
rtrim                                                  builtin function         dcl 61 ref 86 96
seek_command                    002136 automatic       bit(6)                   initial array packed unaligned dcl 3-84 set ref
                                                                                  3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84*
                                                                                  3-84*
substr                                                 builtin function         dcl 61 ref 95 96
subsystem                 2            based           char(4)                  level 2 dcl 6-18 set ref 101* 107 114* 123*
sv_idx                          000127 automatic       fixed bin(17,0)          dcl 49 set ref 86* 88 93 95 96
sv_name                  15            based           char(2)                  level 2 dcl 2-26 set ref 132* 143*
sv_no                           000126 automatic       fixed bin(17,0)          dcl 48 set ref 91* 96* 97 107
sv_num                   11            based           fixed bin(17,0)          array level 2 dcl 2-24 set ref 107
syserr                          000014 constant        entry                    external dcl 55 ref 82 101 114 132 143
syserr$error_code               000016 constant        entry                    external dcl 56 ref 123
type_word                17            based           structure                level 2 dcl 6-18
valid_sv_string                 000002 constant        char(3)                  initial packed unaligned dcl 3-96 ref 96
verify                                                 builtin function         dcl 61 ref 86

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 7-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 7-7
LOG                                    internal static fixed bin(17,0)          initial dcl 7-7
MODEL                                  internal static fixed bin(17,0)          initial array dcl 3-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 3-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 3-60
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 5-92
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 7-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 7-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 2-113
bulkdevt                               internal static fixed bin(4,0)           initial dcl 3-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 3-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-105
dev_time                               internal static float bin(27)            initial array dcl 3-139
device_names                           internal static char(4)                  initial array dcl 3-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 3-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 3-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 3-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 3-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 3-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 3-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 3-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 3-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 3-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 3-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 3-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 3-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 3-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 3-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 3-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 3-93
pvt$array                              external static fixed bin(17,0)          dcl 2-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 2-19
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 3-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 3-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 4-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 4-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 4-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 4-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 3-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 3-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 3-99
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 4-36

NAMES DECLARED BY EXPLICIT CONTEXT.
FOUND_ALL_PART_CARDS            001130 constant        label                    dcl 158 set ref 72
GET_NEXT_PART_CARD              000261 constant        label                    dcl 70 ref 104 116 134 146 151
READ_LABEL                      000606 constant        label                    dcl 119 ref 125
init_partitions                 000155 constant        entry                    external dcl 11
invalid_drive                   000453 constant        label                    dcl 101 ref 97

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1420        1442    1335        1430
Length      1750    1335        22         272      62           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_partitions                    1331 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_partitions          000100 pvtx                        init_partitions
                         000101 part_id                     init_partitions
                         000102 part_name                   init_partitions
                         000103 part_idx                    init_partitions
                         000104 code                        init_partitions
                         000105 problem                     init_partitions
                         000125 drive_no                    init_partitions
                         000126 sv_no                       init_partitions
                         000127 sv_idx                      init_partitions
                         000130 label_buffer                init_partitions
                         002130 pvtp                        init_partitions
                         002132 pvt_arrayp                  init_partitions
                         002134 pvtep                       init_partitions
                         002136 seek_command                init_partitions
                         002140 labelp                      init_partitions
                         002142 part_cardp                  init_partitions

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry           set_chars_eis
index_chars_eis     any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
config_$find                  read_disk_label               syserr                        syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pvt$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000154    3   84 000162        65 000251        66 000253        67 000255        69 000257        70 000261
     72 000272        75 000276        77 000301        80 000311        82 000313        86 000353        88 000400
     90 000401        91 000411        92 000413        93 000414        95 000416        96 000426        97 000450
     99 000452       101 000453       104 000511       107 000512       110 000541       112 000543       114 000546
    116 000605       119 000606       121 000633       123 000635       125 000701       128 000702       130 000707
    132 000712       134 000776       137 000777       139 001012       141 001014       143 001020       146 001123
    149 001124       151 001127       158 001130


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
