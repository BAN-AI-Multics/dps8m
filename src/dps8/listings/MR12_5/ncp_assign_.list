	COMPILATION LISTING OF SEGMENT ncp_assign_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1318.7 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ncp_assign_:
       12           procedure ();
       13 
       14 /*             "ncp_assign_" -- module that contains NCP routines for managing  */
       15 /*        the assignment of the various resources that the NCP assigns to the   */
       16 /*        processes that are using the NCP.                                     */
       17 
       18 /*        Created by D. M. Wells, 1975, June 16.                                */
       19 /*        Modified by M. Grady sometime to change calling sequence to ioam      */
       20 /*        Modified by D. M. Wells, June 1976, to indirect ioam's unassign       */
       21 /*                  call thru ncp_main_ where an any_other handler is set up.  */
       22 /*        Modified by D. M. Wells, August, 1977, to use stacq builtin.          */
       23 
       24           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
       25 
       26      declare
       27          (P_devx fixed binary (12),                         /* devx used to remember process assignments      */
       28           P_proc_table_indx fixed binary (17),              /* index into process table for this slot (ret)   */
       29           P_error_code fixed binary (35))                   /* standard Multics error code                    */
       30                parameter;
       31 
       32           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
       33 
       34      declare
       35          (indx fixed binary (17),
       36           table_size fixed binary (17),
       37           err_code fixed binary (35),
       38           ncp_indx bit (36),                                /* socket indx of on to go away                   */
       39           old_processid bit (36) aligned,                   /* processid of the process that went away        */
       40           (mpr, npr, ppr, procp, sep, spr) pointer)
       41                automatic;
       42 
       43           /* * * * * BASED & TEMPLATE DECLARATIONS * * * * */
       44 
       45      declare
       46           based_ptr pointer
       47                based;
       48 
       49      declare
       50           1 proc_info_array (1) aligned based like pdt,
       51           1 socket_array (1) aligned based like socket;
       52 
       53           /* * * * * EXTERNAL STATIC DECLARATIONS  * * * * */
       54 
       55      declare
       56          (ncp_tables_$tracing_info bit (36) aligned,
       57           pds$process_group_id character (32) aligned,
       58           pds$process_id bit (36) aligned)
       59                external static;
       60 
       61      declare
       62          (ncp_tables_$meter_cells,
       63           ncp_tables_$ncp_data,
       64           ncp_tables_$proc_tbl,
       65           ncp_tables_$socket_tbl)
       66                external static;
       67 
       68      declare
       69          (error_table_$bad_index,
       70           error_table_$net_table_space)
       71                fixed binary (35) external static;
       72 
       73           /* * * * * ENTRY & PROCEDURE DECLARATIONS  * * * */
       74 
       75      declare
       76           dstint$assign_dev_index constant entry () returns (fixed bin (12)),
       77           ioam_$assign constant entry (fixed bin (12), entry, fixed bin (35)),
       78           ncp_lock_$lock_unlock constant entry (ptr, fixed bin (35)),
       79           ncp_lock_$lock_wait constant entry (ptr, fixed bin (35)),
       80           ncp_main_$ncp_process_unassign_handler constant entry (fixed bin (12), fixed bin (35)),
       81           ncp_order_$ncp_priv_order constant entry (bit (36), fixed bin (15), ptr, fixed bin (6), fixed bin (35)),
       82           ncp_trace_ constant entry options (variable);
       83 
       84      declare
       85          (addr, binary, bit, mod, null, stacq, substr)
       86                builtin;
       87 
       88           /* * * * * INCLUDE FILES * * * * * * * * * * * * */
       89 
       90           
  1     2 /*        BEGIN include file "ncp_connection_dcls.incl.pl1" --                  */
  1     3 
  1     4 /*             This include file contains declarations for the structures       */
  1     5 /*        maintained by the NCP which contain information about Host-Host       */
  1     6 /*        connections.  Currently, this is the information about sockets,       */
  1     7 /*        hosts, and requests-for-connection.                                   */
  1     8 
  1     9 /*        Originally created by D. M. Wells, Summer, 1975.                      */
  1    10 /*	Modified by B. Greenberg, Spring '78 for new leader support */
  1    11 /*	        Modified by C. Hornig, July 1979 for new host number format */
  1    12 
  1    13      declare
  1    14           1 socket aligned based,                           /* information we keep on a per-socket basis      */
  1    15              2 event_channel fixed binary (71),             /* event channel of using process                 */
  1    16              2 overseer_event_channel fixed binary (71),    /* event chanel of overseer process               */
  1    17              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    18              2 process_id bit (36) aligned,                 /* process id of using process                    */
  1    19              2 overseer_process_id bit (36) aligned,        /* process id of overseer process                 */
  1    20              2 bit_allocation fixed binary (32),            /* bit allocation outstanding on attached link    */
  1    21              2 msg_allocation fixed binary (16),            /* message allocation outstanding on link         */
  1    22 
  1    23              2 local_socket unaligned like socket.foreign_socket,     /* identification of local socket       */
  1    24              2 foreign_socket unaligned,                    /* identification of foreign socket               */
  1    25 	      3 host,				/* id of this host				*/
  1    26 	        4 net bit (8),			/* network id				*/
  1    27 	        4 host bit (8),			/* port on imp				*/
  1    28 	        4 imp bit (16),			/* imp id					*/
  1    29                 3 socket_num bit (32),                      /* actual socket number                           */
  1    30                 3 pad bit (8),
  1    31 
  1    32              2 rfc_queue fixed binary (17) unaligned,       /* RFC table index of next block for this         */
  1    33                                                             /* socket, 0 if queue is empty                    */
  1    34              2 link_number fixed binary (17) unaligned,     /* number of link assigned for connection         */
  1    35 
  1    36              2 host_entry_index fixed binary (17) unaligned,          /* index in host table of foreign       */
  1    37                                                                       /* host involved in connection          */
  1    38              2 impdim_index fixed binary (17) unaligned,    /* index by which IMPDIM knows about connection   */
  1    39              2 state bit (6) unaligned,                     /* finite-state-machine information               */
  1    40              2 byte_size bit (8) unaligned,                 /* byte-size of connections                       */
  1    41              2 send_gender bit (1) unaligned,               /* on iff this is a transmit socket               */
  1    42              2 allow_interrupts bit (1) unaligned,          /* on iff INS and INR should be signalled to user */
  1    43              2 deactivate bit (1) unaligned,                /* on iff this socket should be deactivated when  */
  1    44                                                             /* matching network messages are finally received */
  1    45              2 allow_rfc_queuing bit (1) unaligned,         /* on iff we should allow multiple outstanding    */
  1    46                                                             /* RFC's for this socket                          */
  1    47              2 extra_bits bit (12) unaligned,
  1    48 
  1    49              2 overseer_validation_level bit (3) unaligned,           /* ring of highest overseer control     */
  1    50              2 validation_level bit (3) unaligned,                    /* ring of highest operator control     */
  1    51 
  1    52              2 overseer_lock_id bit (36) aligned,           /* lock id of the overseer process                */
  1    53              2 umodes bit (36) aligned,                     /* 36 bits that the users can play with           */
  1    54              2 time_state_changed fixed binary (71),        /* time that the socket state last changed        */
  1    55              2 signal_event_channel fixed binary (71),      /* chanel to signal over when get INS or INR      */
  1    56              2 socket_index bit (36) aligned,               /* the handle we gave user for future reference   */
  1    57              2 history aligned,                             /* state of socket over recent past history       */
  1    58                 3 num_state_changes fixed binary (11) unaligned,      /* small field, so only keep mod        */
  1    59                 3 prev_state (0 : 3) fixed binary (5) unaligned;      /* past N states, kept in rotation      */
  1    60 
  1    61      declare
  1    62           1 host aligned based,                             /* information we retain about a foreign host     */
  1    63              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    64              2 rcv_link_index fixed binary (17) unaligned,  /* impdim index of read link for control msgs     */
  1    65              2 xmit_link_index fixed binary (17) unaligned, /* impdim index of write link for control msgs    */
  1    66              2 read_links_assigned bit (32) unaligned,      /* a bit is on iff we have assigned that link     */
  1    67              2 read_link_padd bit (4) unaligned,
  1    68 	   2 xhost_number_pad bit (9) unaligned,
  1    69              2 host_state bit (6) unaligned,                /* stae of communications with this host          */
  1    70              2 previous_host_state bit (6) unaligned,       /* last state of this host                        */
  1    71              2 state_pad bit (15) unaligned,
  1    72              2 time_state_changed fixed binary (71),        /* time when host state last changed              */
  1    73              2 read_links_used bit (32) unaligned,          /* bit is on if link has been used "recently"     */
  1    74              2 read_link_used_pad bit (4) unaligned,
  1    75              2 num_connections fixed binary (17) unaligned, /* times we attached links for this host          */
  1    76              2 hash_index fixed binary (17) unaligned,      /* table index of this host entry                 */
  1    77 	   2 host_number fixed bin (32) aligned,	/* host number of this host			*/
  1    78 	   2 host_number_pad fixed bin (35);
  1    79 
  1    80      declare
  1    81           1 rcvd_rfc aligned based,                         /* info about a rcvd Request for Connection       */
  1    82              2 foreign_socket unaligned like socket.foreign_socket,   /* foreign socket in RFC msg            */
  1    83              2 foreign_hosts_choice fixed binary (17) unaligned,      /* link or size that other host chose   */
  1    84              2 next_entry fixed binary (17) unaligned,                /* next RFC entry in queue for socket   */
  1    85              2 padding (1) fixed binary (35);
  1    86 
  1    87      declare
  1    88 	1 host_address based aligned,			/* Form of a host address			*/
  1    89 	   2 net bit (8) unaligned,			/* Netwwork ID				*/
  1    90 	   2 host bit (8) unaligned,			/* Host Port				*/
  1    91 	   2 imp bit (16) unaligned;			/* IMP ID					*/
  1    92 				/* Duplicated because of PL/I multi-like restriction */
  1    93 
  1    94 /*        END of include file ncp_connection_dcls.incl.pl1                      */
  1    95 
       90 
       91           
  2     2 /*             "ncp_constants_dcls.incl.pl1" -- include file to       */
  2     3 /*        declare some constants used throughout the Multics Network  */
  2     4 /*        Control Program (NCP).                                      */
  2     5 
  2     6 /*        Originally created by D. M. Wells, 1975, May 19.            */
  2     7 
  2     8      declare
  2     9          (NCP_DOWN            initial (0),                  /* the NCP has been shutdown normally             */
  2    10           NCP_UP_IMP_DOWN     initial (1),                  /* the NCP is up, but the IMP is unreachable      */
  2    11           NCP_UP              initial (2),                  /* the NCP is up and running normally             */
  2    12           NCP_CRASHED         initial (-1))                 /* the NCP has crashed itself                     */
  2    13                fixed binary (3) internal static options (constant);
  2    14 
  2    15      declare
  2    16          (READ_GENDER         initial ("0"b),               /* Read sockets are even numbers                  */
  2    17           WRITE_GENDER        initial ("1"b))               /* Write sockets ar odd numbers                   */
  2    18                bit (1) internal static options (constant);
  2    19 
  2    20      declare
  2    21          (HOST_OFF            initial (0),                  /* this host is not enabled for communications    */
  2    22           HOST_UP             initial (1),                  /* Host is up and everything ok                   */
  2    23           HOST_RST            initial (2),                  /* a Host-Host RST command has been sent          */
  2    24           HOST_DOWN           initial (3),                  /* Foreign host is down                           */
  2    25           HOST_ON             initial (4))                  /* Foreign host is enabled, but not RST yet       */
  2    26                fixed binary (6) internal static options (constant);
  2    27 
  2    28      declare
  2    29          (SOCK_UNASSIGNED     initial (0),                  /* This socket entry is not in use currently      */
  2    30           SOCK_ASSIGNED       initial (1),                  /* Socket has been assigned and is quiescent      */
  2    31           SOCK_LISTENING      initial (2),                  /* Socket is listening for incoming-RFCs          */
  2    32           SOCK_RFC_RCVD       initial (3),                  /* Socket has received RFC from foreign socket    */
  2    33           SOCK_RFC_ABORTED    initial (4),                  /* CLS  received for unacknowledged RFC           */
  2    34           SOCK_RFC_SENT       initial (5),                  /* RFC sent to foreign socket, but no reply       */
  2    35           SOCK_CONNECTED      initial (6),                  /* Socket is connected to foreign socket          */
  2    36           SOCK_CLS_WAIT       initial (7),                  /* CLS issued, waiting for reply CLS              */
  2    37                                                             /* State 8 is not currently defined               */
  2    38           SOCK_DATA_WAIT      initial (9),                  /* User requested close, but data still here      */
  2    39           SOCK_RFNM_WAIT      initial (10),                 /* User requested close, but waiting on last RFNM */
  2    40           SOCK_CLS_READ       initial (11),                 /* CLS received, but data still in buffers        */
  2    41                                                             /* State 12 is not currently defined              */
  2    42           SOCK_BROKEN         initial (13),                 /* Socket has been involved in some NCP anomaly   */
  2    43           SOCK_RESET          initial (14))                 /* Socket was connected to host that was reset    */
  2    44                fixed binary (6) internal static options (constant);
  2    45 
  2    46      declare
  2    47          (SOCK_INDX_MASK      initial ("000000777777"b3),   /* mask to get out actual array index             */
  2    48           SOCK_UNIQUE_MASK    initial ("377777000000"b3))   /* mask to get out incrementing part of indx      */
  2    49                bit (36) internal static options (constant);
  2    50 
  2    51      declare
  2    52          (ANY_TRACING         initial ("400000000000"b3),             /* if any tracing is occurring          */
  2    53           PRINTER_TRACING     initial ("200000000000"b3),             /* if tracing to the ptr is happening   */
  2    54           SYSERR_LOG_TRACING  initial ("100000000000"b3),             /* if tracing to syserr log mechanism   */
  2    55 
  2    56           TRACE_CTL_MSGS      initial ("004000000000"b3),             /* if host-host ctl msgs should be trcd */
  2    57           TRACE_PROCESS_INFO  initial ("002000000000"b3),             /* if process control should be trcd    */
  2    58           TRACE_DATA_FLOW     initial ("001000000000"b3),             /* if flow of user data to be traced    */
  2    59 
  2    60           TRACE_NCP_RING      initial ("000400000000"b3),             /* if ncp_ring_ should be traced        */
  2    61           TRACE_NCP_ACCESS    initial ("000200000000"b3),             /* if ncp_access_ should be traced      */
  2    62           TRACE_NCP_DAEMON    initial ("000100000000"b3),             /* if ncp_daemon_ should be traced      */
  2    63           TRACE_NCP_CONTROL   initial ("000040000000"b3),             /* if ncp_control_ should be traced     */
  2    64           TRACE_NCP_TBOP      initial ("000020000000"b3),             /* if ncp_tbop_ should be traced        */
  2    65           TRACE_NCP_IO        initial ("000010000000"b3))             /* if ncp_io_ should be traced          */
  2    66                bit (36) aligned internal static options (constant);
  2    67 
  2    68 /*        end of include file "ncp_constants_dcls.incl.pl1            */
  2    69 
       91 
       92           
  3     2 /*        BEGIN include file ncp_data_dcls.incl.pl1 --                          */
  3     3 
  3     4 /*             This include file contains declarations of structures kept       */
  3     5 /*        in the NCP data base which aren't associated directly with            */
  3     6 /*        Network connections or process control.                               */
  3     7 
  3     8 /*        Originally created by D. M. Wells, Jan., 1976 by altering a           */
  3     9 /*                  previously existing include file.                           */
  3    10      declare
  3    11           1 ncp_dt aligned based,                           /* Information about global state of NCP          */
  3    12              2 ncp_ev_chan fixed binary (71),               /* event channel id of NCP Daemon process         */
  3    13              2 ncp_procid bit (36),                         /* process id of NCP Daemon process               */
  3    14              2 ncp_up fixed binary (2),                     /* -1 crashed, 0 uninit, 1 imp down, 2 up         */
  3    15              2 htbl_size fixed binary (17),                 /* max size of host table in entries              */
  3    16              2 rtbl_size fixed binary (17),                 /* max size of RFC table in entries               */
  3    17              2 stbl_size fixed binary (17),                 /* max size of socket table in entries            */
  3    18              2 size_pad fixed binary (17),
  3    19 
  3    20              2 htbl_gent fixed binary (17),                 /* max host entry used                            */
  3    21              2 rtbl_gent fixed binary (17),                 /* max RFC entry used                             */
  3    22              2 stbl_gent fixed binary (17),                 /* max socket entry used                          */
  3    23              2 gent_pad fixed binary (17),
  3    24 
  3    25              2 htbl_lock bit (36) aligned,                  /* lock for host table                            */
  3    26              2 rtbl_lock bit (36) aligned,                  /* lock for RFC table                             */
  3    27              2 stbl_lock bit (36) aligned,                  /* lock for socket table                          */
  3    28              2 lock_pad bit (36) aligned,
  3    29 
  3    30              2 state_change_reason character (32) unaligned,          /* reason for last state change         */
  3    31 
  3    32              2 ncp_devx fixed binary (12),                  /* IOAM devx of NCP pseudo-device                 */
  3    33              2 ncp_state_changes fixed binary (17),         /* number of times NCP has changed state          */
  3    34              2 spacen1 (14) fixed fixed binary (35),
  3    35 
  3    36              2 host_id fixed binary (32),                   /* network identifier of this Multics System      */
  3    37              2 crash_on_ncp_error bit (1) aligned,          /* on if should crash to trap ncp error */
  3    38              2 imp_state char (8) aligned,
  3    39              2 time_imp_state_changed fixed binary (71),
  3    40              2 time_ncp_state_changed fixed binary (71),
  3    41 
  3    42              2 imp_special_message bit (32),
  3    43              2 imp_state_change_count fixed binary (17),
  3    44              2 spacen3 (3) fixed binary (17),
  3    45              2 ptbl_size fixed binary (17),                 /* number of entries in process table             */
  3    46              2 ptbl_gent fixed binary (17),                 /* index of highest slot in use                   */
  3    47              2 ptbl_lock bit (36) aligned,                  /* lock word for "proc_tb"                        */
  3    48 
  3    49              2 access_dirname character (168) unaligned,              /* dir of access defining segment       */
  3    50              2 access_ename character (32) unaligned;                 /* entry of access defining segment     */
  3    51 
  3    52      declare
  3    53           1 meter_dt aligned based,                         /* various meters kept by the NCP                 */
  3    54              2 prev_user_call_time fixed binary (71),
  3    55              2 prev_daemon_call_time fixed binary (71),
  3    56              2 accu_time_in_ncp fixed binary (71),
  3    57              2 accu_time_since_user_call fixed binary (71),
  3    58 
  3    59              2 nprocs_in_ncp fixed binary (17),
  3    60              2 nprocs_inconsistent bit (1),
  3    61              2 ndaemon_calls fixed binary (17),
  3    62              2 ncalls (5) fixed binary (17),
  3    63 
  3    64              2 net_error_count fixed binary (17),
  3    65              2 ncp_wakeup_count (7) fixed binary (17),
  3    66 
  3    67              2 call_count (0: 31) fixed binary (17),
  3    68 
  3    69              2 ctl_mess_count (0: 15) fixed binary (17),
  3    70 
  3    71              2 tbop_mf_count (48) fixed binary (17),
  3    72 
  3    73              2 eco_time fixed binary (71),
  3    74              2 erp_time fixed binary (71),
  3    75              2 eco_host fixed binary (16),
  3    76              2 erp_host fixed binary (16),
  3    77              2 num_activations fixed binary (30),           /* number of socket activations performed         */
  3    78              2 num_processes fixed binary (30);             /* number of processes using the NCP              */
  3    79 
  3    80 /*        END include file ncp_data_dcls.incl.pl1 --                            */
  3    81 
       92 
       93           
  4     2 /*        BEGIN include file ncp_process_dcls.incl.pl1 --                       */
  4     3 
  4     4 /*             This include file contains declarations of per-process data.     */
  4     5 
  4     6 /*        Originally created by D. M. Wells, Jan, 1976 from a previously        */
  4     7 /*                  existing include file.                                      */
  4     8 
  4     9      declare
  4    10           1 gdt aligned based,                              /* this holds data to/from outside world          */
  4    11              2 init_sw fixed binary (30),                   /* set to 620998 iff initialized properly.        */
  4    12                                                             /* This particular value has  no significance     */
  4    13              2 error_code fixed binary (35),                /* a code returned by internal modules            */
  4    14              2 request_code fixed binary (12),              /* type of request to be performed (input)        */
  4    15              2 ncp_idx bit (36) unaligned,                  /* handle of socket to be manipulated (input)     */
  4    16              2 state fixed binary (6),                      /* state of the socket (output)                   */
  4    17              2 privilege_code fixed binary (2),             /* = 0 unpriv, = 1 priv, = 2 daemon               */
  4    18              2 nbytes fixed binary (24),                    /* number of bytes of data presented (input)      */
  4    19              2 nelemt fixed binary (24),                    /* number of bytes transmitted (output)           */
  4    20 
  4    21              2 areap pointer,                               /* pointer to a supplied area (input)             */
  4    22              2 fsoc bit (64) unaligned,                     /* foreign socket associated with this request    */
  4    23              2 fsoc_pad bit (8) unaligned,
  4    24              2 abort_location label,                        /* label to goto on procedure abort               */
  4    25 
  4    26              2 host_tbl_index fixed binary (17),            /* host_tbl index of foreign host                 */
  4    27              2 proc_id_arg bit (36),                        /* process id argument                            */
  4    28              2 entry_time fixed binary (71),                /* time NCP was entered by this call              */
  4    29              2 entry_type fixed binary (17),                /* 1, 2 daemon; 3 userid; 4 process_rq;           */
  4    30                                                             /* 5 global_chnchn; 6 socket_state; 7 micro       */
  4    31              2 nprocs_sw fixed binary (30),                 /* = 459248 if nprocs cell was properly set       */
  4    32              2 event_chn fixed binary (71),                 /* event_channel argument                         */
  4    33 
  4    34              2 proc_tbp pointer,                            /* pointer to this process's static info block    */
  4    35              2 global_queue aligned,                        /* impdim global queue info struct                */
  4    36                 3 gq_type fixed binary (17),                /* imp_global_state substructure begins here      */
  4    37                 3 gq_imp_state character (8) unaligned,     /* state of our IMP (up, down?)                   */
  4    38                 3 gq_message bit (32) aligned,              /* special message sent by IMP                    */
  4    39 
  4    40                 3 gq_imp_index fixed binary (17),           /* imp_dim index of this link                     */
  4    41                 3 gq_host_id fixed binary (32),             /* host identifier of a foreign host              */
  4    42                 3 gq_link fixed binary (8),                 /* link number of this link                       */
  4    43                 3 gq_status aligned,                        /* of this link returned by imp_global_state      */
  4    44                    4 sba (0 : 17) bit (1) unaligned,        /* status bits from imp dim                       */
  4    45 
  4    46              2 spaceg2 (14) fixed binary (17);
  4    47 
  4    48      declare
  4    49           1 pdt aligned based,                              /* information about each process using NCP       */
  4    50              2 gdtp pointer,                                /* points to this call's global_data base         */
  4    51              2 returnp label,                               /* return label for non-local error goto          */
  4    52 
  4    53              2 multuid character (32) unaligned,            /* process group id                               */
  4    54 
  4    55              2 netuid bit (24),                             /* Network id of this process                     */
  4    56              2 lockid bit (36),                             /* lock id of process,  = ""b iff unassigned      */
  4    57              2 processid bit (36),                          /* process id of this process                     */
  4    58              2 error_recur fixed binary (17),               /* number of ncp error recursions                 */
  4    59              2 global_ev_chn fixed binary (71),             /* this process gets changes of NCP state         */
  4    60              2 num_activations fixed binary (17),
  4    61              2 proc_devx fixed binary (12),
  4    62              2 spacep2 (2) fixed binary (17);
  4    63 
  4    64      declare
  4    65           1 error_snapshot aligned based,                   /* snapshot of process info for an NCP error      */
  4    66              2 ewho character (32) unaligned,               /* process group id of detecting process          */
  4    67              2 econdition character (32) unaligned,         /* condition signalled                            */
  4    68 
  4    69              2 etime fixed binary (71),                     /* time of error                                  */
  4    70              2 error_number fixed binary (17),
  4    71              2 spacee1 (5) fixed binary (17),
  4    72 
  4    73              2 mc_cond (32) bit (36) aligned,               /* machine conditions                             */
  4    74              2 if_data (8) fixed binary (17),               /* space for software supplied data               */
  4    75              2 proc_slot aligned like pdt,                  /* copy of proc_tbl entry for this process        */
  4    76              2 gdt_data aligned like gdt,                   /* copy of ncp_global_data at time of error       */
  4    77              2 associated_data (24) bit (36) aligned;       /* add'l info -- usually copy of socket entry     */
  4    78 
  4    79 /*        END include file ncp_process_dcls.incl.pl1 --                         */
  4    80 
       93 
       94 
       95 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
       96 
       97 make_process_slot:
       98           entry (P_proc_table_indx, P_error_code);
       99 
      100 
      101           P_error_code = 0;
      102           npr = addr (ncp_tables_$ncp_data);
      103           ppr = addr (ncp_tables_$proc_tbl);
      104 
      105           table_size = npr -> ncp_dt.ptbl_size;
      106 
      107           do indx = 1 by 1 to table_size
      108                     while (^ stacq (ppr -> proc_info_array (indx).processid, pds$process_id, (36)"0"b));
      109                end;
      110           if indx > table_size
      111           then do;
      112                P_error_code = error_table_$net_table_space;
      113                return;
      114                end;
      115 
      116           procp = addr (ppr -> proc_info_array (indx));
      117 
      118           mpr = addr (ncp_tables_$meter_cells);
      119           mpr -> meter_dt.num_processes = mpr -> meter_dt.num_processes + 1;
      120                                                             /*      We've now got a process table entry, we   */
      121                                                             /* must fill it in.  Notice that we've already    */
      122                                                             /* got the process id filled in.                  */
      123 
      124           if procp -> pdt.proc_devx = 0
      125           then procp -> pdt.proc_devx = dstint$assign_dev_index ();   /* get ioam index if none already       */
      126 
      127           procp -> pdt.lockid = pds$process_id;
      128 
      129           procp -> pdt.error_recur = 0;
      130           procp -> pdt.multuid = pds$process_group_id;
      131           procp -> pdt.gdtp, addr (procp -> pdt.returnp) -> based_ptr = null ();
      132           procp -> pdt.global_ev_chn = 0;
      133           procp -> pdt.num_activations = 0;
      134 
      135           procp -> pdt.netuid = "010"b || bit (binary (indx, 12)) || substr (procp -> pdt.processid, 28, 9);
      136 
      137           if ncp_tables_$tracing_info ^= ""b
      138           then call ncp_trace_ (TRACE_PROCESS_INFO, "Process slot ^d (netuid ^d) assigned to process ^w (^a)",
      139                          indx, binary (procp -> pdt.netuid, 24), pds$process_id, pds$process_group_id);
      140 
      141           call ioam_$assign (procp -> pdt.proc_devx, ncp_main_$ncp_process_unassign_handler, err_code);
      142           if err_code ^= 0
      143           then do;
      144                call unassign_resources_by_devx (procp -> pdt.proc_devx, (0));
      145                P_error_code = err_code;
      146                return;
      147                end;
      148 
      149           do while (indx > npr -> ncp_dt.ptbl_gent);
      150                npr -> ncp_dt.ptbl_gent = npr -> ncp_dt.ptbl_gent + 1;
      151                end;
      152 
      153           P_proc_table_indx = indx;
      154 
      155           return;
      156 
      157           /* * * * * * * * * * * * * * * * * * * * * * * * */
      158 
      159 unassign_resources_by_devx:
      160           entry (P_devx, P_error_code);
      161 
      162           P_error_code = 0;
      163 
      164           npr = addr (ncp_tables_$ncp_data);
      165           ppr = addr (ncp_tables_$proc_tbl);
      166           spr = addr (ncp_tables_$socket_tbl);
      167 
      168           table_size = npr -> ncp_dt.ptbl_size;
      169           do indx = 1 by 1 to table_size
      170                     while (ppr -> proc_info_array (indx).proc_devx ^= P_devx);
      171                end;
      172           if indx > table_size
      173           then do;
      174                P_error_code = error_table_$bad_index;
      175                return;
      176                end;
      177 
      178           procp = addr (ppr -> proc_info_array (indx));
      179           old_processid = procp -> pdt.processid;
      180 
      181           if ncp_tables_$tracing_info ^= ""b
      182           then call ncp_trace_ (TRACE_PROCESS_INFO, "Freeing process slot ^d (devx ^d, process ^w -- ^a)",
      183                          indx, P_devx, old_processid, procp -> pdt.multuid);
      184 
      185           if ^ stacq (procp -> pdt.processid, (36)"0"b, old_processid)
      186           then;                                             /* ignore success or failure of unlocking         */
      187 
      188           procp = null ();                                  /* fault if we should reference through this ptr  */
      189 
      190           do indx = 1 by 1 to npr -> ncp_dt.stbl_gent;
      191                sep = addr (spr -> socket_array (indx));
      192 
      193                if sep -> socket.overseer_process_id = old_processid
      194                then do;
      195                     call ncp_lock_$lock_wait (addr (sep -> socket.lock), (0));
      196                                                             /* we really should check here that still same processid    */
      197 
      198                     sep -> socket.socket_index = sep -> socket.socket_index | SOCK_UNIQUE_MASK;
      199                                                             /* make unique part all on so user cant get it    */
      200                                                             /* accidentally                                   */
      201                     sep -> socket.overseer_validation_level, sep -> socket.validation_level = "000"b;
      202 
      203                     sep -> socket.deactivate = "1"b;
      204 
      205                     ncp_indx = sep -> socket.socket_index;
      206 
      207                     call ncp_lock_$lock_unlock (addr (sep -> socket.lock), (0));
      208 
      209                     call ncp_order_$ncp_priv_order (ncp_indx, 3, null (), (0), (0));
      210                     end;
      211                end;
      212 
      213           return;
      214 
      215 end;      /* end ncp_assign_                               */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1129.4  ncp_assign_.pl1                   >dumps>old_dumps>hardcore>ncp_assign_.pl1
90           1    09/05/79  2206.3  ncp_connection_dcls.incl.pl1      >ldd>include>ncp_connection_dcls.incl.pl1
91           2    10/07/77  1700.0  ncp_constants_dcls.incl.pl1       >ldd>include>ncp_constants_dcls.incl.pl1
92           3    07/24/78  1704.7  ncp_data_dcls.incl.pl1            >ldd>include>ncp_data_dcls.incl.pl1
93           4    07/24/78  1704.7  ncp_process_dcls.incl.pl1         >ldd>include>ncp_process_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_devx                                 parameter       fixed bin(12,0)          dcl 26 set ref 159 169 181*
P_error_code                           parameter       fixed bin(35,0)          dcl 26 set ref 97 101* 112* 145* 159 162* 174*
P_proc_table_indx                      parameter       fixed bin(17,0)          dcl 26 set ref 97 153*
SOCK_UNIQUE_MASK                       constant        bit(36)                  initial unaligned dcl 2-46 ref 198
TRACE_PROCESS_INFO              000000 constant        bit(36)                  initial dcl 2-51 set ref 137* 181*
addr                                                   builtin function         dcl 84 ref 102 103 116 118 131 164 165 166 178 191
                                                                                  195 195 207 207
based_ptr                              based           pointer                  dcl 45 set ref 131*
binary                                                 builtin function         dcl 84 ref 135 137 137
bit                                                    builtin function         dcl 84 ref 135
deactivate               17(16)        based           bit(1)                   level 2 packed unaligned dcl 1-13 set ref 203*
dstint$assign_dev_index         000032 constant        entry                    external dcl 75 ref 124
err_code                        000102 automatic       fixed bin(35,0)          dcl 34 set ref 141* 142 145
error_recur              21            based           fixed bin(17,0)          level 2 dcl 4-48 set ref 129*
error_table_$bad_index          000026 external static fixed bin(35,0)          dcl 68 ref 174
error_table_$net_table_space    000030 external static fixed bin(35,0)          dcl 68 ref 112
foreign_socket           13            based           structure                level 2 in structure "socket" packed unaligned
                                                                                  dcl 1-13 in procedure "ncp_assign_"
foreign_socket           13            based           structure                array level 2 in structure "socket_array" packed
                                                                                  unaligned dcl 49 in procedure "ncp_assign_"
gdt                                    based           structure                level 1 dcl 4-9
gdtp                                   based           pointer                  level 2 dcl 4-48 set ref 131*
global_ev_chn            22            based           fixed bin(71,0)          level 2 dcl 4-48 set ref 132*
indx                            000100 automatic       fixed bin(17,0)          dcl 34 set ref 107* 107* 110 116 135 137* 149 153
                                                                                  169* 169* 172 178 181* 190* 191*
ioam_$assign                    000034 constant        entry                    external dcl 75 ref 141
lock                      4            based           bit(36)                  level 2 dcl 1-13 set ref 195 195 207 207
lockid                   17            based           bit(36)                  level 2 dcl 4-48 set ref 127*
meter_dt                               based           structure                level 1 dcl 3-52
mpr                             000106 automatic       pointer                  dcl 34 set ref 118* 119 119
multuid                   6            based           char(32)                 level 2 packed unaligned dcl 4-48 set ref 130* 181*
ncp_dt                                 based           structure                level 1 dcl 3-10
ncp_indx                        000103 automatic       bit(36)                  unaligned dcl 34 set ref 205* 209*
ncp_lock_$lock_unlock           000036 constant        entry                    external dcl 75 ref 207
ncp_lock_$lock_wait             000040 constant        entry                    external dcl 75 ref 195
ncp_main_$ncp_process_unassign_handler
                                000042 constant        entry                    external dcl 75 ref 141 141
ncp_order_$ncp_priv_order       000044 constant        entry                    external dcl 75 ref 209
ncp_tables_$meter_cells         000016 external static fixed bin(17,0)          dcl 61 set ref 118
ncp_tables_$ncp_data            000020 external static fixed bin(17,0)          dcl 61 set ref 102 164
ncp_tables_$proc_tbl            000022 external static fixed bin(17,0)          dcl 61 set ref 103 165
ncp_tables_$socket_tbl          000024 external static fixed bin(17,0)          dcl 61 set ref 166
ncp_tables_$tracing_info        000010 external static bit(36)                  dcl 55 ref 137 181
ncp_trace_                      000046 constant        entry                    external dcl 75 ref 137 181
netuid                   16            based           bit(24)                  level 2 dcl 4-48 set ref 135* 137 137
npr                             000110 automatic       pointer                  dcl 34 set ref 102* 105 149 150 150 164* 168 190
null                                                   builtin function         dcl 84 ref 131 188 209 209
num_activations          24            based           fixed bin(17,0)          level 2 dcl 4-48 set ref 133*
num_processes           177            based           fixed bin(30,0)          level 2 dcl 3-52 set ref 119* 119
old_processid                   000104 automatic       bit(36)                  dcl 34 set ref 179* 181* 185 193
overseer_process_id       6            based           bit(36)                  level 2 dcl 1-13 ref 193
overseer_validation_level
                         17(30)        based           bit(3)                   level 2 packed unaligned dcl 1-13 set ref 201*
pds$process_group_id            000012 external static char(32)                 dcl 55 set ref 130 137*
pds$process_id                  000014 external static bit(36)                  dcl 55 set ref 107 127 137*
pdt                                    based           structure                level 1 dcl 4-48
ppr                             000112 automatic       pointer                  dcl 34 set ref 103* 107 116 165* 169 178
proc_devx                25            based           fixed bin(12,0)          level 2 in structure "pdt" dcl 4-48 in procedure
                                                                                  "ncp_assign_" set ref 124 124* 141* 144*
proc_devx                25            based           fixed bin(12,0)          array level 2 in structure "proc_info_array" dcl 49
                                                                                  in procedure "ncp_assign_" set ref 169
proc_info_array                        based           structure                array level 1 dcl 49 set ref 116 178
processid                20            based           bit(36)                  level 2 in structure "pdt" dcl 4-48 in procedure
                                                                                  "ncp_assign_" ref 135 179 185
processid                20            based           bit(36)                  array level 2 in structure "proc_info_array" dcl 49
                                                                                  in procedure "ncp_assign_" set ref 107
procp                           000114 automatic       pointer                  dcl 34 set ref 116* 124 124 127 129 130 131 131 132
                                                                                  133 135 135 137 137 141 144 178* 179 181 185 188*
ptbl_gent                66            based           fixed bin(17,0)          level 2 dcl 3-10 set ref 149 150* 150
ptbl_size                65            based           fixed bin(17,0)          level 2 dcl 3-10 ref 105 168
returnp                   2            based           label variable           level 2 dcl 4-48 set ref 131
sep                             000116 automatic       pointer                  dcl 34 set ref 191* 193 195 195 198 198 201 201 203
                                                                                  205 207 207
socket                                 based           structure                level 1 dcl 1-13
socket_array                           based           structure                array level 1 dcl 49 set ref 191
socket_index             26            based           bit(36)                  level 2 dcl 1-13 set ref 198* 198 205
spr                             000120 automatic       pointer                  dcl 34 set ref 166* 191
stacq                                                  builtin function         dcl 84 ref 107 185
stbl_gent                12            based           fixed bin(17,0)          level 2 dcl 3-10 ref 190
substr                                                 builtin function         dcl 84 ref 135
table_size                      000101 automatic       fixed bin(17,0)          dcl 34 set ref 105* 107 110 168* 169 172
validation_level         17(33)        based           bit(3)                   level 2 packed unaligned dcl 1-13 set ref 201*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_TRACING                            internal static bit(36)                  initial dcl 2-51
HOST_DOWN                              internal static fixed bin(6,0)           initial dcl 2-20
HOST_OFF                               internal static fixed bin(6,0)           initial dcl 2-20
HOST_ON                                internal static fixed bin(6,0)           initial dcl 2-20
HOST_RST                               internal static fixed bin(6,0)           initial dcl 2-20
HOST_UP                                internal static fixed bin(6,0)           initial dcl 2-20
NCP_CRASHED                            internal static fixed bin(3,0)           initial dcl 2-8
NCP_DOWN                               internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP                                 internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP_IMP_DOWN                        internal static fixed bin(3,0)           initial dcl 2-8
PRINTER_TRACING                        internal static bit(36)                  initial dcl 2-51
READ_GENDER                            internal static bit(1)                   initial unaligned dcl 2-15
SOCK_ASSIGNED                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_BROKEN                            internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CLS_READ                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CLS_WAIT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CONNECTED                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_DATA_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_INDX_MASK                         internal static bit(36)                  initial unaligned dcl 2-46
SOCK_LISTENING                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RESET                             internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_ABORTED                       internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_RCVD                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_SENT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFNM_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_UNASSIGNED                        internal static fixed bin(6,0)           initial dcl 2-28
SYSERR_LOG_TRACING                     internal static bit(36)                  initial dcl 2-51
TRACE_CTL_MSGS                         internal static bit(36)                  initial dcl 2-51
TRACE_DATA_FLOW                        internal static bit(36)                  initial dcl 2-51
TRACE_NCP_ACCESS                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_CONTROL                      internal static bit(36)                  initial dcl 2-51
TRACE_NCP_DAEMON                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_IO                           internal static bit(36)                  initial dcl 2-51
TRACE_NCP_RING                         internal static bit(36)                  initial dcl 2-51
TRACE_NCP_TBOP                         internal static bit(36)                  initial dcl 2-51
WRITE_GENDER                           internal static bit(1)                   initial unaligned dcl 2-15
error_snapshot                         based           structure                level 1 dcl 4-64
host                                   based           structure                level 1 dcl 1-61
host_address                           based           structure                level 1 dcl 1-87
mod                                                    builtin function         dcl 84
rcvd_rfc                               based           structure                level 1 dcl 1-80

NAMES DECLARED BY EXPLICIT CONTEXT.
make_process_slot               000064 constant        entry                    external dcl 97
ncp_assign_                     000052 constant        entry                    external dcl 11
unassign_resources_by_devx      000323 constant        entry                    external dcl 159 ref 144

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1036        1106     570        1046
Length      1400     570        50         256     246           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ncp_assign_                         134 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ncp_assign_              000100 indx                        ncp_assign_
                         000101 table_size                  ncp_assign_
                         000102 err_code                    ncp_assign_
                         000103 ncp_indx                    ncp_assign_
                         000104 old_processid               ncp_assign_
                         000106 mpr                         ncp_assign_
                         000110 npr                         ncp_assign_
                         000112 ppr                         ncp_assign_
                         000114 procp                       ncp_assign_
                         000116 sep                         ncp_assign_
                         000120 spr                         ncp_assign_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         call_ext_out_desc   call_ext_out        return              ext_entry           stacq

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dstint$assign_dev_index       ioam_$assign                  ncp_lock_$lock_unlock         ncp_lock_$lock_wait
ncp_main_$ncp_process_unassign_handler                      ncp_order_$ncp_priv_order     ncp_trace_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_index        error_table_$net_table_space  ncp_tables_$meter_cells       ncp_tables_$ncp_data
ncp_tables_$proc_tbl          ncp_tables_$socket_tbl        ncp_tables_$tracing_info      pds$process_group_id
pds$process_id


CONSTANTS
000563  aa     777777777770

000564  aa     777777777707

000566  aa     077777000043
000567  aa     000001000000

000000  aa     002000000000

000001  aa     526000000040

000002  aa     524000000063

000003  aa     524000000040

000004  aa     404000000030

000005  aa     524000000067

000006  aa     514000000044

000007  aa     404000000043

000010  aa     404000000021

000011  aa     404000000014

000012  aa     000000000000
000013  aa     000000000000

000014  aa     077777000043
000015  aa     000001000000

000016  aa  106 162 145 145	Free
000017  aa  151 156 147 040	ing 
000020  aa  160 162 157 143	proc
000021  aa  145 163 163 040	ess 
000022  aa  163 154 157 164	slot
000023  aa  040 136 144 040	 ^d 
000024  aa  050 144 145 166	(dev
000025  aa  170 040 136 144	x ^d
000026  aa  054 040 160 162	, pr
000027  aa  157 143 145 163	oces
000030  aa  163 040 136 167	s ^w
000031  aa  040 055 055 040	 -- 
000032  aa  136 141 051 000	^a)

000033  aa  120 162 157 143	Proc
000034  aa  145 163 163 040	ess 
000035  aa  163 154 157 164	slot
000036  aa  040 136 144 040	 ^d 
000037  aa  050 156 145 164	(net
000040  aa  165 151 144 040	uid 
000041  aa  136 144 051 040	^d) 
000042  aa  141 163 163 151	assi
000043  aa  147 156 145 144	gned
000044  aa  040 164 157 040	 to 
000045  aa  160 162 157 143	proc
000046  aa  145 163 163 040	ess 
000047  aa  136 167 040 050	^w (
000050  aa  136 141 051 000	^a)

BEGIN PROCEDURE ncp_assign_
ENTRY TO ncp_assign_                                        STATEMENT 1 ON LINE 11
ncp_assign_:
          procedure ();

000051  da     000220200000
000052  aa   000220 6270 00	eax7 	144
000053  aa  7 00034 3521 20	epp2 	pr7|28,*
000054  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000055  aa     000000000000
000056  aa     000000000000
						STATEMENT 1 ON LINE 97
make_process_slot:
          entry (P_proc_table_indx, P_error_code);

000057  aa   000012 7100 04	tra  	10,ic		000071
ENTRY TO make_process_slot                                  STATEMENT 1 ON LINE 97
make_process_slot:
          entry (P_proc_table_indx, P_error_code);

000060  at     000002000010
000061  ta     000007000000
000062  ta     000060000000
000063  da     000230300000
000064  aa   000220 6270 00	eax7 	144
000065  aa  7 00034 3521 20	epp2 	pr7|28,*
000066  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000067  aa     000004000000
000070  aa     000000000000
						STATEMENT 1 ON LINE 101
          P_error_code = 0;

000071  aa  6 00032 3735 20	epp7 	pr6|26,*
000072  aa  7 00004 4501 20	stz  	pr7|4,*		P_error_code
						STATEMENT 1 ON LINE 102
          npr = addr (ncp_tables_$ncp_data);

000073  la  4 00020 3715 20	epp5 	pr4|16,*		ncp_tables_$ncp_data
000074  aa  6 00110 6515 00	spri5	pr6|72		npr
						STATEMENT 1 ON LINE 103
          ppr = addr (ncp_tables_$proc_tbl);

000075  la  4 00022 3535 20	epp3 	pr4|18,*		ncp_tables_$proc_tbl
000076  aa  6 00112 2535 00	spri3	pr6|74		ppr
						STATEMENT 1 ON LINE 105
          table_size = npr -> ncp_dt.ptbl_size;

000077  aa  5 00065 2361 00	ldq  	pr5|53		ncp_dt.ptbl_size
000100  aa  6 00101 7561 00	stq  	pr6|65		table_size
						STATEMENT 1 ON LINE 107
          do indx = 1 by 1 to table_size
                    while (^ stacq (ppr -> proc_info_array (indx).processid, pds$process_id, (36)"0"b));

000101  aa  6 00122 7561 00	stq  	pr6|82
000102  aa   000001 2360 07	ldq  	1,dl
000103  aa  6 00100 7561 00	stq  	pr6|64		indx
000104  aa  6 00100 2361 00	ldq  	pr6|64		indx
000105  aa  6 00122 1161 00	cmpq 	pr6|82
000106  aa   000013 6054 04	tpnz 	11,ic		000121
000107  aa   000030 4020 07	mpy  	24,dl
000110  aa  6 00044 3701 20	epp4 	pr6|36,*
000111  la  4 00014 2351 20	lda  	pr4|12,*		pds$process_id
000112  aa  6 00112 3735 20	epp7 	pr6|74,*		ppr
000113  aa  7 77770 3521 06	epp2 	pr7|-8,ql		proc_info_array.processid
000114  aa   000000 2360 07	ldq  	0,dl
000115  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000116  aa   000003 6010 04	tnz  	3,ic		000121
						STATEMENT 1 ON LINE 109
               end;

000117  aa  6 00100 0541 00	aos  	pr6|64		indx
000120  aa   777764 7100 04	tra  	-12,ic		000104
						STATEMENT 1 ON LINE 110
          if indx > table_size
          then do;

000121  aa  6 00100 2361 00	ldq  	pr6|64		indx
000122  aa  6 00101 1161 00	cmpq 	pr6|65		table_size
000123  aa   000006 6044 04	tmoz 	6,ic		000131
						STATEMENT 1 ON LINE 112
               P_error_code = error_table_$net_table_space;

000124  aa  6 00044 3701 20	epp4 	pr6|36,*
000125  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$net_table_space
000126  aa  6 00032 3735 20	epp7 	pr6|26,*
000127  aa  7 00004 7561 20	stq  	pr7|4,*		P_error_code
						STATEMENT 1 ON LINE 113
               return;

000130  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 114
               end;

						STATEMENT 1 ON LINE 116
          procp = addr (ppr -> proc_info_array (indx));

000131  aa   000030 4020 07	mpy  	24,dl
000132  aa  6 00112 3735 20	epp7 	pr6|74,*		ppr
000133  aa  7 77750 3735 06	epp7 	pr7|-24,ql	proc_info_array
000134  aa  6 00114 6535 00	spri7	pr6|76		procp
						STATEMENT 1 ON LINE 118
          mpr = addr (ncp_tables_$meter_cells);

000135  aa  6 00044 3701 20	epp4 	pr6|36,*
000136  la  4 00016 3715 20	epp5 	pr4|14,*		ncp_tables_$meter_cells
000137  aa  6 00106 6515 00	spri5	pr6|70		mpr
						STATEMENT 1 ON LINE 119
          mpr -> meter_dt.num_processes = mpr -> meter_dt.num_processes + 1;

000140  aa  5 00177 0541 00	aos  	pr5|127		meter_dt.num_processes
						STATEMENT 1 ON LINE 124
          if procp -> pdt.proc_devx = 0
          then procp -> pdt.proc_devx = dstint$assign_dev_index ();

000141  aa  7 00025 2361 00	ldq  	pr7|21		pdt.proc_devx
000142  aa   000007 6010 04	tnz  	7,ic		000151
000143  aa  7 00025 3521 00	epp2 	pr7|21		pdt.proc_devx
000144  aa  6 00130 2521 00	spri2	pr6|88
000145  aa  6 00126 6211 00	eax1 	pr6|86
000146  aa   004000 4310 07	fld  	2048,dl
000147  la  4 00032 3521 20	epp2 	pr4|26,*		dstint$assign_dev_index
000150  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 127
          procp -> pdt.lockid = pds$process_id;

000151  aa  6 00044 3701 20	epp4 	pr6|36,*
000152  la  4 00014 2351 20	lda  	pr4|12,*		pds$process_id
000153  aa  6 00114 3735 20	epp7 	pr6|76,*		procp
000154  aa  7 00017 7551 00	sta  	pr7|15		pdt.lockid
						STATEMENT 1 ON LINE 129
          procp -> pdt.error_recur = 0;

000155  aa  7 00021 4501 00	stz  	pr7|17		pdt.error_recur
						STATEMENT 1 ON LINE 130
          procp -> pdt.multuid = pds$process_group_id;

000156  la  4 00012 3715 20	epp5 	pr4|10,*		pds$process_group_id
000157  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000160  aa  5 00000 00 0040	desc9a	pr5|0,32		pds$process_group_id
000161  aa  7 00006 00 0040	desc9a	pr7|6,32		pdt.multuid
						STATEMENT 1 ON LINE 131
          procp -> pdt.gdtp, addr (procp -> pdt.returnp) -> based_ptr = null ();

000162  aa   777632 3534 24	epp3 	-102,ic*
000163  aa  7 00000 2535 00	spri3	pr7|0		pdt.gdtp
000164  aa  7 00002 2535 00	spri3	pr7|2		based_ptr
						STATEMENT 1 ON LINE 132
          procp -> pdt.global_ev_chn = 0;

000165  aa   777625 2370 04	ldaq 	-107,ic		000012 = 000000000000 000000000000
000166  aa  7 00022 7571 00	staq 	pr7|18		pdt.global_ev_chn
						STATEMENT 1 ON LINE 133
          procp -> pdt.num_activations = 0;

000167  aa  7 00024 4501 00	stz  	pr7|20		pdt.num_activations
						STATEMENT 1 ON LINE 135
          procp -> pdt.netuid = "010"b || bit (binary (indx, 12)) || substr (procp -> pdt.processid, 28, 9);

000170  aa  6 00100 2351 00	lda  	pr6|64		indx
000171  aa   000002 6050 04	tpl  	2,ic		000173
000172  aa   000000 5310 00	neg  	0
000173  aa   000030 7350 00	als  	24
000174  aa   000003 7710 00	arl  	3
000175  aa   200000 2750 03	ora  	65536,du
000176  aa  6 00125 7551 00	sta  	pr6|85
000177  aa  7 00020 2351 00	lda  	pr7|16		pdt.processid
000200  aa   000033 7350 00	als  	27
000201  aa   000017 7710 00	arl  	15
000202  aa  6 00125 2751 00	ora  	pr6|85
000203  aa  7 00016 7551 00	sta  	pr7|14		pdt.netuid
						STATEMENT 1 ON LINE 137
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_PROCESS_INFO, "Process slot ^d (netuid ^d) assigned to process ^w (^a)",
                         indx, binary (procp -> pdt.netuid, 24), pds$process_id, pds$process_group_id);

000204  la  4 00010 2351 20	lda  	pr4|8,*		ncp_tables_$tracing_info
000205  aa   000041 6000 04	tze  	33,ic		000246
000206  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000207  aa   777625 00 0070	desc9a	-107,56		000033 = 120162157143
000210  aa  6 00134 00 0070	desc9a	pr6|92,56
000211  aa  7 00016 2351 00	lda  	pr7|14		pdt.netuid
000212  aa   000060 7730 00	lrl  	48
000213  aa  6 00125 7561 00	stq  	pr6|85
000214  aa   777564 3520 04	epp2 	-140,ic		000000 = 002000000000
000215  aa  6 00154 2521 00	spri2	pr6|108
000216  aa  6 00134 3521 00	epp2 	pr6|92
000217  aa  6 00156 2521 00	spri2	pr6|110
000220  aa  6 00100 3521 00	epp2 	pr6|64		indx
000221  aa  6 00160 2521 00	spri2	pr6|112
000222  aa  6 00125 3521 00	epp2 	pr6|85
000223  aa  6 00162 2521 00	spri2	pr6|114
000224  la  4 00014 3521 20	epp2 	pr4|12,*		pds$process_id
000225  aa  6 00164 2521 00	spri2	pr6|116
000226  aa  6 00166 6515 00	spri5	pr6|118
000227  aa   777557 3520 04	epp2 	-145,ic		000006 = 514000000044
000230  aa  6 00170 2521 00	spri2	pr6|120
000231  aa  6 00200 2521 00	spri2	pr6|128
000232  aa   777553 3520 04	epp2 	-149,ic		000005 = 524000000067
000233  aa  6 00172 2521 00	spri2	pr6|122
000234  aa   777554 3520 04	epp2 	-148,ic		000010 = 404000000021
000235  aa  6 00174 2521 00	spri2	pr6|124
000236  aa   777546 3520 04	epp2 	-154,ic		000004 = 404000000030
000237  aa  6 00176 2521 00	spri2	pr6|126
000240  aa   777543 3520 04	epp2 	-157,ic		000003 = 524000000040
000241  aa  6 00202 2521 00	spri2	pr6|130
000242  aa  6 00152 6211 00	eax1 	pr6|106
000243  aa   030000 4310 07	fld  	12288,dl
000244  la  4 00046 3521 20	epp2 	pr4|38,*		ncp_trace_
000245  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 141
          call ioam_$assign (procp -> pdt.proc_devx, ncp_main_$ncp_process_unassign_handler, err_code);

000246  aa  6 00044 3701 20	epp4 	pr6|36,*
000247  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_main_$ncp_process_unassign_handler
000250  aa  6 00126 2521 00	spri2	pr6|86		cp.174
000251  aa   000315 2370 04	ldaq 	205,ic		000566 = 077777000043 000001000000
000252  aa  6 00130 7571 00	staq 	pr6|88		cp.174
000253  aa  6 00114 3735 20	epp7 	pr6|76,*		procp
000254  aa  7 00025 3521 00	epp2 	pr7|21		pdt.proc_devx
000255  aa  6 00136 2521 00	spri2	pr6|94
000256  aa  6 00126 3521 00	epp2 	pr6|86		cp.174
000257  aa  6 00140 2521 00	spri2	pr6|96
000260  aa  6 00102 3521 00	epp2 	pr6|66		err_code
000261  aa  6 00142 2521 00	spri2	pr6|98
000262  aa  6 00134 6211 00	eax1 	pr6|92
000263  aa   014000 4310 07	fld  	6144,dl
000264  la  4 00034 3521 20	epp2 	pr4|28,*		ioam_$assign
000265  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 142
          if err_code ^= 0
          then do;

000266  aa  6 00102 2361 00	ldq  	pr6|66		err_code
000267  aa   000017 6000 04	tze  	15,ic		000306
						STATEMENT 1 ON LINE 144
               call unassign_resources_by_devx (procp -> pdt.proc_devx, (0));

000270  aa  6 00125 4501 00	stz  	pr6|85
000271  aa  6 00114 3735 20	epp7 	pr6|76,*		procp
000272  aa  7 00025 3521 00	epp2 	pr7|21		pdt.proc_devx
000273  aa  6 00136 2521 00	spri2	pr6|94
000274  aa  6 00125 3521 00	epp2 	pr6|85
000275  aa  6 00140 2521 00	spri2	pr6|96
000276  aa  6 00134 6211 00	eax1 	pr6|92
000277  aa   010000 4310 07	fld  	4096,dl
000300  aa   000023 3520 04	epp2 	19,ic		000323 = 000220627000
000301  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 145
               P_error_code = err_code;

000302  aa  6 00102 2361 00	ldq  	pr6|66		err_code
000303  aa  6 00032 3735 20	epp7 	pr6|26,*
000304  aa  7 00004 7561 20	stq  	pr7|4,*		P_error_code
						STATEMENT 1 ON LINE 146
               return;

000305  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 147
               end;

						STATEMENT 1 ON LINE 149
          do while (indx > npr -> ncp_dt.ptbl_gent);

000306  aa  6 00100 2361 00	ldq  	pr6|64		indx
000307  aa  6 00110 3735 20	epp7 	pr6|72,*		npr
000310  aa  7 00066 1161 00	cmpq 	pr7|54		ncp_dt.ptbl_gent
000311  aa   000003 6044 04	tmoz 	3,ic		000314
						STATEMENT 1 ON LINE 150
               npr -> ncp_dt.ptbl_gent = npr -> ncp_dt.ptbl_gent + 1;

000312  aa  7 00066 0541 00	aos  	pr7|54		ncp_dt.ptbl_gent
						STATEMENT 1 ON LINE 151
               end;

000313  aa   777773 7100 04	tra  	-5,ic		000306
						STATEMENT 1 ON LINE 153
          P_proc_table_indx = indx;

000314  aa  6 00032 3715 20	epp5 	pr6|26,*
000315  aa  5 00002 7561 20	stq  	pr5|2,*		P_proc_table_indx
						STATEMENT 1 ON LINE 155
          return;

000316  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO unassign_resources_by_devx                         STATEMENT 1 ON LINE 159
unassign_resources_by_devx:
          entry (P_devx, P_error_code);

000317  at     000002000011
000320  ta     000007000000
000321  ta     000317000000
000322  da     000242300000
000323  aa   000220 6270 00	eax7 	144
000324  aa  7 00034 3521 20	epp2 	pr7|28,*
000325  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000326  aa     000004000000
000327  aa     000000000000
						STATEMENT 1 ON LINE 162
          P_error_code = 0;

000330  aa  6 00032 3735 20	epp7 	pr6|26,*
000331  aa  7 00004 4501 20	stz  	pr7|4,*		P_error_code
						STATEMENT 1 ON LINE 164
          npr = addr (ncp_tables_$ncp_data);

000332  aa  6 00044 3701 20	epp4 	pr6|36,*
000333  la  4 00020 3715 20	epp5 	pr4|16,*		ncp_tables_$ncp_data
000334  aa  6 00110 6515 00	spri5	pr6|72		npr
						STATEMENT 1 ON LINE 165
          ppr = addr (ncp_tables_$proc_tbl);

000335  la  4 00022 3535 20	epp3 	pr4|18,*		ncp_tables_$proc_tbl
000336  aa  6 00112 2535 00	spri3	pr6|74		ppr
						STATEMENT 1 ON LINE 166
          spr = addr (ncp_tables_$socket_tbl);

000337  la  4 00024 3515 20	epp1 	pr4|20,*		ncp_tables_$socket_tbl
000340  aa  6 00120 2515 00	spri1	pr6|80		spr
						STATEMENT 1 ON LINE 168
          table_size = npr -> ncp_dt.ptbl_size;

000341  aa  5 00065 2361 00	ldq  	pr5|53		ncp_dt.ptbl_size
000342  aa  6 00101 7561 00	stq  	pr6|65		table_size
						STATEMENT 1 ON LINE 169
          do indx = 1 by 1 to table_size
                    while (ppr -> proc_info_array (indx).proc_devx ^= P_devx);

000343  aa  6 00123 7561 00	stq  	pr6|83
000344  aa   000001 2360 07	ldq  	1,dl
000345  aa  6 00100 7561 00	stq  	pr6|64		indx
000346  aa  6 00100 2361 00	ldq  	pr6|64		indx
000347  aa  6 00123 1161 00	cmpq 	pr6|83
000350  aa   000011 6054 04	tpnz 	9,ic		000361
000351  aa   000030 4020 07	mpy  	24,dl
000352  aa  6 00112 3735 20	epp7 	pr6|74,*		ppr
000353  aa  7 77775 2361 06	ldq  	pr7|-3,ql		proc_info_array.proc_devx
000354  aa  6 00032 3715 20	epp5 	pr6|26,*
000355  aa  5 00002 1161 20	cmpq 	pr5|2,*		P_devx
000356  aa   000003 6000 04	tze  	3,ic		000361
						STATEMENT 1 ON LINE 171
               end;

000357  aa  6 00100 0541 00	aos  	pr6|64		indx
000360  aa   777766 7100 04	tra  	-10,ic		000346
						STATEMENT 1 ON LINE 172
          if indx > table_size
          then do;

000361  aa  6 00100 2361 00	ldq  	pr6|64		indx
000362  aa  6 00101 1161 00	cmpq 	pr6|65		table_size
000363  aa   000006 6044 04	tmoz 	6,ic		000371
						STATEMENT 1 ON LINE 174
               P_error_code = error_table_$bad_index;

000364  aa  6 00044 3701 20	epp4 	pr6|36,*
000365  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$bad_index
000366  aa  6 00032 3735 20	epp7 	pr6|26,*
000367  aa  7 00004 7561 20	stq  	pr7|4,*		P_error_code
						STATEMENT 1 ON LINE 175
               return;

000370  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 176
               end;

						STATEMENT 1 ON LINE 178
          procp = addr (ppr -> proc_info_array (indx));

000371  aa   000030 4020 07	mpy  	24,dl
000372  aa  6 00112 3735 20	epp7 	pr6|74,*		ppr
000373  aa  7 77750 3735 06	epp7 	pr7|-24,ql	proc_info_array
000374  aa  6 00114 6535 00	spri7	pr6|76		procp
						STATEMENT 1 ON LINE 179
          old_processid = procp -> pdt.processid;

000375  aa  7 00020 2351 00	lda  	pr7|16		pdt.processid
000376  aa  6 00104 7551 00	sta  	pr6|68		old_processid
						STATEMENT 1 ON LINE 181
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_PROCESS_INFO, "Freeing process slot ^d (devx ^d, process ^w -- ^a)",
                         indx, P_devx, old_processid, procp -> pdt.multuid);

000377  aa  6 00044 3701 20	epp4 	pr6|36,*
000400  la  4 00010 2351 20	lda  	pr4|8,*		ncp_tables_$tracing_info
000401  aa   000040 6000 04	tze  	32,ic		000441
000402  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000403  aa   777414 00 0064	desc9a	-244,52		000016 = 106162145145
000404  aa  6 00134 00 0064	desc9a	pr6|92,52
000405  aa   777373 3520 04	epp2 	-261,ic		000000 = 002000000000
000406  aa  6 00154 2521 00	spri2	pr6|108
000407  aa  6 00134 3521 00	epp2 	pr6|92
000410  aa  6 00156 2521 00	spri2	pr6|110
000411  aa  6 00100 3521 00	epp2 	pr6|64		indx
000412  aa  6 00160 2521 00	spri2	pr6|112
000413  aa  6 00032 3715 20	epp5 	pr6|26,*
000414  aa  5 00002 3521 20	epp2 	pr5|2,*		P_devx
000415  aa  6 00162 2521 00	spri2	pr6|114
000416  aa  6 00104 3521 00	epp2 	pr6|68		old_processid
000417  aa  6 00164 2521 00	spri2	pr6|116
000420  aa  7 00006 3521 00	epp2 	pr7|6		pdt.multuid
000421  aa  6 00166 2521 00	spri2	pr6|118
000422  aa   777364 3520 04	epp2 	-268,ic		000006 = 514000000044
000423  aa  6 00170 2521 00	spri2	pr6|120
000424  aa  6 00200 2521 00	spri2	pr6|128
000425  aa   777355 3520 04	epp2 	-275,ic		000002 = 524000000063
000426  aa  6 00172 2521 00	spri2	pr6|122
000427  aa   777361 3520 04	epp2 	-271,ic		000010 = 404000000021
000430  aa  6 00174 2521 00	spri2	pr6|124
000431  aa   777360 3520 04	epp2 	-272,ic		000011 = 404000000014
000432  aa  6 00176 2521 00	spri2	pr6|126
000433  aa   777346 3520 04	epp2 	-282,ic		000001 = 526000000040
000434  aa  6 00202 2521 00	spri2	pr6|130
000435  aa  6 00152 6211 00	eax1 	pr6|106
000436  aa   030000 4310 07	fld  	12288,dl
000437  la  4 00046 3521 20	epp2 	pr4|38,*		ncp_trace_
000440  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 185
          if ^ stacq (procp -> pdt.processid, (36)"0"b, old_processid)
          then;

000441  aa   000000 2350 07	lda  	0,dl
000442  aa  6 00114 3735 20	epp7 	pr6|76,*		procp
000443  aa  7 00020 3521 00	epp2 	pr7|16		pdt.processid
000444  aa  6 00104 2361 00	ldq  	pr6|68		old_processid
000445  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000446  aa   000001 6010 04	tnz  	1,ic		000447
						STATEMENT 1 ON LINE 188
          procp = null ();

000447  aa   777345 2370 04	ldaq 	-283,ic		000014 = 077777000043 000001000000
000450  aa  6 00114 7571 00	staq 	pr6|76		procp
						STATEMENT 1 ON LINE 190
          do indx = 1 by 1 to npr -> ncp_dt.stbl_gent;

000451  aa  6 00110 3735 20	epp7 	pr6|72,*		npr
000452  aa  7 00012 2361 00	ldq  	pr7|10		ncp_dt.stbl_gent
000453  aa  6 00124 7561 00	stq  	pr6|84
000454  aa   000001 2360 07	ldq  	1,dl
000455  aa  6 00100 7561 00	stq  	pr6|64		indx
000456  aa  6 00100 2361 00	ldq  	pr6|64		indx
000457  aa  6 00124 1161 00	cmpq 	pr6|84
000460  aa   000102 6054 04	tpnz 	66,ic		000562
						STATEMENT 1 ON LINE 191
               sep = addr (spr -> socket_array (indx));

000461  aa   000030 4020 07	mpy  	24,dl
000462  aa  6 00120 3735 20	epp7 	pr6|80,*		spr
000463  aa  7 77750 3735 06	epp7 	pr7|-24,ql	socket_array
000464  aa  6 00116 6535 00	spri7	pr6|78		sep
						STATEMENT 1 ON LINE 193
               if sep -> socket.overseer_process_id = old_processid
               then do;

000465  aa  7 00006 2351 00	lda  	pr7|6		socket.overseer_process_id
000466  aa  6 00104 1151 00	cmpa 	pr6|68		old_processid
000467  aa   000071 6010 04	tnz  	57,ic		000560
						STATEMENT 1 ON LINE 195
                    call ncp_lock_$lock_wait (addr (sep -> socket.lock), (0));

000470  aa  7 00004 3715 00	epp5 	pr7|4		socket.lock
000471  aa  6 00132 6515 00	spri5	pr6|90
000472  aa  6 00125 4501 00	stz  	pr6|85
000473  aa  6 00132 3521 00	epp2 	pr6|90
000474  aa  6 00136 2521 00	spri2	pr6|94
000475  aa  6 00125 3521 00	epp2 	pr6|85
000476  aa  6 00140 2521 00	spri2	pr6|96
000477  aa  6 00134 6211 00	eax1 	pr6|92
000500  aa   010000 4310 07	fld  	4096,dl
000501  aa  6 00044 3701 20	epp4 	pr6|36,*
000502  la  4 00040 3521 20	epp2 	pr4|32,*		ncp_lock_$lock_wait
000503  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 198
                    sep -> socket.socket_index = sep -> socket.socket_index | SOCK_UNIQUE_MASK;

000504  aa   377777 2350 03	lda  	131071,du
000505  aa  6 00116 3735 20	epp7 	pr6|78,*		sep
000506  aa  7 00026 2551 00	orsa 	pr7|22		socket.socket_index
						STATEMENT 1 ON LINE 201
                    sep -> socket.overseer_validation_level, sep -> socket.validation_level = "000"b;

000507  aa   000055 2350 04	lda  	45,ic		000564 = 777777777707
000510  aa  7 00017 3551 00	ansa 	pr7|15		socket.overseer_validation_level
000511  aa   000052 2350 04	lda  	42,ic		000563 = 777777777770
000512  aa  7 00017 3551 00	ansa 	pr7|15		socket.validation_level
						STATEMENT 1 ON LINE 203
                    sep -> socket.deactivate = "1"b;

000513  aa   000002 2350 03	lda  	2,du
000514  aa  7 00017 2551 00	orsa 	pr7|15		socket.deactivate
						STATEMENT 1 ON LINE 205
                    ncp_indx = sep -> socket.socket_index;

000515  aa  7 00026 2351 00	lda  	pr7|22		socket.socket_index
000516  aa  6 00103 7551 00	sta  	pr6|67		ncp_indx
						STATEMENT 1 ON LINE 207
                    call ncp_lock_$lock_unlock (addr (sep -> socket.lock), (0));

000517  aa  7 00004 3715 00	epp5 	pr7|4		socket.lock
000520  aa  6 00132 6515 00	spri5	pr6|90
000521  aa  6 00125 4501 00	stz  	pr6|85
000522  aa  6 00132 3521 00	epp2 	pr6|90
000523  aa  6 00136 2521 00	spri2	pr6|94
000524  aa  6 00125 3521 00	epp2 	pr6|85
000525  aa  6 00140 2521 00	spri2	pr6|96
000526  aa  6 00134 6211 00	eax1 	pr6|92
000527  aa   010000 4310 07	fld  	4096,dl
000530  aa  6 00044 3701 20	epp4 	pr6|36,*
000531  la  4 00036 3521 20	epp2 	pr4|30,*		ncp_lock_$lock_unlock
000532  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 209
                    call ncp_order_$ncp_priv_order (ncp_indx, 3, null (), (0), (0));

000533  aa   000003 2360 07	ldq  	3,dl
000534  aa  6 00125 7561 00	stq  	pr6|85
000535  aa   777257 3734 24	epp7 	-337,ic*
000536  aa  6 00132 6535 00	spri7	pr6|90
000537  aa  6 00204 4501 00	stz  	pr6|132
000540  aa  6 00205 4501 00	stz  	pr6|133
000541  aa  6 00103 3521 00	epp2 	pr6|67		ncp_indx
000542  aa  6 00136 2521 00	spri2	pr6|94
000543  aa  6 00125 3521 00	epp2 	pr6|85
000544  aa  6 00140 2521 00	spri2	pr6|96
000545  aa  6 00132 3521 00	epp2 	pr6|90
000546  aa  6 00142 2521 00	spri2	pr6|98
000547  aa  6 00204 3521 00	epp2 	pr6|132
000550  aa  6 00144 2521 00	spri2	pr6|100
000551  aa  6 00205 3521 00	epp2 	pr6|133
000552  aa  6 00146 2521 00	spri2	pr6|102
000553  aa  6 00134 6211 00	eax1 	pr6|92
000554  aa   024000 4310 07	fld  	10240,dl
000555  aa  6 00044 3701 20	epp4 	pr6|36,*
000556  la  4 00044 3521 20	epp2 	pr4|36,*		ncp_order_$ncp_priv_order
000557  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 210
                    end;

						STATEMENT 1 ON LINE 211
               end;

000560  aa  6 00100 0541 00	aos  	pr6|64		indx
000561  aa   777675 7100 04	tra  	-67,ic		000456
						STATEMENT 1 ON LINE 213
          return;

000562  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 215
end;

  END PROCEDURE ncp_assign_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
