	COMPILATION LISTING OF SEGMENT log_create_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1024.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 log_create_:
        9      procedure ();
       10 
       11 /* *	LOG_CREATE_
       12*   *
       13*   *	This procedure is used primarily to create log segments. It is the
       14*   *	major maintainer of the log_segment_info structure, and therefore
       15*   *	also has an entrypoint for filling in such a structure.
       16*   *
       17*   *	Modification history:
       18*   *	1984-06-02, W. Olin Sibert: Initial coding
       19*   *	1984-12-20, WOS: Added mode values to segment_info structure
       20*   *	1984-12-21, WOS: Changed to give better message for link entries
       21*   *	1984-12-27, Keith Loepere: Modified for version 2 create_branch_info
       22*   */
       23 
       24 declare	P_log_segment_info_ptr pointer parameter;
       25 declare	P_old_log_ptr pointer parameter;
       26 declare	P_new_log_ptr pointer parameter;
       27 declare	P_log_dname char (*) parameter;
       28 declare	P_log_ename char (*) parameter;
       29 declare	P_code fixed bin (35) parameter;
       30 
       31 declare	code fixed bin (35);
       32 declare	old_log_dname char (168);
       33 
       34 declare   error_table_$link fixed bin (35) external static;
       35 declare   error_table_$namedup fixed bin (35) external static;
       36 
       37 declare	get_system_free_area_ entry () returns (pointer);
       38 declare	get_group_id_$tag_star entry () returns (char (32));
       39 declare	hcs_$create_branch_ entry (char (*), char (*), pointer, fixed bin (35));
       40 declare	hcs_$fs_get_path_name entry (pointer, char (*), fixed bin, char (*), fixed bin (35));
       41 declare	hcs_$get_max_length_seg entry (pointer, fixed bin (19), fixed bin (35));
       42 declare	hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), pointer, fixed bin (35));
       43 declare	hcs_$list_acl entry (char (*), char (*), pointer, pointer, pointer, fixed bin, fixed bin (35));
       44 declare	hcs_$replace_acl entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
       45 declare	hcs_$set_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35));
       46 declare	hcs_$status_for_backup entry (char (*), char (*), pointer, fixed bin (35));
       47 declare	hcs_$status_long entry (char (*), char (*), fixed bin (1), pointer, pointer, fixed bin (35));
       48 declare   hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
       49 declare	log_initialize_ entry (pointer, pointer, fixed bin (19), char (*), fixed bin (35));
       50 
       51 declare  (addr, null, substr, unspec) builtin;
       52 
       53 /* */
       54 
       55 /* This entrypoint just fills in a log_segment_info structure to describe the
       56*   segment specified. This is used wby log_write_. */
       57 
       58 log_create_$get_info:
       59      entry (P_log_segment_info_ptr, P_old_log_ptr, P_code);
       60 
       61 	log_segment_info_ptr = P_log_segment_info_ptr;
       62 
       63 	call get_log_status (P_old_log_ptr);
       64 	call finished (0);
       65 
       66 
       67 
       68 
       69 /* This entrypoint is used to create a brand new log segment, for which there 
       70*   is no existing segment to copy. The caller must have completely filled in 
       71*   the log_segment_info structure before calling this entrypoint.
       72*   */
       73 
       74 log_create_$new_segment:
       75      entry (P_log_segment_info_ptr, P_new_log_ptr, P_code);
       76 
       77 	log_segment_info_ptr = P_log_segment_info_ptr;
       78 
       79 	call make_log_segment (null (), "", P_new_log_ptr);
       80 	call finished (0);
       81 
       82 /* */
       83 
       84 /* This entrypoint is used to duplicate an existing log segment. It copies
       85*   all the attributes of the old segment onto the new one. The dname and
       86*   ename are separately supplied for the new log, since of course we don't
       87*   want to end up tryng to create the same segment over again. */
       88 
       89 log_create_$duplicate_segment:
       90      entry (P_log_segment_info_ptr, P_log_dname, P_log_ename, P_old_log_ptr, P_new_log_ptr, P_code);
       91 
       92 	log_segment_info_ptr = P_log_segment_info_ptr;
       93 
       94 	call get_log_status (P_old_log_ptr);
       95 
       96 /* Now, extract the old pathname and insert the new one */
       97 
       98 	old_log_dname = log_segment_info.dname;
       99 
      100 	log_segment_info.dname = P_log_dname;
      101 	log_segment_info.ename = P_log_ename;
      102 
      103 	call make_log_segment (P_old_log_ptr, old_log_dname, P_new_log_ptr);
      104 	call finished (0);
      105 
      106 /* */
      107 
      108 get_log_status:
      109      procedure (P_log_ptr);
      110 
      111 declare	P_log_ptr pointer parameter;
      112 
      113 declare	log_dname char (168);
      114 declare	log_ename char (32);
      115 declare	log_max_lth fixed bin (19);
      116 declare 1 sfb aligned like status_for_backup automatic;
      117 declare 1 status aligned like status_branch automatic;
      118 
      119 
      120 	call hcs_$fs_get_path_name (P_log_ptr, log_dname, (0), log_ename, code);
      121 	call check_code ();
      122 
      123 	sfb.version = status_for_backup_version_2;
      124 	call hcs_$status_for_backup (log_dname, log_ename, addr (sfb), code);
      125 	call check_code ();
      126 
      127 	call hcs_$status_long (log_dname, log_ename, 1, addr (status), null (), code);
      128 	call check_code ();
      129 
      130 	call hcs_$list_acl (log_dname, log_ename, (get_system_free_area_ ()),
      131 	     log_segment_info.acl_ptr, null (), log_segment_info.acl_count, code);
      132 	call check_code ();
      133 
      134 	call hcs_$get_max_length_seg (P_log_ptr, log_max_lth, code);
      135 	call check_code ();
      136 
      137 	log_segment_info.rings (*) = status.ring_brackets (*);
      138 	log_segment_info.max_length = log_max_lth;	/* Not sfb.max_length, which is always 261120 */
      139 	log_segment_info.multi_class = sfb.multiple_class;
      140 	log_segment_info.access_class = sfb.access_class;
      141 
      142 /* NOTE: This depends on the format of the old 5-bit mode values, usually
      143*   seen as fixed bin (5) values. */
      144 
      145 	log_segment_info.effective_mode = substr (status.mode, 2, 3);
      146 
      147 	log_segment_info.dname = log_dname;
      148 	log_segment_info.ename = log_ename;
      149 
      150 	return;
      151 	end get_log_status;
      152 
      153 /* */
      154 
      155 make_log_segment:
      156      procedure (P_old_log_ptr, P_old_log_dname, P_new_log_ptr);
      157 
      158 declare	P_old_log_ptr pointer parameter;
      159 declare	P_old_log_dname char (168) parameter;
      160 declare	P_new_log_ptr pointer parameter;
      161 
      162 declare	log_ptr pointer;
      163 declare   entry_type fixed bin (2);
      164 
      165 declare 1 cbi aligned like create_branch_info automatic;
      166 
      167 
      168 	P_new_log_ptr = null ();
      169 
      170 	unspec (cbi) = ""b;
      171 	cbi.mode = RW_ACCESS;
      172 	cbi.bitcnt = 36 * log_segment_info.max_length;
      173 	cbi.access_class = log_segment_info.access_class;
      174 	cbi.priv_upgrade_sw = log_segment_info.multi_class;
      175 	cbi.rings (*) = log_segment_info.rings (*);
      176 	cbi.userid = get_group_id_$tag_star ();
      177 	cbi.version = create_branch_version_2;
      178 
      179 	call hcs_$create_branch_ (log_segment_info.dname, log_segment_info.ename, addr (cbi), code);
      180 	if (code = error_table_$namedup) then do;	/* Special-case error message for links */
      181 	     entry_type = -1;			/* Initialize in case status_minf fails */
      182 	     call hcs_$status_minf (log_segment_info.dname, log_segment_info.ename, 0, entry_type, (0), (0));
      183 	     if (entry_type = 0) then			/* Link type */
      184 		code = error_table_$link;
      185 	     end;
      186 
      187 	call check_code ();
      188 
      189 	call hcs_$set_max_length (log_segment_info.dname, log_segment_info.ename, log_segment_info.max_length, (0));
      190 
      191 	if (log_segment_info.acl_ptr ^= null ()) & (log_segment_info.acl_count ^= 0) then
      192 	     call hcs_$replace_acl (log_segment_info.dname, log_segment_info.ename,
      193 		log_segment_info.acl_ptr, log_segment_info.acl_count, "0"b, (0));
      194 
      195 	call hcs_$initiate (log_segment_info.dname, log_segment_info.ename, "", 0, 0, log_ptr, code);
      196 	if (log_ptr ^= null ()) then code = 0;
      197 	call check_code ();
      198 
      199 	call log_initialize_ (P_old_log_ptr, log_ptr, log_segment_info.max_length, P_old_log_dname, code);
      200 	call check_code ();
      201 
      202 	P_new_log_ptr = log_ptr;
      203 
      204 	return;
      205 	end make_log_segment;
      206 
      207 /* */
      208 
      209 check_code:
      210      procedure ();
      211 
      212 	if (code = 0) then return;
      213 
      214 	call finished (code);
      215 
      216 	end check_code;
      217 
      218 
      219 
      220 finished:
      221      procedure (P_return_code);
      222 
      223 declare	P_return_code fixed bin (35) parameter;
      224 
      225 
      226 	P_code = P_return_code;
      227 	goto MAIN_RETURN;
      228 
      229 	end finished;
      230 
      231 
      232 
      233 MAIN_RETURN:
      234 	return;
      235 
      236  /* BEGIN INCLUDE FILE ... log_write_data.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  1     2 
  1     3 declare   log_write_data_ptr            pointer;
  1     4 declare   log_segment_info_ptr          pointer;
  1     5 
  1     6 declare 1 log_write_data                aligned based (log_write_data_ptr),
  1     7           2 log_name                    char (32) unaligned,
  1     8 
  1     9           2 log_ptr                     pointer,
  1    10           2 migrating                   bit (1) aligned,
  1    11           2 pad (13)                    bit (36) aligned,
  1    12 
  1    13           2 segment_info                aligned like log_segment_info;
  1    14 
  1    15 
  1    16 declare 1 log_segment_info              aligned based (log_segment_info_ptr),
  1    17           2 dname                       char (168) unaligned,
  1    18           2 ename                       char (32) unaligned,
  1    19 
  1    20           2 acl_ptr                     pointer,
  1    21           2 acl_count                   fixed bin,
  1    22           2 rings                       (3) fixed bin (3),
  1    23           2 max_length                  fixed bin (19),
  1    24           2 access_class                bit (72) aligned,
  1    25           2 multi_class                 bit (1) aligned,
  1    26 	2 effective_mode		bit (36) aligned;
  1    27 
  1    28 /* END INCLUDE FILE ... log_write_data.incl.pl1 */
      236 
      237  /* --------------- BEGIN include file status_for_backup.incl.pl1 --------------- */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-20,Lippard), approve(86-06-02,MCR7427),
  2     6*     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
  2     7*      Change non-returned information into pad fields.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 dcl 1 status_for_backup aligned based,
  2    12     2 version fixed bin,
  2    13     2 pad1 bit (108),
  2    14     2 switches unaligned,
  2    15       3 safety bit (1) unaligned,
  2    16       3 entrypt bit (1) unaligned,
  2    17       3 security_oosw bit (1) unaligned,
  2    18       3 audit_flag bit (1) unaligned,
  2    19       3 multiple_class bit (1) unaligned,
  2    20       3 pad2 bit (2) unaligned,
  2    21       3 master_dir bit (1) unaligned,
  2    22       3 tpd bit (1) unaligned,
  2    23       3 pad13 bit (13) unaligned,
  2    24     2 entrypt_bound bit (14) unaligned,
  2    25     2 access_class bit (72),
  2    26     2 spad bit (36),
  2    27     2 author char (32),
  2    28     2 bc_author char (32),
  2    29     2 lvid bit (36),
  2    30     2 pvid bit (36),
  2    31     2 pad3 bit (216);
  2    32 
  2    33 dcl  status_for_backup_version_2 fixed bin initial (2) static options (constant);
  2    34 
  2    35 /* ---------------- END include file status_for_backup.incl.pl1 ---------------- */
      237 
      238  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  3     2 
  3     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  3     4 
  3     5 /* This include file contains branch and link structures returned by
  3     6*   hcs_$status_ and hcs_$status_long. */
  3     7 
  3     8 dcl 1 status_branch aligned based (status_ptr),
  3     9     2 short aligned,
  3    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  3    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  3    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  3    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  3    14       3 dtu bit (36) unaligned,			/* date/time last used */
  3    15       3 mode bit (5) unaligned,			/* caller's effective access */
  3    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  3    17       3 pad1 bit (8) unaligned,
  3    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  3    19 
  3    20 /* Limit of information returned by hcs_$status_ */
  3    21 
  3    22     2 long aligned,
  3    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  3    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  3    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  3    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  3    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  3    28       3 pad2 bit (8) unaligned,
  3    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  3    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  3    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  3    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  3    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  3    34       3 pad3 bit (5) unaligned,
  3    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  3    36       3 uid bit (36) unaligned;			/* unique ID */
  3    37 
  3    38 dcl 1 status_link aligned based (status_ptr),
  3    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  3    40     2 nnames fixed bin (16) unaligned unsigned,
  3    41     2 names_relp bit (18) unaligned,
  3    42     2 dtem bit (36) unaligned,
  3    43     2 dtd bit (36) unaligned,
  3    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  3    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  3    46 
  3    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  3    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  3    49 						/* array of names returned */
  3    50      status_pathname character (status_link.pathname_length) aligned
  3    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  3    52 						/* link target path */
  3    53      status_area_ptr pointer,
  3    54      status_ptr pointer;
  3    55 
  3    56 dcl (Link initial (0),
  3    57      Segment initial (1),
  3    58      Directory initial (2)) fixed bin internal static options (constant);
  3    59 						/* values for type fields declared above */
  3    60 
  3    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      238 
      239  /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  4     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  4     7*       1. Declare version constant properly.
  4     8*       2. Remove version 1 since it was never referenced and to force
  4     9*          callers to upgrade their programs.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  4    14 
  4    15 /* this include files gives the argument structure for create_branch_ */
  4    16 
  4    17 dcl 1 create_branch_info aligned based,
  4    18     2 version fixed bin,				/* set this to the largest value given below */
  4    19     2 switches unaligned,
  4    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  4    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  4    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  4    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  4    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  4    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  4    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  4    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  4    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  4    29     2 userid char (32),				/* user's access control name */
  4    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  4    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  4    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  4    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  4    34 
  4    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  4    36 
  4    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  4    38 
      239 
      240  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      240 
      241 
      242 	end log_create_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0802.0  log_create_.pl1                   >spec>install>1111>log_create_.pl1
236          1    01/21/85  0912.3  log_write_data.incl.pl1           >ldd>include>log_write_data.incl.pl1
237          2    06/17/86  1513.1  status_for_backup.incl.pl1        >ldd>include>status_for_backup.incl.pl1
238          3    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
239          4    03/16/89  2012.8  create_branch_info.incl.pl1       >ldd>include>create_branch_info.incl.pl1
240          5    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 29 set ref 58 74 89 226*
P_log_dname                            parameter       char                     packed unaligned dcl 27 ref 89 100
P_log_ename                            parameter       char                     packed unaligned dcl 28 ref 89 101
P_log_ptr                              parameter       pointer                  dcl 111 set ref 108 120* 134*
P_log_segment_info_ptr                 parameter       pointer                  dcl 24 ref 58 61 74 77 89 92
P_new_log_ptr                          parameter       pointer                  dcl 26 in procedure "log_create_" set ref 74 79* 89
                                                                                  103*
P_new_log_ptr                          parameter       pointer                  dcl 160 in procedure "make_log_segment" set ref 155
                                                                                  168* 202*
P_old_log_dname                        parameter       char(168)                packed unaligned dcl 159 set ref 155 199*
P_old_log_ptr                          parameter       pointer                  dcl 158 in procedure "make_log_segment" set ref 155
                                                                                  199*
P_old_log_ptr                          parameter       pointer                  dcl 25 in procedure "log_create_" set ref 58 63* 89
                                                                                  94* 103*
P_return_code                          parameter       fixed bin(35,0)          dcl 223 ref 220 226
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 5-11 ref 171
access_class              5     000255 automatic       bit(72)                  level 2 in structure "sfb" dcl 116 in procedure
                                                                                  "get_log_status" set ref 140
access_class             71            based           bit(72)                  level 2 in structure "log_segment_info" dcl 1-16
                                                                                  in procedure "log_create_" set ref 140* 173
access_class             20     000341 automatic       bit(72)                  level 2 in structure "cbi" dcl 165 in procedure
                                                                                  "make_log_segment" set ref 173*
acl_count                64            based           fixed bin(17,0)          level 2 dcl 1-16 set ref 130* 191 191*
acl_ptr                  62            based           pointer                  level 2 dcl 1-16 set ref 130* 191 191*
addr                                                   builtin function         dcl 51 ref 124 124 127 127 179 179
bitcnt                   16     000341 automatic       fixed bin(24,0)          level 2 dcl 165 set ref 172*
cbi                             000341 automatic       structure                level 1 dcl 165 set ref 170* 179 179
code                            000100 automatic       fixed bin(35,0)          dcl 31 set ref 120* 124* 127* 130* 134* 179* 180
                                                                                  183* 195* 196* 199* 212 214*
create_branch_info                     based           structure                level 1 dcl 4-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 4-35 ref 177
dname                                  based           char(168)                level 2 packed packed unaligned dcl 1-16 set ref 98
                                                                                  100* 147* 179* 182* 189* 191* 195*
effective_mode           74            based           bit(36)                  level 2 dcl 1-16 set ref 145*
ename                    52            based           char(32)                 level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  101* 148* 179* 182* 189* 191* 195*
entry_type                      000340 automatic       fixed bin(2,0)           dcl 163 set ref 181* 182* 183
error_table_$link               000010 external static fixed bin(35,0)          dcl 34 ref 183
error_table_$namedup            000012 external static fixed bin(35,0)          dcl 35 ref 180
get_group_id_$tag_star          000016 constant        entry                    external dcl 38 ref 176
get_system_free_area_           000014 constant        entry                    external dcl 37 ref 130
hcs_$create_branch_             000020 constant        entry                    external dcl 39 ref 179
hcs_$fs_get_path_name           000022 constant        entry                    external dcl 40 ref 120
hcs_$get_max_length_seg         000024 constant        entry                    external dcl 41 ref 134
hcs_$initiate                   000026 constant        entry                    external dcl 42 ref 195
hcs_$list_acl                   000030 constant        entry                    external dcl 43 ref 130
hcs_$replace_acl                000032 constant        entry                    external dcl 44 ref 191
hcs_$set_max_length             000034 constant        entry                    external dcl 45 ref 189
hcs_$status_for_backup          000036 constant        entry                    external dcl 46 ref 124
hcs_$status_long                000040 constant        entry                    external dcl 47 ref 127
hcs_$status_minf                000042 constant        entry                    external dcl 48 ref 182
log_dname                       000172 automatic       char(168)                packed unaligned dcl 113 set ref 120* 124* 127* 130*
                                                                                  147
log_ename                       000244 automatic       char(32)                 packed unaligned dcl 114 set ref 120* 124* 127* 130*
                                                                                  148
log_initialize_                 000044 constant        entry                    external dcl 49 ref 199
log_max_lth                     000254 automatic       fixed bin(19,0)          dcl 115 set ref 134* 138
log_ptr                         000336 automatic       pointer                  dcl 162 set ref 195* 196 199* 202
log_segment_info                       based           structure                level 1 dcl 1-16
log_segment_info_ptr            000154 automatic       pointer                  dcl 1-4 set ref 61* 77* 92* 98 100 101 130 130 137
                                                                                  138 139 140 145 147 148 172 173 174 175 179 179
                                                                                  182 182 189 189 189 191 191 191 191 191 191 195
                                                                                  195 199
max_length               70            based           fixed bin(19,0)          level 2 dcl 1-16 set ref 138* 172 189* 199*
mode                      2     000341 automatic       bit(3)                   level 2 packed packed unaligned dcl 165 set ref 171*
multi_class              73            based           bit(1)                   level 2 dcl 1-16 set ref 139* 174
multiple_class            4(04) 000255 automatic       bit(1)                   level 3 packed packed unaligned dcl 116 set ref 139
null                                                   builtin function         dcl 51 ref 79 79 127 127 130 130 168 191 196
old_log_dname                   000101 automatic       char(168)                packed unaligned dcl 32 set ref 98* 103*
priv_upgrade_sw           1(03) 000341 automatic       bit(1)                   level 3 packed packed unaligned dcl 165 set ref 174*
rings                    65            based           fixed bin(3,0)           array level 2 in structure "log_segment_info"
                                                                                  dcl 1-16 in procedure "log_create_" set ref 137*
                                                                                  175
rings                     3     000341 automatic       fixed bin(3,0)           array level 2 in structure "cbi" dcl 165
                                                                                  in procedure "make_log_segment" set ref 175*
sfb                             000255 automatic       structure                level 1 dcl 116 set ref 124 124
status                          000315 automatic       structure                level 1 dcl 117 set ref 127 127
status_branch                          based           structure                level 1 dcl 3-8
status_for_backup                      based           structure                level 1 dcl 2-11
status_for_backup_version_2            constant        fixed bin(17,0)          initial dcl 2-33 ref 123
substr                                                 builtin function         dcl 51 ref 145
switches                  1     000341 automatic       structure                level 2 in structure "cbi" packed packed unaligned
                                                                                  dcl 165 in procedure "make_log_segment"
switches                  4     000255 automatic       structure                level 2 in structure "sfb" packed packed unaligned
                                                                                  dcl 116 in procedure "get_log_status"
unspec                                                 builtin function         dcl 51 set ref 170*
userid                    6     000341 automatic       char(32)                 level 2 dcl 165 set ref 176*
version                         000341 automatic       fixed bin(17,0)          level 2 in structure "cbi" dcl 165 in procedure
                                                                                  "make_log_segment" set ref 177*
version                         000255 automatic       fixed bin(17,0)          level 2 in structure "sfb" dcl 116 in procedure
                                                                                  "get_log_status" set ref 123*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 5-33
Directory                              internal static fixed bin(17,0)          initial dcl 3-56
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
Link                                   internal static fixed bin(17,0)          initial dcl 3-56
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
Segment                                internal static fixed bin(17,0)          initial dcl 3-56
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
log_write_data                         based           structure                level 1 dcl 1-6
log_write_data_ptr                     automatic       pointer                  dcl 1-3
status_area_ptr                        automatic       pointer                  dcl 3-47
status_entry_names                     based           char(32)                 array dcl 3-47
status_link                            based           structure                level 1 dcl 3-38
status_pathname                        based           char                     dcl 3-47
status_ptr                             automatic       pointer                  dcl 3-47

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000227 constant        label                    dcl 233 set ref 227
check_code                      001102 constant        entry                    internal dcl 209 ref 121 125 128 132 135 187 197 200
finished                        001111 constant        entry                    internal dcl 220 ref 64 80 104 214
get_log_status                  000230 constant        entry                    internal dcl 108 ref 63 94
log_create_                     000017 constant        entry                    external dcl 8
log_create_$duplicate_segment   000132 constant        entry                    external dcl 89
log_create_$get_info            000031 constant        entry                    external dcl 58
log_create_$new_segment         000063 constant        entry                    external dcl 74
make_log_segment                000516 constant        entry                    internal dcl 155 ref 79 103

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1416        1464    1132        1426
Length      1772    1132        46         271     263           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_create_                         496 external procedure  is an external procedure.  
get_log_status                          internal procedure  shares stack frame of external procedure log_create_.  
make_log_segment                        internal procedure  shares stack frame of external procedure log_create_.  
check_code                              internal procedure  shares stack frame of external procedure log_create_.  
finished                                internal procedure  shares stack frame of external procedure log_create_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
log_create_              000100 code                        log_create_
                         000101 old_log_dname               log_create_
                         000154 log_segment_info_ptr        log_create_
                         000172 log_dname                   get_log_status
                         000244 log_ename                   get_log_status
                         000254 log_max_lth                 get_log_status
                         000255 sfb                         get_log_status
                         000315 status                      get_log_status
                         000336 log_ptr                     make_log_segment
                         000340 entry_type                  make_log_segment
                         000341 cbi                         make_log_segment

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_$tag_star        get_system_free_area_         hcs_$create_branch_           hcs_$fs_get_path_name
hcs_$get_max_length_seg       hcs_$initiate                 hcs_$list_acl                 hcs_$replace_acl
hcs_$set_max_length           hcs_$status_for_backup        hcs_$status_long              hcs_$status_minf
log_initialize_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$link             error_table_$namedup




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      8 000016        58 000024        61 000043        63 000047        64 000055        74 000060        77 000075
     79 000101        80 000120        89 000123        92 000161        94 000165        98 000173       100 000177
    101 000205       103 000212       104 000224       233 000227       108 000230       120 000232       121 000264
    123 000265       124 000267       125 000316       127 000317       128 000361       130 000362       132 000433
    134 000434       135 000450       137 000451       138 000472       139 000474       140 000500       145 000503
    147 000507       148 000512       150 000515       155 000516       168 000520       170 000522       171 000525
    172 000531       173 000535       174 000541       175 000546       176 000553       177 000565       179 000567
    180 000617       181 000623       182 000625       183 000665       187 000672       189 000673       191 000722
    195 000771       196 001035       197 001042       199 001043       200 001075       202 001076       204 001101
    209 001102       212 001103       214 001106       216 001110       220 001111       226 001113       227 001115


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
