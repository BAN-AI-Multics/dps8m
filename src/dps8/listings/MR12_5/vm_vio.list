	COMPILATION LISTING OF SEGMENT vm_vio
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1027.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-01-16,Fawcett), approve(86-04-11,MCR7383),
       15*     audit(86-05-28,Beattie), install(86-07-17,MR12.0-1097):
       16*     Add support for 512_WORD_IO devices, 3380 and 3390.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 vm_vio: proc;
       21 
       22 /* original coding 9/75 by Bensoussan. Use of linear 256k seg for access changed
       23*   5/76 by Kobziar to be a table of abs segs used round robin fashion  and initialized to 64k size.
       24*   Modified 03/21/81, W. Olin Sibert, for ADP PTW formats
       25*   Modified 03/08/82, J. Bongiovanni, for new PVTE
       26*   */
       27 
       28 /* The first abs seg (first 64k) is not releasable, and its ptr is always valid.
       29*   Handling of reused addresses fits in as there is no dependence on any other abs seg  (ptr) */
       30 
       31 /* Optimized for  linearly increasing vtocx index. Only case this not true is in processing
       32*   a reused address, an event which is too infrequent (and happens only if unlucky hardware
       33*   failure during crash) to code for. Thus read ahead and write behind will cause extra work
       34*   due to possible reinitializing already written pages only in this case. */
       35 
       36 /* Note that cleanup entry now releases printer */
       37 
       38 dcl (pvtx, a_pvtx) fixed bin,
       39     (vtocx, a_vtocx, devx) fixed bin,
       40     (code, a_code) fixed bin (35);
       41 
       42 dcl  rec_size fixed bin internal static options (constant) init (1024);
       43 dcl  n_rec_per_seg fixed bin internal static options (constant) init (64);
       44 
       45 dcl  segnos_initialized bit (1) internal static init ("0"b);
       46 
       47 dcl  s (0 : 4) fixed bin internal static;		/* use 5 abs segs for addressibility */
       48 
       49 dcl 1 seg_list (0 : 4) internal static,
       50     2 basep ptr,					/* seg ptr to be used for this abs seg */
       51     2 recno fixed bin,				/* starting addr of this seg w.r.t. disk 0 */
       52     2 perm bit (1) aligned,				/* slot frozen for this disk - header ptrs remain valid */
       53     2 used bit (1) aligned;				/* indicates slot initialized */
       54 
       55 dcl  i fixed bin;
       56 dcl  ptp pointer;
       57 
       58 dcl  dseg$ (0 : 1023) fixed bin (71) external static;
       59 dcl  pds$processid ext bit (36) aligned;
       60 dcl  pvt$n_entries fixed bin external;
       61 dcl  salv_abs_seg_00$ external;
       62 dcl  salv_data$vol_read_ahead fixed bin external;
       63 dcl  sst$astl bit (36) aligned external;
       64 dcl  sst$astsize fixed bin external;
       65 dcl  1 sst$level (0 : 3) aligned external,
       66      2 ausedp bit (18) unaligned,
       67      2 no_aste bit (18) unaligned;
       68 dcl  sst$pts (0 : 3) fixed bin external;
       69 
       70 dcl  get_aste entry (fixed bin) returns (ptr);
       71 dcl  get_ptrs_$given_astep entry (ptr) returns (fixed bin (71) aligned);
       72 dcl  get_ptrs_$given_segno entry (fixed bin) returns (ptr);
       73 dcl  lock$lock_ast entry;
       74 dcl  lock$unlock_ast entry;
       75 dcl  page$cam entry;
       76 dcl  pc$cleanup entry (ptr);
       77 dcl  pc_wired$read entry (ptr, fixed bin, fixed bin);
       78 dcl  pc_wired$write entry (ptr, fixed bin, fixed bin);
       79 dcl  ptw_util_$make_disk entry (pointer, fixed bin (20));
       80 dcl  ptw_util_$make_null entry (pointer, bit (22) aligned);
       81 dcl  put_aste entry (pointer);
       82 dcl  syserr entry options (variable);
       83 dcl  thread$out entry (pointer, bit (18) unaligned);
       84 
       85 dcl (addr, addrel, baseno, baseptr, bit, divide, hbound, mod, null, ptr, fixed) builtin;
       86 
       87 dcl  cleanup condition;
       88 
       89 /*  */
       90 
       91 get_vtocep : entry (a_pvtx, a_vtocx) returns (ptr);
       92 
       93 	pvtx = a_pvtx;
       94 	vtocx = a_vtocx;
       95 	pvt_arrayp = addr (pvt$array);
       96 	devx = pvt_array (pvtx).device_type;
       97 	vtocep = GET_VTOCEP (pvtx, vtocx);
       98 
       99 	return (vtocep);
      100 
      101 
      102 
      103 
      104 
      105 
      106 init :	entry (a_pvtx, a_code) returns (ptr);
      107 
      108 	pvtx = a_pvtx;
      109 	code = 0;
      110 	pvt_arrayp = addr (pvt$array);
      111 	devx = pvt_array (pvtx).device_type;
      112 	on cleanup call CLEAN_UP;
      113 
      114 	call INIT (pvtx, code);
      115 
      116 	a_code = code;
      117 
      118 	if code ^= 0 then do; call CLEAN_UP; return (null); end;
      119 
      120 	return (seg_list (0).basep);
      121 
      122 
      123 
      124 
      125 
      126 clean_up : entry (a_pvtx);
      127 
      128 	pvtx = a_pvtx;
      129 	pvt_arrayp = addr (pvt$array);
      130 	devx = pvt_array (pvtx).device_type;
      131 	call CLEAN_UP;
      132 
      133 	return;
      134 
      135 GET_VTOCEP : procedure (pvtx, vtocx) returns (ptr);
      136 
      137 
      138 /* FUNCTION - This procedure returns a pointer to the vtoc entry whose  vtoc  index
      139*   is (vtocx) in the physical volume that has been assigned the entry number (pvtx) in
      140*   the physical volume table. */
      141 
      142 
      143 dcl  pvtx fixed bin,
      144      vtocx fixed bin;
      145 
      146 dcl  recno fixed bin;
      147 dcl  compno fixed bin;
      148 dcl  segno fixed bin;
      149 dcl  word_number fixed bin;
      150 
      151 dcl  vtoce_size fixed bin;
      152 dcl  n_vtoce_per_rec fixed bin;
      153 
      154 dcl  vtoce_ptr ptr;
      155 
      156 dcl  k fixed bin;
      157 
      158 
      159 	     if pvtx <= 0 | pvtx > pvt$n_entries then
      160 		do;
      161 		call syserr (ANNOUNCE, "vm_vio: get_vtocep: invalid pvtx: ^oo", pvtx);
      162 		return (null);
      163 	     end;
      164 	  devx = pvt_array (pvtx).device_type;
      165 
      166 
      167 /* The vtoce_size calculation is done this way so that for disk devices that
      168*   only do 512 word io will appear to have a vtoce size of 512 instead of 192
      169*   because there is only one vtoce per sector and the remaining 320 are not
      170*   used. Therefore the calculation of word_number will always point to the
      171*   begining of the vtoce. */
      172 
      173                vtoce_size = sect_per_vtoc (devx) * words_per_sect (devx);
      174 	     n_vtoce_per_rec = divide (rec_size, vtoce_size, 17, 0);
      175 	     recno = divide (vtocx, n_vtoce_per_rec, 17, 0) + VTOC_ORIGIN;
      176 	     compno = get_segno (recno);
      177 	     segno = s (compno);
      178 
      179 	     if vtocx < 0 | recno >= pvt_array (pvtx).vtoc_size then
      180 		do;
      181 		call syserr (ANNOUNCE, "vm_vio: get_vtocep: invalid vtocx ^oo on pvtx ^oo", vtocx, pvtx);
      182 		return (null);
      183 	     end;
      184 
      185 	     word_number = mod (recno, n_rec_per_seg) * rec_size
      186 		+ mod (vtocx, n_vtoce_per_rec) * vtoce_size;
      187 
      188 	     vtoce_ptr = ptr (baseptr (segno), word_number);
      189 
      190 	     k = salv_data$vol_read_ahead;
      191 	     if k > 0 then if mod (vtocx, n_vtoce_per_rec * k) = 0 then call READ_AHEAD ;
      192 
      193 	     return (vtoce_ptr);
      194 
      195 
      196 READ_AHEAD :   proc ;				/* INTERNAL TO GET_VTOCEP */
      197 
      198 
      199 
      200 dcl (r, r1, r2) fixed bin;
      201 dcl (j, n (0:1)) fixed bin;
      202 dcl  first (0:1) fixed bin;
      203 dcl  astep (0:1) ptr;
      204 dcl  index fixed bin;
      205 
      206 
      207 		r1 = recno + k;
      208 		r2 = r1 + k - 1;
      209 
      210 		n (0), n (1), j = 0;
      211 
      212 		do r = recno + 1 to r2 while (r < pvt_array (pvtx).vtoc_size);
      213 		     if mod (r, n_rec_per_seg) = 0 then j = 1;
      214 		     if r >= r1 then n (j) = n (j) + 1;
      215 		end;
      216 
      217 		do j = 0, 1;
      218 		     if n (j) > 0 then
      219 			do;
      220 			if j = 0 then astep (0) = get_ptrs_$given_segno (s (compno));
      221 			else do;
      222 			     index = get_segno (recno + n_rec_per_seg);
      223 			     astep (j) = get_ptrs_$given_segno (s (index));
      224 			end;
      225 			if j = 0 then
      226 			first (j) = mod (r1, n_rec_per_seg); else first (j) = mod (r1 + n (0), n_rec_per_seg);
      227 			if astep (j) ^= null then call pc_wired$read (astep (j), first (j), n (j));
      228 			else  call syserr  (CRASH, "vm_vio: no AST pointer at readahead.");
      229 		     end;
      230 		end;
      231 
      232 
      233 		index = mod (recno, n_rec_per_seg);
      234 		if index >= k then
      235 		     do;
      236 		     if n (0) = 0 then astep (0) = get_ptrs_$given_segno (s (compno));
      237 		     if astep (0) ^= null then call pc_wired$write (astep (0), index - k, k);
      238 		end;
      239 
      240 		return;
      241 
      242 	     end READ_AHEAD;
      243 
      244 
      245 get_segno:     proc (pageno) returns (fixed bin);
      246 
      247 dcl  pageno fixed bin;
      248 dcl  fbtemp fixed bin;
      249 
      250 		do i = 0 to hbound (s, 1);
      251 		     if seg_list (i).used then if seg_list (i).recno <= pageno
      252 			then if pageno <= seg_list (i).recno +n_rec_per_seg -1 then return (i);
      253 		end;
      254 						/* must update slot */
      255 		fbtemp = 1;
      256 						/* used to be only one loop with test for perm bit */
      257 		do i = 1 to hbound (s, 1);
      258 		     if seg_list (i).recno < seg_list (fbtemp).recno then fbtemp = i;
      259 		end;
      260 
      261 		call init_seg_list (fbtemp, pageno);
      262 		return (fbtemp);
      263 	     end get_segno;
      264 
      265 init_seg_list: proc (index, pageno);
      266 
      267 dcl (index, pageno) fixed bin;
      268 dcl  start fixed bin;
      269 
      270 		astep = get_ptrs_$given_segno (s (index));
      271 		call pc_wired$write (astep, 0, -1);
      272 		call pc$cleanup (astep);
      273 
      274 		start = divide (pageno, n_rec_per_seg, 17, 0) * n_rec_per_seg;
      275 
      276 		ptp = addrel (astep, sst$astsize);
      277 		do i = 0 to n_rec_per_seg - 1;
      278 		     call ptw_util_$make_disk (addrel (ptp, i), start + i); /* Appropriate record, out on disk */
      279 		end;
      280 
      281 		seg_list (index).recno = start;
      282 
      283 	     end init_seg_list;
      284 	end GET_VTOCEP;
      285 
      286 INIT :	proc (pvtx, code);
      287 
      288 dcl  pvtx fixed bin;
      289 dcl  code fixed bin (35);
      290 
      291 dcl  vtoc_size fixed bin;
      292 dcl  start_recno fixed bin;
      293 
      294 
      295 	     code = 0;
      296 
      297 	     if ^ segnos_initialized then
      298 		do;
      299 		seg_list (0).basep = addr (salv_abs_seg_00$);
      300 		s (0) = fixed (baseno (seg_list (0).basep));
      301 		seg_list (0).used = "0"b;
      302 		seg_list (0).perm = "0"b;
      303 
      304 		do i = 1 to hbound (s, 1);
      305 		     s (i) = s (0) + i;
      306 		     seg_list (i).basep = baseptr (s (i));
      307 		     seg_list (i).used = "0"b;
      308 		     seg_list (i).perm = "0"b;
      309 		end;
      310 
      311 		segnos_initialized = "1"b;
      312 	     end;
      313 
      314 	     start_recno = 0;
      315 	     call INIT_VTOC_SEG (s (0), pvtx, start_recno, n_rec_per_seg, code);
      316 	     if code ^= 0 then return;
      317 
      318 	     seg_list (0).used = "1"b;
      319 	     seg_list (0).perm = "1"b;
      320 	     seg_list (0).recno = 0;
      321 
      322 	     labelp = ptr (baseptr (s (0)), LABEL_ADDR * rec_size);
      323 
      324 	     vtoc_size = label.vtoc_size;
      325 
      326 	     do i = 1 to hbound (s, 1);
      327 		start_recno = start_recno + n_rec_per_seg;
      328 		call INIT_VTOC_SEG (s (i), pvtx, start_recno, n_rec_per_seg, code);
      329 		if code ^= 0 then return;
      330 		seg_list (i).used = "1"b;
      331 		seg_list (i).perm = "0"b;
      332 		seg_list (i).recno = start_recno;
      333 	     end;
      334 
      335 	     pvt_array (pvtx).vtoc_size = vtoc_size; /* Needed by vm_vio$get_vtocep */
      336 	     return;
      337 
      338 	end INIT;
      339 
      340 INIT_VTOC_SEG : proc (segno, pvtx, first_recno, n_records, code) ;
      341 
      342 
      343 dcl  segno fixed bin,				/* segno assigned to this vtoc segment - input */
      344      pvtx fixed bin,				/* PVT index for this vtoc segment - input */
      345      first_recno fixed bin,				/* device add for page 0 of this vtoc segment - input */
      346      n_records fixed bin,				/* number of pages for this vtoc segment - input */
      347      code fixed bin (35);
      348 
      349 dcl (i, pts, ptsi) fixed bin;
      350 
      351 dcl  tsdw fixed bin (71);
      352 
      353 
      354 /* ALLOCATE AN ASTE OF THE APPROPRIATE SIZE */
      355 
      356 	     code = 0;
      357 
      358 	     call lock$lock_ast;
      359 
      360 	     astep = get_aste (n_records);		/* Get an ASTE with the appropriate size PT */
      361 
      362 	     ptsi = fixed (aste.ptsi);
      363 	     pts = sst$pts (ptsi);
      364 
      365 
      366 /* ZERO THE ASTE */
      367 
      368 	     astep -> aste_part.two = "0"b;		/* Zero the rest of the ASTE except ptsi and marker */
      369 
      370 /* INITIALIZE THE PAGE TABLE WITH DISK ADDRESSES AND PAGE FAULT BITS */
      371 
      372 	     ptp = addrel (astep, sst$astsize);	/* get a pointer to the page table */
      373 
      374 	     do i = 0 to n_records - 1;		/* initialize the page table array for the entry */
      375 		call ptw_util_$make_disk (addrel (ptp, i), first_recno + i); /* Appropriate record, out on disk */
      376 	     end;
      377 
      378 	     do i = n_records to pts - 1;
      379 		call ptw_util_$make_null (addrel (ptp, i), fill_page_table_null_addr); /* Make up remaining PTWS */
      380 	     end;
      381 
      382 
      383 
      384 /* INITIALIZE THE ASTE */
      385 
      386 	     astep -> aste.vtocx = -1;		/* show there is no VTOCE for the segment */
      387 	     astep -> aste.dnzp = "1"b;
      388 	     astep -> aste.gtpd = "1"b;		/* do not put pages in the paging device */
      389 	     astep -> aste.nqsw = "1"b;		/* turn on no quota switch */
      390 	     astep -> aste.strp = bit (fixed (segno, 18), 18); /* store segment number in AST */
      391 	     astep -> aste.csl = bit (fixed (n_records, 9), 9); /* set the current length */
      392 	     astep -> aste.msl = bit (fixed (n_records, 9), 9); /* set the max length */
      393 	     astep -> aste.records = bit (fixed (n_records, 9), 9); /* set the number of records used */
      394 	     astep -> aste.pvtx = pvtx;		/* store the physical volume table index */
      395 
      396 
      397 
      398 /* THE CLEAN_UP OPERATION WILL DEPEND ON THE ORDER IN WHICH THE NEXT ACTIONS ARE PERFORMED */
      399 
      400 	     tsdw = get_ptrs_$given_astep (astep);	/* Get initial  SDW. */
      401 	     dseg$ (segno) = tsdw;			/* store temp SDW in the descriptor segment */
      402 	     call page$cam;
      403 
      404 	     astep -> aste.usedf = "1"b;		/* mark it as being used - as late as possible */
      405 
      406 	     call thread$out (astep, sst$level (ptsi).ausedp); /* thread the entry out of the used list */
      407 
      408 	     call lock$unlock_ast;
      409 
      410 	     return;
      411 
      412 	end INIT_VTOC_SEG;
      413 
      414 CLEAN_UP : proc;
      415 
      416 dcl  k fixed bin;
      417 
      418 
      419 	     if ^ segnos_initialized then return;
      420 
      421 	     if sst$astl ^= pds$processid then call lock$lock_ast;
      422 
      423 	     do k = 0 to hbound (s, 1);;
      424 		if seg_list (k).used then do;
      425 		     astep = get_ptrs_$given_segno (s (k));
      426 
      427 		     if astep ^= null then
      428 			if fixed (aste.strp, 18) = s (k) then
      429 			     do;
      430 			     dseg$ (s (k)) = 0;
      431 			     call page$cam;
      432 			     call pc$cleanup (astep);
      433 			     call put_aste (astep);
      434 			end;
      435 		     seg_list (k).used = "0"b;
      436 		     seg_list (k).perm = "0"b;
      437 		end;
      438 	     end;
      439 
      440 	     call lock$unlock_ast;
      441 
      442 	     addr (pvt$array) -> pvt_array (pvtx).vtoc_size = 0;
      443 
      444 	     return;
      445 
      446 	end CLEAN_UP;
      447 
      448  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      448 
      449  /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  2     2 
  2     3 
  2     4 
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  2    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  2    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  2    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  2    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  2    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  2    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 /*
  2    20*   All disk packs have the standard layout described below:
  2    21*
  2    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  2    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  2    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  2    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  2    26*   Record  7		: formerly contained bad track list; no longer used.
  2    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  2    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  2    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  2    30*
  2    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  2    32*   of the particular partition.
  2    33*
  2    34*
  2    35*
  2    36*   A conceptual declaration for a disk pack could be:
  2    37*
  2    38*   dcl 1 disk_pack,
  2    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  2    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  2    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  2    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  2    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  2    44*   2 vtoc_array_records	(8 : n-1),
  2    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  2    46*   3 unused				bit(36 * 64),
  2    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  2    48*
  2    49*
  2    50*
  2    51*
  2    52**/
  2    53 
  2    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  2    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  2    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  2    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  2    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  2    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  2    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  2    61 		         fixed bin (17) int static options (constant);
  2    62 
  2    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  2    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  2    65 /* or the physical volume table entry (pvte) device type.		      */
  2    66 
  2    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  2    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  2    69 
  2    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  2    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  2    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  2    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    76 
  2    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      449 
      450  /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  3     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  3     6*     Add the subvolume info.
  3     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3     9*     Added inconsistent_dbm bit used to determine consistency of volume
  3    10*     dumper bit maps.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  3    14 /* Note: fsout_vol clears pad fields before writing the label */
  3    15 
  3    16 dcl  labelp ptr;
  3    17 
  3    18 dcl 1 label based (labelp) aligned,
  3    19 
  3    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  3    21 
  3    22     2 gcos (5*64) fixed bin,
  3    23 
  3    24 /* Now we have the Multics label */
  3    25 
  3    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  3    27     2 version fixed bin,				/* Version 1 */
  3    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  3    29     2 pv_name char (32),				/* Physical volume name. */
  3    30     2 lv_name char (32),				/* Name of logical volume for pack */
  3    31     2 pvid bit (36),				/* Unique ID of this pack */
  3    32     2 lvid bit (36),				/* unique ID of its logical vol */
  3    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  3    34     2 time_registered fixed bin (71),			/* time imported to system */
  3    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  3    36     2 vol_size fixed bin,				/* total size of volume, in records */
  3    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  3    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  3    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  3    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  3    41     2 flagpad bit (33) unal,
  3    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  3    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  3    44     2 password bit (72),				/* not yet used */
  3    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  3    46     2 this_sv fixed bin,				/* what subvolume number it is */
  3    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  3    48     2 pad1 (13) fixed bin,
  3    49     2 time_mounted fixed bin (71),			/* time mounted */
  3    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  3    51 
  3    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  3    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  3    54* */
  3    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  3    56     2 pad6 fixed bin,				
  3    57 
  3    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  3    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  3    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  3    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  3    62     2 pad1a (2) fixed bin,
  3    63     2 err_hist_size fixed bin,			/* size of pack error history */
  3    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  3    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  3    66     2 pad2 (40) fixed bin,
  3    67     2 root,
  3    68       3 here bit (1),				/* TRUE if the root is on this pack */
  3    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  3    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  3    71       3 pad7 bit (1) aligned,				
  3    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  3    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  3    74       3 esd_state fixed bin,				/* State of esd */
  3    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  3    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  3    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  3    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  3    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  3    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  3    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  3    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  3    83     2 pad3 (52) fixed bin,
  3    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  3    85     2 parts (47),
  3    86       3 part char (4),				/* Name of partition */
  3    87       3 frec fixed bin,				/* First record */
  3    88       3 nrec fixed bin,				/* Number of records */
  3    89       3 pad5 fixed bin,
  3    90     2 pad4 (5*64) fixed bin;
  3    91 
  3    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  3    93 
  3    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      450 
      451  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  4     2 /* Added segmove values, Benson Margulies, 84-01 */
  4     3 
  4     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  4     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  4     6      get_aste_null_addr init			("3770110"b3),
  4     7      make_sdw_null_addr init			("3770120"b3),
  4     8      put_aste_null_addr init			("3770130"b3),
  4     9      page_bad_pd_null_addr init		("3770150"b3),
  4    10      list_deposit_null_addr init		("3770160"b3),
  4    11      get_file_map_null_addr init		("3770170"b3),
  4    12      fill_page_table_null_addr init		("3770200"b3),
  4    13      init_sst_null_addr init			("3770210"b3),
  4    14      get_file_map_vt_null_addr init		("3770220"b3),
  4    15      unprotected_null_addr init		("3770230"b3),
  4    16      page_bad_null_addr init			("3770240"b3),
  4    17      page_problem_null_addr init		("3770250"b3),
  4    18      page_parity_null_addr init		("3770260"b3),
  4    19      page_devparity_null_addr init		("3770270"b3),
  4    20      segmove_old_addr_null_addr init              ("3770300"b3),
  4    21      segmove_new_addr_null_addr init		("3770310"b3),
  4    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  4    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  4    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  4    25 
  4    26 dcl (create_vtoce_null_addr init		("777777"b3),
  4    27      update_vtoce_null_addr init		("777776"b3),
  4    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  4    29      truncate_vtoce_null_addr init		("777002"b3),
  4    30      pv_salv_null_addr init			("777004"b3),
  4    31      pv_scav_null_addr init			("777006"b3),
  4    32      volume_reloader_null_addr init		("777774"b3),
  4    33      volume_retriever_null_addr init		("777773"b3),
  4    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  4    35 
  4    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
      451 
      452  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  5     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  5     8*     Add the support for subvolumes
  5     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  5    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  5    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  5    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5    14*     Added inconsistent_dbm bit for determining the status of volume
  5    15*     dumper bit maps.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18      dcl	   pvt$array	      aligned external;
  5    19      dcl	   pvt$max_n_entries      fixed bin external;
  5    20 
  5    21      dcl	   pvt_arrayp	      ptr;
  5    22      dcl	   pvtep		      ptr;
  5    23 
  5    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  5    25 
  5    26      dcl	   1 pvte		      based (pvtep) aligned,
  5    27 
  5    28 	     2 pvid	      bit (36),		/* physical volume ID */
  5    29 
  5    30 	     2 lvid	      bit (36),		/* logical volume ID */
  5    31 
  5    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  5    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  5    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  5    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  5    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  5    37 	     2 pad3	      bit (2) unaligned,
  5    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  5    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  5    40 
  5    41 
  5    42 
  5    43 	     2 devname	      char (4),		/* device name */
  5    44 
  5    45 	     (2 device_type	      fixed bin (8),	/* device type */
  5    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  5    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  5    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  5    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  5    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  5    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  5    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  5    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  5    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  5    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  5    56 	     2 scav_check_address
  5    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  5    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  5    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  5    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  5    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  5    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  5    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  5    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  5    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  5    66 
  5    67 
  5    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  5    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  5    70 
  5    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  5    72 
  5    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  5    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  5    75 
  5    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  5    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  5    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  5    79 	     2 records_per_cyl    fixed bin,
  5    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  5    81 	     2 sv_name            char (2) aligned,
  5    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  5    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  5    84 
  5    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  5    86 	     2 pad2	      bit (18) unaligned,
  5    87 
  5    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  5    89 
  5    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  5    91 
  5    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  5    93 
  5    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  5    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  5    96 
  5    97 
  5    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  5    99 
  5   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  5   101 
  5   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  5   103 
  5   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  5   105 
  5   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  5   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  5   108 
  5   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  5   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  5   111 
  5   112 
  5   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  5   114 	   VOLMAP_ASYNC_READ      init (1),
  5   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  5   116 
  5   117 
  5   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      452 
      453  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  6     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  6     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  6     4 
  6     5 dcl  vtocep ptr;
  6     6 
  6     7 dcl 1 vtoce based (vtocep) aligned,
  6     8 
  6     9 
  6    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  6    11 
  6    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  6    13 
  6    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  6    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  6    16     2 records bit (9),				/* number of records used by the seg in second storage */
  6    17     2 pad2 bit (9),
  6    18 
  6    19     2 dtu bit (36),					/* date and time segment was last used */
  6    20 
  6    21     2 dtm bit (36),					/* date and time segment was last modified */
  6    22 
  6    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  6    24     2 deciduous bit (1),				/* true if hc_sdw */
  6    25     2 nid bit (1),					/* no incremental dump switch */
  6    26     2 dnzp bit (1),					/* Dont null zero pages */
  6    27     2 gtpd bit (1),					/* Global transparent paging device */
  6    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  6    29     2 damaged bit (1),				/* TRUE if contents damaged */
  6    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  6    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  6    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  6    33     2 pad3 bit (8),
  6    34     2 dirsw bit (1),				/* directory switch */
  6    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  6    36     2 pad4 bit (16)) unaligned,			/* not used */
  6    37 
  6    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  6    39 
  6    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  6    41 
  6    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  6    43 
  6    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  6    45 
  6    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  6    47 
  6    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  6    49 
  6    50 
  6    51 
  6    52 
  6    53 
  6    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  6    55 
  6    56     2 pad6 (10) bit (36),				/* not used */
  6    57 
  6    58     2 ncd bit (1),					/* no complete dump switch */
  6    59     2 pad7 bit (17),
  6    60     2 pad8 bit (18),
  6    61 
  6    62     2 dtd bit (36),					/* date-time-dumped */
  6    63 
  6    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  6    65 
  6    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  6    67 
  6    68 
  6    69 
  6    70 
  6    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  6    72 
  6    73     2 primary_name char (32),				/* primary name of the segment */
  6    74 
  6    75     2 time_created bit (36),				/* time the segment was created */
  6    76 
  6    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  6    78 
  6    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  6    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  6    81 
  6    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  6    83 
  6    84     2 access_class bit (72),				/* access class in branch */
  6    85     2 perm_flags aligned,
  6    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  6    87       3 pad9 bit (35) unal,
  6    88     2 owner bit (36);				/* pvid of this volume */
  6    89 
  6    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  6    91 
  6    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  6    93     2 pad1 bit (7*36),
  6    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  6    95     2 pad2 bit (184*36);
  6    96 
  6    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      453 
      454  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  7     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  7     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  7     4 
  7     5 /* This include file has an ALM version.  Keep 'em in sync! */
  7     6 
  7     7 dcl (
  7     8 
  7     9 /* The following constants define the message action codes.  This indicates
  7    10*how a message is to be handled.  */
  7    11 
  7    12      SYSERR_CRASH_SYSTEM	init (1),			
  7    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  7    14 
  7    15      SYSERR_TERMINATE_PROCESS	init (2),
  7    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  7    17 
  7    18      SYSERR_PRINT_WITH_ALARM	init (3),
  7    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  7    20 
  7    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  7    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  7    23 
  7    24      SYSERR_LOG_OR_PRINT	init (4),
  7    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  7    26 
  7    27      SYSERR_LOG_OR_DISCARD	init (5),
  7    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  7    29 
  7    30 
  7    31 /* The following constants are added to the normal severities to indicate
  7    32*different sorting classes of messages.  */
  7    33 
  7    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  7    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  7    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  7    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  7    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  7    39 	) fixed bin internal static options (constant);
  7    40 
  7    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      454 
      455  /* Begin fs_dev_types_sector.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  8     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  8     7*     Add the sector differance for devices that do 64 word IO and devices that
  8     8*     do 512 word IO.
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  8    12*	 need all the data in fs_dev_types. This is also included in
  8    13*	 fs_dev_types.incl.pl1  */
  8    14 
  8    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  8    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  8    17 
  8    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  8    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  8    20 
  8    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  8    22  /* table of # of sectors per record on each device */
  8    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  8    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  8    25 
  8    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  8    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  8    28 	
  8    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  8    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  8    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  8    32 
  8    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  8    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  8    35 
  8    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  8    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  8    38 
  8    39 /* End fs_dev_types_sector.incl.pl1 */
  8    40 
      455 
      456 /*  */
      457 
      458 /* BEGIN MESSAGE DOCUMENTATION
      459*
      460*   Message:
      461*   vm_vio: get_vtocep: invalid pvtx: PPPo
      462*
      463*   S: $info
      464*
      465*   T: Volume salvaging or disk rebuilding.
      466*
      467*   M: The Volume Salvager virtual access package has been given a bad
      468*   PVT index parameter, PPP (shown in octal).
      469*   $err
      470*
      471*   A: Salvaging will not proceed.
      472*   $boot_tape
      473*
      474*   Message:
      475*   vm_vio: get_vtocep: invalid vtocx VVVo on pvtx PPPo
      476*
      477*   S: $info
      478*
      479*   T: Volume salvaging or disk rebuilding.
      480*
      481*   M: An out-of-range VTOC index (VVV) has been given to the Volume Salvager
      482*   virtual access package while processing PV at pvtx PPP. The vtocx and pvtx
      483*   are shown in octal.
      484*   $err
      485*
      486*   A: Salvaging may fail.
      487*   $note
      488*
      489*   Message:
      490*   vm_vio: no AST pointer at readahead.
      491*
      492*   S: $crash
      493*
      494*   T: Volume salvaging or disk rebuilding.
      495*
      496*   M: No AST entry pointer was found for a VTOC-addressing
      497*   segment used by the Volume Salvager virtual access package.
      498*   $err
      499*
      500*   A: $recover
      501*   $note
      502*
      503*   END MESSAGE DOCUMENTATION */
      504 
      505      end vm_vio;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.7  vm_vio.pl1                        >spec>install>1112>vm_vio.pl1
448          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
449          2    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
450          3    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
451          4    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
452          5    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
453          6    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
454          7    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
455          8    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000027 constant        fixed bin(17,0)          initial dcl 7-7 set ref 161* 181*
CRASH                           000032 constant        fixed bin(17,0)          initial dcl 7-7 set ref 228*
LABEL_ADDR                             constant        fixed bin(17,0)          initial dcl 2-54 ref 322
VTOC_ORIGIN                            constant        fixed bin(17,0)          initial dcl 2-54 ref 175
a_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 106 116*
a_pvtx                                 parameter       fixed bin(17,0)          dcl 38 ref 91 93 106 108 126 128
a_vtocx                                parameter       fixed bin(17,0)          dcl 38 ref 91 94
addr                                                   builtin function         dcl 85 ref 95 110 129 299 442
addrel                                                 builtin function         dcl 85 ref 276 278 278 372 375 375 379 379
aste                                   based           structure                level 1 dcl 1-11
aste_part                              based           structure                level 1 dcl 1-89
astep                           000116 automatic       pointer                  dcl 1-9 in procedure "vm_vio" set ref 270* 271* 272*
                                                                                  276 360* 362 368 372 386 387 388 389 390 391 392
                                                                                  393 394 400* 404 406* 425* 427 427 432* 433*
astep                           000166 automatic       pointer                  array dcl 203 in procedure "READ_AHEAD" set ref 220*
                                                                                  223* 227 227* 236* 237 237*
ausedp                          000072 external static bit(18)                  array level 2 packed packed unaligned dcl 65 set ref
                                                                                  406*
baseno                                                 builtin function         dcl 85 ref 300
basep                           000016 internal static pointer                  array level 2 dcl 49 set ref 120 299* 300 306*
baseptr                                                builtin function         dcl 85 ref 188 306 322
bit                                                    builtin function         dcl 85 ref 390 391 392 393
cleanup                         000110 stack reference condition                dcl 87 ref 112
code                            000103 automatic       fixed bin(35,0)          dcl 38 in procedure "vm_vio" set ref 109* 114* 116
                                                                                  118
code                                   parameter       fixed bin(35,0)          dcl 343 in procedure "INIT_VTOC_SEG" set ref 340
                                                                                  356*
code                                   parameter       fixed bin(35,0)          dcl 289 in procedure "INIT" set ref 286 295* 315*
                                                                                  316 328* 329
compno                          000137 automatic       fixed bin(17,0)          dcl 147 set ref 176* 177 220 236
csl                      12            based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  391*
device_type               4            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 5-24 ref
                                                                                  96 111 130 164
devx                            000102 automatic       fixed bin(17,0)          dcl 38 set ref 96* 111* 130* 164* 173 173
divide                                                 builtin function         dcl 85 ref 174 175 274
dnzp                     12(13)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  387*
dseg$                           000054 external static fixed bin(71,0)          array dcl 58 set ref 401* 430*
fbtemp                          000204 automatic       fixed bin(17,0)          dcl 248 set ref 255* 258 258* 261* 262
fill_page_table_null_addr       000022 constant        bit(22)                  initial dcl 4-4 set ref 379*
first                           000164 automatic       fixed bin(17,0)          array dcl 202 set ref 225* 226* 227*
first_recno                            parameter       fixed bin(17,0)          dcl 343 ref 340 375
fixed                                                  builtin function         dcl 85 ref 300 362 390 391 392 393 427
get_aste                        000076 constant        entry                    external dcl 70 ref 360
get_ptrs_$given_astep           000100 constant        entry                    external dcl 71 ref 400
get_ptrs_$given_segno           000102 constant        entry                    external dcl 72 ref 220 223 236 270 425
gtpd                     12(12)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  388*
hbound                                                 builtin function         dcl 85 ref 250 257 304 326 423
i                               000104 automatic       fixed bin(17,0)          dcl 55 in procedure "vm_vio" set ref 250* 251 251
                                                                                  251 251* 257* 258 258* 277* 278 278 278* 304* 305
                                                                                  305 306 306 307 308* 326* 328 330 331 332*
i                               000234 automatic       fixed bin(17,0)          dcl 349 in procedure "INIT_VTOC_SEG" set ref 374*
                                                                                  375 375 375* 378* 379 379*
index                           000172 automatic       fixed bin(17,0)          dcl 204 in procedure "READ_AHEAD" set ref 222* 223
                                                                                  233* 234 237
index                                  parameter       fixed bin(17,0)          dcl 267 in procedure "init_seg_list" ref 265 270 281
j                               000161 automatic       fixed bin(17,0)          dcl 201 set ref 210* 213* 214 214 217* 218 220 223
                                                                                  225 225 226 227 227 227 227*
k                               000100 automatic       fixed bin(17,0)          dcl 416 in procedure "CLEAN_UP" set ref 423* 424 425
                                                                                  427 430 435 436*
k                               000146 automatic       fixed bin(17,0)          dcl 156 in procedure "GET_VTOCEP" set ref 190* 191
                                                                                  191 207 208 234 237 237*
label                                  based           structure                level 1 dcl 3-18
labelp                          000120 automatic       pointer                  dcl 3-16 set ref 322* 324
lock$lock_ast                   000104 constant        entry                    external dcl 73 ref 358 421
lock$unlock_ast                 000106 constant        entry                    external dcl 74 ref 408 440
mod                                                    builtin function         dcl 85 ref 185 185 191 213 225 226 233
msl                       4            based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  392*
n                               000162 automatic       fixed bin(17,0)          array dcl 201 set ref 210* 210* 214* 214 218 226
                                                                                  227* 236
n_rec_per_seg                   000026 constant        fixed bin(17,0)          initial dcl 43 set ref 185 213 222 225 226 233 251
                                                                                  274 274 277 315* 327 328*
n_records                              parameter       fixed bin(17,0)          dcl 343 set ref 340 360* 374 378 391 392 393
n_vtoce_per_rec                 000143 automatic       fixed bin(17,0)          dcl 152 set ref 174* 175 185 191
nqsw                      5(20)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  389*
null                                                   builtin function         dcl 85 ref 118 162 182 227 237 427
page$cam                        000110 constant        entry                    external dcl 75 ref 402 431
pageno                                 parameter       fixed bin(17,0)          dcl 247 in procedure "get_segno" set ref 245 251 251
                                                                                  261*
pageno                                 parameter       fixed bin(17,0)          dcl 267 in procedure "init_seg_list" ref 265 274
pc$cleanup                      000112 constant        entry                    external dcl 76 ref 272 432
pc_wired$read                   000114 constant        entry                    external dcl 77 ref 227
pc_wired$write                  000116 constant        entry                    external dcl 78 ref 237 271
pds$processid                   000056 external static bit(36)                  dcl 59 ref 421
perm                      3     000016 internal static bit(1)                   array level 2 dcl 49 set ref 302* 308* 319* 331*
                                                                                  436*
ptp                             000106 automatic       pointer                  dcl 56 set ref 276* 278 278 372* 375 375 379 379
ptr                                                    builtin function         dcl 85 ref 188 322
pts                             000235 automatic       fixed bin(17,0)          dcl 349 set ref 363* 378
ptsi                            000236 automatic       fixed bin(17,0)          dcl 349 in procedure "INIT_VTOC_SEG" set ref 362*
                                                                                  363 406
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "vm_vio" ref 362
ptw_util_$make_disk             000120 constant        entry                    external dcl 79 ref 278 375
ptw_util_$make_null             000122 constant        entry                    external dcl 80 ref 379
put_aste                        000124 constant        entry                    external dcl 81 ref 433
pvt$array                       000132 external static fixed bin(17,0)          dcl 5-18 set ref 95 110 129 442
pvt$n_entries                   000060 external static fixed bin(17,0)          dcl 60 ref 159
pvt_array                              based           structure                array level 1 dcl 5-24
pvt_arrayp                      000122 automatic       pointer                  dcl 5-21 set ref 95* 96 110* 111 129* 130 164 179
                                                                                  212 335
pvte                                   based           structure                level 1 dcl 5-26
pvtx                                   parameter       fixed bin(17,0)          dcl 288 in procedure "INIT" set ref 286 315* 328*
                                                                                  335
pvtx                            000100 automatic       fixed bin(17,0)          dcl 38 in procedure "vm_vio" set ref 93* 96 97* 108*
                                                                                  111 114* 128* 130 442
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "vm_vio" set ref 394*
pvtx                                   parameter       fixed bin(17,0)          dcl 343 in procedure "INIT_VTOC_SEG" ref 340 394
pvtx                                   parameter       fixed bin(17,0)          dcl 143 in procedure "GET_VTOCEP" set ref 135 159
                                                                                  159 161* 164 179 181* 212
r                               000156 automatic       fixed bin(17,0)          dcl 200 set ref 212* 212* 213 214*
r1                              000157 automatic       fixed bin(17,0)          dcl 200 set ref 207* 208 214 225 226
r2                              000160 automatic       fixed bin(17,0)          dcl 200 set ref 208* 212
rec_size                               constant        fixed bin(17,0)          initial dcl 42 ref 174 185 322
recno                     2     000016 internal static fixed bin(17,0)          array level 2 in structure "seg_list" dcl 49
                                                                                  in procedure "vm_vio" set ref 251 251 258 258 281*
                                                                                  320* 332*
recno                           000136 automatic       fixed bin(17,0)          dcl 146 in procedure "GET_VTOCEP" set ref 175* 176*
                                                                                  179 185 207 212 222 233
records                  12(18)        based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  393*
s                               000011 internal static fixed bin(17,0)          array dcl 47 set ref 177 220* 223* 236* 250 257 270*
                                                                                  300* 304 305* 305 306 315* 322 326 328* 423 425*
                                                                                  427 430
salv_abs_seg_00$                000062 external static fixed bin(17,0)          dcl 61 set ref 299
salv_data$vol_read_ahead        000064 external static fixed bin(17,0)          dcl 62 ref 190
sect_per_vtoc                   000011 constant        fixed bin(17,0)          initial array dcl 8-26 ref 173
seg_list                        000016 internal static structure                array level 1 unaligned dcl 49
segno                                  parameter       fixed bin(17,0)          dcl 343 in procedure "INIT_VTOC_SEG" ref 340 390 401
segno                           000140 automatic       fixed bin(17,0)          dcl 148 in procedure "GET_VTOCEP" set ref 177* 188
segnos_initialized              000010 internal static bit(1)                   initial packed unaligned dcl 45 set ref 297 311* 419
sst$astl                        000066 external static bit(36)                  dcl 63 ref 421
sst$astsize                     000070 external static fixed bin(17,0)          dcl 64 ref 276 372
sst$level                       000072 external static structure                array level 1 dcl 65
sst$pts                         000074 external static fixed bin(17,0)          array dcl 68 ref 363
start                           000214 automatic       fixed bin(17,0)          dcl 268 set ref 274* 278 281
start_recno                     000225 automatic       fixed bin(17,0)          dcl 292 set ref 314* 315* 327* 327 328* 332
strp                      2            based           bit(18)                  level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  390* 427
syserr                          000126 constant        entry                    external dcl 82 ref 161 181 228
thread$out                      000130 constant        entry                    external dcl 83 ref 406
tsdw                            000240 automatic       fixed bin(71,0)          dcl 351 set ref 400* 401
two                       1            based           bit(388)                 level 2 packed packed unaligned dcl 1-89 set ref
                                                                                  368*
used                      4     000016 internal static bit(1)                   array level 2 dcl 49 set ref 251 301* 307* 318* 330*
                                                                                  424 435*
usedf                     5            based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  404*
vtoc_size               550            based           fixed bin(17,0)          level 2 in structure "label" dcl 3-18 in procedure
                                                                                  "vm_vio" ref 324
vtoc_size                       000224 automatic       fixed bin(17,0)          dcl 291 in procedure "INIT" set ref 324* 335
vtoc_size                 5(18)        based           fixed bin(17,0)          array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 5-24 in procedure "vm_vio" set ref
                                                                                  179 212 335* 442*
vtoce_ptr                       000144 automatic       pointer                  dcl 154 set ref 188* 193
vtoce_size                      000142 automatic       fixed bin(17,0)          dcl 151 set ref 173* 174 185
vtocep                          000124 automatic       pointer                  dcl 6-5 set ref 97* 99
vtocx                                  parameter       fixed bin(17,0)          dcl 143 in procedure "GET_VTOCEP" set ref 135 175
                                                                                  179 181* 185 191
vtocx                           000101 automatic       fixed bin(17,0)          dcl 38 in procedure "vm_vio" set ref 94* 97*
vtocx                     4(18)        based           fixed bin(17,0)          level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "vm_vio" set ref 386*
word_number                     000141 automatic       fixed bin(17,0)          dcl 149 set ref 185* 188
words_per_sect                  000000 constant        fixed bin(17,0)          initial array dcl 8-36 ref 173

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 7-7
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 2-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 2-54
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 7-7
LOG                                    internal static fixed bin(17,0)          initial dcl 7-7
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 2-54
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 3-92
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 2-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 2-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 2-70
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 7-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 7-7
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 2-54
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 5-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 5-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 5-113
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 2-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 2-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 2-54
append_null_addr                       internal static bit(22)                  initial dcl 4-4
asta                                   based           bit(432)                 array dcl 1-86
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 4-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 4-26
get_aste_null_addr                     internal static bit(22)                  initial dcl 4-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 4-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 4-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 4-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 4-4
list_deposit_null_addr                 internal static bit(22)                  initial dcl 4-4
make_sdw_null_addr                     internal static bit(22)                  initial dcl 4-4
page_bad_null_addr                     internal static bit(22)                  initial dcl 4-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 4-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 4-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 4-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 4-4
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 4-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 4-4
put_aste_null_addr                     internal static bit(22)                  initial dcl 4-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 4-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 4-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 5-19
pvtep                                  automatic       pointer                  dcl 5-22
salv_truncate_null_addr                internal static bit(18)                  initial dcl 4-26
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 8-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 8-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 8-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 8-33
seg_aste                               based           structure                level 1 dcl 1-96
seg_vtoce                              based           structure                level 1 dcl 6-92
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 4-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 4-4
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 4-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 4-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 4-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 4-26
volume_reloader_null_addr              internal static bit(18)                  initial dcl 4-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 4-26
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 8-29
vtoce                                  based           structure                level 1 dcl 6-7
vtoce_parts                            based           bit(2304)                array dcl 6-90

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEAN_UP                        001631 constant        entry                    internal dcl 414 ref 112 118 131
GET_VTOCEP                      000331 constant        entry                    internal dcl 135 ref 97
INIT                            001201 constant        entry                    internal dcl 286 ref 114
INIT_VTOC_SEG                   001373 constant        entry                    internal dcl 340 ref 315 328
READ_AHEAD                      000526 constant        entry                    internal dcl 196 ref 191
clean_up                        000275 constant        entry                    external dcl 126
get_segno                       000776 constant        entry                    internal dcl 245 ref 176 222
get_vtocep                      000127 constant        entry                    external dcl 91
init                            000171 constant        entry                    external dcl 106
init_seg_list                   001067 constant        entry                    internal dcl 265 ref 261
vm_vio                          000113 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2330        2464    2016        2340
Length      3070    2016       134         370     311          44

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vm_vio                              301 external procedure  is an external procedure.  
on unit on line 112                  64 on unit               
GET_VTOCEP                              internal procedure  shares stack frame of external procedure vm_vio.  
READ_AHEAD                              internal procedure  shares stack frame of external procedure vm_vio.  
get_segno                               internal procedure  shares stack frame of external procedure vm_vio.  
init_seg_list                           internal procedure  shares stack frame of external procedure vm_vio.  
INIT                                    internal procedure  shares stack frame of external procedure vm_vio.  
INIT_VTOC_SEG                           internal procedure  shares stack frame of external procedure vm_vio.  
CLEAN_UP                             73 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 segnos_initialized          vm_vio
000011 s                           vm_vio
000016 seg_list                    vm_vio

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CLEAN_UP                 000100 k                           CLEAN_UP
vm_vio                   000100 pvtx                        vm_vio
                         000101 vtocx                       vm_vio
                         000102 devx                        vm_vio
                         000103 code                        vm_vio
                         000104 i                           vm_vio
                         000106 ptp                         vm_vio
                         000116 astep                       vm_vio
                         000120 labelp                      vm_vio
                         000122 pvt_arrayp                  vm_vio
                         000124 vtocep                      vm_vio
                         000136 recno                       GET_VTOCEP
                         000137 compno                      GET_VTOCEP
                         000140 segno                       GET_VTOCEP
                         000141 word_number                 GET_VTOCEP
                         000142 vtoce_size                  GET_VTOCEP
                         000143 n_vtoce_per_rec             GET_VTOCEP
                         000144 vtoce_ptr                   GET_VTOCEP
                         000146 k                           GET_VTOCEP
                         000156 r                           READ_AHEAD
                         000157 r1                          READ_AHEAD
                         000160 r2                          READ_AHEAD
                         000161 j                           READ_AHEAD
                         000162 n                           READ_AHEAD
                         000164 first                       READ_AHEAD
                         000166 astep                       READ_AHEAD
                         000172 index                       READ_AHEAD
                         000204 fbtemp                      get_segno
                         000214 start                       init_seg_list
                         000224 vtoc_size                   INIT
                         000225 start_recno                 INIT
                         000234 i                           INIT_VTOC_SEG
                         000235 pts                         INIT_VTOC_SEG
                         000236 ptsi                        INIT_VTOC_SEG
                         000240 tsdw                        INIT_VTOC_SEG

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          mdfx1
signal_op           enable_op           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_aste                      get_ptrs_$given_astep         get_ptrs_$given_segno         lock$lock_ast
lock$unlock_ast               page$cam                      pc$cleanup                    pc_wired$read
pc_wired$write                ptw_util_$make_disk           ptw_util_$make_null           put_aste
syserr                        thread$out

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         pds$processid                 pvt$array                     pvt$n_entries
salv_abs_seg_00$              salv_data$vol_read_ahead      sst$astl                      sst$astsize
sst$level                     sst$pts




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000112        91 000122        93 000135        94 000140        95 000142        96 000144        97 000151
     99 000153       106 000165       108 000177       109 000202       110 000203       111 000206       112 000212
    114 000234       116 000236       118 000241       118 000242       118 000246       120 000260       126 000272
    128 000304       129 000307       130 000312       131 000316       133 000322       135 000331       159 000333
    161 000340       162 000364       164 000370       173 000375       174 000401       175 000404       176 000410
    177 000412       179 000416       181 000432       182 000457       185 000463       188 000500       190 000507
    191 000511       193 000522       196 000526       207 000527       208 000532       210 000535       212 000540
    213 000560       214 000566       215 000573       217 000575       218 000600       220 000603       222 000620
    223 000625       225 000641       226 000651       227 000657       228 000703       230 000723       233 000731
    234 000735       236 000737       237 000753       240 000775       245 000776       250 001000       251 001005
    253 001024       255 001026       257 001030       258 001035       259 001050       261 001052       262 001063
    265 001067       270 001071       271 001103       272 001121       274 001130       276 001135       277 001142
    278 001151       279 001167       281 001171       283 001200       286 001201       295 001203       297 001204
    299 001207       300 001211       301 001215       302 001216       304 001217       305 001225       306 001231
    307 001240       308 001241       309 001242       311 001244       314 001247       315 001250       316 001267
    318 001273       319 001276       320 001277       322 001300       324 001307       326 001311       327 001320
    328 001322       329 001343       330 001347       331 001354       332 001355       333 001360       335 001362
    336 001372       340 001373       356 001375       358 001376       360 001403       362 001415       363 001422
    368 001425       372 001430       374 001434       375 001445       376 001464       378 001466       379 001477
    380 001513       386 001515       387 001520       388 001522       389 001524       390 001526       391 001534
    392 001543       393 001550       394 001556       400 001561       401 001572       402 001601       404 001605
    406 001610       408 001622       410 001627       414 001630       419 001636       421 001640       423 001647
    424 001653       425 001660       427 001672       430 001706       431 001713       432 001717       433 001727
    435 001737       436 001742       438 001743       440 001745       442 001752       444 001762


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
