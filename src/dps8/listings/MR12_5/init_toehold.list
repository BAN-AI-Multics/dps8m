	COMPILATION LISTING OF SEGMENT init_toehold
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0952.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 init_toehold: procedure;
       10 
       11 /* init_toehold.pl1 -- fills in the static data in toehold.alm and saves the
       12*   bootload Multics image. */
       13 
       14 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
       15 
       16 /* This program is IOM/IMU dependent. */
       17 
       18 /* BIM 11/82 */
       19 /* Modified 8/83 Keith Loepere for absolute mode toehold, saving of "crash" image to disk */
       20 /* Modified 3/84 kpl for saving safe_config_deck */
       21 /* Modified 8/84 Chris Jones for new disk dim. */
       22 /* Modified 10/84 kpl to fix stupid bug in loop limits. */
       23 /* Modified 3/85 Keith Loepere to fix config deck saving now that 
       24*   move_non_perm_wired_segs works. */
       25 /* Modified 4/85 by RAF to support the larger 3380 disk drives */
       26 
       27 /****^  HISTORY COMMENTS:
       28*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
       29*     audit(86-02-13,GDixon), install(86-03-21,MR12.0-1033):
       30*     Support IBM FIPS disk drives.
       31*  2) change(86-03-12,Fawcett), approve(86-04-11,MCR7383),
       32*     audit(86-06-07,GDixon), install(86-07-17,MR12.0-1097):
       33*     Add support for subvolumes, MSU3380 and MSU3390.
       34*  3) change(87-04-14,Farley), approve(87-07-06,MCR7717),
       35*     audit(87-07-13,Lippard), install(87-07-17,MR12.1-1043):
       36*     Changed to make sure toehold.seeks_used was set to the higher of the two
       37*     dcw lists.
       38*                                                   END HISTORY COMMENTS */
       39 
       40 dcl  Config_deck_size	        fixed bin init (4) static options (constant);
       41 dcl  Max_pages_in_segment	        fixed bin init (256) static options (constant);
       42 dcl  Pages_per_dcw		        fixed bin init (4) static options (constant);
       43 dcl  Toehold_size		        fixed bin init (2) static options (constant);
       44 dcl  Hardware_low_mem_page_size       fixed bin init (2) static options (constant);
       45 dcl  absadr		        entry (pointer, fixed (35)) returns (fixed bin (26));
       46 dcl  pc$flush		        entry;
       47 dcl  pmut$camp		        entry;
       48 dcl  ptw_util_$make_core	        entry (ptr, fixed bin (26));
       49 dcl  save_handler_mc	        entry (ptr);
       50 dcl  sdw_util_$get_address	        entry (ptr, fixed bin (26));
       51 dcl  syserr		        entry options (variable);
       52 dcl  syserr$error_code	        entry options (variable);
       53 dcl  write_disk$write_disk_no_test    entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
       54 
       55 dcl  abs_seg0$		        (0:255) bit (36 * 1024) aligned external;
       56 dcl  config_deck$		        external;
       57 dcl  dseg$		        (0:2047) fixed bin (71) external aligned;
       58 dcl  emergency_shutdown$	        external;
       59 dcl  fault_vector$		        external;
       60 dcl  int_unpaged_page_tables$	        external;
       61 dcl  pvt$root_pvtx		        fixed bin external static;
       62 dcl  safe_config_deck$	        external;
       63 dcl  sys_boot_info$bce_part_frec      fixed bin external static;
       64 dcl  sys_boot_info$config_part_frec   fixed bin external static;
       65 dcl  sys_boot_info$safe_config_deck_frec fixed bin external static;
       66 dcl  toehold_data$		        external static bit (36) aligned;
       67 
       68 dcl  abs_seg_pt_abs_addr	        fixed bin (26);
       69 dcl  code			        fixed bin (35);
       70 dcl  disk_channel_number	        fixed bin (7);
       71 dcl  disk_iom_number	        fixed bin (3);
       72 dcl  disk_iom_port_number	        fixed bin (3);
       73 dcl  disk_device_number	        fixed bin (6);
       74 dcl  fault_vector_abs_addr	        fixed bin (26);
       75 dcl  iom_mailbox_abs_addr	        fixed bin (26);
       76 dcl  old_memory_state	        fixed bin;
       77 dcl  records_to_do		        fixed bin (18);
       78 dcl  rpv_devt		        fixed bin;
       79 dcl  running_address	        fixed bin;
       80 dcl  running_seeks		        fixed bin;
       81 dcl  running_record		        fixed bin (18);
       82 dcl  sx			        fixed bin;
       83 dcl  toehold_abs_addr	        fixed bin (18);
       84 dcl  toehold_page_addr	        fixed bin;
       85 
       86 dcl  abs_seg_pt		        (0:255) bit (36) aligned based (abs_seg_pt_ptr); /* for abs_seg0 */
       87 dcl  abs_seg_pt_ptr		        ptr;
       88 
       89 dcl  1 (seek_idcw_template, data_idcw_template)
       90 			        aligned like idcw;
       91 
       92 dcl  (addr, addrel, currentsize, dimension, divide, hbound, lbound, max, min, mod, ptr, segno, unspec) builtin;
       93 
       94 	if sys_boot_info$bce_part_frec = -1
       95 	     then call syserr (CRASH, "init_toehold: No ""bce"" partition on rpv. Rebuild the RPV to add one.");
       96 
       97 	toehold_abs_addr = absadr (addr (toehold$), (0));
       98 	toehold_page_addr = divide (toehold_abs_addr, 1024, 17);
       99 	toehold_ptr = addr (toehold$);
      100 	fault_vector_abs_addr = absadr (addr (fault_vector$), (0));
      101 	iom_mailbox_abs_addr = absadr (addr (iom_mailbox$), (0));
      102 
      103 	sys_boot_info$safe_config_deck_frec = divide (absadr (addr (safe_config_deck$), (0)), 1024, 16)
      104 	     + sys_boot_info$bce_part_frec + CRASH_HANDLER_RECORDX;
      105 						/* find this before safe_config_deck is moved in memory */
      106 
      107 	toehold.memory_state = 0;			/* contents invalid */
      108 
      109 	call find_rpv;				/* io paths to rpv */
      110 
      111 	toehold.esd_segnum = segno (addr (emergency_shutdown$));
      112 
      113 	unspec (seek_idcw_template) = IDCW_INIT_STRING;
      114 	seek_idcw_template.command = seek_command (rpv_devt); /* Seek */
      115 	seek_idcw_template.device = disk_device_number;
      116 	seek_idcw_template.ext_ctl = "0"b;
      117 	seek_idcw_template.control = PROCEED;
      118 	seek_idcw_template.chan_cmd = SINGLE_RECORD;
      119 	unspec (data_idcw_template) = unspec (seek_idcw_template);
      120 
      121 /* write command = "31"b3; read command = "25"b3 */
      122 
      123 	data_idcw_template.ext_ctl = "1"b;		/* data is anyplace */
      124 	data_idcw_template.control = TERMINATE;
      125 
      126 	unspec (toehold.save_dcws) = ""b;
      127 	unspec (toehold.handler_dcws) = ""b;
      128 
      129 	dcw_list_ptr = addr (toehold.save_dcws);
      130 	toehold.dcws_per_cyl = divide (rec_per_cyl (rpv_devt) + (Pages_per_dcw - 1), Pages_per_dcw, 17);
      131 	toehold.seeks_used = 1;			/* set here so that the dcw_list_size will be correct */
      132 	toehold.dcw_list_size = currentsize (dcw_list);	/* this is used by toehold */
      133 	running_seeks = 0;
      134 	running_address = Hardware_low_mem_page_size;
      135 	running_record = sys_boot_info$bce_part_frec + SAVED_IMAGE_RECORDX + running_address;
      136 	records_to_do = toehold_page_addr - running_address;
      137 
      138 /* don't save, restore iom_mailbox or toehold */
      139 
      140 	do while (records_to_do > 0);
      141 	     running_seeks = running_seeks + 1;
      142 	     call process_one_cylinder (running_seeks, addr (toehold.save_dcws));
      143 	end;
      144 
      145 	running_address = toehold_page_addr + Toehold_size;
      146 	running_record = sys_boot_info$bce_part_frec + SAVED_IMAGE_RECORDX + running_address;
      147 	records_to_do = Max_pages_in_segment + Max_pages_in_segment - running_address;
      148 
      149 	do while (records_to_do > 0);
      150 	     running_seeks = running_seeks + 1;
      151 	     call process_one_cylinder (running_seeks, addr (toehold.save_dcws));
      152 	end;
      153 
      154 	toehold.seeks_used = running_seeks;		/* remember seeks used for save_dcws */
      155 
      156 /* now list to read in config deck and handler */
      157 
      158 	running_seeks = 0;
      159 	running_record = sys_boot_info$config_part_frec;
      160 	running_address = divide (absadr (addr (config_deck$), (0)), 1024, 18);
      161 	records_to_do = Config_deck_size;
      162 
      163 	do while (records_to_do > 0);
      164 	     running_seeks = running_seeks + 1;
      165 	     call process_one_cylinder (running_seeks, addr (toehold.handler_dcws));
      166 	end;
      167 
      168 	running_address = toehold_page_addr + Toehold_size;
      169 	running_record = sys_boot_info$bce_part_frec + CRASH_HANDLER_RECORDX + running_address;
      170 	records_to_do = Max_pages_in_segment + Max_pages_in_segment - running_address;
      171 
      172 	do while (records_to_do > 0);
      173 	     running_seeks = running_seeks + 1;
      174 	     call process_one_cylinder (running_seeks, addr (toehold.handler_dcws));
      175 	end;
      176 
      177 	toehold.seeks_used = max (running_seeks, toehold.seeks_used);
      178 						/* remember longest of the two lists */
      179 
      180 
      181 /* save fault_vector and iom_mailbox in toehold_data for handler */
      182 
      183 	unspec (addrel (addr (toehold_data$), fault_vector_abs_addr) -> fv) =
      184 	     unspec (addr (fault_vector$) -> fv);
      185 
      186 	unspec (addrel (addr (toehold_data$), iom_mailbox_abs_addr) -> iom_mailbox_seg) =
      187 	     unspec (addr (iom_mailbox$) -> iom_mailbox_seg);
      188 
      189 /* save "crash" handler to disk */
      190 
      191 	call pc$flush;
      192 	call sdw_util_$get_address (addr (dseg$ (segno (addr (abs_seg0$)))), abs_seg_pt_abs_addr); /* build segment onto high 256k mem */
      193 	abs_seg_pt_ptr = ptr (addr (int_unpaged_page_tables$), abs_seg_pt_abs_addr - absadr (addr (int_unpaged_page_tables$), (0)));
      194 
      195 	do running_address = 0 to Max_pages_in_segment - 1;
      196 	     call ptw_util_$make_core (addr (abs_seg_pt (running_address)), (running_address + Max_pages_in_segment) * 1024);
      197 	end;
      198 	call pmut$camp;
      199 
      200 	do running_address = Max_pages_in_segment + Max_pages_in_segment - 1 to Max_pages_in_segment by -1; /* save backwards is faster */
      201 	     running_record = sys_boot_info$bce_part_frec + CRASH_HANDLER_RECORDX + running_address;
      202 	     call write_disk$write_disk_no_test (pvt$root_pvtx, running_record, addr (abs_seg0$ (running_address - Max_pages_in_segment)), code);
      203 	     if code ^= 0 then call syserr$error_code (CRASH, code, "init_toehold: Unable to save bootload Multics image to disk.");
      204 	end;
      205 
      206 	do running_address = 0 to Max_pages_in_segment - 1; /* low mem */
      207 	     call ptw_util_$make_core (addr (abs_seg_pt (running_address)), running_address * 1024);
      208 	end;
      209 	call pmut$camp;
      210 
      211 	do running_address = Max_pages_in_segment - 1 to toehold_page_addr + Toehold_size by -1; /* don't save toehold (or what's below it) */
      212 	     running_record = sys_boot_info$bce_part_frec + CRASH_HANDLER_RECORDX + running_address;
      213 	     call write_disk$write_disk_no_test (pvt$root_pvtx, running_record, addr (abs_seg0$ (running_address)), code);
      214 	     if code ^= 0 then call syserr$error_code (CRASH, code, "init_toehold: Unable to save bootload Multics image to disk.");
      215 	end;
      216 
      217 	call save_handler_mc (addr (toehold$));
      218 
      219 /* must be done as soon as possible after disk save */
      220 
      221 /* We get here at two different times.  The first case is when init_toehold
      222*was called from real_initializer.  At this time, we simply continue on from
      223*this point with filling in the toehold.  In the second case, we have just
      224*crashed/shut down, and the toehold has restarted bce.  When restarting bce, it
      225*transfers to the last location it knows, which was the last instruction in
      226*save_handler_mc, thus returning us here.  In this case, we must quickly get out
      227*of here and back to real_initializer, who will know what to do (reinitialize
      228*bce).  Thus, this operation is the last thing done here in init_toehold.
      229*
      230*This whole thing is done since bce must be restarted with the stack history
      231*basically intact, since from the reinitialized bce we may want to re-boot
      232*Multics, which depends on the normal flow of control, including the sequence
      233*of calls leading up to real_initializer. */
      234 
      235 /* toehold will be declared valid (memory_state set) in real_initializer */
      236 
      237 	return;
      238 
      239 save_safe_config_deck: entry;
      240 
      241 /* Save the safe config deck into the crash handler for future possible 
      242*failure of bce */
      243 
      244 	toehold_ptr = addr (toehold$);
      245 
      246 	old_memory_state = toehold.memory_state;
      247 	toehold.memory_state = 0;			/* while finding rpv */
      248 
      249 	call find_rpv;				/* find new io paths */
      250 
      251 	toehold.memory_state = old_memory_state;
      252 
      253 	do running_record = sys_boot_info$safe_config_deck_frec + Config_deck_size - 1 to sys_boot_info$safe_config_deck_frec by -1;
      254 	     call write_disk$write_disk_no_test (
      255 		pvt$root_pvtx, running_record,
      256 		addrel (addr (safe_config_deck$), 1024 * (running_record - sys_boot_info$safe_config_deck_frec)), code);
      257 	     if code ^= 0 then call syserr$error_code (BEEP, code, "init_toehold: Unable to save safe_config_deck to disk.");
      258 	end;
      259 	return;
      260 
      261 process_one_cylinder:
      262      procedure (cx, p_dcw_list_ptr);
      263 dcl  cx			        fixed bin;		/* dcw_list cylinder index */
      264 dcl  p_dcw_list_ptr		        ptr;
      265 dcl  full_tallys		        fixed bin;
      266 dcl  i			        fixed bin;
      267 dcl  records_to_do_here	        fixed bin (18);
      268 dcl  residue		        fixed bin;
      269 
      270 	dcw_list_ptr = p_dcw_list_ptr;
      271 	dcw_list (cx).seek_idcw = unspec (seek_idcw_template);
      272 	data_idcw_template.ext = ext_value (running_address);
      273 	dcw_list (cx).data_idcw = unspec (data_idcw_template);
      274 	dcw_list (cx).seek_addresses = sector (running_record);
      275 	dcw_ptr = addr (dcw_list (cx).seek_dcw);
      276 	unspec (dcw) = IOTD_INIT_STRING;
      277 	dcw.address = absadr (addr (dcw_list.seek_addresses (cx)), (0));
      278 	dcw.tally = 1;
      279 
      280 /**** First calculate the limit of records we can write into the */
      281 /**** current cylinder. This cannot come out 0 */
      282 
      283 	records_to_do_here = min (records_to_do, rec_per_cyl (rpv_devt) - mod (running_record, rec_per_cyl (rpv_devt)));
      284 
      285 /**** Then correct for the 256K boundary, which occurs when we go from page */
      286 /**** 255 to page 256. */
      287 
      288 	if ext_value (running_address) < 1 & ext_value (running_address + records_to_do_here) ^< 1
      289 	     then records_to_do_here = Max_pages_in_segment - running_address; /* if running_addr is 255 (256'th page), do that 1 record */
      290 
      291 /**** Now fill in the dcws */
      292 
      293 	if mod (records_to_do_here, Pages_per_dcw) = 0
      294 	then do;
      295 	     full_tallys = divide (records_to_do_here, Pages_per_dcw, 18, 0);
      296 	     residue = 0;
      297 	end;
      298 	else do;
      299 	     full_tallys = divide (records_to_do_here, Pages_per_dcw, 18, 0);
      300 	     residue = mod (records_to_do_here, Pages_per_dcw);
      301 	end;
      302 
      303 	do i = 1 to full_tallys;
      304 	     dcw_ptr = addr (dcw_list (cx).data_dcws (i));
      305 	     unspec (dcw) = IOTP_INIT_STRING;
      306 	     dcw.address = mod (running_address, Max_pages_in_segment) * 1024;
      307 	     dcw.tally = 0;				/* 4096 */
      308 	     running_address = running_address + Pages_per_dcw;
      309 	     running_record = running_record + Pages_per_dcw;
      310 	end;
      311 	if residue = 0
      312 	     then dcw.type = IOTD;			/* ptr left at last one */
      313 	else do;
      314 	     dcw_ptr = addr (dcw_list (cx).data_dcws (i));/* i is 1 past */
      315 	     unspec (dcw) = IOTD_INIT_STRING;
      316 	     dcw.address = mod (running_address, Max_pages_in_segment) * 1024;
      317 	     dcw.tally = residue * 1024;
      318 	     running_address = running_address + residue;
      319 	     running_record = running_record + residue;
      320 	end;
      321 
      322 	records_to_do = records_to_do - records_to_do_here;
      323 
      324 /***** WHEW --- all set up */
      325      end process_one_cylinder;
      326 
      327 
      328 
      329 
      330 /* rpv_devt is a global parameter of this */
      331 
      332 sector:
      333      procedure (Record) returns (fixed bin (35));
      334 dcl  Record		        fixed bin (18);
      335 dcl  devadd		        fixed bin (18);
      336 dcl  record_offset		        fixed bin (18);
      337 	if pvte.is_sv then do;
      338 						/* convert the subvolume devadd to the real devadd */
      339 
      340 	     record_offset = mod (Record, pvte.records_per_cyl);
      341 	     devadd = ((Record - record_offset) * pvte.num_of_svs) +
      342 		pvte.record_factor + record_offset;
      343 	end;
      344 	else devadd = Record;
      345 	return ((divide (devadd, rec_per_cyl (rpv_devt), 18, 0) * sect_per_cyl (rpv_devt))
      346 	     + (mod (devadd, rec_per_cyl (rpv_devt)) * sect_per_rec (rpv_devt)));
      347      end sector;
      348 
      349 ext_value:
      350      procedure (Address) returns (fixed bin);
      351 dcl  Address		        fixed bin;
      352 
      353 	return (divide (Address, Max_pages_in_segment, 18, 0));
      354      end ext_value;
      355 
      356 find_rpv: proc;
      357 
      358 /* find out about rpv, in particular, paths to it */
      359 
      360 	pvt_arrayp = addr (pvt$array);
      361 	pvtep = addr (pvt_array (pvt$root_pvtx));
      362 	rpv_devt = pvte.device_type;
      363 	disk_device_number = pvte.logical_area_number;
      364 
      365 /* find the main channel to this disk. */
      366 
      367 	disksp = addr (disk_seg$);
      368 	iom_data_ptr = addr (iom_data$);
      369 	do sx = 1 to disk_data.subsystems while (disk_data.name (sx) ^= pvte.devname);
      370 	end;
      371 	diskp = ptr (disksp, disk_data.offset (sx));
      372 
      373 	do toehold.n_paths_used = 1 to min (dimension (toehold.paths, 1), disktab.nchan);
      374 	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (toehold.n_paths_used));
      375 	     disk_iom_number = iom_data.per_device (chantab.chx).iom;
      376 	     disk_channel_number = iom_data.per_device (chantab.chx).channel;
      377 
      378 	     do disk_iom_port_number = lbound (scs$port_data, 1) to hbound (scs$port_data, 1)
      379 		while (scs$port_data (disk_iom_port_number).assigned ^= IOM_PORT
      380 		| scs$port_data (disk_iom_port_number).iom_number ^= disk_iom_number);
      381 	     end;
      382 
      383 	     toehold.paths (toehold.n_paths_used).port_number = disk_iom_port_number;
      384 	     toehold.paths (toehold.n_paths_used).iom_number = disk_iom_number;
      385 	     toehold.paths (toehold.n_paths_used).channel_number = disk_channel_number;
      386 
      387 	     pcw_ptr = addr (toehold.paths (toehold.n_paths_used).pcw);
      388 	     unspec (pcw) = PCW_INIT_STRING;
      389 	     pcw.command = "40"b3;			/* reset status */
      390 	     pcw.device = disk_device_number;
      391 	     pcw.ext = 0;
      392 	end;
      393 	toehold.n_paths_used = toehold.n_paths_used - 1;	/* do went 1 too far */
      394 	return;
      395      end;
      396  /* Begin include file ...... dskdcl.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  1     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  1     6*     Support for FIPS dev 0.
  1     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  1     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  1     9*     Added reconnect_announce_time to chantab to allow announcement of
  1    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  1    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 /* Structures used by the Disk DIM */
  1    15 
  1    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  1    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  1    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  1    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  1    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  1    21 
  1    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  1    23 
  1    24 dcl  disk_seg$ ext;					/* disk data segment */
  1    25 
  1    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  1    27      diskp ptr,					/* pointer to disk DIM info structure */
  1    28      optp ptr,					/* pointer to opt_info */
  1    29      sysp ptr;					/* pointer to sys_info */
  1    30 
  1    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  1    32        2 subsystems fixed bin,			/* number of subsystems */
  1    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  1    34        2 status_mask bit (36),			/* mask for checking for disk error */
  1    35        2 lock bit (36) unal,				/* disk_data lock */
  1    36        2 free_q like qht,				/* head/tail offsets */
  1    37        2 free_q_size fixed bin,			/* length of queue */
  1    38        2 array (32),				/* per subsystem info */
  1    39          (
  1    40          3 offset bit (18),				/* location of data for this subsystem */
  1    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  1    42          3 name char (4)
  1    43          ) unal,					/* name of subsystem */
  1    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  1    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  1    46        2 pad bit (36),				/* double word align */
  1    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  1    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  1    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  1    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  1    51 
  1    52 
  1    53 /* The following system table is used to hold the maximum queue loading
  1    54*   permitted system-wide for each IO type.  From the current loading and
  1    55*   the maximum loading a multiplier fraction is calculated.  These combine
  1    56*   to produce the final optimization multiplier to derive a Logcial Seek
  1    57*   from a Physical Seek. */
  1    58 
  1    59 dcl  1 sys_info aligned based (sysp),
  1    60        3 depth float bin (27),			/* current load */
  1    61        3 max_depth float bin (27),			/* max permissible */
  1    62        3 fraction float bin (27),			/* load fraction */
  1    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  1    64        3 pad bit (18) unaligned;
  1    65 
  1    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  1    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  1    68*   dctl's use. */
  1    69 
  1    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  1    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  1    72 
  1    73 
  1    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  1    75        2 lock bit (36) unal,				/* data base lock */
  1    76        2 nchan fixed bin,				/* number of disk channels */
  1    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  1    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  1    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  1    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  1    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  1    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  1    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  1    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  1    85        2 errors fixed bin,				/* error count */
  1    86        2 ferrors fixed bin,				/* fatal error count */
  1    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  1    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  1    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  1    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  1    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  1    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  1    93 
  1    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  1    95 
  1    96 
  1    97 dcl  qp ptr,					/* pointer to queue entry */
  1    98      cp ptr;					/* pointer to channel information table */
  1    99 
  1   100 
  1   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  1   102*   expansion space.  They will always be positive and upper bits can be
  1   103*   stolen for other fields.
  1   104*
  1   105*   Entries are forward and back linked to permit easy chasing and removal. */
  1   106 
  1   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  1   108 						/* WORD 1 */
  1   109        2 next bit (18) unaligned,			/* forward link */
  1   110        2 prev bit (18) unaligned,			/* back link */
  1   111 						/* WORD 2 */
  1   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  1   113        2 used bit (1) unaligned,			/* entry in use */
  1   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  1   115        2 pad bit (6) unaligned,			/* future expansion */
  1   116        2 coreadd bit (24) unaligned,			/* main memory address */
  1   117 						/* WORD 3 */
  1   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  1   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  1   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  1   121        2 pad2 bit (5) unaligned,
  1   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  1   123 						/* WORD 4 */
  1   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  1   125        2 pad3 bit (9) unaligned,
  1   126        2 sector bit (21) unaligned,			/* device sector desired */
  1   127 						/* WORDS 5&6 */
  1   128        2 time fixed bin (71);				/* clock at queue */
  1   129 
  1   130 
  1   131 
  1   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  1   133        2 chx fixed bin (35),				/* io_manager channel index */
  1   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  1   135        2 statusp ptr,				/* pointer to hardware status word */
  1   136        2 chanid char (8),				/* channel name */
  1   137        (
  1   138        2 pad0 bit (18),
  1   139        2 in_use bit (1),				/* non-zero if channel being used */
  1   140        2 active bit (1),				/* non-zero if channel active */
  1   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  1   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  1   143        2 inop bit (1),				/* non-zero if channel inoperative */
  1   144        2 broken bit (1),				/* non-zero if channel broken */
  1   145        2 action_code bit (2),				/* saved from status */
  1   146        2 pad1 bit (10)
  1   147        ) unal,
  1   148        (
  1   149        2 qrp bit (18),				/* rel ptr to queue entry */
  1   150        2 pad2 bit (3),
  1   151        2 command bit (6),				/* peripheral command */
  1   152        2 erct fixed bin (8)
  1   153        ) unal,					/* error retry count */
  1   154        2 select_data,				/* data passed to IOM on select */
  1   155          (
  1   156          3 limit bit (12),				/* limit on number of sectors */
  1   157          3 mbz bit (3),
  1   158          3 sector bit (21)
  1   159          ) unaligned,				/* sector address */
  1   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  1   161        2 connect_time fixed bin (52),			/* time of last connect */
  1   162        2 connects fixed bin,				/* count of connects performed */
  1   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  1   164        2 rstdcw bit (36),				/* restore command */
  1   165        2 scdcw bit (36),				/* select command */
  1   166        2 sddcw bit (36),				/* select data xfer */
  1   167        2 dcdcw bit (36),				/* command to read or write */
  1   168        2 dddcw bit (36),				/* data xfer DCW */
  1   169        2 dscdcw bit (36),				/* RSR command */
  1   170        2 dsddcw bit (36),				/* RSR data xfer */
  1   171        2 rssdcw bit (36),				/* RSS command */
  1   172        2 status bit (36) aligned,			/* saved status */
  1   173 						/* Lossage counters for interrupt loss. */
  1   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  1   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  1   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  1   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  1   178 
  1   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  1   180        2 sum fixed bin (35),				/* sum of depths */
  1   181        2 count fixed bin (35),			/* allocs */
  1   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  1   183        2 depth fixed bin (17) unaligned,		/* current depth */
  1   184        2 head bit (18) unaligned,			/* queue head */
  1   185        2 tail bit (18) unaligned;			/* queue tail */
  1   186 
  1   187 dcl  dp ptr,					/* pointer to device information table */
  1   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  1   189 
  1   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  1   191        (
  1   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  1   193        2 inop bit (1),				/* device inoperative */
  1   194        2 was_broken bit (1),				/* device previously broken */
  1   195        2 broken bit (1),				/* device down */
  1   196        2 abandoned bit (1),				/* device lost and gone forever */
  1   197        2 forward bit (1),				/* moving low->high */
  1   198        2 pad bit (10),
  1   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  1   200        2 pdi unsigned fixed bin (6)
  1   201        ) unal,					/* primary device index */
  1   202        2 cylinder fixed bin (35),			/* current cylinder position */
  1   203        2 comb fixed bin (35),				/* number of combs */
  1   204        2 pad1 fixed bin (35),
  1   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  1   206        2 wq like qht,				/* work queue */
  1   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  1   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  1   209 
  1   210 
  1   211 /* Optimizing table for device. Must be even multiple words long. */
  1   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  1   213*   Multiplier is calculated from this and current system loading.
  1   214*
  1   215*   sys_info is the offset to the relevant system queue loading fraction. */
  1   216 
  1   217 dcl  1 opt_info aligned based (optp),
  1   218        3 multiplier float bin (27),			/* depth mult */
  1   219        3 slope float bin (27),			/* slope of line */
  1   220        3 intercept float bin (27),			/* Y intercept */
  1   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  1   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  1   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  1   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  1   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  1   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  1   227 
  1   228 
  1   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  1   230        (
  1   231        2 sx fixed bin (11),				/* structure index */
  1   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  1   233        2 unused_sect_per_cyl fixed bin (11)
  1   234        ) unal;					/* # of unused sectors at end of cylinder */
  1   235 
  1   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  1   237        2 count fixed bin,				/* total number of attempts */
  1   238        2 waits fixed bin,				/* number of attempts which required waiting */
  1   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  1   240 
  1   241 dcl  (
  1   242      RST_LISTX init (1),				/* listx for restore */
  1   243      SC_LISTX init (2),				/* listx for select */
  1   244      DSC_LISTX init (6),				/* listx for RSR */
  1   245      RSS_LISTX init (8)
  1   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  1   247 
  1   248 /* IO types defined.  Value is also index of write_map to determine if
  1   249*   the IO type is a read or a write. */
  1   250 
  1   251 dcl  (
  1   252      PAGE_READ init (0),
  1   253      PAGE_WRITE init (1),
  1   254      VTOC_READ init (2),
  1   255      VTOC_WRITE init (3),
  1   256      TEST init (4),
  1   257      BOOTLOAD_READ init (5),
  1   258      BOOTLOAD_WRITE init (6),
  1   259      MAX_IO_TYPE init (6)
  1   260      ) fixed bin (4) static options (constant);
  1   261 
  1   262 dcl  IO_TYPE (0:6) char (16)
  1   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  1   264 	static options (constant);
  1   265 
  1   266 /* Map indexed by IO type to determine if operation is a read or write. */
  1   267 
  1   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  1   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  1   270 
  1   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  1   272 
  1   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  1   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  1   275 
  1   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  1   277 
  1   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  1   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  1   280 
  1   281 /* End of include file ...... dskdcl.incl.pl1 */
      396 
      397  
  2     2 /* BEGIN INCLUDE FILE ... fault_vector.incl.pl1 ... last modified February 1981 */
  2     3 
  2     4 dcl  fvp ptr;					/* pointer to the fault and interrupt vectors */
  2     5 
  2     6 dcl 1 fv based (fvp) aligned,				/* fault and interrupt vectors */
  2     7     2 ipair (0: 31),				/* interrupt pairs */
  2     8       3 scu bit (36),				/* SCU instruction */
  2     9       3 tra bit (36),				/* TRA instruction */
  2    10     2 fpair (0: 31),				/* fault pairs */
  2    11       3 scu bit (36),				/* SCU instruction */
  2    12       3 tra bit (36),				/* TRA instruction */
  2    13     2 i_tra_ptr (0: 31) ptr,				/* ITS pair for interrupt TRA instruction */
  2    14     2 i_scu_ptr (0: 31) ptr,				/* ITS pair for interrupt SCU instruction */
  2    15     2 f_tra_ptr (0: 31) ptr,				/* ITS pairs for fault TRA instruction */
  2    16     2 f_scu_ptr (0: 31) ptr;				/* ITS pairs for fault SCU instruction */
  2    17 
  2    18 /* Fault Types by fault number								*/
  2    19 	
  2    20    dcl (FAULT_NO_SDF  init (0),			/* Shutdown 				*/
  2    21         FAULT_NO_STR  init (1),			/* Store 				*/
  2    22         FAULT_NO_MME  init (2),			/* Master Mode Entry 1			*/
  2    23         FAULT_NO_F1   init (3),			/* Fault Tag 1				*/
  2    24         FAULT_NO_TRO  init (4),			/* Timer Runout				*/
  2    25         FAULT_NO_CMD  init (5),			/* Command				*/
  2    26         FAULT_NO_DRL  init (6),			/* Derail					*/
  2    27         FAULT_NO_LUF  init (7),			/* Lockup					*/
  2    28         FAULT_NO_CON  init (8),			/* Connect				*/
  2    29         FAULT_NO_PAR  init (9),			/* Parity					*/
  2    30         FAULT_NO_IPR  init (10),			/* Illegal Procedure			*/
  2    31         FAULT_NO_ONC  init (11),			/* Operation Not Complete			*/
  2    32         FAULT_NO_SUF  init (12),			/* Startup				*/
  2    33         FAULT_NO_OFL  init (13),			/* Overflow				*/
  2    34         FAULT_NO_DIV  init (14),			/* Divide Check				*/
  2    35         FAULT_NO_EXF  init (15),			/* Execute				*/
  2    36         FAULT_NO_DF0  init (16),			/* Directed Fault 0 (Segment Fault)		*/
  2    37         FAULT_NO_DF1  init (17),			/* Directed Fault 1 (Page Fault)		*/
  2    38         FAULT_NO_DF2  init (18),			/* Directed Fault 2				*/
  2    39         FAULT_NO_DF3  init (19),			/* Directed Fault 3				*/
  2    40         FAULT_NO_ACV  init (20),			/* Access Violation				*/
  2    41         FAULT_NO_MME2 init (21),			/* Master Mode Entry 2			*/
  2    42         FAULT_NO_MME3 init (22),			/* Master Mode Entry 3			*/
  2    43         FAULT_NO_MME4 init (23),			/* Master Mode Entry 4			*/
  2    44         FAULT_NO_F2   init (24),			/* Fault Tag 2 (Linkage Fault)		*/
  2    45         FAULT_NO_F3   init (25),			/* Fault Tag 3				*/
  2    46 						/* Fault Numbers 26-30 unassigned 		*/
  2    47         FAULT_NO_TRB  init (31)			/* Trouble				*/
  2    48 	
  2    49                                 ) fixed bin (17) int static options (constant);
  2    50 	
  2    51 
  2    52 
  2    53 /* END INCLUDE FILE ... fault_vector.incl.pl1 */
  2    54 
      397 
      398  /* Begin include file ...... fs_dev_types.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  3     6*     Add support for FIPS
  3     7*     3380.
  3     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  3     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  3    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  3    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  3    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  3    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 /* Modified 5/19/76 by N. I. Morris */
  3    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  3    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  3    19 /* Modified '82 by BIM for needs_alt_part */
  3    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  3    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  3    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  3    23*   volmap and record stock can be expanded. */
  3    24 
  3    25 /*
  3    26********************************************************************************
  3    27**							        *
  3    28**                           WARNING:                                          *
  3    29**							        *
  3    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  3    31**   type is added.						        *
  3    32**							        *
  3    33**   There are other include files that contain arrays indexed by the device   *
  3    34**   index obtained by references to MODELX or MODELN in this include file.    *
  3    35**   These must be modified when a new device type is added:		        *
  3    36**   disk_pack.incl.pl1					        *
  3    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  3    38**							        *
  3    39********************************************************************************
  3    40**/
  3    41 
  3    42 
  3    43 dcl (maxdevt init (9),				/* maximum legal devt */
  3    44      bulkdevt init (1),				/* bulk store devt */
  3    45      msu0500devt init (2),				/* MSU0500 device type */
  3    46      msu0451devt init (3),				/* MSU0451 device type */
  3    47      msu0450devt init (3),				/* MSU0450 device type */
  3    48      msu0400devt init (4),				/* MSU0400 device type */
  3    49      dsu191devt init (4),				/* DSU191 device type */
  3    50      dsu190devt init (5),				/* DSU190 device type */
  3    51      dsu181devt init (6),				/* DSU181 device type */
  3    52      msu0501devt init (7),				/* MSU0501 device type */
  3    53      fips3380devt init (8),				/* 3380D FIPS device type */
  3    54      fips3381devt init (9)				/* 3380E FIPS device type */
  3    55      ) fixed bin (4) static options (constant);
  3    56 
  3    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  3    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  3    59 
  3    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  3    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  3    62 
  3    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  3    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  3    65 
  3    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  3    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  3    68 
  3    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  3    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  3    71 
  3    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  3    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  3    74 
  3    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  3    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    77 
  3    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  3    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  3    80 
  3    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  3    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    83 
  3    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  3    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  3    86 
  3    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  3    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  3    89 
  3    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  3    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  3    92 
  3    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  3    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  3    95 
  3    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  3    97      ("abc");
  3    98 
  3    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  3   100      init ("a","b","c");
  3   101 
  3   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  3   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  3   104 
  3   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  3   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  3   107 
  3   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  3   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  3   110 
  3   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  3   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  3   113 
  3   114 
  3   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  3   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   117 
  3   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  3   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  3   120 
  3   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  3   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  3   123 
  3   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  3   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   126 
  3   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  3   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  3   129 
  3   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  3   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  3   132 
  3   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  3   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  3   135 
  3   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  3   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  3   138 
  3   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  3   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  3   141 
  4     1 /* Begin fs_dev_types_sector.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  4     7*     Add the sector differance for devices that do 64 word IO and devices that
  4     8*     do 512 word IO.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  4    12*	 need all the data in fs_dev_types. This is also included in
  4    13*	 fs_dev_types.incl.pl1  */
  4    14 
  4    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  4    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  4    17 
  4    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  4    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  4    20 
  4    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  4    22  /* table of # of sectors per record on each device */
  4    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  4    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    25 
  4    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  4    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    28 	
  4    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  4    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  4    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    32 
  4    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  4    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  4    35 
  4    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  4    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  4    38 
  4    39 /* End fs_dev_types_sector.incl.pl1 */
  4    40 
  3   142 
  3   143 
  3   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      398 
      399  /*  START OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 /* Written by Charles Hornig, 1st quarter 1981 */
  5     4 /* Canonicalization entry added by Chris Jones, January 1984 */
  5     5 
  5     6 /* chanid = canonicalize_chanid (chanid); */
  5     7 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5     8 dcl	io_chnl_util$canonicalize_chanid
  5     9 			   entry (char (8) aligned) returns (char (8) aligned);
  5    10 
  5    11 /* call iom_to_name (iomno, channo, name, code); */
  5    12 dcl	io_chnl_util$iom_to_name
  5    13 			   entry (fixed bin (3), fixed bin (7), char (8) aligned, fixed bin (35));
  5    14 
  5    15 /* call name_to_iom (name, iomno, channo, code); */
  5    16 dcl	io_chnl_util$name_to_iom
  5    17 			   entry (char (8) aligned, fixed bin (3), fixed bin (7), fixed bin (35));
  5    18 
  5    19 /*  END OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      399 
      400  /* Begin include file iom_chan_control_words 12/82 BIM */
  6     2 /* Unsigned and named-constanted pcw, idcw, dcw, tdcw */
  6     3 /* format: style3 */
  6     4 
  6     5 dcl	pcw_ptr		ptr;			/* pointer to PCW */
  6     6 
  6     7 dcl	1 pcw		based (pcw_ptr) aligned,	/* Peripheral Control Word */
  6     8 	( 2 command	bit (6),			/* device command */
  6     9 	  2 device	fixed bin (6) unsigned,	/* device code */
  6    10 	  2 ext		fixed bin (6) unsigned,	/* address extension (addr - mod (addr, 256K)) */
  6    11 	  2 code		bit (3),			/* must be "111"b for PCW */
  6    12 	  2 mask		bit (1),			/* channel mask bit */
  6    13 	  2 control	bit (2),			/* terminate/proceed and marker control bits */
  6    14 	  2 chan_cmd	bit (6),			/* type of I/O operation */
  6    15 	  2 count		fixed bin (6) unsigned,	/* record count or control character */
  6    16 	  2 mbz1		bit (3),
  6    17 	  2 channel	fixed bin (6) unsigned,	/* channel number */
  6    18 	  2 mbz2		bit (27)
  6    19 	  )		unal;
  6    20 
  6    21 dcl	idcw_ptr		ptr;			/* pointer to IDCW */
  6    22 
  6    23 dcl	1 idcw		based (idcw_ptr) aligned,	/* Instruction DCW */
  6    24 	( 2 command	bit (6),			/* device command */
  6    25 	  2 device	fixed bin (6) unsigned,	/* device code */
  6    26 	  2 ext		fixed bin (6) unsigned,	/* address extension */
  6    27 	  2 code		bit (3),			/* should be "111"b for PCW */
  6    28 	  2 ext_ctl	bit (1),			/* "1"b if address extension to be used */
  6    29 	  2 control	bit (2),			/* terminate/proceed and marker control bits */
  6    30 	  2 chan_cmd	bit (6),			/* type of I/O operation */
  6    31 	  2 count		fixed bin (6) unsigned
  6    32 	  )		unal;			/* record count or control character */
  6    33 
  6    34 dcl	PCW_INIT_STRING	bit (72) aligned init ("000000700000000000000000"b3) int static options (constant);
  6    35 dcl	IDCW_INIT_STRING	bit (36) aligned init ("000000700000"b3) int static options (constant);
  6    36 
  6    37 /* Values for chan_cmd */
  6    38 
  6    39 dcl	(
  6    40 	SINGLE_RECORD	init ("00"b3),
  6    41 	NONDATA		init ("02"b3),
  6    42 	MULTIRECORD	init ("06"b3),
  6    43 	SINGLE_CHARACTER	init ("10"b3)
  6    44 	)		bit (6) int static options (constant);
  6    45 
  6    46 /* Values for control */
  6    47 
  6    48 dcl	(
  6    49 	TERMINATE		init ("00"b),
  6    50 	PROCEED		init ("10"b),
  6    51 	MARKER		init ("11"b)
  6    52 	)		bit (2) int static options (constant);
  6    53 
  6    54 
  6    55 dcl	dcw_ptr		ptr;			/* pointer to DCW */
  6    56 dcl	tdcw_ptr		ptr;			/* pointer to TDCW */
  6    57 
  6    58 dcl	1 dcw		based (dcw_ptr) aligned,	/* Data Control Word */
  6    59 	( 2 address	fixed bin (18) unsigned,	/* address for data transfer */
  6    60 	  2 char_pos	fixed bin (3) unsigned,	/* character position */
  6    61 	  2 m64		bit (1),			/* non-zero for mod 64 address */
  6    62 	  2 type		bit (2),			/* DCW type */
  6    63 	  2 tally		fixed bin (12) unsigned
  6    64 	  )		unal;			/* tally for data transfer -- 0 => 4096 */
  6    65 
  6    66 dcl	1 tdcw		based (tdcw_ptr) aligned,	/* Transfer DCW */
  6    67 	( 2 address	fixed bin (18) unsigned,	/* address to transfer to */
  6    68 	  2 mbz1		bit (4),
  6    69 	  2 type		bit (2),			/* should be "10"b for TDCW */
  6    70 	  2 mbz2		bit (9),
  6    71 	  2 ec		bit (1),			/* non-zero to set LPW AE bit */
  6    72 	  2 res		bit (1),			/* non-zero to restrict further use of IDCW */
  6    73 	  2 rel		bit (1)
  6    74 	  )		unal;			/* non-zero to set relative mode after transfer */
  6    75 
  6    76 dcl	IOTD_INIT_STRING	bit (36) init ("000000000000"b3) int static options (constant);
  6    77 dcl	IOTP_INIT_STRING	bit (36) init ("000000010000"b3) int static options (constant);
  6    78 dcl	IONTP_INIT_STRING	bit (36) init ("000000030000"b3) int static options (constant);
  6    79 dcl	TDCW_INIT_STRING	bit (36) init ("000000020000"b3) int static options (constant);
  6    80 
  6    81 dcl	(
  6    82 	IOTD		init ("00"b),		/* Transfer and Disconnect */
  6    83 	IOTP		init ("01"b),		/* Transfer and Proceed */
  6    84 	IONTP		init ("11"b),		/* Discard data and Proceed */
  6    85 	TDCW		init ("10"b)		/* interpret as TDCW */
  6    86 	)		bit (2) aligned int static options (constant);
  6    87 
  6    88 
  6    89 /* End include file iom_chan_control_words.incl.pl1 */
      400 
      401  /* Begin include file ...... iom_data.incl.pl1
  7     2*   First written in August 1971 by R F Mabee.
  7     3*   Modified for paged IOM November 1980 by C. Hornig.
  7     4*   More IIOC changes by C. Hornig, June 1982.
  7     5*   Modified for channel reconfiguration by Chris Jones, January 1984.
  7     6*   Modified to remove support of non-paged IOMs by Chris Jones, August 1984.
  7     7*   Modified to add IMW read protocol flags by M. Pandolf, January 1985.
  7     8**/
  7     9 
  7    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  7    11 dcl	iom_data$		   external;
  7    12 dcl	iom_mailbox$	   external;
  7    13 
  7    14 dcl	n_devices		   fixed bin;
  7    15 dcl	iom_data_ptr	   ptr;
  7    16 
  7    17 dcl	1 iom_data	   based (iom_data_ptr) aligned,
  7    18 	  2 n_devices	   fixed bin,		/* (0) Maximum number of channels. */
  7    19 	  2 stop_lpw	   bit (36),		/* (1) LPW pointing to stop_dcw. */
  7    20 	  2 stop_dcw	   bit (36),		/* (2) DCW to stop channel, probably storing bad status. */
  7    21 	  2 stop_scw	   bit (36),		/* (3) SCW for same */
  7    22 	  2 imw_lock	   fixed bin (35),		/* (4) Essentially a lock for iom switch checking: */
  7    23 						/* 1  : OK to poll IMW */
  7    24 						/* 0  : lock in transition */
  7    25 						/* -1 : DONT poll IMW */
  7    26 	  2 n_intr_procs fixed bin (35),		/* (5) Number of processors in interrupt handler */
  7    27 	  2 pad1		   (2) bit (36),
  7    28 	  2 stop_status	   bit (72),		/* (10) All unused channels store status here. */
  7    29 	  2 rfh1		   (6) bit (36),		/* can't use this */
  7    30 	  2 stop_ext_status	   bit (8 * 36),		/* (20) Unused channels' extended status */
  7    31 	  2 pad3		   (5) bit (36),
  7    32 	  2 invalid_interrupts fixed bin (35),		/* (35) interrupts on unused channels */
  7    33 	  2 null_interrupts	   fixed bin (35),		/* (36) spurious interrupts */
  7    34 	  2 multiple_interrupts
  7    35 			   fixed bin (35),		/* (37) several interrupts at a time */
  7    36 	  2 per_iom	   (4) like per_iom,	/* (40) for each IOM */
  7    37 	  2 per_device	   (n_devices refer (iom_data.n_devices)) like per_device;
  7    38 						/* (240) Data for assigned channels. */
  7    39 
  7    40 dcl	1 per_iom		   aligned based,
  7    41 	  2 lock		   bit (36),		/* (40) connect mailbox lock */
  7    42 	  2 flags,				/* (41) */
  7    43 	    3 configured	   bit (1) unal,		/* is configured */
  7    44 	    3 on_line	   bit (1) unal,		/* is ON */
  7    45 	    3 pad1	   bit (34) unal,
  7    46 	  2 model		   char (4),		/* (42) what kind of IOM */
  7    47 	  2 port		   fixed bin (3),		/* (43) SC port */
  7    48 	  2 connect_time	   fixed bin (71),		/* (44) time of last connect */
  7    49 	  2 connect_lpw	   bit (36),		/* (46) LPW for connect channel */
  7    50 	  2 cow		   bit (36),		/* (47) Connect Operand Word */
  7    51 	  2 special_chx	   fixed bin (35),		/* (50) chx of special status channel */
  7    52 	  2 fault_chx	   fixed bin (35),		/* (51) chx of system fault channel */
  7    53 	  2 pad2		   (4) bit (36),
  7    54 	  2 abandoned_connects fixed bin (35),		/* (56) times we couldn't get IOM to listen at all */
  7    55 	  2 reconnects	   fixed bin (35),		/* (57) times a connect was lost */
  7    56 	  2 chantab	   (0:63) uns fixed bin (9) unal;
  7    57 						/* (60) packed devtab indices */
  7    58 
  7    59 dcl	1 per_device	   aligned based,
  7    60 	  2 status	   bit (72),		/* (0) Status for channel is stored here. */
  7    61 	  2 rfh1		   (6) bit (36),
  7    62 	  2 ext_status	   bit (8 * 36),		/* (10) extended status stored by IIOC */
  7    63 	  2 iom		   uns fixed bin (3),	/* (20) IOM# (1-4) */
  7    64 	  2 channel	   uns fixed bin (6),	/* (21) channel # */
  7    65 	  2 handler	   entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  7    66 						/* (22) Interrupt handler for device. */
  7    67 	  2 flags,				/* (26) */
  7    68 	    3 in_use	   bit (1) unal,		/* assigned */
  7    69 	    3 queue_status	   bit (1) unal,		/* maintain status queue */
  7    70 	    3 on_line	   bit (1) unal,		/* can be assigned */
  7    71 	  2 index		   fixed bin (35),		/* (27) Channel identification index. */
  7    72 	  2 pcw		   bit (72),		/* (30) Peripheral Control Word */
  7    73 	  2 lpw		   bit (72),		/* (32) List Pointer Word */
  7    74 	  2 scw		   bit (36),		/* (34) Status Control Word */
  7    75 	  2 pad1		   fixed bin (35),
  7    76 	  2 status_queue_ptr   ptr,			/* (36) Status queue */
  7    77 	  2 connect_time	   fixed bin (71),		/* (40) time of last connect */
  7    78 	  2 connects	   fixed bin (71),		/* (42) Total connects */
  7    79 	  2 interrupts	   fixed bin (71),		/* (44) Total number of interrupts for this channel. */
  7    80 	  2 interrupt_time	   fixed bin (71);		/* (46) Total interrupt time for this channel. */
  7    81 
  7    82 dcl	iom_mailbox_seg_ptr	   ptr;
  7    83 dcl	1 iom_mailbox_seg	   aligned based (iom_mailbox_seg_ptr),
  7    84 	  2 imw_array	   (0:31) bit (32),		/* Indexed by interrupt cell number. One bit for each channel. */
  7    85 	  2 system_fault	   (4) aligned like status_queue,
  7    86 						/* system faults store here (12 words/IOM) */
  7    87 	  2 special_status	   (4) aligned like status_queue,
  7    88 						/* special status words here (12 words/IOM) */
  7    89 	  2 iom_mailbox	   (4) like iom_mailbox;	/* Used to communicate with the IOM. */
  7    90 
  7    91 dcl	status_queue_ptr	   ptr;
  7    92 dcl	1 status_queue	   aligned based (status_queue_ptr),
  7    93 	  2 status	   (12) bit (36);
  7    94 
  7    95 dcl	1 iom_mailbox	   aligned based,
  7    96 	  2 channel_mailbox	   (0:63) like channel_mailbox;
  7    97 
  7    98 dcl	1 channel_mailbox	   aligned based,
  7    99 	  2 lpw		   bit (72),		/* List pointer word. Points to DCW list. */
  7   100 	  2 scw		   bit (36),		/* Status control word. Points to channel_table.status. */
  7   101 	  2 dcw		   bit (36);		/* Data control word. Primarily scratch space for IOM. */
  7   102 
  7   103 /* Defined channel numbers. */
  7   104 
  7   105 dcl	(
  7   106 	system_fault_channel   init (1),		/* Stores system fault words using LPW and DCW. */
  7   107 	connect_channel	   init (2),		/* Starts other channels using LPW pointing to PCW. */
  7   108 	special_status_channel init (6)		/* Stores special status using LPW and DCW. */
  7   109 	)		   fixed bin (6) static options (constant);
  7   110 
  7   111 /* End of include file ..... iom_data.incl.pl1 */
      401 
      402  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  8     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  8     8*     Add the support for subvolumes
  8     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  8    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  8    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  8    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  8    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  8    14*     Added inconsistent_dbm bit for determining the status of volume
  8    15*     dumper bit maps.
  8    16*                                                   END HISTORY COMMENTS */
  8    17 
  8    18      dcl	   pvt$array	      aligned external;
  8    19      dcl	   pvt$max_n_entries      fixed bin external;
  8    20 
  8    21      dcl	   pvt_arrayp	      ptr;
  8    22      dcl	   pvtep		      ptr;
  8    23 
  8    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  8    25 
  8    26      dcl	   1 pvte		      based (pvtep) aligned,
  8    27 
  8    28 	     2 pvid	      bit (36),		/* physical volume ID */
  8    29 
  8    30 	     2 lvid	      bit (36),		/* logical volume ID */
  8    31 
  8    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  8    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  8    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  8    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  8    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  8    37 	     2 pad3	      bit (2) unaligned,
  8    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  8    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  8    40 
  8    41 
  8    42 
  8    43 	     2 devname	      char (4),		/* device name */
  8    44 
  8    45 	     (2 device_type	      fixed bin (8),	/* device type */
  8    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  8    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  8    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  8    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  8    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  8    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  8    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  8    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  8    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  8    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  8    56 	     2 scav_check_address
  8    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  8    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  8    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  8    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  8    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  8    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  8    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  8    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  8    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  8    66 
  8    67 
  8    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  8    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  8    70 
  8    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  8    72 
  8    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  8    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  8    75 
  8    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  8    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  8    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  8    79 	     2 records_per_cyl    fixed bin,
  8    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  8    81 	     2 sv_name            char (2) aligned,
  8    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  8    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  8    84 
  8    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  8    86 	     2 pad2	      bit (18) unaligned,
  8    87 
  8    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  8    89 
  8    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  8    91 
  8    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  8    93 
  8    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  8    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  8    96 
  8    97 
  8    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  8    99 
  8   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  8   101 
  8   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  8   103 
  8   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  8   105 
  8   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  8   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  8   108 
  8   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  8   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  8   111 
  8   112 
  8   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  8   114 	   VOLMAP_ASYNC_READ      init (1),
  8   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  8   116 
  8   117 
  8   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      402 
      403  /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  9     2 /* format: style4 */
  9     3 
  9     4 /* Information about system controllers */
  9     5 
  9     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  9     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  9     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  9     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  9    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  9    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  9    12          3 mbz bit (3) unaligned,
  9    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  9    14        2 info aligned,
  9    15          3 online bit (1) unaligned,			/* ON if controller is online */
  9    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  9    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  9    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  9    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  9    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  9    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  9    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  9    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  9    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  9    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  9    26          3 type bit (4) unaligned,			/* Model number for this controller */
  9    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  9    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  9    29          3 mbz bit (13) unaligned,
  9    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  9    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  9    32 
  9    33 /* Information about CPUs */
  9    34 
  9    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  9    36        (
  9    37        2 online bit (1),				/* "1"b if CPU is online */
  9    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  9    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  9    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  9    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  9    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  9    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  9    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  9    45        2 mbz1 bit (6),
  9    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  9    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  9    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  9    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  9    50        2 mbz2 bit (12),
  9    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  9    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  9    53        2 controller_port fixed bin (3) unsigned
  9    54        ) unaligned;					/* Port on controller */
  9    55 
  9    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  9    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  9    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  9    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  9    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  9    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  9    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  9    63        2 pad bit (12) unaligned;
  9    64 
  9    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  9    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  9    67        2 cow,
  9    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  9    69          3 mbz1 bit (13) unaligned,
  9    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  9    71          3 mbz2 bit (2) unaligned,
  9    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  9    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  9    74          3 mbz3 bit (3) unaligned,
  9    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  9    76 
  9    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  9    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  9    79        2 pad bit (12) unal,
  9    80        2 tag bit (6) unal;				/* Better be zero. */
  9    81 
  9    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  9    83        2 pad bit (36) aligned,
  9    84        2 cow,					/* Connect operand word, in odd location. */
  9    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  9    86          3 mbz1 bit (13) unaligned,
  9    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  9    88          3 mbz2 bit (9) unaligned,
  9    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  9    90 
  9    91 /* MASKS and PATTERNS */
  9    92 
  9    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  9    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  9    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  9    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  9    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  9    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  9    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  9   100 
  9   101 /* CAM and CACHE clear info */
  9   102 
  9   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  9   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  9   105 
  9   106 /* MASKING INSTRUCTIONS & POINTERS */
  9   107 
  9   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  9   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  9   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  9   111 
  9   112 /* MISCELLANEOUS */
  9   113 
  9   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  9   115        (
  9   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  9   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  9   118        2 pad1 bit (4),
  9   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  9   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  9   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  9   122        2 mask_cpu fixed bin (5)
  9   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  9   124 
  9   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  9   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  9   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  9   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  9   129 
  9   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  9   131 
  9   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  9   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  9   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  9   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  9   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  9   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  9   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  9   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  9   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  9   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  9   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  9   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  9   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  9   145 
  9   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  9   147 
  9   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  9   149 
  9   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  9   151 
  9   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  9   153 
  9   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  9   155 						/* Which ports have expanders */
  9   156 
  9   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  9   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  9   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  9   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  9   161 
  9   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  9   163 
  9   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  9   165 						/* Controller size on config card */
  9   166 
  9   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  9   168 
  9   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  9   170 						/* PTWs for SCAS pages */
  9   171 
  9   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  9   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  9   174 
  9   175 
  9   176 dcl  (
  9   177      IOM_PORT init (1),
  9   178      CPU_PORT init (2),
  9   179      BULK_PORT init (3)
  9   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  9   181 
  9   182 
  9   183 /* END INCLUDE FILE scs.incl.pl1 */
      403 
      404  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 10     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 10     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 10     4 
 10     5 /* This include file has an ALM version.  Keep 'em in sync! */
 10     6 
 10     7 dcl (
 10     8 
 10     9 /* The following constants define the message action codes.  This indicates
 10    10*how a message is to be handled.  */
 10    11 
 10    12      SYSERR_CRASH_SYSTEM	init (1),			
 10    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 10    14 
 10    15      SYSERR_TERMINATE_PROCESS	init (2),
 10    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 10    17 
 10    18      SYSERR_PRINT_WITH_ALARM	init (3),
 10    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 10    20 
 10    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 10    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 10    23 
 10    24      SYSERR_LOG_OR_PRINT	init (4),
 10    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 10    26 
 10    27      SYSERR_LOG_OR_DISCARD	init (5),
 10    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 10    29 
 10    30 
 10    31 /* The following constants are added to the normal severities to indicate
 10    32*different sorting classes of messages.  */
 10    33 
 10    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 10    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 10    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 10    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 10    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 10    39 	) fixed bin internal static options (constant);
 10    40 
 10    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      404 
      405  /* BEGIN include file toehold_save_dcls_.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(83-08-01,Margulies), approve(), audit(), install():
 11     6*     Initial coding by Margulies and Loepere.
 11     7*  2) change(85-01-09,Fawcett), approve(85-09-09,MCR6979),
 11     8*     audit(86-01-31,GDixon), install(86-03-21,MR12.0-1033):
 11     9*     Support of FIPS 3380 cylinder size.
 11    10*                                                   END HISTORY COMMENTS */
 11    11 
 11    12 
 11    13 /* structures that desribe data in the toehold and the save partition */
 11    14 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 11    15 
 11    16 /* WARNING - this include file has an alm counterpart maintained by
 11    17*convert_include_file, as well as a simplified version (toe_hold.incl.pl1)
 11    18*and its convert_include_file maintained alm counterpart. 
 11    19*Exclude prn, prv and pad when converting to the alm version. */
 11    20 
 11    21 dcl  toehold_ptr		        ptr;
 11    22 dcl  toehold$		        (2048) bit (36) external;
 11    23 
 11    24 dcl  1 toehold		        aligned based (toehold_ptr),
 11    25        2 entry_sequences	        (0:15) bit (72) aligned,
 11    26        2 flagbox		        (64) bit (36) aligned,
 11    27        2 handler_mc		        aligned like mc,
 11    28        2 paths		        (4) like io_path,
 11    29        2 n_paths_used	        fixed bin,
 11    30        2 memory_state	        fixed bin,
 11    31        2 bce_dbr		        bit (72) aligned,
 11    32        2 bce_mode_reg	        bit (36) aligned,	/* double word pair with bce_cache_mode_reg */
 11    33        2 bce_cache_mode_reg	        bit (36) aligned,
 11    34        2 esd_segnum		        fixed bin (15),
 11    35 
 11    36        2 dcw_list_size	        fixed bin (17) unaligned, /* the size of the dcw_list used by toehold.alm (upper half) */
 11    37        2 dcws_per_cyl	        fixed bin (17) unaligned, /* number of dcws needed to write 1 pages on 1 cyl*/
 11    38        2 seeks_used		        fixed bin,		/* number of cyls needed to write 512 records	*/
 11    39 						/*   plus 1 for seek at 256K boundary.		*/
 11    40        2 save_dcws		        (260) fixed bin (35), /* Region for dcw_list adjusted to RPV devtype.	*/
 11    41 						/*   Writes Multics low memory (512K) into bce	*/
 11    42 						/*   partition prior to invoking bce; or reads	*/
 11    43 						/*   from partition back into memory prior to	*/
 11    44 						/*   return to Multics.			*/
 11    45        2 handler_dcws	        (260) fixed bin (35), /* Region for dcw_list adjusted to RPV devtype.	*/
 11    46 						/*   Reads/writes bce low memory from/to bce	*/
 11    47 						/*   partition when invoking/returning from bce.	*/
 11    48 
 11    49        2 pad2		        (255) bit (36) aligned,
 11    50        2 handler_code	        (288) fixed bin (71),
 11    51        2 multics_state	        like mc_state;
 11    52 
 11    53 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    54 /*							       */
 11    55 /* 512 records (pages) of low-order memory must be exchanged between memory  */
 11    56 /* and disk when Multics transfers to bce or vice versa.  Device types hold  */
 11    57 /* different numbers of records per cylinder (see fs_dev_types.incl.pl1).    */
 11    58 /* Thus, a different number of cylinders is needed to hold 512 records for   */
 11    59 /* each type of device.  Because there must be a dcw for every 4 records     */
 11    60 /* (pages) of data written to disk, the shape of the dcw_list varies	       */
 11    61 /* depending upon the type of device used for the RPV.		       */
 11    62 /*							       */
 11    63 /* A second consideration is that there must be a separate seek operation    */
 11    64 /* after writing the 256th page of the low memory region in absolute mode.   */
 11    65 /*							       */
 11    66 /* Also the iom_mailbox and toehold area is not saved nor is it restored.    */
 11    67 /* This skip of memory locations causes an additional seek.		       */
 11    68 /*							       */
 11    69 /* Thus, room for an extra two seeks must be added to the cylinder counts    */
 11    70 /* computed below.						       */
 11    71 /*							       */
 11    72 /* Note that a separate connect operation is done for each seek.	       */
 11    73 /*							       */
 11    74 /* The table below shows the shape for each supported device type.	       */
 11    75 /*   recs_per_cyl 	        comes from fs_dev_types.incl.pl1.	       */
 11    76 /*   cyls_per_512k          = ceil (512 / recs_per_cyl)		       */
 11    77 /*   seeks_per_512k	        = cyls_per_512k + 1 seek_at_256k_boundary	       */
 11    78 /*			+ 1 seek_after_skip
 11    79*/*   dcws_per_cyl	        = ceil (recs_per_cyl / 4 recs_per_dcw)	       */
 11    80 /*   currentsize(dcw_list)  is the PL/I builtin function result.  This       */
 11    81 /*		        size must fit within the 260 words allocated     */
 11    82 /*		        above for save_dcws and handler_dcws.	       */
 11    83 /*							       */
 11    84 /*  DEVICE   RECORDS  CYL PER   SEEKS    DCWS PER  currentsize	       */
 11    85 /*   TYPE    PER CYL    512K   PER 512K     CYL     (dcw_list)	       */
 11    86 /*  ------   -------  -------  --------  --------  -----------	       */
 11    87 /* 400,451,						       */
 11    88 /*    500       47       11       13         12        208 =13*(12+4)        */
 11    89 /*							       */
 11    90 /*    501       80        7        9         20	     216 = 9*(20+4)	       */
 11    91 /*							       */
 11    92 /*   3380      127        5        7         32        252 = 7*(32+4)	       */
 11    93 /*							       */
 11    94 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    95 
 11    96 dcl  dcw_list_ptr		        ptr;
 11    97 dcl  1 dcw_list		        (toehold.seeks_used) aligned based (dcw_list_ptr),
 11    98        2 seek_addresses	        fixed bin (35),	/* This array overlays toehold.save_dcws and	*/
 11    99        2 seek_idcw		        bit (36) aligned,	/*   .handler_dcws				*/
 11   100        2 seek_dcw		        bit (36) aligned,
 11   101        2 data_idcw		        bit (36) aligned,
 11   102        2 data_dcws		        (toehold.dcws_per_cyl) bit (36) aligned;
 11   103 
 11   104  /* BEGIN include file bce_partition_layout.incl.pl1
 12     2*This is the layout of the bce partition for bootload Multics.
 12     3*Written September 1983 by Keith Loepere. */
 12     4 
 12     5 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 12     6 
 12     7 dcl  BCE_PART_LTH		        init (2200) fixed bin internal static options (constant);  /* This is the default value. */
 12     8 dcl  SAVED_IMAGE_RECORDX	        init (0) fixed bin internal static options (constant);
 12     9 dcl  CRASH_HANDLER_RECORDX	        init (512) fixed bin internal static options (constant);
 12    10 dcl  BCE_PAGING_AREA_RECORDX	        init (1024) fixed bin internal static options (constant);
 12    11 dcl  BCE_PAGING_AREA_LTH	        init (128) fixed bin internal static options (constant);
 12    12 dcl  MST_AREA_RECORDX	        init (1152) fixed bin internal static options (constant);
 12    13 
 12    14 /* END include file bce_partition_layout.incl.pl1 */
 11   104 
 11   105  /* BEGIN include file toehold.incl.pl1 */
 13     2 
 13     3 /* Various reserved entrypoints into the bce toehold.
 13     4*Also, only those things one really needs to know about the toehold.
 13     5*Keith Loepere, October 1983. */
 13     6 
 13     7 /* Exclude prn, prv and pad when converting to alm version. */
 13     8 
 13     9 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 13    10 
 13    11 dcl  1 toe_hold		        aligned based,	/* name so alm likes */
 13    12        2 entry_sequences	        (0:15) bit (72) aligned, /* described below */
 13    13        2 flagbox		        (64) bit (36) aligned,
 13    14        2 pad1		        (48) bit (36) aligned,
 13    15        2 paths		        (4) like io_path,
 13    16        2 n_paths_used	        fixed bin,
 13    17        2 memory_state	        fixed bin,		/* of memory/disk swapping, etc. */
 13    18        2 bce_dbr		        bit (72) aligned,	/* of bce */
 13    19        2 pad2		        (1355) bit (36) aligned,
 13    20        2 multics_state	        aligned like mc_state;
 13    21 
 13    22 dcl  1 io_path		        aligned based,
 13    23        2 pcw		        fixed bin (71) aligned,
 13    24 
 13    25        2 port_number	        fixed bin (3) uns unal, /* these fields form the word that */
 13    26        2 iom_number		        fixed bin (15) uns unal, /* must be changed upon */
 13    27        2 channel_number	        fixed bin unal,	/* reconfiguration of channels */
 13    28 
 13    29        2 pad		        bit (36) aligned;
 13    30 
 13    31 dcl  TOE_HOLD_CRASH_ENTRY	        fixed bin init (0) static options (constant); /* operator causes crash by xed'ind here */
 13    32 dcl  TOE_HOLD_ESD_ENTRY	        fixed bin init (1) static options (constant);
 13    33 dcl  TOE_HOLD_DUMP_ENTRY	        fixed bin init (2) static options (constant); /* place that causes an early dump */
 13    34 dcl  TOE_HOLD_MULTICS_ENTRY	        fixed bin init (3) static options (constant); /* Multics crashes by drl'ing here */
 13    35 dcl  TOE_HOLD_RESTART_ENTRY	        fixed bin init (4) static options (constant); /* bce restarts Multics by drl'ing here */
 13    36 dcl  TOE_HOLD_BOOT_ENTRY	        fixed bin init (5) static options (constant); /* bootload_tape_label starts init by tra'ing here */
 13    37 dcl  TOE_HOLD_BOS_ENTRY	        fixed bin init (12) static options (constant);
 13    38 dcl  TOE_HOLD_BOS_NO_SAVE_ENTRY       fixed bin init (13) static options (constant);
 13    39 dcl  TOE_HOLD_BOS_MULTICS_ENTRY       fixed bin init (14) static options (constant);
 13    40 
 13    41 declare  mc_state_ptr	        ptr;	/* to toehold$.multics_state */
 13    42 declare 1 mc_state		        aligned based (mc_state_ptr),
 13    43        2 mc_		        aligned like mc,		        
 13    44        2 masks		        (16) bit (36) aligned,
 13    45        2 interrupt		        bit (72) aligned,
 13    46        2 mode_reg		        bit (36) aligned,	/* mode_reg and cache_mode_reg form a double word pair */
 13    47        2 cache_mode_reg	        bit (36) aligned,
 13    48        2 dbr		        bit (72) aligned,
 13    49        2 cfg		        bit (72) aligned,
 13    50        2 bar		        bit (36) aligned,
 13    51        2 old_memory_state	        fixed bin,
 13    52        2 pad16		        (6) bit (36) aligned,
 13    53        2 ou_history_registers	        (0: 15) bit (72) aligned,
 13    54        2 cu_history_registers	        (0: 15) bit (72) aligned,
 13    55        2 du_history_registers	        (0: 15) bit (72) aligned,
 13    56        2 apu_history_registers        (0: 15) bit (72) aligned,
 13    57        2 ptwam_ptrs		        (0: 63) bit (36) aligned,	/* word alignment (mod 16, 32) of these am's matters */
 13    58        2 ptwam_regs		        (0: 63) bit (36) aligned,
 13    59        2 sdwam_ptrs		        (0: 63) bit (36) aligned,
 13    60        2 sdwam_regs		        (0: 63) bit (72) aligned;
 13    61 
 13    62 /* values for memory_state */
 13    63 
 13    64 dcl  Initial_undefined	        fixed bin init (0) static options (constant);  /* initial coming to bce */
 13    65 dcl  At_bce__early		        fixed bin init (1) static options (constant);
 13    66 dcl  At_bce__boot		        fixed bin init (2) static options (constant);  /* at bce during cool boot phase */
 13    67 dcl  Multics		        fixed bin init (3) static options (constant);  /* Multics coming up */
 13    68 dcl  Undefined_saving_state	        fixed bin init (4) static options (constant);  /* saving state during coming down */
 13    69 dcl  Undefined_reading_bce	        fixed bin init (5) static options (constant);  /* reading in bce */
 13    70 dcl  At_bce__crash		        fixed bin init (6) static options (constant);  /* disk holds Multics, at bce */
 13    71 dcl  At_bce__shutdown	        fixed bin init (7) static options (constant);  /* disk holds (nothing), coming to bce */
 13    72 dcl  Undefined_continue	        fixed bin init (8) static options (constant);  /* swapping memory back */
 13    73 dcl  Undefined_saving_mem	        fixed bin init (9) static options (constant);
 13    74 
 13    75  /*  */
 14     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 14     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 14     4 /* Modified 07/07/76 by Morris for fault register data */
 14     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 14     6 /* Modified '82 to make values constant */
 14     7 
 14     8 /* words 0-15 pointer registers */
 14     9 
 14    10 dcl  mcp ptr;
 14    11 
 14    12 dcl 1 mc based (mcp) aligned,
 14    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 14    14    (2 regs,					/* registers */
 14    15       3 x (0:7) bit (18),				/* index registers */
 14    16       3 a bit (36),					/* accumulator */
 14    17       3 q bit (36),					/* q-register */
 14    18       3 e bit (8),					/* exponent */
 14    19       3 pad1 bit (28),
 14    20       3 t bit (27),					/* timer register */
 14    21       3 pad2 bit (6),
 14    22       3 ralr bit (3),				/* ring alarm register */
 14    23 
 14    24     2 scu (0:7) bit (36),
 14    25 
 14    26     2 mask bit (72),				/* mem controller mask at time of fault */
 14    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 14    28     2 errcode fixed bin (35),				/* fault handler's error code */
 14    29     2 fim_temp,
 14    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 14    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 14    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 14    33     2 fault_reg bit (36),				/* fault register */
 14    34     2 pad2 bit (1),
 14    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 14    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 14    37     2 fault_time bit (54),				/* time of fault */
 14    38 
 14    39     2 eis_info (0:7) bit (36)) unaligned;
 14    40 
 14    41 
 14    42 dcl (apx fixed bin init (0),
 14    43      abx fixed bin init (1),
 14    44      bpx fixed bin init (2),
 14    45      bbx fixed bin init (3),
 14    46      lpx fixed bin init (4),
 14    47      lbx fixed bin init (5),
 14    48      spx fixed bin init (6),
 14    49      sbx fixed bin init (7)) internal static options (constant);
 14    50 
 14    51 
 14    52 
 14    53 
 14    54 dcl  scup ptr;
 14    55 
 14    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 14    57 
 14    58 
 14    59 /*	WORD (0)		*/
 14    60 
 14    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 14    62       3 prr bit (3),				/* procedure ring register */
 14    63       3 psr bit (15),				/* procedure segment register */
 14    64       3 p bit (1),					/* procedure privileged bit */
 14    65 
 14    66     2 apu,					/* APPENDING UNIT STATUS */
 14    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 14    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 14    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 14    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 14    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 14    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 14    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 14    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 14    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 14    76       3 ptw bit (1),				/* Fetch of PTW */
 14    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 14    78       3 fap bit (1),				/* Fetch of final address paged */
 14    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 14    80       3 fabs bit (1),				/* Fetch of final address absolute */
 14    81 
 14    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 14    83 
 14    84 
 14    85 /*	WORD (1)		*/
 14    86 
 14    87     2 fd,						/* FAULT  DATA */
 14    88       3 iro bit (1),				/* illegal ring order */
 14    89       3 oeb bit (1),				/* out of execute bracket */
 14    90       3 e_off bit (1),				/* no execute */
 14    91       3 orb bit (1),				/* out of read bracket */
 14    92       3 r_off bit (1),				/* no read */
 14    93       3 owb bit (1),				/* out of write bracket */
 14    94       3 w_off bit (1),				/* no write */
 14    95       3 no_ga bit (1),				/* not a gate */
 14    96       3 ocb bit (1),				/* out of call bracket */
 14    97       3 ocall bit (1),				/* outward call */
 14    98       3 boc bit (1),				/* bad outward call */
 14    99       3 inret bit (1),				/* inward return */
 14   100       3 crt bit (1),				/* cross ring transfer */
 14   101       3 ralr bit (1),				/* ring alarm register */
 14   102       3 am_er bit (1),				/* associative memory fault */
 14   103       3 oosb bit (1),				/* out of segment bounds */
 14   104       3 paru bit (1),				/* processor parity upper */
 14   105       3 parl bit (1),				/* processor parity lower */
 14   106       3 onc_1 bit (1),				/* op not complete type 1 */
 14   107       3 onc_2 bit (1),				/* op not complete type 2 */
 14   108 
 14   109     2 port_stat,					/* PORT  STATUS */
 14   110       3 ial bit (4),				/* illegal action lines */
 14   111       3 iac bit (3),				/* illegal action channel */
 14   112       3 con_chan bit (3),				/* connect channel */
 14   113 
 14   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 14   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 14   116 
 14   117 
 14   118 /*	WORD (2)		*/
 14   119 
 14   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 14   121       3 trr bit (3),				/* temporary ring register */
 14   122       3 tsr bit (15),				/* temporary segment register */
 14   123 
 14   124     2 pad2 bit (9),
 14   125 
 14   126     2 cpu_no bit (3),				/* CPU number */
 14   127 
 14   128     2 delta bit (6),				/* tally modification DELTA */
 14   129 
 14   130 
 14   131 /*	WORD (3)		*/
 14   132 
 14   133     2 word3 bit (18),
 14   134 
 14   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 14   136       3 tsna,					/* Word 1 status */
 14   137         4 prn bit (3),				/* Word 1  PR  number */
 14   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 14   139       3 tsnb,					/* Word 2  status */
 14   140         4 prn bit (3),				/* Word 2  PR  number */
 14   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 14   142       3 tsnc,					/* Word 3  status */
 14   143         4 prn bit (3),				/* Word 3  PR  number */
 14   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 14   145 
 14   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 14   147 
 14   148 
 14   149 /* 	WORD (4)		*/
 14   150 
 14   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 14   152 
 14   153     2 ir,						/* INDICATOR  REGISTERS */
 14   154       3 zero bit (1),				/* zero indicator */
 14   155       3 neg bit (1),				/* negative indicator */
 14   156       3 carry bit (1),				/* carryry indicator */
 14   157       3 ovfl bit (1),				/* overflow indicator */
 14   158       3 eovf bit (1),				/* eponent overflow */
 14   159       3 eufl bit (1),				/* exponent underflow */
 14   160       3 oflm bit (1),				/* overflow mask */
 14   161       3 tro bit (1),				/* tally runout */
 14   162       3 par bit (1),				/* parity error */
 14   163       3 parm bit (1),				/* parity mask */
 14   164       3 bm bit (1),					/* ^bar mode */
 14   165       3 tru bit (1),				/* truncation mode */
 14   166       3 mif bit (1),				/* multi-word instruction mode */
 14   167       3 abs bit (1),				/* absolute mode */
 14   168       3 hex bit (1),				/* hexadecimal exponent mode */
 14   169       3 pad bit (3),
 14   170 
 14   171 
 14   172 /*	WORD (5)		*/
 14   173 
 14   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 14   175 
 14   176     2 cu,						/* CONTROL UNIT STATUS */
 14   177       3 rf bit (1),					/* on first cycle of repeat instr */
 14   178       3 rpt bit (1),				/* repeat instruction */
 14   179       3 rd bit (1),					/* repeat double instruction */
 14   180       3 rl bit (1),					/* repeat link instruciton */
 14   181       3 pot bit (1),				/* IT  modification */
 14   182       3 pon bit (1),				/* return type instruction */
 14   183       3 xde bit (1),				/* XDE from Even location */
 14   184       3 xdo bit (1),				/* XDE from Odd  location */
 14   185       3 poa bit (1),				/* operation preparation */
 14   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 14   187       3 its bit (1),				/* ITS modification */
 14   188       3 if bit (1),					/* fault occured during instruction fetch */
 14   189 
 14   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 14   191 
 14   192 
 14   193 /*	WORDS (6,7)	*/
 14   194 
 14   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 14   196 
 14   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 14   198 
 14   199 
 14   200 
 14   201 
 14   202 
 14   203 
 14   204 /*	ALTERNATE   SCU  DECLARATION		*/
 14   205 
 14   206 
 14   207 dcl 1 scux based (scup) aligned,
 14   208 
 14   209    (2 pad0 bit (36),
 14   210 
 14   211     2 fd,						/* GROUP II  FAULT DATA */
 14   212       3 isn bit (1),				/* illegal segment number */
 14   213       3 ioc bit (1),				/* illegal op  code  */
 14   214       3 ia_am bit (1),				/* illegal address - modifier */
 14   215       3 isp bit (1),				/* illegal slave  procedure */
 14   216       3 ipr bit (1),				/* illegal procedure */
 14   217       3 nea bit (1),				/* non existent address */
 14   218       3 oobb bit (1),				/* out of bounds */
 14   219       3 pad bit (29),
 14   220 
 14   221     2 pad2 bit (36),
 14   222 
 14   223     2 pad3a bit (18),
 14   224 
 14   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 14   226       3 prn bit (3),				/* PR  number */
 14   227       3 prv bit (1),				/* PR  valid bit */
 14   228 
 14   229     2 pad3b bit (6)) unaligned,
 14   230 
 14   231     2 pad45 (0:1) bit (36),
 14   232 
 14   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 14   234 
 14   235 
 14   236 
 14   237 /*  END INCLUDE FILE   mc.incl.pl1 */
 13    75 
 13    76 
 13    77 /* END include file toehold.incl.pl1 */
 11   105 
 11   106 
 11   107 /* END include file toehold_save_dcls_.incl.pl1 */
      405 
      406 
      407 /* BEGIN MESSAGE DOCUMENTATION
      408*
      409*   Message:
      410*   init_toehold: No "bce" partition on rpv. Rebuild the RPV to add one.
      411*
      412*   S: $crash
      413*
      414*   T: $init
      415*
      416*   M:  The partition used to hold the bootload command environment is
      417*   missing from the rpv.  
      418*
      419*   A:  A rebuild of the rpv is necessary.
      420*
      421*   Message:
      422*   init_toehold: Unable to save bootload Multics image to disk.
      423*
      424*   S: $crash
      425*
      426*   T: $init
      427*
      428*   M: An i/o error prevented the establishment of the bce crash handler.
      429*
      430*   Message:
      431*   init_toehold: Unable to save safe_config_deck to disk.
      432*
      433*   S: $beep
      434*
      435*   T: $init
      436*
      437*   M: The safe_config_deck, used to re-establish bce when a failure of bce 
      438*   itself occurs, could not be updated to disk.  A future failure of bce may 
      439*   be catastrophic.
      440*
      441*   A: Try performing a reinitialize operation, making sure that the config 
      442*   deck is perfect.
      443*
      444*   END MESSAGE DOCUMENTATION */
      445 
      446      end init_toehold;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0816.1  init_toehold.pl1                  >spec>install>1112>init_toehold.pl1
396          1    08/11/88  2011.5  dskdcl.incl.pl1                   >ldd>include>dskdcl.incl.pl1
397          2    06/22/81  1815.3  fault_vector.incl.pl1             >ldd>include>fault_vector.incl.pl1
398          3    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
3-142        4    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
399          5    07/11/84  0937.3  io_chnl_util_dcls.incl.pl1        >ldd>include>io_chnl_util_dcls.incl.pl1
400          6    07/11/84  0937.3  iom_chan_control_words.incl.pl1   >ldd>include>iom_chan_control_words.incl.pl1
401          7    04/11/85  1452.4  iom_data.incl.pl1                 >ldd>include>iom_data.incl.pl1
402          8    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
403          9    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
404         10    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
405         11    03/27/86  1120.0  toehold_save_dcls_.incl.pl1       >ldd>include>toehold_save_dcls_.incl.pl1
11-104      12    07/11/84  0937.3  bce_partition_layout.incl.pl1     >ldd>include>bce_partition_layout.incl.pl1
11-105      13    07/11/84  0937.3  toe_hold.incl.pl1                 >ldd>include>toe_hold.incl.pl1
13-75       14    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Address                                parameter       fixed bin(17,0)          dcl 351 ref 349 353
BEEP                            000042 constant        fixed bin(17,0)          initial dcl 10-7 set ref 257*
CRASH                           000046 constant        fixed bin(17,0)          initial dcl 10-7 set ref 94* 203* 214*
CRASH_HANDLER_RECORDX                  constant        fixed bin(17,0)          initial dcl 12-9 ref 103 169 201 212
Config_deck_size                       constant        fixed bin(17,0)          initial dcl 40 ref 161 253
Hardware_low_mem_page_size             constant        fixed bin(17,0)          initial dcl 44 ref 134
IDCW_INIT_STRING                       constant        bit(36)                  initial dcl 6-35 ref 113
IOM_PORT                               constant        fixed bin(17,0)          initial dcl 9-176 ref 378
IOTD                                   constant        bit(2)                   initial dcl 6-81 ref 311
IOTD_INIT_STRING                       constant        bit(36)                  initial packed unaligned dcl 6-76 ref 276 315
IOTP_INIT_STRING                       constant        bit(36)                  initial packed unaligned dcl 6-77 ref 305
Max_pages_in_segment            002052 constant        fixed bin(17,0)          initial dcl 41 ref 147 147 170 170 195 196 200 200
                                                                                  200 202 202 206 211 288 306 316 353
PCW_INIT_STRING                 000000 constant        bit(72)                  initial dcl 6-34 ref 388
PROCEED                                constant        bit(2)                   initial packed unaligned dcl 6-48 ref 117
Pages_per_dcw                   002051 constant        fixed bin(17,0)          initial dcl 42 ref 130 130 293 295 299 300 308 309
Record                                 parameter       fixed bin(18,0)          dcl 334 ref 332 340 341 344
SAVED_IMAGE_RECORDX                    constant        fixed bin(17,0)          initial dcl 12-8 ref 135 146
SINGLE_RECORD                          constant        bit(6)                   initial packed unaligned dcl 6-39 ref 118
TERMINATE                              constant        bit(2)                   initial packed unaligned dcl 6-48 ref 124
Toehold_size                           constant        fixed bin(17,0)          initial dcl 43 ref 145 168 211
abs_seg0$                       000032 external static bit(36864)               array dcl 55 set ref 192 192 202 202 213 213
abs_seg_pt                             based           bit(36)                  array dcl 86 set ref 196 196 207 207
abs_seg_pt_abs_addr             000100 automatic       fixed bin(26,0)          dcl 68 set ref 192* 193
abs_seg_pt_ptr                  000122 automatic       pointer                  dcl 87 set ref 193* 196 196 207 207
absadr                          000010 constant        entry                    external dcl 45 ref 97 100 101 103 160 193 277
addr                                                   builtin function         dcl 92 ref 97 97 99 100 100 101 101 103 103 111 129
                                                                                  142 142 151 151 160 160 165 165 174 174 183 183
                                                                                  186 186 192 192 192 192 193 193 193 196 196 202
                                                                                  202 207 207 213 213 217 217 244 254 254 275 277
                                                                                  277 304 314 360 361 367 368 374 387
addrel                                                 builtin function         dcl 92 ref 183 186 254 254
address                                based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-58
                                                                                  set ref 277* 306* 316*
array                    11            based           structure                array level 2 dcl 1-31
assigned                        000072 external static fixed bin(4,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 9-56 ref 378
chan_cmd                  0(24) 000124 automatic       bit(6)                   level 2 packed packed unaligned dcl 89 set ref 118*
channel                 261            based           fixed bin(6,0)           array level 3 unsigned dcl 7-17 ref 376
channel_mailbox                        based           structure                level 1 dcl 7-98
channel_number          222(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 11-24 set
                                                                                  ref 385*
channels                 11            based           bit(18)                  level 2 packed packed unaligned dcl 1-74 ref 374
chantab                                based           structure                level 1 dcl 1-132
chx                                    based           fixed bin(35,0)          level 2 dcl 1-132 ref 375 376
code                            000101 automatic       fixed bin(35,0)          dcl 69 set ref 202* 203 203* 213* 214 214* 254* 257
                                                                                  257*
command                                based           bit(6)                   level 2 in structure "pcw" packed packed unaligned
                                                                                  dcl 6-7 in procedure "init_toehold" set ref 389*
command                         000124 automatic       bit(6)                   level 2 in structure "seek_idcw_template" packed
                                                                                  packed unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 114*
config_deck$                    000034 external static fixed bin(17,0)          dcl 56 set ref 160 160
control                   0(22) 000125 automatic       bit(2)                   level 2 in structure "data_idcw_template" packed
                                                                                  packed unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 124*
control                   0(22) 000124 automatic       bit(2)                   level 2 in structure "seek_idcw_template" packed
                                                                                  packed unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 117*
cp                              000132 automatic       pointer                  dcl 1-97 set ref 374* 375 376
currentsize                                            builtin function         dcl 92 ref 132
cx                                     parameter       fixed bin(17,0)          dcl 263 ref 261 271 273 274 275 277 277 304 314
data_dcws                 4            based           bit(36)                  array level 2 dcl 11-97 set ref 304 314
data_idcw                 3            based           bit(36)                  array level 2 dcl 11-97 set ref 273*
data_idcw_template              000125 automatic       structure                level 1 dcl 89 set ref 119* 273
dcw                                    based           structure                level 1 dcl 6-58 set ref 276* 305* 315*
dcw_list                               based           structure                array level 1 dcl 11-97 set ref 132
dcw_list_ptr                    000152 automatic       pointer                  dcl 11-96 set ref 129* 132 270* 271 273 274 275 277
                                                                                  277 304 314
dcw_list_size           247            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-24 set ref
                                                                                  132*
dcw_ptr                         000140 automatic       pointer                  dcl 6-55 set ref 275* 276 277 278 304* 305 306 307
                                                                                  311 314* 315 316 317
dcws_per_cyl            247(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-24 set ref
                                                                                  130* 132 271 271 273 273 274 274 275 275 277 277
                                                                                  277 277 304 304 314 314
devadd                          000204 automatic       fixed bin(18,0)          dcl 335 set ref 341* 344* 345 345
device                    0(06) 000124 automatic       fixed bin(6,0)           level 2 in structure "seek_idcw_template" packed
                                                                                  packed unsigned unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 115*
device                    0(06)        based           fixed bin(6,0)           level 2 in structure "pcw" packed packed unsigned
                                                                                  unaligned dcl 6-7 in procedure "init_toehold" set
                                                                                  ref 390*
device_type               4            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 8-26 ref 362
devname                   3            based           char(4)                  level 2 dcl 8-26 ref 369
devtab                                 based           structure                level 1 dcl 1-190
dimension                                              builtin function         dcl 92 ref 373
disk_channel_number             000102 automatic       fixed bin(7,0)           dcl 70 set ref 376* 385
disk_channel_table                     based           structure                array level 1 dcl 1-94 set ref 374
disk_data                              based           structure                level 1 dcl 1-31
disk_device_number              000105 automatic       fixed bin(6,0)           dcl 73 set ref 115 363* 390
disk_iom_number                 000103 automatic       fixed bin(3,0)           dcl 71 set ref 375* 378 384
disk_iom_port_number            000104 automatic       fixed bin(3,0)           dcl 72 set ref 378* 378 378* 383
disk_lock_meters                       based           structure                level 1 dcl 1-236
disk_seg$                       000062 external static fixed bin(17,0)          dcl 1-24 set ref 367
diskp                           000130 automatic       pointer                  dcl 1-26 set ref 371* 373 374
disksp                          000126 automatic       pointer                  dcl 1-26 set ref 367* 369 369 371 371 374
disktab                                based           structure                level 1 dcl 1-74
divide                                                 builtin function         dcl 92 ref 98 103 130 160 295 299 345 353
dseg$                           000036 external static fixed bin(71,0)          array dcl 57 set ref 192 192
emergency_shutdown$             000040 external static fixed bin(17,0)          dcl 58 set ref 111
esd_segnum              246            based           fixed bin(15,0)          level 2 dcl 11-24 set ref 111*
ext                       0(12) 000125 automatic       fixed bin(6,0)           level 2 in structure "data_idcw_template" packed
                                                                                  packed unsigned unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 272*
ext                       0(12)        based           fixed bin(6,0)           level 2 in structure "pcw" packed packed unsigned
                                                                                  unaligned dcl 6-7 in procedure "init_toehold" set
                                                                                  ref 391*
ext_ctl                   0(21) 000124 automatic       bit(1)                   level 2 in structure "seek_idcw_template" packed
                                                                                  packed unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 116*
ext_ctl                   0(21) 000125 automatic       bit(1)                   level 2 in structure "data_idcw_template" packed
                                                                                  packed unaligned dcl 89 in procedure
                                                                                  "init_toehold" set ref 123*
fault_vector$                   000042 external static fixed bin(17,0)          dcl 59 set ref 100 100 183
fault_vector_abs_addr           000106 automatic       fixed bin(26,0)          dcl 74 set ref 100* 183
full_tallys                     000170 automatic       fixed bin(17,0)          dcl 265 set ref 295* 299* 303
fv                                     based           structure                level 1 dcl 2-6 set ref 183* 183
handler_dcws            655            based           fixed bin(35,0)          array level 2 dcl 11-24 set ref 127* 165 165 174 174
hbound                                                 builtin function         dcl 92 ref 378
i                               000171 automatic       fixed bin(17,0)          dcl 266 set ref 303* 304* 314
idcw                                   based           structure                level 1 dcl 6-23
int_unpaged_page_tables$        000044 external static fixed bin(17,0)          dcl 60 set ref 193 193 193
io_path                                based           structure                level 1 dcl 13-22
iom                     260            based           fixed bin(3,0)           array level 3 unsigned dcl 7-17 ref 375
iom_data                               based           structure                level 1 dcl 7-17
iom_data$                       000064 external static fixed bin(17,0)          dcl 7-11 set ref 368
iom_data_ptr                    000142 automatic       pointer                  dcl 7-15 set ref 368* 375 376
iom_mailbox                            based           structure                level 1 dcl 7-95
iom_mailbox$                    000066 external static fixed bin(17,0)          dcl 7-12 set ref 101 101 186
iom_mailbox_abs_addr            000107 automatic       fixed bin(26,0)          dcl 75 set ref 101* 186
iom_mailbox_seg                        based           structure                level 1 dcl 7-83 set ref 186* 186
iom_number              222(03)        based           fixed bin(15,0)          array level 3 in structure "toehold" packed packed
                                                                                  unsigned unaligned dcl 11-24 in procedure
                                                                                  "init_toehold" set ref 384*
iom_number                0(09) 000072 external static fixed bin(3,0)           array level 2 in structure "scs$port_data" packed
                                                                                  packed unsigned unaligned dcl 9-56 in procedure
                                                                                  "init_toehold" ref 378
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 8-26 ref 337
lbound                                                 builtin function         dcl 92 ref 378
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 8-26 ref 363
max                                                    builtin function         dcl 92 ref 177
mc                                     based           structure                level 1 dcl 14-12
mc_state                               based           structure                level 1 dcl 13-42
memory_state            241            based           fixed bin(17,0)          level 2 dcl 11-24 set ref 107* 246 247* 251*
min                                                    builtin function         dcl 92 ref 283 373
mod                                                    builtin function         dcl 92 ref 283 293 300 306 316 340 345
n_paths_used            240            based           fixed bin(17,0)          level 2 dcl 11-24 set ref 373* 374 383 384 385 387*
                                                                                  393* 393
name                     12            based           char(4)                  array level 3 packed packed unaligned dcl 1-31 ref
                                                                                  369
nchan                     1            based           fixed bin(17,0)          level 2 dcl 1-74 ref 373
num_of_svs               12            based           fixed bin(17,0)          level 2 dcl 8-26 ref 341
offset                   11            based           bit(18)                  array level 3 packed packed unaligned dcl 1-31 ref
                                                                                  371
old_memory_state                000110 automatic       fixed bin(17,0)          dcl 76 set ref 246* 251
opt_info                               based           structure                level 1 dcl 1-217
p_dcw_list_ptr                         parameter       pointer                  dcl 264 ref 261 270
paths                   220            based           structure                array level 2 dcl 11-24 set ref 373
pc$flush                        000012 constant        entry                    external dcl 46 ref 191
pcw                     220            based           fixed bin(71,0)          array level 3 in structure "toehold" dcl 11-24
                                                                                  in procedure "init_toehold" set ref 387
pcw                                    based           structure                level 1 dcl 6-7 in procedure "init_toehold" set ref
                                                                                  388*
pcw_ptr                         000136 automatic       pointer                  dcl 6-5 set ref 387* 388 389 390 391
per_device              240            based           structure                array level 2 in structure "iom_data" dcl 7-17
                                                                                  in procedure "init_toehold"
per_device                             based           structure                level 1 dcl 7-59 in procedure "init_toehold"
per_iom                                based           structure                level 1 dcl 7-40
pmut$camp                       000014 constant        entry                    external dcl 47 ref 198 209
port_number             222            based           fixed bin(3,0)           array level 3 packed packed unsigned unaligned
                                                                                  dcl 11-24 set ref 383*
ptr                                                    builtin function         dcl 92 ref 193 371 374
ptw_util_$make_core             000016 constant        entry                    external dcl 48 ref 196 207
pvt$array                       000070 external static fixed bin(17,0)          dcl 8-18 set ref 360
pvt$root_pvtx                   000046 external static fixed bin(17,0)          dcl 61 set ref 202* 213* 254* 361
pvt_array                              based           structure                array level 1 dcl 8-24 set ref 361
pvt_arrayp                      000144 automatic       pointer                  dcl 8-21 set ref 360* 361
pvte                                   based           structure                level 1 dcl 8-26
pvtep                           000146 automatic       pointer                  dcl 8-22 set ref 337 340 341 341 361* 362 363 369
qht                                    based           structure                level 1 dcl 1-179
quentry                                based           structure                level 1 dcl 1-107
rec_per_cyl                     000024 constant        fixed bin(17,0)          initial array dcl 3-108 ref 130 283 283 345 345
record_factor            14            based           fixed bin(17,0)          level 2 dcl 8-26 ref 341
record_offset                   000205 automatic       fixed bin(18,0)          dcl 336 set ref 340* 341 341
records_per_cyl          13            based           fixed bin(17,0)          level 2 dcl 8-26 ref 340
records_to_do                   000111 automatic       fixed bin(18,0)          dcl 77 set ref 136* 140 147* 149 161* 163 170* 172
                                                                                  283 322* 322
records_to_do_here              000172 automatic       fixed bin(18,0)          dcl 267 set ref 283* 288 288* 293 295 299 300 322
residue                         000173 automatic       fixed bin(17,0)          dcl 268 set ref 296* 300* 311 317 318 319
rpv_devt                        000112 automatic       fixed bin(17,0)          dcl 78 set ref 114 130 283 283 345 345 345 345 362*
running_address                 000113 automatic       fixed bin(17,0)          dcl 79 set ref 134* 135 136 145* 146 147 160* 168*
                                                                                  169 170 195* 196 196 196* 200* 201 202 202* 206*
                                                                                  207 207 207* 211* 212 213 213* 272* 288* 288 288
                                                                                  306 308* 308 316 318* 318
running_record                  000115 automatic       fixed bin(18,0)          dcl 81 set ref 135* 146* 159* 169* 201* 202* 212*
                                                                                  213* 253* 254* 254 254* 274* 283 309* 309 319* 319
running_seeks                   000114 automatic       fixed bin(17,0)          dcl 80 set ref 133* 141* 141 142* 150* 150 151* 154
                                                                                  158* 164* 164 165* 173* 173 174* 177
safe_config_deck$               000050 external static fixed bin(17,0)          dcl 62 set ref 103 103 254 254
save_dcws               251            based           fixed bin(35,0)          array level 2 dcl 11-24 set ref 126* 129 142 142 151
                                                                                  151
save_handler_mc                 000020 constant        entry                    external dcl 49 ref 217
scs$port_data                   000072 external static structure                array level 1 dcl 9-56 ref 378 378
sdw_util_$get_address           000022 constant        entry                    external dcl 50 ref 192
sect_per_cyl                    000013 constant        fixed bin(17,0)          initial array dcl 4-15 ref 345
sect_per_rec                    000002 constant        fixed bin(17,0)          initial array dcl 4-21 ref 345
seek_addresses                         based           fixed bin(35,0)          array level 2 dcl 11-97 set ref 274* 277 277
seek_command                    000134 automatic       bit(6)                   initial array packed unaligned dcl 3-84 set ref 114
                                                                                  3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84*
                                                                                  3-84*
seek_dcw                  2            based           bit(36)                  array level 2 dcl 11-97 set ref 275
seek_idcw                 1            based           bit(36)                  array level 2 dcl 11-97 set ref 271*
seek_idcw_template              000124 automatic       structure                level 1 dcl 89 set ref 113* 119 271
seeks_used              250            based           fixed bin(17,0)          level 2 dcl 11-24 set ref 131* 132 154* 177* 177
segno                                                  builtin function         dcl 92 ref 111 192 192
status_queue                           based           structure                level 1 dcl 7-92
subsystems                             based           fixed bin(17,0)          level 2 dcl 1-31 ref 369
sx                              000116 automatic       fixed bin(17,0)          dcl 82 set ref 369* 369* 371
sys_boot_info$bce_part_frec     000052 external static fixed bin(17,0)          dcl 63 ref 94 103 135 146 169 201 212
sys_boot_info$config_part_frec  000054 external static fixed bin(17,0)          dcl 64 ref 159
sys_boot_info$safe_config_deck_frec
                                000056 external static fixed bin(17,0)          dcl 65 set ref 103* 253 253 254 254
sys_info                               based           structure                level 1 dcl 1-59
syserr                          000024 constant        entry                    external dcl 51 ref 94
syserr$error_code               000026 constant        entry                    external dcl 52 ref 203 214 257
tally                     0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 6-58
                                                                                  set ref 278* 307* 317*
toehold                                based           structure                level 1 dcl 11-24
toehold$                        000074 external static bit(36)                  array packed unaligned dcl 11-22 set ref 97 97 99
                                                                                  217 217 244
toehold_abs_addr                000117 automatic       fixed bin(18,0)          dcl 83 set ref 97* 98
toehold_data$                   000060 external static bit(36)                  dcl 66 set ref 183 186
toehold_page_addr               000120 automatic       fixed bin(17,0)          dcl 84 set ref 98* 136 145 168 211
toehold_ptr                     000150 automatic       pointer                  dcl 11-21 set ref 99* 107 111 126 127 129 130 131
                                                                                  132 132 132 142 142 151 151 154 165 165 174 174
                                                                                  177 177 244* 246 247 251 271 271 273 273 274 274
                                                                                  275 275 277 277 277 277 304 304 314 314 373 373
                                                                                  374 383 383 384 384 385 385 387 387 393 393
type                      0(22)        based           bit(2)                   level 2 packed packed unaligned dcl 6-58 set ref
                                                                                  311*
unspec                                                 builtin function         dcl 92 set ref 113* 119* 119 126* 127* 183* 183 186*
                                                                                  186 271 273 276* 305* 315* 388*
write_disk$write_disk_no_test   000030 constant        entry                    external dcl 53 ref 202 213 254

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 10-7
At_bce__boot                           internal static fixed bin(17,0)          initial dcl 13-66
At_bce__crash                          internal static fixed bin(17,0)          initial dcl 13-70
At_bce__early                          internal static fixed bin(17,0)          initial dcl 13-65
At_bce__shutdown                       internal static fixed bin(17,0)          initial dcl 13-71
BCE_PAGING_AREA_LTH                    internal static fixed bin(17,0)          initial dcl 12-11
BCE_PAGING_AREA_RECORDX                internal static fixed bin(17,0)          initial dcl 12-10
BCE_PART_LTH                           internal static fixed bin(17,0)          initial dcl 12-7
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 1-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 1-251
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 9-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 9-176
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
FAULT_NO_ACV                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_CMD                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_CON                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DF0                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DF1                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DF2                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DF3                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DIV                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_DRL                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_EXF                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_F1                            internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_F2                            internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_F3                            internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_IPR                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_LUF                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_MME                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_MME2                          internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_MME3                          internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_MME4                          internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_OFL                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_ONC                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_PAR                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_SDF                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_STR                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_SUF                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_TRB                           internal static fixed bin(17,0)          initial dcl 2-20
FAULT_NO_TRO                           internal static fixed bin(17,0)          initial dcl 2-20
IONTP                                  internal static bit(2)                   initial dcl 6-81
IONTP_INIT_STRING                      internal static bit(36)                  initial packed unaligned dcl 6-78
IOTP                                   internal static bit(2)                   initial dcl 6-81
IO_TYPE                                internal static char(16)                 initial array packed unaligned dcl 1-262
Initial_undefined                      internal static fixed bin(17,0)          initial dcl 13-64
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 10-7
LOG                                    internal static fixed bin(17,0)          initial dcl 10-7
MARKER                                 internal static bit(2)                   initial packed unaligned dcl 6-48
MAX_IO_TYPE                            internal static fixed bin(4,0)           initial dcl 1-251
MODEL                                  internal static fixed bin(17,0)          initial array dcl 3-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 3-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 3-60
MST_AREA_RECORDX                       internal static fixed bin(17,0)          initial dcl 12-12
MULTIRECORD                            internal static bit(6)                   initial packed unaligned dcl 6-39
Multics                                internal static fixed bin(17,0)          initial dcl 13-67
NONDATA                                internal static bit(6)                   initial packed unaligned dcl 6-39
PAGE_READ                              internal static fixed bin(4,0)           initial dcl 1-251
PAGE_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 1-241
SINGLE_CHARACTER                       internal static bit(6)                   initial packed unaligned dcl 6-39
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 10-7
TDCW                                   internal static bit(2)                   initial dcl 6-81
TDCW_INIT_STRING                       internal static bit(36)                  initial packed unaligned dcl 6-79
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 10-7
TEST                                   internal static fixed bin(4,0)           initial dcl 1-251
TOE_HOLD_BOOT_ENTRY                    internal static fixed bin(17,0)          initial dcl 13-36
TOE_HOLD_BOS_ENTRY                     internal static fixed bin(17,0)          initial dcl 13-37
TOE_HOLD_BOS_MULTICS_ENTRY             internal static fixed bin(17,0)          initial dcl 13-39
TOE_HOLD_BOS_NO_SAVE_ENTRY             internal static fixed bin(17,0)          initial dcl 13-38
TOE_HOLD_CRASH_ENTRY                   internal static fixed bin(17,0)          initial dcl 13-31
TOE_HOLD_DUMP_ENTRY                    internal static fixed bin(17,0)          initial dcl 13-33
TOE_HOLD_ESD_ENTRY                     internal static fixed bin(17,0)          initial dcl 13-32
TOE_HOLD_MULTICS_ENTRY                 internal static fixed bin(17,0)          initial dcl 13-34
TOE_HOLD_RESTART_ENTRY                 internal static fixed bin(17,0)          initial dcl 13-35
Undefined_continue                     internal static fixed bin(17,0)          initial dcl 13-72
Undefined_reading_bce                  internal static fixed bin(17,0)          initial dcl 13-69
Undefined_saving_mem                   internal static fixed bin(17,0)          initial dcl 13-73
Undefined_saving_state                 internal static fixed bin(17,0)          initial dcl 13-68
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 8-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 8-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 8-113
VTOC_READ                              internal static fixed bin(4,0)           initial dcl 1-251
VTOC_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
abx                                    internal static fixed bin(17,0)          initial dcl 14-42
apx                                    internal static fixed bin(17,0)          initial dcl 14-42
bbx                                    internal static fixed bin(17,0)          initial dcl 14-42
bootload_map                           defined         bit(1)                   array packed unaligned dcl 1-279
bootload_mapping                       internal static bit(7)                   initial packed unaligned dcl 1-278
bpx                                    internal static fixed bin(17,0)          initial dcl 14-42
bulkdevt                               internal static fixed bin(4,0)           initial dcl 3-43
connect_channel                        internal static fixed bin(6,0)           initial dcl 7-105
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 3-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-105
dev_time                               internal static float bin(27)            initial array dcl 3-139
device_names                           internal static char(4)                  initial array dcl 3-66
dp                                     automatic       pointer                  dcl 1-187
dskdcl_chans_per_subsys                internal static fixed bin(17,0)          initial dcl 1-70
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 1-71
dsu181devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 3-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 3-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 3-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 3-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 3-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 3-124
fvp                                    automatic       pointer                  dcl 2-4
idcw_ptr                               automatic       pointer                  dcl 6-21
io_chnl_util$canonicalize_chanid
                                000000 constant        entry                    external dcl 5-8
io_chnl_util$iom_to_name        000000 constant        entry                    external dcl 5-12
io_chnl_util$name_to_iom        000000 constant        entry                    external dcl 5-16
iom_mailbox_seg_ptr                    automatic       pointer                  dcl 7-82
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 3-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 3-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 3-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 3-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 3-121
lbx                                    internal static fixed bin(17,0)          initial dcl 14-42
lpx                                    internal static fixed bin(17,0)          initial dcl 14-42
maxdevt                                internal static fixed bin(4,0)           initial dcl 3-43
mc_state_ptr                           automatic       pointer                  dcl 13-41
mcp                                    automatic       pointer                  dcl 14-10
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 3-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 3-43
n_devices                              automatic       fixed bin(17,0)          dcl 7-14
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 3-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 3-93
optp                                   automatic       pointer                  dcl 1-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 8-19
pvtdi                                  based           structure                level 1 dcl 1-229
pvtdip                                 automatic       pointer                  dcl 1-187
qp                                     automatic       pointer                  dcl 1-97
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 3-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-90
sbx                                    internal static fixed bin(17,0)          initial dcl 14-42
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 9-137
scs$bos_restart_flags                  external static bit(8)                   dcl 9-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 9-103
scs$cam_wait                           external static bit(8)                   dcl 9-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 9-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 9-152
scs$connect_lock                       external static bit(36)                  dcl 9-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 9-164
scs$controller_data                    external static structure                array level 1 dcl 9-6
scs$cow                                external static structure                array level 1 dcl 9-65
scs$cow_ptrs                           external static structure                array level 1 dcl 9-77
scs$cpu_test_mask                      external static bit(72)                  dcl 9-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 9-99
scs$cycle_priority_template            external static bit(7)                   dcl 9-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 9-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 9-140
scs$faults_initialized                 external static bit(1)                   dcl 9-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 9-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 9-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 9-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 9-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 9-97
scs$open_level                         external static bit(72)                  dcl 9-94
scs$port_addressing_word               external static bit(3)                   array dcl 9-148
scs$processor                          external static bit(8)                   dcl 9-143
scs$processor_data                     external static structure                array level 1 dcl 9-35
scs$processor_data_switch_value        external static bit(36)                  dcl 9-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 9-142
scs$processor_start_mask               external static bit(72)                  dcl 9-95
scs$processor_start_pattern            external static bit(36)                  dcl 9-98
scs$processor_start_wait               external static bit(8)                   dcl 9-144
scs$processor_switch_compare           external static bit(36)                  array dcl 9-159
scs$processor_switch_data              external static bit(36)                  array dcl 9-157
scs$processor_switch_mask              external static bit(36)                  array dcl 9-160
scs$processor_switch_template          external static bit(36)                  array dcl 9-158
scs$processor_test_data                external static structure                level 1 dcl 9-114
scs$read_mask                          external static bit(36)                  array dcl 9-109
scs$reconfig_general_cow               external static structure                level 1 dcl 9-82
scs$reconfig_lock                      external static bit(36)                  dcl 9-133
scs$reconfig_locker_id                 external static char(32)                 dcl 9-167
scs$scas_page_table                    external static bit(36)                  array dcl 9-169
scs$set_cycle_switches                 external static bit(1)                   dcl 9-173
scs$set_mask                           external static bit(36)                  array dcl 9-108
scs$sys_level                          external static bit(72)                  dcl 9-93
scs$sys_trouble_pending                external static bit(1)                   dcl 9-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 9-146
scs$trouble_flags                      external static bit(8)                   dcl 9-134
scu                                    based           structure                level 1 dcl 14-56
scup                                   automatic       pointer                  dcl 14-54
scux                                   based           structure                level 1 dcl 14-207
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 4-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 4-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 4-26
sector_map                             defined         bit(1)                   array packed unaligned dcl 1-274
sector_mapping                         internal static bit(7)                   initial packed unaligned dcl 1-273
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 3-78
special_status_channel                 internal static fixed bin(6,0)           initial dcl 7-105
spx                                    internal static fixed bin(17,0)          initial dcl 14-42
status_queue_ptr                       automatic       pointer                  dcl 7-91
sysp                                   automatic       pointer                  dcl 1-26
system_fault_channel                   internal static fixed bin(6,0)           initial dcl 7-105
tdcw                                   based           structure                level 1 dcl 6-66
tdcw_ptr                               automatic       pointer                  dcl 6-56
toe_hold                               based           structure                level 1 dcl 13-11
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 3-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 3-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 3-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 4-36
write_map                              defined         bit(1)                   array packed unaligned dcl 1-269
write_mapping                          internal static bit(7)                   initial packed unaligned dcl 1-268

NAMES DECLARED BY EXPLICIT CONTEXT.
ext_value                       001615 constant        entry                    internal dcl 349 ref 272 288 288
find_rpv                        001623 constant        entry                    internal dcl 356 ref 109 249
init_toehold                    000221 constant        entry                    external dcl 9
process_one_cylinder            001267 constant        entry                    internal dcl 261 ref 142 151 165 174
save_safe_config_deck           001160 constant        entry                    external dcl 239
sector                          001555 constant        entry                    internal dcl 332 ref 274

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2414        2512    2056        2424
Length      3230    2056        76         502     335           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_toehold                        220 external procedure  is an external procedure.  
process_one_cylinder                    internal procedure  shares stack frame of external procedure init_toehold.  
sector                                  internal procedure  shares stack frame of external procedure init_toehold.  
ext_value                               internal procedure  shares stack frame of external procedure init_toehold.  
find_rpv                                internal procedure  shares stack frame of external procedure init_toehold.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_toehold             000100 abs_seg_pt_abs_addr         init_toehold
                         000101 code                        init_toehold
                         000102 disk_channel_number         init_toehold
                         000103 disk_iom_number             init_toehold
                         000104 disk_iom_port_number        init_toehold
                         000105 disk_device_number          init_toehold
                         000106 fault_vector_abs_addr       init_toehold
                         000107 iom_mailbox_abs_addr        init_toehold
                         000110 old_memory_state            init_toehold
                         000111 records_to_do               init_toehold
                         000112 rpv_devt                    init_toehold
                         000113 running_address             init_toehold
                         000114 running_seeks               init_toehold
                         000115 running_record              init_toehold
                         000116 sx                          init_toehold
                         000117 toehold_abs_addr            init_toehold
                         000120 toehold_page_addr           init_toehold
                         000122 abs_seg_pt_ptr              init_toehold
                         000124 seek_idcw_template          init_toehold
                         000125 data_idcw_template          init_toehold
                         000126 disksp                      init_toehold
                         000130 diskp                       init_toehold
                         000132 cp                          init_toehold
                         000134 seek_command                init_toehold
                         000136 pcw_ptr                     init_toehold
                         000140 dcw_ptr                     init_toehold
                         000142 iom_data_ptr                init_toehold
                         000144 pvt_arrayp                  init_toehold
                         000146 pvtep                       init_toehold
                         000150 toehold_ptr                 init_toehold
                         000152 dcw_list_ptr                init_toehold
                         000170 full_tallys                 process_one_cylinder
                         000171 i                           process_one_cylinder
                         000172 records_to_do_here          process_one_cylinder
                         000173 residue                     process_one_cylinder
                         000204 devadd                      sector
                         000205 record_offset               sector

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_ge_a              call_ext_out_desc   call_ext_out        return_mac          mdfx1
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        pc$flush                      pmut$camp                     ptw_util_$make_core
save_handler_mc               sdw_util_$get_address         syserr                        syserr$error_code
write_disk$write_disk_no_test

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
abs_seg0$                     config_deck$                  disk_seg$                     dseg$
emergency_shutdown$           fault_vector$                 int_unpaged_page_tables$      iom_data$
iom_mailbox$                  pvt$array                     pvt$root_pvtx                 safe_config_deck$
scs$port_data                 sys_boot_info$bce_part_frec   sys_boot_info$config_part_frec
sys_boot_info$safe_config_deck_frec                         toehold$                      toehold_data$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3   84 000127         9 000220        94 000227        97 000252        98 000272        99 000274       100 000277
    101 000314       103 000332       107 000356       109 000360       111 000361       113 000370       114 000372
    115 000377       116 000402       117 000404       118 000410       119 000412       123 000414       124 000416
    126 000420       127 000423       129 000426       130 000430       131 000435       132 000437       133 000446
    134 000447       135 000451       136 000454       140 000457       141 000463       142 000464       143 000471
    145 000472       146 000475       147 000501       149 000504       150 000506       151 000507       152 000514
    154 000515       158 000520       159 000521       160 000524       161 000544       163 000546       164 000550
    165 000551       166 000556       168 000557       169 000562       170 000567       172 000572       173 000574
    174 000575       175 000602       177 000603       183 000611       186 000622       191 000631       192 000635
    193 000656       195 000703       196 000711       197 000727       198 000731       200 000736       201 000745
    202 000752       203 000773       204 001021       206 001024       207 001033       208 001050       209 001052
    211 001057       212 001067       213 001074       214 001114       215 001142       217 001145       237 001156
    239 001157       244 001166       246 001171       247 001173       249 001174       251 001175       253 001200
    254 001211       257 001235       258 001263       259 001266       261 001267       270 001271       271 001274
    272 001307       273 001314       274 001331       275 001342       276 001346       277 001347       278 001371
    283 001374       288 001407       293 001431       295 001435       296 001440       297 001441       299 001442
    300 001445       303 001450       304 001457       305 001474       306 001476       307 001504       308 001506
    309 001510       310 001511       311 001513       314 001520       315 001535       316 001536       317 001544
    318 001547       319 001551       322 001552       325 001554       332 001555       337 001557       340 001563
    341 001567       343 001576       344 001577       345 001601       349 001615       353 001617       356 001623
    360 001624       361 001627       362 001633       363 001636       367 001642       368 001644       369 001646
    370 001663       371 001665       373 001675       374 001714       375 001726       376 001734       378 001736
    381 001756       383 001760       384 001771       385 001776       387 002001       388 002003       389 002006
    390 002010       391 002013       392 002015       393 002020       394 002023


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
