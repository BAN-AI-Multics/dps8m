	COMPILATION LISTING OF SEGMENT convert_date_to_binary_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1037.4 mst Sat
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  convert_date_to_binary_.rd      	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  11/11/89  1037.4 mst Sat                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   * Copyright, (C) Honeywell Bull Inc., 1987                *
       14*   *                                                         *
       15*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
       16*   *                                                         *
       17*   * Copyright (c) 1972 by Massachusetts Institute of        *
       18*   * Technology and Honeywell Information Systems, Inc.      *
       19*   *                                                         *
       20*   *********************************************************** */
       21 
       22 /*++
       23*BEGIN
       24*main    	/ <no-token>		/						/ RETURN	\
       25*	\" Begin with parsing of long date
       26*2	/ <month_name> <day>	/ SL(1) Amonth_and_LEX Aday_and_LEX SLe			/ year 	\
       27*3	/ <day> <month_name>	/ SL(2) Aday_and_LEX Amonth_and_LEX SLe			/ year_	\
       28*
       29*	\" Short date formats
       30*4	/ <month> /_ <day> /_ <year>
       31*			      	/ SL(3) Amonth_and_LEX LEX Aday_and_LEX LEX Ayear_and_LEX SLe/ main	\
       32*5	/ <month> /_ <day>
       33*			       	/ SL(4) Amonth_and_LEX LEX Aday_and_LEX Ayear_default SLe	/ main	\
       34*6	/ <year> - <month> - <day>	/ SL(5) Ayear_and_LEX LEX Amonth_and_LEX LEX Aday_and_LEX SLe/ main	\
       35*7	/ <fweek> <n>		/ SL(6) LEX Afw LEX SLe				/ main	\
       36*
       37*	\" One of the Numeric-Offset family
       38*8	/ <N> <andfraction> <offset>	/ SL(7) Afraction_offset LEX(3) SLe			/ main	\
       39*
       40*	\" request_id format
       41*9	/ <n12> <andfraction6>	/ SL(8) Arequest_id LEX(2) SLe			/ main	\
       42*
       43*	\" Time formats
       44*10	/ <n> <andfraction>		/ SL(9) Atime LEX Aminute_fraction LEX SLe		/ zone_dif\
       45*	\" <n> . is handled because <andfraction> may be just "."
       46*11	/ <hour> : <minute>		/ SL(10) Ahour_and_LEX LEX Aminute_and_LEX SLe		/ second	\
       47*12	/ <hour> <meridian>		/ SL(11) Ahour_and_LEX Ameridian LEX
       48*				  Aminute_zero Asecond_zero SLe			/ zone_dif\
       49*13	/ <twelve> <half_day>	/ SL(12) LEX Ahalf_day LEX SLe			/ zone_dif\
       50*14	/ <half_day>		/ SL(13) Ahalf_day LEX SLe				/ zone_dif\
       51*
       52*	\" Day of week.  It is offset if no other date given, or validates a given date.
       53*15	/ <day_name> ,		/ SL(14) Uday_of_week LEX(2) SLe			/ main	\
       54*16	/ <day_name> <before_on_after>/ SL(15) Uday_of_week LEX Ab_o_a LEX SLe		/ adv_day	\
       55*17	/ <day_name>		/ SL(16) Uday_of_week LEX SLe				/ main	\
       56*
       57*	\" Numeric offsets
       58*num_off	/ <sign> <N> <offset>	/ SL(17) apply_sign_and_offset LEX(3) SLe		/ main	\
       59*19	/ <N> <offset>		/ SL(18) apply_offset LEX(2) SLe			/ main	\
       60*20	/ <sign> <N> <andfraction> <offset>
       61*				/ SL(19) Afraction_sign_and_offset LEX(4) SLe		/ main	\
       62*21	/ <fraction> <offset>	/ SL(20) Afraction_offset LEX(2) SLe			/ main	\
       63*22	/ <sign> <fraction> <offset>
       64*				/ SL(21) Afraction_sign_and_offset LEX(3) SLe		/ main	\
       65*
       66*
       67*	\" Time zone which qualifies the time given.
       68*23	/ <zone>			/ SL(22) Azone LEX SLe				/ main	\
       69*24	/ <yesterday>		/ SL(23) Ayesterday LEX SLe				/ main	\
       70*25	/ <today>			/ SL(23) Atoday LEX SLe				/ main	\
       71*26	/ <tomorrow>		/ SL(23) Atomorrow LEX SLe				/ main	\
       72*27	/ <now>			/ SL(23) Anow LEX SLe				/ main	\
       73*28	/			/ [last_adverb = VWon]				/	\
       74*29	/ <before_after> <or>	/ LEX [err_pt=token.Pvalue;
       75*				  details="""or"" can only be used with <day-name>.";
       76*				  lcode=error_table_$dt_time_conversion_error]		/ RETURN	\
       77*30	/ <before_after>		/ SL(24) Aadverb LEX SLe				/ main	\
       78*
       79*	\" Error diagnostics and return value.
       80*31	/ <on>			/  [err_pt=token.Pvalue;details = """on"" can only be used with <day-name>.";
       81*				    lcode=error_table_$dt_time_conversion_error]		/ RETURN	\
       82*32	/ <any-token>		/  [err_pt=token.Pvalue;
       83*				    lcode=error_table_$dt_time_conversion_error]		/ RETURN	\
       84*33	/ <no-token>		/						/ RETURN	\
       85*
       86*adv_day	/ <or> <before_after>	/ SL(25) LEX Ab_a LEX SLe				/	\
       87*35	/			/ [rtime_first = "1"b]				/ main	\
       88*
       89*	\" Optional seconds and meridian in HH:MM:SS <MERIDIAN><zone-differential>
       90*second	/ : <second> <andfraction>	/ SL(26) LEX Asecond_and_LEX Asecond_fraction LEX SLe	/ meridian\
       91*37	/ : <second>		/ SL(27) LEX Asecond_and_LEX SLe			/ meridian\
       92*38	/ <andfraction>		/ SL(28) Aminute_fraction LEX SLe			/ meridian\
       93*39	/			/ Asecond_zero					/	\
       94*meridian	/ <meridian>		/ SL(29) Ameridian LEX SLe				/	\
       95*
       96*zone_dif	/ <sign> <n4> <offset>	/						/ num_off	\
       97*42	/ <sign> <n4> <andfraction>	/						/ num_off	\
       98*43	/ <sign> <n4>		/ SL(30) [SIGN = token_value] LEX Azone_dif LEX SLe	/ main	\
       99*44	/			/						/ main	\
      100*
      101*	\" Look for optional year in long date formats.
      102*year	/ , <year>		/ SL(31) LEX Ayear_and_LEX SLe			/ main	\
      103*year_	/ <n> <andfraction>		/ Ayear_default					/ main	\
      104*47	/ <n> :			/ Ayear_default					/ main	\
      105*48	/ <n> <meridian>		/ Ayear_default					/ main	\
      106*49	/ <twelve> <half_day>	/ Ayear_default					/ main	\
      107*50	/ <n> <offset>		/ Ayear_default					/ main	\
      108*51	/ <day> <month_name>	/ [err_pt=token.Pvalue;
      109*				   details="<day> <month_name> already given.";
      110*				   lcode=error_table_$dt_time_conversion_error]  		/ RETURN	\
      111*52	/ <year>			/ SL(32) Ayear_and_LEX SLe				/ main	\
      112*53	/			/ Ayear_default					/ main	\
      113*											++*/
      114 
      115 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/
      116 	/* 								         */
      117 	/* Name: convert_date_to_binary_					         */
      118 	/* 								         */
      119 	/*      This subroutine parses a time string, converting it to a standard Multics        */
      120 	/* clock value.  Refer to the MPM Subroutines for a description of a time string.        */
      121 	/* 								         */
      122 	/* Status								         */
      123 	/* 								         */
      124 	/* 0) Created  March 11, 1971      by  Dan Bricklin			         */
      125 	/* 1) Modified July 30, 1971       by  Dan Bricklin - add offset feature	         */
      126 	/* 2) Modified September 10, 1979  by  Gary Dixon - complete rewrite into reduction      */
      127 	/*    language.							         */
      128 	/* 3) Modified June 1, 1983	     by  J Falksen - add fractional offsets, convert	*/
      129 	/*				to new date/time software.			*/
      130 	/* 4) Modified Jan 20, 1984	     by  J Falksen - added optional "," after day_name,	*/
      131 	/*				zone differential form			*/
      132 	/* 5) Modified Aug 1984	     by jaf - added now/today/tomorrow/yesterday		*/
      133 	/*				this_XXX, and adverbial offsets		*/
      134 	/*								         */
      135 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/
      136 
      137 /* HISTORY COMMENTS:
      138*  1) change(86-07-18,GDixon), approve(86-07-25,MCR7495),
      139*     audit(86-07-25,Martinson), install(86-09-16,MR12.0-1120):
      140*     Prior to this change, a time string containing ? caused debugging messages
      141*     to be printed by convert_date_to_binary_.  This change triggers debugging
      142*     from the setting of a new time_defaults_$debug switch, and removes support
      143*     for ? in time strings.
      144*  2) change(86-08-14,GDixon), approve(86-09-04,MCR7532),
      145*     audit(86-09-05,Martinson), install(86-09-16,MR12.0-1159):
      146*     Correct null_pointer fault which occurred when processing the time string
      147*     "this". (phx19450)
      148*  3) change(86-08-14,GDixon), approve(86-09-04,MCR7532),
      149*     audit(86-09-05,Martinson), install(86-09-16,MR12.0-1159):
      150*     Make "<day_name> <on> <date>" and "<date> <day_name>" forms of time
      151*     strings properly verify that the given date falls on the given day_name.
      152*     (phx20492)
      153*  4) change(88-05-26,GDixon), approve(88-05-26,MCR7900),
      154*     audit(88-07-28,Lippard), install(88-08-02,MR12.2-1075):
      155*     Added the $analyze entrypoint, an internal entry used primarily by
      156*     memo_repeat_.pl1 to determine if a memo repeat interval given by the user
      157*     consists only of fixed-length offsets (eg, 1 day 5 hours).  All offsets
      158*     greater than weeks are variable-length.  Even 5 years is variable because
      159*     of leap year calculations.  memo calls the new $analyze entrypoint to
      160*     apply the offset once to the current memo time.  If that produces a time
      161*     which is still in the past and the offsets are all fixed length, memo
      162*     simple adds the fixed-length number of microseconds the offset represents
      163*     iteratively until a time in the future is obtained. If the offsets are
      164*     variable length, memo must call $relative repeated until a time in the
      165*     future is obtained. (phx21094)
      166*  5) change(88-05-29,GDixon), approve(88-06-15,MCR7918),
      167*     audit(88-07-28,Lippard), install(88-08-02,MR12.2-1075):
      168*      A) Correct error preventing an absolute day-of-week specification from
      169*         being enforced.  Fix allows "date 6/1/88 thu" to be reported as an
      170*         error, since it is really a Wednesday. (date_time 32)
      171*                                                   END HISTORY COMMENTS */
      172 
      173 
      174 /* Name: convert_date_to_binary_                                             */
      175 /*                                                                           */
      176 /* ENTRY:  convert_date_to_binary_                                           */
      177 /*                                                                           */
      178 /* The convert_date_to_binary_ subroutine  converts a character rep-         */
      179 /* resentation of a  date and time into a  72-bit clock reading.  It         */
      180 /* accepts  a wide  variety of  date and  time forms,  including the         */
      181 /* output of the date_time_ subroutine.                                      */
      182 /*                                                                           */
      183 /* USAGE:                                                                    */
      184 /*    dcl convert_date_to_binary_ entry (char (*), fixed bin (71),           */
      185 /*       fixed bin (35));                                                    */
      186 /*    call convert_date_to_binary_ (time_string, clock, code);	       */
      187 /*                                                                           */
      188 /* ARGUMENTS:                                                                */
      189 /* time_string (input)					       */
      190 /*    the time string  to be converted.  See  Multics Programmers' Refer-    */
      191 /*    ence Manual for a description of acceptable strings.                   */
      192 /* clock (output)                                                            */
      193 /*    the resulting clock value.  Unchanged if an error occurs.              */
      194 /* code (output)                                                             */
      195 /*    is a standard  status code.  It can have  one of the following         */
      196 /*    values--                                                               */
      197 /*    error_table_$bad_conversion                                            */
      198 /*    error_table_$dt_ambiguous_time                                         */
      199 /*    error_table_$dt_bad_day_of_week				       */
      200 /*    error_table_$dt_bad_fw                                                 */
      201 /*    error_table_$dt_hour_gt_twelve                                         */
      202 /*    error_table_$dt_multiple_date_spec                                     */
      203 /*    error_table_$dt_multiple_diw_spec                                      */
      204 /*    error_table_$dt_multiple_meaning                                       */
      205 /*    error_table_$dt_multiple_time_spec                                     */
      206 /*    error_table_$dt_multiple_zone_spec                                     */
      207 /*    error_table_$dt_time_conversion_error                                  */
      208 /*    error_table_$dt_size_error                                             */
      209 /*    error_table_$too_many_tokens                                           */
      210 /*    error_table_$dt_unknown_word                                           */
      211 /*                                                                           */
      212 /* ENTRY:  convert_date_to_binary_$relative                                  */
      213 /*                                                                           */
      214 /* This entry point is  similar to the convert_date_to_binary_ entry         */
      215 /* point,  except  that  the  clock  reading  returned  is  computed         */
      216 /* relative  to an  input clock time  rather than  the current clock         */
      217 /* time.  Thus the clock reading  returned for the string "March 26"         */
      218 /* is the clock  reading for the first March  26 following the input         */
      219 /* clock time, rather than the clock  reading for the first March 26         */
      220 /* following the current  clock time.  Given a 72-bit  clock time to         */
      221 /* use, this  entry point converts  a character representation  of a         */
      222 /* date and time to the equivalent 72-bit clock reading.                     */
      223 /*                                                                           */
      224 /* USAGE:                                                                    */
      225 /*    dcl convert_date_to_binary_$relative entry (char (*), fixed            */
      226 /*       bin (71), fixed bin (71), fixed bin(35));                           */
      227 /*    call convert_date_to_binary_$relative (time_string, clock,	       */
      228 /*       clock_in, code);                                                    */
      229 /*                                                                           */
      230 /* ARGUMENTS:                                                                */
      231 /* time_string (Input)					       */
      232 /*    is the character representation of the clock reading desired.          */
      233 /* clock (Output)                                                            */
      234 /*    is the computed clock value relative to the clock_in argument.         */
      235 /* clock_in (Input)                                                          */
      236 /*    is the clock time used to compute the clock value.                     */
      237 /* code (output)                                                             */
      238 /*    is a standard status code.                                             */
      239 
      240 convert_date_to_binary_: 
      241 	procedure (time_string, clock_out, code);
      242 
      243      dcl						/*		parameters		*/
      244 	time_string		char(*),		/* date string to be converted. (In)		*/
      245 	clock_out			fixed bin(71),	/* binary clock value. (Out)			*/
      246 	relative_to_clock		fixed bin(71),	/* binary clock value which output clock value	*/
      247 						/*    is relative to. (In)			*/
      248 	fixed_length_sw		bit(1) aligned,	/* on if time_string consists only of		*/
      249 						/*    offsets, where all are smaller than months  */
      250 						/*    (Out)				*/
      251 	code			fixed bin(35);	/* a status code. (Out)			*/
      252 
      253      dcl						/*		automatic variables		*/
      254 	Idelim_type		fixed bin,	/* parse type of delimeter found in string.	*/
      255 	Isearch			fixed bin,	/* index of next string token delimiter.	*/
      256 	Iverify			fixed bin,
      257 	Lnumber_in_str		fixed bin,	/* length of next number found in string.	*/
      258 	Lword_in_str		fixed bin,	/* length of next word found in the string.	*/
      259 	Lstr			fixed bin,	/* length of remainder of input string.		*/
      260 	Ntokens			fixed bin,	/* number of tokens in input string.		*/
      261 	Pstr			ptr,		/* ptr to remainder of input string.		*/
      262 	SIGN			char (1),		/* used for zone differential			*/
      263 	Sspace_encountered		bit(1) aligned,	/* on if previous char of input was whitespace	*/
      264 	a_clock			fixed bin(71),	/* number of micro-seconds in absolute time of day*/
      265 	ambig_sw			bit (1),		/* 1- ambiguous token present			*/
      266 	analyze_sw		bit (1),		/* 1- entered at $analyze entrypoint		*/
      267 
      268 	clock_now			fixed bin(71),	/* number of micro-seconds in current time of day.*/
      269 	date_given		bit (1),
      270 	details			char(64)var,
      271 	done			bit (1),
      272 	dow_given			bit (1),
      273 	errloc			fixed bin (24),
      274 	err_pt			ptr,
      275 	fld59			float decimal (59),
      276 	fw_sw			bit (1),		/* FW has been given			*/
      277 	h_time_sw			bit (1),		/* 1- a held time exists			*/
      278 	i			fixed bin,
      279 	ii			fixed bin,
      280 	lang_index		fixed bin,
      281 	lang_temp			bit (18),
      282 	lang_used			bit (18),
      283 	last_adverb		fixed bin,
      284 	lcode			fixed bin (35),
      285 	number			fixed bin(35),	/* a temp for numeric token values.		*/
      286 	offset_sign		float dec (2),	/* multiplier which applies sign to offset values.*/
      287 	rtime_ct			fixed bin,	/* # of relative phrases present.		*/
      288 	rtime_ct_h		fixed bin,	/* held rtime_ct				*/
      289 	rtime_first		bit (1),
      290 	rtime_p			ptr,
      291 	silent			bit (1),		/* 0-print error message w/details		*/
      292 	size_flag			bit (1),		/* enable/disble size condition handler		*/
      293 	tcode			fixed bin (35),
      294 	u_day_of_week		fixed bin,	/* an undetermined (absolute or relative) number	*/
      295 						/*    of a day of the week.			*/
      296 	year_needed		bit (1);
      297 	
      298 
      299      dcl
      300 	1 atime			like time_value,	/* absolute time data given			*/
      301 	1 atime_h			like time_value,	/* hold absolute data given when ambig match	*/
      302 	1 atime_init		like time_value,	/* hold initial value			*/
      303 	1 ctime			like time_value,	/* current time data			*/
      304 	1 ttime			like time_value,	/* yesterday/tomorrow data, if needed		*/
      305 	1 tokens (250)		like token,	/* array of tokens.				*/
      306 	1 rtime			aligned like time_offset based (rtime_p),
      307 	1 rtime_array		aligned like time_offset_array based (rtime_p),
      308 	1 rspace_init (8)		aligned,
      309 	  2 rel_ct		fixed bin,
      310 	  2 dw_required		fixed bin,
      311 	  2 data like time_offset_array,
      312 	1 rspace (8)		aligned,		/* rel time given				*/
      313 	  2 rel_ct		fixed bin,
      314 	  2 dw_required		fixed bin,
      315 	  2 data like time_offset_array,
      316 	1 rspace_h (8)		aligned,		/* held rspace during ambig processing		*/
      317 	  2 rel_ct		fixed bin,
      318 	  2 dw_required		fixed bin,
      319 	  2 data like time_offset_array;
      320 
      321      dcl						/*		based variables		*/
      322 	first_char_of_str		char(1) based (Pstr),
      323 						/* first character of remainder of input string.	*/
      324 	number_in_str		char(Lnumber_in_str) based(Pstr),
      325 	str			char(Lstr) based (Pstr),
      326 						/* remainder of input string.			*/
      327 	word_in_str		char(Lword_in_str) based(Pstr);
      328 						/* next word in the string.			*/
      329 	
      330      dcl
      331          (addcharno, addr, addrel, charno, char, clock, convert, copy, dim,
      332 	divide, fixed, hbound, index, length, ltrim, mod, null, rtrim,
      333 	search, string, substr, sum, translate, unspec, verify)
      334 				builtin;
      335 
      336 
      337      dcl						/*	conditions and entry points.		*/
      338 	(conversion, size)		condition,
      339 	semantic_error		condition, 
      340 	date_time_$from_clock	entry (fixed bin(71), char(*), ptr, fixed bin(35)),
      341 	date_time_$to_clock		entry (ptr, fixed bin(71), fixed bin(35)),
      342 	date_time_$offset_to_clock	entry (ptr, fixed bin(71), char(*), fixed bin(71), fixed bin(35)),
      343 	ioa_$nnl			entry() options(variable);
      344 
      345 
      346      dcl						/*		static variables		*/
      347         (FALSE			init("0"b),
      348           TRUE			init("1"b)) bit(1) int static options(constant),
      349 	microseconds_per_day	fixed bin (71) int static options (constant) init (864e8),
      350          (Tunknown		init(0),			/* Table unknown				*/
      351 	TTnumber		init(8),			/* Token Type xxx				*/
      352 	TTbignum		init(9),
      353 	TTfraction	init(10),
      354 	TTandfraction	init(11),
      355 	TTother		init(12),
      356 
      357 	VWbefore		init(1),			/* Value for Word xxx			*/
      358 	VWor		init(2),
      359 	VWafter		init(3),
      360 	VWon		init(4),
      361 	VWnoon		init(5),
      362 	VWmidnight	init(6),
      363 	VWnow		init(7),
      364 	VWyesterday	init(8),
      365 	VWtoday		init(9),
      366 	VWtomorrow	init(10),
      367 	VWfw		init(11),
      368 	VWam		init(12),
      369 	VWpm		init(13),
      370 
      371 	VOyear		init(1),			/* Value for Offset xxx			*/
      372 	VOmonth		init(2),
      373 /*	VOweek		init(3),				       */
      374 	VOday		init(4),
      375 	VOhour		init(5),
      376 	VOminute		init(6),
      377 	VOsecond		init(7),
      378 /*	VOmicrosecond	init(8)				       */
      379 
      380 	need_default	init (-1),
      381 	need_year		init (-2),
      382 	need_this		init (-3),
      383 	need_yesterday	init (-10),
      384 	need_today	init (-11),
      385 	need_tomorrow	init (-12)
      386 	)			fixed bin int static options(constant),
      387 						/* various token types.			*/
      388 	Ttoken (19)		fixed bin int static options(constant) init (
      389 				     0, 0, 0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 3),
      390 				/*  HT SP  _  +  -  0  1  2  3  4  5  6  7  8  9  .  /  :  ,	*/
      391 				/* Type of lex to be performed for a token beginning with one of the	*/
      392 				/*    above characters.					*/
      393 	Type	fixed bin,
      394 	Value	fixed bin(35);
      395       dcl (
      396 	error_table_$bad_conversion,
      397 	error_table_$dt_ambiguous_time,
      398 	error_table_$dt_bad_day_of_week,
      399 	error_table_$dt_bad_fw,
      400 	error_table_$dt_hour_gt_twelve,
      401 	error_table_$dt_multiple_meaning,
      402 	error_table_$dt_multiple_date_spec,
      403 	error_table_$dt_multiple_diw_spec,
      404 	error_table_$dt_multiple_time_spec,
      405 	error_table_$dt_multiple_zone_spec,
      406 	error_table_$dt_size_error,
      407 	error_table_$dt_time_conversion_error,
      408 	error_table_$dt_unknown_word,
      409 	error_table_$too_many_tokens
      410 	)					 fixed bin(35) ext static;
      411 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      412 
      413 	analyze_sw = FALSE;
      414 	if constant_sw
      415 	then clock_now = constant_clock;
      416 	else clock_now = clock();			/* initialize clock value to current time.	*/
      417 	goto COMMON;
      418 
      419 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      420 
      421 
      422 relative:	entry	(time_string, clock_out, relative_to_clock, code);
      423 
      424 	analyze_sw = FALSE;
      425 	if constant_sw				/* if we're in testing mode, use the forced	*/
      426 	then clock_now = constant_clock;		/* ..value instead of his.			*/
      427 	else clock_now = relative_to_clock;
      428 
      429 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      430 
      431 analyze:	entry	(time_string, relative_to_clock, clock_out, fixed_length_sw, code);
      432 	
      433 	analyze_sw = TRUE;
      434 	fixed_length_sw = FALSE;
      435 	if constant_sw				/* if we're in testing mode, use the forced	*/
      436 	then clock_now = constant_clock;		/* ..value instead of his.			*/
      437 	else clock_now = relative_to_clock;
      438 	
      439 
      440 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      441 
      442 COMMON:	tcode, lcode, errloc = 0;			/* no errors found during semantic analysis.	*/
      443 	details = "";
      444 	Pfirst_token, err_pt = null();
      445 	h_time_sw = ""b;				/* no held time data			*/
      446 	rtime_ct = 0;				/* no relative date/time values encountered yet.	*/
      447 	rtime_first = "1"b;				/* This is set on initially.			*/
      448 						/* before/on/after will do so also.		*/
      449 	lang_used = copy ("1"b, ti_language.number_lang);	/* show ALL languages used.			*/
      450 	ambig_sw = ""b;				/* and no ambiguous tokens			*/
      451 	code = 0;					/* initialize output value.			*/
      452 	ti_token_p = addr (time_info_$tokens);
      453 
      454 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/
      455 	/* 								         */
      456 	/* Parse the input string into tokens structured like those created by lex_string_ and   */
      457 	/* used with reductions (see reduction_compiler).  lex_string_ is not used because we    */
      458 	/* don't need all of its power, and because our parse associates semantic information    */
      459 	/* with the tokens during the parsing.					         */
      460 	/* 								         */
      461 	/* A token is a lexeme of a time string. Examples are 12, /, Monday, Janvier, 1979,      */
      462 	/* etc.  The parser below finds the tokens in the string.  Associated with each token is */
      463 	/* a token type and a numeric value.  The numeric value depends upon the type of token.  */
      464 	/* Numeric character string tokens use the numeric value of the character string         */
      465 	/* (converted according to PL/I conversion rules).  Month names have their month number  */
      466 	/* as a numeric value.  The same is true for day names (1=Mon,...,7=Sun).  Offset words  */
      467 	/* (like weeks, days, etc) have a value from 1 to 7 (1=years,2=months,...7=seconds).  As */
      468 	/* each token is found, it is added to a chain of tokens by the token_ procedure. token_ */
      469 	/* also removes the token from the string, leaving only unprocessed string characters to */
      470 	/* be parsed.							         */
      471 	/* 	Due to the multiple languages, there are tokens which are ambiguous.  This	*/
      472 	/* means that it does not mean the same thing in all languages.  When one of these guys	*/
      473 	/* is encountered, it is flagged as "unknown".  These steps are taken to decide what a	*/
      474 	/* token is to be used as.							*/
      475 	/*   1) All nonambiguous tokens have their language bits ANDed.  If this results in	*/
      476 	/*      all zeroes, there is a mixed language error.				*/
      477 	/*   2) A multiple parse will be undertaken, first with the process default language,	*/
      478 	/*      then the system default, then with any left in the order they appear in		*/
      479 	/*      time_info_.  HOWEVER, the nonambiguous tokens will have restricted the set of	*/
      480 	/*      possible languages.							*/
      481 	/*         The unknown tokens do not have their numeric value set.  During each pass,	*/
      482 	/*      when a semantic function decides a token can be the type it is looking for it	*/
      483 	/*      will plug in the appropriate numeric value while leaving the type unknown.	*/
      484 	/*      The action routine will then be able to pick up the value without extra work.	*/
      485 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/
      486 
      487 	
      488 	Pstr = addr(time_string);		/* address time string.			*/
      489 	Lstr = length(time_string);
      490 	silent = ^time_defaults_$debug;
      491 	Ntokens = 0;				/* No tokens found yet.			*/
      492 	on conversion				/* handle number conversion errors.		*/
      493 	begin;
      494 	   lcode = error_table_$bad_conversion;
      495 	   goto set_err_loc;
      496 	end;
      497 	size_flag = ""b;
      498 	on size
      499 	begin;
      500 	   if size_flag
      501 	   then do;				/* we know it is all digits, but it might	*/
      502 	      Type = TTbignum;			/* ..not fit in a fixed bin (35).  Thats OK.	*/
      503 	      number = -1;
      504 	      goto lex1a;
      505 	   end;
      506 	   lcode = error_table_$dt_size_error;
      507 	   goto set_err_loc;
      508 	end;
      509 
      510 	Sspace_encountered = TRUE;			/* Pretend string begins with whitespace.	*/
      511 	do while (Lstr > 0);			/* parse the string.			*/
      512 /****          Search string begins with HT SP _ + ...			       			*/
      513 	     Isearch = search (str, "	 _+-0123456789./:,");
      514 	     if Isearch = 0 then Isearch = Lstr + 1;	/* find first delimiter character in string.	*/
      515 
      516 	     if Isearch > 1 then do;			/* Was a word found in the string preceding the.	*/
      517 						/*   delimiter?				*/
      518 		Sspace_encountered = FALSE;
      519 re_try:
      520 		Lword_in_str = Isearch-1;
      521 		if length(word_in_str) > 32 then goto Eunknown_word;
      522 						/* make sure word isn't too long.		*/
      523 		item_p = find_time_name (word_in_str);
      524 		if (item_p ^= null())
      525 		then do;				/* word was found				*/
      526 		   Type = item.table (1);
      527 		   Value = item.element (1);
      528 		   if (item.count > 1) & (Type ^= This_table)
      529 		   then do;			/* we can't tell yet			*/
      530 		      lang_temp = ""b;
      531 		      do ii = 1 to item.count;
      532 		         lang_temp = lang_temp | item.in_lang (ii);
      533 		      end;
      534 		      lang_used = lang_used & lang_temp;
      535 		      call token_ (length(word_in_str), Tunknown, 0);
      536 		      ambig_sw = "1"b;		/* remember its ambiguous			*/
      537 		   end;
      538 		   else do;			/*   create a token for the word.		*/
      539 		      call token_ (length(word_in_str), Type, Value);
      540 		      lang_used = lang_used & item.in_lang (1);	/* only 1 element */
      541 		   end;
      542 		   token.Psemant = item_p;		/* keep ptr to token info			*/
      543 		end;
      544 		else do;				/* the generated zones end in digits, so before	*/
      545 						/* giving up, lets try gathering some digits	*/
      546 						/* also.					*/
      547 		   Isearch = search (str, "	 _+-./:,");
      548 		   if Isearch = 0 then Isearch = Lstr + 1;
      549 		   if (Isearch-1 > Lword_in_str)	/* If that increased the token size, we'll	*/
      550 						/*   try once again.			*/
      551 		   then goto re_try;
      552 		   goto Eunknown_word;		/* Oops!  You shouldn't say that.		*/
      553 		end;
      554 		if Lstr <= 0 then goto end_scan;	/* Stop scan if word at end of time string.	*/
      555 		end;
      556 
      557 	     Idelim_type = Ttoken (index ("	 _+-0123456789./:,", first_char_of_str));    /* HT SP _ ... */
      558 	     goto lex(Idelim_type);			/* we know first char of str is now a delimiter	*/
      559 						/*   because token_ would skip any word which	*/
      560 						/*   might have preceeded the delimiter.	*/
      561 						/*   Continue lexing according to delimiter type.	*/
      562 
      563 lex(0):	     Sspace_encountered = TRUE;
      564 	     Iverify = verify (str, "	 _");		/* skip leading white space (HT SP or _)	*/
      565 	     if Iverify = 0 then Iverify = Lstr + 1;
      566 	     Pstr = addcharno (Pstr,(Iverify-1));
      567 	     Lstr = Lstr - (Iverify-1);
      568 	     goto end_scan;
      569 
      570 lex(1):	     Iverify = verify(str, "0123456789");	/* find out how long numeric field is.		*/
      571 	     if Iverify = 0 then Lnumber_in_str = Lstr;
      572 	     else Lnumber_in_str = Iverify - 1;
      573 	     Type = TTnumber;
      574 	     size_flag = "1"b;
      575 	     number = convert(number, number_in_str);	/* This conversion is done because some range	*/
      576 	     size_flag = ""b;			/* ..checking is done, so we need the value.	*/
      577 lex1a:
      578 	     call token_ (length(number_in_str), Type, number);
      579 	     if (Lstr = 0)
      580 	     then goto end_scan;
      581 	     if (substr (str, 1, 1) ^= ".")
      582 	     then goto end_scan;
      583 	     Type = TTandfraction;
      584 	     goto lex2a;
      585 
      586 lex(2):	     Type = TTfraction;
      587 lex2a:
      588 	     if (Lstr > 1)
      589 	     then do;
      590 	        Iverify = verify(substr (str, 2), "0123456789");	/* find out how long fraction field is.		*/
      591 	        if Iverify = 0 then Lnumber_in_str = Lstr;
      592 	        else Lnumber_in_str = Iverify;
      593 	     end;
      594 	     else Lnumber_in_str = 1;
      595 	     if (Lnumber_in_str > 0)
      596 	     then call token_ (Lnumber_in_str, Type, 0);
      597 	     Sspace_encountered = FALSE;
      598 	     goto end_scan;
      599 
      600 lex(3):	     					/* found "+", "-", "/", ":", or ","		*/
      601 	     Sspace_encountered = FALSE;
      602 	     call token_ (1, TTother, 0);		/*    create a token for the break character.	*/
      603 
      604 end_scan:	     end;					/* continue lexing with the next field.		*/
      605 
      606 	revert conversion, size;			/* get rid of this thing when not needed.	*/
      607 	if Ntokens = 0 then do;
      608 	     clock_out = clock_now;
      609 	     goto exit;
      610           end;
      611 						/* analyze semantic content of any lexed tokens.	*/
      612 	if (lang_used = ""b)			/* --NO COMMON LANGUAGE--			*/
      613 	then do;
      614 	   lcode = error_table_$dt_ambiguous_time;
      615 	   goto error_exit;
      616 	end;
      617 
      618 	unspec (atime_h) = ""b;
      619 	unspec (rspace_h) = ""b;
      620 	unspec (atime_init) = ""b;
      621 	atime_init.version = Vtime_value_3;
      622 	atime_init.yc, atime_init.my, atime_init.dm = need_default;
      623 	atime_init.Hd, atime_init.MH, atime_init.SM, atime_init.US = need_default;
      624 	atime_init.za = "";
      625 	ctime = atime_init;
      626 
      627 	unspec (rspace_init) = ""b;
      628 	rtime_p = addr (rspace_init (1).data);
      629 	rtime.version = Vtime_offset_2;
      630 	rtime_array.val (*) = 0;				/* must have decimal zeroes there		*/
      631 	do i = 2 to dim (rspace_init, 1);
      632 	   rspace_init (i) = rspace_init (1);
      633 	end;
      634 	on condition (semantic_error)
      635 	begin;
      636 	   goto parse_fail;
      637 	end;
      638 	done = ""b;
      639 	do lang_index = time_defaults_$language_index,
      640 	   time_info_$default_language_index while (^done),
      641 	   1 to ti_language.number_lang while (^done);
      642 	   if substr (lang_used, lang_index, 1)
      643 	   then do;
      644 	      if ^silent & ambig_sw
      645 	      then call ioa_$nnl ("***Trying ^a.^/", ti_language.name (1, lang_index));
      646 	      substr (lang_used, lang_index, 1) = ""b;	/* show its been used			*/
      647 	      rspace = rspace_init;
      648 	      atime = atime_init;
      649 	      fw_sw = ""b;
      650 	      u_day_of_week = 0;			/* absolute/relativeness undetermined.		*/
      651 
      652 						/* analyze semantic content of lexed tokens.	*/
      653 	      Pthis_token = addr(tokens(1));
      654 	      tcode, lcode, errloc = 0;
      655 	      err_pt = null();
      656 	      call SEMANTIC_ANALYSIS();
      657 /****	      We don't know what day_of_week stands for yet, just preserve */
      658 /****	      until later.					       */
      659 	      atime.dw = u_day_of_week;
      660 parse_fail:
      661 	      call error_display;
      662 	      done = ^ambig_sw;
      663 	      if (lcode = 0)
      664 	      then do;
      665 	         if ^ambig_sw
      666 	         then goto parse_success;
      667 /****           When ambiguity exists, we must try all selected languages. 				*/
      668 /****           If there is only 1 match, we assume we are safe.  Otherwise we				*/
      669 /****	      must complain that we can't tell.							*/
      670 	         if ^h_time_sw			/* is this first match?			*/
      671 	         then do
      672 		  h_time_sw = "1"b;			/* ..yes, remember the set of data found.	*/
      673 		  atime_h = atime;
      674 		  rspace_h = rspace;
      675 		  rtime_ct_h = rtime_ct;
      676 	         end;
      677 	         else if (unspec (atime_h) ^= unspec (atime))	/* ..no, did we find a different meaning?	*/
      678 		  | (unspec (rspace_h) ^= unspec (rspace))
      679 	         then do;				/* ..yes					*/
      680 		  lcode = error_table_$dt_multiple_meaning;
      681 		  goto error_exit;			/* Sorry ma'm, no can do.			*/
      682 /**** At this point we could trigger a 2nd pass which will gather info to give a more meaningful message.	*/
      683 	         end;
      684 	      end;
      685 	   end;
      686 	end;
      687 	call error_display;
      688 	if ^h_time_sw				/* if there was no match, we are all done	*/
      689 	then do;
      690 error_exit:
      691 	   call error_display;
      692 	   code = lcode;
      693 exit:
      694 	   return;
      695 	end;
      696 
      697 error_display: proc;
      698 	   if (lcode = 0) | (lcode = tcode)
      699 	   then return;
      700 	   if ^silent
      701 	   then do;
      702 	      if (Pfirst_token ^= null())
      703 	      then call ioa_$nnl ("^/");
      704 	      if (lcode ^= 0)
      705 	      then do;
      706 	         if (err_pt ^= null())
      707 	         then errloc = charno (err_pt) - charno (addr (time_string)) + 1;
      708 	         call com_err_ (lcode, "convert_date_to_binary_", "^[
      709 ^a^;^s^]^[
      710 String is: ""^va""
      711  error at: ^vx^^^]", (details ^= ""), details,
      712 		  (errloc > 0), length (time_string), time_string, errloc);
      713 	      end;
      714 	   end;
      715 	   tcode = lcode;
      716 	end error_display;
      717 parse_success:
      718 	if h_time_sw
      719 	then do;
      720 	   atime = atime_h;				/* bring back the remembered success		*/
      721 	   rspace = rspace_h;
      722 	   rtime_ct = rtime_ct_h;
      723 	end;
      724 /****     Now retrieve day_of_week, so that we can determine what it is.     */
      725 	u_day_of_week = atime.dw;
      726 	atime.dw = 0;
      727 
      728 	Lstr = 80;				/* keeps debugging code working		*/
      729 	year_needed, date_given, dow_given = ""b;
      730 						/* get current date/time values.		*/
      731 
      732 	if analyze_sw				/* For $analyze entrypoint,			*/
      733 	then do;					/*  the time_string is a fixed-length increment   */
      734 	   if unspec(atime) = unspec(atime_init) then	/*  iff no absolute date/time info is given, and  */
      735 	   if u_day_of_week = 0 then			/*  only week, day, hour, minute, second and/or   */
      736 	   if rtime_ct > 0 then do;			/*  microsecond offsets are given.                */
      737 	      do i = rtime_ct to 1 by -1;
      738 	         rtime_p = addr(rspace(i).data);
      739 	         if rtime.flag.yr + rtime.flag.mo > UNUSED
      740 	         then go to NOT_FIXED_LENGTH;
      741 	         end;
      742 	      fixed_length_sw = TRUE;
      743 	      end;
      744 NOT_FIXED_LENGTH:
      745 	   end;
      746 
      747 	if (atime.za = "#") then atime.za = "gmt";	/* request_id defaults to GMT			*/
      748 	call date_time_$from_clock (clock_now, atime.za, addr (ctime), code);
      749 	if u_day_of_week ^= 0 then			/* apply defaults to unset date/time values.	*/
      750 	     if atime.my ^= need_default then		/*    day_of_week is absolute if user also gave	*/
      751 		atime.dw = u_day_of_week;		/*       a date specification.		*/
      752 	     else do;				/*    otherwise, it is a day_of_week date,	*/
      753 	          date_given = "1"b;
      754 		call init_rtime;
      755 		rtime.flag.da = USED;
      756 		rtime.val.da = rtime.val.da + mod (u_day_of_week - ctime.dw + 6, 7) + 1;
      757 		end;
      758 
      759 	if (atime.yc = need_this) then atime.yc = ctime.yc;
      760 	if (atime.my = need_this) then atime.my = ctime.my;
      761 	if (atime.dm = need_this) then atime.dm = ctime.dm;
      762 	if (atime.Hd = need_this) then atime.Hd = ctime.Hd;
      763 	if (atime.MH = need_this) then atime.MH = ctime.MH;
      764 	if (atime.SM = need_this) then atime.SM = ctime.SM;
      765 
      766 	if atime.my = need_yesterday
      767 	then do;
      768 	   ttime = atime_init;
      769 	   call date_time_$from_clock (clock_now - microseconds_per_day, atime.za,
      770 	      addr (ttime), code);
      771 	   atime.yc = ttime.yc;
      772 	   atime.my = ttime.my;
      773 	   atime.dm = ttime.dm;
      774 	end;
      775 	else if atime.my = need_today
      776 	then do;
      777 	   atime.yc = ctime.yc;
      778 	   atime.my = ctime.my;
      779 	   atime.dm = ctime.dm;
      780 	end;
      781 	else if atime.my = need_tomorrow
      782 	then do;
      783 	   ttime = atime_init;
      784 	   call date_time_$from_clock (clock_now + microseconds_per_day, atime.za,
      785 	      addr (ttime), code);
      786 	   atime.yc = ttime.yc;
      787 	   atime.my = ttime.my;
      788 	   atime.dm = ttime.dm;
      789 	end;
      790 	if atime.my = need_default	 		/* supply month-day if needed		*/
      791 	then do;
      792 	   atime.my = ctime.my;
      793 	   atime.dm = ctime.dm;
      794 	end;
      795 	else date_given = "1"b;
      796 	if atime.yc < 0 then do;			/* supply year if needed--		*/
      797 						/*   this_year or a missing year.		*/
      798 	   if atime.yc = need_year			/* missing year-- assume current year for now.	*/
      799 	   then year_needed = "1"b;
      800 	   atime.yc = ctime.yc;
      801 	end;
      802 	if atime.Hd = need_default then do;		/* supply time defaults if needed	*/
      803 	     atime.Hd = ctime.Hd;
      804 	     atime.MH = ctime.MH;
      805 	     atime.SM = ctime.SM;
      806 	     atime.US = ctime.US;
      807 	     end;
      808 
      809 /****	  else if (atime.Hd=24)...				       */
      810 /****          In the old days, the "24" times were handled right here.      */
      811 /****          But now date_time_$to_clock handles them instead.	       */
      812 	     
      813 /**** At this point, yc/my/dm/Hd/MH/SM/US have been filled in from "now" if they were not given.	*/
      814           call date_time_$to_clock (addr (atime), clock_out, code);
      815 	if atime.dw > 0 & code = error_table_$dt_bad_day_of_week
      816 	then do;
      817 	   if clock_out >= clock_now |		/* if day-of-week doesn't match and a   */
      818 	     (^year_needed & date_given)		/* specific date was given, report an   */
      819 	   then go to exit;				/* error now.			*/
      820 	   atime.dw = 0;				/* Otherwise, delay dow check until the */
      821 						/* specific date is known.		*/
      822 	   call date_time_$to_clock (addr (atime), clock_out, code);
      823 	   call init_rtime;				/* setup to do dow checks below.	*/
      824 	   rspace(rtime_ct).dw_required = u_day_of_week;
      825 	   rtime_first = "1"b;
      826 	   atime.dw = 0;
      827 	end;
      828           if code ^= 0
      829 	then go to exit;
      830 	if (clock_out < clock_now)			/* if value as defaulted is less than	*/
      831 	then do;					/* ..NOW, we have to adjust forward.	*/
      832 	   if year_needed
      833 	   then do;
      834 	      call init_rtime;
      835 	      rtime.flag.yr = USED;
      836 	      rtime.val.yr = rtime.val.yr +1;
      837 	   end;
      838 	   else if ^date_given
      839 	   then clock_out = clock_out + microseconds_per_day;
      840 	end;
      841 
      842 	do i = rtime_ct to 1 by -1 while (code = 0);
      843 	   if rspace(i).dw_required > UNUSED then do;
      844 	      call date_time_$from_clock (clock_out, atime.za, addr(atime), code);
      845 	      if atime.dw ^= rspace(i).dw_required
      846 	      then do;
      847 	         code = error_table_$dt_bad_day_of_week;
      848 	         goto exit;
      849 	      end;
      850 	   end;
      851 	   if sum(rspace(i).data.flag(*)) > UNUSED | 
      852 	      rspace(i).data.dw.flag ^= UNUSED
      853 	   then call date_time_$offset_to_clock (addr (rspace (i).data),
      854 	      clock_out, atime.za, clock_out, code);
      855 	end;
      856 	goto exit;


      857 Eunknown_word:
      858 	lcode = error_table_$dt_unknown_word;
      859 	goto set_err_loc;
      860 
      861 Etoo_many_adverbs:
      862 	details = "Only " || ltrim (char (hbound (rspace,1)))
      863 	   || " offset groups may be used.";
      864 	lcode = error_table_$too_many_tokens;
      865 	err_pt = token.Pvalue;
      866 	goto error_exit;
      867 
      868 Etoo_many_tokens:
      869 	lcode = error_table_$too_many_tokens;
      870 set_err_loc:
      871 	err_pt = Pstr;
      872 	goto error_exit;
      873 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      874 	/*					       */
      875 	/* The following 2 entries are an aid to debugging.      */
      876 	/* The "set" entry allows a person to fix the reference  */
      877 	/* value to any point they wish.  The "unset" entry      */
      878 	/* returns things to the normal state.  After having     */
      879 	/* called "set", all calls to $convert_date_to_binary_   */
      880 	/* function as if the $relative entry had been called    */
      881 	/* with the saved value.			       */
      882 	/*					       */
      883 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      884 
      885 dcl constant_sw	bit (1) int static init (""b);
      886 dcl constant_clock	fixed bin (71) int static;
      887 
      888 unset: entry;
      889 
      890           constant_sw = ""b;
      891 	return;
      892 
      893 set: entry;
      894 /****     Wrap this code up in a begin block to make 100% sure that nobody outside depends	*/
      895 /****     on anything herein.  Then we can be sure that it may be deleted without effect.		*/
      896           begin;
      897 	   call cu_$arg_ptr (1, arg_p, arg_l, code);
      898 	   if (code ^= 0)
      899 	   then constant_clock = clock();
      900 	   else do;
      901 	      call convert_date_to_binary_ (arg, a_clock, code);
      902 	      if (code ^= 0)
      903 	      then do;
      904 	         call com_err_ (code, "convert_date_to_binary_$set", "^a", arg);
      905 	         return;
      906 	      end;
      907 	      constant_clock = a_clock;
      908 	   end;
      909 	   constant_sw = "1"b;
      910 	   return;
      911      dcl
      912 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      913 	arg			char (arg_l) based (arg_p),
      914 	arg_l			fixed bin (21),
      915 	arg_p			ptr,
      916 	code			fixed bin (35);
      917      end;
      918 dcl Pfirst_token	ptr;
      919 SL: proc (red);
      920 dcl red		fixed bin;	/* reduction to display	       */
      921 
      922         if ^silent
      923         then do;
      924 	 Pfirst_token = Ptoken;
      925 	 call ioa_$nnl (string (SLtext), red);
      926         end;
      927         return;
      928 
      929 SLe: entry;
      930 
      931         if ^silent
      932         then do;
      933 	 do Ptoken = Pfirst_token repeat (token.Pnext) while ((Ptoken ^= null()) & (Ptoken ^= Pthis_token));
      934 	    call ioa_$nnl (" ^a", token_value);
      935 	 end;
      936 	 call ioa_$nnl ("^/");
      937 	 Pfirst_token = null();
      938 	 Ptoken = Pthis_token;
      939         end;
      940 
      941 				/* format: off */
      942 dcl 1 SLtext	unaligned int static options (constant),
      943     2 x0  char ( 3) init ("^3x"),
      944     2 x1	char (20) init ("^[<month-name> <day>"),
      945     2 x2	char (20) init ("^;<day> <month-name>"),
      946     2 x3	char (26) init ("^;<month> / <day> / <year>"),
      947     2 x4	char (17) init ("^;<month> / <day>"),
      948     2 x5	char (26) init ("^;<year> - <month> - <day>"),
      949     2 x6	char (29) init ("^;<fiscal-indicator> <number>"),
      950     2 x7	char (34) init ("^;<number> <and-fraction> <offset>"),
      951     2 x8	char (14) init ("^;<request-id>"),
      952     2 x9	char (23) init ("^;<HHMM> <and-fraction>"),
      953     2 x10	char (19) init ("^;<hour> : <minute>"),
      954     2 x11	char (29) init ("^;<hour> <meridiem-indicator>"),
      955     2 x12	char (15) init ("^;12 <half-day>"),
      956     2 x13	char (12) init ("^;<half-day>"),
      957     2 x14	char (14) init ("^;<day-name> ,"),
      958     2 x15	char (21) init ("^;<day-name> <adverb>"),
      959     2 x16	char (12) init ("^;<day-name>"),
      960     2 x17	char (26) init ("^;<sign> <number> <offset>"),
      961     2 x18	char (19) init ("^;<number> <offset>"),
      962     2 x19	char (41) init ("^;<sign> <number> <and-fraction> <offset>"),
      963     2 x20	char (21) init ("^;<fraction> <offset>"),
      964     2 x21	char (28) init ("^;<sign> <fraction> <offset>"),
      965     2 x22	char ( 8) init ("^;<zone>"),
      966     2 x23	char ( 8) init ("^;<word>"),
      967     2 x24	char (10) init ("^;<adverb>"),
      968     2 x25	char (13) init ("^;or <adverb>"),
      969     2 x26	char (27) init ("^;: <second> <and-fraction>"),
      970     2 x27	char (12) init ("^;: <second>"),
      971     2 x28	char (19) init ("^;<minute-fraction>"),
      972     2 x29	char (22) init ("^;<meridiem-indicator>"),
      973     2 x30	char (21) init ("^;<zone-differential>"),
      974     2 x31	char (10) init ("^;, <year>"),
      975     2 x32	char ( 8) init ("^;<year>"),
      976     2 x99 char ( 8) init ("^]^25.1t");	/* format: on */
      977 
      978      end SL; 
      979 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      980 
      981 /****    A very similar routine exists in get_word_index in date_time_.pl1.				*/
      982 
      983 find_time_name: proc (val) returns (ptr);
      984 
      985 dcl val		char (*);
      986 
      987 dcl (lb, hb)	fixed bin;
      988 dcl symb		char (32) var;
      989 dcl cur_token	fixed bin;
      990 dcl (az		init ("abcdefghijklmnopqrstuvwxyz"),
      991      AZ		init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
      992 		char (26) int static options (constant);
      993 
      994       symb = translate (val, az, AZ);	/* get to normal form		*/
      995       symb = rtrim (symb);		/* minimize compare time		*/
      996 
      997       lb = 1;
      998       hb = ti_token.count;
      999       do while (lb <= hb);
     1000          cur_token = divide (lb + hb, 2, 17, 0);
     1001          if (ti_token.symbol (cur_token) = symb)
     1002          then return (addrel (addr (time_info_$version),
     1003 	       ti_token.list_r (cur_token)));
     1004          if (ti_token.symbol (cur_token) < symb)
     1005          then lb = cur_token + 1;
     1006          else hb = cur_token - 1;
     1007       end;
     1008       return (null ());
     1009 
     1010    end find_time_name; 





     1011 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1012 	/*									*/
     1013 	/*	SEMANTIC FUNCTIONS  and  ACTION ROUTINES				*/
     1014 	/*									*/
     1015 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1016 
     1017 
     1018 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1019 
     1020 
     1021 day_name:	procedure returns (bit(1) aligned);		/* semantic functions which check for token type.	*/
     1022 
     1023 	Twhich1 = Day_table;
     1024 	goto word_check;
     1025 
     1026 fraction:	entry returns (bit(1) aligned);
     1027 
     1028 	if token.Itoken_in_stmt = TTfraction then goto true;
     1029 	goto false;
     1030 
     1031 andfraction:	entry returns (bit(1) aligned);
     1032 
     1033 	if token.Itoken_in_stmt = TTandfraction then goto true;
     1034 	goto false;
     1035 
     1036 andfraction6:	entry returns (bit(1) aligned);
     1037 
     1038 	if token.Itoken_in_stmt = TTandfraction
     1039 	then if length (token_value) = 7 then goto true;
     1040 	goto false;
     1041 fweek: entry returns (bit(1) aligned);
     1042 
     1043           Twhich1, Twhich2, Twhich3 = VWfw;
     1044 	goto word_table_check;
     1045 
     1046 
     1047 half_day: entry returns (bit(1) aligned);
     1048 
     1049 	Twhich1 = VWnoon;
     1050 	Twhich2, Twhich3 = VWmidnight;
     1051 
     1052 word_table_check:
     1053 	if (token.Itoken_in_stmt = Word_table)
     1054 	then
     1055 	   if (token.Nvalue = Twhich1) | (token.Nvalue = Twhich2)
     1056 	   | (token.Nvalue = Twhich3)
     1057 	   then goto true;
     1058 	if (token.Itoken_in_stmt ^= Tunknown) then goto false;
     1059 
     1060 	item_p = token.Psemant;
     1061 	do elem = 1 to item.count;
     1062 	   if substr (item.in_lang (elem), lang_index, 1)	/* if defined in current language	*/
     1063 	   then if (Word_table = item.table (elem))	/* ..and is a type we want		*/
     1064 	   then do;				/* ..its a winner			*/
     1065 	      if (Twhich1 = item.element (elem))
     1066 	      then do;
     1067 	         token.Nvalue = Twhich1;
     1068 	         goto true;
     1069 	      end;
     1070 	      if (Twhich2 = item.element (elem))
     1071 	      then do;
     1072 	         token.Nvalue = Twhich2;
     1073 	         goto true;
     1074 	      end;
     1075 	      if (Twhich3 = item.element (elem))
     1076 	      then do;
     1077 	         token.Nvalue = Twhich3;
     1078 	         goto true;
     1079 	      end;
     1080 	   end;
     1081 	end;
     1082 	goto false;
     1083 
     1084 meridian:	entry returns (bit(1) aligned);
     1085 
     1086 	Twhich1 = VWam;
     1087 	Twhich2, Twhich3 = VWpm;
     1088 	goto word_table_check;
     1089 
     1090 on:	entry returns (bit(1) aligned);
     1091 
     1092 	Twhich1, Twhich2, Twhich3 = VWon;
     1093 	goto word_table_check;
     1094 
     1095 before_on_after:	entry returns (bit(1) aligned);
     1096 
     1097 	Twhich1 = VWbefore;
     1098 	Twhich2 = VWon;
     1099 	Twhich3 = VWafter;
     1100 	goto word_table_check;
     1101 
     1102 before_after:	entry returns (bit(1) aligned);
     1103 
     1104 	if (last_adverb = VWon)
     1105 	then do;
     1106 	   Twhich1 = VWbefore;
     1107 	   Twhich2, Twhich3 = VWafter;
     1108 	end;
     1109 	else Twhich1, Twhich2, Twhich3 = VWon;
     1110 	goto word_table_check;
     1111 
     1112 now:	entry returns (bit(1) aligned);
     1113 	Twhich1, Twhich2, Twhich3 = VWnow;
     1114 	goto word_table_check;
     1115 
     1116 or:	entry returns (bit(1) aligned);
     1117 	Twhich1, Twhich2, Twhich3 = VWor;
     1118 	goto word_table_check;
     1119 
     1120 today:	entry returns (bit(1) aligned);
     1121 	Twhich1, Twhich2, Twhich3 = VWtoday;
     1122 	goto word_table_check;
     1123 
     1124 tomorrow:	entry returns (bit(1) aligned);
     1125 	Twhich1, Twhich2, Twhich3 = VWtomorrow;
     1126 	goto word_table_check;
     1127 
     1128 yesterday:	entry returns (bit(1) aligned);
     1129 	Twhich1, Twhich2, Twhich3 = VWyesterday;
     1130 	goto word_table_check;
     1131 
     1132 day: entry returns (bit(1) aligned);
     1133 	if this_()
     1134 	then do;
     1135 	   Twhich1 = VOday;
     1136 	   goto offset_table_check_next;
     1137 	end;
     1138 	goto n_;
     1139 
     1140 
     1141 month: entry returns (bit(1) aligned);
     1142 	if this_()
     1143 	then do;
     1144 	   Twhich1 = VOmonth;
     1145 	   goto offset_table_check_next;
     1146 	end;
     1147 	goto n_;
     1148 
     1149 
     1150 year: entry returns (bit(1) aligned);
     1151 	if this_()
     1152 	then do;
     1153 	   Twhich1 = VOyear;
     1154 	   goto offset_table_check_next;
     1155 	end;
     1156 	goto n_;
     1157 
     1158 
     1159 hour: entry returns (bit(1) aligned);
     1160 	if this_()
     1161 	then do;
     1162 	   Twhich1 = VOhour;
     1163 	   goto offset_table_check_next;
     1164 	end;
     1165 	goto n_;
     1166 
     1167 
     1168 minute: entry returns (bit(1) aligned);
     1169 	if this_()
     1170 	then do;
     1171 	   Twhich1 = VOminute;
     1172 	   goto offset_table_check_next;
     1173 	end;
     1174 	goto n_;
     1175 
     1176 
     1177 second: entry returns (bit(1) aligned);
     1178 	if this_()
     1179 	then do;
     1180 	   Twhich1 = VOsecond;
     1181 	   goto offset_table_check_next;
     1182 	end;
     1183 	goto n_;
     1184 
     1185 
     1186 month_name: entry returns (bit(1) aligned);
     1187 
     1188 	if this_()
     1189 	then do;
     1190 	   Twhich1 = VOmonth;
     1191 	   goto offset_table_check_next;
     1192 	end;
     1193 	Twhich1  = Month_table;
     1194 	goto word_check;
     1195 
     1196 
     1197 offset_table_check_next:
     1198 	if token.Pnext = null then goto false;
     1199 	Ptoken = token.Pnext;
     1200 	if (token.Itoken_in_stmt = Offset_table)
     1201 	then
     1202 	   if (token.Nvalue = Twhich1)
     1203 	   then goto true;
     1204 	if (token.Itoken_in_stmt ^= Tunknown) then goto false;
     1205 
     1206 	item_p = token.Psemant;
     1207 	do elem = 1 to item.count;
     1208 	   if substr (item.in_lang (elem), lang_index, 1)	/* if defined in current language	*/
     1209 	   then if (Offset_table = item.table (elem))	/* ..and is a type we want		*/
     1210 	   then do;				/* ..its a winner			*/
     1211 	      if (Twhich1 = item.element (elem))
     1212 	      then do;
     1213 	         token.Nvalue = Twhich1;
     1214 	         goto true;
     1215 	      end;
     1216 	   end;
     1217 	end;
     1218 	goto false;
     1219 
     1220 N:	entry returns (bit(1) aligned);
     1221 
     1222 	if token.Itoken_in_stmt = TTbignum then goto true;
     1223 
     1224 n:
     1225 	entry returns (bit(1) aligned);
     1226 
     1227 n_:
     1228 	if token.Itoken_in_stmt = TTnumber then goto true;
     1229 	goto false;
     1230 n4:
     1231 	entry returns (bit(1) aligned);
     1232 
     1233 	if token.Itoken_in_stmt = TTnumber then
     1234 	     if length(token_value) = 4 then goto true;
     1235 	goto false;
     1236 
     1237 
     1238 n12: entry returns (bit(1) aligned);
     1239 
     1240 	if (token.Itoken_in_stmt = TTnumber) | (token.Itoken_in_stmt = TTbignum)
     1241 	     then if length(token_value) = 12 then goto true;
     1242 	goto false;
     1243 
     1244 
     1245 offset:	entry returns (bit(1) aligned);
     1246 
     1247 	Twhich1 = Offset_table;
     1248 	goto word_check;
     1249 
     1250 
     1251 this_:	entry returns (bit(1) aligned);
     1252 
     1253 	Twhich1 = This_table;
     1254 	goto word_check;
     1255 
     1256 
     1257 twelve:	entry returns (bit(1) aligned);
     1258 
     1259 	if token.Itoken_in_stmt = TTnumber then
     1260 	     if token.Nvalue = 12 then
     1261 		goto true;
     1262 	goto false;
     1263 
     1264 
     1265 sign:	entry returns (bit(1) aligned);
     1266 
     1267 	if token_value = "+" | token_value = "-" then goto true;
     1268 	goto false;
     1269 	
     1270 
     1271 zone:	entry returns (bit(1) aligned);
     1272 
     1273 	Twhich1 = Zone_table;
     1274 
     1275 /**** GCD: This check won't work if token means 2 different values in 2 different languages,	*/
     1276 /****     but both values are in the same table.						*/
     1277 /**** JAF: I'm not sure it can ever get here if that is the case.  More thought is needed		*/
     1278 /****	on having time_info_.cds preventing this kind of a table being constructed.  Or get	*/
     1279 /****	figured out when that could happen and still be parsable and then learn to handle it.	*/
     1280 
     1281 word_check:
     1282 	item_p = token.Psemant;
     1283 	if (token.Itoken_in_stmt = Twhich1) then goto true;	/* token.Nvalue is already set	*/
     1284 	if (token.Itoken_in_stmt ^= Tunknown) then goto false;
     1285 	do elem = 1 to item.count;
     1286 	   if substr (item.in_lang (elem), lang_index, 1)		/* if defined in current language	*/
     1287 	   then if (Twhich1 = item.table (elem))
     1288 	   then do;					/* ..and is the type we want		*/
     1289 	      token.Nvalue = item.element (elem);		/* its a winner			*/
     1290 	      goto true;
     1291 	   end;
     1292 	end;
     1293 
     1294 false:	return (FALSE);
     1295 
     1296 true:	return (TRUE);
     1297 
     1298      dcl (Twhich1, Twhich2, Twhich3, elem)			fixed bin;
     1299 
     1300 	end day_name;
     1301 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1302 
     1303 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1304 
     1305 Aday_and_LEX:	procedure;			/* action routines which apply input token value	*/
     1306 						/*    to absolute/relative date/time, as named in	*/
     1307 						/*    entry point.				*/
     1308 
     1309 	if atime.dm ^= need_default then goto Emultiple_date_spec;
     1310 	if this_()
     1311 	then do;
     1312 	   call LEX (1);
     1313 	   atime.dm = need_this;
     1314 	end;
     1315 	else atime.dm = token.Nvalue;
     1316 	call LEX (1);
     1317 	return;
     1318 
     1319 Ab_o_a:	entry;
     1320 
     1321 	call init_rtime;
     1322 	if (rspace.rel_ct (rtime_ct)  ^= 1)
     1323 	then do;
     1324 	   details = "Cannot mix <day_name> with <offsets>.";
     1325 	   lcode = error_table_$dt_time_conversion_error;
     1326 	   err_pt = token.Pvalue;
     1327 	   signal condition (semantic_error);
     1328 	end;
     1329 	if (token.Nvalue = VWbefore)			/* <day_name> <before_after>			*/
     1330 	then rtime.dw.flag = BEFORE;
     1331 	if (token.Nvalue = VWafter)
     1332 	then rtime.dw.flag = AFTER;
     1333 	rtime.dw.val = u_day_of_week;
     1334 	if (token.Nvalue = VWon)			/* <day_name> <on>				*/
     1335 	then rspace.dw_required(rtime_ct) = u_day_of_week;
     1336 	u_day_of_week = 0;
     1337 	last_adverb = token.Nvalue;
     1338 	return;
     1339 
     1340 Ab_a:	entry;
     1341 
     1342 	call init_rtime;
     1343 	if (rspace.rel_ct (rtime_ct) < 2)   		/* there must be something to apply to		*/
     1344 	then do;
     1345 	   details = "Nothing for adverb to apply to.";
     1346 	   lcode = error_table_$dt_time_conversion_error;
     1347 	   err_pt = token.Pvalue;
     1348 	   signal condition (semantic_error);
     1349 	end;
     1350 	begin;					/* <day_name> <before_after> <or> <on>		*/
     1351 dcl sign		builtin;
     1352 	   if (token.Nvalue = VWon)
     1353 	   then rtime.dw.flag = rtime.dw.flag - sign (rtime.dw.flag);
     1354 	end;
     1355 	if (token.Nvalue = VWbefore)			/* <day_name> <on> <or> <before_after>		*/
     1356 	then rtime.dw.flag = ON_OR_BEFORE;
     1357 	if (token.Nvalue = VWafter)
     1358 	then rtime.dw.flag = ON_OR_AFTER;
     1359 	if rtime.dw.flag ^= UNUSED
     1360 	then rspace.dw_required(rtime_ct) = UNUSED;
     1361 	return;
     1362 	
     1363 	
     1364 
     1365 Afw:	entry;
     1366 
     1367 	if fw_sw | (atime.yc ^= need_default) |(atime.my ^= need_default)
     1368 	then goto Emultiple_date_spec;
     1369 	atime.yc, atime.my, atime.dm = 0;
     1370 	if (length (token_value) = 6) | (length (token_value) = 5)
     1371 	then do;
     1372 	   atime.fw = token.Nvalue;
     1373 	   fw_sw = "1"b;
     1374 	   return;
     1375 	end;
     1376 	lcode = error_table_$dt_bad_fw;
     1377 	err_pt = token.Pvalue;
     1378 	signal condition (semantic_error);
     1379 	
     1380 
     1381 Ahalf_day:	entry;
     1382 
     1383 	if atime.Hd ^= need_default then goto Emultiple_time_spec;
     1384 	if (token.Nvalue = VWnoon)
     1385 	then atime.Hd = 12;
     1386 	else atime.Hd = 0;
     1387 	atime.MH = 0;
     1388 	atime.SM = 0;
     1389 	atime.US = 0;
     1390 	return;
     1391 
     1392 
     1393 Ahour_and_LEX:	entry;
     1394 
     1395 	if atime.Hd ^= need_default then goto Emultiple_time_spec;
     1396 	if this_()
     1397 	then do;
     1398 	   call LEX (1);
     1399 	   atime.Hd = need_this;
     1400 	end;
     1401 	else atime.Hd = token.Nvalue;
     1402 	call LEX (1);
     1403 	return;
     1404 
     1405 
     1406 Ameridian:	entry;
     1407 
     1408           if atime.Hd > 12 then goto Ehr_gt_12;
     1409 	if atime.Hd = 12
     1410 	then atime.Hd = 0;
     1411 	if (token.Nvalue = VWpm)
     1412 	then atime.Hd = atime.Hd + 12;
     1413 	return;
     1414 
     1415 
     1416 Arequest_id: entry;
     1417 
     1418 	if (atime.yc ^= need_default) | (atime.my ^= need_default)
     1419 	then goto Emultiple_date_spec;
     1420 	if (atime.Hd ^= need_default)
     1421 	then goto Emultiple_time_spec;
     1422 	atime.yc = fixed (rqid.yc) + 1900;		/* the 1900 is only temporary		*/
     1423 	atime.my = fixed (rqid.my);
     1424 	atime.dm = fixed (rqid.dm);
     1425 	atime.Hd = fixed (rqid.Hd);
     1426 	atime.MH = fixed (rqid.MH);
     1427 	atime.SM = fixed (rqid.SM);
     1428 	atime.US = fixed (rqid.US);
     1429 	fw_sw = "1"b;
     1430 	if (atime.za = "") then atime.za = "#";
     1431 	return;
     1432 
     1433 dcl 1 rqid	based (token.Pvalue),
     1434       2 (yc, my, dm, Hd, MH, SM) char (2),
     1435       2 fill	char (1),
     1436       2 US	char (6);
     1437 
     1438 
     1439 Asecond_fraction:	entry;
     1440 
     1441 	atime.US = get_fraction() * 1e6;		/* token value is the <fraction> of the reduction */
     1442 						/* which parses  HH:MM:SS.fraction		*/
     1443 	return;
     1444 
     1445 Aminute_fraction:	entry;
     1446 
     1447 	if (token_value = ".")
     1448 	then atime.SM, atime.US = 0;			/* 	hhmm.				*/
     1449 	else do;
     1450 	   atime.US = get_fraction() * 6e7;		/* token value is the <fraction> of reduction:	*/
     1451 	   atime.SM = divide (atime.US, 1000000, 17, 0);	/* 	hhmm.fraction			*/
     1452 	   atime.US = atime.US - (atime.SM * 1000000);
     1453 	end;
     1454 	return;
     1455 
     1456 
     1457 Aminute_and_LEX:	entry;
     1458 
     1459 	if this_()
     1460 	then do;
     1461 	   call LEX (1);
     1462 	   atime.MH = need_this;
     1463 	end;
     1464 	else atime.MH = token.Nvalue;
     1465 	call LEX (1);
     1466 	return;
     1467 
     1468 
     1469 Aminute_zero:	entry;
     1470 
     1471 	atime.MH = 0;
     1472 	return;
     1473 
     1474 
     1475 Amonth_and_LEX:	entry;
     1476 
     1477 	if atime.my ^= need_default then goto Emultiple_date_spec;
     1478 	if this_()
     1479 	then do;
     1480 	   call LEX (1);
     1481 	   atime.my = need_this;
     1482 	end;
     1483 	else atime.my = token.Nvalue;
     1484 	call LEX (1);
     1485 	fw_sw = "1"b;
     1486 	return;
     1487 
     1488 
     1489 Asecond_and_LEX:	entry;
     1490 
     1491 	if this_()
     1492 	then do;
     1493 	   call LEX (1);
     1494 	   atime.SM = need_this;
     1495 	end;
     1496 	else atime.SM = token.Nvalue;
     1497 	call LEX (1);
     1498 	atime.US = 0;
     1499 	return;
     1500 
     1501 
     1502 Asecond_zero:	entry;
     1503 
     1504 	atime.SM = 0;
     1505 	atime.US = 0;
     1506 	return;
     1507 
     1508 Atime:	entry;
     1509 
     1510 	if atime.Hd ^= need_default then goto Emultiple_time_spec;
     1511 	atime.Hd = divide(token.Nvalue, 100, 17, 0);
     1512 	atime.MH = mod(token.Nvalue, 100);
     1513 	return;
     1514 
     1515 Aadverb:	entry;
     1516 	if rtime_first
     1517 	then do;			/* nothing preceeds the adverb       */
     1518 	   details = "Nothing for adverb to apply to.";
     1519 	   lcode = error_table_$dt_time_conversion_error;
     1520 	   goto set_err_loc;
     1521 	end;
     1522 	if (rtime.dw.flag ^= UNUSED)	/* day_name cannot be mixed with     */
     1523 	then do;			/* ...offsets		       */
     1524 	   details = "Cannot mix <day_name> with <offsets>.";
     1525 	   lcode = error_table_$dt_time_conversion_error;
     1526 	   goto set_err_loc;
     1527 	end;
     1528 	if (unspec (atime) ^=  unspec (atime_init))	/* all adverbs must preceed any	*/
     1529 	then do;					/* ...absolute specs		*/
     1530 	   details = "All adverbial offsets must precede absolute data.";
     1531 	   lcode = error_table_$dt_time_conversion_error;
     1532 	   goto set_err_loc;
     1533 	end;
     1534 	if (token.Nvalue = VWbefore)
     1535 	then do;
     1536 	   do i = 1 to 8;
     1537 	      rtime_array.val(i) = - rtime_array.val(i);
     1538 	   end;
     1539 	end;	
     1540 	rtime_first = "1"b;
     1541 	return;
     1542 
     1543 
     1544 Anow:	entry;
     1545 	if atime.Hd ^= need_default then goto Emultiple_time_spec;
     1546 	atime.Hd = ctime.Hd;
     1547 	atime.MH = ctime.MH;
     1548 	atime.SM = ctime.SM;
     1549 	atime.US = ctime.US;
     1550 	return;
     1551 
     1552 Atoday:	entry;
     1553 	if (atime.dm ^= need_default)
     1554 	| (atime.my ^= need_default)
     1555 	| (atime.yc ^= need_default) then goto Emultiple_date_spec;
     1556 	atime.dm, atime.my, atime.yc = need_today;
     1557 	return;
     1558 
     1559 Atomorrow:	entry;
     1560 	if (atime.dm ^= need_default)
     1561 	| (atime.my ^= need_default)
     1562 	| (atime.yc ^= need_default) then goto Emultiple_date_spec;
     1563 	atime.dm, atime.my, atime.yc = need_tomorrow;
     1564 	return;
     1565 
     1566 Ayesterday:	entry;
     1567 	if (atime.dm ^= need_default)
     1568 	| (atime.my ^= need_default)
     1569 	| (atime.yc ^= need_default) then goto Emultiple_date_spec;
     1570 	atime.dm, atime.my, atime.yc = need_yesterday;
     1571 	return;
     1572 
     1573 
     1574 Ayear_and_LEX:	entry;
     1575 
     1576 	if atime.yc ^= need_default then goto Emultiple_date_spec;
     1577 	if this_()
     1578 	then do;
     1579 	   call LEX (1);
     1580 	   atime.yc = need_this;
     1581 	end;
     1582 	else do;
     1583 	   atime.yc = token.Nvalue;
     1584 	   if (length (token_value) < 3)
     1585 	   then do;				/* handle century default */
     1586 	      atime.yc = 1900 + atime.yc;
     1587 	   end;
     1588 	end;
     1589 	call LEX (1);
     1590 	return;
     1591 
     1592 
     1593 Ayear_default:	entry;
     1594 
     1595 	if atime.yc ^= need_default then goto Emultiple_date_spec;
     1596 	atime.yc = need_year;
     1597 	return;
     1598 
     1599 
     1600 Azone:	entry;
     1601 
     1602 	if (atime.za ^= "") & (atime.za ^= "#")
     1603 	then goto Emultiple_zone_spec;
     1604 	atime.za = token_value;
     1605 	atime.zone_index = token.Nvalue;
     1606 	return;
     1607 
     1608 
     1609 Azone_dif:	entry;
     1610 
     1611 	if (atime.za ^= "") & (atime.za ^= "#")
     1612 	then goto Emultiple_zone_spec;
     1613 	atime.za = SIGN || token_value;
     1614 	atime.zone_index = 0;
     1615 	return;
     1616 
     1617 
     1618 Uday_of_week:	entry;
     1619 
     1620 	if u_day_of_week ^= 0 then goto Emultiple_diw_spec;
     1621 	u_day_of_week = token.Nvalue;
     1622 	return;
     1623 
     1624 apply_sign_and_offset:
     1625 	entry;
     1626 
     1627 	if token_value = "+" then offset_sign = 1;	/* apply sign to offset value			*/
     1628 	else offset_sign = -1;
     1629 	Ptoken = token.Pnext;			/* skip over sign token.			*/
     1630 	goto join_offset;
     1631 
     1632 
     1633 apply_offset:
     1634 	entry;
     1635 
     1636 	offset_sign = +1;				/* assume positive sign for offset.		*/
     1637 join_offset:
     1638 	number = token.Nvalue;			/* get magnitude of offset.			*/
     1639 	if (number = 0)
     1640 	then return;
     1641 	if (number < 0)
     1642 	then do;
     1643 	   fld59 = get_number();
     1644 	   number = 0;
     1645 	end;
     1646 	else fld59 = 0;
     1647 	goto offset_common;
     1648 
     1649 Afraction_sign_and_offset:
     1650 	entry;
     1651 
     1652 	if token_value = "+" then offset_sign = 1;	/* apply sign to offset value			*/
     1653 	else offset_sign = -1;
     1654 	Ptoken = token.Pnext;			/* skip over sign token.			*/
     1655 	goto join_fraction;
     1656 
     1657 
     1658 Afraction_offset:
     1659 	entry;
     1660 
     1661 	offset_sign = +1;				/* assume positive sign for offset.		*/
     1662 join_fraction:
     1663 	if (token.Itoken_in_stmt ^= TTfraction)		/* the <N> part of the form is optional		*/
     1664 	then do;
     1665 	   number = token.Nvalue;			/* get magnitude of offset.			*/
     1666 	   if (number < 0)
     1667 	   then do;
     1668 	      number = 0;
     1669 	      fld59 = get_number();
     1670 	   end;
     1671 	   else fld59 = 0;
     1672 	   Ptoken = token.Pnext;			/* move to fraction.			*/
     1673 	end;
     1674 	else number, fld59 = 0;
     1675           fld59 = fld59 + get_fraction();
     1676           if (fld59 = 0)
     1677 	then do;
     1678 	   if (number = 0)
     1679 	   then return;				/* forget he even mentioned it		*/
     1680 	end;
     1681 offset_common:
     1682 	Ptoken = token.Pnext;			/* move to offset				*/
     1683 
     1684 	call init_rtime;
     1685 	rtime_array.flag (token.Nvalue) = USED;
     1686 	rtime_array.val (token.Nvalue)
     1687 	   = rtime_array.val (token.Nvalue)
     1688 	   + (convert (fld59, number) + fld59) * offset_sign;
     1689 	return;
     1690 
     1691 Emultiple_time_spec:
     1692 	lcode = error_table_$dt_multiple_time_spec;
     1693 	goto set_err_loc;
     1694 Emultiple_date_spec:
     1695 	lcode = error_table_$dt_multiple_date_spec;
     1696 	goto set_err_loc;
     1697 Emultiple_zone_spec:
     1698 	lcode = error_table_$dt_multiple_zone_spec;
     1699 	goto set_err_loc;
     1700 Emultiple_diw_spec:
     1701 	lcode = error_table_$dt_multiple_diw_spec;
     1702 	goto set_err_loc;
     1703 Ehr_gt_12:
     1704 	lcode = error_table_$dt_hour_gt_twelve;
     1705 	goto set_err_loc;
     1706 set_err_loc:
     1707 	err_pt = token.Pvalue;
     1708 	signal condition (semantic_error);
     1709 
     1710 	end Aday_and_LEX;



     1711 init_rtime: proc;
     1712 
     1713       if rtime_first
     1714       then do;
     1715          rtime_first = ""b;
     1716          if (rtime_ct = hbound (rspace, 1))
     1717          then goto Etoo_many_adverbs;
     1718          rtime_ct = rtime_ct + 1;
     1719          rtime_p = addr (rspace (rtime_ct).data);
     1720          rtime_array.version = Vtime_offset_2;
     1721       end;
     1722       rspace.rel_ct (rtime_ct) = rspace.rel_ct (rtime_ct) + 1;
     1723 
     1724    end init_rtime;
     1725 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1726 get_fraction:
     1727 get_number: proc returns (float dec (59));
     1728 
     1729 dcl number	char (token.Lvalue) based (token.Pvalue);
     1730 
     1731       return (convert (fld59, number));
     1732 
     1733    end get_number;



     1734 token_:	procedure (l, type, value);			/* procedure to fill in the next token of the	*/
     1735 						/*    token chain.				*/
     1736 
     1737 dcl l		fixed bin,	/* length of the new token.	       */
     1738     type		fixed bin,	/* type of the new token.	       */
     1739 				/*    0 = unknown		       */
     1740 				/*    1 = day name		       */
     1741 				/*      2=language name (unused)     */
     1742 				/*    2 = meridian (# borrowed)      */
     1743 				/*    3 = month name	       */
     1744 				/*    4 = offset		       */
     1745 				/*    5 = word		       */
     1746 				/*        1 = before	       */
     1747 				/*        2 = or		       */
     1748 				/*        3 = after		       */
     1749 				/*        4 = on		       */
     1750 				/*        5 = noon		       */
     1751 				/*        6 = midnight	       */
     1752 				/*        7 = now		       */
     1753 				/*        8 = yesterday	       */
     1754 				/*        9 = today		       */
     1755 				/*       10 = tomorrow	       */
     1756 				/*    6 = zone		       */
     1757 				/*    7 = "this"		       */
     1758 				/*    8 = number 		       */
     1759 				/*    9 = big number	       */
     1760 				/*   10 = fraction		       */
     1761 				/*   11 = and_fraction	       */
     1762 				/*   12 = other		       */
     1763     value		fixed bin(35);	/* numeric value of the token.       */
     1764 
     1765 	if Ntokens = dim(tokens,1) then goto Etoo_many_tokens;
     1766 					   	/* if there aren't enough tokens, then there are	*/
     1767 						/*    more tokens in input string than can be	*/
     1768 	Ntokens = Ntokens + 1;			/*    legal.				*/
     1769 	if Ntokens = 1 then do;			/* special case assignment of the first token.	*/
     1770 	     Ptoken = addr(tokens(Ntokens));
     1771 	     token.Plast = null;
     1772 	     end;
     1773 	else do;
     1774 	     token.Pnext = addr(tokens(Ntokens));
     1775 	     token.Pnext -> token.Plast = Ptoken;
     1776 	     Ptoken = token.Pnext;
     1777 	     end;
     1778 	token.Pnext = null;
     1779 	token.Pvalue = Pstr;
     1780 	token.Lvalue = l;
     1781 /****	The comment on token.Itoken_in_stmt is			       */
     1782 /****		"position of token within its statement."	       */
     1783 /****	But we have no statements, so we are using it for token type       */
     1784 	token.Itoken_in_stmt = type;
     1785 	token.Nvalue = value;
     1786 	token.Pstmt, token.Psemant = null;
     1787 	string (token.S) = ""b;
     1788 	Pstr = addcharno (Pstr, l);			/* skip to next token of input string.		*/
     1789 	Lstr = Lstr - l;
     1790        end token_;
  1     1 /* START OF*	time_value.incl.pl1 	  *  *  *  *  *  *  *  *   */
  1     2 
  1     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  1     4 /*							       */
  1     5 /* Name:  time_value.incl.pl1				       */
  1     6 /*							       */
  1     7 /*	This structure holds output from date_time_$from_clock	       */
  1     8 /*	                  and input to   date_time_$to_clock	       */
  1     9 /* (A clock value is a combination of a day portion and a time portion.      */
  1    10 /*  clock_days represents one part and clock_time the other.)	       */
  1    11 /*      to_clock accepts "day" (as opposed to "time") data only in certain   */
  1    12 /*  combinations.  This table shows with the *'s which fields may be present */
  1    13 /*  together.  All others must be zero.				       */
  1    14 /* +-1-+-2-+-3-+-4-+--------------+				       */
  1    15 /* | * | * |   |   |         year |    In cases 1, 2, & 4, if day_in_week is */
  1    16 /* | * |   |   |   |           mm |    present,  it is used to verify the    */
  1    17 /* | * |   |   |   |           dd |    value converted.		       */
  1    18 /* |   |   | * |   |  fiscal_week |    In case 3 it actually defines a day.  */
  1    19 /* |   |   |(*)|   |  day_in_week |    If not present, Monday is assumed.    */
  1    20 /* |   | * |   |   |  day_in_year |				       */
  1    21 /* |   |   |   | * | day_in_clock |				       */
  1    22 /* +-v-+-v-+-v-+-v-+--------------+				       */
  1    23 /*   |   |   |   +-- clock_days = day_in_calendar			       */
  1    24 /*   |   |   +------ clock_days = converted (fiscal_week,day_in_week)	       */
  1    25 /*   |   +---------- clock_days = converted (year,day_in_year)	       */
  1    26 /*   +-------------- clock_days = converted (year,mm,dd)		       */
  1    27 /*							       */
  1    28 /*    clock_time = converted (HH,MM,SS,UUUUUU)			       */
  1    29 /*							       */
  1    30 /* The zone adjustment may be in one of two forms:		       */
  1    31 /*    if zone^="" then zone_index = INDEX_IN_time_info_OF (zone);	       */
  1    32 /* 		[ERROR if not found]			       */
  1    33 /*    if zone="" & zone_index=0 then zone_index = time_defaults_$zone_index  */
  1    34 /* After these two steps, if zone_index=0, it is an ERROR.		       */
  1    35 /* The value in time_info_ of zone_delta (zone_index) is used to adjust      */
  1    36 /* clock_time.						       */
  1    37 /*							       */
  1    38 /* If leap_year^=0 it is an ERROR.  All values are range checked, e.g.       */
  1    39 /*   year<0 or year>9999.  Out-of-range is an ERROR.		       */
  1    40 /*							       */
  1    41 /*  Refer to time_offset_.incl.pl1 for the structure used to input data to   */
  1    42 /*  date_time_$offset_to_clock.				       */
  1    43 /*							       */
  1    44 /* Status							       */
  1    45 /*							       */
  1    46 /* 0) Created by:   J. Falksen - 06/20/78			       */
  1    47 /* 1) Updated:	jaf	 - 84-11-01 US & fw enlarged to bin(20)	       */
  1    48 /*							       */
  1    49 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  1    50 
  1    51 /*	 All values in this structure are zone adjusted, not GMT.	       */
  1    52 
  1    53 dcl 1 time_value		aligned based(Ptime_value),
  1    54       2 version	char (8),
  1    55       2 yc 	fixed bin,	/* Year part of date (eg, 1978)      */
  1    56       2 my 	fixed bin,	/* Month part of date (eg, 7= July)  */
  1    57       2 dm 	fixed bin,	/* Day of month part of date (eg, 4) */
  1    58       2 Hd 	fixed bin,	/* Hour of the day (eg, 18)	       */
  1    59       2 MH 	fixed bin,	/* Minute of the hour (eg, 35)       */
  1    60       2 SM 	fixed bin,	/* Second of the minute (eg, 59)     */
  1    61       2 US 	fixed bin (20),	/* Microseconds in excess of second  */
  1    62       2 fw	fixed bin (20),	/* the digits are yyyyww	 [OUT] */
  1    63       2 dw	fixed bin,	/* Day of the week (1=Mon, 7=Sun).   */
  1    64       2 dy	fixed bin,	/* Day of the year		       */
  1    65 				/*  (eg, 12/31 = 365 or 366).	       */
  1    66       2 dc	fixed bin(22),	/* Day in calendar value	       */
  1    67 				/*  (eg, 1 = Jan 1, 0001).	       */
  1    68       2 Uc	fixed bin(71),	/* Microsecond in calendar value     */
  1    69 				/*  (eg, 0 = 0001-01-01m)	       */
  1    70       2 za	char (5),		/* Zone abbreviation	       */
  1    71       2 zone_index	fixed bin,	/* Index in time_table_$zone_names,  */
  1    72 				/*  of zone in which time expressed  */
  1    73       2 leap_year	fixed bin,	/* 1- this is a leap year	 [OUT] */
  1    74 
  1    75      Ptime_value	ptr,
  1    76      Vtime_value_3	char(8) int static options(constant) init("timeval3");
  1    77 
  1    78 /* END OF*	time_value.incl.pl1	  *  *  *  *  *  *  *  *   */
     1791 
  2     1 /* BEGIN INCLUDE FILE ..... time_offset.incl.pl1 ..... 08/23/79 J Falksen */
  2     2 
  2     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  2     4 /*							       */
  2     5 /* Name:  time_offset.incl.pl1				       */
  2     6 /*							       */
  2     7 /* 1) This structure provides input to date_time_$offset_to_clock.	       */
  2     8 /*  Both integer and real fields may be supplied. Each field containing data */
  2     9 /*  must have its use bit set.  All values may be positive or negative.      */
  2    10 /*  a) dw is applied first.					       */
  2    11 /*  b) The size of a year is dependant upon WHICH year.  The base year is    */
  2    12 /*   determined.  The (adjusted) clock value is the reference for this.      */
  2    13 /*   The integral years (whether from fixed, float, or both) are added to    */
  2    14 /*   this base year.  The new base year is used to determine what value the  */
  2    15 /*   fraction is applied to.					       */
  2    16 /*  c) The size of a month is dependant upon WHICH month of WHICH year.      */
  2    17 /*   The base year/month is determined.  The (adjusted) clock value is the   */
  2    18 /*   reference for this.  The integral months are added to this base month,  */
  2    19 /*   forming a new base year/month.  The new base month in used to determine */
  2    20 /*   value the fraction is applied to.				       */
  2    21 /*  d) Values smaller than a month are added "in parallel" because their     */
  2    22 /*   size is always constant (leap-seconds ignored).		       */
  2    23 /*							       */
  2    24 /* 2) This structure receives output from date_time_$from_clock_interval.    */
  2    25 /*  time_offset.dw is not used.  The input values in val are ignored; they   */
  2    26 /*  are reset.  flag specifies the units in which the output is to be	       */
  2    27 /*  expressed and whether the fractional amount is desired. If only the      */
  2    28 /*  smallest unit is set to receive the fraction it leaves the structure in  */
  2    29 /*  a state that it may be given to $offset_to_clock without modification.   */
  2    30 /*							       */
  2    31 /* Status							       */
  2    32 /* 06/07/83 jaf 0) Created					       */
  2    33 /* 84-11-19 jaf 1) Changed the form of the dw field, added named constants   */
  2    34 /*							       */
  2    35 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  2    36 
  2    37 dcl 1 time_offset	aligned based(Ptime_offset),
  2    38       2 version	char (8),
  2    39       2 flag,
  2    40         3 yr	fixed bin,
  2    41         3 mo	fixed bin,
  2    42         3 wk	fixed bin,
  2    43         3 da	fixed bin,
  2    44         3 hr	fixed bin,
  2    45         3 min	fixed bin,
  2    46         3 sec	fixed bin,
  2    47         3 Usec	fixed bin,
  2    48       2 val,
  2    49         3 yr	float dec (20),	/* years			       */
  2    50         3 mo	float dec (20),	/* months			       */
  2    51         3 wk	float dec (20),	/* weeks			       */
  2    52         3 da	float dec (20),	/* days			       */
  2    53         3 hr	float dec (20),	/* hours			       */
  2    54         3 min	float dec (20),	/* minutes		       */
  2    55         3 sec	float dec (20),	/* seconds		       */
  2    56         3 Usec	float dec (20),	/* microseconds		       */
  2    57       2 dw,
  2    58         3 flag	fixed bin,	/* how to select day, if at all      */
  2    59         3 val	fixed bin;	/* Day of the week (1=Mon...7=Sun).  */
  2    60 
  2    61 /**** time_offset.flag settings for $offset_to_clock		       */
  2    62 dcl (UNUSED	init (0),	/* this offset unit is unused		       */
  2    63      USED		init (1), /* this offset unit has a value	       */
  2    64 /**** time_offset.flag settings for $from_clock_interval		       */
  2    65 /****UNUSED	init (0),	/* this offset unit is unused		       */
  2    66      INTEGER	init (1),	/* return interval unit as an integer	       */
  2    67      FRACTION	init (2),	/* return interval unit as integer+fraction    */
  2    68 /**** offset.dw.flag settings for $offset_to_clock. Tells how to select the  */
  2    69 			/* day given in offset.dw.val		       */
  2    70      BEFORE	init (-2),/*        before day given in clock_in	       */
  2    71      ON_OR_BEFORE	init (-1),/*  on or before day given in clock_in	       */
  2    72 /****UNUSED	init (0),	/*     don't apply day of week offset	       */
  2    73      ON_OR_AFTER	init (1),	/*  on or after  day given in clock_in	       */
  2    74      AFTER	init (2)	/*        after  day given in clock_in	       */
  2    75     )		fixed bin int static options (constant);
  2    76 
  2    77 dcl  Ptime_offset	ptr,
  2    78      Vtime_offset_2	char (8) int static options(constant) init("timeoff2");
  2    79 
  2    80 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  2    81 /*							       */
  2    82 /* Name:  time_offset_array_.incl.pl1				       */
  2    83 /*							       */
  2    84 /* This is an array form of time_offset.			       */
  2    85 /*							       */
  2    86 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  2    87 
  2    88 dcl 1 time_offset_array	aligned based(Ptime_offset),
  2    89     2 version		char (8),
  2    90     2 flag		(8) fixed bin,
  2    91     2 val			(8) float dec (20),
  2    92     2 dw,
  2    93       3 (flag, val) 	fixed bin;
  2    94 
  2    95 /* END INCLUDE FILE ..... time_offset.incl.pl1 ..... */
     1792 
  3     1 /* BEGIN INCLUDE FILE .... time_info_search.incl.pl1 .... 03/16/83 J Falksen */
  3     2 
  3     3 /* This include file describes an internal interface mainly used by	       */
  3     4 /* convert_date_to_binary_ to rapidly search the words in time_info_.	       */
  3     5 /* **	         USER PROGRAMS ARE NOT TO USE THIS TABLE.		    ** */
  3     6 
  3     7 dcl time_info_$tokens	fixed bin ext static;
  3     8 				/* reference point for token table   */
  3     9 
  3    10 dcl 1 ti_token based (ti_token_p),
  3    11       2 count		fixed bin,
  3    12       2 ambig		bit (1)aligned, /* 1- str does not have same   */
  3    13 				/* ..meaning in all languages	       */
  3    14       2 item (0 refer (ti_token.count)),
  3    15         3 symbol		char (32),/* canonical lowercase form	       */
  3    16         3 list_r		bit (18)aligned;
  3    17 /**** list_r is the offset of the item list which goes with symbol.  To      */
  3    18 /****  build a pointer to the list, use:			       */
  3    19 /****	addrel (addr (time_info_$version), ti_token.list_r (cur_token))    */
  3    20 
  3    21 
  3    22 dcl ti_token_p	ptr;		/* = addr (time_info_$tokens)	       */
  3    23 
  3    24 dcl item_p		ptr,
  3    25     1 item	based (item_p)unal,
  3    26       2 count	fixed bin aligned,	/* >1 => diff mean/diff lang	       */
  3    27       2 e		(0 refer (item.count)),
  3    28         3 ambig	bit (1),			/* 1-same mean/diff lang   */
  3    29         3 table	fixed bin (7) unsigned,	/* what table is this      */
  3    30         3 element	fixed bin (10) unsigned,	/* which element in table  */
  3    31         3 in_lang	bit (18);			/* languages using it      */
  3    32 
  3    33 
  3    34 /**** Note that this last element places a limit of 18 on the	       */
  3    35 /**** number of languages which may be defined in the table.	       */
  3    36 
  3    37 /* The table name values assigned here are as needed by CDTB	       */
  3    38 dcl (Day_table	init (1),
  3    39      Language_table	init (2),
  3    40      Month_table	init (3),
  3    41      Offset_table	init (4),
  3    42      Word_table	init (5),
  3    43      Zone_table	init (6),
  3    44      This_table	init (7)		/* resides in offset table	       */
  3    45      )		fixed bin int static options (constant);
  3    46 
  3    47 dcl mo_name	(12) char (3) int static options (constant) init (
  3    48  		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
  3    49  		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
  3    50 dcl da_name	(7) char (3) int static options (constant) init (
  3    51 		"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun");
  3    52 
  3    53 dcl the_offset_count fixed bin int static options (constant) init (8);
  3    54 dcl of_name	(8) char (12) int static options (constant) init (
  3    55 		"year",  "month",  "week",  "day",
  3    56 		"Hour", "Minute",  "Second",  "Microsecond");
  3    57 
  3    58 dcl the_word_count	fixed bin int static options (constant) init (13);
  3    59 dcl wo_name	(13) char (12) int static options (constant) init (
  3    60 		"Before", "Or", "After", "On", "Noon", "Midnight", "Now",
  3    61 		"Yesterday", "Today", "Tomorrow", "FiscalWeek",
  3    62 		"AM", "PM");
  3    63      
  3    64 
  3    65 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  3    66 /* NOTE TO MAINTAINER: Before changing this file, see the comments in	       */
  3    67 /*		        time_info_cds.incl.pl1		       */
  3    68 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  3    69 
  3    70 /* END INCLUDE FILE ..... time_info_search.incl.pl1 ..... */
     1793 
  4     1 	/* START OF:	time_names_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* Name:  time_names_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/* This include file defines the structure of values in the time_table_.  The table	*/
  4     8 	/* includes a list of time zones known to the system, as well as lists of month names	*/
  4     9 	/* and names of days of the week.  All names are expressed in several different languages */
  4    10 	/* to facilitate transliteration of dates into these languages.  The table includes	*/
  4    11 	/* the list of languages in which dates may be expressed.				*/
  4    12 	/*									*/
  4    13 	/* Status									*/
  4    14 	/*									*/
  4    15 	/* 0) Created  06/07/78:  J. Falksen						*/
  4    16 	/* 1) Modified 07/04/78:  G. Dixon						*/
  4    17 	/*									*/
  4    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    19 
  4    20 
  4    21 dcl time_info_$version	char (8) ext static;	/* Version number of all structures in the	*/
  4    22 						/* time_info_.  Currently = 1.		*/
  4    23 dcl Vtime_info_2		char (8) int static options(constant) init("tinfo002");




  4    24 
  4    25 dcl time_info_$gmt_zone_index fixed bin (17) ext static;
  4    26 dcl time_info_$default_language_index fixed bin (17) ext static;
  4    27 
  4    28 dcl time_info_$date_time_keywords fixed bin ext static;	/* Table of named date/time format strings	*/
  4    29 dcl 1 ti_keyword	based (addr (time_info_$date_time_keywords)),
  4    30       2 number_kwd		fixed bin,		/* number of keywords present		*/
  4    31       2 pad		fixed bin,
  4    32       2 e (0 refer (ti_keyword.number_kwd)),
  4    33         3 name		char (32),
  4    34         3 str		char (128)var;
  4    35 dcl (site_date	init (1),
  4    36      site_date_time init (2),
  4    37      site_time	init (3)
  4    38     )		fixed bin int static options (constant);
  4    39 
  4    40 dcl time_info_$language_names fixed bin ext static;	/* Table of language names, in various languages	*/
  4    41 
  4    42 dcl 1 ti_language	based (addr (time_info_$language_names)),
  4    43       2 number_lang		fixed bin,		/* number of language names present 		*/
  4    44       2 pad		fixed bin,
  4    45       2 name (0 refer (ti_language.number_lang), 0 refer (ti_language.number_lang))
  4    46 			char(32) varying;		/* Name of the language.			*/
  4    47 			/* All language names are expressed in all languages.  name(i,j) gives the	*/
  4    48 			/*  jth language name in language i.  name(i,i) gives a language name in its	*/
  4    49 			/*  own language.							*/




  4    50 dcl time_info_$month_names   fixed bin ext static;	/* Table of month  names in various languages. 	*/
  4    51 
  4    52 dcl 1 ti_month based (addr (time_info_$month_names)),
  4    53       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  4    54       2 pad		fixed bin,
  4    55       2 e (0 refer (ti_month.number_lang), 12),
  4    56         3 short       	char(8) var,		/* short form of a month name, i.e., Nov 	*/
  4    57         3 long        	char(32) var;		/* long form of a month name, i.e. November 	*/




  4    58 dcl time_info_$day_names     fixed bin ext static;	/* Table of day names in various languages.	*/
  4    59 
  4    60 dcl 1 ti_day based (addr (time_info_$day_names)),
  4    61       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  4    62       2 pad		fixed bin,
  4    63       2 e (0 refer (ti_day.number_lang), 7),
  4    64         3 short       	char(8) var,		/* short for of a day name, i.e. Sat 		*/
  4    65         3 long        	char(32) var;		/* long form of a day name, i.e. Saturday 	*/




  4    66 dcl time_info_$offset_names  fixed bin ext static;	/* Table of offset names in various languages.	*/
  4    67 
  4    68 dcl 1 ti_offset based (addr (time_info_$offset_names)),
  4    69       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  4    70       2 number_offset	fixed bin,
  4    71       2 e (0 refer (ti_offset.number_lang), 0 refer (ti_offset.number_offset)),
  4    72         3 short        	char(32) var,		/* short form of an offset name, i.e. min 	*/
  4    73         3 plural        	char(32) var,		/* plural form of an offset name, i.e. minutes 	*/
  4    74         3 singular       	char(32) var,		/* singular for of an offset name, i.e. minute	*/
  4    75         3 this		char(32) var;		/* "this" which goes with singular		*/




  4    76 dcl time_info_$word_names    fixed bin ext static;	/* Table of word names in various languages.	*/
  4    77 
  4    78 dcl 1 ti_word based (addr (time_info_$word_names)),
  4    79       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  4    80       2 number_word		fixed bin,
  4    81       2 short (0 refer (ti_word.number_lang), 0 refer (ti_word.number_word))
  4    82 			char (8) var,
  4    83       2 word (0 refer (ti_word.number_lang), 0 refer (ti_word.number_word))
  4    84 			char(32) var;		/* a "word", i.e. Midnight			*/
  4    85 
  4    86 dcl time_info_$zone_names    fixed bin ext static;	/* Table of known time zones.			*/
  4    87 
  4    88 dcl 1 ti_zone based (addr (time_info_$zone_names)),
  4    89       2 number_lang    	fixed bin,		/* number of languages in which zone names	*/
  4    90 						/* are defined.				*/
  4    91       2 number_zone       	fixed bin,		/* number of zone names in the table.		*/
  4    92       2 e (0 refer (ti_zone.number_lang), 0 refer (ti_zone.number_zone)),
  4    93         3 short		char(4) var,		/* short form of the zone name.		*/
  4    94         3 long        	char(64) var,		/* long form of the zone name 		*/
  4    95         3 pad		fixed bin,
  4    96         3 delta		fixed bin(71);		/* offset, in microseconds, of this time zone	*/
  4    97 						/* from GMT (Greenwich mean time).  This value	*/
  4    98 						/* should be subtracted from a clock value	*/
  4    99 						/* (which is expressed in GMT by definition).	*/
  4   100 						/* to obtain a date/time expressed in the	*/
  4   101 						/* named time zone.				*/
  4   102 						/* NOTE:  zones are listed in order of descending */
  4   103 						/* delta, from +11 to -12.  print_time_zones	*/
  4   104 						/* requires this.				*/
  4   105 
  4   106 
  4   107 dcl (tiw_FiscalIndicator init (11)
  4   108     )		fixed bin int static options (constant);
  4   109 
  4   110 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  4   111 /* NOTE TO MAINTAINER: Before changing this file, see the comments in	       */
  4   112 /*		        time_info_cds.incl.pl1		       */
  4   113 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  4   114 
  4   115 /* END OF:	time_names_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1794 
  5     1 /* BEGIN INCLUDE FILE ..... time_defaults_.incl.pl1 ..... 03/29/83 J Falksen */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-07-18,GDixon), approve(86-07-25,MCR7495),
  5     6*     audit(86-07-25,Martinson), install(86-08-19,MR12.0-1120):
  5     7*     Add declaration for time_defaults_$debug.
  5     8*                                                   END HISTORY COMMENTS */
  5     9 
  5    10 
  5    11 /* This include file defines the values in the time_default_ table.  This    */
  5    12 /*  table declares the name and index (in time_info_) of the user-specified, */
  5    13 /*  per-process default time language.  Also, the full name, acronym, index  */
  5    14 /*  and time delta (difference from GMT) of the default time zone. The       */
  5    15 /*  per-process date_time, date, and time format string are here also.       */
  5    16 
  5    17 /**** date_time_$format control strings				       */
  5    18    dcl time_defaults_$date_time	char (64)var ext static;
  5    19    dcl time_defaults_$date		char (64)var ext static;
  5    20    dcl time_defaults_$time		char (64)var ext static;
  5    21 
  5    22 /**** Name of default language in which dates are expressed.	       */
  5    23    dcl time_defaults_$language	char(32) ext static;
  5    24 
  5    25 /**** Value of ti_language_names.index for the default language.	       */
  5    26    dcl time_defaults_$language_index	fixed bin ext static;
  5    27 
  5    28 /**** full name of the default time zone.			       */
  5    29    dcl time_defaults_$zone_long	char(64) var ext static;
  5    30 
  5    31 /**** acronym for default time zone.				       */
  5    32   dcl time_defaults_$zone_short	char(4) var ext static;
  5    33 
  5    34 /**** offset, in microseconds, of default time zone from GMT	       */
  5    35   dcl time_defaults_$zone_delta	fixed bin(71) ext static;
  5    36 
  5    37 /**** index, in time_info_$zone_names, of the default time zone.	       */
  5    38   dcl time_defaults_$zone_index	fixed bin ext static;
  5    39 
  5    40 /**** debug switch controlling debugging within the date/time software.
  5    41*      Mainly of use in convert_date_to_binary_.			       */
  5    42   dcl time_defaults_$debug		bit(1) aligned ext static;
  5    43 
  5    44 /* END INCLUDE FILE ..... time_defaults_.incl.pl1 ..... */
     1795 
     1796 dcl com_err_	entry() options(variable);
     1797 
     1798 
     1799 
     1800      dcl	TRACING			bit(1) aligned int static init("0"b);
     1801 
     1802 
  6     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     4 	/*							*/
  6     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  6     6 	/*							*/
  6     7 	/*      This include segment is used by compilers generated by the	*/
  6     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  6     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  6    10 	/* compares a chain of input tokens with token requirements		*/
  6    11 	/* specified in reductions.  This include segment declares the 	*/
  6    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  6    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  6    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  6    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  6    16 	/*							*/
  6    17 	/* S__t_a_t_u_s							*/
  6    18 	/*							*/
  6    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  6    20 	/*							*/
  6    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    22 
  6    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  6    24 
  7     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  7     2 	
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     4 	/*							*/
  7     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  7     6 	/*							*/
  7     7 	/*      This include segment defines the structure of the token	*/
  7     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  7     9 	/* by the lex_string_ program.				*/
  7    10 	/*							*/
  7    11 	/* Status:						*/
  7    12 	/*							*/
  7    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  7    14 	/*							*/
  7    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7    16 	
  7    17 	
  7    18 	
  7    19 	
  7    20      dcl	
  7    21 	1 comment			aligned based (Pcomment),
  7    22 						/* descriptor for a comment.			*/
  7    23 	  2 group1		unaligned,
  7    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  7    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  7    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  7    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  7    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  7    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  7    30 	  2 group2		unaligned,
  7    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  7    32 	    3 S,					/* switches:				*/
  7    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  7    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  7    35 	      4 pad		bit(16),
  7    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  7    37 						/* body of comment.				*/
  7    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  7    39 	
  7    40      dcl	
  7    41 	1 stmt			aligned based (Pstmt),
  7    42 						/* descriptor for a statement.		*/
  7    43 	  2 group1		unaligned,
  7    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  7    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  7    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  7    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  7    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  7    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  7    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  7    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  7    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  7    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  7    54 	  2 group2		unaligned,
  7    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  7    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  7    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  7    58 						/* (the number includes this stmt.)		*/
  7    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  7    60 	    3 S,					/* switches:				*/
  7    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  7    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  7    63 	      4 pad		bit(34),
  7    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  7    65 						/* text of the statement.			*/
  7    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  7    67 	
  7    68      dcl	
  7    69 	1 token			aligned based (Ptoken),
  7    70 						/* descriptor for a token.			*/
  7    71 	  2 group1		unaligned,
  7    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  7    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  7    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  7    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  7    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  7    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  7    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  7    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  7    80 	  2 group2		unaligned,
  7    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  7    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  7    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  7    84 	    3 S,					/* switches:				*/
  7    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  7    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  7    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  7    88 						/* string (as doubled quotes on input.)		*/
  7    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  7    90 						/* string has been lexed into a token.		*/
  7    91 	      4 pad2		bit(32),
  7    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  7    93 						/* value of the token.			*/
  7    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  7    95 
  7    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  6    25 
  6    26 
  6    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    28 
  6    29 
  6    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  6    31 						/* semantics of the tokens in the input list.	*/
  6    32 
  6    33      dcl						/*	automatic variables			*/
  6    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  6    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  6    36 						/* compared to.				*/
  6    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  6    38 						/* compared to.				*/
  6    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  6    40 						/* with reduction tokens are being compared to.	*/
  6    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  6    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  6    43 	CODE			fixed bin(35),	/* an error code.				*/
  6    44 	I			fixed bin,	/* a do-group index.			*/
  6    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  6    46 						/* number character string.			*/
  6    47 
  6    48      dcl						/*	based variables			*/
  6    49 	1 RED			aligned based (PRED),
  6    50 						/* descriptor for reduction tokens are being 	*/
  6    51 						/* compared to.				*/
  6    52 	  2 TOKEN_REQD		unaligned,
  6    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  6    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  6    55 						/* with this reduction.			*/
  6    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  6    57 						/* a token requirement descriptor.		*/
  6    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  6    59 						/*  -1 = relative token requirement function;	*/
  6    60 						/*       TYPE = index of the particular token	*/
  6    61 						/*	      function in the token_fcn array.	*/
  6    62 						/*   0 = built-in token requirement function;	*/
  6    63 						/*       TYPE = as defined below.		*/
  6    64 						/*  >0 = absolute token requirement:		*/
  6    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  6    66 						/*       TYPE = length(TOKEN_REQD);		*/
  6    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  6    68 						/*   1 = compile test to see if input token 	*/
  6    69 						/*       chain is exhausted (<no-token>).	*/
  6    70 						/*   2 = compile test for any token value	*/
  6    71 						/*       (<any-token>).			*/
  6    72 						/*   3 = compile test for a PL/I identifier	*/
  6    73 						/*       (<name>) of 32 or fewer characters.	*/
  6    74 						/*   4 = compile test for token which is a	*/
  6    75 						/*       <decimal-integer>.			*/
  6    76 						/*   5 = compile test for token which is a single	*/
  6    77 						/*       backspace character (<BS>).		*/
  6    78 						/*   6 = compile test for a token which is a	*/
  6    79 						/*       <quoted-string>.			*/
  6    80 
  6    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  6    82 						/* overlay for an absolute token requirement	*/
  6    83 						/* descriptor.				*/
  6    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  6    85 						/* absolute token string assoc w/ descriptor.	*/
  6    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  6    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  6    88 						/* absolute token string which token is reqd	*/
  6    89 						/* to match in order for tokens which are	*/
  6    90 						/* "current" on the list to match the reduction.	*/
  6    91 
  6    92      dcl						/*	builtin functions			*/
  6    93          (addr, max, null, search, substr, verify)
  6    94 				builtin;
  6    95 
  6    96      dcl						/*	entries				*/
  6    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  6    98 
  6    99      dcl						/*	static variables			*/
  6   100 	BACKSPACE			char(1) aligned int static init ("");
  6   101 
  6   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
     1803 
     1804 
     1805      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
     1806 
     1807 
     1808      dcl	1 REDUCTION (53)		unaligned based (addr (REDUCTIONS)),
     1809 						/* object reductions.			*/
     1810 	  2 TOKEN_REQD,
     1811 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
     1812 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
     1813 
     1814 	REDUCTIONS  (106)		fixed bin(17) unaligned internal static options(constant) initial (
     1815 	         1,     1,	/*     1/  <no-token>                                                           */
     1816 	         2,     3,	/*     2/  <month_name> <day>                                                   */
     1817 	         4,     5,	/*     3/  <day> <month_name>                                                   */
     1818 	         6,    10,	/*     4/  <month> / <day> / <year>                                             */
     1819 	         6,     8,	/*     5/  <month> / <day>                                                      */
     1820 	        11,    15,	/*     6/  <year> - <month> - <day>                                             */
     1821 	        16,    17,	/*     7/  <fweek> <n>                                                          */
     1822 	        18,    20,	/*     8/  <N> <andfraction> <offset>                                           */
     1823 	        21,    22,	/*     9/  <n12> <andfraction6>                                                 */
     1824 	        23,    24,	/*    10/  <n> <andfraction>                                                    */
     1825 	        25,    27,	/*    11/  <hour> : <minute>                                                    */
     1826 	        28,    29,	/*    12/  <hour> <meridian>                                                    */
     1827 	        30,    31,	/*    13/  <twelve> <half_day>                                                  */
     1828 	        31,    31,	/*    14/  <half_day>                                                           */
     1829 	        32,    33,	/*    15/  <day_name> ,                                                         */
     1830 	        34,    35,	/*    16/  <day_name> <before_on_after>                                         */
     1831 	        32,    32,	/*    17/  <day_name>                                                           */
     1832 	        36,    38,	/*    18/  <sign> <N> <offset>                                                  */
     1833 	        37,    38,	/*    19/  <N> <offset>                                                         */
     1834 	        39,    42,	/*    20/  <sign> <N> <andfraction> <offset>                                    */
     1835 	        43,    44,	/*    21/  <fraction> <offset>                                                  */
     1836 	        45,    47,	/*    22/  <sign> <fraction> <offset>                                           */
     1837 	        48,    48,	/*    23/  <zone>                                                               */
     1838 	        49,    49,	/*    24/  <yesterday>                                                          */
     1839 	        50,    50,	/*    25/  <today>                                                              */
     1840 	        51,    51,	/*    26/  <tomorrow>                                                           */
     1841 	        52,    52,	/*    27/  <now>                                                                */
     1842 	        53,    52,	/*    28/                                                                       */
     1843 	        53,    54,	/*    29/  <before_after> <or>                                                  */
     1844 	        53,    53,	/*    30/  <before_after>                                                       */
     1845 	        55,    55,	/*    31/  <on>                                                                 */
     1846 	        56,    56,	/*    32/  <any-token>                                                          */
     1847 	         1,     1,	/*    33/  <no-token>                                                           */
     1848 	        57,    58,	/*    34/  <or> <before_after>                                                  */
     1849 	        59,    58,	/*    35/                                                                       */
     1850 	        59,    61,	/*    36/  : <second> <andfraction>                                             */
     1851 	        59,    60,	/*    37/  : <second>                                                           */
     1852 	        19,    19,	/*    38/  <andfraction>                                                        */
     1853 	        62,    61,	/*    39/                                                                       */
     1854 	        29,    29,	/*    40/  <meridian>                                                           */
     1855 	        62,    64,	/*    41/  <sign> <n4> <offset>                                                 */
     1856 	        65,    67,	/*    42/  <sign> <n4> <andfraction>                                            */
     1857 	        62,    63,	/*    43/  <sign> <n4>                                                          */
     1858 	        68,    67,	/*    44/                                                                       */
     1859 	        68,    69,	/*    45/  , <year>                                                             */
     1860 	        23,    24,	/*    46/  <n> <andfraction>                                                    */
     1861 	        70,    71,	/*    47/  <n> :                                                                */
     1862 	        72,    73,	/*    48/  <n> <meridian>                                                       */
     1863 	        30,    31,	/*    49/  <twelve> <half_day>                                                  */
     1864 	        74,    75,	/*    50/  <n> <offset>                                                         */
     1865 	         4,     5,	/*    51/  <day> <month_name>                                                   */
     1866 	        10,    10,	/*    52/  <year>                                                               */
     1867 	        76,    75);	/*    53/                                                                       */
     1868 
     1869      dcl	1 TOKEN_REQUIREMENT (75)	unaligned based (addr (TOKEN_REQUIREMENTS)),
     1870 						/* object token requirements.			*/
     1871 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
     1872 						/*  -1 = relative token requirement function;	*/
     1873 						/*       TYPE = index of the particular token	*/
     1874 						/*	      function in the token_fcn array.	*/
     1875 						/*   0 = built-in token requirement function;	*/
     1876 						/*       TYPE = as defined below.		*/
     1877 						/*  >0 = absolute token requirement:		*/
     1878 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
     1879 						/*       TYPE = length(TOKEN_REQD);		*/
     1880 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
     1881 						/* function:				*/
     1882 						/*   1 = compile test to see if input token 	*/
     1883 						/*       chain is exhausted (<no-token>).	*/
     1884 						/*   2 = compile test for any token value	*/
     1885 						/*       (<any-token>).			*/
     1886 						/*   3 = compile test for a PL/I identifier	*/
     1887 						/*       (<name>) of 32 or fewer characters.	*/
     1888 						/*   4 = compile test for token which is a	*/
     1889 						/*       <decimal-integer>.			*/
     1890 						/*   5 = compile test for token which is a single	*/
     1891 						/*       backspace character (<BS>).		*/
     1892 						/*   6 = compile test for a token which is a	*/
     1893 						/*       <quoted-string>.			*/
     1894 
     1895 	TOKEN_REQUIREMENTS  (150)	fixed bin(17) unaligned internal static options(constant) initial (
     1896 	         0,    1,      -1,    1,      -1,    2,      -1,    2,      -1,    1,      -1,    3,       1,    1,   
     1897 	        -1,    2,       1,    1,      -1,    4,      -1,    4,       2,    1,      -1,    3,       2,    1,   
     1898 	        -1,    2,      -1,    5,      -1,    6,      -1,    7,      -1,    8,      -1,    9,      -1,   10,   
     1899 	        -1,   11,      -1,    6,      -1,    8,      -1,   12,       3,    1,      -1,   13,      -1,   12,   
     1900 	        -1,   14,      -1,   15,      -1,   16,      -1,   17,       4,    1,      -1,   17,      -1,   18,   
     1901 	        -1,   19,      -1,    7,      -1,    9,      -1,   19,      -1,    7,      -1,    8,      -1,    9,   
     1902 	        -1,   20,      -1,    9,      -1,   19,      -1,   20,      -1,    9,      -1,   21,      -1,   22,   
     1903 	        -1,   23,      -1,   24,      -1,   25,      -1,   26,      -1,   27,      -1,   28,       0,    2,   
     1904 	        -1,   27,      -1,   26,       3,    1,      -1,   29,      -1,    8,      -1,   19,      -1,   30,   
     1905 	        -1,    9,      -1,   19,      -1,   30,      -1,    8,       4,    1,      -1,    4,      -1,    6,   
     1906 	         3,    1,      -1,    6,      -1,   14,      -1,    6,      -1,    9);
     1907 
     1908 
     1909      dcl	TOKEN_STRINGS		char(4) aligned based (addr (TOKEN_STRING_ARRAYS)),
     1910 						/* object token values.			*/
     1911 	TOKEN_STRING_ARRAYS (1)	char(100) aligned internal static options(constant) initial (
     1912 	     "/-:,");
     1913 
     1914 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  8     6*     old history comments:
  8     7*      0) Created: April, 1974 by G. C. Dixon
  8     8*      1) Modified: Feb, 1975  by G. C. Dixon
  8     9*         a) support for Version 2.0 of reduction_compiler.
  8    10*      2) Modified: Feb, 1981  by G. C. Dixon
  8    11*         a) support for Version  2.2 of reduction_compiler
  8    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  8    13*                        reductions command.
  8    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  8    15*     install(86-03-17,MR12.0-1032):
  8    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  8    17*     implemented to avoid references through a null pointer.  The two
  8    18*     accepted uses are:
  8    19*     
  8    20*        / <no-token>               / ... / ... \
  8    21*                    A
  8    22*                    |
  8    23*           Pthis_token (points to top of push down stack)
  8    24*     
  8    25*     which checks to see if the push down stack is totally exhausted (ie,
  8    26*     Ptoken = null); and:
  8    27*     
  8    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  8    29*                           A
  8    30*                           |
  8    31*                 Pthis_token (points to top of push down stack)
  8    32*     
  8    33*     which checks to see whether SPECN is topmost on the push down stack
  8    34*     AND is the final token in the input list.
  8    35*                                                   END HISTORY COMMENTS */
  8    36 
  8    37 
  8    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    39 	/*									*/
  8    40 	/* NAME:  rdc_end_.incl.pl1							*/
  8    41 	/*									*/
  8    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  8    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  8    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  8    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  8    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  8    47 	/*									*/
  8    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    49 
  8    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  8    51 						/*   options(constant) because it is never set.	*/
  8    52 	NRED = 1;
  8    53 	go to RD_TEST_REDUCTION;
  8    54 
  8    55 RD_NEXT_REDUCTION:
  8    56 	NRED = NRED + 1;
  8    57 
  8    58 RD_TEST_REDUCTION:
  8    59 	PRED = addr(REDUCTION(NRED));
  8    60 	Ptoken = Pthis_token;
  8    61 
  8    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  8    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  8    64 	     if Ptoken = null then do;
  8    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  8    66 		     if TOKEN_REQD.TYPE = 1 then
  8    67 			go to RD_TEST_TOKEN(1);
  8    68 		go to RD_NEXT_REDUCTION;
  8    69 		end;
  8    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  8    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  8    72 
  8    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  8    74 						/* In push-down-language, there are 2 		*/
  8    75 						/*   interpretations of <no-token>.		*/
  8    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  8    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  8    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  8    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  8    80 			   RED.TOKEN_REQD.IFIRST = I &
  8    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  8    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  8    83 						/*  and is SPECN the final input token?"	*/
  8    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  8    85 						/* down language mode for <no-token>.		*/
  8    86 		else if Ptoken = null then
  8    87 		     go to RD_MATCH_NO_TOKEN;
  8    88 		go to RD_NEXT_REDUCTION;
  8    89 
  8    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  8    91 
  8    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  8    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  8    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  8    95 		     > 0 then
  8    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  8    97 			= 0 then
  8    98 			     go to RD_MATCH;
  8    99 		go to RD_NEXT_REDUCTION;
  8   100 
  8   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  8   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  8   103 		     go to RD_MATCH;
  8   104 		if token.S.quoted_string then
  8   105 		     go to RD_NEXT_REDUCTION;
  8   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  8   107 		if CODE = 0 then do;
  8   108 		     token.Nvalue = NUMBER;
  8   109 		     go to RD_MATCH;
  8   110 		     end;
  8   111 		go to RD_NEXT_REDUCTION;
  8   112 
  8   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  8   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  8   115 			go to RD_MATCH;
  8   116 		go to RD_NEXT_REDUCTION;
  8   117 
  8   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  8   119 		     go to RD_MATCH;
  8   120 		go to RD_NEXT_REDUCTION;
  8   121 		end;
  8   122 
  8   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  8   124 		if token.S.quoted_string then
  8   125 		     go to RD_NEXT_REDUCTION;
  8   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  8   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  8   128 		if token_value = TOKEN_REQD_VALUE then
  8   129 		     go to RD_MATCH;
  8   130 		go to RD_NEXT_REDUCTION;
  8   131 		end;
  8   132 
  8   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1914 
     1915 
     1916 	     else do;				/* relative syntax function.			*/
     1917 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
     1918 
     1919 RD_TOKEN_FCN(1):	STOKEN_FCN = month_name();
     1920 		go to RD_TEST_RESULT;
     1921 RD_TOKEN_FCN(2):	STOKEN_FCN = day();
     1922 		go to RD_TEST_RESULT;
     1923 RD_TOKEN_FCN(3):	STOKEN_FCN = month();
     1924 		go to RD_TEST_RESULT;
     1925 RD_TOKEN_FCN(4):	STOKEN_FCN = year();
     1926 		go to RD_TEST_RESULT;
     1927 RD_TOKEN_FCN(5):	STOKEN_FCN = fweek();
     1928 		go to RD_TEST_RESULT;
     1929 RD_TOKEN_FCN(6):	STOKEN_FCN = n();
     1930 		go to RD_TEST_RESULT;
     1931 RD_TOKEN_FCN(7):	STOKEN_FCN = N();
     1932 		go to RD_TEST_RESULT;
     1933 RD_TOKEN_FCN(8):	STOKEN_FCN = andfraction();
     1934 		go to RD_TEST_RESULT;
     1935 RD_TOKEN_FCN(9):	STOKEN_FCN = offset();
     1936 		go to RD_TEST_RESULT;
     1937 RD_TOKEN_FCN(10):	STOKEN_FCN = n12();
     1938 		go to RD_TEST_RESULT;
     1939 RD_TOKEN_FCN(11):	STOKEN_FCN = andfraction6();
     1940 		go to RD_TEST_RESULT;
     1941 RD_TOKEN_FCN(12):	STOKEN_FCN = hour();
     1942 		go to RD_TEST_RESULT;
     1943 RD_TOKEN_FCN(13):	STOKEN_FCN = minute();
     1944 		go to RD_TEST_RESULT;
     1945 RD_TOKEN_FCN(14):	STOKEN_FCN = meridian();
     1946 		go to RD_TEST_RESULT;
     1947 RD_TOKEN_FCN(15):	STOKEN_FCN = twelve();
     1948 		go to RD_TEST_RESULT;
     1949 RD_TOKEN_FCN(16):	STOKEN_FCN = half_day();
     1950 		go to RD_TEST_RESULT;
     1951 RD_TOKEN_FCN(17):	STOKEN_FCN = day_name();
     1952 		go to RD_TEST_RESULT;
     1953 RD_TOKEN_FCN(18):	STOKEN_FCN = before_on_after();
     1954 		go to RD_TEST_RESULT;
     1955 RD_TOKEN_FCN(19):	STOKEN_FCN = sign();
     1956 		go to RD_TEST_RESULT;
     1957 RD_TOKEN_FCN(20):	STOKEN_FCN = fraction();
     1958 		go to RD_TEST_RESULT;
     1959 RD_TOKEN_FCN(21):	STOKEN_FCN = zone();
     1960 		go to RD_TEST_RESULT;
     1961 RD_TOKEN_FCN(22):	STOKEN_FCN = yesterday();
     1962 		go to RD_TEST_RESULT;
     1963 RD_TOKEN_FCN(23):	STOKEN_FCN = today();
     1964 		go to RD_TEST_RESULT;
     1965 RD_TOKEN_FCN(24):	STOKEN_FCN = tomorrow();
     1966 		go to RD_TEST_RESULT;
     1967 RD_TOKEN_FCN(25):	STOKEN_FCN = now();
     1968 		go to RD_TEST_RESULT;
     1969 RD_TOKEN_FCN(26):	STOKEN_FCN = before_after();
     1970 		go to RD_TEST_RESULT;
     1971 RD_TOKEN_FCN(27):	STOKEN_FCN = or();
     1972 		go to RD_TEST_RESULT;
     1973 RD_TOKEN_FCN(28):	STOKEN_FCN = on();
     1974 		go to RD_TEST_RESULT;
     1975 RD_TOKEN_FCN(29):	STOKEN_FCN = second();
     1976 		go to RD_TEST_RESULT;
     1977 RD_TOKEN_FCN(30):	STOKEN_FCN = n4();
     1978 		go to RD_TEST_RESULT;
     1979 
     1980 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
     1981 		else go to RD_NEXT_REDUCTION;
     1982 		end;
     1983 
     1984 RD_MATCH:      Ptoken = token.Pnext;
     1985 RD_MATCH_NO_TOKEN:
     1986 	     end;
     1987 	Ptoken = Pthis_token;
     1988 	go to RD_ACTION(NRED);
     1989 
     1990 
     1991 RD_ACTION(1):					/* /					*/
     1992 	return;					/* / RETURN	\			*/
     1993 
     1994 RD_ACTION(2):					/* /					*/
     1995 	call 					     SL ( 1 );
     1996 	call					     Amonth_and_LEX();
     1997 	call					     Aday_and_LEX();
     1998 	call					     SLe();
     1999 	NRED = 45;
     2000 	go to RD_TEST_REDUCTION;			/* / year \                            		*/
     2001 
     2002 RD_ACTION(3):					/* /					*/
     2003 	call 					     SL ( 2 );
     2004 	call					     Aday_and_LEX();
     2005 	call					     Amonth_and_LEX();
     2006 	call					     SLe();
     2007 	NRED = 46;
     2008 	go to RD_TEST_REDUCTION;			/* / year_ \                           		*/
     2009 
     2010 RD_ACTION(4):					/* /					*/
     2011 	call 					     SL ( 3 );
     2012 	call					     Amonth_and_LEX();
     2013 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2014 	call					     Aday_and_LEX();
     2015 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2016 	call					     Ayear_and_LEX();
     2017 	call					     SLe();
     2018 	NRED = 1;
     2019 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2020 
     2021 RD_ACTION(5):					/* /					*/
     2022 	call 					     SL ( 4 );
     2023 	call					     Amonth_and_LEX();
     2024 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2025 	call					     Aday_and_LEX();
     2026 	call					     Ayear_default();
     2027 	call					     SLe();
     2028 	NRED = 1;
     2029 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2030 
     2031 RD_ACTION(6):					/* /					*/
     2032 	call 					     SL ( 5 );
     2033 	call					     Ayear_and_LEX();
     2034 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2035 	call					     Amonth_and_LEX();
     2036 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2037 	call					     Aday_and_LEX();
     2038 	call					     SLe();
     2039 	NRED = 1;
     2040 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2041 
     2042 RD_ACTION(7):					/* /					*/
     2043 	call 					     SL ( 6 );
     2044 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2045 	call					     Afw();
     2046 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2047 	call					     SLe();
     2048 	NRED = 1;
     2049 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2050 
     2051 RD_ACTION(8):					/* /					*/
     2052 	call 					     SL ( 7 );
     2053 	call					     Afraction_offset();
     2054 	call 					     LEX ( 3 );
     2055 	call					     SLe();
     2056 	NRED = 1;
     2057 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2058 
     2059 RD_ACTION(9):					/* /					*/
     2060 	call 					     SL ( 8 );
     2061 	call					     Arequest_id();
     2062 	call 					     LEX ( 2 );
     2063 	call					     SLe();
     2064 	NRED = 1;
     2065 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2066 
     2067 RD_ACTION(10):					/* /					*/
     2068 	call 					     SL ( 9 );
     2069 	call					     Atime();
     2070 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2071 	call					     Aminute_fraction();
     2072 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2073 	call					     SLe();
     2074 	NRED = 41;
     2075 	go to RD_TEST_REDUCTION;			/* / zone_dif \                        		*/
     2076 
     2077 RD_ACTION(11):					/* /					*/
     2078 	call 					     SL ( 10 );
     2079 	call					     Ahour_and_LEX();
     2080 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2081 	call					     Aminute_and_LEX();
     2082 	call					     SLe();
     2083 	NRED = 36;
     2084 	go to RD_TEST_REDUCTION;			/* / second \                          		*/
     2085 
     2086 RD_ACTION(12):					/* /					*/
     2087 	call 					     SL ( 11 );
     2088 	call					     Ahour_and_LEX();
     2089 	call					     Ameridian();
     2090 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2091 	call					     Aminute_zero();
     2092 	call					     Asecond_zero();
     2093 	call					     SLe();
     2094 	NRED = 41;
     2095 	go to RD_TEST_REDUCTION;			/* / zone_dif \                        		*/
     2096 
     2097 RD_ACTION(13):					/* /					*/
     2098 	call 					     SL ( 12 );
     2099 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2100 	call					     Ahalf_day();
     2101 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2102 	call					     SLe();
     2103 	NRED = 41;
     2104 	go to RD_TEST_REDUCTION;			/* / zone_dif \                        		*/
     2105 
     2106 RD_ACTION(14):					/* /					*/
     2107 	call 					     SL ( 13 );
     2108 	call					     Ahalf_day();
     2109 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2110 	call					     SLe();
     2111 	NRED = 41;
     2112 	go to RD_TEST_REDUCTION;			/* / zone_dif \                        		*/
     2113 
     2114 RD_ACTION(15):					/* /					*/
     2115 	call 					     SL ( 14 );
     2116 	call					     Uday_of_week();
     2117 	call 					     LEX ( 2 );
     2118 	call					     SLe();
     2119 	NRED = 1;
     2120 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2121 
     2122 RD_ACTION(16):					/* /					*/
     2123 	call 					     SL ( 15 );
     2124 	call					     Uday_of_week();
     2125 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2126 	call					     Ab_o_a();
     2127 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2128 	call					     SLe();
     2129 	NRED = 34;
     2130 	go to RD_TEST_REDUCTION;			/* / adv_day \                         		*/
     2131 
     2132 RD_ACTION(17):					/* /					*/
     2133 	call 					     SL ( 16 );
     2134 	call					     Uday_of_week();
     2135 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2136 	call					     SLe();
     2137 	NRED = 1;
     2138 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2139 
     2140 RD_ACTION(18):					/* /					*/
     2141 	call 					     SL ( 17 );
     2142 	call					     apply_sign_and_offset();
     2143 	call 					     LEX ( 3 );
     2144 	call					     SLe();
     2145 	NRED = 1;
     2146 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2147 
     2148 RD_ACTION(19):					/* /					*/
     2149 	call 					     SL ( 18 );
     2150 	call					     apply_offset();
     2151 	call 					     LEX ( 2 );
     2152 	call					     SLe();
     2153 	NRED = 1;
     2154 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2155 
     2156 RD_ACTION(20):					/* /					*/
     2157 	call 					     SL ( 19 );
     2158 	call					     Afraction_sign_and_offset();
     2159 	call 					     LEX ( 4 );
     2160 	call					     SLe();
     2161 	NRED = 1;
     2162 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2163 
     2164 RD_ACTION(21):					/* /					*/
     2165 	call 					     SL ( 20 );
     2166 	call					     Afraction_offset();
     2167 	call 					     LEX ( 2 );
     2168 	call					     SLe();
     2169 	NRED = 1;
     2170 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2171 
     2172 RD_ACTION(22):					/* /					*/
     2173 	call 					     SL ( 21 );
     2174 	call					     Afraction_sign_and_offset();
     2175 	call 					     LEX ( 3 );
     2176 	call					     SLe();
     2177 	NRED = 1;
     2178 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2179 
     2180 RD_ACTION(23):					/* /					*/
     2181 	call 					     SL ( 22 );
     2182 	call					     Azone();
     2183 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2184 	call					     SLe();
     2185 	NRED = 1;
     2186 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2187 
     2188 RD_ACTION(24):					/* /					*/
     2189 	call 					     SL ( 23 );
     2190 	call					     Ayesterday();
     2191 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2192 	call					     SLe();
     2193 	NRED = 1;
     2194 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2195 
     2196 RD_ACTION(25):					/* /					*/
     2197 	call 					     SL ( 23 );
     2198 	call					     Atoday();
     2199 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2200 	call					     SLe();
     2201 	NRED = 1;
     2202 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2203 
     2204 RD_ACTION(26):					/* /					*/
     2205 	call 					     SL ( 23 );
     2206 	call					     Atomorrow();
     2207 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2208 	call					     SLe();
     2209 	NRED = 1;
     2210 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2211 
     2212 RD_ACTION(27):					/* /					*/
     2213 	call 					     SL ( 23 );
     2214 	call					     Anow();
     2215 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2216 	call					     SLe();
     2217 	NRED = 1;
     2218 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2219 
     2220 RD_ACTION(28):					/* /					*/
     2221 						     last_adverb = VWon;
     2222 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     2223 
     2224 RD_ACTION(29):					/* /					*/
     2225 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2226 						     err_pt = token.Pvalue;
     2227 						     details = """or"" can only be used with <day-name>.";
     2228 						     lcode = error_table_$dt_time_conversion_error;
     2229 	return;					/* / RETURN	\			*/
     2230 
     2231 RD_ACTION(30):					/* /					*/
     2232 	call 					     SL ( 24 );
     2233 	call					     Aadverb();
     2234 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2235 	call					     SLe();
     2236 	NRED = 1;
     2237 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2238 
     2239 RD_ACTION(31):					/* /					*/
     2240 						     err_pt = token.Pvalue;
     2241 						     details = """on"" can only be used with <day-name>.";
     2242 						     lcode = error_table_$dt_time_conversion_error;
     2243 	return;					/* / RETURN	\			*/
     2244 
     2245 RD_ACTION(32):					/* /					*/
     2246 						     err_pt = token.Pvalue;
     2247 						     lcode = error_table_$dt_time_conversion_error;
     2248 	return;					/* / RETURN	\			*/
     2249 
     2250 RD_ACTION(33):					/* /					*/
     2251 	return;					/* / RETURN	\			*/
     2252 
     2253 RD_ACTION(34):					/* /					*/
     2254 	call 					     SL ( 25 );
     2255 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2256 	call					     Ab_a();
     2257 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2258 	call					     SLe();
     2259 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     2260 
     2261 RD_ACTION(35):					/* /					*/
     2262 						     rtime_first = "1"b;
     2263 	NRED = 1;
     2264 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2265 
     2266 RD_ACTION(36):					/* /					*/
     2267 	call 					     SL ( 26 );
     2268 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2269 	call					     Asecond_and_LEX();
     2270 	call					     Asecond_fraction();
     2271 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2272 	call					     SLe();
     2273 	NRED = 40;
     2274 	go to RD_TEST_REDUCTION;			/* / meridian \                        		*/
     2275 
     2276 RD_ACTION(37):					/* /					*/
     2277 	call 					     SL ( 27 );
     2278 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2279 	call					     Asecond_and_LEX();
     2280 	call					     SLe();
     2281 	NRED = 40;
     2282 	go to RD_TEST_REDUCTION;			/* / meridian \                        		*/
     2283 
     2284 RD_ACTION(38):					/* /					*/
     2285 	call 					     SL ( 28 );
     2286 	call					     Aminute_fraction();
     2287 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2288 	call					     SLe();
     2289 	NRED = 40;
     2290 	go to RD_TEST_REDUCTION;			/* / meridian \                        		*/
     2291 
     2292 RD_ACTION(39):					/* /					*/
     2293 	call					     Asecond_zero();
     2294 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     2295 
     2296 RD_ACTION(40):					/* /					*/
     2297 	call 					     SL ( 29 );
     2298 	call					     Ameridian();
     2299 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2300 	call					     SLe();
     2301 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     2302 
     2303 RD_ACTION(41):					/* /					*/
     2304 	NRED = 18;
     2305 	go to RD_TEST_REDUCTION;			/* / num_off \                         		*/
     2306 
     2307 RD_ACTION(42):					/* /					*/
     2308 	NRED = 18;
     2309 	go to RD_TEST_REDUCTION;			/* / num_off \                         		*/
     2310 
     2311 RD_ACTION(43):					/* /					*/
     2312 	call 					     SL ( 30 );
     2313 						     SIGN = token_value;
     2314 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2315 	call					     Azone_dif();
     2316 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2317 	call					     SLe();
     2318 	NRED = 1;
     2319 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2320 
     2321 RD_ACTION(44):					/* /					*/
     2322 	NRED = 1;
     2323 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2324 
     2325 RD_ACTION(45):					/* /					*/
     2326 	call 					     SL ( 31 );
     2327 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     2328 	call					     Ayear_and_LEX();
     2329 	call					     SLe();
     2330 	NRED = 1;
     2331 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2332 
     2333 RD_ACTION(46):					/* /					*/
     2334 	call					     Ayear_default();
     2335 	NRED = 1;
     2336 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2337 
     2338 RD_ACTION(47):					/* /					*/
     2339 	call					     Ayear_default();
     2340 	NRED = 1;
     2341 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2342 
     2343 RD_ACTION(48):					/* /					*/
     2344 	call					     Ayear_default();
     2345 	NRED = 1;
     2346 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2347 
     2348 RD_ACTION(49):					/* /					*/
     2349 	call					     Ayear_default();
     2350 	NRED = 1;
     2351 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2352 
     2353 RD_ACTION(50):					/* /					*/
     2354 	call					     Ayear_default();
     2355 	NRED = 1;
     2356 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2357 
     2358 RD_ACTION(51):					/* /					*/
     2359 						     err_pt = token.Pvalue;
     2360 						     details = "<day> <month_name> already given.";
     2361 						     lcode = error_table_$dt_time_conversion_error;
     2362 	return;					/* / RETURN	\			*/
     2363 
     2364 RD_ACTION(52):					/* /					*/
     2365 	call 					     SL ( 32 );
     2366 	call					     Ayear_and_LEX();
     2367 	call					     SLe();
     2368 	NRED = 1;
     2369 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2370 
     2371 RD_ACTION(53):					/* /					*/
     2372 	call					     Ayear_default();
     2373 	NRED = 1;
     2374 	go to RD_TEST_REDUCTION;			/* / main \                            		*/
     2375 
     2376 
     2377 	end SEMANTIC_ANALYSIS;
     2378 
     2379 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     2380 
     2381      dcl	SPDL			bit(1) aligned init ("0"b);
     2382 						/* off: This compiler parses a non-PUSH DOWN	*/
     2383 						/*      LANGUAGE.				*/
     2384 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9     4 	/*									*/
  9     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  9     6 	/*									*/
  9     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  9     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  9     9 	/* "current" token, Pthis_token.						*/
  9    10 	/*									*/
  9    11 	/* E__n_t_r_y:  LEX								*/
  9    12 	/*									*/
  9    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  9    14 	/* _n is its positive (or negative) input argument.				*/
  9    15 	/*									*/
  9    16 	/* U__s_a_g_e									*/
  9    17 	/*									*/
  9    18 	/*      call LEX(n);							*/
  9    19 	/*									*/
  9    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  9    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  9    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  9    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  9    24 	/*									*/
  9    25 	/* S__t_a_t_u_s									*/
  9    26 	/*									*/
  9    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  9    28 	/*									*/
  9    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    30 
  9    31 LEX:	procedure (n);
  9    32 
  9    33      dcl	n			fixed bin,
  9    34 	i			fixed bin;
  9    35 
  9    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  9    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  9    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  9    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  9    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  9    41 		end;
  9    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  9    43 						/*   running off end of token list.		*/
  9    44 	     end;
  9    45 	else					/* new "current" token precedes present one.	*/
  9    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  9    47 		Ptoken = token.Plast;
  9    48 		end;
  9    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  9    50 
  9    51 	end LEX;
  9    52 
  9    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     2384 
     2385 
     2386 	end convert_date_to_binary_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  1037.4  convert_date_to_binary_.pl1       >special_ldd>install>MR12.3-1114>convert_date_to_binary_.pl1
1791         1    12/21/84  1239.8  time_value.incl.pl1               >ldd>include>time_value.incl.pl1
1792         2    12/21/84  1239.8  time_offset.incl.pl1              >ldd>include>time_offset.incl.pl1
1793         3    09/06/84  0850.2  time_info_search.incl.pl1         >ldd>include>time_info_search.incl.pl1
1794         4    09/06/84  0850.2  time_names.incl.pl1               >ldd>include>time_names.incl.pl1
1795         5    09/02/86  1552.9  time_defaults_.incl.pl1           >ldd>include>time_defaults_.incl.pl1
1803         6    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
6-25         7    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
1914         8    03/17/86  1534.3  rdc_end_.incl.pl1                 >ldd>include>rdc_end_.incl.pl1
2384         9    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AFTER                                  constant        fixed bin(17,0)          initial dcl 2-62 ref 1331
AZ                              000625 constant        char(26)                 initial packed unaligned dcl 990 ref 994
BACKSPACE                       012736 constant        char(1)                  initial dcl 6-99 ref 8-113
BEFORE                                 constant        fixed bin(17,0)          initial dcl 2-62 ref 1329
CODE                            010407 automatic       fixed bin(35,0)          dcl 6-33 set ref 8-106* 8-107
DIRECTION                       010412 automatic       fixed bin(17,0)          initial dcl 1805 set ref 8-62 1805*
Day_table                              constant        fixed bin(17,0)          initial dcl 3-38 ref 1023
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 346 ref 413 424 434 518
                                                                                  597 600 1294
FORM                                   based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-48 ref 8-65
                                                                                  8-70 8-123
Hd                        5     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 762 803 1546
Hd                        1(18)        based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1425
Hd                        5     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  623*
Hd                        5     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 762 762* 802
                                                                                  803* 1383 1384* 1386* 1395 1399* 1401* 1408 1409
                                                                                  1409* 1411* 1411 1420 1425* 1510 1511* 1545 1546*
I                               010410 automatic       fixed bin(17,0)          dcl 6-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  8-62* 8-63 8-79*
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  packed unaligned dcl 6-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 8-126
IFIRST                                 based           fixed bin(17,0)          level 3 packed packed unaligned dcl 6-48 ref 8-62
                                                                                  8-73 8-79 8-79
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 6-48 ref 8-62
                                                                                  8-73 8-79
Idelim_type                     000100 automatic       fixed bin(17,0)          dcl 253 set ref 557* 558
Isearch                         000101 automatic       fixed bin(17,0)          dcl 253 set ref 513* 514 514* 516 519 547* 548 548*
                                                                                  549
Itoken_in_stmt            7            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 7-68 set ref
                                                                                  1028 1033 1038 1052 1058 1200 1204 1222 1227 1233
                                                                                  1240 1240 1259 1283 1284 1662 1784*
Iverify                         000102 automatic       fixed bin(17,0)          dcl 253 set ref 564* 565 565* 566 567 570* 571 572
                                                                                  590* 591 592
L                         0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-48 ref 8-127
LTOKEN_REQD_VALUE               010376 automatic       fixed bin(18,0)          dcl 6-33 set ref 8-127* 8-128
Lnumber_in_str                  000103 automatic       fixed bin(17,0)          dcl 253 set ref 571* 572* 575 577 577 591* 592* 594*
                                                                                  595 595*
Lstr                            000105 automatic       fixed bin(17,0)          dcl 253 set ref 489* 511 513 514 547 548 554 564 565
                                                                                  567* 567 570 571 579 581 587 590 591 728* 1789*
                                                                                  1789
Lvalue                    4            based           fixed bin(18,0)          level 2 dcl 7-68 set ref 934 934 1038 1233 1240 1267
                                                                                  1267 1370 1370 1447 1584 1604 1613 1627 1652 1731
                                                                                  1780* 8-92 8-92 8-92 8-92 8-106 8-106 8-113 8-113
                                                                                  8-128 2313
Lword_in_str                    000104 automatic       fixed bin(17,0)          dcl 253 set ref 519* 521 523 523 535 535 539 539 549
MH                        6     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 763 804 1547
MH                        6     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  623*
MH                        6     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 763 763* 804*
                                                                                  1387* 1426* 1462* 1464* 1471* 1512* 1547*
MH                        2            based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1426
Month_table                            constant        fixed bin(17,0)          initial dcl 3-38 ref 1193
NRED                            010377 automatic       fixed bin(17,0)          dcl 6-33 set ref 8-52* 8-55* 8-55 8-58 1988 1999*
                                                                                  2007* 2018* 2028* 2039* 2048* 2056* 2064* 2074*
                                                                                  2083* 2094* 2103* 2111* 2119* 2129* 2137* 2145*
                                                                                  2153* 2161* 2169* 2177* 2185* 2193* 2201* 2209*
                                                                                  2217* 2236* 2263* 2273* 2281* 2289* 2303* 2307*
                                                                                  2318* 2321* 2330* 2335* 2340* 2345* 2350* 2355*
                                                                                  2368* 2373*
NUMBER                          010411 automatic       fixed bin(35,0)          dcl 6-33 set ref 8-106* 8-108
Ntokens                         000106 automatic       fixed bin(17,0)          dcl 253 set ref 491* 607 1765 1768* 1768 1769 1770
                                                                                  1774
Nvalue                   10            based           fixed bin(35,0)          level 3 packed packed unaligned dcl 7-68 set ref
                                                                                  1052 1052 1052 1067* 1072* 1077* 1200 1213* 1259
                                                                                  1289* 1315 1329 1331 1334 1337 1352 1355 1357 1372
                                                                                  1384 1401 1411 1464 1483 1496 1511 1512 1534 1583
                                                                                  1605 1621 1637 1665 1685 1686 1686 1785* 8-101
                                                                                  8-108*
ON_OR_AFTER                            constant        fixed bin(17,0)          initial dcl 2-62 ref 1357
ON_OR_BEFORE                           constant        fixed bin(17,0)          initial dcl 2-62 ref 1355
Offset_table                           constant        fixed bin(17,0)          initial dcl 3-38 ref 1200 1208 1247
PRED                            010400 automatic       pointer                  dcl 6-33 set ref 8-58* 8-62 8-62 8-73 8-73 8-79 8-79
                                                                                  8-79
PTOKEN_REQD                     010402 automatic       pointer                  dcl 6-33 set ref 8-63* 8-65 8-65 8-70 8-71 8-123
                                                                                  8-126 8-127 1917
PTOKEN_REQD_VALUE               010404 automatic       pointer                  dcl 6-33 set ref 8-126* 8-128
Pfirst_token                    010234 automatic       pointer                  dcl 918 set ref 444* 702 924* 933 937*
Plast                     2            based           pointer                  level 2 packed packed unaligned dcl 7-68 set ref
                                                                                  1771* 1775* 9-45 9-47
Pnext                     1            based           pointer                  level 2 packed packed unaligned dcl 7-68 set ref 935
                                                                                  1197 1199 1629 1654 1672 1681 1774* 1775 1776
                                                                                  1778* 8-79 1984 2013 2015 2024 2034 2036 2044 2046
                                                                                  2070 2072 2080 2090 2099 2101 2109 2125 2127 2135
                                                                                  2183 2191 2199 2207 2215 2224 2234 2255 2257 2268
                                                                                  2271 2278 2287 2299 2314 2316 2327 9-39 9-40
Psemant                   6            based           pointer                  level 2 packed packed unaligned dcl 7-68 set ref
                                                                                  542* 1060 1206 1281 1786*
Pstmt                     5            based           pointer                  level 2 packed packed unaligned dcl 7-68 set ref
                                                                                  1786*
Pstr                            000110 automatic       pointer                  dcl 253 set ref 488* 513 521 523 535 535 539 539 547
                                                                                  557 564 566* 566 570 575 577 577 581 590 870 1779
                                                                                  1788* 1788
Pthis_token                     010242 automatic       pointer                  dcl 6-23 set ref 653* 933 938 8-60 1987 2013 2013*
                                                                                  2015 2015* 2024 2024* 2034 2034* 2036 2036* 2044
                                                                                  2044* 2046 2046* 2070 2070* 2072 2072* 2080 2080*
                                                                                  2090 2090* 2099 2099* 2101 2101* 2109 2109* 2125
                                                                                  2125* 2127 2127* 2135 2135* 2183 2183* 2191 2191*
                                                                                  2199 2199* 2207 2207* 2215 2215* 2224 2224* 2234
                                                                                  2234* 2255 2255* 2257 2257* 2268 2268* 2271 2271*
                                                                                  2278 2278* 2287 2287* 2299 2299* 2314 2314* 2316
                                                                                  2316* 2327 2327* 9-36 9-49*
Ptoken                          010244 automatic       pointer                  dcl 7-68 set ref 542 865 924 933* 933 933* 934 934
                                                                                  934* 935 938* 1028 1033 1038 1038 1038 1052 1052
                                                                                  1052 1052 1058 1060 1067 1072 1077 1197 1199* 1199
                                                                                  1200 1200 1204 1206 1213 1222 1227 1233 1233 1233
                                                                                  1240 1240 1240 1240 1259 1259 1267 1267 1267 1267
                                                                                  1281 1283 1284 1289 1315 1326 1329 1331 1334 1337
                                                                                  1347 1352 1355 1357 1370 1370 1370 1370 1372 1377
                                                                                  1384 1401 1411 1422 1423 1424 1425 1426 1427 1428
                                                                                  1447 1447 1464 1483 1496 1511 1512 1534 1583 1584
                                                                                  1584 1604 1604 1605 1613 1613 1621 1627 1627 1629*
                                                                                  1629 1637 1652 1652 1654* 1654 1662 1665 1672*
                                                                                  1672 1681* 1681 1685 1686 1686 1706 1731 1731
                                                                                  1770* 1771 1774 1775 1775 1776* 1776 1778 1779
                                                                                  1780 1784 1785 1786 1786 1787 8-60* 8-64 8-73 8-79
                                                                                  8-86 8-92 8-92 8-92 8-92 8-92 8-92 8-92 8-101
                                                                                  8-104 8-106 8-106 8-106 8-108 8-113 8-113 8-113
                                                                                  8-113 8-118 8-124 8-128 8-128 1984* 1984 1987*
                                                                                  2013* 2015* 2024* 2034* 2036* 2044* 2046* 2070*
                                                                                  2072* 2080* 2090* 2099* 2101* 2109* 2125* 2127*
                                                                                  2135* 2183* 2191* 2199* 2207* 2215* 2224* 2226
                                                                                  2234* 2239 2245 2255* 2257* 2268* 2271* 2278*
                                                                                  2287* 2299* 2313 2313 2314* 2316* 2327* 2358 9-36*
                                                                                  9-37 9-39 9-40* 9-40 9-42* 9-45 9-47* 9-47 9-49
Pvalue                    3            based           pointer                  level 2 packed packed unaligned dcl 7-68 set ref 865
                                                                                  934 1038 1233 1240 1267 1267 1326 1347 1370 1370
                                                                                  1377 1422 1423 1424 1425 1426 1427 1428 1447 1584
                                                                                  1604 1613 1627 1652 1706 1731 1779* 8-92 8-92
                                                                                  8-106 8-113 8-128 2226 2239 2245 2313 2358
RED                                    based           structure                level 1 dcl 6-48
REDUCTION                              based           structure                array level 1 packed packed unaligned dcl 1808 set
                                                                                  ref 8-58
REDUCTIONS                      000540 constant        fixed bin(17,0)          initial array packed unaligned dcl 1808 set ref 8-58
S                        11            based           structure                level 3 packed packed unaligned dcl 7-68 set ref
                                                                                  1787*
SIGN                            000112 automatic       char(1)                  packed unaligned dcl 253 set ref 1613 2313*
SLtext                          000004 constant        structure                level 1 packed packed unaligned dcl 942 ref 925 925
SM                        2(18)        based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1427
SM                        7     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 764 764* 805*
                                                                                  1388* 1427* 1447* 1451* 1452 1494* 1496* 1504*
                                                                                  1548*
SM                        7     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 764 805 1548
SM                        7     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  623*
SPDL                            010246 automatic       bit(1)                   initial dcl 2381 set ref 2381* 8-73 9-42
STOKEN_FCN                      010406 automatic       bit(1)                   dcl 6-33 set ref 1919* 1921* 1923* 1925* 1927* 1929*
                                                                                  1931* 1933* 1935* 1937* 1939* 1941* 1943* 1945*
                                                                                  1947* 1949* 1951* 1953* 1955* 1957* 1959* 1961*
                                                                                  1963* 1965* 1967* 1969* 1971* 1973* 1975* 1977*
                                                                                  1980
Sspace_encountered              000113 automatic       bit(1)                   dcl 253 set ref 510* 518* 563* 597* 600*
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed packed unaligned
                                                                                  dcl 6-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 1 dcl 6-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 6-48
TOKEN_REQD_VALUE                       based           char                     packed unaligned dcl 6-48 ref 8-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed packed unaligned dcl 1869 set
                                                                                  ref 8-63
TOKEN_REQUIREMENTS              000425 constant        fixed bin(17,0)          initial array packed unaligned dcl 1869 set ref 8-63
TOKEN_STRINGS                          based           char(4)                  dcl 1909 set ref 8-126
TOKEN_STRING_ARRAYS             000374 constant        char(100)                initial array dcl 1909 set ref 8-126
TRACING                         000014 internal static bit(1)                   initial dcl 1800 set ref 8-50* 8-50
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 346 ref 433 510 563 742
                                                                                  1296
TTandfraction                          constant        fixed bin(17,0)          initial dcl 346 ref 583 1033 1038
TTbignum                               constant        fixed bin(17,0)          initial dcl 346 ref 502 1222 1240
TTfraction                             constant        fixed bin(17,0)          initial dcl 346 ref 586 1028 1662
TTnumber                               constant        fixed bin(17,0)          initial dcl 346 ref 573 1227 1233 1240 1259
TTother                                constant        fixed bin(17,0)          initial dcl 346 set ref 602*
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-48 ref 8-65
                                                                                  8-71 1917
This_table                             constant        fixed bin(17,0)          initial dcl 3-38 ref 528 1253
Ttoken                          000650 constant        fixed bin(17,0)          initial array dcl 346 ref 557
Tunknown                               constant        fixed bin(17,0)          initial dcl 346 set ref 535* 1058 1204 1284
Twhich1                         000100 automatic       fixed bin(17,0)          dcl 1298 set ref 1023* 1043* 1049* 1052 1065 1067
                                                                                  1086* 1092* 1097* 1106* 1109* 1113* 1117* 1121*
                                                                                  1125* 1129* 1135* 1144* 1153* 1162* 1171* 1180*
                                                                                  1190* 1193* 1200 1211 1213 1247* 1253* 1273* 1283
                                                                                  1286
Twhich2                         000101 automatic       fixed bin(17,0)          dcl 1298 set ref 1043* 1050* 1052 1070 1072 1087*
                                                                                  1092* 1098* 1107* 1109* 1113* 1117* 1121* 1125*
                                                                                  1129*
Twhich3                         000102 automatic       fixed bin(17,0)          dcl 1298 set ref 1043* 1050* 1052 1075 1077 1087*
                                                                                  1092* 1099* 1107* 1109* 1113* 1117* 1121* 1125*
                                                                                  1129*
Type                            010232 automatic       fixed bin(17,0)          dcl 346 set ref 502* 526* 528 539* 573* 577* 583*
                                                                                  586* 595*
UNUSED                                 constant        fixed bin(17,0)          initial dcl 2-62 ref 739 843 851 851 1359 1359 1522
US                       10     000314 automatic       fixed bin(20,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 806 1549
US                       10     000270 automatic       fixed bin(20,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  623*
US                        3(09)        based           char(6)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1428
US                       10     000220 automatic       fixed bin(20,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 806* 1389* 1428*
                                                                                  1441* 1447* 1450* 1451 1452* 1452 1498* 1505*
                                                                                  1549*
USED                                   constant        fixed bin(17,0)          initial dcl 2-62 ref 755 835 1685
VOday                                  constant        fixed bin(17,0)          initial dcl 346 ref 1135
VOhour                                 constant        fixed bin(17,0)          initial dcl 346 ref 1162
VOminute                               constant        fixed bin(17,0)          initial dcl 346 ref 1171
VOmonth                                constant        fixed bin(17,0)          initial dcl 346 ref 1144 1190
VOsecond                               constant        fixed bin(17,0)          initial dcl 346 ref 1180
VOyear                                 constant        fixed bin(17,0)          initial dcl 346 ref 1153
VWafter                                constant        fixed bin(17,0)          initial dcl 346 ref 1099 1107 1331 1357
VWam                                   constant        fixed bin(17,0)          initial dcl 346 ref 1086
VWbefore                               constant        fixed bin(17,0)          initial dcl 346 ref 1097 1106 1329 1355 1534
VWfw                                   constant        fixed bin(17,0)          initial dcl 346 ref 1043
VWmidnight                             constant        fixed bin(17,0)          initial dcl 346 ref 1050
VWnoon                                 constant        fixed bin(17,0)          initial dcl 346 ref 1049 1384
VWnow                                  constant        fixed bin(17,0)          initial dcl 346 ref 1113
VWon                                   constant        fixed bin(17,0)          initial dcl 346 ref 1092 1098 1104 1109 1334 1352
                                                                                  2220
VWor                                   constant        fixed bin(17,0)          initial dcl 346 ref 1117
VWpm                                   constant        fixed bin(17,0)          initial dcl 346 ref 1087 1411
VWtoday                                constant        fixed bin(17,0)          initial dcl 346 ref 1121
VWtomorrow                             constant        fixed bin(17,0)          initial dcl 346 ref 1125
VWyesterday                            constant        fixed bin(17,0)          initial dcl 346 ref 1129
Value                           010233 automatic       fixed bin(35,0)          dcl 346 set ref 527* 539*
Vtime_offset_2                  000644 constant        char(8)                  initial packed unaligned dcl 2-77 ref 629 1720
Vtime_value_3                   000646 constant        char(8)                  initial packed unaligned dcl 1-53 ref 621
Word_table                             constant        fixed bin(17,0)          initial dcl 3-38 ref 1052 1062
Zone_table                             constant        fixed bin(17,0)          initial dcl 3-38 ref 1273
a_clock                         000114 automatic       fixed bin(71,0)          dcl 253 set ref 901* 907
addcharno                                              builtin function         dcl 330 ref 566 1788
addr                                                   builtin function         dcl 330 in procedure "convert_date_to_binary_" ref
                                                                                  449 452 488 628 639 644 653 706 738 748 748 769
                                                                                  769 784 784 814 814 822 822 844 844 851 851 1001
                                                                                  1719 1770 1774
addr                                                   builtin function         dcl 6-92 in procedure "SEMANTIC_ANALYSIS" ref 8-58
                                                                                  8-58 8-63 8-63 8-126 8-126
addrel                                                 builtin function         dcl 330 ref 1001
ambig_sw                        000116 automatic       bit(1)                   packed unaligned dcl 253 set ref 450* 536* 644 662
                                                                                  665
analyze_sw                      000117 automatic       bit(1)                   packed unaligned dcl 253 set ref 413* 424* 433* 732
arg                                    based           char                     packed unaligned dcl 911 set ref 901* 904*
arg_l                           010274 automatic       fixed bin(21,0)          dcl 911 set ref 897* 901 901 904 904
arg_p                           010276 automatic       pointer                  dcl 911 set ref 897* 901 904
atime                           000220 automatic       structure                level 1 unaligned dcl 299 set ref 648* 673 677 720*
                                                                                  734 814 814 822 822 844 844 1528
atime_h                         000244 automatic       structure                level 1 unaligned dcl 299 set ref 618* 673* 677 720
atime_init                      000270 automatic       structure                level 1 unaligned dcl 299 set ref 620* 625 648 734
                                                                                  768 783 1528
az                              000634 constant        char(26)                 initial packed unaligned dcl 990 ref 994
char                                                   builtin function         dcl 330 ref 861
charno                                                 builtin function         dcl 330 ref 706 706
clock                                                  builtin function         dcl 330 ref 416 898
clock_now                       000120 automatic       fixed bin(71,0)          dcl 253 set ref 414* 416* 425* 427* 435* 437* 608
                                                                                  748* 769 784 817 830
clock_out                              parameter       fixed bin(71,0)          dcl 243 set ref 240 422 431 608* 814* 817 822* 830
                                                                                  838* 838 844* 851* 851*
code                            010300 automatic       fixed bin(35,0)          dcl 911 in begin block on line 896 set ref 897* 898
                                                                                  901* 902 904*
code                                   parameter       fixed bin(35,0)          dcl 243 in procedure "convert_date_to_binary_" set
                                                                                  ref 240 422 431 451* 692* 748* 769* 784* 814* 815
                                                                                  822* 828 842 844* 847* 851*
com_err_                        000076 constant        entry                    external dcl 1796 ref 708 904
constant_clock                  000012 internal static fixed bin(71,0)          dcl 886 set ref 414 425 435 898* 907*
constant_sw                     000010 internal static bit(1)                   initial packed unaligned dcl 885 set ref 414 425 435
                                                                                  890* 909*
conversion                      010210 stack reference condition                dcl 337 ref 492 606
convert                                                builtin function         dcl 330 ref 575 1686 1731
copy                                                   builtin function         dcl 330 ref 449
count                                  based           fixed bin(17,0)          level 2 in structure "ti_token" dcl 3-10
                                                                                  in procedure "convert_date_to_binary_" ref 998
count                                  based           fixed bin(17,0)          level 2 in structure "item" dcl 3-24 in procedure
                                                                                  "convert_date_to_binary_" ref 528 531 1061 1207
                                                                                  1285
ctime                           000314 automatic       structure                level 1 unaligned dcl 299 set ref 625* 748 748
cu_$arg_ptr                     000100 constant        entry                    external dcl 911 ref 897
cur_token                       010331 automatic       fixed bin(17,0)          dcl 989 set ref 1000* 1001 1001 1004 1004 1006
cv_dec_check_                   000102 constant        entry                    external dcl 6-96 ref 8-106
da                       34            based           float dec(20)            level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 756* 756
da                        5            based           fixed bin(17,0)          level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 755*
data                      2     005270 automatic       structure                array level 2 in structure "rspace_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref 628
data                      2     006250 automatic       structure                array level 2 in structure "rspace" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref 738
                                                                                  851 851 1719
date_given                      000122 automatic       bit(1)                   packed unaligned dcl 253 set ref 729* 753* 795* 817
                                                                                  838
date_time_$from_clock           000016 constant        entry                    external dcl 337 ref 748 769 784 844
date_time_$offset_to_clock      000022 constant        entry                    external dcl 337 ref 851
date_time_$to_clock             000020 constant        entry                    external dcl 337 ref 814 822
details                         000123 automatic       varying char(64)         dcl 253 set ref 443* 708 708* 861* 1324* 1345* 1518*
                                                                                  1524* 1530* 2227* 2241* 2360*
dim                                                    builtin function         dcl 330 ref 631 1765
divide                                                 builtin function         dcl 330 ref 1000 1451 1511
dm                        4     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 761 761* 773*
                                                                                  779* 788* 793* 1309 1313* 1315* 1369* 1424* 1553
                                                                                  1556* 1560 1563* 1567 1570*
dm                        4     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 761 779 793
dm                        4     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  622*
dm                        4     000340 automatic       fixed bin(17,0)          level 2 in structure "ttime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 773 788
dm                        1            based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1424
done                            000144 automatic       bit(1)                   packed unaligned dcl 253 set ref 638* 662* 686 686
dow_given                       000145 automatic       bit(1)                   packed unaligned dcl 253 set ref 729*
dw                       74     006250 automatic       structure                array level 3 in structure "rspace" dcl 299
                                                                                  in procedure "convert_date_to_binary_"
dw                       12     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 659* 725 726*
                                                                                  749* 815 820* 826* 845
dw                       72            based           structure                level 2 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_"
dw                       12     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 756
dw_required               1     006250 automatic       fixed bin(17,0)          array level 2 dcl 299 set ref 824* 843 845 1334*
                                                                                  1359*
e                         1            based           structure                array level 2 packed packed unaligned dcl 3-24
elem                            000103 automatic       fixed bin(17,0)          dcl 1298 set ref 1061* 1062 1062 1065 1070 1075*
                                                                                  1207* 1208 1208 1211* 1285* 1286 1286 1289*
element                   1(08)        based           fixed bin(10,0)          array level 3 packed packed unsigned unaligned
                                                                                  dcl 3-24 ref 527 1065 1070 1075 1211 1289
err_pt                          000150 automatic       pointer                  dcl 253 set ref 444* 655* 706 706 865* 870* 1326*
                                                                                  1347* 1377* 1706* 2226* 2239* 2245* 2358*
errloc                          000146 automatic       fixed bin(24,0)          dcl 253 set ref 442* 654* 706* 708 708*
error_table_$bad_conversion     000026 external static fixed bin(35,0)          dcl 395 ref 494
error_table_$dt_ambiguous_time  000030 external static fixed bin(35,0)          dcl 395 ref 614
error_table_$dt_bad_day_of_week 000032 external static fixed bin(35,0)          dcl 395 ref 815 847
error_table_$dt_bad_fw          000034 external static fixed bin(35,0)          dcl 395 ref 1376
error_table_$dt_hour_gt_twelve  000036 external static fixed bin(35,0)          dcl 395 ref 1703
error_table_$dt_multiple_date_spec
                                000042 external static fixed bin(35,0)          dcl 395 ref 1694
error_table_$dt_multiple_diw_spec
                                000044 external static fixed bin(35,0)          dcl 395 ref 1700
error_table_$dt_multiple_meaning
                                000040 external static fixed bin(35,0)          dcl 395 ref 680
error_table_$dt_multiple_time_spec
                                000046 external static fixed bin(35,0)          dcl 395 ref 1691
error_table_$dt_multiple_zone_spec
                                000050 external static fixed bin(35,0)          dcl 395 ref 1697
error_table_$dt_size_error      000052 external static fixed bin(35,0)          dcl 395 ref 506
error_table_$dt_time_conversion_error
                                000054 external static fixed bin(35,0)          dcl 395 ref 1325 1346 1519 1525 1531 2228 2242 2247
                                                                                  2361
error_table_$dt_unknown_word    000056 external static fixed bin(35,0)          dcl 395 ref 857
error_table_$too_many_tokens    000060 external static fixed bin(35,0)          dcl 395 ref 864 868
first_char_of_str                      based           char(1)                  packed unaligned dcl 321 ref 557
fixed                                                  builtin function         dcl 330 ref 1422 1423 1424 1425 1426 1427 1428
fixed_length_sw                        parameter       bit(1)                   dcl 243 set ref 431 434* 742*
flag                     72            based           fixed bin(17,0)          level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 1329* 1331*
                                                                                  1352* 1352 1352 1355* 1357* 1359 1522
flag                      4     006250 automatic       fixed bin(17,0)          array level 3 in structure "rspace" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref 851
flag                      2            based           fixed bin(17,0)          array level 2 in structure "rtime_array" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  1685*
flag                     74     006250 automatic       fixed bin(17,0)          array level 4 in structure "rspace" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref 851
flag                      2            based           structure                level 2 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_"
fld59                           000152 automatic       float dec(59)            dcl 253 set ref 1643* 1646* 1669* 1671* 1674* 1675*
                                                                                  1675 1676 1686 1686 1731
fw                       11     000220 automatic       fixed bin(20,0)          level 2 dcl 299 set ref 1372*
fw_sw                           000172 automatic       bit(1)                   packed unaligned dcl 253 set ref 649* 1367 1373*
                                                                                  1429* 1485*
group2                    7            based           structure                level 2 packed packed unaligned dcl 7-68
h_time_sw                       000173 automatic       bit(1)                   packed unaligned dcl 253 set ref 445* 670 670* 688
                                                                                  717
hb                              010317 automatic       fixed bin(17,0)          dcl 987 set ref 998* 999 1000 1006*
hbound                                                 builtin function         dcl 330 ref 861 1716
i                               000174 automatic       fixed bin(17,0)          dcl 253 in procedure "convert_date_to_binary_" set
                                                                                  ref 631* 632* 737* 738* 842* 843 845 851 851 851
                                                                                  851* 1536* 1537 1537*
i                               010444 automatic       fixed bin(17,0)          dcl 9-33 in procedure "LEX" set ref 9-39* 9-42 9-45*
ii                              000175 automatic       fixed bin(17,0)          dcl 253 set ref 531* 532*
in_lang                   1(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 3-24 ref
                                                                                  532 540 1062 1208 1286
index                                                  builtin function         dcl 330 ref 557
ioa_$nnl                        000024 constant        entry                    external dcl 337 ref 644 702 925 934 936
item                                   based           structure                level 1 unaligned dcl 3-24 in procedure
                                                                                  "convert_date_to_binary_"
item                      2            based           structure                array level 2 in structure "ti_token" unaligned
                                                                                  dcl 3-10 in procedure "convert_date_to_binary_"
item_p                          010240 automatic       pointer                  dcl 3-24 set ref 523* 524 526 527 528 531 532 540
                                                                                  542 1060* 1061 1062 1062 1065 1070 1075 1206* 1207
                                                                                  1208 1208 1211 1281* 1285 1286 1286 1289
l                                      parameter       fixed bin(17,0)          dcl 1737 ref 1734 1780 1788 1789
lang_index                      000176 automatic       fixed bin(17,0)          dcl 253 set ref 639* 642 644 646* 1062 1208 1286
lang_temp                       000177 automatic       bit(18)                  packed unaligned dcl 253 set ref 530* 532* 532 534
lang_used                       000200 automatic       bit(18)                  packed unaligned dcl 253 set ref 449* 534* 534 540*
                                                                                  540 612 642 646*
last_adverb                     000201 automatic       fixed bin(17,0)          dcl 253 set ref 1104 1337* 2220*
lb                              010316 automatic       fixed bin(17,0)          dcl 987 set ref 997* 999 1000 1004*
lcode                           000202 automatic       fixed bin(35,0)          dcl 253 set ref 442* 494* 506* 614* 654* 663 680*
                                                                                  692 698 698 704 708* 715 857* 864* 868* 1325*
                                                                                  1346* 1376* 1519* 1525* 1531* 1691* 1694* 1697*
                                                                                  1700* 1703* 2228* 2242* 2247* 2361*
length                                                 builtin function         dcl 330 ref 489 521 535 535 539 539 577 577 708 708
                                                                                  1038 1233 1240 1370 1370 1584
list_r                   12            based           bit(18)                  array level 3 dcl 3-10 ref 1001
ltrim                                                  builtin function         dcl 330 ref 861
microseconds_per_day            000674 constant        fixed bin(71,0)          initial dcl 346 ref 769 784 838
mo                        3            based           fixed bin(17,0)          level 3 dcl 299 ref 739
mod                                                    builtin function         dcl 330 ref 756 1512
my                        3     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  622*
my                        0(18)        based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1423
my                        3     000340 automatic       fixed bin(17,0)          level 2 in structure "ttime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 772 787
my                        3     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 760 778 792
my                        3     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 749 760 760* 766
                                                                                  772* 775 778* 781 787* 790 792* 1367 1369* 1418
                                                                                  1423* 1477 1481* 1483* 1553 1556* 1560 1563* 1567
                                                                                  1570*
n                                      parameter       fixed bin(17,0)          dcl 9-33 ref 9-31 9-38 9-39 9-42 9-45
name                      2            based           varying char(32)         array level 2 dcl 4-42 set ref 644*
need_default                    012744 constant        fixed bin(17,0)          initial dcl 346 ref 622 623 749 790 802 1309 1367
                                                                                  1367 1383 1395 1418 1418 1420 1477 1510 1545 1553
                                                                                  1553 1553 1560 1560 1560 1567 1567 1567 1576 1595
need_this                       012742 constant        fixed bin(17,0)          initial dcl 346 ref 759 760 761 762 763 764 1313
                                                                                  1399 1462 1481 1494 1580
need_today                      012740 constant        fixed bin(17,0)          initial dcl 346 ref 775 1556
need_tomorrow                   012737 constant        fixed bin(17,0)          initial dcl 346 ref 781 1563
need_year                       012743 constant        fixed bin(17,0)          initial dcl 346 ref 798 1596
need_yesterday                  012741 constant        fixed bin(17,0)          initial dcl 346 ref 766 1570
null                                                   builtin function         dcl 6-92 in procedure "SEMANTIC_ANALYSIS" ref 8-64
                                                                                  8-73 8-79 8-86
null                                                   builtin function         dcl 330 in procedure "convert_date_to_binary_" ref
                                                                                  444 524 655 702 706 933 937 1008 1197 1771 1778
                                                                                  1786 9-37 9-39 9-42 9-45
number                                 based           char                     packed unaligned dcl 1729 in procedure "get_number"
                                                                                  ref 1731
number                          000203 automatic       fixed bin(35,0)          dcl 253 in procedure "convert_date_to_binary_" set
                                                                                  ref 503* 575* 575 577* 1637* 1639 1641 1644* 1665*
                                                                                  1666 1668* 1674* 1678 1686
number_in_str                          based           char                     packed unaligned dcl 321 ref 575 577 577
number_lang                            based           fixed bin(17,0)          level 2 dcl 4-42 ref 449 639 644 644
offset_sign                     000204 automatic       float dec(2)             dcl 253 set ref 1627* 1628* 1636* 1652* 1653* 1661*
                                                                                  1686
quoted_string            11(01)        based           bit(1)                   level 4 packed packed unaligned dcl 7-68 set ref
                                                                                  8-92 8-104 8-113 8-118 8-124
red                                    parameter       fixed bin(17,0)          dcl 920 set ref 919 925*
rel_ct                          006250 automatic       fixed bin(17,0)          array level 2 dcl 299 set ref 1322 1343 1722* 1722
relative_to_clock                      parameter       fixed bin(71,0)          dcl 243 ref 422 427 431 437
rqid                                   based           structure                level 1 packed packed unaligned dcl 1433
rspace                          006250 automatic       structure                array level 1 dcl 299 set ref 647* 674 677 721* 861
                                                                                  1716
rspace_h                        007230 automatic       structure                array level 1 dcl 299 set ref 619* 674* 677 721
rspace_init                     005270 automatic       structure                array level 1 dcl 299 set ref 627* 631 632* 632 647
rtime                                  based           structure                level 1 dcl 299
rtime_array                            based           structure                level 1 dcl 299
rtime_ct                        000205 automatic       fixed bin(17,0)          dcl 253 set ref 446* 675 722* 734 737 824 842 1322
                                                                                  1334 1343 1359 1716 1718* 1718 1719 1722 1722
rtime_ct_h                      000206 automatic       fixed bin(17,0)          dcl 253 set ref 675* 722
rtime_first                     000207 automatic       bit(1)                   packed unaligned dcl 253 set ref 447* 825* 1516
                                                                                  1540* 1713 1715* 2261*
rtime_p                         000210 automatic       pointer                  dcl 253 set ref 628* 629 630 738* 739 739 755 756
                                                                                  756 835 836 836 1329 1331 1333 1352 1352 1352 1355
                                                                                  1357 1359 1522 1537 1537 1685 1686 1686 1719* 1720
rtrim                                                  builtin function         dcl 330 ref 995
search                                                 builtin function         dcl 330 in procedure "convert_date_to_binary_" ref
                                                                                  513 547
search                                                 builtin function         dcl 6-92 in procedure "SEMANTIC_ANALYSIS" ref 8-92
semantic_error                  010224 stack reference condition                dcl 337 ref 634 1327 1348 1378 1708
sign                                                   builtin function         dcl 1351 ref 1352
silent                          000212 automatic       bit(1)                   packed unaligned dcl 253 set ref 490* 644 700 922
                                                                                  931
size                            010216 stack reference condition                dcl 337 ref 498 606
size_flag                       000213 automatic       bit(1)                   packed unaligned dcl 253 set ref 497* 500 574* 576*
str                                    based           char                     packed unaligned dcl 321 ref 513 547 564 570 581 590
string                                                 builtin function         dcl 330 set ref 925 925 1787*
substr                                                 builtin function         dcl 6-92 in procedure "SEMANTIC_ANALYSIS" ref 8-92
                                                                                  8-126
substr                                                 builtin function         dcl 330 in procedure "convert_date_to_binary_" set
                                                                                  ref 581 590 642 646* 1062 1208 1286
sum                                                    builtin function         dcl 330 ref 851
symb                            010320 automatic       varying char(32)         dcl 988 set ref 994* 995* 995 1001 1004
symbol                    2            based           char(32)                 array level 3 packed packed unaligned dcl 3-10 ref
                                                                                  1001 1004
table                     1(01)        based           fixed bin(7,0)           array level 3 packed packed unsigned unaligned
                                                                                  dcl 3-24 ref 526 1062 1208 1286
tcode                           000214 automatic       fixed bin(35,0)          dcl 253 set ref 442* 654* 698 715*
ti_language                            based           structure                level 1 unaligned dcl 4-42
ti_token                               based           structure                level 1 unaligned dcl 3-10
ti_token_p                      010236 automatic       pointer                  dcl 3-22 set ref 452* 998 1001 1001 1004
time_defaults_$debug            000074 external static bit(1)                   dcl 5-42 ref 490
time_defaults_$language_index   000072 external static fixed bin(17,0)          dcl 5-26 ref 639
time_info_$default_language_index
                                000066 external static fixed bin(17,0)          dcl 4-26 ref 639
time_info_$language_names       000070 external static fixed bin(17,0)          dcl 4-40 set ref 449 639 644
time_info_$tokens               000062 external static fixed bin(17,0)          dcl 3-7 set ref 452
time_info_$version              000064 external static char(8)                  packed unaligned dcl 4-21 set ref 1001
time_offset                            based           structure                level 1 dcl 2-37
time_offset_array                      based           structure                level 1 dcl 2-88
time_string                            parameter       char                     packed unaligned dcl 243 set ref 240 422 431 488 489
                                                                                  706 708 708 708*
time_value                             based           structure                level 1 dcl 1-53
token                                  based           structure                level 1 dcl 7-68
token_value                            based           char                     packed unaligned dcl 7-68 set ref 934* 1038 1233
                                                                                  1240 1267 1267 1370 1370 1447 1584 1604 1613 1627
                                                                                  1652 8-92 8-92 8-106* 8-113 8-128 2313
tokens                          000364 automatic       structure                array level 1 unaligned dcl 299 set ref 653 1765
                                                                                  1770 1774
translate                                              builtin function         dcl 330 ref 994
ttime                           000340 automatic       structure                level 1 unaligned dcl 299 set ref 768* 769 769 783*
                                                                                  784 784
type                                   parameter       fixed bin(17,0)          dcl 1737 ref 1734 1784
u_day_of_week                   000215 automatic       fixed bin(17,0)          dcl 253 set ref 650* 659 725* 734 749 749 756 824
                                                                                  1333 1334 1336* 1620 1621*
unspec                                                 builtin function         dcl 330 set ref 618* 619* 620* 627* 677 677 677 677
                                                                                  734 734 1528 1528
val                      12            based           float dec(20)            array level 2 in structure "rtime_array" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  630* 1537* 1537 1686* 1686
val                      12            based           structure                level 2 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_"
val                      73            based           fixed bin(17,0)          level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 1333*
val                                    parameter       char                     packed unaligned dcl 985 in procedure
                                                                                  "find_time_name" ref 983 994
value                                  parameter       fixed bin(35,0)          dcl 1737 ref 1734 1785
verify                                                 builtin function         dcl 330 in procedure "convert_date_to_binary_" ref
                                                                                  564 570 590
verify                                                 builtin function         dcl 6-92 in procedure "SEMANTIC_ANALYSIS" ref 8-92
version                         000270 automatic       char(8)                  level 2 in structure "atime_init" packed packed
                                                                                  unaligned dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 621*
version                                based           char(8)                  level 2 in structure "rtime_array" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  1720*
version                                based           char(8)                  level 2 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 629*
word_in_str                            based           char                     packed unaligned dcl 321 set ref 521 523* 535 535
                                                                                  539 539
yc                        2     000220 automatic       fixed bin(17,0)          level 2 in structure "atime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 759 759* 771*
                                                                                  777* 786* 796 798 800* 1367 1369* 1418 1422* 1553
                                                                                  1556* 1560 1563* 1567 1570* 1576 1580* 1583* 1586*
                                                                                  1586 1595 1596*
yc                        2     000270 automatic       fixed bin(17,0)          level 2 in structure "atime_init" dcl 299
                                                                                  in procedure "convert_date_to_binary_" set ref
                                                                                  622*
yc                        2     000340 automatic       fixed bin(17,0)          level 2 in structure "ttime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 771 786
yc                        2     000314 automatic       fixed bin(17,0)          level 2 in structure "ctime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 759 777 800
yc                                     based           char(2)                  level 2 in structure "rqid" packed packed unaligned
                                                                                  dcl 1433 in procedure "Aday_and_LEX" ref 1422
year_needed                     000216 automatic       bit(1)                   packed unaligned dcl 253 set ref 729* 798* 817 832
yr                       12            based           float dec(20)            level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 836* 836
yr                        2            based           fixed bin(17,0)          level 3 in structure "rtime" dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 739 835*
za                       20     000220 automatic       char(5)                  level 2 in structure "atime" packed packed unaligned
                                                                                  dcl 299 in procedure "convert_date_to_binary_" set
                                                                                  ref 747 747* 748* 769* 784* 844* 851* 1430 1430*
                                                                                  1602 1602 1604* 1611 1611 1613*
za                       20     000270 automatic       char(5)                  level 2 in structure "atime_init" packed packed
                                                                                  unaligned dcl 299 in procedure
                                                                                  "convert_date_to_binary_" set ref 624*
zone_index               22     000220 automatic       fixed bin(17,0)          level 2 dcl 299 set ref 1605* 1614*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FRACTION                               internal static fixed bin(17,0)          initial dcl 2-62
INTEGER                                internal static fixed bin(17,0)          initial dcl 2-62
Language_table                         internal static fixed bin(17,0)          initial dcl 3-38
Pcomment                               automatic       pointer                  dcl 7-20
Pstmt                                  automatic       pointer                  dcl 7-40
Ptime_offset                           automatic       pointer                  dcl 2-77
Ptime_value                            automatic       pointer                  dcl 1-53
Vtime_info_2                           internal static char(8)                  initial packed unaligned dcl 4-23
comment                                based           structure                level 1 dcl 7-20
comment_value                          based           char                     packed unaligned dcl 7-20
da_name                                internal static char(3)                  initial array packed unaligned dcl 3-50
max                                                    builtin function         dcl 6-92
mo_name                                internal static char(3)                  initial array packed unaligned dcl 3-47
of_name                                internal static char(12)                 initial array packed unaligned dcl 3-54
site_date                              internal static fixed bin(17,0)          initial dcl 4-35
site_date_time                         internal static fixed bin(17,0)          initial dcl 4-35
site_time                              internal static fixed bin(17,0)          initial dcl 4-35
stmt                                   based           structure                level 1 dcl 7-40
stmt_value                             based           char                     packed unaligned dcl 7-40
the_offset_count                       internal static fixed bin(17,0)          initial dcl 3-53
the_word_count                         internal static fixed bin(17,0)          initial dcl 3-58
ti_day                                 based           structure                level 1 unaligned dcl 4-60
ti_keyword                             based           structure                level 1 unaligned dcl 4-29
ti_month                               based           structure                level 1 unaligned dcl 4-52
ti_offset                              based           structure                level 1 unaligned dcl 4-68
ti_word                                based           structure                level 1 unaligned dcl 4-78
ti_zone                                based           structure                level 1 unaligned dcl 4-88
time_defaults_$date                    external static varying char(64)         dcl 5-19
time_defaults_$date_time               external static varying char(64)         dcl 5-18
time_defaults_$language                external static char(32)                 packed unaligned dcl 5-23
time_defaults_$time                    external static varying char(64)         dcl 5-20
time_defaults_$zone_delta              external static fixed bin(71,0)          dcl 5-35
time_defaults_$zone_index              external static fixed bin(17,0)          dcl 5-38
time_defaults_$zone_long               external static varying char(64)         dcl 5-29
time_defaults_$zone_short              external static varying char(4)          dcl 5-32
time_info_$date_time_keywords          external static fixed bin(17,0)          dcl 4-28
time_info_$day_names                   external static fixed bin(17,0)          dcl 4-58
time_info_$gmt_zone_index              external static fixed bin(17,0)          dcl 4-25
time_info_$month_names                 external static fixed bin(17,0)          dcl 4-50
time_info_$offset_names                external static fixed bin(17,0)          dcl 4-66
time_info_$word_names                  external static fixed bin(17,0)          dcl 4-76
time_info_$zone_names                  external static fixed bin(17,0)          dcl 4-86
tiw_FiscalIndicator                    internal static fixed bin(17,0)          initial dcl 4-107
wo_name                                internal static char(12)                 initial array packed unaligned dcl 3-59

NAMES DECLARED BY EXPLICIT CONTEXT.
Aadverb                         006255 constant        entry                    internal dcl 1515 ref 2233
Ab_a                            005424 constant        entry                    internal dcl 1340 ref 2256
Ab_o_a                          005343 constant        entry                    internal dcl 1319 ref 2126
Aday_and_LEX                    005307 constant        entry                    internal dcl 1305 ref 1997 2004 2014 2025 2037
Afraction_offset                006706 constant        entry                    internal dcl 1658 ref 2053 2166
Afraction_sign_and_offset       006662 constant        entry                    internal dcl 1649 ref 2158 2174
Afw                             005510 constant        entry                    internal dcl 1365 ref 2045
Ahalf_day                       005550 constant        entry                    internal dcl 1381 ref 2100 2108
Ahour_and_LEX                   005570 constant        entry                    internal dcl 1393 ref 2079 2088
Ameridian                       005624 constant        entry                    internal dcl 1406 ref 2089 2298
Aminute_and_LEX                 006110 constant        entry                    internal dcl 1457 ref 2081
Aminute_fraction                006047 constant        entry                    internal dcl 1445 ref 2071 2286
Aminute_zero                    006141 constant        entry                    internal dcl 1469 ref 2091
Amonth_and_LEX                  006144 constant        entry                    internal dcl 1475 ref 1996 2005 2012 2023 2035
Anow                            006346 constant        entry                    internal dcl 1544 ref 2214
Arequest_id                     005641 constant        entry                    internal dcl 1416 ref 2061
Asecond_and_LEX                 006202 constant        entry                    internal dcl 1489 ref 2269 2279
Asecond_fraction                006031 constant        entry                    internal dcl 1439 ref 2270
Asecond_zero                    006234 constant        entry                    internal dcl 1502 ref 2092 2292
Atime                           006240 constant        entry                    internal dcl 1508 ref 2069
Atoday                          006363 constant        entry                    internal dcl 1552 ref 2198
Atomorrow                       006402 constant        entry                    internal dcl 1559 ref 2206
Ayear_and_LEX                   006440 constant        entry                    internal dcl 1574 ref 2016 2033 2328 2366
Ayear_default                   006501 constant        entry                    internal dcl 1593 ref 2026 2333 2338 2343 2348 2353
                                                                                  2371
Ayesterday                      006421 constant        entry                    internal dcl 1566 ref 2190
Azone                           006510 constant        entry                    internal dcl 1600 ref 2182
Azone_dif                       006542 constant        entry                    internal dcl 1609 ref 2315
COMMON                          001341 constant        label                    dcl 442 ref 417
Ehr_gt_12                       007031 constant        label                    dcl 1703 ref 1408
Emultiple_date_spec             007015 constant        label                    dcl 1694 ref 1309 1367 1418 1477 1553 1560 1567 1576
                                                                                  1595
Emultiple_diw_spec              007025 constant        label                    dcl 1700 ref 1620
Emultiple_time_spec             007011 constant        label                    dcl 1691 ref 1383 1395 1420 1510 1545
Emultiple_zone_spec             007021 constant        label                    dcl 1697 ref 1602 1611
Etoo_many_adverbs               003254 constant        label                    dcl 861 ref 1716
Etoo_many_tokens                003340 constant        label                    dcl 868 ref 1765
Eunknown_word                   003250 constant        label                    dcl 857 ref 521 552
LEX                             011141 constant        entry                    internal dcl 9-31 ref 1312 1316 1398 1402 1461 1465
                                                                                  1480 1484 1493 1497 1579 1589 2054 2062 2117 2143
                                                                                  2151 2159 2167 2175
N                               005031 constant        entry                    internal dcl 1220 ref 1931
NOT_FIXED_LENGTH                002445 constant        label                    dcl 744 ref 739
RD_ACTION                       000307 constant        label                    array(53) dcl 1991 ref 1988
RD_MATCH                        010012 constant        label                    dcl 1984 ref 8-90 8-92 8-101 8-109 8-113 8-118 8-128
                                                                                  1980
RD_MATCH_NO_TOKEN               010015 constant        label                    dcl 1985 ref 8-73 8-79 8-86
RD_NEXT_REDUCTION               007176 constant        label                    dcl 8-55 ref 8-68 8-84 8-88 8-99 8-104 8-111 8-116
                                                                                  8-120 8-124 8-130 1981 2222 2259 2294 2301
RD_TEST_REDUCTION               007177 constant        label                    dcl 8-58 ref 8-53 2000 2008 2019 2029 2040 2049 2057
                                                                                  2065 2075 2084 2095 2104 2112 2120 2130 2138 2146
                                                                                  2154 2162 2170 2178 2186 2194 2202 2210 2218 2237
                                                                                  2264 2274 2282 2290 2305 2309 2319 2323 2331 2336
                                                                                  2341 2346 2351 2356 2369 2374
RD_TEST_RESULT                  010006 constant        label                    dcl 1980 ref 1920 1922 1924 1926 1928 1930 1932 1934
                                                                                  1936 1938 1940 1942 1944 1946 1948 1950 1952 1954
                                                                                  1956 1958 1960 1962 1964 1966 1968 1970 1972 1974
                                                                                  1976 1978
RD_TEST_TOKEN                   000243 constant        label                    array(6) dcl 8-73 ref 8-65 8-71
RD_TOKEN_FCN                    000251 constant        label                    array(30) dcl 1919 ref 1917
SEMANTIC_ANALYSIS               007166 constant        entry                    internal dcl 6-30 ref 656
SL                              003666 constant        entry                    internal dcl 919 ref 1994 2002 2010 2021 2031 2042
                                                                                  2051 2059 2067 2077 2086 2097 2106 2114 2122 2132
                                                                                  2140 2148 2156 2164 2172 2180 2188 2196 2204 2212
                                                                                  2231 2253 2266 2276 2284 2296 2311 2325 2364
SLe                             003716 constant        entry                    internal dcl 929 ref 1998 2006 2017 2027 2038 2047
                                                                                  2055 2063 2073 2082 2093 2102 2110 2118 2128 2136
                                                                                  2144 2152 2160 2168 2176 2184 2192 2200 2208 2216
                                                                                  2235 2258 2272 2280 2288 2300 2317 2329 2367
Uday_of_week                    006605 constant        entry                    internal dcl 1618 ref 2116 2124 2134
analyze                         001302 constant        entry                    external dcl 431
andfraction                     004152 constant        entry                    internal dcl 1031 ref 1933
andfraction6                    004167 constant        entry                    internal dcl 1036 ref 1939
apply_offset                    006640 constant        entry                    internal dcl 1633 ref 2150
apply_sign_and_offset           006614 constant        entry                    internal dcl 1624 ref 2142
before_after                    004406 constant        entry                    internal dcl 1102 ref 1969
before_on_after                 004371 constant        entry                    internal dcl 1095 ref 1953
convert_date_to_binary_         001200 constant        entry                    external dcl 240 ref 901
day                             004522 constant        entry                    internal dcl 1132 ref 1921
day_name                        004124 constant        entry                    internal dcl 1021 ref 1951
end_scan                        002042 constant        label                    dcl 604 ref 554 568 579 581 598
error_display                   003510 constant        entry                    internal dcl 697 ref 660 687 690
error_exit                      002365 constant        label                    dcl 690 ref 615 681 866 872
exit                            002370 constant        label                    dcl 693 ref 609 817 828 848 856
false                           005300 constant        label                    dcl 1294 ref 1029 1034 1040 1058 1082 1197 1204 1218
                                                                                  1229 1235 1242 1262 1268 1284
find_time_name                  004004 constant        entry                    internal dcl 983 ref 523
fraction                        004135 constant        entry                    internal dcl 1026 ref 1957
fweek                           004207 constant        entry                    internal dcl 1041 ref 1927
get_fraction                    007072 constant        entry                    internal dcl 1726 ref 1441 1450 1675
get_number                      007067 constant        entry                    internal dcl 1726 ref 1643 1669
half_day                        004222 constant        entry                    internal dcl 1047 ref 1949
hour                            004616 constant        entry                    internal dcl 1159 ref 1941
init_rtime                      007044 constant        entry                    internal dcl 1711 ref 754 823 834 1321 1342 1684
join_fraction                   006712 constant        label                    dcl 1662 ref 1655
join_offset                     006644 constant        label                    dcl 1637 ref 1630
lex                             000000 constant        label                    array(0:3) dcl 563 ref 558
lex1a                           001760 constant        label                    dcl 577 ref 504
lex2a                           002000 constant        label                    dcl 587 ref 584
meridian                        004342 constant        entry                    internal dcl 1084 ref 1945
minute                          004642 constant        entry                    internal dcl 1168 ref 1943
month                           004546 constant        entry                    internal dcl 1141 ref 1923
month_name                      004712 constant        entry                    internal dcl 1186 ref 1919
n                               005046 constant        entry                    internal dcl 1224 ref 1929
n12                             005103 constant        entry                    internal dcl 1238 ref 1937
n4                              005063 constant        entry                    internal dcl 1230 ref 1977
n_                              005053 constant        label                    dcl 1227 ref 1138 1147 1156 1165 1174 1183
now                             004433 constant        entry                    internal dcl 1112 ref 1967
offset                          005126 constant        entry                    internal dcl 1245 ref 1935
offset_common                   006752 constant        label                    dcl 1681 ref 1647
offset_table_check_next         004737 constant        label                    dcl 1197 ref 1136 1145 1154 1163 1172 1181 1191
on                              004356 constant        entry                    internal dcl 1090 ref 1973
or                              004446 constant        entry                    internal dcl 1116 ref 1971
parse_fail                      002270 constant        label                    dcl 660 ref 636
parse_success                   002371 constant        label                    dcl 717 ref 665
re_try                          001510 constant        label                    dcl 519 ref 549
relative                        001240 constant        entry                    external dcl 422
second                          004666 constant        entry                    internal dcl 1177 ref 1975
set                             003361 constant        entry                    external dcl 893
set_err_loc                     003343 constant        label                    dcl 870 in procedure "convert_date_to_binary_" ref
                                                                                  495 507 859
set_err_loc                     007035 constant        label                    dcl 1706 in procedure "Aday_and_LEX" ref 1520 1526
                                                                                  1532 1693 1696 1699 1702 1705
sign                            005170 constant        entry                    internal dcl 1265 ref 1955
this_                           005137 constant        entry                    internal dcl 1251 ref 1133 1142 1151 1160 1169 1178
                                                                                  1188 1310 1396 1459 1478 1491 1577
today                           004461 constant        entry                    internal dcl 1120 ref 1963
token_                          007110 constant        entry                    internal dcl 1734 ref 535 539 577 595 602
tomorrow                        004474 constant        entry                    internal dcl 1124 ref 1965
true                            005303 constant        label                    dcl 1296 ref 1028 1033 1038 1052 1068 1073 1078 1200
                                                                                  1214 1222 1227 1233 1240 1259 1267 1283 1290
twelve                          005150 constant        entry                    internal dcl 1257 ref 1947
unset                           003347 constant        entry                    external dcl 888
word_check                      005222 constant        label                    dcl 1281 ref 1024 1194 1248 1254
word_table_check                004234 constant        label                    dcl 1052 ref 1044 1088 1093 1100 1110 1114 1118 1122
                                                                                  1126 1130
year                            004572 constant        entry                    internal dcl 1150 ref 1925
yesterday                       004507 constant        entry                    internal dcl 1128 ref 1961
zone                            005213 constant        entry                    internal dcl 1271 ref 1959

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13636       13742   12755       13646
Length     14464   12755       104         506     660           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
convert_date_to_binary_            5230 external procedure  is an external procedure.  
on unit on line 492                  64 on unit               
on unit on line 498                  64 on unit               
on unit on line 634                  64 on unit               
error_display                           internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
begin block on line 896                 begin block         shares stack frame of external procedure convert_date_to_binary_.  
SL                                      internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
find_time_name                          internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
day_name                             78 internal procedure  calls itself recursively.  
Aday_and_LEX                            internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
begin block on line 1350                begin block         shares stack frame of external procedure convert_date_to_binary_.  
init_rtime                              internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
get_number                              internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
token_                                  internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure convert_date_to_binary_.  
LEX                                     internal procedure  shares stack frame of external procedure convert_date_to_binary_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 constant_sw                 convert_date_to_binary_
000012 constant_clock              convert_date_to_binary_
000014 TRACING                     convert_date_to_binary_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_date_to_binary_  000100 Idelim_type                 convert_date_to_binary_
                         000101 Isearch                     convert_date_to_binary_
                         000102 Iverify                     convert_date_to_binary_
                         000103 Lnumber_in_str              convert_date_to_binary_
                         000104 Lword_in_str                convert_date_to_binary_
                         000105 Lstr                        convert_date_to_binary_
                         000106 Ntokens                     convert_date_to_binary_
                         000110 Pstr                        convert_date_to_binary_
                         000112 SIGN                        convert_date_to_binary_
                         000113 Sspace_encountered          convert_date_to_binary_
                         000114 a_clock                     convert_date_to_binary_
                         000116 ambig_sw                    convert_date_to_binary_
                         000117 analyze_sw                  convert_date_to_binary_
                         000120 clock_now                   convert_date_to_binary_
                         000122 date_given                  convert_date_to_binary_
                         000123 details                     convert_date_to_binary_
                         000144 done                        convert_date_to_binary_
                         000145 dow_given                   convert_date_to_binary_
                         000146 errloc                      convert_date_to_binary_
                         000150 err_pt                      convert_date_to_binary_
                         000152 fld59                       convert_date_to_binary_
                         000172 fw_sw                       convert_date_to_binary_
                         000173 h_time_sw                   convert_date_to_binary_
                         000174 i                           convert_date_to_binary_
                         000175 ii                          convert_date_to_binary_
                         000176 lang_index                  convert_date_to_binary_
                         000177 lang_temp                   convert_date_to_binary_
                         000200 lang_used                   convert_date_to_binary_
                         000201 last_adverb                 convert_date_to_binary_
                         000202 lcode                       convert_date_to_binary_
                         000203 number                      convert_date_to_binary_
                         000204 offset_sign                 convert_date_to_binary_
                         000205 rtime_ct                    convert_date_to_binary_
                         000206 rtime_ct_h                  convert_date_to_binary_
                         000207 rtime_first                 convert_date_to_binary_
                         000210 rtime_p                     convert_date_to_binary_
                         000212 silent                      convert_date_to_binary_
                         000213 size_flag                   convert_date_to_binary_
                         000214 tcode                       convert_date_to_binary_
                         000215 u_day_of_week               convert_date_to_binary_
                         000216 year_needed                 convert_date_to_binary_
                         000220 atime                       convert_date_to_binary_
                         000244 atime_h                     convert_date_to_binary_
                         000270 atime_init                  convert_date_to_binary_
                         000314 ctime                       convert_date_to_binary_
                         000340 ttime                       convert_date_to_binary_
                         000364 tokens                      convert_date_to_binary_
                         005270 rspace_init                 convert_date_to_binary_
                         006250 rspace                      convert_date_to_binary_
                         007230 rspace_h                    convert_date_to_binary_
                         010232 Type                        convert_date_to_binary_
                         010233 Value                       convert_date_to_binary_
                         010234 Pfirst_token                convert_date_to_binary_
                         010236 ti_token_p                  convert_date_to_binary_
                         010240 item_p                      convert_date_to_binary_
                         010242 Pthis_token                 convert_date_to_binary_
                         010244 Ptoken                      convert_date_to_binary_
                         010246 SPDL                        convert_date_to_binary_
                         010274 arg_l                       begin block on line 896
                         010276 arg_p                       begin block on line 896
                         010300 code                        begin block on line 896
                         010316 lb                          find_time_name
                         010317 hb                          find_time_name
                         010320 symb                        find_time_name
                         010331 cur_token                   find_time_name
                         010376 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         010377 NRED                        SEMANTIC_ANALYSIS
                         010400 PRED                        SEMANTIC_ANALYSIS
                         010402 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         010404 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         010406 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         010407 CODE                        SEMANTIC_ANALYSIS
                         010410 I                           SEMANTIC_ANALYSIS
                         010411 NUMBER                      SEMANTIC_ANALYSIS
                         010412 DIRECTION                   SEMANTIC_ANALYSIS
                         010444 i                           LEX
day_name                 000100 Twhich1                     day_name
                         000101 Twhich2                     day_name
                         000102 Twhich3                     day_name
                         000103 elem                        day_name

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               r_ne_as             alloc_char_temp     alloc_bit_temp      cat_realloc_chars
call_ext_in_desc    call_ext_out_desc   call_ext_out        call_int_this       call_int_other      begin_return_mac
return_mac          tra_ext_1           sign_mac            mdfx1               signal_op           enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           real_to_real_round_ any_to_any_round_
any_to_any_truncate_clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_ptr                   cv_dec_check_                 date_time_$from_clock
date_time_$offset_to_clock    date_time_$to_clock           ioa_$nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$dt_ambiguous_time
error_table_$dt_bad_day_of_week                             error_table_$dt_bad_fw
error_table_$dt_hour_gt_twelve                              error_table_$dt_multiple_date_spec
error_table_$dt_multiple_diw_spec                           error_table_$dt_multiple_meaning
error_table_$dt_multiple_time_spec                          error_table_$dt_multiple_zone_spec
error_table_$dt_size_error    error_table_$dt_time_conversion_error                       error_table_$dt_unknown_word
error_table_$too_many_tokens  time_defaults_$debug          time_defaults_$language_index
time_info_$default_language_index                           time_info_$language_names     time_info_$tokens
time_info_$version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   2381 001171       240 001174       413 001221       414 001222       416 001230       417 001232       422 001233
    424 001263       425 001264       427 001272       431 001274       433 001325       434 001327       435 001331
    437 001337       442 001341       443 001344       444 001345       445 001350       446 001351       447 001352
    449 001354       450 001366       451 001370       452 001371       488 001373       489 001376       490 001400
    491 001403       492 001404       494 001420       495 001423       497 001426       498 001427       500 001443
    502 001446       503 001450       504 001452       506 001455       507 001457       510 001462       511 001464
    513 001466       514 001501       516 001505       518 001507       519 001510       521 001513       523 001515
    524 001533       526 001537       527 001544       528 001550       530 001556       531 001557       532 001567
    533 001572       534 001574       535 001600       536 001605       537 001607       539 001610       540 001614
    542 001624       543 001627       547 001630       548 001644       549 001650       552 001653       554 001654
    557 001656       558 001671       563 001672       564 001674       565 001707       566 001713       567 001716
    568 001721       570 001722       571 001735       572 001741       573 001743       574 001745       575 001747
    576 001757       577 001760       579 001764       581 001766       583 001773       584 001775       586 001776
    587 002000       590 002003       591 002016       592 002022       593 002023       594 002024       595 002026
    597 002032       598 002033       600 002034       602 002035       604 002042       606 002043       607 002045
    608 002047       609 002051       612 002052       614 002055       615 002060       618 002061       619 002064
    620 002067       621 002072       622 002074       623 002100       624 002104       625 002106       627 002111
    628 002114       629 002116       630 002121       631 002137       632 002145       633 002152       634 002154
    636 002170       638 002173       639 002174       642 002201       644 002206       646 002242       647 002246
    648 002251       649 002254       650 002255       653 002256       654 002260       655 002263       656 002265
    659 002266       660 002270       662 002271       663 002274       665 002276       670 002300       673 002304
    674 002307       675 002312       676 002314       677 002315       680 002326       681 002331       686 002332
    687 002362       688 002363       690 002365       692 002366       693 002370       717 002371       720 002373
    721 002376       722 002401       725 002403       726 002405       728 002406       729 002410       732 002413
    734 002415       737 002425       738 002431       739 002434       741 002437       742 002442       747 002445
    748 002460       749 002507       753 002517       754 002521       755 002522       756 002525       759 002561
    760 002566       761 002573       762 002600       763 002605       764 002612       766 002617       768 002622
    769 002625       771 002657       772 002661       773 002663       774 002665       775 002666       777 002670
    778 002672       779 002674       780 002676       781 002677       783 002701       784 002704       786 002736
    787 002740       788 002742       790 002744       792 002747       793 002751       794 002753       795 002754
    796 002756       798 002760       800 002764       802 002766       803 002771       804 002773       805 002775
    806 002777       814 003001       815 003016       817 003024       820 003033       822 003034       823 003050
    824 003051       825 003056       826 003060       828 003061       830 003063       832 003066       834 003070
    835 003071       836 003074       837 003077       838 003100       842 003105       843 003115       844 003121
    845 003150       847 003156       848 003161       851 003162       855 003244       856 003247       857 003250
    859 003253       861 003254       864 003330       865 003334       866 003337       868 003340       870 003343
    872 003345       888 003346       890 003355       891 003357       893 003360       897 003367       898 003406
    901 003414       902 003437       904 003441       905 003476       907 003500       909 003503       910 003505
   2386 003507       697 003510       698 003511       700 003516       702 003520       704 003537       706 003541
    708 003570       715 003663       716 003665       919 003666       922 003670       924 003672       925 003674
    927 003715       929 003716       931 003717       933 003721       934 003734       935 003760       936 003764
    937 003777       938 004001       978 004003       983 004004       994 004015       995 004033       997 004052
    998 004054       999 004056      1000 004061      1001 004064      1004 004106      1006 004113      1007 004116
   1008 004117      1021 004123      1023 004131      1024 004133      1026 004134      1028 004142      1029 004150
   1031 004151      1033 004157      1034 004165      1036 004166      1038 004174      1040 004205      1041 004206
   1043 004214      1044 004220      1047 004221      1049 004227      1050 004231      1052 004234      1058 004252
   1060 004254      1061 004256      1062 004265      1065 004310      1067 004316      1068 004321      1070 004322
   1072 004324      1073 004327      1075 004330      1077 004332      1078 004335      1081 004336      1082 004340
   1084 004341      1086 004347      1087 004351      1088 004354      1090 004355      1092 004363      1093 004367
   1095 004370      1097 004376      1098 004400      1099 004402      1100 004404      1102 004405      1104 004413
   1106 004417      1107 004421      1108 004424      1109 004425      1110 004431      1112 004432      1113 004440
   1114 004444      1116 004445      1117 004453      1118 004457      1120 004460      1121 004466      1122 004472
   1124 004473      1125 004501      1126 004505      1128 004506      1129 004514      1130 004520      1132 004521
   1133 004527      1135 004541      1136 004543      1138 004544      1141 004545      1142 004553      1144 004565
   1145 004567      1147 004570      1150 004571      1151 004577      1153 004611      1154 004613      1156 004614
   1159 004615      1160 004623      1162 004635      1163 004637      1165 004640      1168 004641      1169 004647
   1171 004661      1172 004663      1174 004664      1177 004665      1178 004673      1180 004705      1181 004707
   1183 004710      1186 004711      1188 004717      1190 004731      1191 004733      1193 004734      1194 004736
   1197 004737      1199 004744      1200 004746      1204 004756      1206 004760      1207 004762      1208 004771
   1211 005014      1213 005021      1214 005024      1217 005025      1218 005027      1220 005030      1222 005036
   1224 005044      1227 005053      1229 005061      1230 005062      1233 005070      1235 005101      1238 005102
   1240 005110      1242 005124      1245 005125      1247 005133      1248 005135      1251 005136      1253 005144
   1254 005146      1257 005147      1259 005155      1262 005166      1265 005167      1267 005175      1268 005211
   1271 005212      1273 005220      1281 005222      1283 005227      1284 005233      1285 005235      1286 005245
   1289 005270      1290 005275      1292 005276      1294 005300      1296 005303      1305 005307      1309 005310
   1310 005313      1312 005324      1313 005330      1314 005332      1315 005333      1316 005336      1317 005342
   1319 005343      1321 005344      1322 005345      1324 005352      1325 005357      1326 005362      1327 005365
   1329 005370      1331 005377      1333 005405      1334 005410      1336 005420      1337 005421      1338 005423
   1340 005424      1342 005425      1343 005426      1345 005433      1346 005440      1347 005443      1348 005446
   1352 005451      1355 005463      1357 005471      1359 005477      1361 005507      1365 005510      1367 005511
   1369 005521      1370 005524      1372 005532      1373 005534      1374 005536      1376 005537      1377 005542
   1378 005544      1381 005547      1383 005551      1384 005554      1386 005563      1387 005564      1388 005565
   1389 005566      1390 005567      1393 005570      1395 005571      1396 005574      1398 005605      1399 005611
   1400 005613      1401 005614      1402 005617      1403 005623      1406 005624      1408 005625      1409 005630
   1411 005632      1413 005640      1416 005641      1418 005642      1420 005650      1422 005653      1423 005675
   1424 005712      1425 005726      1426 005744      1427 005760      1428 005776      1429 006014      1430 006016
   1431 006030      1439 006031      1441 006032      1443 006046      1445 006047      1447 006050      1450 006064
   1451 006100      1452 006103      1454 006107      1457 006110      1459 006111      1461 006122      1462 006126
   1463 006130      1464 006131      1465 006134      1466 006140      1469 006141      1471 006142      1472 006143
   1475 006144      1477 006145      1478 006150      1480 006161      1481 006165      1482 006167      1483 006170
   1484 006173      1485 006177      1486 006201      1489 006202      1491 006203      1493 006214      1494 006220
   1495 006222      1496 006223      1497 006226      1498 006232      1499 006233      1502 006234      1504 006235
   1505 006236      1506 006237      1508 006240      1510 006241      1511 006244      1512 006250      1513 006254
   1515 006255      1516 006256      1518 006260      1519 006265      1520 006270      1522 006271      1524 006274
   1525 006301      1526 006304      1528 006305      1530 006311      1531 006316      1532 006321      1534 006322
   1536 006326      1537 006333      1538 006341      1540 006343      1541 006345      1544 006346      1545 006347
   1546 006352      1547 006354      1548 006356      1549 006360      1550 006362      1552 006363      1553 006364
   1556 006375      1557 006401      1559 006402      1560 006403      1563 006414      1564 006420      1566 006421
   1567 006422      1570 006433      1571 006437      1574 006440      1576 006441      1577 006444      1579 006455
   1580 006461      1581 006463      1583 006464      1584 006467      1586 006472      1589 006474      1590 006500
   1593 006501      1595 006502      1596 006505      1597 006507      1600 006510      1602 006511      1604 006527
   1605 006537      1606 006541      1609 006542      1611 006543      1613 006561      1614 006602      1615 006604
   1618 006605      1620 006606      1621 006610      1622 006613      1624 006614      1627 006615      1628 006632
   1629 006635      1630 006637      1633 006640      1636 006641      1637 006644      1639 006647      1641 006651
   1643 006652      1644 006654      1645 006655      1646 006656      1647 006661      1649 006662      1652 006663
   1653 006700      1654 006703      1655 006705      1658 006706      1661 006707      1662 006712      1665 006717
   1666 006721      1668 006722      1669 006723      1670 006725      1671 006726      1672 006731      1673 006734
   1674 006735      1675 006741      1676 006746      1678 006747      1681 006752      1684 006755      1685 006756
   1686 006763      1689 007010      1691 007011      1693 007014      1694 007015      1696 007020      1697 007021
   1699 007024      1700 007025      1702 007030      1703 007031      1705 007034      1706 007035      1708 007040
   1710 007043      1711 007044      1713 007045      1715 007047      1716 007050      1718 007053      1719 007054
   1720 007060      1722 007063      1724 007066      1726 007067      1731 007074      1734 007110      1765 007112
   1768 007115      1769 007116      1770 007121      1771 007124      1772 007126      1774 007127      1775 007133
   1776 007135      1777 007137      1778 007140      1779 007143      1780 007145      1784 007147      1785 007152
   1786 007154      1787 007157      1788 007160      1789 007163      1790 007165    6   30 007166      1805 007167
 8   50 007171    8   52 007174    8   53 007175    8   55 007176    8   58 007177    8   60 007202    8   62 007204
 8   63 007230    8   64 007233    8   65 007237    8   68 007247    8   70 007250    8   71 007254    8   73 007256
 8   79 007275    8   84 007306    8   86 007307    8   88 007313    8   90 007314    8   92 007315    8   99 007351
 8  101 007352    8  104 007355    8  106 007360    8  107 007404    8  108 007406    8  109 007411    8  111 007412
 8  113 007413    8  116 007427    8  118 007430    8  120 007434    8  123 007435    8  124 007436    8  126 007442
 8  127 007447    8  128 007453    8  130 007461      1917 007462      1919 007464      1920 007472      1921 007473
   1922 007501      1923 007502      1924 007510      1925 007511      1926 007517      1927 007520      1928 007526
   1929 007527      1930 007535      1931 007536      1932 007544      1933 007545      1934 007553      1935 007554
   1936 007562      1937 007563      1938 007571      1939 007572      1940 007600      1941 007601      1942 007607
   1943 007610      1944 007616      1945 007617      1946 007625      1947 007626      1948 007634      1949 007635
   1950 007643      1951 007644      1952 007652      1953 007653      1954 007661      1955 007662      1956 007670
   1957 007671      1958 007677      1959 007700      1960 007706      1961 007707      1962 007715      1963 007716
   1964 007724      1965 007725      1966 007733      1967 007734      1968 007742      1969 007743      1970 007751
   1971 007752      1972 007760      1973 007761      1974 007767      1975 007770      1976 007776      1977 007777
   1978 010005      1980 010006      1981 010011      1984 010012      1985 010015      1987 010020      1988 010022
   1991 010024      1994 010025      1996 010031      1997 010032      1998 010033      1999 010034      2000 010036
   2002 010037      2004 010043      2005 010044      2006 010045      2007 010046      2008 010050      2010 010051
   2012 010055      2013 010056      2014 010062      2015 010063      2016 010067      2017 010070      2018 010071
   2019 010073      2021 010074      2023 010100      2024 010101      2025 010105      2026 010106      2027 010107
   2028 010110      2029 010112      2031 010113      2033 010117      2034 010120      2035 010124      2036 010125
   2037 010131      2038 010132      2039 010133      2040 010135      2042 010136      2044 010142      2045 010146
   2046 010147      2047 010153      2048 010154      2049 010156      2051 010157      2053 010163      2054 010164
   2055 010170      2056 010171      2057 010173      2059 010174      2061 010200      2062 010201      2063 010205
   2064 010206      2065 010210      2067 010211      2069 010215      2070 010216      2071 010222      2072 010223
   2073 010227      2074 010230      2075 010232      2077 010233      2079 010237      2080 010240      2081 010244
   2082 010245      2083 010246      2084 010250      2086 010251      2088 010255      2089 010256      2090 010257
   2091 010263      2092 010264      2093 010265      2094 010266      2095 010270      2097 010271      2099 010275
   2100 010301      2101 010302      2102 010306      2103 010307      2104 010311      2106 010312      2108 010316
   2109 010317      2110 010323      2111 010324      2112 010326      2114 010327      2116 010333      2117 010334
   2118 010340      2119 010341      2120 010343      2122 010344      2124 010350      2125 010351      2126 010355
   2127 010356      2128 010362      2129 010363      2130 010365      2132 010366      2134 010372      2135 010373
   2136 010377      2137 010400      2138 010402      2140 010403      2142 010407      2143 010410      2144 010414
   2145 010415      2146 010417      2148 010420      2150 010424      2151 010425      2152 010431      2153 010432
   2154 010434      2156 010435      2158 010441      2159 010442      2160 010446      2161 010447      2162 010451
   2164 010452      2166 010456      2167 010457      2168 010463      2169 010464      2170 010466      2172 010467
   2174 010473      2175 010474      2176 010500      2177 010501      2178 010503      2180 010504      2182 010510
   2183 010511      2184 010515      2185 010516      2186 010520      2188 010521      2190 010525      2191 010526
   2192 010532      2193 010533      2194 010535      2196 010536      2198 010542      2199 010543      2200 010547
   2201 010550      2202 010552      2204 010553      2206 010557      2207 010560      2208 010564      2209 010565
   2210 010567      2212 010570      2214 010574      2215 010575      2216 010601      2217 010602      2218 010604
   2220 010605      2222 010607      2224 010610      2226 010613      2227 010616      2228 010623      2229 010626
   2231 010627      2233 010633      2234 010634      2235 010640      2236 010641      2237 010643      2239 010644
   2241 010647      2242 010654      2243 010657      2245 010660      2247 010663      2248 010666      2250 010667
   2253 010670      2255 010674      2256 010700      2257 010701      2258 010705      2259 010706      2261 010707
   2263 010711      2264 010713      2266 010714      2268 010720      2269 010724      2270 010725      2271 010726
   2272 010732      2273 010733      2274 010735      2276 010736      2278 010742      2279 010746      2280 010747
   2281 010750      2282 010752      2284 010753      2286 010757      2287 010760      2288 010764      2289 010765
   2290 010767      2292 010770      2294 010771      2296 010772      2298 010776      2299 010777      2300 011003
   2301 011004      2303 011005      2305 011007      2307 011010      2309 011012      2311 011013      2313 011017
   2314 011027      2315 011033      2316 011034      2317 011040      2318 011041      2319 011043      2321 011044
   2323 011046      2325 011047      2327 011053      2328 011057      2329 011060      2330 011061      2331 011063
   2333 011064      2335 011065      2336 011067      2338 011070      2340 011071      2341 011073      2343 011074
   2345 011075      2346 011077      2348 011100      2350 011101      2351 011103      2353 011104      2355 011105
   2356 011107      2358 011110      2360 011113      2361 011120      2362 011123      2364 011124      2366 011130
   2367 011131      2368 011132      2369 011134      2371 011135      2373 011136      2374 011140    9   31 011141
 9   36 011143    9   37 011145    9   38 011152    9   39 011154    9   40 011167    9   41 011171    9   42 011173
 9   44 011203    9   45 011204    9   47 011217    9   48 011221    9   49 011224    9   51 011226


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
