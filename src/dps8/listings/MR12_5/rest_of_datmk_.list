	COMPILATION LISTING OF SEGMENT rest_of_datmk_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1200.7 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*
       12*   rest_of_datmk_ - segment grower for Multics
       13*   separated from datmk_ on 18 October 1972 by M. Weaver
       14*   and put into hardcore so that the linker could call it for
       15*   create-if-not-found links
       16*
       17*   last modified 1/24/74 by M. Weaver to call datmk_util_ with a code
       18*   11/10/75	by S.Webber to place offset of next available word of storage
       19*   in static for the data segment.
       20**/
       21 /*
       22*
       23*   Calling sequence:
       24*   call rest_of_datmk_ (dsp, a_data_ptr, a_code);
       25*
       26*   Where:
       27*   dsp		= ptr to input structure
       28*   a_data_ptr	= ptr to newly created data item (output)
       29*   a_code		= status code
       30*
       31*   The EPL-compiled argument list appears as follows:
       32*   dec	n	number of words to grow data segment
       33*   dec	x	x = 0, 1, or 2
       34*   ...
       35*
       36*   If "x" = 0, no initialization is to be done.
       37*   If "x" = 1, the third location points to the initialization procedure.
       38*   If "x" = 2, the third location is the first location of
       39*   the initialization procedure.
       40*
       41*
       42*   The PL/1-compiled argument list appears as follows:
       43*   dec	n	number of words to grow data segment
       44*   dec	x	x = 0, 3, or 4
       45*   ...
       46*
       47*   If "x" = 0, no initialization is to be done.
       48*   If "x" = 3, the third location is the first of n words which must
       49*   be copied into the newly-grown space to initialize it.
       50*   If "x" = 4, the newly-grown space must be initialized as an area.
       51*   There is no third argument.
       52*
       53*   */
       54 
       55 /*  */
       56 
       57 rest_of_datmk_: proc (dsp, a_data_ptr, a_code);
       58 
       59 declare (dsp, a_data_ptr, data_ptr, link_ptr, static_ptr) pointer;
       60 
       61 declare  seg char (32);				/* name of data segment */
       62 
       63 declare  rcode fixed bin (35);			/* status code */
       64 declare  a_code fixed bin (35);
       65 declare  temp fixed bin;				/* temp for mod 8 rounding */
       66 declare  value fixed bin (18);			/* offset of new symbol */
       67 declare  nwords fixed bin (18);			/* number of words of data needed */
       68 declare  fixed_18 fixed bin (18) based;			/* fixed bin(18) variable */
       69 declare  code fixed bin;				/* initialization code */
       70 
       71 declare (error_table_$no_linkage, error_table_$bad_link_target_init_info,
       72          error_table_$noalloc, error_table_$defs_loop) ext fixed bin (35);
       73 declare  sys_info$max_seg_size ext fixed bin (35);
       74 
       75 declare  move_array (nwords) fixed bin based;
       76 
       77 declare (addr, baseno, size, bit, bin, mod, null, ptr) builtin;
       78 
       79 declare 1 arg_list based (arg_list_ptr) aligned,		/* declaration for datmk_ argument list */
       80         2 nwords fixed bin (18),			/* number of words to grow segment */
       81         2 code fixed bin (17),			/* initialization code */
       82         2 y bit (18);
       83 
       84 declare  make_seg ext entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
       85 declare  link_man$get_lp ext entry (ptr, ptr);
       86 declare  link_man$set_lp ext entry (ptr, ptr);
       87 declare  datmk_util_$add_linkage_definition ext entry (ptr, ptr, fixed bin (18), fixed bin);
       88 declare  area_ ext entry (fixed bin (18), ptr);
       89 declare  level$get entry () returns (fixed bin);
       90 
       91 declare 1 datmk_info aligned based (dsp),		/* input structure */
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... datmk_info.incl.pl1 */
  1     3 /* created on 18 October 1972 by M. Weaver */
  1     4 
  1     5 	2 arg_list_ptr ptr,			/* ptr to datmk_ "argument list" */
  1     6 	2 text_ptr ptr,			/* ptr to data segment to be grown */
  1     7 	2 sym_ptr ptr,			/* ptr to ext symbol name which is to be added */
  1     8 	2 segname char(32) var;		/* seg name of data segment */
  1     9 
  1    10 /* END INCLUDE FILE ... datmk_info.incl.pl1 */
       92 
       93 
       94 /*  */
       95 
  2     1 /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  2     2 
  2     3 /* Last Modified (Date and Reason):
  2     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  2     5*   6/75 by S.Webber to comment existing structures better
  2     6*   9/77 by M. Weaver to add run_depth to link
  2     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  2     8**/
  2     9 
  2    10 /* format: style3 */
  2    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  2    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  2    13 	  2 ringno	bit (3) unal,
  2    14 	  2 mbz		bit (6) unal,
  2    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  2    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  2    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  2    18 	  2 mbz2		bit (12) unal,
  2    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  2    20 
  2    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  2    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  2    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  2    24 
  2    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  2    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  2    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  2    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  2    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  2    30 
  2    31 dcl	1 header		based aligned,		/* linkage block header */
  2    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  2    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  2    34 	  2 original_linkage_ptr
  2    35 			ptr unal,			/* pointer to linkage section in object segment */
  2    36 	  2 unused	bit (72),
  2    37 	  2 stats,
  2    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  2    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  2    40 	    3 segment_number
  2    41 			bit (18) unal,		/* text segment number associated with this section */
  2    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  2    43 
  2    44 dcl	1 linkage_header_flags
  2    45 			aligned based,		/* overlay of def_ptr for flags */
  2    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  2    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  2    48 	  2 perprocess_static
  2    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  2    50 	  2 pad2		bit (6) unaligned;
  2    51 
  2    52 dcl	1 virgin_linkage_header
  2    53 			aligned based,		/* template for linkage header in object segment */
  2    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  2    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  2    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  2    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  2    58 	  2 filled_in_later bit (144),
  2    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  2    60 	  2 linkage_section_lng
  2    61 			bit (18) unaligned,		/* length of linkage section */
  2    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  2    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  2    64 
  2    65 
  2    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  2    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  2    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  2    69 
  2    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  2    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  2    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  2    73 
  2    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
       96 
       97 
  3     1 /* BEGIN INCLUDE FILE its.incl.pl1
  3     2*   modified 27 July 79 by JRDavis to add its_unsigned
  3     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  3     4 
  3     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  3     6     2 pad1 bit (3) unaligned,
  3     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  3     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  3     9     2 pad2 bit (9) unaligned,
  3    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  3    11 
  3    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  3    13     2 pad3 bit (3) unaligned,
  3    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  3    15     2 pad4 bit (3) unaligned,
  3    16     2 mod bit (6) unaligned;				/* further modification */
  3    17 
  3    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  3    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  3    20     2 pad1 bit (27) unaligned,
  3    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  3    22 
  3    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  3    24     2 pad2 bit (3) unaligned,
  3    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  3    26     2 pad3 bit (3) unaligned,
  3    27     2 mod bit (6) unaligned;				/* further modification */
  3    28 
  3    29 
  3    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  3    31     2 pad1 bit (3) unaligned,
  3    32     2 segno fixed bin (15) unsigned unaligned,
  3    33     2 ringno fixed bin (3) unsigned unaligned,
  3    34     2 pad2 bit (9) unaligned,
  3    35     2 its_mod bit (6) unaligned,
  3    36 
  3    37     2 offset fixed bin (18) unsigned unaligned,
  3    38     2 pad3 bit (3) unaligned,
  3    39     2 bit_offset fixed bin (6) unsigned unaligned,
  3    40     2 pad4 bit (3) unaligned,
  3    41     2 mod bit (6) unaligned;
  3    42 
  3    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  3    44     2 pr_no fixed bin (3) unsigned unaligned,
  3    45     2 pad1 bit (27) unaligned,
  3    46     2 itp_mod bit (6) unaligned,
  3    47 
  3    48     2 offset fixed bin (18) unsigned unaligned,
  3    49     2 pad2 bit (3) unaligned,
  3    50     2 bit_offset fixed bin (6) unsigned unaligned,
  3    51     2 pad3 bit (3) unaligned,
  3    52     2 mod bit (6) unaligned;
  3    53 
  3    54 
  3    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  3    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  3    57 
  3    58 /* END INCLUDE FILE   its.incl.pl1 */
       98 
       99 
      100 /*  */
      101          a_data_ptr = null;				/* initialize output parameters */
      102 	a_code = 0;
      103 
      104 /* Step 1.
      105*   Get pointer to data segment's associated linkage section.
      106*   If it does not exist, create and initialize it
      107*   */
      108 
      109 
      110 	call link_man$get_lp (text_ptr, link_ptr);	/* Get a pointer to linkage segment. */
      111 	if link_ptr = null then do;			/* If linkage segment not found ... */
      112 	     seg = datmk_info.segname || ".link";	/* create name of linkage segment */
      113 	     call make_seg ("", "", seg, 01010b, link_ptr, rcode);
      114 						/* Create the linkage segment. */
      115 	     if link_ptr = null then do;
      116 		a_code = error_table_$no_linkage;
      117 		return;				/* nothing more we can do */
      118 	     end;
      119 	     link_ptr -> header.def_ptr = ptr (link_ptr, size (header)+2); /* 2 words are for static */
      120 						/* Set definitions pointer in linkage block header. */
      121 	     link_ptr -> header.stats.block_length = bit (bin (size (header)+1+2, 18), 18);
      122 						/* 2 words are for static */
      123 	     link_ptr -> header.stats.segment_number = baseno (text_ptr);
      124 	     call link_man$set_lp (text_ptr, link_ptr);	/* Set linkage pointer in the LOT. */
      125 	end;
      126 	addr (link_ptr) -> its.ringno = bit (bin (level$get (), 3), 3);
      127 						/* set ringno so won't clobber ring 0 seg */
      128 
      129 	static_ptr = ptr (link_ptr, size (header));	/* get pointer to static where next offset is kept */
      130 
      131 /* Step 2.
      132*   Determine value of the new definition from the value
      133*   maintained in the first word of static for the segment.
      134*
      135*   */
      136 
      137 	value = static_ptr -> fixed_18;		/* Pick up value of new definition. */
      138 	nwords = arg_list_ptr -> arg_list.nwords;	/* Extract the number of words needed. */
      139 	code = arg_list_ptr -> arg_list.code;		/* Extract initialization code from argument list. */
      140 
      141 	if code = 4				/* PL/1 area */
      142 	then do;
      143 	     temp = mod (value, 8);			/* use mod 8 boundary */
      144 	     if temp ^= 0 then value = value + 8 - temp;
      145 	end;
      146 	else if nwords > 1 then do;			/* be sure item starts on even word boundary */
      147 	     if mod (value, 2) ^= 0 then value = value + 1;
      148 	end;
      149 
      150 	if (value+nwords) > sys_info$max_seg_size then do; /* new item will overflow segment */
      151 	     a_code = error_table_$noalloc;
      152 	     return;
      153 	end;
      154 
      155 
      156 
      157 /* Step 3.
      158*   Determine if initialization is required.  If so, take care of it.
      159*   Step the value in the first word by the number of words
      160*   needed to grow the data item.
      161*
      162*   */
      163 
      164 	a_data_ptr,
      165 	     data_ptr = ptr (text_ptr, value);		/* Generate a pointer to the data */
      166 
      167 	if code ^= 0 then do;			/* If non-zero, then initialization is required. */
      168 	     if code = 3 then			/* If 3 ... */
      169 		data_ptr -> move_array = addr (arg_list_ptr -> arg_list.y) -> move_array;
      170 						/* Move words from calling proc to init variable. */
      171 	     else if code = 4 then			/* If 4 ... */
      172 		call area_ (nwords, data_ptr);	/* Initialize as an area. */
      173 	     else do;
      174 		a_code = error_table_$bad_link_target_init_info; /* Otherwise, argument list is in error */
      175 		return;
      176 	     end;
      177 
      178 	end;
      179 
      180 	static_ptr -> fixed_18 = value + nwords;	/* Step the saved value by number of words needed. */
      181 
      182 
      183 /* Step 4.
      184*   Add the new symbol definition to the linkage section.
      185*
      186*   */
      187 
      188 	if sym_ptr ^= null then do;
      189 	     call datmk_util_$add_linkage_definition (link_ptr, sym_ptr, value, code);
      190 						/* The code is much simpler in machine language. */
      191 	     if code ^= 0 then do;			/* couldn't add def */
      192 		a_code = error_table_$defs_loop;	/* because couldn't find proper block */
      193 		static_ptr -> fixed_18 = value - nwords; /* pretend nothing was added */
      194 		a_data_ptr = null;
      195 	     end;
      196 	end;
      197 
      198 	return;					/* All finished. Return. */
      199 
      200      end rest_of_datmk_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1005.6  rest_of_datmk_.pl1                >special_ldd>hard>41-5>rest_of_datmk_.pl1
92           1    05/06/74  1741.1  datmk_info.incl.pl1               >ldd>include>datmk_info.incl.pl1
96           2    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
98           3    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 57 102* 116* 151* 174* 192*
a_data_ptr                             parameter       pointer                  dcl 59 set ref 57 101* 164* 194*
addr                                                   builtin function         dcl 77 ref 126 168
area_                           000032 constant        entry                    external dcl 88 ref 171
arg_list                               based           structure                level 1 dcl 79
arg_list_ptr                           based           pointer                  level 2 dcl 91 ref 138 139 168
baseno                                                 builtin function         dcl 77 ref 123
bin                                                    builtin function         dcl 77 ref 121 126
bit                                                    builtin function         dcl 77 ref 121 126
block_length              6(18)        based           bit(18)                  level 3 packed unaligned dcl 2-31 set ref 121*
code                      1            based           fixed bin(17,0)          level 2 in structure "arg_list" dcl 79 in procedure
                                                                                  "rest_of_datmk_" ref 139
code                            000122 automatic       fixed bin(17,0)          dcl 69 in procedure "rest_of_datmk_" set ref 139*
                                                                                  141 167 168 171 189* 191
data_ptr                        000100 automatic       pointer                  dcl 59 set ref 164* 168 171*
datmk_info                             based           structure                level 1 dcl 91
datmk_util_$add_linkage_definition
                                000030 constant        entry                    external dcl 87 ref 189
def_ptr                                based           pointer                  level 2 dcl 2-31 set ref 119*
dsp                                    parameter       pointer                  dcl 59 ref 57 110 112 123 124 138 139 164 168 188
                                                                                  189
error_table_$bad_link_target_init_info
                                000012 external static fixed bin(35,0)          dcl 71 ref 174
error_table_$defs_loop          000016 external static fixed bin(35,0)          dcl 71 ref 192
error_table_$no_linkage         000010 external static fixed bin(35,0)          dcl 71 ref 116
error_table_$noalloc            000014 external static fixed bin(35,0)          dcl 71 ref 151
fixed_18                               based           fixed bin(18,0)          dcl 68 set ref 137 180* 193*
header                                 based           structure                level 1 dcl 2-31 set ref 119 121 129
its                                    based           structure                level 1 dcl 3-5
level$get                       000034 constant        entry                    external dcl 89 ref 126
link_man$get_lp                 000024 constant        entry                    external dcl 85 ref 110
link_man$set_lp                 000026 constant        entry                    external dcl 86 ref 124
link_ptr                        000102 automatic       pointer                  dcl 59 set ref 110* 111 113* 115 119 119 121 123
                                                                                  124* 126 129 189*
make_seg                        000022 constant        entry                    external dcl 84 ref 113
mod                                                    builtin function         dcl 77 ref 143 147
move_array                             based           fixed bin(17,0)          array dcl 75 set ref 168* 168
null                                                   builtin function         dcl 77 ref 101 111 115 188 194
nwords                                 based           fixed bin(18,0)          level 2 in structure "arg_list" dcl 79 in procedure
                                                                                  "rest_of_datmk_" ref 138
nwords                          000121 automatic       fixed bin(18,0)          dcl 67 in procedure "rest_of_datmk_" set ref 138*
                                                                                  146 150 168 171* 180 193
ptr                                                    builtin function         dcl 77 ref 119 129 164
rcode                           000116 automatic       fixed bin(35,0)          dcl 63 set ref 113*
ringno                    0(18)        based           bit(3)                   level 2 packed unaligned dcl 3-5 set ref 126*
seg                             000106 automatic       char(32)                 unaligned dcl 61 set ref 112* 113*
segment_number            7            based           bit(18)                  level 3 packed unaligned dcl 2-31 set ref 123*
segname                   6            based           varying char(32)         level 2 dcl 91 ref 112
size                                                   builtin function         dcl 77 ref 119 121 129
static_ptr                      000104 automatic       pointer                  dcl 59 set ref 129* 137 180 193
stats                     6            based           structure                level 2 dcl 2-31
sym_ptr                   4            based           pointer                  level 2 dcl 91 set ref 188 189*
sys_info$max_seg_size           000020 external static fixed bin(35,0)          dcl 73 ref 150
temp                            000117 automatic       fixed bin(17,0)          dcl 65 set ref 143* 144 144
text_ptr                  2            based           pointer                  level 2 dcl 91 set ref 110* 123 124* 164
value                           000120 automatic       fixed bin(18,0)          dcl 66 set ref 137* 143 144* 144 147 147* 147 150
                                                                                  164 180 189* 193
y                         2            based           bit(18)                  level 2 dcl 79 set ref 168

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-55
exp_word                               based           structure                level 1 dcl 2-21
itp                                    based           structure                level 1 dcl 3-18
itp_unsigned                           based           structure                level 1 dcl 3-43
its_unsigned                           based           structure                level 1 dcl 3-30
link                                   based           structure                level 1 dcl 2-11
linkage_header_flags                   based           structure                level 1 dcl 2-44
name                                   based           structure                level 1 dcl 2-70
trap_word                              based           structure                level 1 dcl 2-66
type_pair                              based           structure                level 1 dcl 2-25
virgin_linkage_header                  based           structure                level 1 dcl 2-52

NAME DECLARED BY EXPLICIT CONTEXT.
rest_of_datmk_                  000016 constant        entry                    external dcl 57

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       540         576     370         550
Length      1026     370        36         214     150           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rest_of_datmk_                      120 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rest_of_datmk_           000100 data_ptr                    rest_of_datmk_
                         000102 link_ptr                    rest_of_datmk_
                         000104 static_ptr                  rest_of_datmk_
                         000106 seg                         rest_of_datmk_
                         000116 rcode                       rest_of_datmk_
                         000117 temp                        rest_of_datmk_
                         000120 value                       rest_of_datmk_
                         000121 nwords                      rest_of_datmk_
                         000122 code                        rest_of_datmk_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              mod_fx1             shorten_stack
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_                         datmk_util_$add_linkage_definition                          level$get
link_man$get_lp               link_man$set_lp               make_seg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_link_target_init_info                      error_table_$defs_loop        error_table_$no_linkage
error_table_$noalloc          sys_info$max_seg_size


CONSTANTS
000366  aa     000000000010

000000  aa     404000000005

000001  aa     526000000040

000002  aa     524000000000

000003  aa     404000000021

000004  aa     404000000043

000367  aa     000000000002

000005  aa     464000000000

000006  aa  056 154 151 156	.lin
000007  aa  153 000 000 000	k

000010  aa     077777000043
000011  aa     000001000000

BEGIN PROCEDURE rest_of_datmk_
ENTRY TO rest_of_datmk_                                     STATEMENT 1 ON LINE 57
rest_of_datmk_: proc (dsp, a_data_ptr, a_code);

000012  at     000003000005
000013  tt     000005000004
000014  ta     000012000000
000015  da     000144300000
000016  aa   000200 6270 00	eax7 	128
000017  aa  7 00034 3521 20	epp2 	pr7|28,*
000020  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000021  aa     000006000000
000022  aa     000000000000
						STATEMENT 1 ON LINE 101
         a_data_ptr = null;

000023  aa   777765 2370 04	ldaq 	-11,ic		000010 = 077777000043 000001000000
000024  aa  6 00032 3735 20	epp7 	pr6|26,*
000025  aa  7 00004 7571 20	staq 	pr7|4,*		a_data_ptr
						STATEMENT 1 ON LINE 102
	a_code = 0;

000026  aa  7 00006 4501 20	stz  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 110
	call link_man$get_lp (text_ptr, link_ptr);

000027  aa  7 00002 3715 20	epp5 	pr7|2,*		dsp
000030  aa  5 00000 3715 20	epp5 	pr5|0,*		dsp
000031  aa  5 00002 3521 00	epp2 	pr5|2		datmk_info.text_ptr
000032  aa  6 00126 2521 00	spri2	pr6|86
000033  aa  6 00102 3521 00	epp2 	pr6|66		link_ptr
000034  aa  6 00130 2521 00	spri2	pr6|88
000035  aa  6 00124 6211 00	eax1 	pr6|84
000036  aa   010000 4310 07	fld  	4096,dl
000037  la  4 00024 3521 20	epp2 	pr4|20,*		link_man$get_lp
000040  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 111
	if link_ptr = null then do;

000041  aa  6 00102 2371 00	ldaq 	pr6|66		link_ptr
000042  aa   777746 6770 04	eraq 	-26,ic		000010 = 077777000043 000001000000
000043  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000044  aa   000125 6010 04	tnz  	85,ic		000171
						STATEMENT 1 ON LINE 112
	     seg = datmk_info.segname || ".link";

000045  aa  6 00032 3735 20	epp7 	pr6|26,*
000046  aa  7 00002 3715 20	epp5 	pr7|2,*		dsp
000047  aa  5 00000 3715 20	epp5 	pr5|0,*		dsp
000050  aa  5 00006 2361 00	ldq  	pr5|6		datmk_info.segname
000051  aa   000005 0760 07	adq  	5,dl
000052  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
000053  aa  5 00006 7271 00	lxl7 	pr5|6		datmk_info.segname
000054  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000055  aa  5 00007 00 0017	desc9a	pr5|7,x7		datmk_info.segname
000056  aa  2 00000 00 0017	desc9a	pr2|0,x7
000057  aa  5 00006 7271 00	lxl7 	pr5|6		datmk_info.segname
000060  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
000061  aa   777726 00 0005	desc9a	-42,5		000006 = 056154151156
000062  aa  2 00000 00 0005	desc9a	pr2|0,5
000063  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000064  aa  2 00000 00 0006	desc9a	pr2|0,ql
000065  aa  6 00106 00 0040	desc9a	pr6|70,32		seg
						STATEMENT 1 ON LINE 113
	     call make_seg ("", "", seg, 01010b, link_ptr, rcode);

000066  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000067  aa   000012 2360 07	ldq  	10,dl
000070  aa  6 00133 7561 00	stq  	pr6|91
000071  aa  6 00123 3521 00	epp2 	pr6|83
000072  aa  6 00136 2521 00	spri2	pr6|94
000073  aa  6 00132 3521 00	epp2 	pr6|90
000074  aa  6 00140 2521 00	spri2	pr6|96
000075  aa  6 00106 3521 00	epp2 	pr6|70		seg
000076  aa  6 00142 2521 00	spri2	pr6|98
000077  aa  6 00133 3521 00	epp2 	pr6|91
000100  aa  6 00144 2521 00	spri2	pr6|100
000101  aa  6 00102 3521 00	epp2 	pr6|66		link_ptr
000102  aa  6 00146 2521 00	spri2	pr6|102
000103  aa  6 00116 3521 00	epp2 	pr6|78		rcode
000104  aa  6 00150 2521 00	spri2	pr6|104
000105  aa   777675 3520 04	epp2 	-67,ic		000002 = 524000000000
000106  aa  6 00152 2521 00	spri2	pr6|106
000107  aa  6 00154 2521 00	spri2	pr6|108
000110  aa   777671 3520 04	epp2 	-71,ic		000001 = 526000000040
000111  aa  6 00156 2521 00	spri2	pr6|110
000112  aa   777666 3520 04	epp2 	-74,ic		000000 = 404000000005
000113  aa  6 00160 2521 00	spri2	pr6|112
000114  aa   777671 3520 04	epp2 	-71,ic		000005 = 464000000000
000115  aa  6 00162 2521 00	spri2	pr6|114
000116  aa   777666 3520 04	epp2 	-74,ic		000004 = 404000000043
000117  aa  6 00164 2521 00	spri2	pr6|116
000120  aa  6 00134 6211 00	eax1 	pr6|92
000121  aa   030000 4310 07	fld  	12288,dl
000122  aa  6 00044 3701 20	epp4 	pr6|36,*
000123  la  4 00022 3521 20	epp2 	pr4|18,*		make_seg
000124  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 115
	     if link_ptr = null then do;

000125  aa  6 00102 2371 00	ldaq 	pr6|66		link_ptr
000126  aa   777662 6770 04	eraq 	-78,ic		000010 = 077777000043 000001000000
000127  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000130  aa   000006 6010 04	tnz  	6,ic		000136
						STATEMENT 1 ON LINE 116
		a_code = error_table_$no_linkage;

000131  aa  6 00044 3701 20	epp4 	pr6|36,*
000132  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$no_linkage
000133  aa  6 00032 3735 20	epp7 	pr6|26,*
000134  aa  7 00006 7561 20	stq  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 117
		return;

000135  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 118
	     end;

						STATEMENT 1 ON LINE 119
	     link_ptr -> header.def_ptr = ptr (link_ptr, size (header)+2);

000136  aa   000012 2360 07	ldq  	10,dl
000137  aa  6 00102 3521 20	epp2 	pr6|66,*		link_ptr
000140  aa   000000 3120 06	eawp2	0,ql
000141  aa  6 00102 2521 20	spri2	pr6|66,*		header.def_ptr
						STATEMENT 1 ON LINE 121
	     link_ptr -> header.stats.block_length = bit (bin (size (header)+1+2, 18), 18);

000142  aa   000013 2360 07	ldq  	11,dl
000143  aa   000003 6050 04	tpl  	3,ic		000146
000144  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
000145  aa   000001 0760 07	adq  	1,dl
000146  aa   000066 7370 00	lls  	54
000147  aa   000022 7730 00	lrl  	18
000150  aa  6 00102 3735 20	epp7 	pr6|66,*		link_ptr
000151  aa  7 00006 5511 14	stba 	pr7|6,14		header.block_length
						STATEMENT 1 ON LINE 123
	     link_ptr -> header.stats.segment_number = baseno (text_ptr);

000152  aa  6 00032 3715 20	epp5 	pr6|26,*
000153  aa  5 00002 3535 20	epp3 	pr5|2,*		dsp
000154  aa  3 00000 3535 20	epp3 	pr3|0,*		dsp
000155  aa  3 00002 2131 20	epaq 	pr3|2,*		datmk_info.text_ptr
000156  aa   077777 3750 03	ana  	32767,du
000157  aa  7 00007 5511 60	stba 	pr7|7,60		header.segment_number
						STATEMENT 1 ON LINE 124
	     call link_man$set_lp (text_ptr, link_ptr);

000160  aa  3 00002 3521 00	epp2 	pr3|2		datmk_info.text_ptr
000161  aa  6 00126 2521 00	spri2	pr6|86
000162  aa  6 00102 3521 00	epp2 	pr6|66		link_ptr
000163  aa  6 00130 2521 00	spri2	pr6|88
000164  aa  6 00124 6211 00	eax1 	pr6|84
000165  aa   010000 4310 07	fld  	4096,dl
000166  aa  6 00044 3701 20	epp4 	pr6|36,*
000167  la  4 00026 3521 20	epp2 	pr4|22,*		link_man$set_lp
000170  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 125
	end;

						STATEMENT 1 ON LINE 126
	addr (link_ptr) -> its.ringno = bit (bin (level$get (), 3), 3);

000171  aa  6 00133 3521 00	epp2 	pr6|91
000172  aa  6 00126 2521 00	spri2	pr6|86
000173  aa  6 00124 6211 00	eax1 	pr6|84
000174  aa   004000 4310 07	fld  	2048,dl
000175  aa  6 00044 3701 20	epp4 	pr6|36,*
000176  la  4 00034 3521 20	epp2 	pr4|28,*		level$get
000177  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000200  aa  6 00133 2351 00	lda  	pr6|91
000201  aa   000002 6050 04	tpl  	2,ic		000203
000202  aa   000000 5310 00	neg  	0
000203  aa   000041 7350 00	als  	33
000204  aa   000022 7710 00	arl  	18
000205  aa  6 00102 6751 00	era  	pr6|66		its.ringno
000206  aa   700000 3750 07	ana  	229376,dl
000207  aa  6 00102 6551 00	ersa 	pr6|66		its.ringno
						STATEMENT 1 ON LINE 129
	static_ptr = ptr (link_ptr, size (header));

000210  aa  6 00102 3521 20	epp2 	pr6|66,*		link_ptr
000211  aa   000010 3120 00	eawp2	8
000212  aa  6 00104 2521 00	spri2	pr6|68		static_ptr
						STATEMENT 1 ON LINE 137
	value = static_ptr -> fixed_18;

000213  aa  2 00000 2361 00	ldq  	pr2|0		fixed_18
000214  aa  6 00120 7561 00	stq  	pr6|80		value
						STATEMENT 1 ON LINE 138
	nwords = arg_list_ptr -> arg_list.nwords;

000215  aa  6 00032 3735 20	epp7 	pr6|26,*
000216  aa  7 00002 3715 20	epp5 	pr7|2,*		dsp
000217  aa  5 00000 3535 20	epp3 	pr5|0,*		datmk_info.arg_list_ptr
000220  aa  3 00000 2361 20	ldq  	pr3|0,*		arg_list.nwords
000221  aa  6 00121 7561 00	stq  	pr6|81		nwords
						STATEMENT 1 ON LINE 139
	code = arg_list_ptr -> arg_list.code;

000222  aa  3 00000 3515 20	epp1 	pr3|0,*		datmk_info.arg_list_ptr
000223  aa  1 00001 2361 00	ldq  	pr1|1		arg_list.code
000224  aa  6 00122 7561 00	stq  	pr6|82		code
						STATEMENT 1 ON LINE 141
	if code = 4				/* PL/1 area */
	then do;

000225  aa   000004 1160 07	cmpq 	4,dl
000226  aa   000013 6010 04	tnz  	11,ic		000241
						STATEMENT 1 ON LINE 143
	     temp = mod (value, 8);

000227  aa  6 00120 2361 00	ldq  	pr6|80		value
000230  aa   000136 3520 04	epp2 	94,ic		000366 = 000000000010
000231  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000232  aa  6 00117 7561 00	stq  	pr6|79		temp
						STATEMENT 1 ON LINE 144
	     if temp ^= 0 then value = value + 8 - temp;

000233  aa   000016 6000 04	tze  	14,ic		000251
000234  aa  6 00120 2361 00	ldq  	pr6|80		value
000235  aa  2 00000 0761 00	adq  	pr2|0
000236  aa  6 00117 1761 00	sbq  	pr6|79		temp
000237  aa  6 00120 7561 00	stq  	pr6|80		value
						STATEMENT 1 ON LINE 145
	end;

000240  aa   000011 7100 04	tra  	9,ic		000251
						STATEMENT 1 ON LINE 146
	else if nwords > 1 then do;

000241  aa  6 00121 2361 00	ldq  	pr6|81		nwords
000242  aa   000001 1160 07	cmpq 	1,dl
000243  aa   000006 6044 04	tmoz 	6,ic		000251
						STATEMENT 1 ON LINE 147
	     if mod (value, 2) ^= 0 then value = value + 1;

000244  aa  6 00120 2361 00	ldq  	pr6|80		value
000245  aa   000122 3520 04	epp2 	82,ic		000367 = 000000000002
000246  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000247  aa   000002 6000 04	tze  	2,ic		000251
000250  aa  6 00120 0541 00	aos  	pr6|80		value
						STATEMENT 1 ON LINE 148
	end;

						STATEMENT 1 ON LINE 150
	if (value+nwords) > sys_info$max_seg_size then do;

000251  aa  6 00120 2361 00	ldq  	pr6|80		value
000252  aa  6 00121 0761 00	adq  	pr6|81		nwords
000253  aa  6 00044 3701 20	epp4 	pr6|36,*
000254  la  4 00020 1161 20	cmpq 	pr4|16,*		sys_info$max_seg_size
000255  aa   000004 6044 04	tmoz 	4,ic		000261
						STATEMENT 1 ON LINE 151
	     a_code = error_table_$noalloc;

000256  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$noalloc
000257  aa  7 00006 7561 20	stq  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 152
	     return;

000260  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 153
	end;

						STATEMENT 1 ON LINE 164
	a_data_ptr,
	     data_ptr = ptr (text_ptr, value);

000261  aa  6 00120 2361 00	ldq  	pr6|80		value
000262  aa  5 00000 3515 20	epp1 	pr5|0,*		dsp
000263  aa  1 00002 3521 20	epp2 	pr1|2,*		datmk_info.text_ptr
000264  aa   000000 3120 06	eawp2	0,ql
000265  aa  6 00166 2521 00	spri2	pr6|118
000266  aa  7 00004 2521 20	spri2	pr7|4,*		a_data_ptr
000267  aa  6 00100 2521 00	spri2	pr6|64		data_ptr
						STATEMENT 1 ON LINE 167
	if code ^= 0 then do;

000270  aa  6 00122 2361 00	ldq  	pr6|82		code
000271  aa   000032 6000 04	tze  	26,ic		000323
						STATEMENT 1 ON LINE 168
	     if code = 3 then			/* If 3 ... */
		data_ptr -> move_array = addr (arg_list_ptr -> arg_list.y) -> move_array;

000272  aa   000003 1160 07	cmpq 	3,dl
000273  aa   000012 6010 04	tnz  	10,ic		000305
000274  aa  6 00121 2361 00	ldq  	pr6|81		nwords
000275  aa   000002 7360 00	qls  	2
000276  aa  7 00002 3515 20	epp1 	pr7|2,*		dsp
000277  aa  1 00000 3535 20	epp3 	pr1|0,*		datmk_info.arg_list_ptr
000300  aa  3 00000 3535 20	epp3 	pr3|0,*		datmk_info.arg_list_ptr
000301  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
000302  aa  3 00002 00 0006	desc9a	pr3|2,ql		move_array
000303  aa  2 00000 00 0006	desc9a	pr2|0,ql		move_array
000304  aa   000017 7100 04	tra  	15,ic		000323
						STATEMENT 1 ON LINE 171
	     else if code = 4 then			/* If 4 ... */
		call area_ (nwords, data_ptr);

000305  aa   000004 1160 07	cmpq 	4,dl
000306  aa   000012 6010 04	tnz  	10,ic		000320
000307  aa  6 00121 3521 00	epp2 	pr6|81		nwords
000310  aa  6 00126 2521 00	spri2	pr6|86
000311  aa  6 00100 3521 00	epp2 	pr6|64		data_ptr
000312  aa  6 00130 2521 00	spri2	pr6|88
000313  aa  6 00124 6211 00	eax1 	pr6|84
000314  aa   010000 4310 07	fld  	4096,dl
000315  la  4 00032 3521 20	epp2 	pr4|26,*		area_
000316  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000317  aa   000004 7100 04	tra  	4,ic		000323
						STATEMENT 1 ON LINE 173
	     else do;

						STATEMENT 1 ON LINE 174
		a_code = error_table_$bad_link_target_init_info;

000320  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$bad_link_target_init_info
000321  aa  7 00006 7561 20	stq  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 175
		return;

000322  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 176
	     end;

						STATEMENT 1 ON LINE 178
	end;

						STATEMENT 1 ON LINE 180
	static_ptr -> fixed_18 = value + nwords;

000323  aa  6 00120 2361 00	ldq  	pr6|80		value
000324  aa  6 00121 0761 00	adq  	pr6|81		nwords
000325  aa  6 00104 7561 20	stq  	pr6|68,*		fixed_18
						STATEMENT 1 ON LINE 188
	if sym_ptr ^= null then do;

000326  aa  6 00032 3735 20	epp7 	pr6|26,*
000327  aa  7 00002 3715 20	epp5 	pr7|2,*		dsp
000330  aa  5 00000 3715 20	epp5 	pr5|0,*		dsp
000331  aa  5 00004 2371 00	ldaq 	pr5|4		datmk_info.sym_ptr
000332  aa   777456 6770 04	eraq 	-210,ic		000010 = 077777000043 000001000000
000333  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000334  aa   000031 6000 04	tze  	25,ic		000365
						STATEMENT 1 ON LINE 189
	     call datmk_util_$add_linkage_definition (link_ptr, sym_ptr, value, code);

000335  aa  6 00102 3521 00	epp2 	pr6|66		link_ptr
000336  aa  6 00136 2521 00	spri2	pr6|94
000337  aa  5 00004 3521 00	epp2 	pr5|4		datmk_info.sym_ptr
000340  aa  6 00140 2521 00	spri2	pr6|96
000341  aa  6 00120 3521 00	epp2 	pr6|80		value
000342  aa  6 00142 2521 00	spri2	pr6|98
000343  aa  6 00122 3521 00	epp2 	pr6|82		code
000344  aa  6 00144 2521 00	spri2	pr6|100
000345  aa  6 00134 6211 00	eax1 	pr6|92
000346  aa   020000 4310 07	fld  	8192,dl
000347  aa  6 00044 3701 20	epp4 	pr6|36,*
000350  la  4 00030 3521 20	epp2 	pr4|24,*		datmk_util_$add_linkage_definition
000351  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 191
	     if code ^= 0 then do;

000352  aa  6 00122 2361 00	ldq  	pr6|82		code
000353  aa   000012 6000 04	tze  	10,ic		000365
						STATEMENT 1 ON LINE 192
		a_code = error_table_$defs_loop;

000354  aa  6 00044 3701 20	epp4 	pr6|36,*
000355  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$defs_loop
000356  aa  6 00032 3735 20	epp7 	pr6|26,*
000357  aa  7 00006 7561 20	stq  	pr7|6,*		a_code
						STATEMENT 1 ON LINE 193
		static_ptr -> fixed_18 = value - nwords;

000360  aa  6 00120 2361 00	ldq  	pr6|80		value
000361  aa  6 00121 1761 00	sbq  	pr6|81		nwords
000362  aa  6 00104 7561 20	stq  	pr6|68,*		fixed_18
						STATEMENT 1 ON LINE 194
		a_data_ptr = null;

000363  aa   777425 2370 04	ldaq 	-235,ic		000010 = 077777000043 000001000000
000364  aa  7 00004 7571 20	staq 	pr7|4,*		a_data_ptr
						STATEMENT 1 ON LINE 195
	     end;

						STATEMENT 1 ON LINE 196
	end;

						STATEMENT 1 ON LINE 198
	return;

000365  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 200
     end rest_of_datmk_;

  END PROCEDURE rest_of_datmk_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
