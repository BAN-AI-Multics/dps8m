	COMPILATION LISTING OF SEGMENT fs_get
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 08/21/90  1449.2 mdt Tue
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
       17*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
       18*     Remove the include of kst.incl.pl1, since reference to variables in the
       19*     program was removed in an early release.
       20*  2) change(86-08-20,Lippard), approve(86-09-08,MCR7539),
       21*     audit(86-10-15,Farley), install(86-10-20,MR12.0-1189):
       22*     Modified by Jim Lippard to fix ref names allocation bug, fix supplied
       23*     by Steve Harris (UNCA).
       24*  3) change(90-07-26,WAAnderson), approve(90-07-26,MCR8182),
       25*     audit(90-08-10,Schroth), install(90-08-21,MR12.4-1030):
       26*     Replaced call to ref_name_$get_refnames with call to
       27*     ref_name_$get_refname.  This change reduces stack space requirements
       28*     and corrects the list_ref_names infinite loop bug.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       33 
       34 fs_get: proc;
       35 
       36 /*	Modified 03/05/85 by Melanie Weaver to remove entry label  $call_name */
       37 /*	Modified 02/25/85 by Keith Loepere to use dc_find for name lookup check for path_name. */
       38 /*	Modified 10/16/84 by Keith Loepere to use dc_find for access computations. */
       39 /*	Modified 7/17/84 by Keith Loepere to use the new dc_find. */
       40 /*	Modified 5/17/83 by E. N. Kittlitz to decrement ref on get_link_target.
       41*/*	Modified 1/3/83 by Jay Pattin to add access_modes entry */
       42 /*	Modified 01/15/79 by C. D. Tavares to compute access correctly w.r.t. dir extended ring brackets */
       43 /* 	Modified March 1977 by M. Weaver to get rntp from stack */
       44 /*	Modified March 1976 by R. Bratt for initiated_mode and to fix get_search_rules bug */
       45 /*	Modified April 1975 by E. Stone to put access info in kst */
       46 /*	Modified April 1975 by R. Bratt for new kst */
       47 /*	Modified  Feb 1975 by R. Bratt to use get_pathname_ */
       48 /* 	Modified by Kobziar July 74 to call appropriate entry point in access_mode */
       49 /*
       50*   -- ->  fs_get$brackets returns the mode and ring brackets of the current
       51*   user for the segment specified by segptr.
       52*
       53*   USAGE: call fs_get$brackets (segptr, mode, rings, code);
       54*
       55*   1) segptr ptr - - - pointer to segment
       56*   2) mode fixed bin(5) - - - mode of user (output)
       57*   3) rings (3) fixed bin(6) - - - ring brackets of user (output)
       58*   4) code fixed bin - - - error code (output)
       59*
       60*   -- ->  fs_get$ex_mode_name returns the mode, brackets, extended access, and
       61*   primary name of a segment for the current user.
       62*
       63*   USAGE: call fs_get$ex_mode_name(segptr,mode,rings,ex_mode,name,code);
       64*
       65*   4) ex_mode is the extended access mode.
       66*
       67*   5) name is the primary name of the segment.
       68*
       69*   All other arguments same as fs_get$brackets.
       70*
       71*   -- ->  fs_get$mode returns the mode of the current user at the current
       72*   validation level for the segment specified by segptr.
       73*
       74*   USAGE: call fs_get$mode (segptr, mode, code);
       75*
       76*   The arguments are the same as for fs_get$brackets.
       77*
       78*   -- ->  fs_get$access_modes returns both mode and extended modes.
       79*
       80*   USAGE:  call fs_get$access_modes (segptr, mode, exmodes, code);
       81*
       82*   -- ->  fs_get$segptr returns a pointer to a segment given its reference name.
       83*
       84*   USAGE: call fs_get$segptr (refname, segptr, code);
       85*
       86*   1) refname char(*) - - - refernce name of segment
       87*   2) segptr ptr - - - pointer to segment (output)
       88*   3) code fixed bin - - - error code (output)
       89*
       90*   -- ->  fs_get$search_rules  returns in a space provided by the user a list of
       91*   of the search rules currently in use by the user for his validation level.
       92*
       93*   USAGE:call fs_get$search_rules (search_rules_ptr);
       94*
       95*   1) search_rules_ptr ptr - - - is a pointer to the space where the list of names will be stored.
       96*
       97*   The names are stored in a structure of the form:
       98*
       99*   dcl 1 ret_struc aligned,
      100*   2 num fixed bin,	number of rules
      101*   2 names(21) char(168) aligned;
      102*
      103*
      104*   -- ->  fs_get$path_name returns the pathname of the directory immediately superior
      105*   to, and the entry name of the segment specified by segptr.
      106*
      107*   USAGE: call fs_get$path_name (segptr, dirname, lnd, ename, code);
      108*
      109*   1) segptr ptr - - - pointer to the segment
      110*   2) dirname char(168) - - - pathname of superior directory (output)
      111*   3) lnd fixed bin - - - number of significant chars in pathname (output)
      112*   4) ename char(32) - - - entry name of segment (output)
      113*   5) code fixed bin - - - error code (output)
      114*
      115*   -- ->  fs_get$dir_name returns the pathname of the directory immediatetly superior
      116*   to the segment specified by segptr.
      117*
      118*   USAGE: call fs_get$dir_name (segptr, dirname, lnd, code);
      119*
      120*   The arguments are the same as fs_get$path_name.
      121*
      122*   -- ->  fs_get$ref_name returns the reference name corresponding to namecnt for
      123*   the segment specified by segptr.
      124*
      125*   USAGE: call fs_get$ref_name (segptr, namecnt, refname, code);
      126*
      127*   1) segptr ptr - - - pointer to the segment
      128*   2) namecnt fixed bin(17) - - - number of the reference name desired
      129*   3) refname char(*) - - - reference name (output)
      130*   4) code fixed bin - - - error code (output)
      131*
      132*   -- ->  fs_get$trans_sw returns the current value of the transparent usage/modification
      133*   switch and sets it to a new value.
      134*
      135*   USAGE: call fs_get$trans_sw (newsw, oldsw)
      136*
      137*   1) newsw fixed bin - - - new value for switch, if > 3, don't set switch
      138*   2) oldsw fixed bin - - - old value of switch (output)
      139*
      140*   */
      141 
      142 /* Parameters */
      143 
      144 dcl  a_code			fixed bin (35) parameter;
      145 dcl  a_dirname			char (*) parameter;
      146 dcl  a_ename			char (*) parameter;
      147 dcl  a_ex_mode			bit (*) parameter;	/* extended access  bits EX ACC */
      148 dcl  a_ex_modes			bit (36) aligned parameter;
      149 dcl  a_ldir			char (*) parameter;
      150 dcl  a_lentry			char (*) parameter;
      151 dcl  a_lnd			fixed bin (17) parameter;
      152 dcl  a_mode			fixed bin (5) parameter;
      153 dcl  a_name			char (*) parameter; /* name of segment EX ACC */
      154 dcl  a_namecnt			fixed bin (17) parameter;
      155 dcl  a_new_mode			bit (36) aligned parameter;
      156 dcl  a_newsw			fixed bin (17) parameter;
      157 dcl  a_oldsw			fixed bin (17) parameter;
      158 dcl  a_ptr			ptr parameter;
      159 dcl  a_refname			char (*) parameter;
      160 dcl  a_rings			(3) fixed bin (3) parameter;
      161 dcl  a_rname			char (*) parameter;
      162 dcl  a_segptr			ptr parameter;
      163 
      164 /* Constants */
      165 
      166 dcl  access_modes			fixed bin static options (constant) init (5);
      167 dcl  brackets			fixed bin static options (constant) init (3);
      168 dcl  ex_mode_name			fixed bin static options (constant) init (4);
      169 dcl  just_mode			fixed bin static options (constant) init (0);
      170 
      171 /* Variables */
      172 
      173 dcl  aptr				ptr;
      174 dcl  code				fixed bin (35);
      175 dcl  dirsw			bit (1) aligned;
      176 dcl  dlen				fixed bin (17);
      177 dcl  end_rule			fixed bin (17);
      178 dcl  entry_point			fixed bin;
      179 dcl  extended_mode			bit (36) aligned;
      180 dcl  i				fixed bin;
      181 dcl  l				fixed bin;
      182 dcl  ldir				char (168);
      183 dcl  lentry			char (32);
      184 dcl  mode				bit (36) aligned;
      185 dcl  namecnt			fixed bin (17);
      186 dcl  newsw			fixed bin (17);
      187 dcl  oldsw			fixed bin (17);
      188 dcl  pathname			char (201) varying;
      189 dcl  rb				(3) fixed bin (3);
      190 dcl  return_ename			bit (1) aligned;
      191 dcl  ring				fixed bin;
      192 dcl  rname			char (32) varying;
      193 dcl  segnum			fixed bin (17);
      194 dcl  segptr			ptr;
      195 dcl  srpp				ptr;
      196 
      197 /* Based */
      198 
      199 dcl  1 ret_struc			based aligned,
      200        2 num			fixed bin,
      201        2 names			(21) char (168);
      202 
      203 dcl  1 sr				(22) based aligned,
      204        2 segno			fixed bin (17) unaligned,
      205        2 offset			fixed bin (17) unaligned,
      206        2 uid			bit (36);
      207 
      208 /* External */
      209 
      210 dcl  error_table_$dirseg		fixed bin (35) external;
      211 dcl  error_table_$noentry		fixed bin (35) external;
      212 dcl  error_table_$root		fixed bin (35) external;
      213 dcl  pds$stacks			(0:7) ptr external;
      214 dcl  pds$transparent		bit (2) external aligned;
      215 
      216 /* Entries */
      217 
      218 dcl  get_pathname_			entry (fixed bin (17), char (*) varying, fixed bin (35));
      219 dcl  level$get			entry returns (fixed bin);
      220 dcl  ref_name_$get_refname		entry (fixed bin (17), fixed bin (17), char (*) varying, fixed bin (35));
      221 dcl  ref_name_$get_segno		entry (char (32) varying, fixed bin (17), fixed bin (35));
      222 
      223 /* Misc */
      224 
      225 dcl  (baseno, baseptr, binary, fixed, hbound, index, lbound, length, max, null, reverse, segno, substr) builtin;
      226 
      227 mode: entry (a_segptr, a_mode, a_code);
      228 
      229 	entry_point = just_mode;			/* Set entry switch */
      230 	go to join_mode;
      231 
      232 brackets: entry (a_segptr, a_mode, a_rings, a_code);
      233 
      234 	entry_point = brackets;			/* Set entry switch */
      235 	go to join_mode;
      236 
      237 access_modes:
      238      entry (a_segptr, a_new_mode, a_ex_modes, a_code);	/* new_mode because has correct dcl */
      239 
      240 	entry_point = access_modes;			/* Set entry switch */
      241 	go to join_mode;
      242 
      243 ex_mode_name:
      244      entry (a_segptr, a_mode, a_rings, a_ex_mode, a_name, a_code); /* extended acess entry EX ACC */
      245 
      246 	entry_point = ex_mode_name;			/* set entry switch EX ACC */
      247 join_mode:
      248 	segptr = a_segptr;				/* copy arg */
      249 
      250 	call dc_find$obj_modes_ptr (segptr, mode, extended_mode, rb, code);
      251 	if code ^= 0 then
      252 	     if code = error_table_$dirseg then do;
      253 		code = 0;
      254 		dirsw = "1"b;
      255 	     end;
      256 	     else go to err0;
      257 	else dirsw = "0"b;
      258 
      259 	if (entry_point = brackets) | (entry_point = ex_mode_name) then do;
      260 	     a_rings = rb;
      261 	     if entry_point = ex_mode_name then do;
      262 		a_ex_mode = extended_mode;
      263 		a_name = "";
      264 	     end;
      265 	end;
      266 	if entry_point = access_modes then do;
      267 	     if dirsw then code = error_table_$dirseg;
      268 	     else do;
      269 		a_new_mode = mode;
      270 		a_ex_modes = extended_mode;
      271 	     end;
      272 	end;
      273 	else do;
      274 	     if dirsw then mode = substr (mode, 1, 1) || "1"b || substr (mode, 2, 2);
      275 	     a_mode = fixed (substr (mode, 1, 4), 5);
      276 	end;
      277 
      278 err0:
      279 	a_code = code;
      280 	return;
      281 
      282 
      283 /* * * * * * * * * * * * * * * * * * * */
      284 
      285 seg_ptr: entry (a_rname, a_segptr, a_code);
      286 
      287 	call ref_name_$get_segno ((a_rname), segnum, code);
      288 	if code = 0 then a_segptr = baseptr (segnum);
      289 	else a_segptr = null ();
      290 	a_code = code;
      291 	return;
      292 
      293 /* * * * * * * * * * * * * * * * * * * * */
      294 search_rules: entry (a_ptr);
      295 
      296 	aptr = a_ptr;				/* copy arg */
      297 	ring = level$get ();
      298 	rntp = pds$stacks (ring) -> stack_header.rnt_ptr;
      299 	srpp = rntp -> rnt.srulep;
      300 	end_rule = binary (END_RULE);			/* pull computation out of loop */
      301 	do i = lbound (srpp -> sr, 1) to hbound (srpp -> sr, 1) while (srpp -> sr (i).offset ^= end_rule); /* now get the search rule names */
      302 	     if srpp -> sr (i).offset ^= 0 then aptr -> ret_struc.names (i) = search_rule_names (srpp -> sr (i).offset);
      303 	     else do;
      304 		segnum = srpp -> sr (i).segno;
      305 		segptr = baseptr (segnum);
      306 		call dc_find$obj_existence_ptr (segptr, ep, code);
      307 		if code ^= 0 then aptr -> ret_struc.names (i) = "invalid search rule pointer";
      308 		else do;
      309 		     call get_pathname_ (segnum, pathname, code);
      310 		     if code ^= 0 then aptr -> ret_struc.names (i) = "invalid search rule pointer";
      311 		     else aptr -> ret_struc.names (i) = pathname; /* copy name */
      312 		     call dc_find$finished (ep, DC_FIND_UNLOCK_DIR);
      313 		end;
      314 	     end;
      315 	end;
      316 	aptr -> ret_struc.num = i - 1;
      317 	return;
      318 
      319 /* * * * * * * * * * * * * * * * * * * * */
      320 
      321 get_link_target:
      322      entry (a_ldir, a_lentry, a_dirname, a_ename, a_code);
      323 
      324 	ldir = a_ldir;				/* copy input arguments */
      325 	lentry = a_lentry;
      326 
      327 	a_dirname = "";				/* set default values for return arguments */
      328 	a_ename = "";
      329 
      330 	call dc_find$link_target (ldir, lentry, code);
      331 
      332 	if code = 0 | code = error_table_$noentry then do;
      333 	     a_dirname = ldir;
      334 	     a_ename = lentry;
      335 	end;
      336 
      337 	a_code = code;
      338 	return;
      339 
      340 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      341 
      342 path_name: entry (a_segptr, a_dirname, a_lnd, a_ename, a_code);
      343 	return_ename = "1"b;
      344 	goto name_join;
      345 
      346 dir_name: entry (a_segptr, a_dirname, a_lnd, a_code);
      347 	return_ename = "0"b;
      348 
      349 name_join:
      350 	code = 0;
      351 	segptr = a_segptr;
      352 	call dc_find$obj_existence_ptr (segptr, ep, code);
      353 	if code = 0 then do;
      354 	     call get_pathname_ (segno (segptr), pathname, code);
      355 	     call dc_find$finished (ep, DC_FIND_UNLOCK_DIR);
      356 	end;
      357 	else if code = error_table_$root then do;
      358 	     code = 0;
      359 	     pathname = ">";
      360 	end;
      361 	else goto name_return;
      362 
      363 	i = index (reverse (pathname), ">");
      364 	l = length (pathname);
      365 	dlen = max (l - i, 1);
      366 	if return_ename then if dlen = 1 then dlen = 0;
      367 	a_dirname = substr (pathname, 1, dlen);
      368 	a_lnd = dlen;
      369 	if return_ename then a_ename = substr (pathname, l + 2 - i, i - 1);
      370 name_return:
      371 	a_code = code;
      372 	return;
      373 
      374 /* * * * * * * * * * * * * * * * * * */
      375 
      376 ref_name: entry (a_segptr, a_namecnt, a_refname, a_code);
      377 
      378           namecnt = max(a_namecnt, 1);
      379 
      380           segnum = fixed (baseno (a_segptr), 17);
      381           call ref_name_$get_refname (segnum, namecnt, rname, code);
      382 	if code = 0 then do;
      383 	   a_refname = rname;
      384 	   a_code = 0;
      385 	end;
      386 	else a_code = code;
      387 
      388 	return;
      389 
      390 /* * * * * * * * * * * * * * * * * * */
      391 
      392 trans_sw: entry (a_newsw, a_oldsw);
      393 
      394 	newsw = a_newsw;
      395 	oldsw = fixed (pds$transparent, 2);
      396 	if newsw > 3 then go to fin2;			/* newsw > 3 means only go to fin2 oldsw, don't change newsw */
      397 	if newsw < 0 then go to fin2;
      398 	if newsw = 0 then pds$transparent = "0"b;
      399 	else if newsw = 1 then pds$transparent = "01"b;
      400 	else pds$transparent = "11"b;			/* can't have modified transparent without used */
      401 
      402 fin2:	a_oldsw = oldsw;
      403 	return;
      404  /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      404 
      405  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      405 
      406  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  3     2 
  3     3 /* Template for names of branches or links. Length = 14 words. */
  3     4 
  3     5 dcl np ptr;
  3     6 
  3     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  3     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  3     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  3    10 
  3    11     2 type bit (18) unaligned,			/* type = dir name */
  3    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  3    13 
  3    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  3    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  3    16 
  3    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  3    18     2 pad3 bit (18) unal,
  3    19 
  3    20     2 name char(32) aligned,
  3    21 
  3    22     2 checksum bit (36),				/* checksum from entry_rp */
  3    23 
  3    24     2 owner bit (36);				/* uid of entry */
  3    25 
  3    26 
  3    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      406 
      407  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  4     2 
  4     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  4     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  4     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  4     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  4     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  4     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  4     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  4    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  4    11 
  4    12 dcl  access_name_type fixed bin static options (constant) init (1);
  4    13 dcl  acle_type fixed bin static options (constant) init (2);
  4    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  4    15 dcl  dir_type fixed bin static options (constant) init (4);
  4    16 dcl  link_type fixed bin static options (constant) init (5);
  4    17 dcl  name_type fixed bin static options (constant) init (6);
  4    18 dcl  seg_type fixed bin static options (constant) init (7);
  4    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  4    20 
  4    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      407 
      408  /* BEGIN INCLUDE FILE RNT.INCL.PL1 - WRITTEN SEPTEMBER 1974 BY R. BRATT */
  5     2 /* modified July 1976 by R. Bratt; updated March 1977 by M. Weaver */
  5     3 /* modified November 1977 by M. Weaver to use PL/I offsets instead of pointers */
  5     4 
  5     5 dcl (rntp, rntep) ptr;
  5     6 dcl lth fixed bin (17);
  5     7 dcl based_rnt_area area based;
  5     8 
  5     9 dcl 1 rnt aligned based (rntp),
  5    10     2 areap ptr,					/* pointer to area for rnte allocations */
  5    11     2 meters,
  5    12       3 insert,
  5    13         4 trys fixed bin (17) unaligned,
  5    14         4 wins fixed bin (17) unaligned,
  5    15       3 get_segno like insert,
  5    16       3 get_refnames like insert,
  5    17       3 delete_segno like insert,
  5    18       3 delete_name like insert,
  5    19     2 rnt_area_size fixed bin,
  5    20     2 srulep ptr,
  5    21     2 name_hash_table (0:127) offset (rnt.areap -> based_rnt_area),
  5    22     2 segno_hash_table (0:127) offset (rnt.areap -> based_rnt_area);
  5    23 
  5    24 dcl 1 rnte aligned based (rntep),
  5    25     2 name_fp offset (rnt.areap -> based_rnt_area),
  5    26     2 segno_fp offset (rnt.areap -> based_rnt_area),
  5    27     (2 segno fixed bin (17),
  5    28     2 length fixed bin (17),
  5    29     2 name char (lth refer (rnte.length)))unaligned;
  5    30 
  5    31 /* --------------------END RNT.INCL.PL1--------------------- */
      408 
      409  /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  6     2 
  6     3 dcl  sdwp ptr;
  6     4 
  6     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  6     6 
  6     7    (2 add bit (24),					/* main memory address of page table */
  6     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  6     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  6    10     2 df_no bit (2),				/* directed fault number */
  6    11 
  6    12     2 pad1 bit (1),
  6    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  6    14     2 access,					/* access bits */
  6    15       3 read bit (1),				/* read permission bit */
  6    16       3 execute bit (1),				/* execute permission bit */
  6    17       3 write bit (1),				/* write permission bit */
  6    18       3 privileged bit (1),				/* privileged bit */
  6    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  6    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  6    21     2 cache bit (1),				/* cache enable bit */
  6    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  6    23 
  6    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  6    25 
  6    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      409 
      410  /* BEGIN INCLUDE FILE ... search_rule_flags.incl.pl1 */
  7     2 
  7     3 dcl  INITIATED_RULE bit (18) static options (constant) init ("000000000000000001"b);
  7     4 dcl  REFERENCING_DIR_RULE bit (18) static options (constant) init ("000000000000000010"b);
  7     5 dcl  WDIR_RULE bit (18) static options (constant) init ("000000000000000011"b);
  7     6 dcl  END_RULE bit (18) static options (constant) init ("000000000000000100"b);
  7     7 dcl  BAD_RULE bit (18) static options (constant) init ("000000000000001000"b);
  7     8 
  7     9 dcl  search_rule_names (8) char (32) aligned static options (constant) init
  7    10     ("initiated_segments",
  7    11      "referencing_dir",
  7    12      "working_dir",
  7    13      "end_rules",
  7    14      "",
  7    15      "",
  7    16      "",
  7    17      "bad search rule");
  7    18 
  7    19 /* END INCLUDE FILE ... search_rule_flags.incl.pl1 */
      410 
      411  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  8     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  8     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  8     4 /*	Modified April 1983 by C. Hornig for tasking */
  8     5 
  8     6 /****^  HISTORY COMMENTS:
  8     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  8     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  8     9*     added the heap_header_ptr definition.
  8    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  8    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  8    12*     Modified to support control point management.  These changes were actually
  8    13*     made in February 1985 by G. Palter.
  8    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  8    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  8    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  8    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  8    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  8    19*     (ITS pair).
  8    20*                                                   END HISTORY COMMENTS */
  8    21 
  8    22 /* format: style2 */
  8    23 
  8    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  8    25 
  8    26      dcl	   1 stack_header	      based (sb) aligned,
  8    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  8    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  8    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  8    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  8    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  8    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  8    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  8    34 	     2 pad4	      bit (2) unal,
  8    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  8    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  8    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  8    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  8    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  8    40 	     2 null_ptr	      ptr,		/*  (16)  */
  8    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  8    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  8    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  8    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  8    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  8    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  8    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  8    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  8    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  8    50 	     2 return_no_pop_op_ptr
  8    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  8    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  8    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  8    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  8    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  8    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  8    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  8    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  8    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  8    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  8    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  8    62 	     2 trace,
  8    63 	       3 frames,
  8    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  8    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  8    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  8    67 	     2 pad2	      bit (36),		/*  (61) */
  8    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  8    69 
  8    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  8    71 
  8    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  8    73 						/* (551) octal */
  8    74 
  8    75 
  8    76 /*	The following constants are offsets within this transfer vector table.  */
  8    77 
  8    78      dcl	   (
  8    79 	   call_offset	      fixed bin init (271),
  8    80 	   push_offset	      fixed bin init (272),
  8    81 	   return_offset	      fixed bin init (273),
  8    82 	   return_no_pop_offset   fixed bin init (274),
  8    83 	   entry_offset	      fixed bin init (275)
  8    84 	   )		      internal static;
  8    85 
  8    86 
  8    87 
  8    88 
  8    89 
  8    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  8    91*	move the whole stack header should use this overlay.
  8    92**/
  8    93 
  8    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  8    95 
  8    96 
  8    97 
  8    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      411 
      412      end fs_get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/21/90  1449.2  fs_get.pl1                        >spec>install>1030>fs_get.pl1
404          1    05/20/85  0948.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
405          2    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
406          3    11/02/76  1514.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
407          4    05/26/77  1022.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
408          5    01/27/78  1811.4  rnt.incl.pl1                      >ldd>include>rnt.incl.pl1
409          6    09/14/76  0859.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
410          7    09/13/76  1200.5  search_rule_flags.incl.pl1        >ldd>include>search_rule_flags.incl.pl1
411          8    11/07/86  1650.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_UNLOCK_DIR              000102 constant        bit(1)                   initial dcl 1-13 set ref 312* 355*
END_RULE                               constant        bit(18)                  initial packed unaligned dcl 7-6 ref 300
a_code                                 parameter       fixed bin(35,0)          dcl 144 set ref 227 232 237 243 278* 285 290* 321
                                                                                  337* 342 346 370* 376 384* 386*
a_dirname                              parameter       char                     packed unaligned dcl 145 set ref 321 327* 333* 342
                                                                                  346 367*
a_ename                                parameter       char                     packed unaligned dcl 146 set ref 321 328* 334* 342
                                                                                  369*
a_ex_mode                              parameter       bit                      packed unaligned dcl 147 set ref 243 262*
a_ex_modes                             parameter       bit(36)                  dcl 148 set ref 237 270*
a_ldir                                 parameter       char                     packed unaligned dcl 149 ref 321 324
a_lentry                               parameter       char                     packed unaligned dcl 150 ref 321 325
a_lnd                                  parameter       fixed bin(17,0)          dcl 151 set ref 342 346 368*
a_mode                                 parameter       fixed bin(5,0)           dcl 152 set ref 227 232 243 275*
a_name                                 parameter       char                     packed unaligned dcl 153 set ref 243 263*
a_namecnt                              parameter       fixed bin(17,0)          dcl 154 ref 376 378
a_new_mode                             parameter       bit(36)                  dcl 155 set ref 237 269*
a_newsw                                parameter       fixed bin(17,0)          dcl 156 ref 392 394
a_oldsw                                parameter       fixed bin(17,0)          dcl 157 set ref 392 402*
a_ptr                                  parameter       pointer                  dcl 158 ref 294 296
a_refname                              parameter       char                     packed unaligned dcl 159 set ref 376 383*
a_rings                                parameter       fixed bin(3,0)           array dcl 160 set ref 232 243 260*
a_rname                                parameter       char                     packed unaligned dcl 161 ref 285 287
a_segptr                               parameter       pointer                  dcl 162 set ref 227 232 237 243 247 285 288* 289*
                                                                                  342 346 351 376 380
access_modes                           constant        fixed bin(17,0)          initial dcl 166 ref 240 266
aptr                            000100 automatic       pointer                  dcl 173 set ref 296* 302 307 310 311 316
baseno                                                 builtin function         dcl 225 ref 380
baseptr                                                builtin function         dcl 225 ref 288 305
binary                                                 builtin function         dcl 225 ref 300
brackets                               constant        fixed bin(17,0)          initial dcl 167 ref 234 259
code                            000102 automatic       fixed bin(35,0)          dcl 174 set ref 250* 251 251 253* 267* 278 287* 288
                                                                                  290 306* 307 309* 310 330* 332 332 337 349* 352*
                                                                                  353 354* 357 358* 370 381* 382 386
dc_find$finished                000032 constant        entry                    external dcl 1-33 ref 312 355
dc_find$link_target             000034 constant        entry                    external dcl 1-35 ref 330
dc_find$obj_existence_ptr       000036 constant        entry                    external dcl 1-59 ref 306 352
dc_find$obj_modes_ptr           000040 constant        entry                    external dcl 1-69 ref 250
dirsw                           000103 automatic       bit(1)                   dcl 175 set ref 254* 257* 267 274
dlen                            000104 automatic       fixed bin(17,0)          dcl 176 set ref 365* 366 366* 367 368
end_rule                        000105 automatic       fixed bin(17,0)          dcl 177 set ref 300* 301
entry_point                     000106 automatic       fixed bin(17,0)          dcl 178 set ref 229* 234* 240* 246* 259 259 261 266
ep                              000310 automatic       pointer                  dcl 2-6 set ref 306* 312* 352* 355*
error_table_$dirseg             000010 external static fixed bin(35,0)          dcl 210 ref 251 267
error_table_$noentry            000012 external static fixed bin(35,0)          dcl 211 ref 332
error_table_$root               000014 external static fixed bin(35,0)          dcl 212 ref 357
ex_mode_name                           constant        fixed bin(17,0)          initial dcl 168 ref 246 259 261
extended_mode                   000107 automatic       bit(36)                  dcl 179 set ref 250* 262 270
fixed                                                  builtin function         dcl 225 ref 275 380 395
get_pathname_                   000022 constant        entry                    external dcl 218 ref 309 354
hbound                                                 builtin function         dcl 225 ref 301
i                               000110 automatic       fixed bin(17,0)          dcl 180 set ref 301* 301* 302 302 302 304 307 310
                                                                                  311* 316 363* 365 369 369
index                                                  builtin function         dcl 225 ref 363
insert                    2            based           structure                level 3 dcl 5-9
just_mode                              constant        fixed bin(17,0)          initial dcl 169 ref 229
l                               000111 automatic       fixed bin(17,0)          dcl 181 set ref 364* 365 369
lbound                                                 builtin function         dcl 225 ref 301
ldir                            000112 automatic       char(168)                packed unaligned dcl 182 set ref 324* 330* 333
length                                                 builtin function         dcl 225 ref 364
lentry                          000164 automatic       char(32)                 packed unaligned dcl 183 set ref 325* 330* 334
level$get                       000024 constant        entry                    external dcl 219 ref 297
max                                                    builtin function         dcl 225 ref 365 378
meters                    2            based           structure                level 2 dcl 5-9
mode                            000174 automatic       bit(36)                  dcl 184 set ref 250* 269 274* 274 274 275
namecnt                         000175 automatic       fixed bin(17,0)          dcl 185 set ref 378* 381*
names                     1            based           char(168)                array level 2 dcl 199 set ref 302* 307* 310* 311*
newsw                           000176 automatic       fixed bin(17,0)          dcl 186 set ref 394* 396 397 398 399
null                                                   builtin function         dcl 225 ref 289
num                                    based           fixed bin(17,0)          level 2 dcl 199 set ref 316*
offset                    0(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 203 ref
                                                                                  301 302 302
oldsw                           000177 automatic       fixed bin(17,0)          dcl 187 set ref 395* 402
pathname                        000200 automatic       varying char(201)        dcl 188 set ref 309* 311 354* 359* 363 364 367 369
pds$stacks                      000016 external static pointer                  array dcl 213 ref 298
pds$transparent                 000020 external static bit(2)                   dcl 214 set ref 395 398* 399* 400*
rb                              000264 automatic       fixed bin(3,0)           array dcl 189 set ref 250* 260
ref_name_$get_refname           000026 constant        entry                    external dcl 220 ref 381
ref_name_$get_segno             000030 constant        entry                    external dcl 221 ref 287
ret_struc                              based           structure                level 1 dcl 199
return_ename                    000267 automatic       bit(1)                   dcl 190 set ref 343* 347* 366 369
reverse                                                builtin function         dcl 225 ref 363
ring                            000270 automatic       fixed bin(17,0)          dcl 191 set ref 297* 298
rname                           000271 automatic       varying char(32)         dcl 192 set ref 381* 383
rnt                                    based           structure                level 1 dcl 5-9
rnt_ptr                  62            based           pointer                  level 2 dcl 8-26 ref 298
rntp                            000312 automatic       pointer                  dcl 5-5 set ref 298* 299
sdw                                    based           structure                level 1 dcl 6-5
search_rule_names               000000 constant        char(32)                 initial array dcl 7-9 ref 302
segno                                                  builtin function         dcl 225 in procedure "fs_get" ref 354 354
segno                                  based           fixed bin(17,0)          array level 2 in structure "sr" packed packed
                                                                                  unaligned dcl 203 in procedure "fs_get" ref 304
segnum                          000302 automatic       fixed bin(17,0)          dcl 193 set ref 287* 288 304* 305 309* 380* 381*
segptr                          000304 automatic       pointer                  dcl 194 set ref 247* 250* 305* 306* 351* 352* 354
                                                                                  354
sr                                     based           structure                array level 1 dcl 203 ref 301 301
srpp                            000306 automatic       pointer                  dcl 195 set ref 299* 301 301 301 302 302 304
srulep                   10            based           pointer                  level 2 dcl 5-9 ref 299
stack_header                           based           structure                level 1 dcl 8-26
substr                                                 builtin function         dcl 225 ref 274 274 275 367 369

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 4-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 4-4
BAD_RULE                               internal static bit(18)                  initial packed unaligned dcl 7-7
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 1-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 4-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 4-6
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 4-10
INITIATED_RULE                         internal static bit(18)                  initial packed unaligned dcl 7-3
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 4-7
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 4-8
REFERENCING_DIR_RULE                   internal static bit(18)                  initial packed unaligned dcl 7-4
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 4-9
WDIR_RULE                              internal static bit(18)                  initial packed unaligned dcl 7-5
access_name_type                       internal static fixed bin(17,0)          initial dcl 4-12
acle_type                              internal static fixed bin(17,0)          initial dcl 4-13
based_rnt_area                         based           area(1024)               dcl 5-7
call_offset                            internal static fixed bin(17,0)          initial dcl 8-78
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_read                000000 constant        entry                    external dcl 1-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 1-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 1-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 1-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 1-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 1-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 1-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 1-51
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 1-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 1-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 1-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 1-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 1-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 1-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 1-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 1-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 1-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 1-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 1-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 1-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 1-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 1-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 4-14
dir_type                               internal static fixed bin(17,0)          initial dcl 4-15
entry                                  based           structure                level 1 dcl 2-8
entry_offset                           internal static fixed bin(17,0)          initial dcl 8-78
hash_table_type                        internal static fixed bin(17,0)          initial dcl 4-19
link_type                              internal static fixed bin(17,0)          initial dcl 4-16
lth                                    automatic       fixed bin(17,0)          dcl 5-6
name_type                              internal static fixed bin(17,0)          initial dcl 4-17
names                                  based           structure                level 1 dcl 3-7
np                                     automatic       pointer                  dcl 3-5
push_offset                            internal static fixed bin(17,0)          initial dcl 8-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 8-78
return_offset                          internal static fixed bin(17,0)          initial dcl 8-78
rnte                                   based           structure                level 1 dcl 5-24
rntep                                  automatic       pointer                  dcl 5-5
sb                                     automatic       pointer                  dcl 8-24
sdwa                                   based           structure                array level 1 dcl 6-24
sdwp                                   automatic       pointer                  dcl 6-3
seg_type                               internal static fixed bin(17,0)          initial dcl 4-18
stack_header_overlay                   based           fixed bin(17,0)          array dcl 8-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 8-72

NAMES DECLARED BY EXPLICIT CONTEXT.
access_modes                    000206 constant        entry                    external dcl 237
brackets                        000164 constant        entry                    external dcl 232
dir_name                        001101 constant        entry                    external dcl 346
err0                            000406 constant        label                    dcl 278 ref 251
ex_mode_name                    000231 constant        entry                    external dcl 243
fin2                            001434 constant        label                    dcl 402 ref 396 397
fs_get                          000130 constant        entry                    external dcl 34
get_link_target                 000715 constant        entry                    external dcl 321
join_mode                       000260 constant        label                    dcl 247 ref 230 235 241
mode                            000142 constant        entry                    external dcl 227
name_join                       001121 constant        label                    dcl 349 ref 344
name_return                     001270 constant        label                    dcl 370 ref 357
path_name                       001045 constant        entry                    external dcl 342
ref_name                        001300 constant        entry                    external dcl 376
search_rules                    000501 constant        entry                    external dcl 294
seg_ptr                         000415 constant        entry                    external dcl 285
trans_sw                        001401 constant        entry                    external dcl 392

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1716        1760    1437        1726
Length      2336    1437        42         342     257           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fs_get                              272 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fs_get                   000100 aptr                        fs_get
                         000102 code                        fs_get
                         000103 dirsw                       fs_get
                         000104 dlen                        fs_get
                         000105 end_rule                    fs_get
                         000106 entry_point                 fs_get
                         000107 extended_mode               fs_get
                         000110 i                           fs_get
                         000111 l                           fs_get
                         000112 ldir                        fs_get
                         000164 lentry                      fs_get
                         000174 mode                        fs_get
                         000175 namecnt                     fs_get
                         000176 newsw                       fs_get
                         000177 oldsw                       fs_get
                         000200 pathname                    fs_get
                         000264 rb                          fs_get
                         000267 return_ename                fs_get
                         000270 ring                        fs_get
                         000271 rname                       fs_get
                         000302 segnum                      fs_get
                         000304 segptr                      fs_get
                         000306 srpp                        fs_get
                         000310 ep                          fs_get
                         000312 rntp                        fs_get

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dc_find$finished              dc_find$link_target           dc_find$obj_existence_ptr     dc_find$obj_modes_ptr
get_pathname_                 level$get                     ref_name_$get_refname         ref_name_$get_segno

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dirseg           error_table_$noentry          error_table_$root             pds$stacks
pds$transparent


CONSTANTS
000000  aa  151 156 151 164	init
000001  aa  151 141 164 145	iate
000002  aa  144 137 163 145	d_se
000003  aa  147 155 145 156	gmen
000004  aa  164 163 040 040	ts  
000005  aa  040 040 040 040	    
000006  aa  040 040 040 040	    
000007  aa  040 040 040 040	    
000010  aa  162 145 146 145	refe
000011  aa  162 145 156 143	renc
000012  aa  151 156 147 137	ing_
000013  aa  144 151 162 040	dir 
000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    
000016  aa  040 040 040 040	    
000017  aa  040 040 040 040	    
000020  aa  167 157 162 153	work
000021  aa  151 156 147 137	ing_
000022  aa  144 151 162 040	dir 
000023  aa  040 040 040 040	    
000024  aa  040 040 040 040	    
000025  aa  040 040 040 040	    
000026  aa  040 040 040 040	    
000027  aa  040 040 040 040	    
000030  aa  145 156 144 137	end_
000031  aa  162 165 154 145	rule
000032  aa  163 040 040 040	s   
000033  aa  040 040 040 040	    
000034  aa  040 040 040 040	    
000035  aa  040 040 040 040	    
000036  aa  040 040 040 040	    
000037  aa  040 040 040 040	    
000040  aa  040 040 040 040	    
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa  040 040 040 040	    
000044  aa  040 040 040 040	    
000045  aa  040 040 040 040	    
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa  040 040 040 040	    
000051  aa  040 040 040 040	    
000052  aa  040 040 040 040	    
000053  aa  040 040 040 040	    
000054  aa  040 040 040 040	    
000055  aa  040 040 040 040	    
000056  aa  040 040 040 040	    
000057  aa  040 040 040 040	    
000060  aa  040 040 040 040	    
000061  aa  040 040 040 040	    
000062  aa  040 040 040 040	    
000063  aa  040 040 040 040	    
000064  aa  040 040 040 040	    
000065  aa  040 040 040 040	    
000066  aa  040 040 040 040	    
000067  aa  040 040 040 040	    
000070  aa  142 141 144 040	bad 
000071  aa  163 145 141 162	sear
000072  aa  143 150 040 162	ch r
000073  aa  165 154 145 040	ule 
000074  aa  040 040 040 040	    
000075  aa  040 040 040 040	    
000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    

000100  aa     530000000040

000101  aa     530000000311

000102  aa     400000000000

000103  aa     464000000000

000104  aa     404000000005

000105  aa     404000000021

000106  aa     514000000044

000107  aa     516077777777

000110  aa     526077777777

000111  aa     404000000043

000112  aa     077777000043
000113  aa     000001000000

000114  aa     404100000003
000115  aa     000000000001
000116  aa     000000000003
000117  aa     000000000001

000120  aa  151 156 166 141	inva
000121  aa  154 151 144 040	lid 
000122  aa  163 145 141 162	sear
000123  aa  143 150 040 162	ch r
000124  aa  165 154 145 040	ule 
000125  aa  160 157 151 156	poin
000126  aa  164 145 162 000	ter

BEGIN PROCEDURE fs_get
ENTRY TO fs_get                                             STATEMENT 1 ON LINE 34
fs_get: proc;

000127  da     000147200000
000130  aa   000420 6270 00	eax7 	272
000131  aa  7 00034 3521 20	epp2 	pr7|28,*
000132  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000133  aa     000000000000
000134  aa     000000000000
						STATEMENT 1 ON LINE 227
mode: entry (a_segptr, a_mode, a_code);

000135  aa   000017 7100 04	tra  	15,ic		000154
ENTRY TO mode                                               STATEMENT 1 ON LINE 227
mode: entry (a_segptr, a_mode, a_code);

000136  at     000003000103
000137  tt     000104000111
000140  ta     000136000000
000141  da     000154300000
000142  aa   000420 6270 00	eax7 	272
000143  aa  7 00034 3521 20	epp2 	pr7|28,*
000144  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000145  aa     000006000000
000146  aa     000000000000
000147  aa  6 00032 3735 20	epp7 	pr6|26,*
000150  aa  7 00002 3715 20	epp5 	pr7|2,*
000151  aa  6 00322 6515 00	spri5	pr6|210
000152  aa  7 00006 3535 20	epp3 	pr7|6,*
000153  aa  6 00314 2535 00	spri3	pr6|204
						STATEMENT 1 ON LINE 229
	entry_point = just_mode;

000154  aa   000000 2360 07	ldq  	0,dl
000155  aa  6 00106 7561 00	stq  	pr6|70		entry_point
						STATEMENT 1 ON LINE 230
	go to join_mode;

000156  aa   000102 7100 04	tra  	66,ic		000260
ENTRY TO brackets                                           STATEMENT 1 ON LINE 232
brackets: entry (a_segptr, a_mode, a_rings, a_code);

000157  at     000004000103
000160  tt     000104000114
000161  ta     000111000000
000162  ta     000157000000
000163  da     000162300000
000164  aa   000420 6270 00	eax7 	272
000165  aa  7 00034 3521 20	epp2 	pr7|28,*
000166  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000167  aa     000010000000
000170  aa     000000000000
000171  aa  6 00032 3735 20	epp7 	pr6|26,*
000172  aa  7 00002 3715 20	epp5 	pr7|2,*
000173  aa  6 00322 6515 00	spri5	pr6|210
000174  aa  7 00010 3535 20	epp3 	pr7|8,*
000175  aa  6 00314 2535 00	spri3	pr6|204
						STATEMENT 1 ON LINE 234
	entry_point = brackets;

000176  aa   000003 2360 07	ldq  	3,dl
000177  aa  6 00106 7561 00	stq  	pr6|70		entry_point
						STATEMENT 1 ON LINE 235
	go to join_mode;

000200  aa   000060 7100 04	tra  	48,ic		000260
ENTRY TO access_modes                                       STATEMENT 1 ON LINE 237
access_modes:
     entry (a_segptr, a_new_mode, a_ex_modes, a_code);

000201  at     000004000103
000202  tt     000106000106
000203  ta     000111000000
000204  ta     000201000000
000205  da     000171300000
000206  aa   000420 6270 00	eax7 	272
000207  aa  7 00034 3521 20	epp2 	pr7|28,*
000210  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000211  aa     000010000000
000212  aa     000000000000
000213  aa  6 00032 3735 20	epp7 	pr6|26,*
000214  aa  7 00002 3715 20	epp5 	pr7|2,*
000215  aa  6 00322 6515 00	spri5	pr6|210
000216  aa  7 00010 3535 20	epp3 	pr7|8,*
000217  aa  6 00314 2535 00	spri3	pr6|204
						STATEMENT 1 ON LINE 240
	entry_point = access_modes;

000220  aa   000005 2360 07	ldq  	5,dl
000221  aa  6 00106 7561 00	stq  	pr6|70		entry_point
						STATEMENT 1 ON LINE 241
	go to join_mode;

000222  aa   000036 7100 04	tra  	30,ic		000260
ENTRY TO ex_mode_name                                       STATEMENT 1 ON LINE 243
ex_mode_name:
     entry (a_segptr, a_mode, a_rings, a_ex_mode, a_name, a_code);

000223  at     000006000103
000224  tt     000104000114
000225  tt     000107000110
000226  ta     000111000000
000227  ta     000223000000
000230  da     000200300000
000231  aa   000420 6270 00	eax7 	272
000232  aa  7 00034 3521 20	epp2 	pr7|28,*
000233  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000234  aa     000014000000
000235  aa     000000000000
000236  aa  6 00042 3735 20	epp7 	pr6|34,*
000237  aa  7 00006 2361 20	ldq  	pr7|6,*
000240  aa   000002 6040 04	tmi  	2,ic		000242
000241  aa   777777 3760 07	anq  	262143,dl
000242  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000243  aa  6 00324 7561 00	stq  	pr6|212
000244  aa  7 00010 2361 20	ldq  	pr7|8,*
000245  aa   000002 6040 04	tmi  	2,ic		000247
000246  aa   777777 3760 07	anq  	262143,dl
000247  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000250  aa  6 00325 7561 00	stq  	pr6|213
000251  aa  6 00032 3715 20	epp5 	pr6|26,*
000252  aa  5 00002 3535 20	epp3 	pr5|2,*
000253  aa  6 00322 2535 00	spri3	pr6|210
000254  aa  5 00014 3515 20	epp1 	pr5|12,*
000255  aa  6 00314 2515 00	spri1	pr6|204
						STATEMENT 1 ON LINE 246
	entry_point = ex_mode_name;

000256  aa   000004 2360 07	ldq  	4,dl
000257  aa  6 00106 7561 00	stq  	pr6|70		entry_point
						STATEMENT 1 ON LINE 247
join_mode:
	segptr = a_segptr;

000260  aa  6 00322 3735 20	epp7 	pr6|210,*		a_segptr
000261  aa  7 00000 3735 20	epp7 	pr7|0,*		a_segptr
000262  aa  6 00304 6535 00	spri7	pr6|196		segptr
						STATEMENT 1 ON LINE 250
	call dc_find$obj_modes_ptr (segptr, mode, extended_mode, rb, code);

000263  aa  6 00304 3521 00	epp2 	pr6|196		segptr
000264  aa  6 00330 2521 00	spri2	pr6|216
000265  aa  6 00174 3521 00	epp2 	pr6|124		mode
000266  aa  6 00332 2521 00	spri2	pr6|218
000267  aa  6 00107 3521 00	epp2 	pr6|71		extended_mode
000270  aa  6 00334 2521 00	spri2	pr6|220
000271  aa  6 00264 3521 00	epp2 	pr6|180		rb
000272  aa  6 00336 2521 00	spri2	pr6|222
000273  aa  6 00102 3521 00	epp2 	pr6|66		code
000274  aa  6 00340 2521 00	spri2	pr6|224
000275  aa  6 00326 6211 00	eax1 	pr6|214
000276  aa   024000 4310 07	fld  	10240,dl
000277  aa  6 00044 3701 20	epp4 	pr6|36,*
000300  la  4 00040 3521 20	epp2 	pr4|32,*		dc_find$obj_modes_ptr
000301  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 251
	if code ^= 0 then
	     if code = error_table_$dirseg then do;

000302  aa  6 00102 2361 00	ldq  	pr6|66		code
000303  aa   000010 6000 04	tze  	8,ic		000313
000304  aa  6 00044 3701 20	epp4 	pr6|36,*
000305  la  4 00010 1161 20	cmpq 	pr4|8,*		error_table_$dirseg
000306  aa   000100 6010 04	tnz  	64,ic		000406
						STATEMENT 1 ON LINE 253
		code = 0;

000307  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 254
		dirsw = "1"b;

000310  aa   400000 2350 03	lda  	131072,du
000311  aa  6 00103 7551 00	sta  	pr6|67		dirsw
						STATEMENT 1 ON LINE 255
	     end;

000312  aa   000002 7100 04	tra  	2,ic		000314
						STATEMENT 1 ON LINE 257
	else dirsw = "0"b;

000313  aa  6 00103 4501 00	stz  	pr6|67		dirsw
						STATEMENT 1 ON LINE 259
	if (entry_point = brackets) | (entry_point = ex_mode_name) then do;

000314  aa  6 00106 2361 00	ldq  	pr6|70		entry_point
000315  aa   000003 1160 07	cmpq 	3,dl
000316  aa   000003 6000 04	tze  	3,ic		000321
000317  aa   000004 1160 07	cmpq 	4,dl
000320  aa   000025 6010 04	tnz  	21,ic		000345
						STATEMENT 1 ON LINE 260
	     a_rings = rb;

000321  aa  6 00032 3735 20	epp7 	pr6|26,*
000322  aa  7 00006 3715 20	epp5 	pr7|6,*
000323  aa  6 00264 2371 00	ldaq 	pr6|180		rb
000324  aa  5 00000 7551 00	sta  	pr5|0		a_rings
000325  aa  5 00001 7561 00	stq  	pr5|1		a_rings
000326  aa  6 00266 2351 00	lda  	pr6|182		rb
000327  aa  5 00002 7551 00	sta  	pr5|2		a_rings
						STATEMENT 1 ON LINE 261
	     if entry_point = ex_mode_name then do;

000330  aa  6 00106 2361 00	ldq  	pr6|70		entry_point
000331  aa   000004 1160 07	cmpq 	4,dl
000332  aa   000013 6010 04	tnz  	11,ic		000345
						STATEMENT 1 ON LINE 262
		a_ex_mode = extended_mode;

000333  aa  7 00010 3535 20	epp3 	pr7|8,*
000334  aa  6 00324 2351 00	lda  	pr6|212
000335  aa  003 140 060 500	csl  	(pr),(pr,rl),fill(0),bool(move)
000336  aa  6 00107 00 0044	descb	pr6|71,36		extended_mode
000337  aa  3 00000 00 0005	descb	pr3|0,al		a_ex_mode
						STATEMENT 1 ON LINE 263
		a_name = "";

000340  aa  7 00012 3515 20	epp1 	pr7|10,*
000341  aa  6 00325 2361 00	ldq  	pr6|213
000342  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
000343  aa   000000 00 0000	desc9a	0,0
000344  aa  1 00000 00 0006	desc9a	pr1|0,ql		a_name
						STATEMENT 1 ON LINE 264
	     end;

						STATEMENT 1 ON LINE 265
	end;

						STATEMENT 1 ON LINE 266
	if entry_point = access_modes then do;

000345  aa  6 00106 2361 00	ldq  	pr6|70		entry_point
000346  aa   000005 1160 07	cmpq 	5,dl
000347  aa   000015 6010 04	tnz  	13,ic		000364
						STATEMENT 1 ON LINE 267
	     if dirsw then code = error_table_$dirseg;

000350  aa  6 00103 2351 00	lda  	pr6|67		dirsw
000351  aa   000005 6000 04	tze  	5,ic		000356
000352  aa  6 00044 3701 20	epp4 	pr6|36,*
000353  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$dirseg
000354  aa  6 00102 7561 00	stq  	pr6|66		code
000355  aa   000031 7100 04	tra  	25,ic		000406
						STATEMENT 1 ON LINE 268
	     else do;

						STATEMENT 1 ON LINE 269
		a_new_mode = mode;

000356  aa  6 00174 2351 00	lda  	pr6|124		mode
000357  aa  6 00032 3735 20	epp7 	pr6|26,*
000360  aa  7 00004 7551 20	sta  	pr7|4,*		a_new_mode
						STATEMENT 1 ON LINE 270
		a_ex_modes = extended_mode;

000361  aa  6 00107 2351 00	lda  	pr6|71		extended_mode
000362  aa  7 00006 7551 20	sta  	pr7|6,*		a_ex_modes
						STATEMENT 1 ON LINE 271
	     end;

						STATEMENT 1 ON LINE 272
	end;

000363  aa   000023 7100 04	tra  	19,ic		000406
						STATEMENT 1 ON LINE 273
	else do;

						STATEMENT 1 ON LINE 274
	     if dirsw then mode = substr (mode, 1, 1) || "1"b || substr (mode, 2, 2);

000364  aa  6 00103 2351 00	lda  	pr6|67		dirsw
000365  aa   000015 6000 04	tze  	13,ic		000402
000366  aa  6 00174 2351 00	lda  	pr6|124		mode
000367  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000370  aa  6 00342 7551 00	sta  	pr6|226		mode
000371  aa   200000 2350 03	lda  	65536,du
000372  aa  6 00342 2751 00	ora  	pr6|226		mode
000373  aa  6 00342 7551 00	sta  	pr6|226
000374  aa  6 00174 2351 00	lda  	pr6|124		mode
000375  aa   000001 7350 00	als  	1
000376  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
000377  aa   000002 7710 00	arl  	2
000400  aa  6 00342 2751 00	ora  	pr6|226
000401  aa  6 00174 7551 00	sta  	pr6|124		mode
						STATEMENT 1 ON LINE 275
	     a_mode = fixed (substr (mode, 1, 4), 5);

000402  aa  6 00174 2351 00	lda  	pr6|124		mode
000403  aa   000104 7730 00	lrl  	68
000404  aa  6 00032 3735 20	epp7 	pr6|26,*
000405  aa  7 00004 7561 20	stq  	pr7|4,*		a_mode
						STATEMENT 1 ON LINE 276
	end;

						STATEMENT 1 ON LINE 278
err0:
	a_code = code;

000406  aa  6 00102 2361 00	ldq  	pr6|66		code
000407  aa  6 00314 7561 20	stq  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 280
	return;

000410  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO seg_ptr                                            STATEMENT 1 ON LINE 285
seg_ptr: entry (a_rname, a_segptr, a_code);

000411  at     000003000110
000412  tt     000103000111
000413  ta     000411000000
000414  da     000205300000
000415  aa   000420 6270 00	eax7 	272
000416  aa  7 00034 3521 20	epp2 	pr7|28,*
000417  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000420  aa     000006000000
000421  aa     000000000000
000422  aa  6 00042 3735 20	epp7 	pr6|34,*
000423  aa  7 00000 2361 20	ldq  	pr7|0,*
000424  aa   000002 6040 04	tmi  	2,ic		000426
000425  aa   777777 3760 07	anq  	262143,dl
000426  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000427  aa  6 00343 7561 00	stq  	pr6|227
000430  aa  6 00032 3715 20	epp5 	pr6|26,*
000431  aa  5 00004 3535 20	epp3 	pr5|4,*
000432  aa  6 00322 2535 00	spri3	pr6|210
000433  aa  5 00006 3515 20	epp1 	pr5|6,*
000434  aa  6 00314 2515 00	spri1	pr6|204
						STATEMENT 1 ON LINE 287
	call ref_name_$get_segno ((a_rname), segnum, code);

000435  aa  6 00343 2361 00	ldq  	pr6|227
000436  aa   000040 1160 07	cmpq 	32,dl
000437  aa   000002 6040 04	tmi  	2,ic		000441
000440  aa   000040 2360 07	ldq  	32,dl
000441  aa  6 00326 7561 00	stq  	pr6|214
000442  aa  6 00032 3735 20	epp7 	pr6|26,*
000443  aa  7 00002 3715 20	epp5 	pr7|2,*
000444  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000445  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_rname
000446  aa  6 00327 00 0006	desc9a	pr6|215,ql
000447  aa  6 00327 3521 00	epp2 	pr6|215
000450  aa  6 00346 2521 00	spri2	pr6|230
000451  aa  6 00302 3521 00	epp2 	pr6|194		segnum
000452  aa  6 00350 2521 00	spri2	pr6|232
000453  aa  6 00102 3521 00	epp2 	pr6|66		code
000454  aa  6 00352 2521 00	spri2	pr6|234
000455  aa  6 00344 6211 00	eax1 	pr6|228
000456  aa   014000 4310 07	fld  	6144,dl
000457  aa  6 00044 3701 20	epp4 	pr6|36,*
000460  la  4 00030 3521 20	epp2 	pr4|24,*		ref_name_$get_segno
000461  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 288
	if code = 0 then a_segptr = baseptr (segnum);

000462  aa  6 00102 2361 00	ldq  	pr6|66		code
000463  aa   000006 6010 04	tnz  	6,ic		000471
000464  aa  6 00302 2361 00	ldq  	pr6|194		segnum
000465  aa  6 00000 3525 00	epbp2	pr6|0
000466  aa   000000 3130 06	easp2	0,ql
000467  aa  6 00322 2521 20	spri2	pr6|210,*		a_segptr
000470  aa   000003 7100 04	tra  	3,ic		000473
						STATEMENT 1 ON LINE 289
	else a_segptr = null ();

000471  aa   777421 2370 04	ldaq 	-239,ic		000112 = 077777000043 000001000000
000472  aa  6 00322 7571 20	staq 	pr6|210,*		a_segptr
						STATEMENT 1 ON LINE 290
	a_code = code;

000473  aa  6 00102 2361 00	ldq  	pr6|66		code
000474  aa  6 00314 7561 20	stq  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 291
	return;

000475  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO search_rules                                       STATEMENT 1 ON LINE 294
search_rules: entry (a_ptr);

000476  at     000001000103
000477  ta     000476000000
000500  da     000214300000
000501  aa   000420 6270 00	eax7 	272
000502  aa  7 00034 3521 20	epp2 	pr7|28,*
000503  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000504  aa     000002000000
000505  aa     000000000000
						STATEMENT 1 ON LINE 296
	aptr = a_ptr;

000506  aa  6 00032 3735 20	epp7 	pr6|26,*
000507  aa  7 00002 3715 20	epp5 	pr7|2,*		a_ptr
000510  aa  5 00000 3715 20	epp5 	pr5|0,*		a_ptr
000511  aa  6 00100 6515 00	spri5	pr6|64		aptr
						STATEMENT 1 ON LINE 297
	ring = level$get ();

000512  aa  6 00270 3521 00	epp2 	pr6|184		ring
000513  aa  6 00346 2521 00	spri2	pr6|230
000514  aa  6 00344 6211 00	eax1 	pr6|228
000515  aa   004000 4310 07	fld  	2048,dl
000516  aa  6 00044 3701 20	epp4 	pr6|36,*
000517  la  4 00024 3521 20	epp2 	pr4|20,*		level$get
000520  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 298
	rntp = pds$stacks (ring) -> stack_header.rnt_ptr;

000521  aa  6 00270 2361 00	ldq  	pr6|184		ring
000522  aa   000001 7360 00	qls  	1
000523  aa  6 00044 3701 20	epp4 	pr6|36,*
000524  la  4 00016 3735 66	epp7 	pr4|14,*ql	pds$stacks
000525  aa  7 00000 3735 20	epp7 	pr7|0,*		pds$stacks
000526  aa  7 00062 3735 20	epp7 	pr7|50,*		stack_header.rnt_ptr
000527  aa  6 00312 6535 00	spri7	pr6|202		rntp
						STATEMENT 1 ON LINE 299
	srpp = rntp -> rnt.srulep;

000530  aa  7 00010 3715 20	epp5 	pr7|8,*		rnt.srulep
000531  aa  6 00306 6515 00	spri5	pr6|198		srpp
						STATEMENT 1 ON LINE 300
	end_rule = binary (END_RULE);

000532  aa   000004 2350 03	lda  	4,du
000533  aa   000066 7730 00	lrl  	54
000534  aa  6 00105 7561 00	stq  	pr6|69		end_rule
						STATEMENT 1 ON LINE 301
	do i = lbound (srpp -> sr, 1) to hbound (srpp -> sr, 1) while (srpp -> sr (i).offset ^= end_rule);

000535  aa   000001 2360 07	ldq  	1,dl
000536  aa  6 00110 7561 00	stq  	pr6|72		i
000537  aa   000000 0110 03	nop  	0,du
000540  aa  6 00110 2361 00	ldq  	pr6|72		i
000541  aa   000026 1160 07	cmpq 	22,dl
000542  aa   000142 6054 04	tpnz 	98,ic		000704
000543  aa   000001 7360 00	qls  	1
000544  aa  6 00306 3735 20	epp7 	pr6|198,*		srpp
000545  aa  7 77776 2351 06	lda  	pr7|-2,ql		sr.offset
000546  aa   000022 7350 00	als  	18
000547  aa  6 00342 7561 00	stq  	pr6|226
000550  aa   000066 7330 00	lrs  	54
000551  aa  6 00105 1161 00	cmpq 	pr6|69		end_rule
000552  aa   000132 6000 04	tze  	90,ic		000704
						STATEMENT 1 ON LINE 302
	     if srpp -> sr (i).offset ^= 0 then aptr -> ret_struc.names (i) = search_rule_names (srpp -> sr (i).offset);

000553  aa  6 00354 7561 00	stq  	pr6|236		sr.offset
000554  aa  6 00354 2361 00	ldq  	pr6|236		sr.offset
000555  aa   000015 6000 04	tze  	13,ic		000572
000556  aa  6 00110 2361 00	ldq  	pr6|72		i
000557  aa   000052 4020 07	mpy  	42,dl
000560  aa   000000 6270 06	eax7 	0,ql
000561  aa  6 00354 2361 00	ldq  	pr6|236		sr.offset
000562  aa   000003 7360 00	qls  	3
000563  aa  6 00100 3715 20	epp5 	pr6|64,*		aptr
000564  aa  5 77727 3715 17	epp5 	pr5|-41,7		ret_struc.names
000565  ta   777770 3534 06	epp3 	-8,ql
000566  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000567  aa  3 00000 00 0040	desc9a	pr3|0,32		search_rule_names
000570  aa  5 00000 00 0250	desc9a	pr5|0,168		ret_struc.names
000571  aa   000111 7100 04	tra  	73,ic		000702
						STATEMENT 1 ON LINE 303
	     else do;

						STATEMENT 1 ON LINE 304
		segnum = srpp -> sr (i).segno;

000572  aa  6 00342 7271 00	lxl7 	pr6|226
000573  aa  7 77776 2351 17	lda  	pr7|-2,7		sr.segno
000574  aa   000066 7330 00	lrs  	54
000575  aa  6 00302 7561 00	stq  	pr6|194		segnum
						STATEMENT 1 ON LINE 305
		segptr = baseptr (segnum);

000576  aa  6 00000 3525 00	epbp2	pr6|0
000577  aa   000000 3130 06	easp2	0,ql
000600  aa  6 00304 2521 00	spri2	pr6|196		segptr
						STATEMENT 1 ON LINE 306
		call dc_find$obj_existence_ptr (segptr, ep, code);

000601  aa  6 00304 3521 00	epp2 	pr6|196		segptr
000602  aa  6 00346 2521 00	spri2	pr6|230
000603  aa  6 00310 3521 00	epp2 	pr6|200		ep
000604  aa  6 00350 2521 00	spri2	pr6|232
000605  aa  6 00102 3521 00	epp2 	pr6|66		code
000606  aa  6 00352 2521 00	spri2	pr6|234
000607  aa  6 00344 6211 00	eax1 	pr6|228
000610  aa   014000 4310 07	fld  	6144,dl
000611  aa  6 00044 3701 20	epp4 	pr6|36,*
000612  la  4 00036 3521 20	epp2 	pr4|30,*		dc_find$obj_existence_ptr
000613  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 307
		if code ^= 0 then aptr -> ret_struc.names (i) = "invalid search rule pointer";

000614  aa  6 00102 2361 00	ldq  	pr6|66		code
000615  aa   000011 6000 04	tze  	9,ic		000626
000616  aa  6 00110 2361 00	ldq  	pr6|72		i
000617  aa   000052 4020 07	mpy  	42,dl
000620  aa  6 00100 3735 20	epp7 	pr6|64,*		aptr
000621  aa  7 77727 3735 06	epp7 	pr7|-41,ql	ret_struc.names
000622  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000623  aa   777276 00 0033	desc9a	-322,27		000120 = 151156166141
000624  aa  7 00000 00 0250	desc9a	pr7|0,168		ret_struc.names
000625  aa   000055 7100 04	tra  	45,ic		000702
						STATEMENT 1 ON LINE 308
		else do;

						STATEMENT 1 ON LINE 309
		     call get_pathname_ (segnum, pathname, code);

000626  aa  6 00302 3521 00	epp2 	pr6|194		segnum
000627  aa  6 00360 2521 00	spri2	pr6|240
000630  aa  6 00201 3521 00	epp2 	pr6|129		pathname
000631  aa  6 00362 2521 00	spri2	pr6|242
000632  aa  6 00102 3521 00	epp2 	pr6|66		code
000633  aa  6 00364 2521 00	spri2	pr6|244
000634  aa   777251 3520 04	epp2 	-343,ic		000105 = 404000000021
000635  aa  6 00366 2521 00	spri2	pr6|246
000636  aa   777243 3520 04	epp2 	-349,ic		000101 = 530000000311
000637  aa  6 00370 2521 00	spri2	pr6|248
000640  aa   777251 3520 04	epp2 	-343,ic		000111 = 404000000043
000641  aa  6 00372 2521 00	spri2	pr6|250
000642  aa  6 00356 6211 00	eax1 	pr6|238
000643  aa   014000 4310 07	fld  	6144,dl
000644  aa  6 00044 3701 20	epp4 	pr6|36,*
000645  la  4 00022 3521 20	epp2 	pr4|18,*		get_pathname_
000646  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 310
		     if code ^= 0 then aptr -> ret_struc.names (i) = "invalid search rule pointer";

000647  aa  6 00102 2361 00	ldq  	pr6|66		code
000650  aa   000011 6000 04	tze  	9,ic		000661
000651  aa  6 00110 2361 00	ldq  	pr6|72		i
000652  aa   000052 4020 07	mpy  	42,dl
000653  aa  6 00100 3735 20	epp7 	pr6|64,*		aptr
000654  aa  7 77727 3735 06	epp7 	pr7|-41,ql	ret_struc.names
000655  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000656  aa   777243 00 0033	desc9a	-349,27		000120 = 151156166141
000657  aa  7 00000 00 0250	desc9a	pr7|0,168		ret_struc.names
000660  aa   000011 7100 04	tra  	9,ic		000671
						STATEMENT 1 ON LINE 311
		     else aptr -> ret_struc.names (i) = pathname;

000661  aa  6 00110 2361 00	ldq  	pr6|72		i
000662  aa   000052 4020 07	mpy  	42,dl
000663  aa  6 00100 3735 20	epp7 	pr6|64,*		aptr
000664  aa  7 77727 3735 06	epp7 	pr7|-41,ql	ret_struc.names
000665  aa  6 00200 7271 00	lxl7 	pr6|128		pathname
000666  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000667  aa  6 00201 00 0017	desc9a	pr6|129,x7	pathname
000670  aa  7 00000 00 0250	desc9a	pr7|0,168		ret_struc.names
						STATEMENT 1 ON LINE 312
		     call dc_find$finished (ep, DC_FIND_UNLOCK_DIR);

000671  aa  6 00310 3521 00	epp2 	pr6|200		ep
000672  aa  6 00346 2521 00	spri2	pr6|230
000673  aa   777207 3520 04	epp2 	-377,ic		000102 = 400000000000
000674  aa  6 00350 2521 00	spri2	pr6|232
000675  aa  6 00344 6211 00	eax1 	pr6|228
000676  aa   010000 4310 07	fld  	4096,dl
000677  aa  6 00044 3701 20	epp4 	pr6|36,*
000700  la  4 00032 3521 20	epp2 	pr4|26,*		dc_find$finished
000701  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 313
		end;

						STATEMENT 1 ON LINE 314
	     end;

						STATEMENT 1 ON LINE 315
	end;

000702  aa  6 00110 0541 00	aos  	pr6|72		i
000703  aa   777635 7100 04	tra  	-99,ic		000540
						STATEMENT 1 ON LINE 316
	aptr -> ret_struc.num = i - 1;

000704  aa  6 00110 2361 00	ldq  	pr6|72		i
000705  aa   000001 1760 07	sbq  	1,dl
000706  aa  6 00100 7561 20	stq  	pr6|64,*		ret_struc.num
						STATEMENT 1 ON LINE 317
	return;

000707  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_link_target                                    STATEMENT 1 ON LINE 321
get_link_target:
     entry (a_ldir, a_lentry, a_dirname, a_ename, a_code);

000710  at     000005000110
000711  tt     000110000110
000712  tt     000110000111
000713  ta     000710000000
000714  da     000223300000
000715  aa   000420 6270 00	eax7 	272
000716  aa  7 00034 3521 20	epp2 	pr7|28,*
000717  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000720  aa     000012000000
000721  aa     000000000000
000722  aa  6 00042 3735 20	epp7 	pr6|34,*
000723  aa  7 00000 2361 20	ldq  	pr7|0,*
000724  aa   000002 6040 04	tmi  	2,ic		000726
000725  aa   777777 3760 07	anq  	262143,dl
000726  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000727  aa  6 00343 7561 00	stq  	pr6|227
000730  aa  7 00002 2361 20	ldq  	pr7|2,*
000731  aa   000002 6040 04	tmi  	2,ic		000733
000732  aa   777777 3760 07	anq  	262143,dl
000733  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000734  aa  6 00374 7561 00	stq  	pr6|252
000735  aa  7 00006 2361 20	ldq  	pr7|6,*
000736  aa   000002 6040 04	tmi  	2,ic		000740
000737  aa   777777 3760 07	anq  	262143,dl
000740  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000741  aa  6 00324 7561 00	stq  	pr6|212
000742  aa  6 00032 3715 20	epp5 	pr6|26,*
000743  aa  5 00006 3535 20	epp3 	pr5|6,*
000744  aa  6 00320 2535 00	spri3	pr6|208
000745  aa  7 00004 3515 20	epp1 	pr7|4,*
000746  aa  6 00316 2515 00	spri1	pr6|206
000747  aa  5 00012 3535 20	epp3 	pr5|10,*
000750  aa  6 00314 2535 00	spri3	pr6|204
						STATEMENT 1 ON LINE 324
	ldir = a_ldir;

000751  aa  6 00032 3735 20	epp7 	pr6|26,*
000752  aa  7 00002 3715 20	epp5 	pr7|2,*
000753  aa  6 00343 2351 00	lda  	pr6|227
000754  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000755  aa  5 00000 00 0005	desc9a	pr5|0,al		a_ldir
000756  aa  6 00112 00 0250	desc9a	pr6|74,168	ldir
						STATEMENT 1 ON LINE 325
	lentry = a_lentry;

000757  aa  7 00004 3535 20	epp3 	pr7|4,*
000760  aa  6 00374 2361 00	ldq  	pr6|252
000761  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000762  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_lentry
000763  aa  6 00164 00 0040	desc9a	pr6|116,32	lentry
						STATEMENT 1 ON LINE 327
	a_dirname = "";

000764  aa  6 00316 2361 20	ldq  	pr6|206,*
000765  aa   000002 6040 04	tmi  	2,ic		000767
000766  aa   777777 3760 07	anq  	262143,dl
000767  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000770  aa  6 00320 3515 20	epp1 	pr6|208,*
000771  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
000772  aa   000000 00 0000	desc9a	0,0
000773  aa  1 00000 00 0006	desc9a	pr1|0,ql		a_dirname
						STATEMENT 1 ON LINE 328
	a_ename = "";

000774  aa  7 00010 3715 20	epp5 	pr7|8,*
000775  aa  6 00324 2351 00	lda  	pr6|212
000776  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
000777  aa   000000 00 0000	desc9a	0,0
001000  aa  5 00000 00 0005	desc9a	pr5|0,al		a_ename
						STATEMENT 1 ON LINE 330
	call dc_find$link_target (ldir, lentry, code);

001001  aa  6 00112 3521 00	epp2 	pr6|74		ldir
001002  aa  6 00346 2521 00	spri2	pr6|230
001003  aa  6 00164 3521 00	epp2 	pr6|116		lentry
001004  aa  6 00350 2521 00	spri2	pr6|232
001005  aa  6 00102 3521 00	epp2 	pr6|66		code
001006  aa  6 00352 2521 00	spri2	pr6|234
001007  aa  6 00342 7561 00	stq  	pr6|226
001010  aa  6 00344 6211 00	eax1 	pr6|228
001011  aa   014000 4310 07	fld  	6144,dl
001012  aa  6 00044 3701 20	epp4 	pr6|36,*
001013  la  4 00034 3521 20	epp2 	pr4|28,*		dc_find$link_target
001014  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 332
	if code = 0 | code = error_table_$noentry then do;

001015  aa  6 00102 2361 00	ldq  	pr6|66		code
001016  aa   000004 6000 04	tze  	4,ic		001022
001017  aa  6 00044 3701 20	epp4 	pr6|36,*
001020  la  4 00012 1161 20	cmpq 	pr4|10,*		error_table_$noentry
001021  aa   000014 6010 04	tnz  	12,ic		001035
						STATEMENT 1 ON LINE 333
	     a_dirname = ldir;

001022  aa  6 00320 3735 20	epp7 	pr6|208,*
001023  aa  6 00342 2351 00	lda  	pr6|226
001024  aa  040 140 100 500	mlr  	(pr),(pr,rl),fill(040)
001025  aa  6 00112 00 0250	desc9a	pr6|74,168	ldir
001026  aa  7 00000 00 0005	desc9a	pr7|0,al		a_dirname
						STATEMENT 1 ON LINE 334
	     a_ename = lentry;

001027  aa  6 00032 3715 20	epp5 	pr6|26,*
001030  aa  5 00010 3535 20	epp3 	pr5|8,*
001031  aa  6 00324 2361 00	ldq  	pr6|212
001032  aa  040 140 100 500	mlr  	(pr),(pr,rl),fill(040)
001033  aa  6 00164 00 0040	desc9a	pr6|116,32	lentry
001034  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_ename
						STATEMENT 1 ON LINE 335
	end;

						STATEMENT 1 ON LINE 337
	a_code = code;

001035  aa  6 00102 2361 00	ldq  	pr6|66		code
001036  aa  6 00314 7561 20	stq  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 338
	return;

001037  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO path_name                                          STATEMENT 1 ON LINE 342
path_name: entry (a_segptr, a_dirname, a_lnd, a_ename, a_code);

001040  at     000005000103
001041  tt     000110000105
001042  tt     000110000111
001043  ta     001040000000
001044  da     000231300000
001045  aa   000420 6270 00	eax7 	272
001046  aa  7 00034 3521 20	epp2 	pr7|28,*
001047  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001050  aa     000012000000
001051  aa     000000000000
001052  aa  6 00042 3735 20	epp7 	pr6|34,*
001053  aa  7 00006 2361 20	ldq  	pr7|6,*
001054  aa   000002 6040 04	tmi  	2,ic		001056
001055  aa   777777 3760 07	anq  	262143,dl
001056  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001057  aa  6 00324 7561 00	stq  	pr6|212
001060  aa  6 00032 3715 20	epp5 	pr6|26,*
001061  aa  5 00002 3535 20	epp3 	pr5|2,*
001062  aa  6 00322 2535 00	spri3	pr6|210
001063  aa  5 00004 3515 20	epp1 	pr5|4,*
001064  aa  6 00320 2515 00	spri1	pr6|208
001065  aa  7 00002 3535 20	epp3 	pr7|2,*
001066  aa  6 00316 2535 00	spri3	pr6|206
001067  aa  5 00012 3735 20	epp7 	pr5|10,*
001070  aa  6 00314 6535 00	spri7	pr6|204
						STATEMENT 1 ON LINE 343
	return_ename = "1"b;

001071  aa   400000 2350 03	lda  	131072,du
001072  aa  6 00267 7551 00	sta  	pr6|183		return_ename
						STATEMENT 1 ON LINE 344
	goto name_join;

001073  aa   000026 7100 04	tra  	22,ic		001121
ENTRY TO dir_name                                           STATEMENT 1 ON LINE 346
dir_name: entry (a_segptr, a_dirname, a_lnd, a_code);

001074  at     000004000103
001075  tt     000110000105
001076  ta     000111000000
001077  ta     001074000000
001100  da     000237300000
001101  aa   000420 6270 00	eax7 	272
001102  aa  7 00034 3521 20	epp2 	pr7|28,*
001103  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001104  aa     000010000000
001105  aa     000000000000
001106  aa  6 00032 3735 20	epp7 	pr6|26,*
001107  aa  7 00002 3715 20	epp5 	pr7|2,*
001110  aa  6 00322 6515 00	spri5	pr6|210
001111  aa  7 00004 3535 20	epp3 	pr7|4,*
001112  aa  6 00320 2535 00	spri3	pr6|208
001113  aa  6 00042 3515 20	epp1 	pr6|34,*
001114  aa  1 00002 3715 20	epp5 	pr1|2,*
001115  aa  6 00316 6515 00	spri5	pr6|206
001116  aa  7 00010 3535 20	epp3 	pr7|8,*
001117  aa  6 00314 2535 00	spri3	pr6|204
						STATEMENT 1 ON LINE 347
	return_ename = "0"b;

001120  aa  6 00267 4501 00	stz  	pr6|183		return_ename
						STATEMENT 1 ON LINE 349
name_join:
	code = 0;

001121  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 351
	segptr = a_segptr;

001122  aa  6 00322 3735 20	epp7 	pr6|210,*		a_segptr
001123  aa  7 00000 3735 20	epp7 	pr7|0,*		a_segptr
001124  aa  6 00304 6535 00	spri7	pr6|196		segptr
						STATEMENT 1 ON LINE 352
	call dc_find$obj_existence_ptr (segptr, ep, code);

001125  aa  6 00304 3521 00	epp2 	pr6|196		segptr
001126  aa  6 00346 2521 00	spri2	pr6|230
001127  aa  6 00310 3521 00	epp2 	pr6|200		ep
001130  aa  6 00350 2521 00	spri2	pr6|232
001131  aa  6 00102 3521 00	epp2 	pr6|66		code
001132  aa  6 00352 2521 00	spri2	pr6|234
001133  aa  6 00344 6211 00	eax1 	pr6|228
001134  aa   014000 4310 07	fld  	6144,dl
001135  aa  6 00044 3701 20	epp4 	pr6|36,*
001136  la  4 00036 3521 20	epp2 	pr4|30,*		dc_find$obj_existence_ptr
001137  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 353
	if code = 0 then do;

001140  aa  6 00102 2361 00	ldq  	pr6|66		code
001141  aa   000040 6010 04	tnz  	32,ic		001201
						STATEMENT 1 ON LINE 354
	     call get_pathname_ (segno (segptr), pathname, code);

001142  aa  6 00304 2131 20	epaq 	pr6|196,*		segptr
001143  aa   000022 7770 00	llr  	18
001144  aa   077777 3760 07	anq  	32767,dl
001145  aa  6 00342 7561 00	stq  	pr6|226
001146  aa  6 00342 3521 00	epp2 	pr6|226
001147  aa  6 00360 2521 00	spri2	pr6|240
001150  aa  6 00201 3521 00	epp2 	pr6|129		pathname
001151  aa  6 00362 2521 00	spri2	pr6|242
001152  aa  6 00102 3521 00	epp2 	pr6|66		code
001153  aa  6 00364 2521 00	spri2	pr6|244
001154  aa   776731 3520 04	epp2 	-551,ic		000105 = 404000000021
001155  aa  6 00366 2521 00	spri2	pr6|246
001156  aa   776723 3520 04	epp2 	-557,ic		000101 = 530000000311
001157  aa  6 00370 2521 00	spri2	pr6|248
001160  aa   776731 3520 04	epp2 	-551,ic		000111 = 404000000043
001161  aa  6 00372 2521 00	spri2	pr6|250
001162  aa  6 00356 6211 00	eax1 	pr6|238
001163  aa   014000 4310 07	fld  	6144,dl
001164  aa  6 00044 3701 20	epp4 	pr6|36,*
001165  la  4 00022 3521 20	epp2 	pr4|18,*		get_pathname_
001166  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 355
	     call dc_find$finished (ep, DC_FIND_UNLOCK_DIR);

001167  aa  6 00310 3521 00	epp2 	pr6|200		ep
001170  aa  6 00346 2521 00	spri2	pr6|230
001171  aa   776711 3520 04	epp2 	-567,ic		000102 = 400000000000
001172  aa  6 00350 2521 00	spri2	pr6|232
001173  aa  6 00344 6211 00	eax1 	pr6|228
001174  aa   010000 4310 07	fld  	4096,dl
001175  aa  6 00044 3701 20	epp4 	pr6|36,*
001176  la  4 00032 3521 20	epp2 	pr4|26,*		dc_find$finished
001177  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 356
	end;

001200  aa   000011 7100 04	tra  	9,ic		001211
						STATEMENT 1 ON LINE 357
	else if code = error_table_$root then do;

001201  aa  6 00044 3701 20	epp4 	pr6|36,*
001202  la  4 00014 1161 20	cmpq 	pr4|12,*		error_table_$root
001203  aa   000065 6010 04	tnz  	53,ic		001270
						STATEMENT 1 ON LINE 358
	     code = 0;

001204  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 359
	     pathname = ">";

001205  aa   076000 2350 03	lda  	31744,du
001206  aa  6 00201 7551 00	sta  	pr6|129		pathname
001207  aa   000001 2360 07	ldq  	1,dl
001210  aa  6 00200 7561 00	stq  	pr6|128		pathname
						STATEMENT 1 ON LINE 360
	end;

						STATEMENT 1 ON LINE 363
	i = index (reverse (pathname), ">");

001211  aa  6 00200 7271 00	lxl7 	pr6|128		pathname
001212  aa  000 003 125 540	scmr 	(pr,rl),(du),mask(000)
001213  aa  6 00201 00 0017	desc9a	pr6|129,x7	pathname
001214  aa   076000 00 0001	desc9a	31744,1
001215  aa  6 00056 0001 00	arg  	pr6|46
001216  aa  6 00056 2361 00	ldq  	pr6|46
001217  aa   000002 6070 04	ttf  	2,ic		001221
001220  aa   000001 3360 07	lcq  	1,dl
001221  aa   000001 0760 07	adq  	1,dl
001222  aa  6 00110 7561 00	stq  	pr6|72		i
						STATEMENT 1 ON LINE 364
	l = length (pathname);

001223  aa  6 00200 2361 00	ldq  	pr6|128		pathname
001224  aa  6 00111 7561 00	stq  	pr6|73		l
						STATEMENT 1 ON LINE 365
	dlen = max (l - i, 1);

001225  aa  6 00110 1761 00	sbq  	pr6|72		i
001226  aa   000001 1160 07	cmpq 	1,dl
001227  aa   000002 6050 04	tpl  	2,ic		001231
001230  aa   000001 2360 07	ldq  	1,dl
001231  aa  6 00104 7561 00	stq  	pr6|68		dlen
						STATEMENT 1 ON LINE 366
	if return_ename then if dlen = 1 then dlen = 0;

001232  aa  6 00267 2351 00	lda  	pr6|183		return_ename
001233  aa   000004 6000 04	tze  	4,ic		001237
001234  aa   000001 1160 07	cmpq 	1,dl
001235  aa   000002 6010 04	tnz  	2,ic		001237
001236  aa  6 00104 4501 00	stz  	pr6|68		dlen
						STATEMENT 1 ON LINE 367
	a_dirname = substr (pathname, 1, dlen);

001237  aa  6 00316 2361 20	ldq  	pr6|206,*
001240  aa   000002 6040 04	tmi  	2,ic		001242
001241  aa   777777 3760 07	anq  	262143,dl
001242  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001243  aa  6 00320 3735 20	epp7 	pr6|208,*
001244  aa  6 00104 7271 00	lxl7 	pr6|68		dlen
001245  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001246  aa  6 00201 00 0017	desc9a	pr6|129,x7	pathname
001247  aa  7 00000 00 0006	desc9a	pr7|0,ql		a_dirname
						STATEMENT 1 ON LINE 368
	a_lnd = dlen;

001250  aa  6 00104 2361 00	ldq  	pr6|68		dlen
001251  aa  6 00032 3715 20	epp5 	pr6|26,*
001252  aa  5 00006 7561 20	stq  	pr5|6,*		a_lnd
						STATEMENT 1 ON LINE 369
	if return_ename then a_ename = substr (pathname, l + 2 - i, i - 1);

001253  aa   400000 3150 03	cana 	131072,du
001254  aa   000014 6000 04	tze  	12,ic		001270
001255  aa  6 00110 2361 00	ldq  	pr6|72		i
001256  aa   000001 1760 07	sbq  	1,dl
001257  aa   000000 6260 06	eax6 	0,ql
001260  aa  6 00111 2361 00	ldq  	pr6|73		l
001261  aa   000002 0760 07	adq  	2,dl
001262  aa  6 00110 1761 00	sbq  	pr6|72		i
001263  aa  5 00010 3535 20	epp3 	pr5|8,*
001264  aa  6 00324 2351 00	lda  	pr6|212
001265  aa  040 140 100 546	mlr  	(pr,rl,ql),(pr,rl),fill(040)
001266  aa  6 00200 60 0016	desc9a	pr6|128(3),x6	pathname
001267  aa  3 00000 00 0005	desc9a	pr3|0,al		a_ename
						STATEMENT 1 ON LINE 370
name_return:
	a_code = code;

001270  aa  6 00102 2361 00	ldq  	pr6|66		code
001271  aa  6 00314 7561 20	stq  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 372
	return;

001272  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO ref_name                                           STATEMENT 1 ON LINE 376
ref_name: entry (a_segptr, a_namecnt, a_refname, a_code);

001273  at     000004000103
001274  tt     000105000110
001275  ta     000111000000
001276  ta     001273000000
001277  da     000245300000
001300  aa   000420 6270 00	eax7 	272
001301  aa  7 00034 3521 20	epp2 	pr7|28,*
001302  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001303  aa     000010000000
001304  aa     000000000000
001305  aa  6 00042 3735 20	epp7 	pr6|34,*
001306  aa  7 00004 2361 20	ldq  	pr7|4,*
001307  aa   000002 6040 04	tmi  	2,ic		001311
001310  aa   777777 3760 07	anq  	262143,dl
001311  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001312  aa  6 00375 7561 00	stq  	pr6|253
001313  aa  6 00032 3715 20	epp5 	pr6|26,*
001314  aa  5 00002 3535 20	epp3 	pr5|2,*
001315  aa  6 00322 2535 00	spri3	pr6|210
001316  aa  5 00010 3515 20	epp1 	pr5|8,*
001317  aa  6 00314 2515 00	spri1	pr6|204
						STATEMENT 1 ON LINE 378
          namecnt = max(a_namecnt, 1);

001320  aa  6 00032 3735 20	epp7 	pr6|26,*
001321  aa  7 00004 2361 20	ldq  	pr7|4,*		a_namecnt
001322  aa   000001 1160 07	cmpq 	1,dl
001323  aa   000002 6050 04	tpl  	2,ic		001325
001324  aa   000001 2360 07	ldq  	1,dl
001325  aa  6 00175 7561 00	stq  	pr6|125		namecnt
						STATEMENT 1 ON LINE 380
          segnum = fixed (baseno (a_segptr), 17);

001326  aa  6 00322 3715 20	epp5 	pr6|210,*		a_segptr
001327  aa  5 00000 3715 20	epp5 	pr5|0,*		a_segptr
001330  aa  5 00000 2131 00	epaq 	pr5|0		a_segptr
001331  aa   077777 3750 03	ana  	32767,du
001332  aa   000066 7730 00	lrl  	54
001333  aa  6 00302 7561 00	stq  	pr6|194		segnum
						STATEMENT 1 ON LINE 381
          call ref_name_$get_refname (segnum, namecnt, rname, code);

001334  aa  6 00302 3521 00	epp2 	pr6|194		segnum
001335  aa  6 00400 2521 00	spri2	pr6|256
001336  aa  6 00175 3521 00	epp2 	pr6|125		namecnt
001337  aa  6 00402 2521 00	spri2	pr6|258
001340  aa  6 00272 3521 00	epp2 	pr6|186		rname
001341  aa  6 00404 2521 00	spri2	pr6|260
001342  aa  6 00102 3521 00	epp2 	pr6|66		code
001343  aa  6 00406 2521 00	spri2	pr6|262
001344  aa   776541 3520 04	epp2 	-671,ic		000105 = 404000000021
001345  aa  6 00410 2521 00	spri2	pr6|264
001346  aa  6 00412 2521 00	spri2	pr6|266
001347  aa   776531 3520 04	epp2 	-679,ic		000100 = 530000000040
001350  aa  6 00414 2521 00	spri2	pr6|268
001351  aa   776540 3520 04	epp2 	-672,ic		000111 = 404000000043
001352  aa  6 00416 2521 00	spri2	pr6|270
001353  aa  6 00376 6211 00	eax1 	pr6|254
001354  aa   020000 4310 07	fld  	8192,dl
001355  aa  6 00044 3701 20	epp4 	pr6|36,*
001356  la  4 00026 3521 20	epp2 	pr4|22,*		ref_name_$get_refname
001357  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 382
	if code = 0 then do;

001360  aa  6 00102 2361 00	ldq  	pr6|66		code
001361  aa   000012 6010 04	tnz  	10,ic		001373
						STATEMENT 1 ON LINE 383
	   a_refname = rname;

001362  aa  6 00032 3735 20	epp7 	pr6|26,*
001363  aa  7 00006 3715 20	epp5 	pr7|6,*
001364  aa  6 00375 2351 00	lda  	pr6|253
001365  aa  6 00271 7271 00	lxl7 	pr6|185		rname
001366  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001367  aa  6 00272 00 0017	desc9a	pr6|186,x7	rname
001370  aa  5 00000 00 0005	desc9a	pr5|0,al		a_refname
						STATEMENT 1 ON LINE 384
	   a_code = 0;

001371  aa  6 00314 4501 20	stz  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 385
	end;

001372  aa   000002 7100 04	tra  	2,ic		001374
						STATEMENT 1 ON LINE 386
	else a_code = code;

001373  aa  6 00314 7561 20	stq  	pr6|204,*		a_code
						STATEMENT 1 ON LINE 388
	return;

001374  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO trans_sw                                           STATEMENT 1 ON LINE 392
trans_sw: entry (a_newsw, a_oldsw);

001375  at     000002000105
001376  ta     000105000000
001377  ta     001375000000
001400  da     000253300000
001401  aa   000420 6270 00	eax7 	272
001402  aa  7 00034 3521 20	epp2 	pr7|28,*
001403  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001404  aa     000004000000
001405  aa     000000000000
						STATEMENT 1 ON LINE 394
	newsw = a_newsw;

001406  aa  6 00032 3735 20	epp7 	pr6|26,*
001407  aa  7 00002 2361 20	ldq  	pr7|2,*		a_newsw
001410  aa  6 00176 7561 00	stq  	pr6|126		newsw
						STATEMENT 1 ON LINE 395
	oldsw = fixed (pds$transparent, 2);

001411  aa  6 00044 3701 20	epp4 	pr6|36,*
001412  la  4 00020 2351 20	lda  	pr4|16,*		pds$transparent
001413  aa   000106 7730 00	lrl  	70
001414  aa  6 00177 7561 00	stq  	pr6|127		oldsw
						STATEMENT 1 ON LINE 396
	if newsw > 3 then go to fin2;

001415  aa  6 00176 2361 00	ldq  	pr6|126		newsw
001416  aa   000003 1160 07	cmpq 	3,dl
001417  aa   000015 6054 04	tpnz 	13,ic		001434
						STATEMENT 1 ON LINE 397
	if newsw < 0 then go to fin2;

001420  aa  6 00176 2361 00	ldq  	pr6|126		newsw
001421  aa   000013 6040 04	tmi  	11,ic		001434
						STATEMENT 1 ON LINE 398
	if newsw = 0 then pds$transparent = "0"b;

001422  aa   000003 6010 04	tnz  	3,ic		001425
001423  la  4 00020 4501 20	stz  	pr4|16,*		pds$transparent
001424  aa   000010 7100 04	tra  	8,ic		001434
						STATEMENT 1 ON LINE 399
	else if newsw = 1 then pds$transparent = "01"b;

001425  aa   000001 1160 07	cmpq 	1,dl
001426  aa   000004 6010 04	tnz  	4,ic		001432
001427  aa   200000 2350 03	lda  	65536,du
001430  la  4 00020 7551 20	sta  	pr4|16,*		pds$transparent
001431  aa   000003 7100 04	tra  	3,ic		001434
						STATEMENT 1 ON LINE 400
	else pds$transparent = "11"b;

001432  aa   600000 2350 03	lda  	196608,du
001433  la  4 00020 7551 20	sta  	pr4|16,*		pds$transparent
						STATEMENT 1 ON LINE 402
fin2:	a_oldsw = oldsw;

001434  aa  6 00177 2361 00	ldq  	pr6|127		oldsw
001435  aa  7 00004 7561 20	stq  	pr7|4,*		a_oldsw
						STATEMENT 1 ON LINE 403
	return;

001436  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 412
     end fs_get;

  END PROCEDURE fs_get


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
