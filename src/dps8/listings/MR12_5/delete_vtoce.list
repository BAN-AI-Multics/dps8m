	COMPILATION LISTING OF SEGMENT delete_vtoce
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0954.5 mst Sat
	    Options: optimize list

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1987 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        * Copyright (c) 1972 by Massachusetts Institute of   *
        9*        * Technology and Honeywell Information Systems, Inc. *
       10*        *                                                    *
       11*        ****************************************************** */
       12 
       13 /*
       14*   delete_vtoce (branchp, code)
       15*
       16*
       17*   FUNCTION -
       18*
       19*   This procedure deletes the vtoc entry of the segment whose branch is pointed  to
       20*   by the input argument "branchp". It performs the following system functions:
       21*   -  Disconnect  the  page table (if any) of the segment from any sdw that may be
       22*   pointing to it.
       23*   - Free all disk, bulk store and core addresses occupied by the  pages  of  that
       24*   segment.
       25*   - Free the vtoc entry for that segment.
       26*   -  If  the  segment  is  a directory which received some quota from its parent,
       27*   return this quota to the parent.
       28*
       29*
       30*   IMPLEMENTATION -
       31*
       32*   This procedure is called only by delentry.  It  assumes  the  following  initial
       33*   conditions:
       34*   -  The directory in which the branch resides is locked for writing on behalf of the current
       35*   process.
       36*   - All items of the branch pointed to by "branchp" are valid.
       37*   - All conditions required to delete the segment have already been checked.
       38*   - If the segment to be deleted is a directory, it is locked on  behalf  of  the
       39*   current process.
       40*
       41*
       42*   MODIFICATIONS -
       43*
       44*   03/27/75	Andre Bensoussan.
       45*   07/29/77	Greenberg, for TPP update.
       46*   09/17/82	J. Bongiovanni to optimize by reducing work done under
       47*   AST Lock
       48*   10/26/82	J. Bongiovanni, for fm_damaged
       49*   05/30/83	E. N. Kittlitz search_ast$check, setfaults$if_active pvid, vtocx args
       50*
       51**/
       52 
       53 
       54 /* format: style4 */
       55 
       56 delete_vtoce: procedure (branchp, code);
       57 
       58 
       59 dcl  branchp ptr;					/* Input  - branch pointer */
       60 dcl  code fixed bin (35);				/* Output - error code */
       61 
       62 dcl  uid bit (36) aligned;
       63 dcl  pvid bit (36) aligned;
       64 dcl  (i, pvtx, vtocx) fixed bin (17);
       65 dcl  n_deposit_pages fixed bin;
       66 dcl  1 local_aste aligned like aste;
       67 dcl  1 local_vtoce aligned like vtoce;
       68 dcl  deposit_list (0:255) bit (22) aligned;
       69 dcl  pageno_list (0:255) fixed bin aligned;
       70 
       71 dcl  null builtin;
       72 
       73 dcl  error_table_$vtoce_connection_fail external fixed bin (35);
       74 dcl  sst$checksum_filemap fixed bin (35) external;
       75 
       76 dcl  lock$lock_ast entry;
       77 dcl  lock$unlock_ast entry;
       78 dcl  search_ast$check entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (35)) returns (ptr);
       79 dcl  setfaults$if_active entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (1) aligned);
       80 dcl  quotaw$mq entry (ptr, ptr, fixed bin, bit (1) aligned, fixed bin (35));
       81 dcl  vtoc_man$await_vtoce entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
       82 dcl  vtoc_man$free_vtoce entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
       83 dcl  get_pvtx entry (bit (36), fixed bin (35)) returns (fixed bin);
       84 dcl  get_pvtx$hold_pvtx entry (bit (36) aligned, fixed bin, fixed bin (35));
       85 dcl  get_pvtx$release_pvtx entry (bit (36) aligned, fixed bin);
       86 dcl  activate entry (ptr, fixed bin (35)) returns (ptr);
       87 dcl  deactivate$for_delete entry (ptr, fixed bin (35));
       88 dcl  pc$get_file_map entry (ptr, ptr, ptr, fixed bin, ptr, ptr);
       89 dcl  pc$deposit_list entry (fixed bin, fixed bin, ptr, fixed bin, ptr);
       90 dcl  truncate_vtoce$truncate_vtoce_delete entry (ptr, fixed bin (35));
       91 dcl  syserr$error_code entry options (variable);
       92 
       93 dcl  (error_table_$mylock, error_table_$root) fixed bin (35) external;
       94 
       95 
       96 	code = 0;
       97 	ep = branchp;
       98 
       99 	uid = entry.uid;
      100 	pvid = entry.pvid;
      101 	pvtx = get_pvtx (entry.pvid, code); if code ^= 0 then return;
      102 	vtocx = entry.vtocx;
      103 
      104 
      105 	call get_pvtx$hold_pvtx (pvid, pvtx, code);
      106 	if code ^= 0 then return;
      107 	call setfaults$if_active (uid, pvid, vtocx, "0"b);
      108 
      109 	call truncate_vtoce$truncate_vtoce_delete (ep, code);
      110 	if code ^= 0 then if code = error_table_$vtoce_connection_fail then do;
      111 		code = 0;				/* delete the branch only */
      112 		go to release;
      113 	     end;
      114 	     else go to release;
      115 
      116 	if entry.dirsw then call RETURN_QUOTA;
      117 
      118 	n_deposit_pages = 0;
      119 
      120 	call lock$lock_ast;
      121 
      122 	astep = search_ast$check (uid, pvid, vtocx, (0)); /* don't worry about double uid */
      123 	if astep ^= null then do;
      124 	     if aste.dius then do;			/* volume dumper is using this */
      125 		call lock$unlock_ast;
      126 		astep = activate (ep, code);
      127 		if code ^= 0 then go to release;
      128 	     end;
      129 	     call pc$get_file_map (astep, addr (local_aste), addr (local_vtoce.fm), n_deposit_pages,
      130 		addr (deposit_list), addr (pageno_list));
      131 	     if aste.fm_damaged & (sst$checksum_filemap ^= 0)
      132 	     then n_deposit_pages = 0;
      133 	     call deactivate$for_delete (astep, code);
      134 	end;
      135 
      136 	if code = 0 then
      137 	     call vtoc_man$free_vtoce (pvid, pvtx, vtocx, code);
      138 
      139 	call lock$unlock_ast;
      140 	if code ^= 0 then go to release;
      141 
      142 	if n_deposit_pages > 0 then do;
      143 	     call vtoc_man$await_vtoce (pvid, pvtx, vtocx, code);
      144 	     if code = 0 then
      145 		call pc$deposit_list (pvtx, n_deposit_pages, addr (deposit_list),
      146 		     vtocx, addr (pageno_list));
      147 	end;
      148 
      149 release:
      150 	call get_pvtx$release_pvtx (pvid, pvtx);
      151 
      152 	return;
      153 
      154 
      155 
      156 RETURN_QUOTA: procedure;
      157 
      158 dcl  qsw bit (1) init ("0"b);
      159 dcl  local_tpp (0:1) fixed bin (71) aligned;
      160 dcl  fixedoverflow condition;
      161 dcl  par_pvid bit (36) aligned;
      162 dcl  par_pvtx fixed bin;
      163 dcl  pep ptr;
      164 dcl  par_vtocx fixed bin (17);
      165 dcl  sumcode fixed bin (35);
      166 dcl  READ_LOCK bit (36) options (constant) static init ("000000000000"b3) aligned;
      167 
      168 
      169 dcl  sum$getbranch_root_my entry (ptr, bit (36) aligned, ptr, fixed bin (35));
      170 dcl  lock$dir_unlock entry (ptr);
      171 dcl  (vtoc_man$get_vtoce, vtoc_man$put_vtoce) entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr,
      172 	fixed bin (35));
      173 
      174 dcl  1 local_vtoce like vtoce aligned;
      175 
      176 	astep = activate (ep, code); if code ^= 0 then return; /* Locks the AST and leaves it locked */
      177 
      178 	do i = 0 to 1;
      179 	     if (i = 0 & aste.tqsw (i) & ^aste.master_dir) |
      180 		(i = 1 & aste.tqsw (i)) then
      181 		do;
      182 		qsw = "1"b;
      183 		call quotaw$mq (ptr (astep, astep -> aste.par_astep), astep, -aste.quota (i),
      184 		     bit (fixed (i, 1), 1), code);
      185 		if code ^= 0 then call syserr$error_code (4, code,
      186 			"delete_vtoce: from quotaw, pvid ^w, vtocx ^o", pvid, vtocx);
      187 	     end;
      188 	end;
      189 
      190 	call lock$unlock_ast;
      191 
      192 	if ^qsw then return;
      193 
      194 /*	UPDATE TPP TO THE SUPERIOR */
      195 
      196 	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "100"b, addr (local_vtoce), code);
      197 	if code ^= 0 then return;
      198 
      199 	local_tpp = local_vtoce.trp;
      200 	if local_tpp (0) = 0 & local_tpp (1) = 0 then return;
      201 
      202 
      203 	dp = ptr (ep, 0);				/* We're deleting >a>b>c>d. dp -> >a>b>c */
      204 	call sum$getbranch_root_my (dp, READ_LOCK, pep, sumcode);
      205 						/* This locking of parent's parent is to prevent seg move on parent. */
      206 
      207 	if sumcode = 0 | sumcode = error_table_$root | sumcode = error_table_$mylock then do;
      208 	     par_pvid = dir.pvid;
      209 	     par_vtocx = dir.vtocx;
      210 	end;
      211 	else do;
      212 	     code = sumcode;
      213 	     go to tploss;
      214 	end;
      215 
      216 	call lock$lock_ast;				/* must protect VTOCE */
      217 
      218 	par_pvtx = get_pvtx ((par_pvid), code);
      219 	if code ^= 0 then go to tpploss1;
      220 						/* Shouldn't happen, RLV better be mounted. */
      221 	call vtoc_man$get_vtoce (par_pvid, par_pvtx, par_vtocx, "100"b, addr (local_vtoce), code);
      222 	if code ^= 0 then go to tpploss1;
      223 
      224 	on fixedoverflow go to tpploss1;
      225 	local_vtoce.trp = local_vtoce.trp + local_tpp;
      226 	revert fixedoverflow;
      227 
      228 	call vtoc_man$put_vtoce (par_pvid, par_pvtx, par_vtocx, "100"b, addr (local_vtoce), code);
      229 tpploss1:
      230 	call lock$unlock_ast;
      231 tploss:
      232 	if sumcode = 0 then call lock$dir_unlock (ptr (pep, 0));
      233 
      234 	if code ^= 0 then call syserr$error_code (4, code,
      235 		"delete_vtoce: cannot add time/page product (^d ^d) to pvid ^w vtocx ^o uid ^w.",
      236 		local_tpp, par_pvid, par_vtocx, dir.uid);
      237 
      238 	return;
      239 
      240      end RETURN_QUOTA;
      241 
      242 /* format: off */
      243  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      243 
      244  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  2     2 /* Modified 8/74 for NSS */
  2     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  2     4 /* Modified 3/82 BIM for change pclock */
  2     5 /* format: style3 */
  2     6 
  2     7 /* Template for the directory header. Length = 64 words. */
  2     8 
  2     9 dcl  dp ptr;
  2    10 
  2    11 dcl 1 dir based (dp) aligned,
  2    12 
  2    13    2 modify bit (36),				/* Process ID of last modifier */
  2    14    2 type bit (18) unaligned,			/* type of object = dir header */
  2    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  2    16     2 dtc (3),					/* date-time checked by salvager array */
  2    17       3 date bit (36),				/* the date */
  2    18       3 error bit (36),				/* what errors were discovered */
  2    19 
  2    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  2    21 
  2    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  2    23 
  2    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  2    25 
  2    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  2    27 
  2    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  2    29     2 version_number fixed bin (17),			/* version number of header */
  2    30 
  2    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  2    32     2 pad2 bit (18),
  2    33 
  2    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  2    35     2 pad3 bit (18),
  2    36 
  2    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  2    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  2    39 
  2    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  2    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  2    42 
  2    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  2    44     2 dir_count fixed bin (17),			/* number of directory branches */
  2    45 
  2    46     2 lcount fixed bin (17),				/* number of links */
  2    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  2    48 
  2    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  2    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  2    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  2    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  2    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  2    54     2 pad4 bit (14),
  2    55 
  2    56     2 iacl_count (0:7),
  2    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  2    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  2    59 
  2    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  2    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  2    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  2    63 
  2    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  2    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  2    66 
  2    67     2 htsize fixed bin (17),				/* size of hash table */
  2    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  2    69 
  2    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  2    71     2 pad6 fixed bin (17),
  2    72 
  2    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  2    74     2 pad7 bit (18)) unaligned,
  2    75 
  2    76     2 dts bit (36),					/* date-time directory last salvaged */
  2    77 
  2    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  2    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  2    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  2    81     2 checksum bit (36),				/* checksummed from uid on */
  2    82     2 owner bit (36);				/* uid of parent dir */
  2    83 
  2    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  2    85 
  2    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      244 
      245  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      245 
      246  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  4     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  4     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  4     4 
  4     5 dcl  vtocep ptr;
  4     6 
  4     7 dcl 1 vtoce based (vtocep) aligned,
  4     8 
  4     9 
  4    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  4    11 
  4    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  4    13 
  4    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  4    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  4    16     2 records bit (9),				/* number of records used by the seg in second storage */
  4    17     2 pad2 bit (9),
  4    18 
  4    19     2 dtu bit (36),					/* date and time segment was last used */
  4    20 
  4    21     2 dtm bit (36),					/* date and time segment was last modified */
  4    22 
  4    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  4    24     2 deciduous bit (1),				/* true if hc_sdw */
  4    25     2 nid bit (1),					/* no incremental dump switch */
  4    26     2 dnzp bit (1),					/* Dont null zero pages */
  4    27     2 gtpd bit (1),					/* Global transparent paging device */
  4    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  4    29     2 damaged bit (1),				/* TRUE if contents damaged */
  4    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  4    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  4    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  4    33     2 pad3 bit (8),
  4    34     2 dirsw bit (1),				/* directory switch */
  4    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  4    36     2 pad4 bit (16)) unaligned,			/* not used */
  4    37 
  4    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  4    39 
  4    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  4    41 
  4    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  4    43 
  4    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  4    45 
  4    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  4    47 
  4    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  4    49 
  4    50 
  4    51 
  4    52 
  4    53 
  4    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  4    55 
  4    56     2 pad6 (10) bit (36),				/* not used */
  4    57 
  4    58     2 ncd bit (1),					/* no complete dump switch */
  4    59     2 pad7 bit (17),
  4    60     2 pad8 bit (18),
  4    61 
  4    62     2 dtd bit (36),					/* date-time-dumped */
  4    63 
  4    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  4    65 
  4    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  4    67 
  4    68 
  4    69 
  4    70 
  4    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  4    72 
  4    73     2 primary_name char (32),				/* primary name of the segment */
  4    74 
  4    75     2 time_created bit (36),				/* time the segment was created */
  4    76 
  4    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  4    78 
  4    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  4    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  4    81 
  4    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  4    83 
  4    84     2 access_class bit (72),				/* access class in branch */
  4    85     2 perm_flags aligned,
  4    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  4    87       3 pad9 bit (35) unal,
  4    88     2 owner bit (36);				/* pvid of this volume */
  4    89 
  4    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  4    91 
  4    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  4    93     2 pad1 bit (7*36),
  4    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  4    95     2 pad2 bit (184*36);
  4    96 
  4    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      246 
      247 
      248 /* format: on */
      249 
      250 /* BEGIN MESSAGE DOCUMENTATION
      251*
      252*   Message:
      253*   delete_vtoce: from quotaw, pvid PPP. vtocx VVV ERRORMESSAGE
      254*
      255*   S: $log
      256*
      257*   T: $run
      258*
      259*   M: While deleting a directory which had a quota
      260*   account, a quota handling  problem usually record
      261*   quota overflow, was encountered.
      262*
      263*   A: $ignore
      264*
      265*   Message:
      266*   delete_vtoce: cannot add time/page product (SEGTPP DIRTPP)
      267*   to pvid PPP vtocx VVV uid UUU ERRORMESSAGE
      268*
      269*   S: $log
      270*
      271*   T: $run
      272*
      273*   M: During the deletion of a directory which had
      274*   a quota account, a difficulty was encountered in
      275*   reflecting its time/page product upward. SEGTPP and
      276*   DIRTPP are the time/page product for segments and directories,
      277*   respectively.
      278*
      279*   A: $notify_sa
      280*
      281*   END MESSAGE DOCUMENTATION */
      282      end delete_vtoce;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0851.5  delete_vtoce.pl1                  >spec>install>1115>delete_vtoce.pl1
243          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
244          2    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
245          3    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
246          4    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
READ_LOCK                       000004 constant        bit(36)                  initial dcl 166 set ref 204*
activate                        000040 constant        entry                    external dcl 86 ref 126 176
aste                                   based           structure                level 1 dcl 1-11
astep                           001422 automatic       pointer                  dcl 1-9 set ref 122* 123 124 126* 129* 131 133* 176*
                                                                                  179 179 179 183 183 183 183 183* 183
branchp                                parameter       pointer                  dcl 59 ref 56 97
code                                   parameter       fixed bin(35,0)          dcl 60 set ref 56 96* 101* 101 105* 106 109* 110 110
                                                                                  111* 126* 127 133* 136 136* 140 143* 144 176* 176
                                                                                  183* 185 185* 196* 197 212* 218* 219 221* 222 228*
                                                                                  234 234*
deactivate$for_delete           000042 constant        entry                    external dcl 87 ref 133
deposit_list                    000422 automatic       bit(22)                  array dcl 68 set ref 129 129 144 144
dir                                    based           structure                level 1 dcl 2-11
dirsw                    32            based           bit(1)                   level 2 packed packed unaligned dcl 3-8 ref 116
dius                      5(16)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 124
dp                              001424 automatic       pointer                  dcl 2-9 set ref 203* 204* 208 209 234
entry                                  based           structure                level 1 dcl 3-8
ep                              001426 automatic       pointer                  dcl 3-6 set ref 97* 99 100 101 102 109* 116 126*
                                                                                  176* 203
error_table_$mylock             000054 external static fixed bin(35,0)          dcl 93 ref 207
error_table_$root               000056 external static fixed bin(35,0)          dcl 93 ref 207
error_table_$vtoce_connection_fail
                                000010 external static fixed bin(35,0)          dcl 73 ref 110
fixedoverflow                   000106 stack reference condition                dcl 160 ref 224 226
fm                       20     000122 automatic       bit(18)                  array level 2 packed packed unaligned dcl 67 set ref
                                                                                  129 129
fm_damaged                5(12)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 131
get_pvtx                        000032 constant        entry                    external dcl 83 ref 101 218
get_pvtx$hold_pvtx              000034 constant        entry                    external dcl 84 ref 105
get_pvtx$release_pvtx           000036 constant        entry                    external dcl 85 ref 149
i                               000102 automatic       fixed bin(17,0)          dcl 64 set ref 178* 179 179 179 179 183 183 183*
local_aste                      000106 automatic       structure                level 1 dcl 66 set ref 129 129
local_tpp                       000102 automatic       fixed bin(71,0)          array dcl 159 set ref 199* 200 200 225 234*
local_vtoce                     000122 automatic       structure                level 1 dcl 67 in procedure "delete_vtoce"
local_vtoce                     000122 automatic       structure                level 1 dcl 174 in procedure "RETURN_QUOTA" set ref
                                                                                  196 196 221 221 228 228
lock$dir_unlock                 000062 constant        entry                    external dcl 170 ref 231
lock$lock_ast                   000014 constant        entry                    external dcl 76 ref 120 216
lock$unlock_ast                 000016 constant        entry                    external dcl 77 ref 125 139 190 229
master_dir                5(22)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 179
n_deposit_pages                 000105 automatic       fixed bin(17,0)          dcl 65 set ref 118* 129* 131* 142 144*
null                                                   builtin function         dcl 71 ref 123
pageno_list                     001022 automatic       fixed bin(17,0)          array dcl 69 set ref 129 129 144 144
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 183 183
par_pvid                        000114 automatic       bit(36)                  dcl 161 set ref 208* 218 221* 228* 234*
par_pvtx                        000115 automatic       fixed bin(17,0)          dcl 162 set ref 218* 221* 228*
par_vtocx                       000120 automatic       fixed bin(17,0)          dcl 164 set ref 209* 221* 228* 234*
pc$deposit_list                 000046 constant        entry                    external dcl 89 ref 144
pc$get_file_map                 000044 constant        entry                    external dcl 88 ref 129
pep                             000116 automatic       pointer                  dcl 163 set ref 204* 231 231
pvid                            000101 automatic       bit(36)                  dcl 63 in procedure "delete_vtoce" set ref 100* 105*
                                                                                  107* 122* 136* 143* 149* 185* 196*
pvid                     11            based           bit(36)                  level 2 in structure "dir" dcl 2-11 in procedure
                                                                                  "delete_vtoce" ref 208
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "delete_vtoce" set ref 100
                                                                                  101*
pvtx                            000103 automatic       fixed bin(17,0)          dcl 64 set ref 101* 105* 136* 143* 144* 149* 196*
qsw                             000100 automatic       bit(1)                   initial packed unaligned dcl 158 set ref 158* 182*
                                                                                  192
quota                    10            based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 1-11 ref 183
quotaw$mq                       000024 constant        entry                    external dcl 80 ref 183
search_ast$check                000020 constant        entry                    external dcl 78 ref 122
setfaults$if_active             000022 constant        entry                    external dcl 79 ref 107
sst$checksum_filemap            000012 external static fixed bin(35,0)          dcl 74 ref 131
sum$getbranch_root_my           000060 constant        entry                    external dcl 169 ref 204
sumcode                         000121 automatic       fixed bin(35,0)          dcl 165 set ref 204* 207 207 207 212 231
syserr$error_code               000052 constant        entry                    external dcl 91 ref 185 234
tqsw                      5(24)        based           bit(1)                   array level 2 packed packed unaligned dcl 1-11 ref
                                                                                  179 179
trp                      12     000122 automatic       fixed bin(71,0)          array level 2 packed packed unaligned dcl 174 set
                                                                                  ref 199 225* 225
truncate_vtoce$truncate_vtoce_delete
                                000050 constant        entry                    external dcl 90 ref 109
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "delete_vtoce" ref 99
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 2-11 in procedure
                                                                                  "delete_vtoce" set ref 234*
uid                             000100 automatic       bit(36)                  dcl 62 in procedure "delete_vtoce" set ref 99* 107*
                                                                                  122*
vtoc_man$await_vtoce            000026 constant        entry                    external dcl 81 ref 143
vtoc_man$free_vtoce             000030 constant        entry                    external dcl 82 ref 136
vtoc_man$get_vtoce              000064 constant        entry                    external dcl 171 ref 196 221
vtoc_man$put_vtoce              000066 constant        entry                    external dcl 171 ref 228
vtoce                                  based           structure                level 1 dcl 4-7
vtocx                           000104 automatic       fixed bin(17,0)          dcl 64 in procedure "delete_vtoce" set ref 102* 107*
                                                                                  122* 136* 143* 144* 185* 196*
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 2-11 in procedure "delete_vtoce" ref 209
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "delete_vtoce" ref 102

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
seg_aste                               based           structure                level 1 dcl 1-96
seg_vtoce                              based           structure                level 1 dcl 4-92
version_number_2                       internal static fixed bin(17,0)          initial dcl 2-84
vtoce_parts                            based           bit(2304)                array dcl 4-90
vtocep                                 automatic       pointer                  dcl 4-5

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_QUOTA                    000460 constant        entry                    internal dcl 156 ref 116
delete_vtoce                    000065 constant        entry                    external dcl 56
release                         000445 constant        label                    dcl 149 ref 110 112 127 140
tploss                          001150 constant        label                    dcl 231 ref 213
tpploss1                        001143 constant        label                    dcl 229 ref 219 222 224

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 129 129 129 129 129 129 129 129 144 144 144 144
                                                                                  196 196 221 221 228 228
bit                                                    builtin function         ref 183 183
fixed                                                  builtin function         ref 183 183
ptr                                                    builtin function         ref 183 183 203 231 231

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1566        1656    1236        1576
Length      2152    1236        70         260     330           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
delete_vtoce                        846 external procedure  is an external procedure.  
RETURN_QUOTA                        352 internal procedure  enables or reverts conditions.  
on unit on line 224                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
RETURN_QUOTA             000100 qsw                         RETURN_QUOTA
                         000102 local_tpp                   RETURN_QUOTA
                         000114 par_pvid                    RETURN_QUOTA
                         000115 par_pvtx                    RETURN_QUOTA
                         000116 pep                         RETURN_QUOTA
                         000120 par_vtocx                   RETURN_QUOTA
                         000121 sumcode                     RETURN_QUOTA
                         000122 local_vtoce                 RETURN_QUOTA
delete_vtoce             000100 uid                         delete_vtoce
                         000101 pvid                        delete_vtoce
                         000102 i                           delete_vtoce
                         000103 pvtx                        delete_vtoce
                         000104 vtocx                       delete_vtoce
                         000105 n_deposit_pages             delete_vtoce
                         000106 local_aste                  delete_vtoce
                         000122 local_vtoce                 delete_vtoce
                         000422 deposit_list                delete_vtoce
                         001022 pageno_list                 delete_vtoce
                         001422 astep                       delete_vtoce
                         001424 dp                          delete_vtoce
                         001426 ep                          delete_vtoce

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       return_mac          tra_ext_1           enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
activate                      deactivate$for_delete         get_pvtx                      get_pvtx$hold_pvtx
get_pvtx$release_pvtx         lock$dir_unlock               lock$lock_ast                 lock$unlock_ast
pc$deposit_list               pc$get_file_map               quotaw$mq                     search_ast$check
setfaults$if_active           sum$getbranch_root_my         syserr$error_code
truncate_vtoce$truncate_vtoce_delete                        vtoc_man$await_vtoce          vtoc_man$free_vtoce
vtoc_man$get_vtoce            vtoc_man$put_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$mylock           error_table_$root             error_table_$vtoce_connection_fail
sst$checksum_filemap


CONSTANTS
000000  aa     524000000116

000001  aa     514000000044

000002  aa     524000000054

000003  aa     404000000005

000004  aa     000000000000

000005  aa     404000000021

000006  aa     404000000043

000007  aa     464000000000

000010  aa     077777000043
000011  aa     000001000000

000012  aa     410100000107
000013  aa     000000000000
000014  aa     000000000001
000015  aa     000000000002

000016  aa  146 151 170 145	fixe
000017  aa  144 157 166 145	dove
000020  aa  162 146 154 157	rflo
000021  aa  167 000 000 000	w

000022  aa  144 145 154 145	dele
000023  aa  164 145 137 166	te_v
000024  aa  164 157 143 145	toce
000025  aa  072 040 146 162	: fr
000026  aa  157 155 040 161	om q
000027  aa  165 157 164 141	uota
000030  aa  167 054 040 160	w, p
000031  aa  166 151 144 040	vid 
000032  aa  136 167 054 040	^w, 
000033  aa  166 164 157 143	vtoc
000034  aa  170 040 136 157	x ^o

000035  aa  144 145 154 145	dele
000036  aa  164 145 137 166	te_v
000037  aa  164 157 143 145	toce
000040  aa  072 040 143 141	: ca
000041  aa  156 156 157 164	nnot
000042  aa  040 141 144 144	 add
000043  aa  040 164 151 155	 tim
000044  aa  145 057 160 141	e/pa
000045  aa  147 145 040 160	ge p
000046  aa  162 157 144 165	rodu
000047  aa  143 164 040 050	ct (
000050  aa  136 144 040 136	^d ^
000051  aa  144 051 040 164	d) t
000052  aa  157 040 160 166	o pv
000053  aa  151 144 040 136	id ^
000054  aa  167 040 166 164	w vt
000055  aa  157 143 170 040	ocx 
000056  aa  136 157 040 165	^o u
000057  aa  151 144 040 136	id ^
000060  aa  167 056 000 000	w.

BEGIN PROCEDURE delete_vtoce
ENTRY TO delete_vtoce                                       STATEMENT 1 ON LINE 56
delete_vtoce: procedure (branchp, code);

000061  at     000002000007
000062  ta     000006000000
000063  ta     000061000000
000064  da     000306300000
000065  aa   001520 6270 00	eax7 	848
000066  aa  7 00034 3521 20	epp2 	pr7|28,*
000067  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000070  aa     000004000000
000071  aa     000000000000
						STATEMENT 1 ON LINE 96
	code = 0;

000072  aa  6 00032 3735 20	epp7 	pr6|26,*
000073  aa  7 00004 4501 20	stz  	pr7|4,*		code
						STATEMENT 1 ON LINE 97
	ep = branchp;

000074  aa  7 00002 3715 20	epp5 	pr7|2,*		branchp
000075  aa  5 00000 3715 20	epp5 	pr5|0,*		branchp
000076  aa  6 01426 6515 00	spri5	pr6|790		ep
						STATEMENT 1 ON LINE 99
	uid = entry.uid;

000077  aa  5 00002 2351 00	lda  	pr5|2		entry.uid
000100  aa  6 00100 7551 00	sta  	pr6|64		uid
						STATEMENT 1 ON LINE 100
	pvid = entry.pvid;

000101  aa  5 00030 2351 00	lda  	pr5|24		entry.pvid
000102  aa  6 00101 7551 00	sta  	pr6|65		pvid
						STATEMENT 1 ON LINE 101
	pvtx = get_pvtx (entry.pvid, code);

000103  aa  5 00030 3521 00	epp2 	pr5|24		entry.pvid
000104  aa  6 01432 2521 00	spri2	pr6|794
000105  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000106  aa  6 01434 2521 00	spri2	pr6|796
000107  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000110  aa  6 01436 2521 00	spri2	pr6|798
000111  aa  6 01430 6211 00	eax1 	pr6|792
000112  aa   014000 4310 07	fld  	6144,dl
000113  la  4 00032 3521 20	epp2 	pr4|26,*		get_pvtx
000114  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 2 ON LINE 101
 if code ^= 0 then return;

000115  aa  6 00032 3735 20	epp7 	pr6|26,*
000116  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000117  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 102
	vtocx = entry.vtocx;

000120  aa  6 01426 3715 20	epp5 	pr6|790,*		ep
000121  aa  5 00031 2351 00	lda  	pr5|25		entry.vtocx
000122  aa   000066 7330 00	lrs  	54
000123  aa  6 00104 7561 00	stq  	pr6|68		vtocx
						STATEMENT 1 ON LINE 105
	call get_pvtx$hold_pvtx (pvid, pvtx, code);

000124  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000125  aa  6 01432 2521 00	spri2	pr6|794
000126  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000127  aa  6 01434 2521 00	spri2	pr6|796
000130  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000131  aa  6 01436 2521 00	spri2	pr6|798
000132  aa  6 01430 6211 00	eax1 	pr6|792
000133  aa   014000 4310 07	fld  	6144,dl
000134  aa  6 00044 3701 20	epp4 	pr6|36,*
000135  la  4 00034 3521 20	epp2 	pr4|28,*		get_pvtx$hold_pvtx
000136  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 106
	if code ^= 0 then return;

000137  aa  6 00032 3735 20	epp7 	pr6|26,*
000140  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000141  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 107
	call setfaults$if_active (uid, pvid, vtocx, "0"b);

000142  aa   000000 2350 07	lda  	0,dl
000143  aa  6 01440 7551 00	sta  	pr6|800
000144  aa  6 00100 3521 00	epp2 	pr6|64		uid
000145  aa  6 01444 2521 00	spri2	pr6|804
000146  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000147  aa  6 01446 2521 00	spri2	pr6|806
000150  aa  6 00104 3521 00	epp2 	pr6|68		vtocx
000151  aa  6 01450 2521 00	spri2	pr6|808
000152  aa  6 01440 3521 00	epp2 	pr6|800
000153  aa  6 01452 2521 00	spri2	pr6|810
000154  aa  6 01442 6211 00	eax1 	pr6|802
000155  aa   020000 4310 07	fld  	8192,dl
000156  aa  6 00044 3701 20	epp4 	pr6|36,*
000157  la  4 00022 3521 20	epp2 	pr4|18,*		setfaults$if_active
000160  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 109
	call truncate_vtoce$truncate_vtoce_delete (ep, code);

000161  aa  6 01426 3521 00	epp2 	pr6|790		ep
000162  aa  6 01432 2521 00	spri2	pr6|794
000163  aa  6 00032 3735 20	epp7 	pr6|26,*
000164  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000165  aa  6 01434 2521 00	spri2	pr6|796
000166  aa  6 01430 6211 00	eax1 	pr6|792
000167  aa   010000 4310 07	fld  	4096,dl
000170  aa  6 00044 3701 20	epp4 	pr6|36,*
000171  la  4 00050 3521 20	epp2 	pr4|40,*		truncate_vtoce$truncate_vtoce_delete
000172  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 110
	if code ^= 0 then if code = error_table_$vtoce_connection_fail then do;

000173  aa  6 00032 3735 20	epp7 	pr6|26,*
000174  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000175  aa   000006 6000 04	tze  	6,ic		000203
000176  aa  6 00044 3701 20	epp4 	pr6|36,*
000177  la  4 00010 1161 20	cmpq 	pr4|8,*		error_table_$vtoce_connection_fail
000200  aa   000245 6010 04	tnz  	165,ic		000445
						STATEMENT 1 ON LINE 111
		code = 0;

000201  aa  7 00004 4501 20	stz  	pr7|4,*		code
						STATEMENT 1 ON LINE 112
		go to release;

000202  aa   000243 7100 04	tra  	163,ic		000445
						STATEMENT 1 ON LINE 113
	     end;

						STATEMENT 1 ON LINE 116
	if entry.dirsw then call RETURN_QUOTA;

000203  aa  6 01426 3715 20	epp5 	pr6|790,*		ep
000204  aa  5 00032 2351 00	lda  	pr5|26		entry.dirsw
000205  aa   400000 3150 03	cana 	131072,du
000206  aa   000005 6000 04	tze  	5,ic		000213
000207  aa  6 00056 6211 00	eax1 	pr6|46
000210  aa   000000 4310 07	fld  	0,dl
000211  aa   000247 3520 04	epp2 	167,ic		000460 = 000540627000
000212  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 118
	n_deposit_pages = 0;

000213  aa  6 00105 4501 00	stz  	pr6|69		n_deposit_pages
						STATEMENT 1 ON LINE 120
	call lock$lock_ast;

000214  aa  6 00056 6211 00	eax1 	pr6|46
000215  aa   000000 4310 07	fld  	0,dl
000216  aa  6 00044 3701 20	epp4 	pr6|36,*
000217  la  4 00014 3521 20	epp2 	pr4|12,*		lock$lock_ast
000220  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 122
	astep = search_ast$check (uid, pvid, vtocx, (0));

000221  aa  6 01440 4501 00	stz  	pr6|800
000222  aa  6 00100 3521 00	epp2 	pr6|64		uid
000223  aa  6 01456 2521 00	spri2	pr6|814
000224  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000225  aa  6 01460 2521 00	spri2	pr6|816
000226  aa  6 00104 3521 00	epp2 	pr6|68		vtocx
000227  aa  6 01462 2521 00	spri2	pr6|818
000230  aa  6 01440 3521 00	epp2 	pr6|800
000231  aa  6 01464 2521 00	spri2	pr6|820
000232  aa  6 01422 3521 00	epp2 	pr6|786		astep
000233  aa  6 01466 2521 00	spri2	pr6|822
000234  aa  6 01454 6211 00	eax1 	pr6|812
000235  aa   024000 4310 07	fld  	10240,dl
000236  aa  6 00044 3701 20	epp4 	pr6|36,*
000237  la  4 00020 3521 20	epp2 	pr4|16,*		search_ast$check
000240  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 123
	if astep ^= null then do;

000241  aa  6 01422 2371 00	ldaq 	pr6|786		astep
000242  aa   777546 6770 04	eraq 	-154,ic		000010 = 077777000043 000001000000
000243  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000244  aa   000104 6000 04	tze  	68,ic		000350
						STATEMENT 1 ON LINE 124
	     if aste.dius then do;

000245  aa  6 01422 3735 20	epp7 	pr6|786,*		astep
000246  aa  7 00005 2351 00	lda  	pr7|5		aste.dius
000247  aa   000002 3150 03	cana 	2,du
000250  aa   000025 6000 04	tze  	21,ic		000275
						STATEMENT 1 ON LINE 125
		call lock$unlock_ast;

000251  aa  6 00056 6211 00	eax1 	pr6|46
000252  aa   000000 4310 07	fld  	0,dl
000253  aa  6 00044 3701 20	epp4 	pr6|36,*
000254  la  4 00016 3521 20	epp2 	pr4|14,*		lock$unlock_ast
000255  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 126
		astep = activate (ep, code);

000256  aa  6 01426 3521 00	epp2 	pr6|790		ep
000257  aa  6 01432 2521 00	spri2	pr6|794
000260  aa  6 00032 3735 20	epp7 	pr6|26,*
000261  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000262  aa  6 01434 2521 00	spri2	pr6|796
000263  aa  6 01422 3521 00	epp2 	pr6|786		astep
000264  aa  6 01436 2521 00	spri2	pr6|798
000265  aa  6 01430 6211 00	eax1 	pr6|792
000266  aa   014000 4310 07	fld  	6144,dl
000267  aa  6 00044 3701 20	epp4 	pr6|36,*
000270  la  4 00040 3521 20	epp2 	pr4|32,*		activate
000271  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 127
		if code ^= 0 then go to release;

000272  aa  6 00032 3735 20	epp7 	pr6|26,*
000273  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000274  aa   000151 6010 04	tnz  	105,ic		000445
						STATEMENT 1 ON LINE 128
	     end;

						STATEMENT 1 ON LINE 129
	     call pc$get_file_map (astep, addr (local_aste), addr (local_vtoce.fm), n_deposit_pages,
		addr (deposit_list), addr (pageno_list));

000275  aa  6 00106 3735 00	epp7 	pr6|70		local_aste
000276  aa  6 01470 6535 00	spri7	pr6|824
000277  aa  6 00142 3715 00	epp5 	pr6|98		local_vtoce.fm
000300  aa  6 01472 6515 00	spri5	pr6|826
000301  aa  6 00422 3535 00	epp3 	pr6|274		deposit_list
000302  aa  6 01474 2535 00	spri3	pr6|828
000303  aa  6 01022 3515 00	epp1 	pr6|530		pageno_list
000304  aa  6 01476 2515 00	spri1	pr6|830
000305  aa  6 01422 3521 00	epp2 	pr6|786		astep
000306  aa  6 01502 2521 00	spri2	pr6|834
000307  aa  6 01470 3521 00	epp2 	pr6|824
000310  aa  6 01504 2521 00	spri2	pr6|836
000311  aa  6 01472 3521 00	epp2 	pr6|826
000312  aa  6 01506 2521 00	spri2	pr6|838
000313  aa  6 00105 3521 00	epp2 	pr6|69		n_deposit_pages
000314  aa  6 01510 2521 00	spri2	pr6|840
000315  aa  6 01474 3521 00	epp2 	pr6|828
000316  aa  6 01512 2521 00	spri2	pr6|842
000317  aa  6 01476 3521 00	epp2 	pr6|830
000320  aa  6 01514 2521 00	spri2	pr6|844
000321  aa  6 01500 6211 00	eax1 	pr6|832
000322  aa   030000 4310 07	fld  	12288,dl
000323  aa  6 00044 3701 20	epp4 	pr6|36,*
000324  la  4 00044 3521 20	epp2 	pr4|36,*		pc$get_file_map
000325  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 131
	     if aste.fm_damaged & (sst$checksum_filemap ^= 0)
	     then n_deposit_pages = 0;

000326  aa  6 01422 3735 20	epp7 	pr6|786,*		astep
000327  aa  7 00005 2351 00	lda  	pr7|5		aste.fm_damaged
000330  aa   000040 3150 03	cana 	32,du
000331  aa   000005 6000 04	tze  	5,ic		000336
000332  aa  6 00044 3701 20	epp4 	pr6|36,*
000333  la  4 00012 2361 20	ldq  	pr4|10,*		sst$checksum_filemap
000334  aa   000002 6000 04	tze  	2,ic		000336
000335  aa  6 00105 4501 00	stz  	pr6|69		n_deposit_pages
						STATEMENT 1 ON LINE 133
	     call deactivate$for_delete (astep, code);

000336  aa  6 01422 3521 00	epp2 	pr6|786		astep
000337  aa  6 01432 2521 00	spri2	pr6|794
000340  aa  6 00032 3715 20	epp5 	pr6|26,*
000341  aa  5 00004 3521 20	epp2 	pr5|4,*		code
000342  aa  6 01434 2521 00	spri2	pr6|796
000343  aa  6 01430 6211 00	eax1 	pr6|792
000344  aa   010000 4310 07	fld  	4096,dl
000345  aa  6 00044 3701 20	epp4 	pr6|36,*
000346  la  4 00042 3521 20	epp2 	pr4|34,*		deactivate$for_delete
000347  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 134
	end;

						STATEMENT 1 ON LINE 136
	if code = 0 then
	     call vtoc_man$free_vtoce (pvid, pvtx, vtocx, code);

000350  aa  6 00032 3735 20	epp7 	pr6|26,*
000351  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000352  aa   000016 6010 04	tnz  	14,ic		000370
000353  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000354  aa  6 01444 2521 00	spri2	pr6|804
000355  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000356  aa  6 01446 2521 00	spri2	pr6|806
000357  aa  6 00104 3521 00	epp2 	pr6|68		vtocx
000360  aa  6 01450 2521 00	spri2	pr6|808
000361  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000362  aa  6 01452 2521 00	spri2	pr6|810
000363  aa  6 01442 6211 00	eax1 	pr6|802
000364  aa   020000 4310 07	fld  	8192,dl
000365  aa  6 00044 3701 20	epp4 	pr6|36,*
000366  la  4 00030 3521 20	epp2 	pr4|24,*		vtoc_man$free_vtoce
000367  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 139
	call lock$unlock_ast;

000370  aa  6 00056 6211 00	eax1 	pr6|46
000371  aa   000000 4310 07	fld  	0,dl
000372  aa  6 00044 3701 20	epp4 	pr6|36,*
000373  la  4 00016 3521 20	epp2 	pr4|14,*		lock$unlock_ast
000374  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 140
	if code ^= 0 then go to release;

000375  aa  6 00032 3735 20	epp7 	pr6|26,*
000376  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000377  aa   000046 6010 04	tnz  	38,ic		000445
						STATEMENT 1 ON LINE 142
	if n_deposit_pages > 0 then do;

000400  aa  6 00105 2361 00	ldq  	pr6|69		n_deposit_pages
000401  aa   000044 6044 04	tmoz 	36,ic		000445
						STATEMENT 1 ON LINE 143
	     call vtoc_man$await_vtoce (pvid, pvtx, vtocx, code);

000402  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000403  aa  6 01444 2521 00	spri2	pr6|804
000404  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000405  aa  6 01446 2521 00	spri2	pr6|806
000406  aa  6 00104 3521 00	epp2 	pr6|68		vtocx
000407  aa  6 01450 2521 00	spri2	pr6|808
000410  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000411  aa  6 01452 2521 00	spri2	pr6|810
000412  aa  6 01442 6211 00	eax1 	pr6|802
000413  aa   020000 4310 07	fld  	8192,dl
000414  aa  6 00044 3701 20	epp4 	pr6|36,*
000415  la  4 00026 3521 20	epp2 	pr4|22,*		vtoc_man$await_vtoce
000416  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 144
	     if code = 0 then
		call pc$deposit_list (pvtx, n_deposit_pages, addr (deposit_list),
		     vtocx, addr (pageno_list));

000417  aa  6 00032 3735 20	epp7 	pr6|26,*
000420  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000421  aa   000024 6010 04	tnz  	20,ic		000445
000422  aa  6 00422 3715 00	epp5 	pr6|274		deposit_list
000423  aa  6 01476 6515 00	spri5	pr6|830
000424  aa  6 01022 3535 00	epp3 	pr6|530		pageno_list
000425  aa  6 01474 2535 00	spri3	pr6|828
000426  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000427  aa  6 01456 2521 00	spri2	pr6|814
000430  aa  6 00105 3521 00	epp2 	pr6|69		n_deposit_pages
000431  aa  6 01460 2521 00	spri2	pr6|816
000432  aa  6 01476 3521 00	epp2 	pr6|830
000433  aa  6 01462 2521 00	spri2	pr6|818
000434  aa  6 00104 3521 00	epp2 	pr6|68		vtocx
000435  aa  6 01464 2521 00	spri2	pr6|820
000436  aa  6 01474 3521 00	epp2 	pr6|828
000437  aa  6 01466 2521 00	spri2	pr6|822
000440  aa  6 01454 6211 00	eax1 	pr6|812
000441  aa   024000 4310 07	fld  	10240,dl
000442  aa  6 00044 3701 20	epp4 	pr6|36,*
000443  la  4 00046 3521 20	epp2 	pr4|38,*		pc$deposit_list
000444  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 147
	end;

						STATEMENT 1 ON LINE 149
release:
	call get_pvtx$release_pvtx (pvid, pvtx);

000445  aa  6 00101 3521 00	epp2 	pr6|65		pvid
000446  aa  6 01432 2521 00	spri2	pr6|794
000447  aa  6 00103 3521 00	epp2 	pr6|67		pvtx
000450  aa  6 01434 2521 00	spri2	pr6|796
000451  aa  6 01430 6211 00	eax1 	pr6|792
000452  aa   010000 4310 07	fld  	4096,dl
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00036 3521 20	epp2 	pr4|30,*		get_pvtx$release_pvtx
000455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 152
	return;

000456  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 282
     end delete_vtoce;

BEGIN PROCEDURE RETURN_QUOTA
ENTRY TO RETURN_QUOTA                                       STATEMENT 1 ON LINE 156
RETURN_QUOTA: procedure;

000457  da     000315200000
000460  aa   000540 6270 00	eax7 	352
000461  aa  7 00034 3521 20	epp2 	pr7|28,*
000462  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000463  aa     000000000000
000464  aa     000000000000
						STATEMENT 1 ON LINE 158
000465  aa  6 00100 4501 00	stz  	pr6|64		qsw
						STATEMENT 1 ON LINE 176
	astep = activate (ep, code);

000466  aa  6 00040 3735 20	epp7 	pr6|32,*
000467  aa  7 01426 3521 00	epp2 	pr7|790		ep
000470  aa  6 00426 2521 00	spri2	pr6|278
000471  aa  7 00032 3715 20	epp5 	pr7|26,*
000472  aa  5 00004 3521 20	epp2 	pr5|4,*		code
000473  aa  6 00430 2521 00	spri2	pr6|280
000474  aa  7 01422 3521 00	epp2 	pr7|786		astep
000475  aa  6 00432 2521 00	spri2	pr6|282
000476  aa  6 00424 6211 00	eax1 	pr6|276
000477  aa   014000 4310 07	fld  	6144,dl
000500  la  4 00040 3521 20	epp2 	pr4|32,*		activate
000501  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 2 ON LINE 176
 if code ^= 0 then return;

000502  aa  6 00040 3735 20	epp7 	pr6|32,*
000503  aa  7 00032 3715 20	epp5 	pr7|26,*
000504  aa  5 00004 2361 20	ldq  	pr5|4,*		code
000505  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 178
	do i = 0 to 1;

000506  aa  7 00102 4501 00	stz  	pr7|66		i
000507  aa   000000 0110 03	nop  	0,du
000510  aa  6 00040 3735 20	epp7 	pr6|32,*
000511  aa  7 00102 2361 00	ldq  	pr7|66		i
000512  aa   000001 1160 07	cmpq 	1,dl
000513  aa   000132 6054 04	tpnz 	90,ic		000645
						STATEMENT 1 ON LINE 179
	     if (i = 0 & aste.tqsw (i) & ^aste.master_dir) |
		(i = 1 & aste.tqsw (i)) then
		do;

000514  aa  7 01422 3715 20	epp5 	pr7|786,*		astep
000515  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000516  aa  5 00005 46 0001	descb	pr5|5(24),1	aste.tqsw
000517  aa  6 00423 00 0044	descb	pr6|275,36	aste.tqsw
000520  aa  6 00423 2351 00	lda  	pr6|275		aste.tqsw
000521  aa   000006 6000 04	tze  	6,ic		000527
000522  aa  7 00102 2361 00	ldq  	pr7|66		i
000523  aa   000004 6010 04	tnz  	4,ic		000527
000524  aa  5 00005 2351 00	lda  	pr5|5		aste.master_dir
000525  aa   020000 3150 07	cana 	8192,dl
000526  aa   000005 6000 04	tze  	5,ic		000533
000527  aa  6 00423 2351 00	lda  	pr6|275		aste.tqsw
000530  aa   000112 6000 04	tze  	74,ic		000642
000531  aa   000001 1160 07	cmpq 	1,dl
000532  aa   000110 6010 04	tnz  	72,ic		000642
						STATEMENT 1 ON LINE 182
		qsw = "1"b;

000533  aa   400000 2350 03	lda  	131072,du
000534  aa  6 00100 7551 00	sta  	pr6|64		qsw
						STATEMENT 1 ON LINE 183
		call quotaw$mq (ptr (astep, astep -> aste.par_astep), astep, -aste.quota (i),
		     bit (fixed (i, 1), 1), code);

000535  aa  5 00002 2351 00	lda  	pr5|2		aste.par_astep
000536  aa   000022 7350 00	als  	18
000537  aa  5 00000 3521 00	epp2 	pr5|0
000540  aa   000000 3120 01	eawp2	0,au
000541  aa  6 00434 2521 00	spri2	pr6|284
000542  aa   000022 4020 07	mpy  	18,dl
000543  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000544  aa  5 00010 00 0022	descb	pr5|8,18		aste.quota
000545  aa  6 00056 00 0044	descb	pr6|46,36
000546  aa  6 00056 2351 00	lda  	pr6|46
000547  aa   000066 7730 00	lrl  	54
000550  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
000551  aa   000001 0760 07	adq  	1,dl
000552  aa  6 00423 7561 00	stq  	pr6|275
000553  aa  7 00102 2351 00	lda  	pr7|66		i
000554  aa   000002 6050 04	tpl  	2,ic		000556
000555  aa   000000 5310 00	neg  	0
000556  aa   000043 7350 00	als  	35
000557  aa  6 00436 7551 00	sta  	pr6|286
000560  aa  6 00434 3521 00	epp2 	pr6|284
000561  aa  6 00442 2521 00	spri2	pr6|290
000562  aa  7 01422 3521 00	epp2 	pr7|786		astep
000563  aa  6 00444 2521 00	spri2	pr6|292
000564  aa  6 00423 3521 00	epp2 	pr6|275
000565  aa  6 00446 2521 00	spri2	pr6|294
000566  aa  6 00436 3521 00	epp2 	pr6|286
000567  aa  6 00450 2521 00	spri2	pr6|296
000570  aa  7 00032 3535 20	epp3 	pr7|26,*
000571  aa  3 00004 3521 20	epp2 	pr3|4,*		code
000572  aa  6 00452 2521 00	spri2	pr6|298
000573  aa  6 00440 6211 00	eax1 	pr6|288
000574  aa   024000 4310 07	fld  	10240,dl
000575  aa  6 00044 3701 20	epp4 	pr6|36,*
000576  la  4 00024 3521 20	epp2 	pr4|20,*		quotaw$mq
000577  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 185
		if code ^= 0 then call syserr$error_code (4, code,
			"delete_vtoce: from quotaw, pvid ^w, vtocx ^o", pvid, vtocx);

000600  aa  6 00040 3735 20	epp7 	pr6|32,*
000601  aa  7 00032 3715 20	epp5 	pr7|26,*
000602  aa  5 00004 2361 20	ldq  	pr5|4,*		code
000603  aa   000037 6000 04	tze  	31,ic		000642
000604  aa   000004 2360 07	ldq  	4,dl
000605  aa  6 00436 7561 00	stq  	pr6|286
000606  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000607  aa   777214 00 0054	desc9a	-372,44		000022 = 144145154145
000610  aa  6 00440 00 0054	desc9a	pr6|288,44
000611  aa  6 00436 3521 00	epp2 	pr6|286
000612  aa  6 00456 2521 00	spri2	pr6|302
000613  aa  5 00004 3521 20	epp2 	pr5|4,*		code
000614  aa  6 00460 2521 00	spri2	pr6|304
000615  aa  6 00440 3521 00	epp2 	pr6|288
000616  aa  6 00462 2521 00	spri2	pr6|306
000617  aa  7 00101 3521 00	epp2 	pr7|65		pvid
000620  aa  6 00464 2521 00	spri2	pr6|308
000621  aa  7 00104 3521 00	epp2 	pr7|68		vtocx
000622  aa  6 00466 2521 00	spri2	pr6|310
000623  aa   777160 3520 04	epp2 	-400,ic		000003 = 404000000005
000624  aa  6 00470 2521 00	spri2	pr6|312
000625  aa   777161 3520 04	epp2 	-399,ic		000006 = 404000000043
000626  aa  6 00472 2521 00	spri2	pr6|314
000627  aa   777153 3520 04	epp2 	-405,ic		000002 = 524000000054
000630  aa  6 00474 2521 00	spri2	pr6|316
000631  aa   777150 3520 04	epp2 	-408,ic		000001 = 514000000044
000632  aa  6 00476 2521 00	spri2	pr6|318
000633  aa   777152 3520 04	epp2 	-406,ic		000005 = 404000000021
000634  aa  6 00500 2521 00	spri2	pr6|320
000635  aa  6 00454 6211 00	eax1 	pr6|300
000636  aa   024000 4310 07	fld  	10240,dl
000637  aa  6 00044 3701 20	epp4 	pr6|36,*
000640  la  4 00052 3521 20	epp2 	pr4|42,*		syserr$error_code
000641  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 187
	     end;

						STATEMENT 1 ON LINE 188
	end;

000642  aa  6 00040 3735 20	epp7 	pr6|32,*
000643  aa  7 00102 0541 00	aos  	pr7|66		i
000644  aa   777644 7100 04	tra  	-92,ic		000510
						STATEMENT 1 ON LINE 190
	call lock$unlock_ast;

000645  aa  6 00056 6211 00	eax1 	pr6|46
000646  aa   000000 4310 07	fld  	0,dl
000647  aa  6 00044 3701 20	epp4 	pr6|36,*
000650  la  4 00016 3521 20	epp2 	pr4|14,*		lock$unlock_ast
000651  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 192
	if ^qsw then return;

000652  aa  6 00100 2351 00	lda  	pr6|64		qsw
000653  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 196
	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "100"b, addr (local_vtoce), code);

000654  aa   400000 2350 03	lda  	131072,du
000655  aa  6 00436 7551 00	sta  	pr6|286
000656  aa  6 00122 3735 00	epp7 	pr6|82		local_vtoce
000657  aa  6 00434 6535 00	spri7	pr6|284
000660  aa  6 00040 3715 20	epp5 	pr6|32,*
000661  aa  5 00101 3521 00	epp2 	pr5|65		pvid
000662  aa  6 00456 2521 00	spri2	pr6|302
000663  aa  5 00103 3521 00	epp2 	pr5|67		pvtx
000664  aa  6 00460 2521 00	spri2	pr6|304
000665  aa  5 00104 3521 00	epp2 	pr5|68		vtocx
000666  aa  6 00462 2521 00	spri2	pr6|306
000667  aa  6 00436 3521 00	epp2 	pr6|286
000670  aa  6 00464 2521 00	spri2	pr6|308
000671  aa  6 00434 3521 00	epp2 	pr6|284
000672  aa  6 00466 2521 00	spri2	pr6|310
000673  aa  5 00032 3535 20	epp3 	pr5|26,*
000674  aa  3 00004 3521 20	epp2 	pr3|4,*		code
000675  aa  6 00470 2521 00	spri2	pr6|312
000676  aa  6 00454 6211 00	eax1 	pr6|300
000677  aa   030000 4310 07	fld  	12288,dl
000700  aa  6 00044 3701 20	epp4 	pr6|36,*
000701  la  4 00064 3521 20	epp2 	pr4|52,*		vtoc_man$get_vtoce
000702  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 197
	if code ^= 0 then return;

000703  aa  6 00040 3735 20	epp7 	pr6|32,*
000704  aa  7 00032 3715 20	epp5 	pr7|26,*
000705  aa  5 00004 2361 20	ldq  	pr5|4,*		code
000706  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 199
	local_tpp = local_vtoce.trp;

000707  aa   000001 2360 07	ldq  	1,dl
000710  aa  6 00422 7561 00	stq  	pr6|274
000711  aa   000000 0110 03	nop  	0,du
000712  aa  6 00422 2361 00	ldq  	pr6|274
000713  aa   000001 7360 00	qls  	1
000714  aa   000000 6270 06	eax7 	0,ql
000715  aa  6 00132 2351 06	lda  	pr6|90,ql		local_vtoce.trp
000716  aa  6 00133 2361 06	ldq  	pr6|91,ql		local_vtoce.trp
000717  aa   000000 7330 00	lrs  	0
000720  aa  6 00100 7571 17	staq 	pr6|64,7		local_tpp
000721  aa  6 00422 2361 00	ldq  	pr6|274
000722  aa  6 00422 0541 00	aos  	pr6|274
000723  aa   000002 1160 07	cmpq 	2,dl
000724  aa   777766 6040 04	tmi  	-10,ic		000712
						STATEMENT 1 ON LINE 200
	if local_tpp (0) = 0 & local_tpp (1) = 0 then return;

000725  aa  6 00102 2371 00	ldaq 	pr6|66		local_tpp
000726  aa   000003 6010 04	tnz  	3,ic		000731
000727  aa  6 00104 2371 00	ldaq 	pr6|68		local_tpp
000730  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 203
	dp = ptr (ep, 0);

000731  aa  6 00040 3735 20	epp7 	pr6|32,*
000732  aa  7 01426 3525 20	epbp2	pr7|790,*		ep
000733  aa  7 01424 2521 00	spri2	pr7|788		dp
						STATEMENT 1 ON LINE 204
	call sum$getbranch_root_my (dp, READ_LOCK, pep, sumcode);

000734  aa  7 01424 3521 00	epp2 	pr7|788		dp
000735  aa  6 00442 2521 00	spri2	pr6|290
000736  aa   777046 3520 04	epp2 	-474,ic		000004 = 000000000000
000737  aa  6 00444 2521 00	spri2	pr6|292
000740  aa  6 00116 3521 00	epp2 	pr6|78		pep
000741  aa  6 00446 2521 00	spri2	pr6|294
000742  aa  6 00121 3521 00	epp2 	pr6|81		sumcode
000743  aa  6 00450 2521 00	spri2	pr6|296
000744  aa  6 00440 6211 00	eax1 	pr6|288
000745  aa   020000 4310 07	fld  	8192,dl
000746  aa  6 00044 3701 20	epp4 	pr6|36,*
000747  la  4 00060 3521 20	epp2 	pr4|48,*		sum$getbranch_root_my
000750  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 207
	if sumcode = 0 | sumcode = error_table_$root | sumcode = error_table_$mylock then do;

000751  aa  6 00121 2361 00	ldq  	pr6|81		sumcode
000752  aa   000006 6000 04	tze  	6,ic		000760
000753  aa  6 00044 3701 20	epp4 	pr6|36,*
000754  la  4 00056 1161 20	cmpq 	pr4|46,*		error_table_$root
000755  aa   000003 6000 04	tze  	3,ic		000760
000756  la  4 00054 1161 20	cmpq 	pr4|44,*		error_table_$mylock
000757  aa   000011 6010 04	tnz  	9,ic		000770
						STATEMENT 1 ON LINE 208
	     par_pvid = dir.pvid;

000760  aa  6 00040 3735 20	epp7 	pr6|32,*
000761  aa  7 01424 3715 20	epp5 	pr7|788,*		dp
000762  aa  5 00011 2351 00	lda  	pr5|9		dir.pvid
000763  aa  6 00114 7551 00	sta  	pr6|76		par_pvid
						STATEMENT 1 ON LINE 209
	     par_vtocx = dir.vtocx;

000764  aa  5 00015 2351 00	lda  	pr5|13		dir.vtocx
000765  aa   000066 7330 00	lrs  	54
000766  aa  6 00120 7561 00	stq  	pr6|80		par_vtocx
						STATEMENT 1 ON LINE 210
	end;

000767  aa   000005 7100 04	tra  	5,ic		000774
						STATEMENT 1 ON LINE 211
	else do;

						STATEMENT 1 ON LINE 212
	     code = sumcode;

000770  aa  6 00040 3735 20	epp7 	pr6|32,*
000771  aa  7 00032 3715 20	epp5 	pr7|26,*
000772  aa  5 00004 7561 20	stq  	pr5|4,*		code
						STATEMENT 1 ON LINE 213
	     go to tploss;

000773  aa   000155 7100 04	tra  	109,ic		001150
						STATEMENT 1 ON LINE 214
	end;

						STATEMENT 1 ON LINE 216
	call lock$lock_ast;

000774  aa  6 00056 6211 00	eax1 	pr6|46
000775  aa   000000 4310 07	fld  	0,dl
000776  aa  6 00044 3701 20	epp4 	pr6|36,*
000777  la  4 00014 3521 20	epp2 	pr4|12,*		lock$lock_ast
001000  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 218
	par_pvtx = get_pvtx ((par_pvid), code);

001001  aa  6 00114 2351 00	lda  	pr6|76		par_pvid
001002  aa  6 00436 7551 00	sta  	pr6|286
001003  aa  6 00436 3521 00	epp2 	pr6|286
001004  aa  6 00426 2521 00	spri2	pr6|278
001005  aa  6 00040 3735 20	epp7 	pr6|32,*
001006  aa  7 00032 3715 20	epp5 	pr7|26,*
001007  aa  5 00004 3521 20	epp2 	pr5|4,*		code
001010  aa  6 00430 2521 00	spri2	pr6|280
001011  aa  6 00115 3521 00	epp2 	pr6|77		par_pvtx
001012  aa  6 00432 2521 00	spri2	pr6|282
001013  aa  6 00424 6211 00	eax1 	pr6|276
001014  aa   014000 4310 07	fld  	6144,dl
001015  aa  6 00044 3701 20	epp4 	pr6|36,*
001016  la  4 00032 3521 20	epp2 	pr4|26,*		get_pvtx
001017  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 219
	if code ^= 0 then go to tpploss1;

001020  aa  6 00040 3735 20	epp7 	pr6|32,*
001021  aa  7 00032 3715 20	epp5 	pr7|26,*
001022  aa  5 00004 2361 20	ldq  	pr5|4,*		code
001023  aa   000120 6010 04	tnz  	80,ic		001143
						STATEMENT 1 ON LINE 221
	call vtoc_man$get_vtoce (par_pvid, par_pvtx, par_vtocx, "100"b, addr (local_vtoce), code);

001024  aa   400000 2350 03	lda  	131072,du
001025  aa  6 00436 7551 00	sta  	pr6|286
001026  aa  6 00122 3535 00	epp3 	pr6|82		local_vtoce
001027  aa  6 00434 2535 00	spri3	pr6|284
001030  aa  6 00114 3521 00	epp2 	pr6|76		par_pvid
001031  aa  6 00456 2521 00	spri2	pr6|302
001032  aa  6 00115 3521 00	epp2 	pr6|77		par_pvtx
001033  aa  6 00460 2521 00	spri2	pr6|304
001034  aa  6 00120 3521 00	epp2 	pr6|80		par_vtocx
001035  aa  6 00462 2521 00	spri2	pr6|306
001036  aa  6 00436 3521 00	epp2 	pr6|286
001037  aa  6 00464 2521 00	spri2	pr6|308
001040  aa  6 00434 3521 00	epp2 	pr6|284
001041  aa  6 00466 2521 00	spri2	pr6|310
001042  aa  5 00004 3521 20	epp2 	pr5|4,*		code
001043  aa  6 00470 2521 00	spri2	pr6|312
001044  aa  6 00454 6211 00	eax1 	pr6|300
001045  aa   030000 4310 07	fld  	12288,dl
001046  aa  6 00044 3701 20	epp4 	pr6|36,*
001047  la  4 00064 3521 20	epp2 	pr4|52,*		vtoc_man$get_vtoce
001050  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 222
	if code ^= 0 then go to tpploss1;

001051  aa  6 00040 3735 20	epp7 	pr6|32,*
001052  aa  7 00032 3715 20	epp5 	pr7|26,*
001053  aa  5 00004 2361 20	ldq  	pr5|4,*		code
001054  aa   000067 6010 04	tnz  	55,ic		001143
						STATEMENT 1 ON LINE 224
	on fixedoverflow go to tpploss1;

001055  aa   000015 7260 07	lxl6 	13,dl
001056  aa   776740 3520 04	epp2 	-544,ic		000016 = 146151170145
001057  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001060  aa   000004 7100 04	tra  	4,ic		001064
001061  aa     000106000000
001062  aa   000012 7100 04	tra  	10,ic		001074
BEGIN CONDITION fixedoverflow.1
ENTRY TO fixedoverflow.1                                    STATEMENT 1 ON LINE 224
	on fixedoverflow go to tpploss1;

001063  da     000324200000
001064  aa   000100 6270 00	eax7 	64
001065  aa  7 00034 3521 20	epp2 	pr7|28,*
001066  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001067  aa     000000000000
001070  aa     000000000000
001071  aa   000052 3520 04	epp2 	42,ic		001143 = 600056621100
001072  aa   000001 7270 07	lxl7 	1,dl
001073  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
  END CONDITION fixedoverflow.1
						STATEMENT 1 ON LINE 225
	local_vtoce.trp = local_vtoce.trp + local_tpp;

001074  aa   000001 2360 07	ldq  	1,dl
001075  aa  6 00422 7561 00	stq  	pr6|274
001076  aa  6 00422 2361 00	ldq  	pr6|274
001077  aa   000001 7360 00	qls  	1
001100  aa   000000 6270 06	eax7 	0,ql
001101  aa  6 00132 2351 06	lda  	pr6|90,ql		local_vtoce.trp
001102  aa  6 00133 2361 06	ldq  	pr6|91,ql		local_vtoce.trp
001103  aa   000000 7330 00	lrs  	0
001104  aa  6 00100 0771 17	adaq 	pr6|64,7		local_tpp
001105  aa  6 00132 7551 17	sta  	pr6|90,7		local_vtoce.trp
001106  aa  6 00133 7561 17	stq  	pr6|91,7		local_vtoce.trp
001107  aa  6 00422 2361 00	ldq  	pr6|274
001110  aa  6 00422 0541 00	aos  	pr6|274
001111  aa   000002 1160 07	cmpq 	2,dl
001112  aa   777764 6040 04	tmi  	-12,ic		001076
						STATEMENT 1 ON LINE 226
	revert fixedoverflow;

001113  aa  6 00112 4501 00	stz  	pr6|74
						STATEMENT 1 ON LINE 228
	call vtoc_man$put_vtoce (par_pvid, par_pvtx, par_vtocx, "100"b, addr (local_vtoce), code);

001114  aa   400000 2350 03	lda  	131072,du
001115  aa  6 00436 7551 00	sta  	pr6|286
001116  aa  6 00122 3735 00	epp7 	pr6|82		local_vtoce
001117  aa  6 00434 6535 00	spri7	pr6|284
001120  aa  6 00114 3521 00	epp2 	pr6|76		par_pvid
001121  aa  6 00456 2521 00	spri2	pr6|302
001122  aa  6 00115 3521 00	epp2 	pr6|77		par_pvtx
001123  aa  6 00460 2521 00	spri2	pr6|304
001124  aa  6 00120 3521 00	epp2 	pr6|80		par_vtocx
001125  aa  6 00462 2521 00	spri2	pr6|306
001126  aa  6 00436 3521 00	epp2 	pr6|286
001127  aa  6 00464 2521 00	spri2	pr6|308
001130  aa  6 00434 3521 00	epp2 	pr6|284
001131  aa  6 00466 2521 00	spri2	pr6|310
001132  aa  6 00040 3715 20	epp5 	pr6|32,*
001133  aa  5 00032 3535 20	epp3 	pr5|26,*
001134  aa  3 00004 3521 20	epp2 	pr3|4,*		code
001135  aa  6 00470 2521 00	spri2	pr6|312
001136  aa  6 00454 6211 00	eax1 	pr6|300
001137  aa   030000 4310 07	fld  	12288,dl
001140  aa  6 00044 3701 20	epp4 	pr6|36,*
001141  la  4 00066 3521 20	epp2 	pr4|54,*		vtoc_man$put_vtoce
001142  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 229
tpploss1:
	call lock$unlock_ast;

001143  aa  6 00056 6211 00	eax1 	pr6|46
001144  aa   000000 4310 07	fld  	0,dl
001145  aa  6 00044 3701 20	epp4 	pr6|36,*
001146  la  4 00016 3521 20	epp2 	pr4|14,*		lock$unlock_ast
001147  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 231
tploss:
	if sumcode = 0 then call lock$dir_unlock (ptr (pep, 0));

001150  aa  6 00121 2361 00	ldq  	pr6|81		sumcode
001151  aa   000012 6010 04	tnz  	10,ic		001163
001152  aa  6 00116 3525 20	epbp2	pr6|78,*		pep
001153  aa  6 00434 2521 00	spri2	pr6|284
001154  aa  6 00434 3521 00	epp2 	pr6|284
001155  aa  6 00426 2521 00	spri2	pr6|278
001156  aa  6 00424 6211 00	eax1 	pr6|276
001157  aa   004000 4310 07	fld  	2048,dl
001160  aa  6 00044 3701 20	epp4 	pr6|36,*
001161  la  4 00062 3521 20	epp2 	pr4|50,*		lock$dir_unlock
001162  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 234
	if code ^= 0 then call syserr$error_code (4, code,
		"delete_vtoce: cannot add time/page product (^d ^d) to pvid ^w vtocx ^o uid ^w.",
		local_tpp, par_pvid, par_vtocx, dir.uid);

001163  aa  6 00040 3735 20	epp7 	pr6|32,*
001164  aa  7 00032 3715 20	epp5 	pr7|26,*
001165  aa  5 00004 2361 20	ldq  	pr5|4,*		code
001166  aa   000047 6000 04	tze  	39,ic		001235
001167  aa   000004 2360 07	ldq  	4,dl
001170  aa  6 00436 7561 00	stq  	pr6|286
001171  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001172  aa   776644 00 0120	desc9a	-604,80		000035 = 144145154145
001173  aa  6 00454 00 0120	desc9a	pr6|300,80
001174  aa  6 00436 3521 00	epp2 	pr6|286
001175  aa  6 00504 2521 00	spri2	pr6|324
001176  aa  5 00004 3521 20	epp2 	pr5|4,*		code
001177  aa  6 00506 2521 00	spri2	pr6|326
001200  aa  6 00454 3521 00	epp2 	pr6|300
001201  aa  6 00510 2521 00	spri2	pr6|328
001202  aa  6 00102 3521 00	epp2 	pr6|66		local_tpp
001203  aa  6 00512 2521 00	spri2	pr6|330
001204  aa  6 00114 3521 00	epp2 	pr6|76		par_pvid
001205  aa  6 00514 2521 00	spri2	pr6|332
001206  aa  6 00120 3521 00	epp2 	pr6|80		par_vtocx
001207  aa  6 00516 2521 00	spri2	pr6|334
001210  aa  7 01424 3535 20	epp3 	pr7|788,*		dp
001211  aa  3 00010 3521 00	epp2 	pr3|8		dir.uid
001212  aa  6 00520 2521 00	spri2	pr6|336
001213  aa   776570 3520 04	epp2 	-648,ic		000003 = 404000000005
001214  aa  6 00522 2521 00	spri2	pr6|338
001215  aa   776571 3520 04	epp2 	-647,ic		000006 = 404000000043
001216  aa  6 00524 2521 00	spri2	pr6|340
001217  aa   776561 3520 04	epp2 	-655,ic		000000 = 524000000116
001220  aa  6 00526 2521 00	spri2	pr6|342
001221  aa   776571 3520 04	epp2 	-647,ic		000012 = 410100000107
001222  aa  6 00530 2521 00	spri2	pr6|344
001223  aa   776556 3520 04	epp2 	-658,ic		000001 = 514000000044
001224  aa  6 00532 2521 00	spri2	pr6|346
001225  aa  6 00536 2521 00	spri2	pr6|350
001226  aa   776557 3520 04	epp2 	-657,ic		000005 = 404000000021
001227  aa  6 00534 2521 00	spri2	pr6|348
001230  aa  6 00502 6211 00	eax1 	pr6|322
001231  aa   034000 4310 07	fld  	14336,dl
001232  aa  6 00044 3701 20	epp4 	pr6|36,*
001233  la  4 00052 3521 20	epp2 	pr4|42,*		syserr$error_code
001234  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 238
	return;

001235  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 240
     end RETURN_QUOTA;

  END PROCEDURE RETURN_QUOTA
  END PROCEDURE delete_vtoce


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
