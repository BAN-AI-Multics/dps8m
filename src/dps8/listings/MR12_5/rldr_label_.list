	COMPILATION LISTING OF SEGMENT rldr_label_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/21/92  1623.8 mdt Wed
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(86-01-15,Fawcett), approve(86-04-11,MCR7383),
       18*     audit(86-06-03,GWMay), install(86-07-17,MR12.0-1097):
       19*     Add support for 512_WORD_IO devices.
       20*  2) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
       21*     install(88-10-17,MR12.2-1173):
       22*     Changed to turn the inconsistent dumper bit map on in the disk label after
       23*     a sucessful reload.
       24*  3) change(92-08-24,Schroth), approve(92-10-15,MCR8265),
       25*     audit(92-10-15,Zimmerman), install(92-10-21,MR12.5-1039):
       26*     To correct the online PVID reported when a PVID mismatch occurs when
       27*     reloading multiple volumes.  Add message documentation for PVID mismatch
       28*     message.  phx21270
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       33 
       34 rldr_label_: proc;
       35 
       36 /* This routine maintains the data base that will be the new label for the volume being reloaded. */
       37 /* Written in antiquity by Dave Vinograd.					        */
       38 /* Modified: 03/83 by GA Texada for multiple physical volume reloading.		        */
       39 
       40 dcl code		     fixed bin (35);
       41 dcl pvindex	     fixed bin;
       42 dcl myname	     char (32) static init ("rldr_label_") options (constant);
       43 
       44 dcl error_table_$bad_volid ext fixed bin (35);
       45 
       46 dcl rldr_report_$error_output entry options (variable);
       47 dcl iox_$position	     entry (ptr, fixed bin, fixed bin, fixed bin (35));
       48 dcl iox_$get_chars	     entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       49 dcl iox_$put_chars	     entry (ptr, ptr, fixed bin, fixed bin (35));
       50 
       51 dcl (size, divide, clock) builtin;
       52 
       53 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       54 
       55 
       56 open: entry (rldr_datap, pvindex, code);
       57 
       58 /* This entry positions to and reads the label from the physical volume.  It also cross checks
       59*   to see if the correct physical volume has been mounted. */
       60 
       61     code = 0;
       62 						/* position to sector */
       63     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (LABEL_ADDR), code);
       64     if code ^= 0 then do;
       65         call rldr_report_$error_output (rldr_datap, code, myname, "Label position failed for pv ^a",
       66 	   rldr_data_.pvname (pvindex));
       67         return;
       68       end;
       69 						/* read label into temp seg */
       70     call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.labelp (pvindex), size (label) * 4, (0), code);
       71     if code ^= 0 then do;
       72         call rldr_report_$error_output (rldr_datap, code, myname, "Label read failed for pv ^a",
       73 	   rldr_data_.pvname (pvindex));
       74         return;
       75       end;
       76 						/* cross check label info against registration info */
       77     labelp = rldr_data_.labelp (pvindex);
       78     if ^(rldr_data_.pvname (pvindex) = "rpv") then
       79       if label.pvid ^= rldr_data_.pvid (pvindex) then do;
       80 	code = error_table_$bad_volid;
       81 	call rldr_report_$error_output (rldr_datap, code, myname,
       82 	     "Output volume pvid ^o not equal to online pvid ^o for pv ^a",
       83 	     label.pvid, rldr_data_.pvid (pvindex), rldr_data_.pvname (pvindex));
       84         end;
       85     return;
       86 
       87 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       88 
       89 
       90 close: entry (rldr_datap, pvindex, code);
       91 
       92 /* This entry updates the physical volume label with the results of the reload. */
       93 
       94     code = 0;
       95     labelp = rldr_data_.labelp (pvindex);
       96 						/* special case rpv */
       97     if (rldr_data_.rpv & rldr_data_.pvname (pvindex) = "rpv") then do;
       98         label.pv_name = "rpv";
       99         label.lv_name = "root";
      100         infop = rldr_data_.infop;
      101         label.pvid = backup_info.rpv_pvid;
      102         label.lvid = backup_info.rpv_lvid;
      103         label.root.here = "1"b;
      104         label.root.shutdown_state = 4;
      105       end;
      106 						/* set time */
      107     label.time_last_reloaded = clock;
      108 
      109 /* The dumper bit map has not been reloaded. Set the inconsistent flag so    */
      110 /* that the dumper will use seg dtms and automatically build a valid map.    */
      111 
      112     label.inconsistent_dbm = "1"b;
      113 						/* position to sector */
      114     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (LABEL_ADDR), code);
      115     if code ^= 0 then do;
      116         call rldr_report_$error_output (rldr_datap, code, myname, "Label position failed for pv ^a",
      117 	   rldr_data_.pvname (pvindex));
      118         return;
      119       end;
      120 						/* write label to physical volume */
      121     call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), labelp, size (label) * 4, code);
      122     if code ^= 0 then
      123       call rldr_report_$error_output (rldr_datap, code, myname, "Label write failed on pv ^a",
      124 	 rldr_data_.pvname (pvindex));
      125     return;
      126 
      127 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      128 
      129 
      130 sector: proc (add) returns (fixed bin);
      131 
      132 /* This proc converts Multics record numbers to  sector numbers */
      133 
      134 dcl add		     fixed bin;
      135 dcl (dev_idx, sector)    fixed bin;
      136 
      137     dev_idx = rldr_data_.disk_type (pvindex);
      138     sector = add * SECTORS_PER_RECORD (dev_idx);
      139     sector = sector + divide (sector, rldr_data_.usable_sectors (pvindex), 17, 0) * rldr_data_.unusable_sectors (pvindex);
      140     return (sector * words_per_sect (dev_idx) * 4);
      141 
      142   end sector;
      143 
  1     1 /* BEGIN INCLUDE FILE ... rldr_data_.incl.pl1 ... March 1976 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  1     6*     audit(86-05-22,GWMay), install(86-07-18,MR12.0-1098):
  1     7*     Add device_name to support the -pvname_device argument to reload.
  1     8*  2) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  1     9*     install(88-10-17,MR12.2-1173):
  1    10*     Added pointer and length values for use as an input_buffer for
  1    11*     intermediate reads.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 /* Severely modified 3/1/83 by GA Texada to support multiple physical */
  1    16 /*          volume reloading.				          */
  1    17 /*          Modified: 3/5/84 by GA Texada to make restart a per pv attribute */
  1    18 /*		  and add stranger flag.			*/
  1    19 
  1    20 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
  1    21 
  1    22 
  1    23 dcl rldr_datap	     ptr,
  1    24   rldr_data_max_pvs	     fixed bin,
  1    25 
  1    26   1 rldr_data_	     aligned based (rldr_datap),
  1    27     2 common	     like rldr_data_common,		/* only one of each needed			*/
  1    28     2 per_pv	     (rldr_data_max_pvs refer (rldr_data_.npvs)) like rldr_data_perpv,
  1    29 
  1    30   1 rldr_data_common     aligned,
  1    31     2 bits,
  1    32     ( 3 save	     bit (1),			/* if on can use disk pack restored by BOS */
  1    33       3 first_volume     bit (1),			/* if on indicates we are on first volume */
  1    34       3 rpv	     bit (1),			/* if on indicates we are reloading rpv */
  1    35       3 data_init	     bit (1),			/* if on data structure initialized to null state */
  1    36       3 arg_init	     bit (1),			/* on if arguments have been processed */
  1    37       3 disable_error_report bit (1),			/* if on will disable error messages */
  1    38       3 no_object	     bit (1),			/* if on only vtoces will be reloaded */
  1    39       3 err_online	     bit (1),			/* if on error messages written to error output */
  1    40       3 detach	     bit (1),			/* if on attached media will  be detached */
  1    41       3 brief	     bit (1),			/* if on brief mode enabled */
  1    42       3 manual	     bit (1),			/* if on operator will select input volumes */
  1    43       3 restart	     bit (1),			/* -restart was supplied			*/
  1    44       3 stranger	     bit (1),			/* ON if the pv's do not belong to the mounted RPV*/
  1    45       3 pad0	     bit (23)) unal,
  1    46       3 old_256K_switch  bit (2) aligned,		/* state of 256KW connection switch before we came along*/
  1    47       (3 last_pvid,					/* pvid of last good object read		*/
  1    48       3 rpv_pvid,					/* rpv pvid */
  1    49       3 rpv_lvid)	     bit (36),			/* rpv lvid */
  1    50       3 last_valid_puid  (0:15) bit (36),		/* last non-zero path uid read from input medium */
  1    51     2 chars,
  1    52     ( 3 sys_dir,					/* directory where vologs are */
  1    53       3 default_sys_dir) char (168),			/* default directory where vologs are */
  1    54       (3 last_valid_vtoce_ename,			/* last valid entry name from VTOCE */
  1    55       3 operator,					/* operator's name or initials */
  1    56       3 io_module)	     char (32),			/* name of io outer module used to read input */
  1    57       (3 input_volume_desc,				/* optional input medium attach description */
  1    58       3 output_volume_desc) char (256),			/* optional output medium attach description */
  1    59     2 fixed,
  1    60     ( 3 num_abandoned,				/* count these as we go along			*/
  1    61       3 last_vtocx,					/* vtocx of last valid object read		*/
  1    62       3 npvs,					/* the number of pv names given to the reload_volume command*/
  1    63       3 rpv_disk_type)   fixed bin,			/* model index of rpv disk drive */
  1    64       (3 start_time,				/* time reload started */
  1    65       3 from_time)	     fixed bin (71),		/*  time from which dump tapes should be skipped */
  1    66       3 input_buffer_len fixed bin (21),		/* length of the data in the read buffer */
  1    67       3 input_buffer_start fixed bin (21),		/* position in read buffer where new data begins */
  1    68     2 ptrs,
  1    69     ( 3 inputvol_iocbp,				/* iocb ptr for input */
  1    70       3 error_iocbp,				/* iocb ptr for error output */
  1    71       3 skip,					/* ptr to skip list */
  1    72       3 volume_record_bp,				/* ptr to temp seg containing most recent volume record */
  1    73       3 infop,					/* ptr to temp seg containig tdump info */
  1    74       3 data_object_bp,				/* ptr to temp seg containing most recent object from input medium */
  1    75       3 input_vol_lstp  ptr,				/* ptr to temp seg containing list of input media */
  1    76       3 input_buffer_ptr)  ptr,			/* ptr to read buffer */
  1    77  
  1    78 
  1    79   1 rldr_data_perpv	     aligned,			/* one entry per physical volume to be reloaded	*/
  1    80     2 flags,
  1    81       3 abandoned	     bit (1) unal,			/* we quit due to some error			*/
  1    82       3 restart	     bit (1),			/* if on unitialized volume ok and reload will restart */
  1    83       3 mbz0	     bit (34) unal,			/* beware, RFU				*/
  1    84     (2 pvname,					/* physical volume name */
  1    85     2 lvname,					/* logical volume name of physical volume being reloaded */
  1    86     2 disk_model)	     char (32),			/* model name of disk drive */
  1    87     2 device_name	     char (8),
  1    88     (2 lvid,					/* logical volume id of volume being reloaded */
  1    89     2 pvid)	     bit (36),			/* physical volume id of volume being reloaded */
  1    90     (2 prev_wordx,					/* index to fsmap */
  1    91     2 prev_bitx,					/* index to fsmap */
  1    92     2 disk_type,					/* model index of disk drive */
  1    93     2 usable_sectors,				/* usable sectors per cylinder of disk pack */
  1    94     2 unusable_sectors,				/* unusable sectors per cylinder of disk pack */
  1    95     2 n_vtoce)	     fixed bin,			/* number of vtoce on disk pack */
  1    96     (2 vtocbp,					/* ptr to vtoc buffer seg */
  1    97     2 vtoc_headerp,					/* ptr to temp seg containing the vtoc header */
  1    98     2 labelp,					/* ptr to temp seg containing pack label */
  1    99     2 bvlp,					/* ptr to volume log */
  1   100     2 outputvol_iocbp,				/* iocb ptr for output */
  1   101     2 controlp,					/* ptr to seg containing reload control info about vtoc */
  1   102     2 vol_mapp)	     ptr,				/* ptr to temp seg containing volume map */
  1   103 
  1   104   1 rldr_data_nulled_pv  aligned int static options (constant),
  1   105     2 flags,
  1   106       3 abandoned	     bit (1) init ("0"b) unal,
  1   107       3 restart	     bit (1) init ("0"b) unal,
  1   108       3 mbz0	     bit (34) init ((34)"0"b) unal,
  1   109       (2 pvname,
  1   110     2 lvname,
  1   111     2 disk_model)	     char (32) init (""),
  1   112     2 device_name	     char (8) init (""),
  1   113     (2 lvid,
  1   114     2 pvid)	     bit (36) init ("0"b),
  1   115     (2 prev_wordx,
  1   116     2 prev_bitx,
  1   117     2 disk_type,
  1   118     2 usable_sectors,
  1   119     2 unusable_sectors,
  1   120     2 n_vtoce)	     fixed bin init (0),
  1   121     (2 vtocbp,
  1   122     2 vtoc_headerp,
  1   123     2 labelp,
  1   124     2 bvlp,
  1   125     2 outputvol_iocbp,
  1   126     2 controlp,
  1   127     2 vol_mapp)	     ptr init (null ());
  1   128 
  1   129 
  1   130 /* END INCLUDE FILE rldr_data_.incl.pl1 */
      144 
      145 
  2     1 /* BEGIN INCLUDE FILE ... backup_info.incl.pl1 ... June 1976 */
  2     2 
  2     3 dcl  infop ptr;					/* ptr to structure */
  2     4 
  2     5 dcl  backup_info_version_2 fixed bin static init (2) options (constant); /* version number */
  2     6 
  2     7 dcl 1 backup_info based (infop) aligned,
  2     8     2 header like backup_volume_header aligned,
  2     9     2 version fixed bin,				/* version number */
  2    10     2 rpv_pvid bit (36),				/* pvid of rpv */
  2    11     2 rpv_lvid bit (36),				/* lvid of rpv */
  2    12     2 rpv_disk_type fixed bin,			/* disk model index of rpv */
  2    13     2 dump_volid bit (36),				/* dump volume id */
  2    14     2 pad bit (36),
  2    15     2 dump_type fixed bin,				/* type of dump */
  2    16     2 dump_volname char (32),				/* volname of dump volume */
  2    17     2 system_id char (32),				/* system identifier */
  2    18     2 control_file char (168),			/* path name of dump control file */
  2    19     2 operator char (32);				/* operator who started dump */
  2    20 
  2    21 /* END INCLUDE FILE ... backup_info.incl.pl1 */
      146 
  3     1 /* BEGIN INCLUDE FILE ... backup_volume_header ... Feb 1976 */
  3     2 
  3     3 dcl  hdp ptr;					/* ptr to header */
  3     4 
  3     5 dcl 1 backup_volume_header based (hdp) aligned,
  3     6     2 pattern1 bit (36),				/* unique  word 1 */
  3     7     2 rec1_type fixed bin,				/* record 1 type */
  3     8     2 rec1_len fixed bin,				/* length in chars */
  3     9     2 pattern2 bit (36),				/* unique word 2 */
  3    10     2 rec2_type fixed bin,				/* record 2 type */
  3    11     2 rec2_len fixed bin,				/* length in chars */
  3    12     2 pattern3 bit (36),				/* unique word 3 */
  3    13     2 time_dumped bit (36);				/* dump time of this record */
  3    14 
  3    15 dcl  vtoce_type fixed bin static init (1) options (constant); /* type code for vtoce */
  3    16 dcl  dir_type fixed bin static init (2) options (constant); /* type code for directory */
  3    17 dcl  seg_type fixed bin static init (3) options (constant); /* type code for segment */
  3    18 dcl  null_type fixed bin static init (4) options (constant); /* type code for null record */
  3    19 dcl  volume_log_type fixed bin static init (5) options (constant); /* type code for volume log */
  3    20 dcl  prev_output_log_type fixed bin static init (6) options (constant); /* type code for prev output log */
  3    21 dcl  contents_type fixed bin static init (7) options (constant); /* type code for contents segment of previous volume */
  3    22 dcl  info_type fixed bin static init (8) options (constant); /* type code for info structure */
  3    23 
  3    24 dcl  pattern1 bit (36) int static init ("110111000011001100011101101010100101"b) options (constant);
  3    25 dcl  pattern2 bit (36) int static init ("101001010101101110001100110000111011"b) options (constant);
  3    26 dcl  pattern3 bit (36) int static init ("001000111100110011100010010101011010"b) options (constant);
  3    27 
  3    28 /* END INCLUDE FILE ... backup_volume_header */
      147 
      148 
  4     1 /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  4     2 
  4     3 
  4     4 
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  4     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  4     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  4    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  4    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  4    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  4    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  4    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  4    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  4    16*                                                   END HISTORY COMMENTS */
  4    17 
  4    18 
  4    19 /*
  4    20*   All disk packs have the standard layout described below:
  4    21*
  4    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  4    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  4    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  4    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  4    26*   Record  7		: formerly contained bad track list; no longer used.
  4    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  4    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  4    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  4    30*
  4    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  4    32*   of the particular partition.
  4    33*
  4    34*
  4    35*
  4    36*   A conceptual declaration for a disk pack could be:
  4    37*
  4    38*   dcl 1 disk_pack,
  4    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  4    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  4    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  4    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  4    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  4    44*   2 vtoc_array_records	(8 : n-1),
  4    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  4    46*   3 unused				bit(36 * 64),
  4    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  4    48*
  4    49*
  4    50*
  4    51*
  4    52**/
  4    53 
  4    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  4    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  4    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  4    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  4    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  4    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  4    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  4    61 		         fixed bin (17) int static options (constant);
  4    62 
  4    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  4    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  4    65 /* or the physical volume table entry (pvte) device type.		      */
  4    66 
  4    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  4    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  4    69 
  4    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  4    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  4    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  4    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    76 
  4    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      149 
      150 
  5     1 /* Begin fs_dev_types_sector.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     7*     Add the sector differance for devices that do 64 word IO and devices that
  5     8*     do 512 word IO.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  5    12*	 need all the data in fs_dev_types. This is also included in
  5    13*	 fs_dev_types.incl.pl1  */
  5    14 
  5    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  5    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  5    17 
  5    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  5    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  5    20 
  5    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  5    22  /* table of # of sectors per record on each device */
  5    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  5    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    25 
  5    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  5    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    28 	
  5    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  5    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  5    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    32 
  5    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  5    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  5    35 
  5    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  5    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  5    38 
  5    39 /* End fs_dev_types_sector.incl.pl1 */
  5    40 
      151 
      152 
  6     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  6     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  6     6*     Add the subvolume info.
  6     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6     9*     Added inconsistent_dbm bit used to determine consistency of volume
  6    10*     dumper bit maps.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  6    14 /* Note: fsout_vol clears pad fields before writing the label */
  6    15 
  6    16 dcl  labelp ptr;
  6    17 
  6    18 dcl 1 label based (labelp) aligned,
  6    19 
  6    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  6    21 
  6    22     2 gcos (5*64) fixed bin,
  6    23 
  6    24 /* Now we have the Multics label */
  6    25 
  6    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  6    27     2 version fixed bin,				/* Version 1 */
  6    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  6    29     2 pv_name char (32),				/* Physical volume name. */
  6    30     2 lv_name char (32),				/* Name of logical volume for pack */
  6    31     2 pvid bit (36),				/* Unique ID of this pack */
  6    32     2 lvid bit (36),				/* unique ID of its logical vol */
  6    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  6    34     2 time_registered fixed bin (71),			/* time imported to system */
  6    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  6    36     2 vol_size fixed bin,				/* total size of volume, in records */
  6    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  6    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  6    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  6    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  6    41     2 flagpad bit (33) unal,
  6    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  6    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  6    44     2 password bit (72),				/* not yet used */
  6    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  6    46     2 this_sv fixed bin,				/* what subvolume number it is */
  6    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  6    48     2 pad1 (13) fixed bin,
  6    49     2 time_mounted fixed bin (71),			/* time mounted */
  6    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  6    51 
  6    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  6    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  6    54* */
  6    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  6    56     2 pad6 fixed bin,				
  6    57 
  6    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  6    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  6    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  6    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  6    62     2 pad1a (2) fixed bin,
  6    63     2 err_hist_size fixed bin,			/* size of pack error history */
  6    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  6    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  6    66     2 pad2 (40) fixed bin,
  6    67     2 root,
  6    68       3 here bit (1),				/* TRUE if the root is on this pack */
  6    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  6    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  6    71       3 pad7 bit (1) aligned,				
  6    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  6    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  6    74       3 esd_state fixed bin,				/* State of esd */
  6    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  6    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  6    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  6    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  6    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  6    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  6    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  6    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  6    83     2 pad3 (52) fixed bin,
  6    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  6    85     2 parts (47),
  6    86       3 part char (4),				/* Name of partition */
  6    87       3 frec fixed bin,				/* First record */
  6    88       3 nrec fixed bin,				/* Number of records */
  6    89       3 pad5 fixed bin,
  6    90     2 pad4 (5*64) fixed bin;
  6    91 
  6    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  6    93 
  6    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      153 
      154 
      155 /* BEGIN MESSAGE DOCUMENTATION
      156*
      157*   Message:
      158*   rldr_label_: Label position failed: ERROR_MESS
      159*
      160*   S:	$rld_out
      161*
      162*   T:	$reload
      163*
      164*   M:	Someting is wrong with a reloader output volume.
      165*
      166*   A:	Mount a correct volume and try again.
      167*
      168*
      169*   Message:
      170*   rldr_label_: Label read failed: ERROR_MESS
      171*
      172*   S:	$rld_out
      173*
      174*   T:	$reload
      175*
      176*   M:	Someting is wrong with a reloader output volume.
      177*
      178*   A:	Mount a correct volume and try again.
      179*
      180*
      181*   Message:
      182*   rldr_label_: Incorrect output medium mounted: ERROR_MESS
      183*
      184*   S:	$rld_out
      185*
      186*   T:	$reload
      187*
      188*   M:	Someting is wrong with a reloader output volume.
      189*
      190*   A:	Mount a correct volume and try again.
      191*
      192*
      193*   Message:
      194*   rldr_label_: Output volume pvid MMMMMMMMMMMM not equal to online 
      195*	      pvid NNNNNNNNNNNN for pv PPPPPPPP. Invalid volume identifier.
      196*
      197*   S:	$rld_out
      198*
      199*   T:	$reload
      200*
      201*   M:	The PVID on the output disk volume does not match the PVID as
      202*          recorded in the pvolog for the disk volume.  This indicates that
      203*	either the label on the PV is incorrect or the pvolog segment
      204*	is corrupted.
      205*
      206*   A:	Verify the PVID using output from the display_disk_label command.
      207*	If the PVID from ddl output is differnet from that reported for the
      208*	output volume, use change_volume_registration and init_vol to
      209*	correct the disk label.  If the online PVID does not match, use the
      210*	recover_volume_log command to retrieve a correct pvolog segment.
      211*	Retry the reload.
      212*
      213*
      214*   Message:
      215*   rldr_label_: Label write failed: ERROR_MESS
      216*
      217*   S:	$rld_out
      218*
      219*   T:	$reload
      220*
      221*   M:	Someting is wrong with a reloader output volume.
      222*
      223*   A:	Mount a correct volume and try again.
      224*
      225*
      226*   END MESSAGE DOCUMENTATION */
      227 
      228   end rldr_label_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/21/92  1623.8  rldr_label_.pl1                   >spec>install>1039>rldr_label_.pl1
144          1    10/18/88  1315.0  rldr_data_.incl.pl1               >ldd>include>rldr_data_.incl.pl1
146          2    09/05/80  1236.5  backup_info.incl.pl1              >ldd>include>backup_info.incl.pl1
147          3    09/05/80  1236.5  backup_volume_header.incl.pl1     >ldd>include>backup_volume_header.incl.pl1
149          4    10/22/86  1550.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
151          5    07/24/86  2151.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
153          6    07/21/88  2136.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LABEL_ADDR                             constant        fixed bin(17,0)          initial dcl 4-54 set ref 63* 63* 114* 114*
SECTORS_PER_RECORD              000011 constant        fixed bin(17,0)          initial array dcl 4-74 ref 138
add                                    parameter       fixed bin(17,0)          dcl 134 ref 130 138
backup_info                            based           structure                level 1 dcl 2-7
backup_volume_header                   based           structure                level 1 dcl 3-5
bits                                   based           structure                level 3 dcl 1-23
clock                                                  builtin function         dcl 51 ref 107
code                                   parameter       fixed bin(35,0)          dcl 40 set ref 56 61* 63* 64 65* 70* 71 72* 80* 81*
                                                                                  90 94* 114* 115 116* 121* 122 122*
common                                 based           structure                level 2 dcl 1-23
dev_idx                         000632 automatic       fixed bin(17,0)          dcl 135 set ref 137* 138 140
disk_type               475            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 137
divide                                                 builtin function         dcl 51 ref 139
error_table_$bad_volid          000010 external static fixed bin(35,0)          dcl 44 ref 80
here                    700            based           bit(1)                   level 3 dcl 6-18 set ref 103*
inconsistent_dbm        551(02)        based           bit(1)                   level 2 packed packed unaligned dcl 6-18 set ref
                                                                                  112*
infop                           000620 automatic       pointer                  dcl 2-3 in procedure "rldr_label_" set ref 100* 101
                                                                                  102
infop                   424            based           pointer                  level 4 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "rldr_label_" ref 100
iox_$get_chars                  000016 constant        entry                    external dcl 48 ref 70
iox_$position                   000014 constant        entry                    external dcl 47 ref 63 114
iox_$put_chars                  000020 constant        entry                    external dcl 49 ref 121
label                                  based           structure                level 1 dcl 6-18 set ref 70 121
labelp                          000622 automatic       pointer                  dcl 6-16 in procedure "rldr_label_" set ref 70 77*
                                                                                  78 81 95* 98 99 101 102 103 104 107 112 121* 121
labelp                  506            based           pointer                  array level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "rldr_label_" set ref 70* 77 95
lv_name                 531            based           char(32)                 level 2 dcl 6-18 set ref 99*
lvid                    542            based           bit(36)                  level 2 dcl 6-18 set ref 102*
myname                          000022 constant        char(32)                 initial packed unaligned dcl 42 set ref 65* 72* 81*
                                                                                  116* 122*
outputvol_iocbp         512            based           pointer                  array level 3 dcl 1-23 set ref 63* 70* 114* 121*
per_pv                  434            based           structure                array level 2 dcl 1-23
ptrs                    414            based           structure                level 3 dcl 1-23
pv_name                 521            based           char(32)                 level 2 dcl 6-18 set ref 98*
pvid                    541            based           bit(36)                  level 2 in structure "label" dcl 6-18 in procedure
                                                                                  "rldr_label_" set ref 78 81* 101*
pvid                    472            based           bit(36)                  array level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "rldr_label_" set ref 78 81*
pvindex                                parameter       fixed bin(17,0)          dcl 41 ref 56 63 65 70 70 72 77 78 78 81 81 90 95 97
                                                                                  114 116 121 122 137 139 139
pvname                  437            based           char(32)                 array level 3 dcl 1-23 set ref 65* 72* 78 81* 97
                                                                                  116* 122*
rldr_data_                             based           structure                level 1 dcl 1-23
rldr_data_common                000100 automatic       structure                level 1 dcl 1-23
rldr_data_perpv                 000534 automatic       structure                level 1 dcl 1-23
rldr_datap                             parameter       pointer                  dcl 1-23 set ref 56 63 65* 65 70 70 72* 72 77 78 78
                                                                                  81* 81 81 90 95 97 97 100 114 116* 116 121 122*
                                                                                  122 137 139 139
rldr_report_$error_output       000012 constant        entry                    external dcl 46 ref 65 72 81 116 122
root                    700            based           structure                level 2 dcl 6-18
rpv                       0(02)        based           bit(1)                   level 4 packed packed unaligned dcl 1-23 ref 97
rpv_lvid                 12            based           bit(36)                  level 2 dcl 2-7 ref 102
rpv_pvid                 11            based           bit(36)                  level 2 dcl 2-7 ref 101
sector                          000633 automatic       fixed bin(17,0)          dcl 135 set ref 138* 139* 139 139 140
shutdown_state          702            based           fixed bin(17,0)          level 3 dcl 6-18 set ref 104*
size                                                   builtin function         dcl 51 ref 70 121
time_last_reloaded      626            based           fixed bin(71,0)          level 2 dcl 6-18 set ref 107*
unusable_sectors        477            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 139
usable_sectors          476            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 139
words_per_sect                  000000 constant        fixed bin(17,0)          initial array dcl 5-36 ref 140

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 4-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 4-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 4-54
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 6-92
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 4-67
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 4-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 4-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 4-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 4-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 4-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 4-54
backup_info_version_2                  internal static fixed bin(17,0)          initial dcl 2-5
contents_type                          internal static fixed bin(17,0)          initial dcl 3-21
dir_type                               internal static fixed bin(17,0)          initial dcl 3-16
hdp                                    automatic       pointer                  dcl 3-3
info_type                              internal static fixed bin(17,0)          initial dcl 3-22
null_type                              internal static fixed bin(17,0)          initial dcl 3-18
pattern1                               internal static bit(36)                  initial packed unaligned dcl 3-24
pattern2                               internal static bit(36)                  initial packed unaligned dcl 3-25
pattern3                               internal static bit(36)                  initial packed unaligned dcl 3-26
prev_output_log_type                   internal static fixed bin(17,0)          initial dcl 3-20
rldr_data_max_pvs                      automatic       fixed bin(17,0)          dcl 1-23
rldr_data_nulled_pv                    internal static structure                level 1 dcl 1-23
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 5-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 5-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 5-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 5-26
seg_type                               internal static fixed bin(17,0)          initial dcl 3-17
volume_log_type                        internal static fixed bin(17,0)          initial dcl 3-19
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-29
vtoce_type                             internal static fixed bin(17,0)          initial dcl 3-15

NAMES DECLARED BY EXPLICIT CONTEXT.
close                           000424 constant        entry                    external dcl 90
open                            000126 constant        entry                    external dcl 56
rldr_label_                     000114 constant        entry                    external dcl 34
sector                          000666 constant        entry                    internal dcl 130 ref 63 63 114 114

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1042        1064     732        1052
Length      1366     732        22         265     107           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rldr_label_                         479 external procedure  is an external procedure.  
sector                                  internal procedure  shares stack frame of external procedure rldr_label_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rldr_label_              000100 rldr_data_common            rldr_label_
                         000534 rldr_data_perpv             rldr_label_
                         000620 infop                       rldr_label_
                         000622 labelp                      rldr_label_
                         000632 dev_idx                     sector
                         000633 sector                      sector

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$get_chars                iox_$position                 iox_$put_chars                rldr_report_$error_output

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_volid


CONSTANTS
000716  aa     000004000000
000717  aa     000000000000
000720  ta     000042000000
000721  aa     000000000000
000722  aa     600000000041
000723  aa     000635000000

000724  aa     000004000000
000725  aa     000000000000
000726  ta     000042000000
000727  aa     000000000000
000730  aa     600000000041
000731  aa     000636000000

000000  aa     000000000000
000001  aa     000000000100
000002  aa     000000000100
000003  aa     000000000100
000004  aa     000000000100
000005  aa     000000000100
000006  aa     000000000100
000007  aa     000000001000
000010  aa     000000001000

000011  aa     000000000000
000012  aa     000000000020
000013  aa     000000000020
000014  aa     000000000020
000015  aa     000000000020
000016  aa     000000000020
000017  aa     000000000020
000020  aa     000000000002
000021  aa     000000000002

000022  aa  162 154 144 162	rldr
000023  aa  137 154 141 142	_lab
000024  aa  145 154 137 040	el_ 
000025  aa  040 040 040 040	    
000026  aa  040 040 040 040	    
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa  040 040 040 040	    

000032  aa  162 157 157 164	root

000033  aa     514000000044

000034  aa     524000000073

000035  aa  162 160 166 000	rpv

000036  aa     524000000033

000037  aa     524000000040

000040  aa     524000000037

000041  aa     526000000040

000042  aa     000000000000

000043  aa     464000000000

000044  aa     404000000021

000045  aa     404000000043

000046  aa  114 141 142 145	Labe
000047  aa  154 040 167 162	l wr
000050  aa  151 164 145 040	ite 
000051  aa  146 141 151 154	fail
000052  aa  145 144 040 157	ed o
000053  aa  156 040 160 166	n pv
000054  aa  040 136 141 000	 ^a

000055  aa  114 141 142 145	Labe
000056  aa  154 040 162 145	l re
000057  aa  141 144 040 146	ad f
000060  aa  141 151 154 145	aile
000061  aa  144 040 146 157	d fo
000062  aa  162 040 160 166	r pv
000063  aa  040 136 141 000	 ^a

000064  aa  114 141 142 145	Labe
000065  aa  154 040 160 157	l po
000066  aa  163 151 164 151	siti
000067  aa  157 156 040 146	on f
000070  aa  141 151 154 145	aile
000071  aa  144 040 146 157	d fo
000072  aa  162 040 160 166	r pv
000073  aa  040 136 141 000	 ^a

000074  aa  117 165 164 160	Outp
000075  aa  165 164 040 166	ut v
000076  aa  157 154 165 155	olum
000077  aa  145 040 160 166	e pv
000100  aa  151 144 040 136	id ^
000101  aa  157 040 156 157	o no
000102  aa  164 040 145 161	t eq
000103  aa  165 141 154 040	ual 
000104  aa  164 157 040 157	to o
000105  aa  156 154 151 156	nlin
000106  aa  145 040 160 166	e pv
000107  aa  151 144 040 136	id ^
000110  aa  157 040 146 157	o fo
000111  aa  162 040 160 166	r pv
000112  aa  040 136 141 000	 ^a

BEGIN PROCEDURE rldr_label_
ENTRY TO rldr_label_                                        STATEMENT 1 ON LINE 34
rldr_label_: proc;

000113  da     000071200000
000114  aa   000740 6270 00	eax7 	480
000115  aa  7 00034 3521 20	epp2 	pr7|28,*
000116  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000117  aa     000000000000
000120  aa     000000000000
						STATEMENT 1 ON LINE 56
open: entry (rldr_datap, pvindex, code);

000121  aa   000012 7100 04	tra  	10,ic		000133
ENTRY TO open                                               STATEMENT 1 ON LINE 56
open: entry (rldr_datap, pvindex, code);

000122  at     000003000043
000123  tt     000044000045
000124  ta     000122000000
000125  da     000076300000
000126  aa   000740 6270 00	eax7 	480
000127  aa  7 00034 3521 20	epp2 	pr7|28,*
000130  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000131  aa     000006000000
000132  aa     000000000000
						STATEMENT 1 ON LINE 61
    code = 0;

000133  aa  6 00032 3735 20	epp7 	pr6|26,*
000134  aa  7 00006 4501 20	stz  	pr7|6,*		code
						STATEMENT 1 ON LINE 63
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (LABEL_ADDR), code);

000135  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000136  aa   000064 4020 07	mpy  	52,dl
000137  aa  6 00635 7561 00	stq  	pr6|413
000140  aa   000002 2360 07	ldq  	2,dl
000141  aa  6 00634 7561 00	stq  	pr6|412
000142  aa   000562 3520 04	epp2 	370,ic		000724 = 000004000000
000143  aa   000523 6700 04	tsp4 	339,ic		000666
000144  aa  6 00032 3735 20	epp7 	pr6|26,*
000145  aa  6 00635 7271 00	lxl7 	pr6|413
000146  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000147  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000150  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000151  aa  6 00642 2521 00	spri2	pr6|418
000152  aa  6 00634 3521 00	epp2 	pr6|412
000153  aa  6 00644 2521 00	spri2	pr6|420
000154  aa  6 00636 3521 00	epp2 	pr6|414
000155  aa  6 00646 2521 00	spri2	pr6|422
000156  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000157  aa  6 00650 2521 00	spri2	pr6|424
000160  aa  6 00640 6211 00	eax1 	pr6|416
000161  aa   020000 4310 07	fld  	8192,dl
000162  aa  6 00044 3701 20	epp4 	pr6|36,*
000163  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$position
000164  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 64
    if code ^= 0 then do;

000165  aa  6 00032 3735 20	epp7 	pr6|26,*
000166  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000167  aa   000044 6000 04	tze  	36,ic		000233
						STATEMENT 1 ON LINE 65
        call rldr_report_$error_output (rldr_datap, code, myname, "Label position failed for pv ^a",
	   rldr_data_.pvname (pvindex));

000170  aa   777647 2360 04	ldq  	-89,ic		000037 = 524000000040
000171  aa  6 00636 7561 00	stq  	pr6|414
000172  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000173  aa   777672 00 0040	desc9a	-70,32		000064 = 114141142145
000174  aa  6 00640 00 0040	desc9a	pr6|416,32
000175  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000176  aa   000064 4020 07	mpy  	52,dl
000177  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000200  aa  6 00654 2521 00	spri2	pr6|428
000201  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000202  aa  6 00656 2521 00	spri2	pr6|430
000203  aa   777617 3520 04	epp2 	-113,ic		000022 = 162154144162
000204  aa  6 00660 2521 00	spri2	pr6|432
000205  aa  6 00640 3521 00	epp2 	pr6|416
000206  aa  6 00662 2521 00	spri2	pr6|434
000207  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000210  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000211  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000212  aa  6 00664 2521 00	spri2	pr6|436
000213  aa   777630 3520 04	epp2 	-104,ic		000043 = 464000000000
000214  aa  6 00666 2521 00	spri2	pr6|438
000215  aa   777630 3520 04	epp2 	-104,ic		000045 = 404000000043
000216  aa  6 00670 2521 00	spri2	pr6|440
000217  aa   777622 3520 04	epp2 	-110,ic		000041 = 526000000040
000220  aa  6 00672 2521 00	spri2	pr6|442
000221  aa   777617 3520 04	epp2 	-113,ic		000040 = 524000000037
000222  aa  6 00674 2521 00	spri2	pr6|444
000223  aa  6 00636 3521 00	epp2 	pr6|414
000224  aa  6 00676 2521 00	spri2	pr6|446
000225  aa  6 00652 6211 00	eax1 	pr6|426
000226  aa   024000 4310 07	fld  	10240,dl
000227  aa  6 00044 3701 20	epp4 	pr6|36,*
000230  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_report_$error_output
000231  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 67
        return;

000232  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 68
      end;

						STATEMENT 1 ON LINE 70
    call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.labelp (pvindex), size (label) * 4, (0), code);

000233  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000234  aa   000064 4020 07	mpy  	52,dl
000235  aa   000000 6270 06	eax7 	0,ql
000236  aa   010000 2360 07	ldq  	4096,dl
000237  aa  6 00636 7561 00	stq  	pr6|414
000240  aa  6 00635 4501 00	stz  	pr6|413
000241  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000242  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000243  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000244  aa  6 00654 2521 00	spri2	pr6|428
000245  aa  5 00422 3521 17	epp2 	pr5|274,7		rldr_data_.labelp
000246  aa  6 00656 2521 00	spri2	pr6|430
000247  aa  6 00636 3521 00	epp2 	pr6|414
000250  aa  6 00660 2521 00	spri2	pr6|432
000251  aa  6 00635 3521 00	epp2 	pr6|413
000252  aa  6 00662 2521 00	spri2	pr6|434
000253  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000254  aa  6 00664 2521 00	spri2	pr6|436
000255  aa  6 00652 6211 00	eax1 	pr6|426
000256  aa   024000 4310 07	fld  	10240,dl
000257  aa  6 00044 3701 20	epp4 	pr6|36,*
000260  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$get_chars
000261  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 71
    if code ^= 0 then do;

000262  aa  6 00032 3735 20	epp7 	pr6|26,*
000263  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000264  aa   000044 6000 04	tze  	36,ic		000330
						STATEMENT 1 ON LINE 72
        call rldr_report_$error_output (rldr_datap, code, myname, "Label read failed for pv ^a",
	   rldr_data_.pvname (pvindex));

000265  aa   777552 2360 04	ldq  	-150,ic		000037 = 524000000040
000266  aa  6 00635 7561 00	stq  	pr6|413
000267  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000270  aa   777566 00 0034	desc9a	-138,28		000055 = 114141142145
000271  aa  6 00640 00 0034	desc9a	pr6|416,28
000272  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000273  aa   000064 4020 07	mpy  	52,dl
000274  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000275  aa  6 00654 2521 00	spri2	pr6|428
000276  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000277  aa  6 00656 2521 00	spri2	pr6|430
000300  aa   777522 3520 04	epp2 	-174,ic		000022 = 162154144162
000301  aa  6 00660 2521 00	spri2	pr6|432
000302  aa  6 00640 3521 00	epp2 	pr6|416
000303  aa  6 00662 2521 00	spri2	pr6|434
000304  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000305  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000306  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000307  aa  6 00664 2521 00	spri2	pr6|436
000310  aa   777533 3520 04	epp2 	-165,ic		000043 = 464000000000
000311  aa  6 00666 2521 00	spri2	pr6|438
000312  aa   777533 3520 04	epp2 	-165,ic		000045 = 404000000043
000313  aa  6 00670 2521 00	spri2	pr6|440
000314  aa   777525 3520 04	epp2 	-171,ic		000041 = 526000000040
000315  aa  6 00672 2521 00	spri2	pr6|442
000316  aa   777520 3520 04	epp2 	-176,ic		000036 = 524000000033
000317  aa  6 00674 2521 00	spri2	pr6|444
000320  aa  6 00635 3521 00	epp2 	pr6|413
000321  aa  6 00676 2521 00	spri2	pr6|446
000322  aa  6 00652 6211 00	eax1 	pr6|426
000323  aa   024000 4310 07	fld  	10240,dl
000324  aa  6 00044 3701 20	epp4 	pr6|36,*
000325  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_report_$error_output
000326  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 74
        return;

000327  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 75
      end;

						STATEMENT 1 ON LINE 77
    labelp = rldr_data_.labelp (pvindex);

000330  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000331  aa   000064 4020 07	mpy  	52,dl
000332  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000333  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000334  aa  5 00422 3535 26	epp3 	pr5|274,ql*	rldr_data_.labelp
000335  aa  6 00622 2535 00	spri3	pr6|402		labelp
						STATEMENT 1 ON LINE 78
    if ^(rldr_data_.pvname (pvindex) = "rpv") then
      if label.pvid ^= rldr_data_.pvid (pvindex) then do;

000336  aa  5 00353 3515 06	epp1 	pr5|235,ql	rldr_data_.pvname
000337  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000340  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_data_.pvname
000341  aa   777476 00 0003	desc9a	-194,3		000035 = 162160166000
000342  aa   000057 6000 04	tze  	47,ic		000421
000343  aa  3 00541 2351 00	lda  	pr3|353		label.pvid
000344  aa  5 00406 1151 06	cmpa 	pr5|262,ql	rldr_data_.pvid
000345  aa   000054 6000 04	tze  	44,ic		000421
						STATEMENT 1 ON LINE 80
	code = error_table_$bad_volid;

000346  aa  6 00044 3701 20	epp4 	pr6|36,*
000347  aa   000000 6270 06	eax7 	0,ql
000350  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_volid
000351  aa  7 00006 7561 20	stq  	pr7|6,*		code
						STATEMENT 1 ON LINE 81
	call rldr_report_$error_output (rldr_datap, code, myname,
	     "Output volume pvid ^o not equal to online pvid ^o for pv ^a",
	     label.pvid, rldr_data_.pvid (pvindex), rldr_data_.pvname (pvindex));

000352  aa   777461 2360 04	ldq  	-207,ic		000033 = 514000000044
000353  aa  6 00636 7561 00	stq  	pr6|414
000354  aa   777463 2360 04	ldq  	-205,ic		000037 = 524000000040
000355  aa  6 00634 7561 00	stq  	pr6|412
000356  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000357  aa   777516 00 0074	desc9a	-178,60		000074 = 117165164160
000360  aa  6 00652 00 0074	desc9a	pr6|426,60
000361  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000362  aa  6 00702 2521 00	spri2	pr6|450
000363  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000364  aa  6 00704 2521 00	spri2	pr6|452
000365  aa   777435 3520 04	epp2 	-227,ic		000022 = 162154144162
000366  aa  6 00706 2521 00	spri2	pr6|454
000367  aa  6 00652 3521 00	epp2 	pr6|426
000370  aa  6 00710 2521 00	spri2	pr6|456
000371  aa  3 00541 3521 00	epp2 	pr3|353		label.pvid
000372  aa  6 00712 2521 00	spri2	pr6|458
000373  aa  5 00406 3521 17	epp2 	pr5|262,7		rldr_data_.pvid
000374  aa  6 00714 2521 00	spri2	pr6|460
000375  aa  5 00353 3521 17	epp2 	pr5|235,7		rldr_data_.pvname
000376  aa  6 00716 2521 00	spri2	pr6|462
000377  aa   777444 3520 04	epp2 	-220,ic		000043 = 464000000000
000400  aa  6 00720 2521 00	spri2	pr6|464
000401  aa   777444 3520 04	epp2 	-220,ic		000045 = 404000000043
000402  aa  6 00722 2521 00	spri2	pr6|466
000403  aa   777436 3520 04	epp2 	-226,ic		000041 = 526000000040
000404  aa  6 00724 2521 00	spri2	pr6|468
000405  aa   777427 3520 04	epp2 	-233,ic		000034 = 524000000073
000406  aa  6 00726 2521 00	spri2	pr6|470
000407  aa   777424 3520 04	epp2 	-236,ic		000033 = 514000000044
000410  aa  6 00730 2521 00	spri2	pr6|472
000411  aa  6 00636 3521 00	epp2 	pr6|414
000412  aa  6 00732 2521 00	spri2	pr6|474
000413  aa  6 00634 3521 00	epp2 	pr6|412
000414  aa  6 00734 2521 00	spri2	pr6|476
000415  aa  6 00700 6211 00	eax1 	pr6|448
000416  aa   034000 4310 07	fld  	14336,dl
000417  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_report_$error_output
000420  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 84
        end;

						STATEMENT 1 ON LINE 85
    return;

000421  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO close                                              STATEMENT 1 ON LINE 90
close: entry (rldr_datap, pvindex, code);

000422  ta     000122000000
000423  da     000103300000
000424  aa   000740 6270 00	eax7 	480
000425  aa  7 00034 3521 20	epp2 	pr7|28,*
000426  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000427  aa     000006000000
000430  aa     000000000000
						STATEMENT 1 ON LINE 94
    code = 0;

000431  aa  6 00032 3735 20	epp7 	pr6|26,*
000432  aa  7 00006 4501 20	stz  	pr7|6,*		code
						STATEMENT 1 ON LINE 95
    labelp = rldr_data_.labelp (pvindex);

000433  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000434  aa   000064 4020 07	mpy  	52,dl
000435  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000436  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000437  aa  5 00422 3535 26	epp3 	pr5|274,ql*	rldr_data_.labelp
000440  aa  6 00622 2535 00	spri3	pr6|402		labelp
						STATEMENT 1 ON LINE 97
    if (rldr_data_.rpv & rldr_data_.pvname (pvindex) = "rpv") then do;

000441  aa  5 00000 2351 00	lda  	pr5|0		rldr_data_.rpv
000442  aa   100000 3150 03	cana 	32768,du
000443  aa   000026 6000 04	tze  	22,ic		000471
000444  aa  5 00353 3515 06	epp1 	pr5|235,ql	rldr_data_.pvname
000445  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000446  aa  1 00000 00 0040	desc9a	pr1|0,32		rldr_data_.pvname
000447  aa   777370 00 0003	desc9a	-264,3		000035 = 162160166000
000450  aa   000021 6010 04	tnz  	17,ic		000471
						STATEMENT 1 ON LINE 98
        label.pv_name = "rpv";

000451  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000452  aa   777364 00 0003	desc9a	-268,3		000035 = 162160166000
000453  aa  3 00521 00 0040	desc9a	pr3|337,32	label.pv_name
						STATEMENT 1 ON LINE 99
        label.lv_name = "root";

000454  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000455  aa   777356 00 0004	desc9a	-274,4		000032 = 162157157164
000456  aa  3 00531 00 0040	desc9a	pr3|345,32	label.lv_name
						STATEMENT 1 ON LINE 100
        infop = rldr_data_.infop;

000457  aa  5 00424 3515 20	epp1 	pr5|276,*		rldr_data_.infop
000460  aa  6 00620 2515 00	spri1	pr6|400		infop
						STATEMENT 1 ON LINE 101
        label.pvid = backup_info.rpv_pvid;

000461  aa  1 00011 2351 00	lda  	pr1|9		backup_info.rpv_pvid
000462  aa  3 00541 7551 00	sta  	pr3|353		label.pvid
						STATEMENT 1 ON LINE 102
        label.lvid = backup_info.rpv_lvid;

000463  aa  1 00012 2351 00	lda  	pr1|10		backup_info.rpv_lvid
000464  aa  3 00542 7551 00	sta  	pr3|354		label.lvid
						STATEMENT 1 ON LINE 103
        label.root.here = "1"b;

000465  aa   400000 2350 03	lda  	131072,du
000466  aa  3 00700 7551 00	sta  	pr3|448		label.here
						STATEMENT 1 ON LINE 104
        label.root.shutdown_state = 4;

000467  aa   000004 2360 07	ldq  	4,dl
000470  aa  3 00702 7561 00	stq  	pr3|450		label.shutdown_state
						STATEMENT 1 ON LINE 105
      end;

						STATEMENT 1 ON LINE 107
    label.time_last_reloaded = clock;

000471  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
000472  aa  3 00626 7571 00	staq 	pr3|406		label.time_last_reloaded
						STATEMENT 1 ON LINE 112
    label.inconsistent_dbm = "1"b;

000473  aa   100000 2350 03	lda  	32768,du
000474  aa  3 00551 2551 00	orsa 	pr3|361		label.inconsistent_dbm
						STATEMENT 1 ON LINE 114
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (LABEL_ADDR), code);

000475  aa  6 00032 3735 20	epp7 	pr6|26,*
000476  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000477  aa   000064 4020 07	mpy  	52,dl
000500  aa  6 00634 7561 00	stq  	pr6|412
000501  aa   000002 2360 07	ldq  	2,dl
000502  aa  6 00636 7561 00	stq  	pr6|414
000503  aa   000213 3520 04	epp2 	139,ic		000716 = 000004000000
000504  aa   000162 6700 04	tsp4 	114,ic		000666
000505  aa  6 00032 3735 20	epp7 	pr6|26,*
000506  aa  6 00634 7271 00	lxl7 	pr6|412
000507  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000510  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000511  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000512  aa  6 00642 2521 00	spri2	pr6|418
000513  aa  6 00636 3521 00	epp2 	pr6|414
000514  aa  6 00644 2521 00	spri2	pr6|420
000515  aa  6 00635 3521 00	epp2 	pr6|413
000516  aa  6 00646 2521 00	spri2	pr6|422
000517  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000520  aa  6 00650 2521 00	spri2	pr6|424
000521  aa  6 00640 6211 00	eax1 	pr6|416
000522  aa   020000 4310 07	fld  	8192,dl
000523  aa  6 00044 3701 20	epp4 	pr6|36,*
000524  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$position
000525  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 115
    if code ^= 0 then do;

000526  aa  6 00032 3735 20	epp7 	pr6|26,*
000527  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000530  aa   000044 6000 04	tze  	36,ic		000574
						STATEMENT 1 ON LINE 116
        call rldr_report_$error_output (rldr_datap, code, myname, "Label position failed for pv ^a",
	   rldr_data_.pvname (pvindex));

000531  aa   777306 2360 04	ldq  	-314,ic		000037 = 524000000040
000532  aa  6 00635 7561 00	stq  	pr6|413
000533  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000534  aa   777331 00 0040	desc9a	-295,32		000064 = 114141142145
000535  aa  6 00640 00 0040	desc9a	pr6|416,32
000536  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000537  aa   000064 4020 07	mpy  	52,dl
000540  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000541  aa  6 00654 2521 00	spri2	pr6|428
000542  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000543  aa  6 00656 2521 00	spri2	pr6|430
000544  aa   777256 3520 04	epp2 	-338,ic		000022 = 162154144162
000545  aa  6 00660 2521 00	spri2	pr6|432
000546  aa  6 00640 3521 00	epp2 	pr6|416
000547  aa  6 00662 2521 00	spri2	pr6|434
000550  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000551  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000552  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000553  aa  6 00664 2521 00	spri2	pr6|436
000554  aa   777267 3520 04	epp2 	-329,ic		000043 = 464000000000
000555  aa  6 00666 2521 00	spri2	pr6|438
000556  aa   777267 3520 04	epp2 	-329,ic		000045 = 404000000043
000557  aa  6 00670 2521 00	spri2	pr6|440
000560  aa   777261 3520 04	epp2 	-335,ic		000041 = 526000000040
000561  aa  6 00672 2521 00	spri2	pr6|442
000562  aa   777256 3520 04	epp2 	-338,ic		000040 = 524000000037
000563  aa  6 00674 2521 00	spri2	pr6|444
000564  aa  6 00635 3521 00	epp2 	pr6|413
000565  aa  6 00676 2521 00	spri2	pr6|446
000566  aa  6 00652 6211 00	eax1 	pr6|426
000567  aa   024000 4310 07	fld  	10240,dl
000570  aa  6 00044 3701 20	epp4 	pr6|36,*
000571  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_report_$error_output
000572  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 118
        return;

000573  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 119
      end;

						STATEMENT 1 ON LINE 121
    call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), labelp, size (label) * 4, code);

000574  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000575  aa   000064 4020 07	mpy  	52,dl
000576  aa   000000 6270 06	eax7 	0,ql
000577  aa   010000 2360 07	ldq  	4096,dl
000600  aa  6 00635 7561 00	stq  	pr6|413
000601  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000602  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000603  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000604  aa  6 00642 2521 00	spri2	pr6|418
000605  aa  6 00622 3521 00	epp2 	pr6|402		labelp
000606  aa  6 00644 2521 00	spri2	pr6|420
000607  aa  6 00635 3521 00	epp2 	pr6|413
000610  aa  6 00646 2521 00	spri2	pr6|422
000611  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000612  aa  6 00650 2521 00	spri2	pr6|424
000613  aa  6 00640 6211 00	eax1 	pr6|416
000614  aa   020000 4310 07	fld  	8192,dl
000615  aa  6 00044 3701 20	epp4 	pr6|36,*
000616  la  4 00020 3521 20	epp2 	pr4|16,*		iox_$put_chars
000617  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 122
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "Label write failed on pv ^a",
	 rldr_data_.pvname (pvindex));

000620  aa  6 00032 3735 20	epp7 	pr6|26,*
000621  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000622  aa   000043 6000 04	tze  	35,ic		000665
000623  aa   777214 2360 04	ldq  	-372,ic		000037 = 524000000040
000624  aa  6 00635 7561 00	stq  	pr6|413
000625  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000626  aa   777221 00 0034	desc9a	-367,28		000046 = 114141142145
000627  aa  6 00640 00 0034	desc9a	pr6|416,28
000630  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000631  aa   000064 4020 07	mpy  	52,dl
000632  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000633  aa  6 00654 2521 00	spri2	pr6|428
000634  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000635  aa  6 00656 2521 00	spri2	pr6|430
000636  aa   777164 3520 04	epp2 	-396,ic		000022 = 162154144162
000637  aa  6 00660 2521 00	spri2	pr6|432
000640  aa  6 00640 3521 00	epp2 	pr6|416
000641  aa  6 00662 2521 00	spri2	pr6|434
000642  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000643  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000644  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000645  aa  6 00664 2521 00	spri2	pr6|436
000646  aa   777175 3520 04	epp2 	-387,ic		000043 = 464000000000
000647  aa  6 00666 2521 00	spri2	pr6|438
000650  aa   777175 3520 04	epp2 	-387,ic		000045 = 404000000043
000651  aa  6 00670 2521 00	spri2	pr6|440
000652  aa   777167 3520 04	epp2 	-393,ic		000041 = 526000000040
000653  aa  6 00672 2521 00	spri2	pr6|442
000654  aa   777162 3520 04	epp2 	-398,ic		000036 = 524000000033
000655  aa  6 00674 2521 00	spri2	pr6|444
000656  aa  6 00635 3521 00	epp2 	pr6|413
000657  aa  6 00676 2521 00	spri2	pr6|446
000660  aa  6 00652 6211 00	eax1 	pr6|426
000661  aa   024000 4310 07	fld  	10240,dl
000662  aa  6 00044 3701 20	epp4 	pr6|36,*
000663  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_report_$error_output
000664  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 125
    return;

000665  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 228
  end rldr_label_;

BEGIN PROCEDURE sector
ENTRY TO sector                                             STATEMENT 1 ON LINE 130
sector: proc (add) returns (fixed bin);

000666  aa  6 00624 6501 00	spri4	pr6|404
000667  aa  6 00626 2521 00	spri2	pr6|406
						STATEMENT 1 ON LINE 137
    dev_idx = rldr_data_.disk_type (pvindex);

000670  aa  6 00032 3735 20	epp7 	pr6|26,*
000671  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000672  aa   000064 4020 07	mpy  	52,dl
000673  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000674  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000675  aa   000000 6260 06	eax6 	0,ql
000676  aa  5 00411 2361 06	ldq  	pr5|265,ql	rldr_data_.disk_type
000677  aa  6 00632 7561 00	stq  	pr6|410		dev_idx
						STATEMENT 1 ON LINE 138
    sector = add * SECTORS_PER_RECORD (dev_idx);

000700  aa  2 00002 2361 20	ldq  	pr2|2,*		add
000701  aa  6 00632 7271 00	lxl7 	pr6|410		dev_idx
000702  ta   000010 4020 17	mpy  	8,7
000703  aa  6 00633 7561 00	stq  	pr6|411		sector
						STATEMENT 1 ON LINE 139
    sector = sector + divide (sector, rldr_data_.usable_sectors (pvindex), 17, 0) * rldr_data_.unusable_sectors (pvindex);

000704  aa  5 00412 5061 16	div  	pr5|266,6		rldr_data_.usable_sectors
000705  aa  5 00413 4021 16	mpy  	pr5|267,6		rldr_data_.unusable_sectors
000706  aa   000044 7770 00	llr  	36
000707  aa   000044 7330 00	lrs  	36
000710  aa  6 00633 0331 00	adl  	pr6|411		sector
000711  aa  6 00633 7561 00	stq  	pr6|411		sector
						STATEMENT 1 ON LINE 140
    return (sector * words_per_sect (dev_idx) * 4);

000712  ta   777777 4020 17	mpy  	-1,7
000713  aa   000004 4020 07	mpy  	4,dl
000714  aa  2 00004 7561 20	stq  	pr2|4,*
000715  aa  6 00624 6101 00	rtcd 	pr6|404
						STATEMENT 1 ON LINE 142
  end sector;

  END PROCEDURE sector
  END PROCEDURE rldr_label_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
