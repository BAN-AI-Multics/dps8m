	COMPILATION LISTING OF SEGMENT syserr_copy
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1118.31_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4 */
       10 
       11 syserr_copy:
       12      procedure ();
       13 
       14 /* *	SYSERR_COPY
       15*   *
       16*   *	This is the procedure in charge of all syserr log copying, both for the
       17*   *	daemon in ring zero, and for the process that is in charge of copying
       18*   *	messages out of the ring zero buffer into ring four.  Its major duties
       19*   *	are filling a paged log segment from the wired buffer, swapping log
       20*   *	segments and names (either when one fills or on demand), and copying
       21*   *	messages from ring zero out to ring four.
       22*   *
       23*   *	Modification history:
       24*   *	84-08-20, W. Olin Sibert: Initial coding, after syserr_copy_paged
       25*   *	84-10-02, WOS: Removed file system name changing to syserr_seg_manager
       26*   *	84-10-16, WOS: Implemented wakeup sending and threshold
       27*   * 	84-11-11, WOS: Added console recovery support
       28*   *	85-01-21, EJ Sharpe: copy process_id from wired log, convert binary
       29*   *		data_class to character string, change data class to char (16)
       30*   *	85-03-03, EJ Sharpe: format, fix an error message
       31*   *	85-03-25, EJ Sharpe: fix message documentation, sound beeper on "mostly full" msg
       32**/
       33 
       34 declare  P_wlog_ptr pointer parameter;
       35 
       36 declare  sys_log_ptr pointer;
       37 declare  code fixed bin (35);
       38 declare  must_send_wakeup bit (1) aligned;
       39 
       40 declare  error_table_$log_segment_full fixed bin (35) external static;
       41 
       42 declare  ioa_$rsnnl entry options (variable);
       43 declare  lock$unlock_fast entry (pointer);
       44 declare  lock$lock_fast entry (pointer);
       45 declare  log_initialize_ entry (pointer, pointer, fixed bin (18), char (*), fixed bin (35));
       46 declare  log_segment_$create_message_number entry (pointer,
       47 	    fixed bin, fixed bin, char (16) varying, fixed bin (35), pointer, fixed bin (35));
       48 declare  log_segment_$finish_message entry (pointer, pointer, fixed bin (35));
       49 declare  pxss$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       50 declare  syserr entry options (variable);
       51 declare  syserr$error_code entry options (variable);
       52 
       53 declare  WHOAMI char (32) internal static options (constant) init ("syserr_copy");
       54 
       55 declare  (addr, addrel, clock, currentsize, hbound, mod, unspec, wordno) builtin;
       56 
       57 
       58 syserr_copy$wired_log:				/* Called ONLY by syserr_logger_daemon */
       59      entry (P_wlog_ptr);				/* Log is LOCKED on entry */
       60 
       61 	wlog_ptr = P_wlog_ptr;
       62 	syserr_log_data_ptr = addr (syserr_log_data$);
       63 
       64 	must_send_wakeup = "0"b;			/* Set if we hit a threshold */
       65 	call copy_messages ();
       66 
       67 	if must_send_wakeup then
       68 	     if (syserr_log_data.copy_channel ^= 0) then
       69 		call pxss$wakeup (syserr_log_data.copy_process_id, syserr_log_data.copy_channel, -1, (0));
       70 
       71 	return;
       72 
       73 
       74 
       75 syserr_copy$swap_logs:				/* called from syserr_seg_manager to perform */
       76      entry ();					/* actual exchange of logs */
       77 
       78 	syserr_log_data_ptr = addr (syserr_log_data$);
       79 	call swap_logs (("0"b));			/* Swap if we can, ignore if we can't */
       80 	return;
       81 
       82 
       83 
       84 syserr_copy$lock:					/* Utility entrypoints for the rest of ring */
       85      entry ();					/* zero syserr stuff (daemon and seg manager) */
       86 
       87 	syserr_log_data_ptr = addr (syserr_log_data$);
       88 	call lock_paged_log ();
       89 	return;
       90 
       91 
       92 
       93 syserr_copy$unlock:
       94      entry ();
       95 
       96 	syserr_log_data_ptr = addr (syserr_log_data$);
       97 	call unlock_paged_log ();
       98 	return;
       99 
      100 
      101 copy_messages:
      102      procedure ();
      103 
      104 declare  drop_threshold fixed bin (18);
      105 declare  msg_idx fixed bin;
      106 declare  swap_successful bit (1) aligned;
      107 
      108 
      109 	if syserr_log_data.copy_disabled then do;	/* Nothing to do until this gets fixed */
      110 	     syserr_log_data.messages_lost = syserr_log_data.messages_lost + wlog.head.count;
      111 	     return;
      112 	end;
      113 
      114 	sys_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);
      115 	drop_threshold = 1024 * 10;			/* Ten pages in the new log before we cancel */
      116 						/* severity five messages. Really, this should */
      117 						/* be calculated from something, but this will */
      118 						/* have to do for now */
      119 
      120 /* THIS WILL ALL CHANGE WHEN THE COPY IS MADE DIRECTLY FROM ONE OF THE
      121*   MINI-LOGS IN THE WIRED BUFFER */
      122 
      123 	wmess_ptr = addr (wlog.buffer);		/* This is the first wired message */
      124 
      125 	do msg_idx = 1 to wlog.head.count;
      126 	     if (^create_syserr_message ()) then do;	/* If no room in this log, it's full. Try another. */
      127 		call swap_logs (swap_successful);	/* If we can't swap logs, either, thengive up */
      128 		if ^swap_successful then
      129 		     return;
      130 
      131 		if (^create_syserr_message ()) then	/* And, if the new empty log won't do, either, give up */
      132 		     return;			/* (even though should never happen) */
      133 	     end;
      134 
      135 	     if (syserr_log_data.swap_time ^= 0) then	/* Check to see whether we should give up severity 5 */
      136 		if ^syserr_log_data.drop_severity_5 then/* and be sure we haven't made the decision yet */
      137 		     if (wordno (log_message_ptr) > drop_threshold) then do;
      138 			call syserr (SYSERR_PRINT_WITH_ALARM,
      139 			     "^a: LOG partition mostly full. Severity 5 messages will be lost.", WHOAMI);
      140 			syserr_log_data.drop_severity_5 = "1"b;
      141 		     end;
      142 
      143 	     syserr_log_data.messages_copied = syserr_log_data.messages_copied + 1;
      144 
      145 	     wmess_ptr = addrel (wmess_ptr, currentsize (wmess)); /* Move on to the next message */
      146 	end;
      147 
      148 	return;
      149      end copy_messages;
      150 
      151 
      152 create_syserr_message:
      153      procedure () returns (bit (1) aligned);
      154 
      155 declare  text_lth fixed bin;
      156 declare  data_lth fixed bin;
      157 declare  data_type fixed bin;
      158 declare  data_class char (16) varying;
      159 declare  data_buffer (data_lth) bit (36) aligned based;
      160 declare  message_offset fixed bin (18);
      161 
      162 
      163 	if syserr_log_data.drop_severity_5 then		/* Are we to give up this one? */
      164 	     if (mod (wmess.code, 10) = 5) then do;	/* Dispose of it */
      165 		syserr_log_data.messages_lost = syserr_log_data.messages_lost + 1;
      166 		return ("1"b);			/* And act like we succeeded */
      167 	     end;
      168 
      169 	text_lth = wmess.text_len;
      170 	data_lth = wmess.data_size;
      171 	data_type = wmess.data_code;
      172 	data_class = "";				/* init */
      173 
      174 	if (data_lth > 0) then do;
      175 	     if data_type < 1 | data_type > hbound (SB_char_data_classes, 1)
      176 	     then call ioa_$rsnnl ("syserr^d", data_class, (0), data_type);
      177 	     else data_class = SB_char_data_classes (data_type);
      178 	end;
      179 
      180 	call log_segment_$create_message_number (sys_log_ptr,
      181 	     text_lth, data_lth, data_class, wmess.seq_num, log_message_ptr, code);
      182 
      183 	if (code ^= 0) then do;			/* Failed to create. See why */
      184 	     if (code ^= error_table_$log_segment_full) then /* If not just plain full, fatal error */
      185 		call syserr$error_code (SYSERR_CRASH_SYSTEM, code, "^a: Cannot add message to paged syserr log ^p.", WHOAMI, sys_log_ptr);
      186 
      187 	     return ("0"b);				/* Return failure indicator, and try again */
      188 	end;
      189 
      190 	log_message.severity = wmess.code;		/* Copy the message */
      191 	log_message.time = wmess.time;
      192 	log_message.process_id = wmess.process_id;
      193 	log_message.text = wmess.text;
      194 
      195 	if (data_lth > 0) then do;
      196 	     unspec (addr (log_message.data (1)) -> data_buffer) = unspec (wmess.data);
      197 	end;
      198 
      199 	call log_segment_$finish_message (sys_log_ptr, log_message_ptr, (0));
      200 
      201 	message_offset = wordno (log_message_ptr);	/* See if we have more than enough pages stuck */
      202 	if (message_offset > (1024 * syserr_log_data.copy_threshold)) then
      203 	     must_send_wakeup = "1"b;			/* in ring zero, and notify AS if so */
      204 
      205 	if syserr_log_data.wakeup_on_printable then	/* Console recovery is in action-- send a wakeup */
      206 	     if write_flags (mod (wmess.code, 10)) then	/* if the message should have been printed */
      207 		must_send_wakeup = "1"b;
      208 
      209 	return ("1"b);
      210      end create_syserr_message;
      211 
      212 
      213 swap_logs:
      214      procedure (P_success);
      215 
      216 declare  P_success bit (1) aligned parameter;
      217 
      218 declare  new_log fixed bin;
      219 declare  new_log_ptr pointer;
      220 declare  new_log_size fixed bin (18);
      221 declare  old_log_ptr pointer;
      222 declare  swap_time fixed bin (71);
      223 
      224 
      225 	must_send_wakeup = "1"b;			/* Any time we swap, or try to swap, while copying from */
      226 						/* the wired buffer, we want to send a wakeup to the AS */
      227 
      228 	if (syserr_log_data.swap_time ^= 0) then do;	/* A swap is *already* pending */
      229 	     call syserr (SYSERR_PRINT_WITH_ALARM, "^a: LOG partition full. Further copying temporarily disabled.", WHOAMI);
      230 	     syserr_log_data.copy_disabled = "1"b;
      231 	     P_success = "0"b;
      232 	     return;
      233 	end;
      234 
      235 	new_log = 3 - syserr_log_data.live_log;		/* Then swap: #1 => #2, #2 => #1 */
      236 
      237 	old_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);
      238 	new_log_ptr = syserr_log_data.log_ptr (new_log);
      239 	new_log_size = 1024 * syserr_log_data.log_size (new_log);
      240 
      241 	swap_time = clock ();
      242 	call log_initialize_ (old_log_ptr, new_log_ptr, new_log_size, "", (0));
      243 
      244 	syserr_log_data.live_log = new_log;		/* Once it's initialized, start using it */
      245 	sys_log_ptr = syserr_log_data.log_ptr (new_log);
      246 
      247 	syserr_log_data.swap_time = swap_time;		/* Remember when it happened (stays set until log copied) */
      248 
      249 	syserr_log_data.copy_disabled = "0"b;		/* We have a nice big empty place to put them again */
      250 	syserr_log_data.drop_severity_5 = "0"b;		/* so turn off both the throttles */
      251 
      252 	P_success = "1"b;
      253 	return;
      254 
      255      end swap_logs;
      256 
      257 
      258 lock_paged_log:
      259      procedure ();
      260 
      261 	call lock$lock_fast (addr (syserr_log_data.lock));
      262 
      263 	return;
      264      end lock_paged_log;
      265 
      266 
      267 
      268 unlock_paged_log:
      269      procedure ();
      270 
      271 	call lock$unlock_fast (addr (syserr_log_data.lock));
      272 
      273 	return;
      274      end unlock_paged_log;
      275 
      276 /* format: off */
      277  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  1     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  1     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  1     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  1     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  1     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  1     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  1    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  1    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  1    12 
  1    13 declare 1 log_message         aligned based (log_message_ptr),
  1    14           2 header            aligned like log_message_header,
  1    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  1    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  1    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  1    18 
  1    19 declare   log_message_ptr pointer;
  1    20 declare   log_message_text_lth fixed bin;
  1    21 declare   log_message_data_class_lth fixed bin;
  1    22 declare   log_message_data_lth fixed bin;
  1    23 
  1    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      277 
      278  /* BEGIN INCLUDE FILE ... syserr_log_dcls.incl.pl1 ... 84-08-17 ... W. Olin Sibert */
  2     2 /* Modified 1984-12-10, BIM: changed to a fast lock, added error count. */
  2     3 
  2     4 /* The syserr_log_data segment, made reverse-deciduous in >sl1, overlays the
  2     5*   first page of the LOG partition, and contains control information about
  2     6*   the other syserr_log segments. */
  2     7 
  2     8 declare   syserr_log_data$    fixed bin external static;
  2     9 declare   syserr_log_data_ptr pointer;
  2    10 
  2    11 declare 1 syserr_log_data     aligned based (syserr_log_data_ptr),
  2    12           2 version           char (8) unaligned,           /* SYSERR_LOG_DATA_V1 */
  2    13           2 old_init_word     char (4) unaligned,           /* Overlays slog.head.init_word ("INIT") */
  2    14 	2 pad003    	bit (1) aligned,
  2    15 
  2    16           2 live_log          fixed bin,                    /* Identifier of live log (#1 or #2) */
  2    17 	2 pad001		bit (1) aligned,
  2    18           2 error_count       fixed bin (35),               /* errors copying the log */
  2    19           2 swap_time         fixed bin (71),               /* Time of last log swap; zero if other_log_empty */
  2    20 
  2    21           2 messages_copied   fixed bin (35),               /* A meter */
  2    22           2 messages_lost     fixed bin (35),               /* Messages not copied because logs full */
  2    23 
  2    24           2 log_start (2)     fixed bin,                    /* Offset of each log segment in the partition */
  2    25           2 log_size (2)      fixed bin,                    /* Number of pages in each log segment */
  2    26 
  2    27           2 per_bootload,                                   /* Ramaining structure is reinitialized at each boot */
  2    28             3 log_ptr (2) pointer,                          /* Pointer to the three segments in the partition */
  2    29 
  2    30             3 log_name (2) char (32) unaligned,             /* Current names of log segments (by syserr_seg_manager) */
  2    31             3 log_dir char (168) unaligned,                 /* Parent directory */
  2    32 
  2    33             3 lock		aligned,
  2    34 	    4 pid		bit (36) aligned,             /* Standard format wait lock, used when updating log */
  2    35               4 event_id      fixed bin (35),
  2    36               4 notify_requested 
  2    37 	                    bit (1) unaligned,
  2    38 	    4 pad           bit (35) unaligned,
  2    39             3 take_a_fault    bit (1) aligned,              /* Forces a fault if on, for testing fault recovery */
  2    40             3 test_mode       bit (1) aligned,              /* Running in outer-ring test mode */
  2    41 
  2    42             3 copy_disabled   bit (1) aligned,              /* No more messages being copied into live log */
  2    43             3 drop_severity_5 bit (1) aligned,              /* No more severity 5 messages (log is 3/4 full) */
  2    44 	  3 wakeup_on_printable bit (1) aligned,	/* Console recovery: send wakeup for printable message */
  2    45 
  2    46             3 copy_threshold  fixed bin (18),               /* How often to copy to outer ring log segments */
  2    47             3 copy_channel    fixed bin (71),
  2    48             3 copy_process_id bit (36) aligned,
  2    49 
  2    50           2 pad fixed bin (71);                             /* Anything goes, as long as it's under a page */
  2    51 
  2    52 declare   SYSERR_LOG_DATA_V1 char (8) internal static options (constant) init ("syserr01");
  2    53 
  2    54 /* END INCLUDE FILE ... syserr_log_dcls.incl.p1l */
      278 
      279  /* Begin include file ..... syserr_actions.incl.pl1 */
  3     2 
  3     3 /* Created November 1975 by Larry Johnson */
  3     4 /* These arrays map the action codes into actions syserr must provide. */
  3     5 
  3     6 /* write: Codes for message should be written on operator console */
  3     7 /* alarm: Codes which should sound alram when written */
  3     8 /* crash: Codes which should cause system to crash */
  3     9 /* termp: Codes for which the callers process should be terminated */
  3    10 /* wifnl: Codes for messages which should be written if they can't be logged */
  3    11 
  3    12 dcl  write_flags (0:9) bit (1) unal int static init ("1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    13 dcl  alarm_flags (0:9) bit (1) unal int static init ("0"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    14 dcl  crash_flags (0:9) bit (1) unal int static init ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    15 dcl  termp_flags (0:9) bit (1) unal int static init ("0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    16 dcl  wifnl_flags (0:9) bit (1) unal int static init ("0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    17 
  3    18 /* End include file ..... syserr_actions.incl.pl1 */
      279 
      280  /* BEGIN INCLUDE FILE  syserr_data.incl.pl1 */
  4     2 
  4     3 /* Created by  Bill Silver  on 01/03/73. */
  4     4 /* Modified September 1975 by Larry Johnson to add binary data */
  4     5 /* Modified March 1976 by Steve Webber for use with cds */
  4     6 /* Modified 1985-01-21 by EJ Sharpe: added wmess.process_id */
  4     7 /* Modified 1985-02-18 by Keith Loepere to break out headers. */
  4     8 
  4     9 /* This include file defines the syserr and log areas found in  syserr_data.cds
  4    10*   There is one lock that coordinates the use of all the data found in
  4    11*   syserr_data.cds.  NOTE, if this include file changes, syserr_data.cds
  4    12*   may also have to be changed. */
  4    13 
  4    14 dcl  syserr_data$syserr_area char (1) aligned external,
  4    15      syserr_data$wired_log_area char (1) aligned external;
  4    16 
  4    17 dcl  sd_ptr ptr,					/* Pointer to beginning of syserr_area. */
  4    18      wlog_ptr ptr,					/* Pointer to beginning of wired_log_area. */
  4    19      wmess_ptr ptr;					/* Pointer to a message entry in the wired log. */
  4    20 
  4    21 dcl 1 sd based (sd_ptr) aligned,			/* Overlay of syserr_data$syserr_area. */
  4    22     2 lock bit (36),				/* Locks all the data in syserr_data. */
  4    23     2 log_flag bit (1) unal,				/* ON => logging mechanism enabled. */
  4    24     2 char_type_flag bit (1) unal,			/* ON => ASCII,  OFF => BCD. */
  4    25     2 ocdcm_init_flag bit (1) unal,			/* ON => ocdcm_ has been initialized. */
  4    26     2 pad bit (33) unal,
  4    27     2 prev_text_written char (80);			/* Text of last message written */
  4    28 
  4    29 dcl 1 wlog based (wlog_ptr) aligned,			/* Overlay of syserr_data$wired_log_area. */
  4    30     2 head like wlog_header,				/* Wired log header. */
  4    31     2 buffer (wlog.head.bsize) bit (36);		/* Wired log buffer. */
  4    32 
  4    33 dcl 1 wlog_header based aligned,			/* WIRED LOG HEADER */
  4    34     2 bsize fixed bin,				/* Size of the wired log buffer in words.
  4    35*						   Defined in syserr_data.cds. */
  4    36     2 count fixed bin,				/* Num of message entries in wired log. */
  4    37     2 slog_ptr ptr,					/* Pointer to the paged log segment: syserr_log. */
  4    38     2 seq_num fixed bin (35),				/* Sequence number of last message logged. */
  4    39     2 next bit (18) unal,				/* Offset relative to base syserr_data */
  4    40 						/* Where next entry will go in wired log. */
  4    41     2 pad bit (18) unal;
  4    42 
  4    43 
  4    44 /* This is an overlay of a message entry that goes into the wired log.  Each message
  4    45*   entry corresponds to one syserr message. */
  4    46 
  4    47 dcl 1 wmess based (wmess_ptr) aligned,
  4    48     2 header aligned like wmess_header,
  4    49     2 text char (0 refer (wmess.text_len)),		/* Text of expanded message - kept in ASCII. */
  4    50     2 data (0 refer (wmess.data_size)) bit (36);		/* Binary data area */
  4    51 
  4    52 dcl 1 wmess_header based aligned,
  4    53     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  4    54     2 time fixed bin (71) unal,			/* Time message logged at */
  4    55     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  4    56     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  4    57     2 data_size fixed bin (11) unal,			/* Size of binary data */
  4    58     2 data_code fixed bin (11) unal,			/* Data code */
  4    59     2 pad bit (24) unal,
  4    60     2 process_id bit (36);				/* ID of process which wrote message */
  4    61 
  4    62 /* END INCLUDE FILE syserr_data.incl.pl1 */
      280 
      281  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  5     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  5     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  5     4 
  5     5 /* This include file has an ALM version.  Keep 'em in sync! */
  5     6 
  5     7 dcl (
  5     8 
  5     9 /* The following constants define the message action codes.  This indicates
  5    10*how a message is to be handled.  */
  5    11 
  5    12      SYSERR_CRASH_SYSTEM	init (1),			
  5    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  5    14 
  5    15      SYSERR_TERMINATE_PROCESS	init (2),
  5    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  5    17 
  5    18      SYSERR_PRINT_WITH_ALARM	init (3),
  5    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  5    20 
  5    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  5    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  5    23 
  5    24      SYSERR_LOG_OR_PRINT	init (4),
  5    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  5    26 
  5    27      SYSERR_LOG_OR_DISCARD	init (5),
  5    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  5    29 
  5    30 
  5    31 /* The following constants are added to the normal severities to indicate
  5    32*different sorting classes of messages.  */
  5    33 
  5    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  5    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  5    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  5    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  5    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  5    39 	) fixed bin internal static options (constant);
  5    40 
  5    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      281 
      282  /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  6     2 
  6     3 /* This include file has an ALM version, keep 'em in sync. */
  6     4 
  6     5 /* format: off */
  6     6 
  6     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  6     8*   to be examined by display_cpu_error. */
  6     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  6    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  6    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  6    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  6    13*		also changed some codes to "SB_unused_NN" - see line comments */
  6    14 
  6    15 /* In the future, these will be the only constants needed in this include
  6    16*file.  They are the binary data class strings for messages in the new format
  6    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  6    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  6    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  6    20 
  6    21 dcl (						/* include file name */
  6    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  6    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  6    24 SB_mos_data_class		init ("mos"),		/* scr */
  6    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  6    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  6    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  6    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  6    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  6    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  6    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  6    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  6    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  6    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  6    35 ) static internal char (16) varying options (constant);
  6    36 
  6    37 
  6    38 /************************
  6    39*Once the syserr$binary is replaced with something that takes real data classes
  6    40*and all system modules and tools are upgraded to use the new interface, the
  6    41*rest of this include file may be discarded.
  6    42*************************/
  6    43 
  6    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  6    45*   extended at any time. */
  6    46 
  6    47 dcl (
  6    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  6    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  6    50 SB_io_err		init (3),		SBL_io_err	init (5),
  6    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  6    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  6    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  6    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  6    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  6    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  6    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  6    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  6    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  6    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  6    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  6    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  6    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  6    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  6    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  6    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  6    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  6    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  6    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  6    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  6    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  6    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  6    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  6    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  6    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  6    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  6    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  6    78   ) internal static options (constant) fixed bin;
  6    79 
  6    80 
  6    81 /* The following array is a mapping of the old syserr$binary codes into the
  6    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  6    83*the binary data codes stored in the wired syserr log (see above) into the data
  6    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  6    85*is also used by syserr_log_util_ to translate the data classes back into the
  6    86*corresponding binary code (for tools not yet upgraded to deal with the new
  6    87*format log messages). */
  6    88 
  6    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  6    90 	init (	"io_status",		/* 1 */
  6    91 		"hwfault",		/* 2 */
  6    92 		"io_status",		/* 3 */
  6    93 		"unused_4",		/* 4 */
  6    94 		"mos",			/* 5 */
  6    95 
  6    96 		"unused_6",		/* 6 */
  6    97 		"unused_7",		/* 7 */
  6    98 		"unused_8",		/* 8 */
  6    99 		"unused_9",		/* 9 */ 
  6   100 		"unused_10",		/* 10 */
  6   101 
  6   102 		"segdamage",		/* 11 */
  6   103 		"unused_12",		/* 12 */
  6   104 		"segdamage",		/* 13 */
  6   105 		"unused_14",		/* 14 */
  6   106 		"unused_15",		/* 15 */
  6   107 
  6   108 		"segdamage",		/* 16 */
  6   109 		"voldamage",		/* 17 */
  6   110 		"unused_18",		/* 18 */
  6   111 		"mdc_del_uidpath",		/* 19 */
  6   112 		"io_status",		/* 20 */
  6   113 
  6   114 		"mmdam",			/* 21 */
  6   115 		"hwfault",		/* 22 */
  6   116 		"io_status",		/* 23 */
  6   117 		"mpc_poll",		/* 24 */
  6   118 		"fnp_poll",		/* 25 */
  6   119 
  6   120 		"config_deck",		/* 26 */
  6   121 		"vtoce",			/* 27 */
  6   122 		"access_audit",		/* 28 */
  6   123 		"unused_29",		/* 29 */
  6   124 		"unused_30",		/* 30 */
  6   125 		"unused_31",		/* 31 */
  6   126 		"unused_32",		/* 32 */
  6   127 		"unused_33",		/* 33 */
  6   128 		"unused_34",		/* 34 */
  6   129 		"ibm3270_mde",		/* 35 */
  6   130 		"unused_36"		/* 36 */
  6   131 	);
  6   132 
  6   133 
  6   134 /* format: on */
  6   135 
  6   136 /* These constants are used by various tools which analyze syserr messages and
  6   137*still call the old interface "syserr_log_util_". */
  6   138 
  6   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  6   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  6   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  6   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  6   143 
  6   144      dcl	   display_cpu_error_binary_defs (2) init (
  6   145 			      2,			/** SB_hw_fault */
  6   146 			      22			/** SB_verify_lock */
  6   147 			      ) internal static options (constant) fixed bin;
  6   148 
  6   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      282 
      283 
      284 
      285 /* BEGIN MESSAGE DOCUMENTATION
      286*
      287*   Message:
      288*   syserr_copy: LOG partition mostly full. Severity 5 messages will be lost.
      289*
      290*   S:     $beep
      291*
      292*   T:     $run
      293*
      294*   M:     Both halves of the ring zero syserr log buffer are nearly full. This
      295*generally indicates that the Answering Service is not copying messages from
      296*ring zero into >sc1>syserr_log; there will have been a previous message left in
      297*the Answering Service log describing why.
      298*
      299*   A:     If the problem is correctable, copying from ring zero should
      300*be restarted (see the documentation for "syserr_log_man_: Automatic log
      301*copying disabled" for instructions); otherwise, messages will be lost.
      302*
      303*
      304*   Message:
      305*   syserr_copy: Cannot add message to paged syserr log PTR. ERROR-MESSAGE
      306*
      307*   S:     $crash
      308*
      309*   T:     $run
      310*
      311*   M:     $err
      312*This may indicate that the syserr log partition has been damaged.
      313*If this is the case, the LOG partition should be reinitialized using
      314*the BCE test_disk command. Some messages will be lost if this happens.
      315*
      316*   A:     Re-boot the system. Reinitialize the LOG partition if necessary.
      317*
      318*
      319*   Message:
      320*   syserr_copy: LOG partition full. Further copying temporarily disabled.
      321*
      322*   S:     $crash
      323*
      324*   T:     $run
      325*
      326*   M:     Both halves of the ring zero syserr log buffer are full. This
      327*generally indicates that the Answering Service is not copying messages from
      328*ring zero into >sc1>syserr_log; there will have been a previous message left in
      329*the Answering Service log describing why.
      330*
      331*   A:     If the problem is correctable, copying from ring zero should
      332*be restarted (see the documentation for "syserr_log_man_: Automatic log
      333*copying disabled" for instructions); otherwise, messages will be lost.
      334*
      335*
      336*   END MESSAGE DOCUMENTATION
      337*   */
      338 
      339      end syserr_copy;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1118.3  syserr_copy.pl1                   >udd>sm>ds>w>ml>syserr_copy.pl1
277          1    01/21/85  1012.2  log_message.incl.pl1              >ldd>incl>log_message.incl.pl1
278          2    01/06/85  1522.2  syserr_log_dcls.incl.pl1          >ldd>incl>syserr_log_dcls.incl.pl1
279          3    02/12/76  1602.4  syserr_actions.incl.pl1           >ldd>incl>syserr_actions.incl.pl1
280          4    03/08/85  0952.7  syserr_data.incl.pl1              >ldd>incl>syserr_data.incl.pl1
281          5    05/17/85  0715.7  syserr_constants.incl.pl1         >ldd>incl>syserr_constants.incl.pl1
282          6    03/15/85  1053.1  syserr_binary_def.incl.pl1        >ldd>incl>syserr_binary_def.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_success                              parameter       bit(1)                   dcl 216 set ref 213 231* 252*
P_wlog_ptr                             parameter       pointer                  dcl 34 ref 58 61
SB_char_data_classes            000000 constant        varying char(16)         initial array dcl 6-89 ref 175 177
SYSERR_CRASH_SYSTEM             000312 constant        fixed bin(17,0)          initial dcl 5-7 set ref 184*
SYSERR_PRINT_WITH_ALARM         000277 constant        fixed bin(17,0)          initial dcl 5-7 set ref 138* 229*
WHOAMI                          000265 constant        char(32)                 initial packed unaligned dcl 53 set ref 138* 184*
                                                                                  229*
addr                                                   builtin function         dcl 55 ref 62 78 87 96 123 196 261 261 271 271
addrel                                                 builtin function         dcl 55 ref 145
buffer                    6            based           bit(36)                  array level 2 dcl 4-29 set ref 123
clock                                                  builtin function         dcl 55 ref 241
code                      3            based           fixed bin(11,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 4-47 in procedure "syserr_copy" ref 163 190
                                                                                  205
code                            000102 automatic       fixed bin(35,0)          dcl 37 in procedure "syserr_copy" set ref 180* 183
                                                                                  184 184*
copy_channel            130            based           fixed bin(71,0)          level 3 dcl 2-11 set ref 67 67*
copy_disabled           123            based           bit(1)                   level 3 dcl 2-11 set ref 109 230* 249*
copy_process_id         132            based           bit(36)                  level 3 dcl 2-11 set ref 67*
copy_threshold          126            based           fixed bin(18,0)          level 3 dcl 2-11 ref 202
count                     1            based           fixed bin(17,0)          level 3 dcl 4-29 ref 110 125
currentsize                                            builtin function         dcl 55 ref 145
data                                   based           bit(36)                  array level 2 in structure "wmess" dcl 4-47
                                                                                  in procedure "syserr_copy" ref 196
data                                   based           bit(36)                  array level 2 in structure "log_message" dcl 1-13
                                                                                  in procedure "syserr_copy" set ref 196
data_buffer                            based           bit(36)                  array dcl 159 set ref 196*
data_class                      000137 automatic       varying char(16)         dcl 158 set ref 172* 175* 177* 180*
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 1-13
                                                                                  ref 196
data_code                 4            based           fixed bin(11,0)          level 3 packed packed unaligned dcl 4-47 ref 171
data_lth                        000135 automatic       fixed bin(17,0)          dcl 156 set ref 170* 174 180* 195 196
data_size                 3(24)        based           fixed bin(11,0)          level 3 packed packed unaligned dcl 4-47 ref 145 170
                                                                                  196
data_type                       000136 automatic       fixed bin(17,0)          dcl 157 set ref 171* 175 175 175* 177
drop_severity_5         124            based           bit(1)                   level 3 dcl 2-11 set ref 135 140* 163 250*
drop_threshold                  000122 automatic       fixed bin(18,0)          dcl 104 set ref 115* 135
error_table_$log_segment_full   000010 external static fixed bin(35,0)          dcl 40 ref 184
hbound                                                 builtin function         dcl 55 ref 175
head                                   based           structure                level 2 dcl 4-29
header                                 based           structure                level 2 in structure "log_message" dcl 1-13
                                                                                  in procedure "syserr_copy"
header                                 based           structure                level 2 in structure "wmess" dcl 4-47 in procedure
                                                                                  "syserr_copy"
ioa_$rsnnl                      000012 constant        entry                    external dcl 42 ref 175
live_log                  4            based           fixed bin(17,0)          level 2 dcl 2-11 set ref 114 235 237 244*
lock                    116            based           structure                level 3 dcl 2-11 set ref 261 261 271 271
lock$lock_fast                  000016 constant        entry                    external dcl 44 ref 261
lock$unlock_fast                000014 constant        entry                    external dcl 43 ref 271
log_initialize_                 000020 constant        entry                    external dcl 45 ref 242
log_message                            based           structure                level 1 dcl 1-13
log_message_header                     based           structure                level 1 dcl 1-3
log_message_ptr                 000104 automatic       pointer                  dcl 1-19 set ref 135 180* 190 191 192 193 196 199*
                                                                                  201
log_ptr                  20            based           pointer                  array level 3 dcl 2-11 ref 114 237 238 245
log_segment_$create_message_number
                                000022 constant        entry                    external dcl 46 ref 180
log_segment_$finish_message     000024 constant        entry                    external dcl 48 ref 199
log_size                 16            based           fixed bin(17,0)          array level 2 dcl 2-11 ref 239
message_offset                  000144 automatic       fixed bin(18,0)          dcl 160 set ref 201* 202
messages_copied          12            based           fixed bin(35,0)          level 2 dcl 2-11 set ref 143* 143
messages_lost            13            based           fixed bin(35,0)          level 2 dcl 2-11 set ref 110* 110 165* 165
mod                                                    builtin function         dcl 55 ref 163 205
msg_idx                         000123 automatic       fixed bin(17,0)          dcl 105 set ref 125*
must_send_wakeup                000103 automatic       bit(1)                   dcl 38 set ref 64* 67 202* 205* 225*
new_log                         000154 automatic       fixed bin(17,0)          dcl 218 set ref 235* 238 239 244 245
new_log_ptr                     000156 automatic       pointer                  dcl 219 set ref 238* 242*
new_log_size                    000160 automatic       fixed bin(18,0)          dcl 220 set ref 239* 242*
old_log_ptr                     000162 automatic       pointer                  dcl 221 set ref 237* 242*
per_bootload             20            based           structure                level 2 dcl 2-11
process_id                5            based           bit(36)                  level 3 in structure "wmess" dcl 4-47 in procedure
                                                                                  "syserr_copy" ref 192
process_id                5            based           bit(36)                  level 3 in structure "log_message" dcl 1-13
                                                                                  in procedure "syserr_copy" set ref 192*
pxss$wakeup                     000026 constant        entry                    external dcl 49 ref 67
seq_num                                based           fixed bin(35,0)          level 3 dcl 4-47 set ref 180*
severity                  2            based           fixed bin(8,0)           level 3 packed packed unaligned dcl 1-13 set ref
                                                                                  190*
swap_successful                 000124 automatic       bit(1)                   dcl 106 set ref 127* 128
swap_time                       000164 automatic       fixed bin(71,0)          dcl 222 in procedure "swap_logs" set ref 241* 247
swap_time                10            based           fixed bin(71,0)          level 2 in structure "syserr_log_data" dcl 2-11
                                                                                  in procedure "syserr_copy" set ref 135 228 247*
sys_log_ptr                     000100 automatic       pointer                  dcl 36 set ref 114* 180* 184* 199* 245*
syserr                          000030 constant        entry                    external dcl 50 ref 138 229
syserr$error_code               000032 constant        entry                    external dcl 51 ref 184
syserr_log_data                        based           structure                level 1 dcl 2-11
syserr_log_data$                000034 external static fixed bin(17,0)          dcl 2-8 set ref 62 78 87 96
syserr_log_data_ptr             000106 automatic       pointer                  dcl 2-9 set ref 62* 67 67 67 78* 87* 96* 109 110 110
                                                                                  114 114 135 135 140 143 143 163 165 165 202 205
                                                                                  228 230 235 237 237 238 239 244 245 247 249 250
                                                                                  261 261 271 271
text                      6            based           char                     level 2 in structure "log_message" packed packed
                                                                                  unaligned dcl 1-13 in procedure "syserr_copy" set
                                                                                  ref 193*
text                      6            based           char                     level 2 in structure "wmess" dcl 4-47 in procedure
                                                                                  "syserr_copy" ref 193
text_len                  3(12)        based           fixed bin(11,0)          level 3 packed packed unaligned dcl 4-47 ref 145 169
                                                                                  193 196
text_lth                        000134 automatic       fixed bin(17,0)          dcl 155 in procedure "create_syserr_message" set ref
                                                                                  169* 180*
text_lth                  4            based           fixed bin(17,0)          level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 1-13 in procedure "syserr_copy" ref
                                                                                  193 196
time                      2(18)        based           fixed bin(53,0)          level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 1-13 in procedure "syserr_copy" set
                                                                                  ref 191*
time                      1            based           fixed bin(71,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 4-47 in procedure "syserr_copy" ref 191
unspec                                                 builtin function         dcl 55 set ref 196* 196
wakeup_on_printable     125            based           bit(1)                   level 3 dcl 2-11 ref 205
wlog                                   based           structure                level 1 dcl 4-29
wlog_header                            based           structure                level 1 dcl 4-33
wlog_ptr                        000110 automatic       pointer                  dcl 4-17 set ref 61* 110 123 125
wmess                                  based           structure                level 1 dcl 4-47 set ref 145
wmess_header                           based           structure                level 1 dcl 4-52
wmess_ptr                       000112 automatic       pointer                  dcl 4-17 set ref 123* 145* 145 145 163 169 170 171
                                                                                  180 190 191 192 193 196 205
wordno                                                 builtin function         dcl 55 ref 135 201
write_flags                     000264 constant        bit(1)                   initial array packed unaligned dcl 3-12 ref 205

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 5-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 5-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 5-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 5-7
LOG                                    internal static fixed bin(17,0)          initial dcl 5-7
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 6-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 6-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 6-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 6-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 6-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 6-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 6-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 6-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 6-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 6-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 6-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 6-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 6-21
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 6-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 6-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 6-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 6-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 6-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 6-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 6-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 6-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 6-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 6-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 6-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 6-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 6-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 6-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 6-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 6-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 6-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 6-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 6-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 6-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 6-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 6-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 6-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 6-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 6-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 6-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 6-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 6-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 6-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 6-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 6-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 6-47
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_LOG_DATA_V1                     internal static char(8)                  initial packed unaligned dcl 2-52
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 5-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 5-7
alarm_flags                            internal static bit(1)                   initial array packed unaligned dcl 3-13
crash_flags                            internal static bit(1)                   initial array packed unaligned dcl 3-14
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 6-144
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 1-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 1-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 1-20
sd                                     based           structure                level 1 dcl 4-21
sd_ptr                                 automatic       pointer                  dcl 4-17
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 6-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 6-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 6-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 6-141
syserr_data$syserr_area                external static char(1)                  dcl 4-14
syserr_data$wired_log_area             external static char(1)                  dcl 4-14
termp_flags                            internal static bit(1)                   initial array packed unaligned dcl 3-15
wifnl_flags                            internal static bit(1)                   initial array packed unaligned dcl 3-16

NAMES DECLARED BY EXPLICIT CONTEXT.
copy_messages                   000515 constant        entry                    internal dcl 101 ref 65
create_syserr_message           000657 constant        entry                    internal dcl 152 ref 126 131
lock_paged_log                  001346 constant        entry                    internal dcl 258 ref 88
swap_logs                       001214 constant        entry                    internal dcl 213 ref 79 127
syserr_copy                     000375 constant        entry                    external dcl 11
syserr_copy$lock                000470 constant        entry                    external dcl 84
syserr_copy$swap_logs           000452 constant        entry                    external dcl 75
syserr_copy$unlock              000503 constant        entry                    external dcl 93
syserr_copy$wired_log           000406 constant        entry                    external dcl 58
unlock_paged_log                001362 constant        entry                    internal dcl 268 ref 97

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1652        1710    1413        1662
Length      2224    1413        36         277     237           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
syserr_copy                         290 external procedure  is an external procedure.  
copy_messages                           internal procedure  shares stack frame of external procedure syserr_copy.  
create_syserr_message                   internal procedure  shares stack frame of external procedure syserr_copy.  
swap_logs                               internal procedure  shares stack frame of external procedure syserr_copy.  
lock_paged_log                          internal procedure  shares stack frame of external procedure syserr_copy.  
unlock_paged_log                        internal procedure  shares stack frame of external procedure syserr_copy.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
syserr_copy              000100 sys_log_ptr                 syserr_copy
                         000102 code                        syserr_copy
                         000103 must_send_wakeup            syserr_copy
                         000104 log_message_ptr             syserr_copy
                         000106 syserr_log_data_ptr         syserr_copy
                         000110 wlog_ptr                    syserr_copy
                         000112 wmess_ptr                   syserr_copy
                         000122 drop_threshold              copy_messages
                         000123 msg_idx                     copy_messages
                         000124 swap_successful             copy_messages
                         000134 text_lth                    create_syserr_message
                         000135 data_lth                    create_syserr_message
                         000136 data_type                   create_syserr_message
                         000137 data_class                  create_syserr_message
                         000144 message_offset              create_syserr_message
                         000154 new_log                     swap_logs
                         000156 new_log_ptr                 swap_logs
                         000160 new_log_size                swap_logs
                         000162 old_log_ptr                 swap_logs
                         000164 swap_time                   swap_logs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rsnnl                    lock$lock_fast                lock$unlock_fast              log_initialize_
log_segment_$create_message_number                          log_segment_$finish_message   pxss$wakeup
syserr                        syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$log_segment_full syserr_log_data$


CONSTANTS
001376  aa     000002000000
001377  aa     000000000000
001400  aa     600000000041
001401  aa     000124000000

001402  aa     000002000000
001403  aa     000000000000
001404  aa     600000000041
001405  aa     000220000000

001406  aa     000002000000
001407  aa     000000000000
001410  aa     600000000041
001411  aa     000204000000

000000  aa     000000000011
000001  aa  151 157 137 163	io_s
000002  aa  164 141 164 165	tatu
000003  aa  163 040 040 040	s   
000004  aa  040 040 040 040	    
000005  aa     000000000007
000006  aa  150 167 146 141	hwfa
000007  aa  165 154 164 040	ult 
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    
000012  aa     000000000011
000013  aa  151 157 137 163	io_s
000014  aa  164 141 164 165	tatu
000015  aa  163 040 040 040	s   
000016  aa  040 040 040 040	    
000017  aa     000000000010
000020  aa  165 156 165 163	unus
000021  aa  145 144 137 064	ed_4
000022  aa  040 040 040 040	    
000023  aa  040 040 040 040	    
000024  aa     000000000003
000025  aa  155 157 163 040	mos 
000026  aa  040 040 040 040	    
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa     000000000010
000032  aa  165 156 165 163	unus
000033  aa  145 144 137 066	ed_6
000034  aa  040 040 040 040	    
000035  aa  040 040 040 040	    
000036  aa     000000000010
000037  aa  165 156 165 163	unus
000040  aa  145 144 137 067	ed_7
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa     000000000010
000044  aa  165 156 165 163	unus
000045  aa  145 144 137 070	ed_8
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa     000000000010
000051  aa  165 156 165 163	unus
000052  aa  145 144 137 071	ed_9
000053  aa  040 040 040 040	    
000054  aa  040 040 040 040	    
000055  aa     000000000011
000056  aa  165 156 165 163	unus
000057  aa  145 144 137 061	ed_1
000060  aa  060 040 040 040	0   
000061  aa  040 040 040 040	    
000062  aa     000000000011
000063  aa  163 145 147 144	segd
000064  aa  141 155 141 147	amag
000065  aa  145 040 040 040	e   
000066  aa  040 040 040 040	    
000067  aa     000000000011
000070  aa  165 156 165 163	unus
000071  aa  145 144 137 061	ed_1
000072  aa  062 040 040 040	2   
000073  aa  040 040 040 040	    
000074  aa     000000000011
000075  aa  163 145 147 144	segd
000076  aa  141 155 141 147	amag
000077  aa  145 040 040 040	e   
000100  aa  040 040 040 040	    
000101  aa     000000000011
000102  aa  165 156 165 163	unus
000103  aa  145 144 137 061	ed_1
000104  aa  064 040 040 040	4   
000105  aa  040 040 040 040	    
000106  aa     000000000011
000107  aa  165 156 165 163	unus
000110  aa  145 144 137 061	ed_1
000111  aa  065 040 040 040	5   
000112  aa  040 040 040 040	    
000113  aa     000000000011
000114  aa  163 145 147 144	segd
000115  aa  141 155 141 147	amag
000116  aa  145 040 040 040	e   
000117  aa  040 040 040 040	    
000120  aa     000000000011
000121  aa  166 157 154 144	vold
000122  aa  141 155 141 147	amag
000123  aa  145 040 040 040	e   
000124  aa  040 040 040 040	    
000125  aa     000000000011
000126  aa  165 156 165 163	unus
000127  aa  145 144 137 061	ed_1
000130  aa  070 040 040 040	8   
000131  aa  040 040 040 040	    
000132  aa     000000000017
000133  aa  155 144 143 137	mdc_
000134  aa  144 145 154 137	del_
000135  aa  165 151 144 160	uidp
000136  aa  141 164 150 040	ath 
000137  aa     000000000011
000140  aa  151 157 137 163	io_s
000141  aa  164 141 164 165	tatu
000142  aa  163 040 040 040	s   
000143  aa  040 040 040 040	    
000144  aa     000000000005
000145  aa  155 155 144 141	mmda
000146  aa  155 040 040 040	m   
000147  aa  040 040 040 040	    
000150  aa  040 040 040 040	    
000151  aa     000000000007
000152  aa  150 167 146 141	hwfa
000153  aa  165 154 164 040	ult 
000154  aa  040 040 040 040	    
000155  aa  040 040 040 040	    
000156  aa     000000000011
000157  aa  151 157 137 163	io_s
000160  aa  164 141 164 165	tatu
000161  aa  163 040 040 040	s   
000162  aa  040 040 040 040	    
000163  aa     000000000010
000164  aa  155 160 143 137	mpc_
000165  aa  160 157 154 154	poll
000166  aa  040 040 040 040	    
000167  aa  040 040 040 040	    
000170  aa     000000000010
000171  aa  146 156 160 137	fnp_
000172  aa  160 157 154 154	poll
000173  aa  040 040 040 040	    
000174  aa  040 040 040 040	    
000175  aa     000000000013
000176  aa  143 157 156 146	conf
000177  aa  151 147 137 144	ig_d
000200  aa  145 143 153 040	eck 
000201  aa  040 040 040 040	    
000202  aa     000000000005
000203  aa  166 164 157 143	vtoc
000204  aa  145 040 040 040	e   
000205  aa  040 040 040 040	    
000206  aa  040 040 040 040	    
000207  aa     000000000014
000210  aa  141 143 143 145	acce
000211  aa  163 163 137 141	ss_a
000212  aa  165 144 151 164	udit
000213  aa  040 040 040 040	    
000214  aa     000000000011
000215  aa  165 156 165 163	unus
000216  aa  145 144 137 062	ed_2
000217  aa  071 040 040 040	9   
000220  aa  040 040 040 040	    
000221  aa     000000000011
000222  aa  165 156 165 163	unus
000223  aa  145 144 137 063	ed_3
000224  aa  060 040 040 040	0   
000225  aa  040 040 040 040	    
000226  aa     000000000011
000227  aa  165 156 165 163	unus
000230  aa  145 144 137 063	ed_3
000231  aa  061 040 040 040	1   
000232  aa  040 040 040 040	    
000233  aa     000000000011
000234  aa  165 156 165 163	unus
000235  aa  145 144 137 063	ed_3
000236  aa  062 040 040 040	2   
000237  aa  040 040 040 040	    
000240  aa     000000000011
000241  aa  165 156 165 163	unus
000242  aa  145 144 137 063	ed_3
000243  aa  063 040 040 040	3   
000244  aa  040 040 040 040	    
000245  aa     000000000011
000246  aa  165 156 165 163	unus
000247  aa  145 144 137 063	ed_3
000250  aa  064 040 040 040	4   
000251  aa  040 040 040 040	    
000252  aa     000000000013
000253  aa  151 142 155 063	ibm3
000254  aa  062 067 060 137	270_
000255  aa  155 144 145 040	mde 
000256  aa  040 040 040 040	    
000257  aa     000000000011
000260  aa  165 156 165 163	unus
000261  aa  145 144 137 063	ed_3
000262  aa  066 040 040 040	6   
000263  aa  040 040 040 040	    

000264  aa     740000000000

000265  aa  163 171 163 145	syse
000266  aa  162 162 137 143	rr_c
000267  aa  157 160 171 040	opy 
000270  aa  040 040 040 040	    
000271  aa  040 040 040 040	    
000272  aa  040 040 040 040	    
000273  aa  040 040 040 040	    
000274  aa  040 040 040 040	    

000275  aa     524000000000

000276  aa     404000000022

000277  aa     000000000003

000300  aa     524000000075

000301  aa     524000000056

000302  aa     404000000043

000303  aa     404000000005

000304  aa     530000000020

000305  aa     524000000010

001412  aa     000000000012

000306  aa     526000000040

000307  aa     524000000100

000310  aa     404000000021

000311  aa     514000000001

000312  aa     000000000001

000313  aa     464000000000

000314  aa  163 171 163 145	syse
000315  aa  162 162 136 144	rr^d

000316  aa     777777777777
000317  aa     777777777777

000320  aa  136 141 072 040	^a: 
000321  aa  103 141 156 156	Cann
000322  aa  157 164 040 141	ot a
000323  aa  144 144 040 155	dd m
000324  aa  145 163 163 141	essa
000325  aa  147 145 040 164	ge t
000326  aa  157 040 160 141	o pa
000327  aa  147 145 144 040	ged 
000330  aa  163 171 163 145	syse
000331  aa  162 162 040 154	rr l
000332  aa  157 147 040 136	og ^
000333  aa  160 056 000 000	p.

000334  aa  136 141 072 040	^a: 
000335  aa  114 117 107 040	LOG 
000336  aa  160 141 162 164	part
000337  aa  151 164 151 157	itio
000340  aa  156 040 146 165	n fu
000341  aa  154 154 056 040	ll. 
000342  aa  106 165 162 164	Furt
000343  aa  150 145 162 040	her 
000344  aa  143 157 160 171	copy
000345  aa  151 156 147 040	ing 
000346  aa  164 145 155 160	temp
000347  aa  157 162 141 162	orar
000350  aa  151 154 171 040	ily 
000351  aa  144 151 163 141	disa
000352  aa  142 154 145 144	bled
000353  aa  056 000 000 000	.

000354  aa  136 141 072 040	^a: 
000355  aa  114 117 107 040	LOG 
000356  aa  160 141 162 164	part
000357  aa  151 164 151 157	itio
000360  aa  156 040 155 157	n mo
000361  aa  163 164 154 171	stly
000362  aa  040 146 165 154	 ful
000363  aa  154 056 040 123	l. S
000364  aa  145 166 145 162	ever
000365  aa  151 164 171 040	ity 
000366  aa  065 040 155 145	5 me
000367  aa  163 163 141 147	ssag
000370  aa  145 163 040 167	es w
000371  aa  151 154 154 040	ill 
000372  aa  142 145 040 154	be l
000373  aa  157 163 164 056	ost.

BEGIN PROCEDURE syserr_copy
ENTRY TO syserr_copy                                        STATEMENT 1 ON LINE 11
syserr_copy:
     procedure ();

000374  da     000145200000
000375  aa   000460 6270 00	eax7 	304
000376  aa  7 00034 3521 20	epp2 	pr7|28,*
000377  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000400  aa     000000000000
000401  aa     000000000000
						STATEMENT 1 ON LINE 58
syserr_copy$wired_log:				/* Called ONLY by syserr_logger_daemon */
     entry (P_wlog_ptr);

000402  aa   000011 7100 04	tra  	9,ic		000413
ENTRY TO syserr_copy$wired_log                              STATEMENT 1 ON LINE 58
syserr_copy$wired_log:				/* Called ONLY by syserr_logger_daemon */
     entry (P_wlog_ptr);

000403  at     000001000313
000404  ta     000403000000
000405  da     000164300000
000406  aa   000460 6270 00	eax7 	304
000407  aa  7 00034 3521 20	epp2 	pr7|28,*
000410  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000411  aa     000002000000
000412  aa     000000000000
						STATEMENT 1 ON LINE 61
	wlog_ptr = P_wlog_ptr;

000413  aa  6 00032 3735 20	epp7 	pr6|26,*
000414  aa  7 00002 3715 20	epp5 	pr7|2,*		P_wlog_ptr
000415  aa  5 00000 3715 20	epp5 	pr5|0,*		P_wlog_ptr
000416  aa  6 00110 6515 00	spri5	pr6|72		wlog_ptr
						STATEMENT 1 ON LINE 62
	syserr_log_data_ptr = addr (syserr_log_data$);

000417  la  4 00034 3535 20	epp3 	pr4|28,*		syserr_log_data$
000420  aa  6 00106 2535 00	spri3	pr6|70		syserr_log_data_ptr
						STATEMENT 1 ON LINE 64
	must_send_wakeup = "0"b;

000421  aa  6 00103 4501 00	stz  	pr6|67		must_send_wakeup
						STATEMENT 1 ON LINE 65
	call copy_messages ();

000422  aa   000073 6700 04	tsp4 	59,ic		000515
						STATEMENT 1 ON LINE 67
	if must_send_wakeup then
	     if (syserr_log_data.copy_channel ^= 0) then
		call pxss$wakeup (syserr_log_data.copy_process_id, syserr_log_data.copy_channel, -1, (0));

000423  aa  6 00103 2351 00	lda  	pr6|67		must_send_wakeup
000424  aa   000024 6000 04	tze  	20,ic		000450
000425  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
000426  aa  7 00130 2371 00	ldaq 	pr7|88		syserr_log_data.copy_channel
000427  aa   000021 6000 04	tze  	17,ic		000450
000430  aa   777666 2370 04	ldaq 	-74,ic		000316 = 777777777777 777777777777
000431  aa  6 00202 7571 00	staq 	pr6|130
000432  aa  6 00204 4501 00	stz  	pr6|132
000433  aa  7 00132 3521 00	epp2 	pr7|90		syserr_log_data.copy_process_id
000434  aa  6 00210 2521 00	spri2	pr6|136
000435  aa  7 00130 3521 00	epp2 	pr7|88		syserr_log_data.copy_channel
000436  aa  6 00212 2521 00	spri2	pr6|138
000437  aa  6 00202 3521 00	epp2 	pr6|130
000440  aa  6 00214 2521 00	spri2	pr6|140
000441  aa  6 00204 3521 00	epp2 	pr6|132
000442  aa  6 00216 2521 00	spri2	pr6|142
000443  aa  6 00206 6211 00	eax1 	pr6|134
000444  aa   020000 4310 07	fld  	8192,dl
000445  aa  6 00044 3701 20	epp4 	pr6|36,*
000446  la  4 00026 3521 20	epp2 	pr4|22,*		pxss$wakeup
000447  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 71
	return;

000450  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO syserr_copy$swap_logs                              STATEMENT 1 ON LINE 75
syserr_copy$swap_logs:				/* called from syserr_seg_manager to perform */
     entry ();

000451  da     000203200000
000452  aa   000460 6270 00	eax7 	304
000453  aa  7 00034 3521 20	epp2 	pr7|28,*
000454  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000455  aa     000000000000
000456  aa     000000000000
						STATEMENT 1 ON LINE 78
	syserr_log_data_ptr = addr (syserr_log_data$);

000457  aa  6 00044 3701 20	epp4 	pr6|36,*
000460  la  4 00034 3735 20	epp7 	pr4|28,*		syserr_log_data$
000461  aa  6 00106 6535 00	spri7	pr6|70		syserr_log_data_ptr
						STATEMENT 1 ON LINE 79
	call swap_logs (("0"b));

000462  aa   000000 2350 07	lda  	0,dl
000463  aa  6 00204 7551 00	sta  	pr6|132
000464  aa   000722 3520 04	epp2 	466,ic		001406 = 000002000000
000465  aa   000527 6700 04	tsp4 	343,ic		001214
						STATEMENT 1 ON LINE 80
	return;

000466  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO syserr_copy$lock                                   STATEMENT 1 ON LINE 84
syserr_copy$lock:					/* Utility entrypoints for the rest of ring */
     entry ();

000467  da     000216200000
000470  aa   000460 6270 00	eax7 	304
000471  aa  7 00034 3521 20	epp2 	pr7|28,*
000472  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000473  aa     000000000000
000474  aa     000000000000
						STATEMENT 1 ON LINE 87
	syserr_log_data_ptr = addr (syserr_log_data$);

000475  aa  6 00044 3701 20	epp4 	pr6|36,*
000476  la  4 00034 3735 20	epp7 	pr4|28,*		syserr_log_data$
000477  aa  6 00106 6535 00	spri7	pr6|70		syserr_log_data_ptr
						STATEMENT 1 ON LINE 88
	call lock_paged_log ();

000500  aa   000646 6700 04	tsp4 	422,ic		001346
						STATEMENT 1 ON LINE 89
	return;

000501  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO syserr_copy$unlock                                 STATEMENT 1 ON LINE 93
syserr_copy$unlock:
     entry ();

000502  da     000233200000
000503  aa   000460 6270 00	eax7 	304
000504  aa  7 00034 3521 20	epp2 	pr7|28,*
000505  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000506  aa     000000000000
000507  aa     000000000000
						STATEMENT 1 ON LINE 96
	syserr_log_data_ptr = addr (syserr_log_data$);

000510  aa  6 00044 3701 20	epp4 	pr6|36,*
000511  la  4 00034 3735 20	epp7 	pr4|28,*		syserr_log_data$
000512  aa  6 00106 6535 00	spri7	pr6|70		syserr_log_data_ptr
						STATEMENT 1 ON LINE 97
	call unlock_paged_log ();

000513  aa   000647 6700 04	tsp4 	423,ic		001362
						STATEMENT 1 ON LINE 98
	return;

000514  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 339
     end syserr_copy;

BEGIN PROCEDURE copy_messages
ENTRY TO copy_messages                                      STATEMENT 1 ON LINE 101
copy_messages:
     procedure ();

000515  aa  6 00114 6501 00	spri4	pr6|76
						STATEMENT 1 ON LINE 109
	if syserr_log_data.copy_disabled then do;

000516  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
000517  aa  7 00123 2351 00	lda  	pr7|83		syserr_log_data.copy_disabled
000520  aa   000007 6000 04	tze  	7,ic		000527
						STATEMENT 1 ON LINE 110
	     syserr_log_data.messages_lost = syserr_log_data.messages_lost + wlog.head.count;

000521  aa  7 00013 2351 00	lda  	pr7|11		syserr_log_data.messages_lost
000522  aa   000044 7330 00	lrs  	36
000523  aa  6 00110 3715 20	epp5 	pr6|72,*		wlog_ptr
000524  aa  5 00001 0331 00	adl  	pr5|1		wlog.count
000525  aa  7 00013 7561 00	stq  	pr7|11		syserr_log_data.messages_lost
						STATEMENT 1 ON LINE 111
	     return;

000526  aa  6 00114 6101 00	rtcd 	pr6|76
						STATEMENT 1 ON LINE 112
	end;

						STATEMENT 1 ON LINE 114
	sys_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);

000527  aa  7 00004 2361 00	ldq  	pr7|4		syserr_log_data.live_log
000530  aa   000001 7360 00	qls  	1
000531  aa  7 00016 3715 26	epp5 	pr7|14,ql*	syserr_log_data.log_ptr
000532  aa  6 00100 6515 00	spri5	pr6|64		sys_log_ptr
						STATEMENT 1 ON LINE 115
	drop_threshold = 1024 * 10;

000533  aa   024000 2360 07	ldq  	10240,dl
000534  aa  6 00122 7561 00	stq  	pr6|82		drop_threshold
						STATEMENT 1 ON LINE 123
	wmess_ptr = addr (wlog.buffer);

000535  aa  6 00110 3535 20	epp3 	pr6|72,*		wlog_ptr
000536  aa  3 00006 3535 00	epp3 	pr3|6		wlog.buffer
000537  aa  6 00112 2535 00	spri3	pr6|74		wmess_ptr
						STATEMENT 1 ON LINE 125
	do msg_idx = 1 to wlog.head.count;

000540  aa  6 00110 3515 20	epp1 	pr6|72,*		wlog_ptr
000541  aa  1 00001 2361 00	ldq  	pr1|1		wlog.count
000542  aa  6 00125 7561 00	stq  	pr6|85
000543  aa   000001 2360 07	ldq  	1,dl
000544  aa  6 00123 7561 00	stq  	pr6|83		msg_idx
000545  aa   000000 0110 03	nop  	0,du
000546  aa  6 00123 2361 00	ldq  	pr6|83		msg_idx
000547  aa  6 00125 1161 00	cmpq 	pr6|85
000550  aa   000106 6054 04	tpnz 	70,ic		000656
						STATEMENT 1 ON LINE 126
	     if (^create_syserr_message ()) then do;

000551  aa   000631 3520 04	epp2 	409,ic		001402 = 000002000000
000552  aa   000105 6700 04	tsp4 	69,ic		000657
000553  aa  6 00220 2351 00	lda  	pr6|144
000554  aa   400000 3150 03	cana 	131072,du
000555  aa   000015 6010 04	tnz  	13,ic		000572
						STATEMENT 1 ON LINE 127
		call swap_logs (swap_successful);

000556  aa   000620 3520 04	epp2 	400,ic		001376 = 000002000000
000557  aa   000435 6700 04	tsp4 	285,ic		001214
						STATEMENT 1 ON LINE 128
		if ^swap_successful then
		     return;

000560  aa  6 00124 2351 00	lda  	pr6|84		swap_successful
000561  aa   400000 3150 03	cana 	131072,du
000562  aa   000002 6010 04	tnz  	2,ic		000564
000563  aa  6 00114 6101 00	rtcd 	pr6|76
						STATEMENT 1 ON LINE 131
		if (^create_syserr_message ()) then	/* And, if the new empty log won't do, either, give up */
		     return;

000564  aa   000616 3520 04	epp2 	398,ic		001402 = 000002000000
000565  aa   000072 6700 04	tsp4 	58,ic		000657
000566  aa  6 00220 2351 00	lda  	pr6|144
000567  aa   400000 3150 03	cana 	131072,du
000570  aa   000002 6010 04	tnz  	2,ic		000572
000571  aa  6 00114 6101 00	rtcd 	pr6|76
						STATEMENT 1 ON LINE 133
	     end;

						STATEMENT 1 ON LINE 135
	     if (syserr_log_data.swap_time ^= 0) then	/* Check to see whether we should give up severity 5 */
		if ^syserr_log_data.drop_severity_5 then/* and be sure we haven't made the decision yet */
		     if (wordno (log_message_ptr) > drop_threshold) then do;

000572  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
000573  aa  7 00010 2371 00	ldaq 	pr7|8		syserr_log_data.swap_time
000574  aa   000036 6000 04	tze  	30,ic		000632
000575  aa  7 00124 2351 00	lda  	pr7|84		syserr_log_data.drop_severity_5
000576  aa   000034 6010 04	tnz  	28,ic		000632
000577  aa  6 00104 6361 20	eaq  	pr6|68,*		log_message_ptr
000600  aa   000022 7720 00	qrl  	18
000601  aa  6 00122 1161 00	cmpq 	pr6|82		drop_threshold
000602  aa   000030 6044 04	tmoz 	24,ic		000632
						STATEMENT 1 ON LINE 138
			call syserr (SYSERR_PRINT_WITH_ALARM,
			     "^a: LOG partition mostly full. Severity 5 messages will be lost.", WHOAMI);

000603  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000604  aa   777551 00 0100	desc9a	-151,64		000354 = 136141072040
000605  aa  6 00222 00 0100	desc9a	pr6|146,64
000606  aa   777471 3520 04	epp2 	-199,ic		000277 = 000000000003
000607  aa  6 00244 2521 00	spri2	pr6|164
000610  aa  6 00222 3521 00	epp2 	pr6|146
000611  aa  6 00246 2521 00	spri2	pr6|166
000612  aa   777453 3520 04	epp2 	-213,ic		000265 = 163171163145
000613  aa  6 00250 2521 00	spri2	pr6|168
000614  aa   777474 3520 04	epp2 	-196,ic		000310 = 404000000021
000615  aa  6 00252 2521 00	spri2	pr6|170
000616  aa   777471 3520 04	epp2 	-199,ic		000307 = 524000000100
000617  aa  6 00254 2521 00	spri2	pr6|172
000620  aa   777466 3520 04	epp2 	-202,ic		000306 = 526000000040
000621  aa  6 00256 2521 00	spri2	pr6|174
000622  aa  6 00242 6211 00	eax1 	pr6|162
000623  aa   014000 4310 07	fld  	6144,dl
000624  aa  6 00044 3701 20	epp4 	pr6|36,*
000625  la  4 00030 3521 20	epp2 	pr4|24,*		syserr
000626  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 140
			syserr_log_data.drop_severity_5 = "1"b;

000627  aa   400000 2350 03	lda  	131072,du
000630  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
000631  aa  7 00124 7551 00	sta  	pr7|84		syserr_log_data.drop_severity_5
						STATEMENT 1 ON LINE 141
		     end;

						STATEMENT 1 ON LINE 143
	     syserr_log_data.messages_copied = syserr_log_data.messages_copied + 1;

000632  aa  7 00012 2351 00	lda  	pr7|10		syserr_log_data.messages_copied
000633  aa   000044 7330 00	lrs  	36
000634  aa   000001 0330 07	adl  	1,dl
000635  aa  7 00012 7561 00	stq  	pr7|10		syserr_log_data.messages_copied
						STATEMENT 1 ON LINE 145
	     wmess_ptr = addrel (wmess_ptr, currentsize (wmess));

000636  aa  6 00112 3715 20	epp5 	pr6|74,*		wmess_ptr
000637  aa  5 00003 2351 00	lda  	pr5|3		wmess.data_size
000640  aa   000030 7350 00	als  	24
000641  aa   000074 7330 00	lrs  	60
000642  aa  6 00221 7561 00	stq  	pr6|145		wmess.data_size
000643  aa  5 00003 2351 00	lda  	pr5|3		wmess.text_len
000644  aa   000014 7350 00	als  	12
000645  aa   000074 7330 00	lrs  	60
000646  aa   000003 0760 07	adq  	3,dl
000647  aa   000002 7320 00	qrs  	2
000650  aa   000006 0760 07	adq  	6,dl
000651  aa  6 00221 0761 00	adq  	pr6|145		wmess.data_size
000652  aa  5 00000 5075 06	awd  	pr5|0,ql
000653  aa  6 00112 6515 00	spri5	pr6|74		wmess_ptr
						STATEMENT 1 ON LINE 146
	end;

000654  aa  6 00123 0541 00	aos  	pr6|83		msg_idx
000655  aa   777671 7100 04	tra  	-71,ic		000546
						STATEMENT 1 ON LINE 148
	return;

000656  aa  6 00114 6101 00	rtcd 	pr6|76
						STATEMENT 1 ON LINE 149
     end copy_messages;

  END PROCEDURE copy_messages
BEGIN PROCEDURE create_syserr_message
ENTRY TO create_syserr_message                              STATEMENT 1 ON LINE 152
create_syserr_message:
     procedure () returns (bit (1) aligned);

000657  aa  6 00126 6501 00	spri4	pr6|86
000660  aa  6 00130 2521 00	spri2	pr6|88
						STATEMENT 1 ON LINE 163
	if syserr_log_data.drop_severity_5 then		/* Are we to give up this one? */
	     if (mod (wmess.code, 10) = 5) then do;

000661  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
000662  aa  7 00124 2351 00	lda  	pr7|84		syserr_log_data.drop_severity_5
000663  aa   000020 6000 04	tze  	16,ic		000703
000664  aa  6 00112 3715 20	epp5 	pr6|74,*		wmess_ptr
000665  aa  5 00003 2351 00	lda  	pr5|3		wmess.code
000666  aa   000074 7330 00	lrs  	60
000667  aa   000523 3520 04	epp2 	339,ic		001412 = 000000000012
000670  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
000671  aa   000005 1160 07	cmpq 	5,dl
000672  aa   000011 6010 04	tnz  	9,ic		000703
						STATEMENT 1 ON LINE 165
		syserr_log_data.messages_lost = syserr_log_data.messages_lost + 1;

000673  aa  7 00013 2351 00	lda  	pr7|11		syserr_log_data.messages_lost
000674  aa   000044 7330 00	lrs  	36
000675  aa   000001 0330 07	adl  	1,dl
000676  aa  7 00013 7561 00	stq  	pr7|11		syserr_log_data.messages_lost
						STATEMENT 1 ON LINE 166
		return ("1"b);

000677  aa   400000 2350 03	lda  	131072,du
000700  aa  6 00130 3535 20	epp3 	pr6|88,*
000701  aa  3 00002 7551 20	sta  	pr3|2,*
000702  aa  6 00126 6101 00	rtcd 	pr6|86
						STATEMENT 1 ON LINE 167
	     end;

						STATEMENT 1 ON LINE 169
	text_lth = wmess.text_len;

000703  aa  6 00112 3715 20	epp5 	pr6|74,*		wmess_ptr
000704  aa  5 00003 2351 00	lda  	pr5|3		wmess.text_len
000705  aa   000014 7350 00	als  	12
000706  aa   000074 7330 00	lrs  	60
000707  aa  6 00134 7561 00	stq  	pr6|92		text_lth
						STATEMENT 1 ON LINE 170
	data_lth = wmess.data_size;

000710  aa  5 00003 2351 00	lda  	pr5|3		wmess.data_size
000711  aa   000030 7350 00	als  	24
000712  aa   000074 7330 00	lrs  	60
000713  aa  6 00135 7561 00	stq  	pr6|93		data_lth
						STATEMENT 1 ON LINE 171
	data_type = wmess.data_code;

000714  aa  5 00004 2351 00	lda  	pr5|4		wmess.data_code
000715  aa   000074 7330 00	lrs  	60
000716  aa  6 00136 7561 00	stq  	pr6|94		data_type
						STATEMENT 1 ON LINE 172
	data_class = "";

000717  aa  6 00137 4501 00	stz  	pr6|95		data_class
						STATEMENT 1 ON LINE 174
	if (data_lth > 0) then do;

000720  aa  6 00135 2361 00	ldq  	pr6|93		data_lth
000721  aa   000047 6044 04	tmoz 	39,ic		000770
						STATEMENT 1 ON LINE 175
	     if data_type < 1 | data_type > hbound (SB_char_data_classes, 1)
	     then call ioa_$rsnnl ("syserr^d", data_class, (0), data_type);

000722  aa  6 00136 2361 00	ldq  	pr6|94		data_type
000723  aa   000001 1160 07	cmpq 	1,dl
000724  aa   000003 6040 04	tmi  	3,ic		000727
000725  aa   000044 1160 07	cmpq 	36,dl
000726  aa   000032 6044 04	tmoz 	26,ic		000760
000727  aa   777365 2370 04	ldaq 	-267,ic		000314 = 163171163145 162162136144
000730  aa  6 00260 7571 00	staq 	pr6|176
000731  aa  6 00262 4501 00	stz  	pr6|178
000732  aa  6 00260 3521 00	epp2 	pr6|176
000733  aa  6 00266 2521 00	spri2	pr6|182
000734  aa  6 00140 3521 00	epp2 	pr6|96		data_class
000735  aa  6 00270 2521 00	spri2	pr6|184
000736  aa  6 00262 3521 00	epp2 	pr6|178
000737  aa  6 00272 2521 00	spri2	pr6|186
000740  aa  6 00136 3521 00	epp2 	pr6|94		data_type
000741  aa  6 00274 2521 00	spri2	pr6|188
000742  aa   777343 3520 04	epp2 	-285,ic		000305 = 524000000010
000743  aa  6 00276 2521 00	spri2	pr6|190
000744  aa   777340 3520 04	epp2 	-288,ic		000304 = 530000000020
000745  aa  6 00300 2521 00	spri2	pr6|192
000746  aa   777335 3520 04	epp2 	-291,ic		000303 = 404000000005
000747  aa  6 00302 2521 00	spri2	pr6|194
000750  aa   777340 3520 04	epp2 	-288,ic		000310 = 404000000021
000751  aa  6 00304 2521 00	spri2	pr6|196
000752  aa  6 00264 6211 00	eax1 	pr6|180
000753  aa   020000 4310 07	fld  	8192,dl
000754  aa  6 00044 3701 20	epp4 	pr6|36,*
000755  la  4 00012 3521 20	epp2 	pr4|10,*		ioa_$rsnnl
000756  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000757  aa   000011 7100 04	tra  	9,ic		000770
						STATEMENT 1 ON LINE 177
	     else data_class = SB_char_data_classes (data_type);

000760  aa   000005 4020 07	mpy  	5,dl
000761  aa   000000 6270 06	eax7 	0,ql
000762  ta   777773 2360 06	ldq  	-5,ql
000763  ta   777774 3534 17	epp3 	-4,7
000764  aa  6 00137 7561 00	stq  	pr6|95		data_class
000765  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000766  aa  3 00000 00 0006	desc9a	pr3|0,ql		SB_char_data_classes
000767  aa  6 00140 00 0006	desc9a	pr6|96,ql		data_class
						STATEMENT 1 ON LINE 178
	end;

						STATEMENT 1 ON LINE 180
	call log_segment_$create_message_number (sys_log_ptr,
	     text_lth, data_lth, data_class, wmess.seq_num, log_message_ptr, code);

000770  aa  6 00100 3521 00	epp2 	pr6|64		sys_log_ptr
000771  aa  6 00266 2521 00	spri2	pr6|182
000772  aa  6 00134 3521 00	epp2 	pr6|92		text_lth
000773  aa  6 00270 2521 00	spri2	pr6|184
000774  aa  6 00135 3521 00	epp2 	pr6|93		data_lth
000775  aa  6 00272 2521 00	spri2	pr6|186
000776  aa  6 00140 3521 00	epp2 	pr6|96		data_class
000777  aa  6 00274 2521 00	spri2	pr6|188
001000  aa  6 00112 3521 20	epp2 	pr6|74,*		wmess.seq_num
001001  aa  6 00276 2521 00	spri2	pr6|190
001002  aa  6 00104 3521 00	epp2 	pr6|68		log_message_ptr
001003  aa  6 00300 2521 00	spri2	pr6|192
001004  aa  6 00102 3521 00	epp2 	pr6|66		code
001005  aa  6 00302 2521 00	spri2	pr6|194
001006  aa  6 00264 6211 00	eax1 	pr6|180
001007  aa   034000 4310 07	fld  	14336,dl
001010  aa  6 00044 3701 20	epp4 	pr6|36,*
001011  la  4 00022 3521 20	epp2 	pr4|18,*		log_segment_$create_message_number
001012  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 183
	if (code ^= 0) then do;

001013  aa  6 00102 2361 00	ldq  	pr6|66		code
001014  aa   000042 6000 04	tze  	34,ic		001056
						STATEMENT 1 ON LINE 184
	     if (code ^= error_table_$log_segment_full) then /* If not just plain full, fatal error */
		call syserr$error_code (SYSERR_CRASH_SYSTEM, code, "^a: Cannot add message to paged syserr log ^p.", WHOAMI, sys_log_ptr);

001015  aa  6 00044 3701 20	epp4 	pr6|36,*
001016  la  4 00010 1161 20	cmpq 	pr4|8,*		error_table_$log_segment_full
001017  aa   000034 6000 04	tze  	28,ic		001053
001020  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001021  aa   777300 00 0060	desc9a	-320,48		000320 = 136141072040
001022  aa  6 00264 00 0060	desc9a	pr6|180,48
001023  aa   777267 3520 04	epp2 	-329,ic		000312 = 000000000001
001024  aa  6 00310 2521 00	spri2	pr6|200
001025  aa  6 00102 3521 00	epp2 	pr6|66		code
001026  aa  6 00312 2521 00	spri2	pr6|202
001027  aa  6 00264 3521 00	epp2 	pr6|180
001030  aa  6 00314 2521 00	spri2	pr6|204
001031  aa   777234 3520 04	epp2 	-356,ic		000265 = 163171163145
001032  aa  6 00316 2521 00	spri2	pr6|206
001033  aa  6 00100 3521 00	epp2 	pr6|64		sys_log_ptr
001034  aa  6 00320 2521 00	spri2	pr6|208
001035  aa   777253 3520 04	epp2 	-341,ic		000310 = 404000000021
001036  aa  6 00322 2521 00	spri2	pr6|210
001037  aa   777243 3520 04	epp2 	-349,ic		000302 = 404000000043
001040  aa  6 00324 2521 00	spri2	pr6|212
001041  aa   777240 3520 04	epp2 	-352,ic		000301 = 524000000056
001042  aa  6 00326 2521 00	spri2	pr6|214
001043  aa   777243 3520 04	epp2 	-349,ic		000306 = 526000000040
001044  aa  6 00330 2521 00	spri2	pr6|216
001045  aa   777246 3520 04	epp2 	-346,ic		000313 = 464000000000
001046  aa  6 00332 2521 00	spri2	pr6|218
001047  aa  6 00306 6211 00	eax1 	pr6|198
001050  aa   024000 4310 07	fld  	10240,dl
001051  la  4 00032 3521 20	epp2 	pr4|26,*		syserr$error_code
001052  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 187
	     return ("0"b);

001053  aa  6 00130 3735 20	epp7 	pr6|88,*
001054  aa  7 00002 4501 20	stz  	pr7|2,*
001055  aa  6 00126 6101 00	rtcd 	pr6|86
						STATEMENT 1 ON LINE 188
	end;

						STATEMENT 1 ON LINE 190
	log_message.severity = wmess.code;

001056  aa  6 00112 3735 20	epp7 	pr6|74,*		wmess_ptr
001057  aa  7 00003 2351 00	lda  	pr7|3		wmess.code
001060  aa   000003 7350 00	als  	3
001061  aa  6 00104 3715 20	epp5 	pr6|68,*		log_message_ptr
001062  aa  5 00002 5511 40	stba 	pr5|2,40		log_message.severity
						STATEMENT 1 ON LINE 191
	log_message.time = wmess.time;

001063  aa  7 00001 2351 00	lda  	pr7|1		wmess.time
001064  aa  7 00002 2361 00	ldq  	pr7|2		wmess.time
001065  aa   000000 7330 00	lrs  	0
001066  aa  5 00002 5511 14	stba 	pr5|2,14		log_message.time
001067  aa  5 00003 7561 00	stq  	pr5|3		log_message.time
						STATEMENT 1 ON LINE 192
	log_message.process_id = wmess.process_id;

001070  aa  7 00005 2351 00	lda  	pr7|5		wmess.process_id
001071  aa  5 00005 7551 00	sta  	pr5|5		log_message.process_id
						STATEMENT 1 ON LINE 193
	log_message.text = wmess.text;

001072  aa  5 00004 2351 00	lda  	pr5|4		log_message.text_lth
001073  aa   000066 7330 00	lrs  	54
001074  aa  7 00003 2351 00	lda  	pr7|3		wmess.text_len
001075  aa   000014 7350 00	als  	12
001076  aa  6 00334 7561 00	stq  	pr6|220		log_message.text_lth
001077  aa   000000 6270 06	eax7 	0,ql
001100  aa   000074 7330 00	lrs  	60
001101  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001102  aa  7 00006 00 0006	desc9a	pr7|6,ql		wmess.text
001103  aa  5 00006 00 0017	desc9a	pr5|6,x7		log_message.text
						STATEMENT 1 ON LINE 195
	if (data_lth > 0) then do;

001104  aa  6 00263 7561 00	stq  	pr6|179
001105  aa  6 00135 2361 00	ldq  	pr6|93		data_lth
001106  aa   000035 6044 04	tmoz 	29,ic		001143
						STATEMENT 1 ON LINE 196
	     unspec (addr (log_message.data (1)) -> data_buffer) = unspec (wmess.data);

001107  aa  5 00002 2351 00	lda  	pr5|2		log_message.data_class_lth
001110  aa   000011 7350 00	als  	9
001111  aa   000077 7730 00	lrl  	63
001112  aa  6 00262 7561 00	stq  	pr6|178		log_message.data_class_lth
001113  aa  6 00334 2361 00	ldq  	pr6|220		log_message.text_lth
001114  aa   000030 0760 07	adq  	24,dl
001115  aa  6 00262 0761 00	adq  	pr6|178		log_message.data_class_lth
001116  aa   000003 0760 07	adq  	3,dl
001117  aa   000002 7320 00	qrs  	2
001120  aa   000000 6260 06	eax6 	0,ql
001121  aa  6 00135 2361 00	ldq  	pr6|93		data_lth
001122  aa   000044 4020 07	mpy  	36,dl
001123  aa  7 00003 2351 00	lda  	pr7|3		wmess.data_size
001124  aa   000030 7350 00	als  	24
001125  aa  6 00334 7561 00	stq  	pr6|220
001126  aa   000074 7330 00	lrs  	60
001127  aa   000044 4020 07	mpy  	36,dl
001130  aa  6 00335 7561 00	stq  	pr6|221
001131  aa  6 00263 2361 00	ldq  	pr6|179
001132  aa   000003 0760 07	adq  	3,dl
001133  aa   000002 7320 00	qrs  	2
001134  aa  5 00000 3535 16	epp3 	pr5|0,6
001135  aa  7 00006 3515 06	epp1 	pr7|6,ql
001136  aa  6 00334 2351 00	lda  	pr6|220
001137  aa  6 00335 2361 00	ldq  	pr6|221
001140  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
001141  aa  1 00000 00 0006	descb	pr1|0,ql
001142  aa  3 00000 00 0005	descb	pr3|0,al
						STATEMENT 1 ON LINE 197
	end;

001143  aa  6 00334 7461 00	stx6 	pr6|220
						STATEMENT 1 ON LINE 199
	call log_segment_$finish_message (sys_log_ptr, log_message_ptr, (0));

001144  aa  6 00335 4501 00	stz  	pr6|221
001145  aa  6 00100 3521 00	epp2 	pr6|64		sys_log_ptr
001146  aa  6 00266 2521 00	spri2	pr6|182
001147  aa  6 00104 3521 00	epp2 	pr6|68		log_message_ptr
001150  aa  6 00270 2521 00	spri2	pr6|184
001151  aa  6 00335 3521 00	epp2 	pr6|221
001152  aa  6 00272 2521 00	spri2	pr6|186
001153  aa  6 00264 6211 00	eax1 	pr6|180
001154  aa   014000 4310 07	fld  	6144,dl
001155  aa  6 00044 3701 20	epp4 	pr6|36,*
001156  la  4 00024 3521 20	epp2 	pr4|20,*		log_segment_$finish_message
001157  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 201
	message_offset = wordno (log_message_ptr);

001160  aa  6 00104 6361 20	eaq  	pr6|68,*		log_message_ptr
001161  aa   000022 7720 00	qrl  	18
001162  aa  6 00144 7561 00	stq  	pr6|100		message_offset
						STATEMENT 1 ON LINE 202
	if (message_offset > (1024 * syserr_log_data.copy_threshold)) then
	     must_send_wakeup = "1"b;

001163  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001164  aa  7 00126 2361 00	ldq  	pr7|86		syserr_log_data.copy_threshold
001165  aa   000012 7360 00	qls  	10
001166  aa  6 00144 1161 00	cmpq 	pr6|100		message_offset
001167  aa   000003 6050 04	tpl  	3,ic		001172
001170  aa   400000 2350 03	lda  	131072,du
001171  aa  6 00103 7551 00	sta  	pr6|67		must_send_wakeup
						STATEMENT 1 ON LINE 205
	if syserr_log_data.wakeup_on_printable then	/* Console recovery is in action-- send a wakeup */
	     if write_flags (mod (wmess.code, 10)) then	/* if the message should have been printed */
		must_send_wakeup = "1"b;

001172  aa  7 00125 2351 00	lda  	pr7|85		syserr_log_data.wakeup_on_printable
001173  aa   000015 6000 04	tze  	13,ic		001210
001174  aa  6 00112 3715 20	epp5 	pr6|74,*		wmess_ptr
001175  aa  5 00003 2351 00	lda  	pr5|3		wmess.code
001176  aa   000074 7330 00	lrs  	60
001177  aa   000213 3520 04	epp2 	139,ic		001412 = 000000000012
001200  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001201  aa  6 00335 7561 00	stq  	pr6|221
001202  aa  000 000 066 406	cmpb 	(ql),(),fill(0)
001203  ta   000264 00 0001	descb	180,1
001204  aa   000000 00 0000	descb	0,0
001205  aa   000003 6000 04	tze  	3,ic		001210
001206  aa   400000 2350 03	lda  	131072,du
001207  aa  6 00103 7551 00	sta  	pr6|67		must_send_wakeup
						STATEMENT 1 ON LINE 209
	return ("1"b);

001210  aa   400000 2350 03	lda  	131072,du
001211  aa  6 00130 3715 20	epp5 	pr6|88,*
001212  aa  5 00002 7551 20	sta  	pr5|2,*
001213  aa  6 00126 6101 00	rtcd 	pr6|86
						STATEMENT 1 ON LINE 210
     end create_syserr_message;

  END PROCEDURE create_syserr_message
BEGIN PROCEDURE swap_logs
ENTRY TO swap_logs                                          STATEMENT 1 ON LINE 213
swap_logs:
     procedure (P_success);

001214  aa  6 00146 6501 00	spri4	pr6|102
001215  aa  6 00150 2521 00	spri2	pr6|104
						STATEMENT 1 ON LINE 225
	must_send_wakeup = "1"b;

001216  aa   400000 2350 03	lda  	131072,du
001217  aa  6 00103 7551 00	sta  	pr6|67		must_send_wakeup
						STATEMENT 1 ON LINE 228
	if (syserr_log_data.swap_time ^= 0) then do;

001220  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001221  aa  7 00010 2371 00	ldaq 	pr7|8		syserr_log_data.swap_time
001222  aa   000033 6000 04	tze  	27,ic		001255
						STATEMENT 1 ON LINE 229
	     call syserr (SYSERR_PRINT_WITH_ALARM, "^a: LOG partition full. Further copying temporarily disabled.", WHOAMI);

001223  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001224  aa   777111 00 0100	desc9a	-439,64		000334 = 136141072040
001225  aa  6 00336 00 0100	desc9a	pr6|222,64
001226  aa   777051 3520 04	epp2 	-471,ic		000277 = 000000000003
001227  aa  6 00360 2521 00	spri2	pr6|240
001230  aa  6 00336 3521 00	epp2 	pr6|222
001231  aa  6 00362 2521 00	spri2	pr6|242
001232  aa   777033 3520 04	epp2 	-485,ic		000265 = 163171163145
001233  aa  6 00364 2521 00	spri2	pr6|244
001234  aa   777054 3520 04	epp2 	-468,ic		000310 = 404000000021
001235  aa  6 00366 2521 00	spri2	pr6|246
001236  aa   777042 3520 04	epp2 	-478,ic		000300 = 524000000075
001237  aa  6 00370 2521 00	spri2	pr6|248
001240  aa   777046 3520 04	epp2 	-474,ic		000306 = 526000000040
001241  aa  6 00372 2521 00	spri2	pr6|250
001242  aa  6 00356 6211 00	eax1 	pr6|238
001243  aa   014000 4310 07	fld  	6144,dl
001244  aa  6 00044 3701 20	epp4 	pr6|36,*
001245  la  4 00030 3521 20	epp2 	pr4|24,*		syserr
001246  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 230
	     syserr_log_data.copy_disabled = "1"b;

001247  aa   400000 2350 03	lda  	131072,du
001250  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001251  aa  7 00123 7551 00	sta  	pr7|83		syserr_log_data.copy_disabled
						STATEMENT 1 ON LINE 231
	     P_success = "0"b;

001252  aa  6 00150 3715 20	epp5 	pr6|104,*
001253  aa  5 00002 4501 20	stz  	pr5|2,*		P_success
						STATEMENT 1 ON LINE 232
	     return;

001254  aa  6 00146 6101 00	rtcd 	pr6|102
						STATEMENT 1 ON LINE 233
	end;

						STATEMENT 1 ON LINE 235
	new_log = 3 - syserr_log_data.live_log;

001255  aa   000003 2360 07	ldq  	3,dl
001256  aa  7 00004 1761 00	sbq  	pr7|4		syserr_log_data.live_log
001257  aa  6 00154 7561 00	stq  	pr6|108		new_log
						STATEMENT 1 ON LINE 237
	old_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);

001260  aa  7 00004 2361 00	ldq  	pr7|4		syserr_log_data.live_log
001261  aa   000001 7360 00	qls  	1
001262  aa  7 00016 3715 26	epp5 	pr7|14,ql*	syserr_log_data.log_ptr
001263  aa  6 00162 6515 00	spri5	pr6|114		old_log_ptr
						STATEMENT 1 ON LINE 238
	new_log_ptr = syserr_log_data.log_ptr (new_log);

001264  aa  6 00154 2361 00	ldq  	pr6|108		new_log
001265  aa   000001 7360 00	qls  	1
001266  aa  7 00016 3535 26	epp3 	pr7|14,ql*	syserr_log_data.log_ptr
001267  aa  6 00156 2535 00	spri3	pr6|110		new_log_ptr
						STATEMENT 1 ON LINE 239
	new_log_size = 1024 * syserr_log_data.log_size (new_log);

001270  aa  6 00154 7271 00	lxl7 	pr6|108		new_log
001271  aa  6 00374 7561 00	stq  	pr6|252
001272  aa  7 00015 2361 17	ldq  	pr7|13,7		syserr_log_data.log_size
001273  aa   000012 7360 00	qls  	10
001274  aa  6 00160 7561 00	stq  	pr6|112		new_log_size
						STATEMENT 1 ON LINE 241
	swap_time = clock ();

001275  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
001276  aa  6 00164 7571 00	staq 	pr6|116		swap_time
						STATEMENT 1 ON LINE 242
	call log_initialize_ (old_log_ptr, new_log_ptr, new_log_size, "", (0));

001277  aa  6 00376 4501 00	stz  	pr6|254
001300  aa  6 00162 3521 00	epp2 	pr6|114		old_log_ptr
001301  aa  6 00402 2521 00	spri2	pr6|258
001302  aa  6 00156 3521 00	epp2 	pr6|110		new_log_ptr
001303  aa  6 00404 2521 00	spri2	pr6|260
001304  aa  6 00160 3521 00	epp2 	pr6|112		new_log_size
001305  aa  6 00406 2521 00	spri2	pr6|262
001306  aa  6 00375 3521 00	epp2 	pr6|253
001307  aa  6 00410 2521 00	spri2	pr6|264
001310  aa  6 00376 3521 00	epp2 	pr6|254
001311  aa  6 00412 2521 00	spri2	pr6|266
001312  aa   777001 3520 04	epp2 	-511,ic		000313 = 464000000000
001313  aa  6 00414 2521 00	spri2	pr6|268
001314  aa  6 00416 2521 00	spri2	pr6|270
001315  aa   776761 3520 04	epp2 	-527,ic		000276 = 404000000022
001316  aa  6 00420 2521 00	spri2	pr6|272
001317  aa   776756 3520 04	epp2 	-530,ic		000275 = 524000000000
001320  aa  6 00422 2521 00	spri2	pr6|274
001321  aa   776761 3520 04	epp2 	-527,ic		000302 = 404000000043
001322  aa  6 00424 2521 00	spri2	pr6|276
001323  aa  6 00400 6211 00	eax1 	pr6|256
001324  aa   024000 4310 07	fld  	10240,dl
001325  aa  6 00044 3701 20	epp4 	pr6|36,*
001326  la  4 00020 3521 20	epp2 	pr4|16,*		log_initialize_
001327  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 244
	syserr_log_data.live_log = new_log;

001330  aa  6 00154 2361 00	ldq  	pr6|108		new_log
001331  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001332  aa  7 00004 7561 00	stq  	pr7|4		syserr_log_data.live_log
						STATEMENT 1 ON LINE 245
	sys_log_ptr = syserr_log_data.log_ptr (new_log);

001333  aa  6 00374 7271 00	lxl7 	pr6|252
001334  aa  7 00016 3715 37	epp5 	pr7|14,7*		syserr_log_data.log_ptr
001335  aa  6 00100 6515 00	spri5	pr6|64		sys_log_ptr
						STATEMENT 1 ON LINE 247
	syserr_log_data.swap_time = swap_time;

001336  aa  6 00164 2371 00	ldaq 	pr6|116		swap_time
001337  aa  7 00010 7571 00	staq 	pr7|8		syserr_log_data.swap_time
						STATEMENT 1 ON LINE 249
	syserr_log_data.copy_disabled = "0"b;

001340  aa  7 00123 4501 00	stz  	pr7|83		syserr_log_data.copy_disabled
						STATEMENT 1 ON LINE 250
	syserr_log_data.drop_severity_5 = "0"b;

001341  aa  7 00124 4501 00	stz  	pr7|84		syserr_log_data.drop_severity_5
						STATEMENT 1 ON LINE 252
	P_success = "1"b;

001342  aa   400000 2350 03	lda  	131072,du
001343  aa  6 00150 3535 20	epp3 	pr6|104,*
001344  aa  3 00002 7551 20	sta  	pr3|2,*		P_success
						STATEMENT 1 ON LINE 253
	return;

001345  aa  6 00146 6101 00	rtcd 	pr6|102
						STATEMENT 1 ON LINE 255
     end swap_logs;

  END PROCEDURE swap_logs
BEGIN PROCEDURE lock_paged_log
ENTRY TO lock_paged_log                                     STATEMENT 1 ON LINE 258
lock_paged_log:
     procedure ();

001346  aa  6 00166 6501 00	spri4	pr6|118
						STATEMENT 1 ON LINE 261
	call lock$lock_fast (addr (syserr_log_data.lock));

001347  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001350  aa  7 00116 3735 00	epp7 	pr7|78		syserr_log_data.lock
001351  aa  6 00426 6535 00	spri7	pr6|278
001352  aa  6 00426 3521 00	epp2 	pr6|278
001353  aa  6 00432 2521 00	spri2	pr6|282
001354  aa  6 00430 6211 00	eax1 	pr6|280
001355  aa   004000 4310 07	fld  	2048,dl
001356  aa  6 00044 3701 20	epp4 	pr6|36,*
001357  la  4 00016 3521 20	epp2 	pr4|14,*		lock$lock_fast
001360  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 263
	return;

001361  aa  6 00166 6101 00	rtcd 	pr6|118
						STATEMENT 1 ON LINE 264
     end lock_paged_log;

  END PROCEDURE lock_paged_log
BEGIN PROCEDURE unlock_paged_log
ENTRY TO unlock_paged_log                                   STATEMENT 1 ON LINE 268
unlock_paged_log:
     procedure ();

001362  aa  6 00174 6501 00	spri4	pr6|124
						STATEMENT 1 ON LINE 271
	call lock$unlock_fast (addr (syserr_log_data.lock));

001363  aa  6 00106 3735 20	epp7 	pr6|70,*		syserr_log_data_ptr
001364  aa  7 00116 3735 00	epp7 	pr7|78		syserr_log_data.lock
001365  aa  6 00434 6535 00	spri7	pr6|284
001366  aa  6 00434 3521 00	epp2 	pr6|284
001367  aa  6 00440 2521 00	spri2	pr6|288
001370  aa  6 00436 6211 00	eax1 	pr6|286
001371  aa   004000 4310 07	fld  	2048,dl
001372  aa  6 00044 3701 20	epp4 	pr6|36,*
001373  la  4 00014 3521 20	epp2 	pr4|12,*		lock$unlock_fast
001374  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 273
	return;

001375  aa  6 00174 6101 00	rtcd 	pr6|124
						STATEMENT 1 ON LINE 274
     end unlock_paged_log;

  END PROCEDURE unlock_paged_log
  END PROCEDURE syserr_copy


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
