	COMPILATION LISTING OF SEGMENT get_temp_segments_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1005.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       13 get_temp_segments_:
       14      proc (a_caller, a_ptrs, a_code);
       15 
       16 /* This program implements the temporary segment management features as used by the
       17*   get_temp_segments_, release_temp_segments_, get_temp_segment_, release_temp_segment_,
       18*   and list_temp_segments interfaces.  All of these entries are included in this
       19*   external procedure as they must share static.
       20*
       21*   Last Modified: (date and reason):
       22*
       23*   11/21/75	by S. Webber (Initial coding)
       24*   11/15/76	by Larry Johnson to add arguments to list_temp_segments
       25*   08/29/77	by Melanie Weaver to add entry list_segnos
       26*   11/2/77	by Richard A. Barnes to add get_temp_segment_ & release_temp_segment_
       27*   03/20/81	by S. Herbst to clean up lts interface and make gts turn on safety switches.
       28*   07/14/81	by S. Herbst to resinstate listing all when given no args.
       29*   03/14/83	by E. N. Kittlitz to reset max length to sys_info$max_seg_size.
       30*   04/14/83	by K. Loepere for bootload Multics
       31*   83-12-01         by BIM to only reset max_length if neccessary.
       32*   83-12-20	by C Spitzer. use copy of caller id for tests.
       33**/
       34 
       35 
       36 /****^  HISTORY COMMENTS:
       37*  1) change(87-04-27,Farley), approve(87-07-06,MCR7717),
       38*     audit(87-07-13,Lippard), install(87-07-17,MR12.1-1043):
       39*     Changed get_new_segments to return a non-zero error code when unable to
       40*     get a good pointer to one of the bootload_temp_N segments.
       41*                                                   END HISTORY COMMENTS */
       42 
       43 
       44 /* Parameters */
       45 
       46 dcl  a_caller char (*);
       47 dcl  a_ptrs (*) ptr;
       48 dcl  a_code fixed bin (35);
       49 
       50 /* Automatic */
       51 
       52 dcl  max_length fixed bin (19);
       53 dcl  new_block_ptr ptr;
       54 dcl  caller char (32);
       55 dcl  array_ptr ptr;
       56 dcl  j fixed bin;
       57 dcl  n_segs fixed bin;
       58 dcl  new_blocks fixed bin;
       59 dcl  i fixed bin;
       60 dcl  n_found fixed bin;
       61 dcl  old_blocks fixed bin;
       62 dcl  code fixed bin (35);
       63 dcl  ename char (20);
       64 dcl  ename2 char (32);
       65 dcl  segno (4) char (1) defined (ename2) pos (22);
       66 dcl  segment_number fixed bin;
       67 dcl  found_it bit (1);
       68 dcl  arg_count fixed bin;
       69 dcl  arg_list_ptr ptr;
       70 dcl  arg_ptr ptr;
       71 dcl  arg_len fixed bin;
       72 dcl  bootload_sw bit (1) aligned;
       73 
       74 /* Based */
       75 
       76 dcl  ptrs (n_segs) ptr based (array_ptr);
       77 dcl  arg char (arg_len) based (arg_ptr);
       78 dcl  1 octal_digits aligned based (addr (segment_number)),
       79        2 filler bit (24) unal,
       80        2 digit (4) bit (3) unal;
       81 dcl  1 new_block (new_blocks) aligned based (new_block_ptr) like block;
       82 dcl  1 block (n_blocks) aligned based (block_ptr),
       83        2 caller char (32),
       84        2 segptr ptr,
       85        2 name char (25),
       86        2 used bit (1);
       87 dcl  area area based (areap);
       88 
       89 /* Static */
       90 
       91 dcl  block_ptr ptr static init (null);
       92 dcl  areap ptr static init (null);
       93 dcl  n_blocks fixed bin static init (0);
       94 
       95 /* Builtin */
       96 
       97 dcl  (addr, baseno, bin, character, dim, index, length, ltrim, max, null, substr) builtin;
       98 
       99 /* Entries */
      100 
      101 dcl  com_err_ entry options (variable);
      102 dcl  hcs_$chname_seg entry (ptr, char (*), char (*), fixed bin (35));
      103 dcl  get_system_free_area_ entry returns (ptr);
      104 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
      105 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      106 dcl  unique_bits_ entry returns (bit (70));
      107 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
      108 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      109 dcl  hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
      110 dcl  hcs_$get_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
      111 dcl  hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
      112 dcl  ioa_ entry options (variable);
      113 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
      114 dcl  cu_$arg_list_ptr entry (ptr);
      115 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      116 dcl  slt_manager$get_seg_ptr entry (char (32) aligned) returns (ptr);
      117 
      118 /* External */
      119 
      120 dcl  error_table_$argerr fixed bin (35) ext;
      121 dcl  error_table_$badopt fixed bin (35) ext;
      122 dcl  error_table_$illegal_activation fixed bin (35) ext;
      123 dcl  sys_info$max_seg_size fixed bin (18) ext static;
      124 dcl  sys_info$service_system bit (1) aligned ext;
      125 
      126 /**/
      127 
      128 /* Execution of get_temp_segments_ begins here */
      129 
      130 	n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
      131 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
      132 
      133 gts_join:
      134 	bootload_sw = ^sys_info$service_system;
      135 	caller = a_caller;
      136 	a_code = 0;
      137 	n_found = 0;				/* initialize indicating we've found no free entries */
      138 	if block_ptr = null then do;			/* we haven't yet gotten any segments */
      139 	     n_blocks = n_segs;			/* so get the exact amount requested */
      140 	     areap = get_system_free_area_ ();		/* get pointer to standard area to use */
      141 	     allocate block in (area) set (block_ptr);	/* get the needed storage */
      142 	     old_blocks = 0;			/* needed by get_new_segments routine */
      143 	     call get_new_segments;			/* do the work in this subr */
      144 	     return;
      145 	     end;
      146 
      147 	do i = 1 to n_blocks while (n_found < n_segs);	/* search for the necessary free segments */
      148 	     if ^block (i).used then do;		/* we found another free one */
      149 		block (i).used = "1"b;		/* mark entry as being used */
      150 		block (i).caller = caller;		/* save name of whose using it */
      151 		n_found = n_found + 1;
      152 		ptrs (n_found) = block (i).segptr;
      153 		end;
      154 	end;
      155 	if n_found < n_segs then do;			/* there weren't enough free ones */
      156 	     new_blocks = n_blocks + n_segs - n_found;	/* get more storage, just large enough */
      157 	     old_blocks = n_blocks;
      158 	     if areap = null then areap = get_system_free_area_ ();
      159 						/* get pointer to area */
      160 	     allocate new_block in (area) set (new_block_ptr);
      161 						/* get the needed storage */
      162 	     new_block_ptr -> block = block;		/* copy the current structure */
      163 	     free block in (area);
      164 	     n_blocks = new_blocks;
      165 	     block_ptr = new_block_ptr;
      166 	     call get_new_segments;			/* get the needed segments */
      167 	     end;
      168 
      169 	return;
      170 
      171 get_new_segments:
      172      proc;
      173 
      174 dcl  (i, j) fixed bin;
      175 
      176 	do i = old_blocks + 1 to n_blocks;		/* initialize the new entries */
      177 	     block (i).used = "1"b;			/* the caller will use these blocks */
      178 	     block (i).caller = caller;		/* ditto */
      179 	     if bootload_sw then do;
      180 		ename2 = "bootload_temp_" || ltrim (character (i));
      181 		block (i).segptr = slt_manager$get_seg_ptr ((ename2));
      182 		if block (i).segptr = null then do;
      183 		     code = error_table_$illegal_activation;
      184 		     call undo;
      185 		     return;
      186 		     end;
      187 		end;
      188 	     else do;
      189 		ename2 = unique_chars_ (unique_bits_ ()) || ".temp.";
      190 		ename = substr (ename2, 1, length (ename));
      191 		call hcs_$make_seg ("", ename, "", 01110b, block (i).segptr, code);
      192 		if code ^= 0 then do;
      193 		     call undo;
      194 		     return;
      195 		     end;
      196 		segment_number = bin (baseno (block (i).segptr), 18);
      197 		do j = 1 to 4;
      198 		     segno (j) = substr ("01234567", bin (digit (j), 3) + 1, 1);
      199 		end;
      200 		call hcs_$chname_seg (block (i).segptr, ename, ename2, code);
      201 		if code ^= 0 then do;
      202 		     call undo;
      203 		     return;
      204 		     end;
      205 
      206 		call hcs_$set_safety_sw_seg (block (i).segptr, "1"b, code);
      207 		end;
      208 
      209 	     block (i).name = substr (ename2, 1, length (block (i).name));
      210 	     n_found = n_found + 1;
      211 	     ptrs (n_found) = block (i).segptr;
      212 	end;
      213 
      214 undo:
      215 	proc;
      216 
      217 	     a_code = code;
      218 	     n_blocks = old_blocks;			/* reset to the way things were */
      219 	     if ^bootload_sw
      220 	     then do j = old_blocks + 1 to i - 1;	/* clean up the segments we already got */
      221 		call hcs_$delentry_seg (block (j).segptr, code);
      222 	     end;
      223 
      224 	end;
      225      end;						/*						*/
      226 get_temp_segment_:
      227      entry (a_caller, a_ptr, a_code);
      228 
      229 dcl  a_ptr ptr parameter;
      230 
      231 	n_segs = 1;				/* only 1 segment is being processed */
      232 	array_ptr = addr (a_ptr);
      233 	go to gts_join;				/*						*/
      234 
      235 release_temp_segments_:
      236      entry (a_caller, a_ptrs, a_code);
      237 
      238 	n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
      239 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
      240 
      241 rts_join:
      242 	bootload_sw = ^sys_info$service_system;
      243 	caller = a_caller;
      244 	a_code = 0;
      245 	do i = 1 to n_segs;				/* release each segment passed in */
      246 	     if ptrs (i) ^= null then do;
      247 		found_it = "0"b;			/* flag says we've not yet found this segment */
      248 		do j = 1 to n_blocks while (^found_it); /* search for segment in array */
      249 		     if block (j).used then do;	/* candidate, see if right one */
      250 			if ptrs (i) = block (j).segptr then do;
      251 						/* we found the given segment */
      252 			     if block (j).caller ^= caller
      253 			     then a_code = error_table_$argerr;
      254 			     else do;		/* the right guy (as far as we care) */
      255 				if ^bootload_sw then do;
      256 				     call hcs_$truncate_seg (block (j).segptr, 0, code);
      257 						/* truncate now */
      258 				     if code ^= 0 then a_code = code;
      259 						/* accumulate error */
      260 				     call hcs_$get_max_length_seg (block (j).segptr, max_length, code);
      261 				     if code ^= 0 then a_code = code;
      262 				     if max_length ^= sys_info$max_seg_size then do;
      263 					call hcs_$set_max_length_seg (block (j).segptr, (sys_info$max_seg_size),
      264 					     code);
      265 						/* ensure no funny business */
      266 					if code ^= 0 then a_code = code;
      267 						/* accumulate error */
      268 					end;
      269 				     end;
      270 				block (j).used = "0"b;
      271 						/* ditto */
      272 				block (j).caller = "";
      273 				ptrs (i) = null;
      274 				found_it = "1"b;
      275 				end;
      276 			     end;
      277 			end;
      278 		end;
      279 		if ^found_it then a_code = error_table_$argerr;
      280 		end;
      281 	end;
      282 	return;
      283 
      284 /**/
      285 release_temp_segment_:
      286      entry (a_caller, a_ptr, a_code);
      287 
      288 	n_segs = 1;				/* only 1 segment is being processed */
      289 	array_ptr = addr (a_ptr);
      290 	goto rts_join;				/*						*/
      291 
      292 
      293 list_temp_segments:
      294      entry;
      295 
      296 	if n_blocks = 0 then do;			/* nothing ever allocated */
      297 	     call ioa_ ("No temporary segments.");
      298 RETURN:
      299 	     return;
      300 	     end;
      301 	call cu_$arg_count (arg_count, code);
      302 	if code ^= 0 then do;
      303 	     call com_err_ (code, "list_temp_segments");
      304 	     return;
      305 	     end;
      306 	call cu_$arg_list_ptr (arg_list_ptr);
      307 
      308 	begin;					/* to allocate storage */
      309 
      310 dcl  treq char (32);
      311 dcl  req (max (1, arg_count)) char (32);
      312 dcl  nreq fixed bin;				/* number of names requested */
      313 dcl  all_sw bit (1);				/* set if -all given */
      314 dcl  (i, j, cnt) fixed bin;
      315 dcl  dup_sw bit (1);
      316 
      317 	     nreq = 0;
      318 	     all_sw = "0"b;
      319 	     do i = 1 to arg_count;			/* get table of requests */
      320 		call cu_$arg_ptr_rel (i, arg_ptr, arg_len, code, arg_list_ptr);
      321 
      322 		if index (arg, "-") = 1
      323 		then if arg = "-all" | arg = "-a"
      324 		     then all_sw = "1"b;
      325 		     else do;
      326 			call com_err_ (error_table_$badopt, "list_temp_segments", "^a", arg);
      327 			go to RETURN;
      328 			end;
      329 
      330 		else do;
      331 		     dup_sw = "0"b;			/* be sure not given dup args */
      332 		     treq = arg;
      333 		     do j = 1 to nreq;
      334 			if req (j) = treq then dup_sw = "1"b;
      335 		     end;
      336 		     if ^dup_sw then do;		/* new one */
      337 			nreq = nreq + 1;
      338 			req (nreq) = treq;
      339 			end;
      340 		     end;
      341 	     end;
      342 
      343 	     if all_sw then do;
      344 		if nreq > 0 then do;
      345 		     call com_err_ (0, "list_temp_segments", "-all is inconsistent with name arguments.");
      346 		     go to RETURN;
      347 		     end;
      348 		end;
      349 
      350 	     if nreq = 0 then do;			/* if no special requests */
      351 		cnt = 0;
      352 		do i = 1 to n_blocks;		/* count free segs */
      353 		     if ^block.used (i) then cnt = cnt + 1;
      354 		end;
      355 		call ioa_ ("^/^-^d Segment^[s^],  ^d Free^/", n_blocks, (n_blocks ^= 1), cnt);
      356 		end;
      357 	     else do;				/* count segments that match requests */
      358 		cnt = 0;
      359 		do i = 1 to n_blocks;
      360 		     if block.used (i)
      361 		     then do j = 1 to nreq;
      362 			if block.caller (i) = req (j) then cnt = cnt + 1;
      363 		     end;
      364 		end;
      365 		call ioa_ ("^/^-^d Segment^[s^] used.^/", cnt, (cnt ^= 1));
      366 		end;
      367 
      368 	     do i = 1 to n_blocks;			/* now print them */
      369 		if all_sw then go to print_it;
      370 		else if block.used (i) then do;
      371 		     if nreq = 0
      372 		     then go to print_it;
      373 		     else do j = 1 to nreq;
      374 			if block.caller (i) = req (j) then go to print_it;
      375 		     end;
      376 		     end;
      377 		go to next_block;
      378 print_it:
      379 		call ioa_ ("^a  ^[^a^;(free)^]", block.name (i), block.used (i), block.caller (i));
      380 next_block:
      381 	     end;
      382 	     call ioa_ ("");
      383 	end;
      384 	return;
      385 
      386 /**/
      387 
      388 list_segnos:
      389      entry (struc_ptr);
      390 
      391 dcl  struc_ptr ptr;
      392 dcl  1 segno_struc aligned based (struc_ptr),
      393        2 num_segs fixed bin,
      394        2 segno (n_blocks) fixed bin;
      395 
      396 
      397 	if (block_ptr = null) | (areap = null) then do;
      398 	     struc_ptr = null;
      399 	     return;
      400 	     end;
      401 
      402 	allocate segno_struc in (area) set (struc_ptr);
      403 	segno_struc.num_segs = n_blocks;
      404 	do i = 1 to n_blocks;
      405 	     segno_struc.segno (i) = bin (baseno (block (i).segptr), 15);
      406 	end;
      407 
      408 	return;
      409 
      410 
      411      end get_temp_segments_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.1  get_temp_segments_.pl1            >spec>install>1110>get_temp_segments_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_caller                               parameter       char                     packed unaligned dcl 46 ref 13 135 226 235 243 285
a_code                                 parameter       fixed bin(35,0)          dcl 48 set ref 13 136* 217* 226 235 244* 252* 258*
                                                                                  261* 266* 279* 285
a_ptr                                  parameter       pointer                  dcl 229 set ref 226 232 285 289
a_ptrs                                 parameter       pointer                  array dcl 47 set ref 13 130 131 235 238 239
addr                                                   builtin function         dcl 97 ref 131 198 232 239 289
all_sw                          000111 automatic       bit(1)                   packed unaligned dcl 313 set ref 318* 322* 343 369
area                                   based           area(1024)               dcl 87 ref 141 160 163 402
areap                           000012 internal static pointer                  initial dcl 92 set ref 140* 141 158 158* 160 163 397
                                                                                  402
arg                                    based           char                     packed unaligned dcl 77 set ref 322 322 322 326* 332
arg_count                       000144 automatic       fixed bin(17,0)          dcl 68 set ref 301* 311 319
arg_len                         000152 automatic       fixed bin(17,0)          dcl 71 set ref 320* 322 322 322 326 326 332
arg_list_ptr                    000146 automatic       pointer                  dcl 69 set ref 306* 320*
arg_ptr                         000150 automatic       pointer                  dcl 70 set ref 320* 322 322 322 326 332
array_ptr                       000114 automatic       pointer                  dcl 55 set ref 131* 152 211 232* 239* 246 250 273
                                                                                  289*
baseno                                                 builtin function         dcl 97 ref 196 405
bin                                                    builtin function         dcl 97 ref 196 198 405
block                                  based           structure                array level 1 dcl 82 set ref 141 162* 162 163
block_ptr                       000010 internal static pointer                  initial dcl 91 set ref 138 141* 148 149 150 152 162
                                                                                  163 165* 177 178 181 182 191 196 200 206 209 209
                                                                                  211 221 249 250 252 256 260 263 270 272 353 360
                                                                                  362 370 374 378 378 378 397 405
bootload_sw                     000153 automatic       bit(1)                   dcl 72 set ref 133* 179 219 241* 255
caller                          000104 automatic       char(32)                 packed unaligned dcl 54 in procedure
                                                                                  "get_temp_segments_" set ref 135* 150 178 243* 252
caller                                 based           char(32)                 array level 2 in structure "block" dcl 82
                                                                                  in procedure "get_temp_segments_" set ref 150*
                                                                                  178* 252 272* 362 374 378*
character                                              builtin function         dcl 97 ref 180
cnt                             000114 automatic       fixed bin(17,0)          dcl 314 set ref 351* 353* 353 355* 358* 362* 362
                                                                                  365* 365
code                            000124 automatic       fixed bin(35,0)          dcl 62 set ref 183* 191* 192 200* 201 206* 217 221*
                                                                                  256* 258 258 260* 261 261 263* 266 266 301* 302
                                                                                  303* 320*
com_err_                        000016 constant        entry                    external dcl 101 ref 303 326 345
cu_$arg_count                   000046 constant        entry                    external dcl 113 ref 301
cu_$arg_list_ptr                000050 constant        entry                    external dcl 114 ref 306
cu_$arg_ptr_rel                 000052 constant        entry                    external dcl 115 ref 320
digit                     0(24)        based           bit(3)                   array level 2 packed packed unaligned dcl 78 ref 198
dim                                                    builtin function         dcl 97 ref 130 238
dup_sw                          000115 automatic       bit(1)                   packed unaligned dcl 315 set ref 331* 334* 336
ename                           000125 automatic       char(20)                 packed unaligned dcl 63 set ref 190* 190 191* 200*
ename2                          000132 automatic       char(32)                 packed unaligned dcl 64 set ref 180* 181 189* 190
                                                                                  198* 198 200* 209
error_table_$argerr             000056 external static fixed bin(35,0)          dcl 120 ref 252 279
error_table_$badopt             000060 external static fixed bin(35,0)          dcl 121 set ref 326*
error_table_$illegal_activation 000062 external static fixed bin(35,0)          dcl 122 ref 183
found_it                        000143 automatic       bit(1)                   packed unaligned dcl 67 set ref 247* 248 274* 279
get_system_free_area_           000022 constant        entry                    external dcl 103 ref 140 158
hcs_$chname_seg                 000020 constant        entry                    external dcl 102 ref 200
hcs_$delentry_seg               000024 constant        entry                    external dcl 104 ref 221
hcs_$get_max_length_seg         000040 constant        entry                    external dcl 110 ref 260
hcs_$make_seg                   000034 constant        entry                    external dcl 108 ref 191
hcs_$set_max_length_seg         000042 constant        entry                    external dcl 111 ref 263
hcs_$set_safety_sw_seg          000036 constant        entry                    external dcl 109 ref 206
hcs_$truncate_seg               000032 constant        entry                    external dcl 107 ref 256
i                               000112 automatic       fixed bin(17,0)          dcl 314 in begin block on line 308 set ref 319* 320*
                                                                                  352* 353* 359* 360 362* 368* 370 374 378 378 378*
i                               000121 automatic       fixed bin(17,0)          dcl 59 in procedure "get_temp_segments_" set ref
                                                                                  147* 148 149 150 152* 245* 246 250 273* 404* 405
                                                                                  405*
i                               000166 automatic       fixed bin(17,0)          dcl 174 in procedure "get_new_segments" set ref 176*
                                                                                  177 178 180 181 182 191 196 200 206 209 209 211*
                                                                                  219
index                                                  builtin function         dcl 97 ref 322
ioa_                            000044 constant        entry                    external dcl 112 ref 297 355 365 378 382
j                               000113 automatic       fixed bin(17,0)          dcl 314 in begin block on line 308 set ref 333* 334*
                                                                                  360* 362* 373* 374*
j                               000116 automatic       fixed bin(17,0)          dcl 56 in procedure "get_temp_segments_" set ref
                                                                                  248* 249 250 252 256 260 263 270 272*
j                               000167 automatic       fixed bin(17,0)          dcl 174 in procedure "get_new_segments" set ref 197*
                                                                                  198 198* 219* 221*
length                                                 builtin function         dcl 97 ref 190 209
ltrim                                                  builtin function         dcl 97 ref 180
max                                                    builtin function         dcl 97 ref 311
max_length                      000100 automatic       fixed bin(19,0)          dcl 52 set ref 260* 262
n_blocks                        000014 internal static fixed bin(17,0)          initial dcl 93 set ref 139* 141 147 156 157 162 163
                                                                                  164* 176 218* 248 296 352 355* 355 359 368 402 403
                                                                                  404
n_found                         000122 automatic       fixed bin(17,0)          dcl 60 set ref 137* 147 151* 151 152 155 156 210*
                                                                                  210 211
n_segs                          000117 automatic       fixed bin(17,0)          dcl 57 set ref 130* 139 147 155 156 231* 238* 245
                                                                                  288*
name                     12            based           char(25)                 array level 2 dcl 82 set ref 209* 209 378*
new_block                              based           structure                array level 1 dcl 81 ref 160
new_block_ptr                   000102 automatic       pointer                  dcl 53 set ref 160* 162 165
new_blocks                      000120 automatic       fixed bin(17,0)          dcl 58 set ref 156* 160 164
nreq                            000110 automatic       fixed bin(17,0)          dcl 312 set ref 317* 333 337* 337 338 344 350 360
                                                                                  371 373
null                                                   builtin function         dcl 97 ref 138 158 182 246 273 397 397 398
num_segs                               based           fixed bin(17,0)          level 2 dcl 392 set ref 403*
octal_digits                           based           structure                level 1 dcl 78
old_blocks                      000123 automatic       fixed bin(17,0)          dcl 61 set ref 142* 157* 176 218 219
ptrs                                   based           pointer                  array dcl 76 set ref 152* 211* 246 250 273*
req                             000110 automatic       char(32)                 array packed unaligned dcl 311 set ref 334 338* 362
                                                                                  374
segment_number                  000142 automatic       fixed bin(17,0)          dcl 66 set ref 196* 198
segno                                  defined         char(1)                  array packed unaligned dcl 65 in procedure
                                                                                  "get_temp_segments_" set ref 198*
segno                     1            based           fixed bin(17,0)          array level 2 in structure "segno_struc" dcl 392
                                                                                  in procedure "get_temp_segments_" set ref 405*
segno_struc                            based           structure                level 1 dcl 392 set ref 402
segptr                   10            based           pointer                  array level 2 dcl 82 set ref 152 181* 182 191* 196
                                                                                  200* 206* 211 221* 250 256* 260* 263* 405
slt_manager$get_seg_ptr         000054 constant        entry                    external dcl 116 ref 181
struc_ptr                              parameter       pointer                  dcl 391 set ref 388 398* 402* 403 405
substr                                                 builtin function         dcl 97 ref 190 198 209
sys_info$max_seg_size           000064 external static fixed bin(18,0)          dcl 123 ref 262 263
sys_info$service_system         000066 external static bit(1)                   dcl 124 ref 133 241
treq                            000100 automatic       char(32)                 packed unaligned dcl 310 set ref 332* 334 338
unique_bits_                    000030 constant        entry                    external dcl 106 ref 189 189
unique_chars_                   000026 constant        entry                    external dcl 105 ref 189
used                     21            based           bit(1)                   array level 2 dcl 82 set ref 148 149* 177* 249 270*
                                                                                  353 360 370 378*

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN                          000675 constant        label                    dcl 298 ref 327 346
get_new_segments                001606 constant        entry                    internal dcl 171 ref 143 166
get_temp_segment_               000334 constant        entry                    external dcl 226
get_temp_segments_              000122 constant        entry                    external dcl 13
gts_join                        000147 constant        label                    dcl 133 ref 233
list_segnos                     001524 constant        entry                    external dcl 388
list_temp_segments              000647 constant        entry                    external dcl 293
next_block                      001504 constant        label                    dcl 380 ref 377
print_it                        001440 constant        label                    dcl 378 ref 369 371 374
release_temp_segment_           000625 constant        entry                    external dcl 285
release_temp_segments_          000357 constant        entry                    external dcl 235
rts_join                        000405 constant        label                    dcl 241 ref 290
undo                            002170 constant        entry                    internal dcl 214 ref 184 193 202

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2566        2656    2235        2576
Length      3132    2235        70         237     330           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_temp_segments_                  228 external procedure  is an external procedure.  
get_new_segments                        internal procedure  shares stack frame of external procedure get_temp_segments_.  
undo                                    internal procedure  shares stack frame of external procedure get_temp_segments_.  
begin block on line 308             136 begin block         uses auto adjustable storage.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 block_ptr                   get_temp_segments_
000012 areap                       get_temp_segments_
000014 n_blocks                    get_temp_segments_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 308  000100 treq                        begin block on line 308
                         000110 req                         begin block on line 308
                         000110 nreq                        begin block on line 308
                         000111 all_sw                      begin block on line 308
                         000112 i                           begin block on line 308
                         000113 j                           begin block on line 308
                         000114 cnt                         begin block on line 308
                         000115 dup_sw                      begin block on line 308
get_temp_segments_       000100 max_length                  get_temp_segments_
                         000102 new_block_ptr               get_temp_segments_
                         000104 caller                      get_temp_segments_
                         000114 array_ptr                   get_temp_segments_
                         000116 j                           get_temp_segments_
                         000117 n_segs                      get_temp_segments_
                         000120 new_blocks                  get_temp_segments_
                         000121 i                           get_temp_segments_
                         000122 n_found                     get_temp_segments_
                         000123 old_blocks                  get_temp_segments_
                         000124 code                        get_temp_segments_
                         000125 ename                       get_temp_segments_
                         000132 ename2                      get_temp_segments_
                         000142 segment_number              get_temp_segments_
                         000143 found_it                    get_temp_segments_
                         000144 arg_count                   get_temp_segments_
                         000146 arg_list_ptr                get_temp_segments_
                         000150 arg_ptr                     get_temp_segments_
                         000152 arg_len                     get_temp_segments_
                         000153 bootload_sw                 get_temp_segments_
                         000166 i                           get_new_segments
                         000167 j                           get_new_segments

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     enter_begin_block   leave_begin_block   call_ext_out_desc   call_ext_out
return_mac          tra_ext_1           alloc_auto_adj      shorten_stack       ext_entry           ext_entry_desc
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel
get_system_free_area_         hcs_$chname_seg               hcs_$delentry_seg             hcs_$get_max_length_seg
hcs_$make_seg                 hcs_$set_max_length_seg       hcs_$set_safety_sw_seg        hcs_$truncate_seg
ioa_                          slt_manager$get_seg_ptr       unique_bits_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$badopt           error_table_$illegal_activation
sys_info$max_seg_size         sys_info$service_system




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000116       130 000135       131 000144       133 000147       135 000153       136 000161       137 000162
    138 000163       139 000167       140 000171       141 000177       142 000207       143 000210       144 000211
    147 000212       148 000224       149 000234       150 000236       151 000242       152 000243       154 000251
    155 000253       156 000256       157 000263       158 000265       160 000277       162 000306       163 000317
    164 000321       165 000324       166 000326       169 000327       226 000330       231 000347       232 000351
    233 000354       235 000355       238 000372       239 000402       241 000405       243 000411       244 000417
    245 000420       246 000427       247 000435       248 000436       249 000451       250 000460       252 000471
    255 000502       256 000504       258 000517       260 000523       261 000540       262 000544       263 000550
    266 000566       270 000572       272 000576       273 000602       274 000606       278 000610       279 000612
    281 000620       282 000622       285 000623       288 000640       289 000642       290 000645       293 000646
    296 000654       297 000657       298 000675       301 000676       302 000706       303 000710       304 000730
    306 000731       308 000740       311 000743       317 000755       318 000756       319 000757       320 000767
    322 001007       326 001037       327 001074       328 001077       331 001100       332 001101       333 001104
    334 001113       335 001125       336 001127       337 001131       338 001132       341 001141       343 001143
    344 001145       345 001147       346 001177       350 001202       351 001204       352 001205       353 001215
    354 001225       355 001227       356 001262       358 001263       359 001264       360 001275       362 001313
    363 001333       364 001335       365 001337       368 001367       369 001377       370 001401       371 001407
    373 001411       374 001417       375 001435       377 001437       378 001440       380 001504       382 001506
    383 001517       384 001520       388 001521       397 001531       398 001542       399 001545       402 001546
    403 001556       404 001561       405 001571       406 001603       408 001605       171 001606       176 001607
    177 001621       178 001626       179 001632       180 001635       181 001675       182 001712       183 001721
    184 001723       185 001724       187 001725       189 001726       190 001764       191 001770       192 002032
    193 002034       194 002035       196 002036       197 002045       198 002053       199 002065       200 002067
    201 002122       202 002124       203 002125       206 002126       209 002145       210 002155       211 002156
    212 002165       225 002167       214 002170       217 002171       218 002174       219 002177       221 002213
    222 002226       224 002230


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
