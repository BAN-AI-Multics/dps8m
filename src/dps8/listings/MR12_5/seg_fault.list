	COMPILATION LISTING OF SEGMENT seg_fault
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1021.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 seg_fault: proc (a_mcptr);
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(86-08-09,GDixon), approve(86-08-09,MCR7388),
       19*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
       20*     Document restrictions placed upon future callers of
       21*     seg_fault$makeknown_activate.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 /*
       25*    1/85 by Keith Loepere to audit logical volume full conditions.
       26*   10/84 by Keith Loepere to move access computations into dc_find, also to
       27*         avoid dir unlocking/locking during makeknown_activates.
       28*   07/84 by Keith Loepere for the new dc_find.
       29*   09/83 by E. N. Kittlitz to ignore per-process 256K switch for dirs.
       30*   02/83 by E. N. Kittlitz for 256K segments.
       31*   02/82 by J. Bongiovanni to eliminate use of FSDCT.
       32*   01/82 by Benson I. Margulies, to give initializer segbusteds.
       33*   08/81 by W. Olin Sibert, for use of validate_entryp by makeknown_activate,
       34*     to fix confusion caused by (you guessed it) the directory rebuild salvager.
       35*   07/81 by J. Bongiovanni for seg_fault call metering
       36*   04/81 by W. Olin Sibert, for ADP SDWs
       37*   02/81 by E. N. Kittlitz for makeknown_activate entry
       38*   04/77 by THVV for damaged switch and messages
       39*   09/76 by R. Bratt to meter per-process seg_faults
       40*   05/76 by Greenberg for signalling out_of_bounds for 0 max length seg
       41*   03/76 by R. Bratt for gtpd, initiated mode, and user deactivate
       42*   03/76 by R. Bratt to fix kst access setting bug
       43*   02/76 by R. Bratt for private LV stuff
       44*   04/75 by E. Stone to put access info in kst
       45*   04/75 by Andre Bensoussan for the new storage system
       46*   04/75 by R. Bratt for new kst (merge by tvv)
       47*   07/74 by Kobziar to check for security out-of-service
       48*   04/74 by Greenberg for 2 cpu cache
       49*   04/74 by Greenberg for full entry bound mechanism
       50*   02/74 by Greenberg for 6180 cache
       51*   12/73 by Kobziar to set bound only on basis of max_length (drop "a" bit requirement to grow page)
       52*   10/73 by Steve Webber to add KLUDGE for hardcore gate entry bounds.
       53*   08/73 by R.B.Snyder to put in check for illegal segfaults.
       54*
       55*
       56*   seg_fault: Handles all missing segment faults in the system. The segment
       57*   must alreay have a KST entry and seg_fault will as necessary do the following:
       58*   1. Create an AST entry.
       59*   2. Compute the access for the SDW.
       60*   3. Compute the bounds field for the SDW.
       61*   4. Create the trailer for the segment.
       62*
       63*   USAGE: call seg_fault(mc_ptr);
       64*
       65*   1. machine_conditions_ptr pointer		an ITS pointer to the machine conditions
       66*   in which the missing segment fault occured.
       67*
       68*
       69*   makeknown_activate: Called by makeknown_ to activate and connect directories
       70*   rather than deferring this until first reference (as is the case with
       71*   non-directory segments).  This allows activation errors such as
       72*   connection failure to be indicated by status code, causing a
       73*   makeknown_ failure, rather than eventually causing a crawlout due
       74*   to segment fault error.
       75*
       76*   Currently makeknown_ is the only caller of this entrypoint.  Should other
       77*   procedures need to call it in the future, they must meet the following
       78*   requirements:
       79*   
       80*      The caller must have called sum$getbranch or sum$getbranch_root_my to 
       81*      obtain a pointer to the directory entry corresponding to the segment
       82*      (identified by a_kstep) to be activated.  This will lock the directory
       83*      and validate that a_kstep->kste.entryp properly points to the directory
       84*      entry for the segment.  The directory must remain locked until seg_fault
       85*      returns, since seg_fault used kste.entryp.  If the directory were
       86*      unlocked, another processor could move or delete the directory entry out
       87*      from under seg_fault.
       88*
       89*   USAGE: call seg_fault$makeknown_activate (a_kstep, a_code);
       90*
       91*   1. a_kstep pointer to KST entry (input)
       92*   2. a_code status error code (output)
       93*   */
       94 
       95 /* Parameters */
       96 
       97 dcl  a_code			fixed bin (35) parameter;
       98 dcl  a_kstep			pointer parameter;
       99 dcl  a_mcptr			pointer parameter;
      100 
      101 /* Variables */
      102 
      103 dcl  activated_sw			bit (1) aligned;
      104 dcl  audit_eventflags		bit (36) aligned;
      105 dcl  branch_entrypt_bound		bit (14);
      106 dcl  branch_entrypt_sw		bit (1);
      107 dcl  code				fixed bin (35);
      108 dcl  esw				fixed bin;
      109 dcl  lsw				bit (1) aligned;
      110 dcl  lvx				fixed bin (8);
      111 dcl  mode				bit (36) aligned;
      112 dcl  offset			fixed bin (18);
      113 dcl  1 orig_sdwi			aligned like sdw_info automatic;
      114 dcl  pts				fixed bin;
      115 dcl  pw1				fixed bin (17);
      116 dcl  pw2				fixed bin (17);
      117 dcl  ringno			fixed bin;
      118 dcl  sdw_address			fixed bin (26);
      119 dcl  sdw_valid			bit (1) aligned;
      120 dcl  1 sdwi			aligned like sdw_info automatic;
      121 dcl  segno			fixed bin (17);
      122 dcl  segptr			pointer;
      123 dcl  time1			fixed bin (71);
      124 dcl  time2			fixed bin (71);
      125 dcl  tsdw				fixed bin (71);
      126 
      127 /* External */
      128 
      129 dcl  access_operations_$log_vol_full	bit (36) aligned external static;
      130 dcl  active_all_rings_data$stack_base_segno fixed bin (18) external static;
      131 dcl  dseg$			(0:4095) fixed bin (71) external static;
      132 dcl  error_table_$big_seg		fixed bin (35) external static;
      133 dcl  error_table_$boundviol		fixed bin (35) external static;
      134 dcl  error_table_$log_vol_full	fixed bin (35) external static;
      135 dcl  error_table_$mylock		fixed bin (35) external static;
      136 dcl  error_table_$oosw		fixed bin (35) external static;
      137 dcl  error_table_$seg_busted		fixed bin (35) external static;
      138 dcl  error_table_$seg_deleted		fixed bin (35) external static;
      139 dcl  pds$access_authorization		bit (72) aligned ext;
      140 dcl  pds$dstep			bit (18) external static;
      141 dcl  pds$segment_faults		fixed bin (35) external static;
      142 dcl  pds$stacks			(0:7) ptr external static;
      143 dcl  pvt$root_lvid			bit (36) aligned external static;
      144 dcl  sst$cpu_sf_time		fixed bin (71) external static;
      145 dcl  sst$makeknown_activations	fixed bin (35) external static;
      146 dcl  sst$pts			(0:3) fixed bin external static;
      147 dcl  sst$root_astep			pointer external static;
      148 dcl  sst$tfreep			pointer external static;
      149 dcl  sst$total_sf_pf		fixed bin (35) external static;
      150 dcl  sst$total_sf			fixed bin (35) external static;
      151 dcl  sst$seg_fault_calls		fixed bin (35) external static;
      152 dcl  sys_info$seg_size_256K		fixed bin (19) external static;
      153 
      154 /* Entries */
      155 
      156 dcl  access_audit_$log_general	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, char (*), fixed bin (35), ptr, fixed bin (18), char (*));
      157 dcl  activate$activate_long		entry (ptr, bit (1) aligned, fixed bin (35)) returns (ptr);
      158 dcl  get_kstep			entry (fixed bin (17), ptr, fixed bin (35));
      159 dcl  get_ptrs_$given_astep		entry (pointer) returns (fixed bin (71));
      160 dcl  level$get			entry () returns (fixed bin);
      161 dcl  lock$dir_unlock		entry (pointer);
      162 dcl  lock$lock_ast			entry;
      163 dcl  lock$unlock_ast		entry;
      164 dcl  logical_volume_manager$lvtep	entry (bit (36) aligned, ptr, fixed bin (35));
      165 dcl  makestack			entry (fixed bin);
      166 dcl  page$enter_data		entry (fixed bin (17), fixed bin);
      167 dcl  private_logical_volume$lvx	entry (bit (36) aligned, fixed bin (8), fixed bin (35));
      168 dcl  sdw_util_$construct		entry (pointer, pointer);
      169 dcl  sdw_util_$dissect		entry (pointer, pointer);
      170 dcl  sdw_util_$get_address		entry (pointer, fixed bin (26));
      171 dcl  sdw_util_$get_valid		entry (pointer, bit (1) aligned);
      172 dcl  segment_mover			entry (fixed bin (18), ptr, ptr, fixed bin, fixed bin (35));
      173 dcl  setfaults$cache		entry (pointer, bit (1) aligned);
      174 dcl  sum$getbranch_root_my		entry (pointer, bit (36) aligned, pointer, fixed bin (35));
      175 dcl  syserr			entry options (variable);
      176 dcl  thread$lin			entry (pointer, bit (18)); /* Requires bit (18) unal in upper halfword only */
      177 dcl  usage_values			entry (fixed bin (17), fixed bin (71));
      178 
      179 /* Constants */
      180 
      181 dcl  FAULT			fixed bin static internal options (constant) init (0);
      182 dcl  MAKEKNOWN			fixed bin static internal options (constant) init (1);
      183 
      184 /* Miscelaneous */
      185 
      186 dcl  (addr, baseptr, bin, binary, bit, min, null, ptr, rel, string, substr) builtin;
      187 
      188 
      189 /* set initial pointer values */
      190 
      191 	call usage_values (pw1, time1);		/* start metering of seg faults */
      192 	esw = FAULT;
      193 	code = 0;
      194 	kstp = pds$kstp;
      195 	mcp = a_mcptr;
      196 	scup = addr (mc.scu (0));
      197 	mc.errcode = 0;
      198 	ringno = bin (scu.ppr.prr, 3);
      199 
      200 
      201 /* NOW FIND OUT THE SEGMENT NUMBER OF THE FAULTING SEGMENT - IF THE RESTART BIT IN THE SCU
      202*   DATA IS "ON", THE FAULTING SDW IS FOR THE PROCEDURE SEGMENT AND HENCE PSR SHOULD BE USED -
      203*   OTHERWISE, TSR SHOULD BE USED */
      204 
      205 	if scu.cu.if then segno = bin (scu.ppr.psr, 15);
      206 	else segno = bin (scu.tpr.tsr, 15);
      207 
      208 	call sdw_util_$get_valid (addr (dseg$ (segno)), sdw_valid);
      209 	if sdw_valid then do;			/* Fault is a fraud */
      210 	     call syserr (0, "seg_fault: illegal segfault on cpu ^a",
      211 		substr ("ABCDEFGH", bin (scu.cpu_no, 3) + 1, 1)); /* log it and maybe crash */
      212 	     return;				/* rcu the data and try again */
      213 	end;
      214 
      215 	call page$enter_data (segno, (seg_fault_start));	/* enter start of seg_fault in trace */
      216 
      217 	offset = bin (scu.ca, 18);			/* get computed address */
      218 
      219 
      220 /* CHECK FOR FAULT ON STACK SEGMENT */
      221 
      222 	if segno >= active_all_rings_data$stack_base_segno then
      223 	     if segno <= active_all_rings_data$stack_base_segno + 7 then
      224 		if pds$stacks (segno - active_all_rings_data$stack_base_segno) = null then do;
      225 		     call makestack (segno - active_all_rings_data$stack_base_segno); /* Will cause recursive segfault on stack */
      226 		     go to finish;
      227 		end;
      228 
      229 
      230 /* GET KST ENTRY POINTER */
      231 
      232 	segptr = baseptr (segno);			/* make a seg pointer */
      233 	call get_kstep (segno, kstep, code);
      234 	if code ^= 0 then go to err;
      235 
      236 /* GET THE ASTE POINTER - IF IT IS THE ROOT, IT IS ALWAYS ACTIVE AND ITS ASTE POINTER IS IN THE SST -
      237*   IF IT IS NOT THE ROOT, ONE HAS TO FIND THE BRANCH, LOCK THE PARENT AND GET AN ASTE FOR THE SEGMENT IF IT
      238*   DOES NOT HAVE ONE ALREADY. */
      239 
      240 
      241 COMMON:
      242 	if kste.uid = (36)"1"b then do;		/* is this the root */
      243 
      244 /* ROOT */
      245 
      246 	     lsw = "0"b;				/* we won't lock the parent */
      247 	     call lock$lock_ast;
      248 	     if code ^= 0 then go to err;
      249 	     astep = sst$root_astep;			/* this is easy */
      250 	end;
      251 
      252 /* NOT THE ROOT */
      253 
      254 	else do;
      255 	     if esw = MAKEKNOWN then lsw = "0"b;	/* guaranteed to be a locked directory */
      256 
      257 	     else do;				/* normal seg_fault */
      258 
      259 /* sum must be called here, not in dc_find.  This is because sum may take a
      260*(recursive) seg_fault on the parent directory.  dc_find has too big a stack
      261*frame to allow it to come into play in these recursive seg_fault occurences. */
      262 
      263 		lsw = "0"b;
      264 		call sum$getbranch_root_my (segptr, "0"b, ep, code);
      265 		if code = 0 then lsw = "1"b;
      266 		else if code = error_table_$mylock then code = 0;
      267 		else if code = error_table_$seg_deleted then do;
      268 		     dp, ep = null;
      269 		     go to seg_audit;
      270 		end;
      271 		else go to err;
      272 		dp = ptr (ep, 0);
      273 
      274 /* Parent is guaranteed to be in service if we got this far.
      275*   Make sure the entry is still in service. */
      276 
      277 		if entry.security_oosw then
      278 		     if ^addr (pds$access_authorization) -> aim_template.privileges.soos then do;
      279 			code = error_table_$oosw;
      280 			go to err1;
      281 		     end;
      282 
      283 		if ^entry.dirsw then do;		/* compute access (dirs are special cased later) */
      284 seg_audit:	     call dc_find$seg_fault (kstep, ep, code);
      285 		     if code ^= 0 then go to err1;
      286 		end;
      287 	     end;
      288 
      289 	     if ^kste.dirsw then do;
      290 
      291 /* COPY FROM BRANCH THOSE ITEMS THAT WILL BE NEEDED AFTER AST IS LOCKED
      292*   SO THAT DIRECTORIES ARE NEVER REFERENCED WHILE THE AST IS LOCKED */
      293 
      294 		branch_entrypt_bound = entry.entrypt_bound;
      295 		branch_entrypt_sw = entry.entrypt_sw;
      296 
      297 	     end;
      298 
      299 /* MAKE SURE ITS LOGICALLY MOUNTED FOR THIS PROCESS (NOT NECESSARILY PHYSICALLY MOUNTED)
      300*   TO AVOID PAGE FAULTS ON DIR HEADER AND LVT SEVERAL TESTS ARE MADE WHERE ONE WOULD DO */
      301 
      302 	     if ^kste.dirsw then			/* not a dir which would be on RLV and hence public */
      303 		if kste.infcount = 0 then		/* not marked as privately mounted */
      304 		     if (entry.sons_lvid ^= pvt$root_lvid) |
      305 			entry.master_dir then do;	/* cant prove its on RLV and hence public */
      306 						/* oh well, time for the definitive test */
      307 			call logical_volume_manager$lvtep (dir.sons_lvid, lvtep, code);
      308 			if code ^= 0 then goto err1;	/* sorry, no such LV */
      309 			if ^lvte.public then do;	/* LV not public so check for private mount */
      310 			     call private_logical_volume$lvx (dir.sons_lvid, lvx, code);
      311 			     if code ^= 0 then goto err1; /* sorry, not privately mounted */
      312 			     kste.infcount = lvx;	/* remember that it was privately mounted */
      313 			end;
      314 		     end;
      315 
      316 	     astep = activate$activate_long (ep, activated_sw, code); /* Returns with AST locked if OK */
      317 	     if code ^= 0 then go to err1;
      318 
      319 	     if esw = MAKEKNOWN then			/* meter ? */
      320 		if activated_sw then
      321 		     sst$makeknown_activations = sst$makeknown_activations + 1;
      322 	end;
      323 
      324 /* ARE THERE PAGE_CONTROL INDUCED EXCEPTION CONDITIONS ON SEGMENT ? */
      325 
      326 	if aste.damaged & ^kste.dirsw then do;
      327 	     code = error_table_$seg_busted;
      328 	     go to err0;
      329 	end;
      330 
      331 /* IS THERE A PER-PROCESS SIZE LIMITATION (256K) ? */
      332 
      333 	if ^kst.allow_256K_connect & ^kste.dirsw then	/* dir should never be 256K, but don't enforce it here */
      334 	     if bin (aste.msl, 9) * 1024 >= sys_info$seg_size_256K then do;
      335 		code = error_table_$big_seg;
      336 		go to err0;
      337 	     end;
      338 
      339 /* MAKE SURE THE REFERENCE IS NOT OUT OF BOUNDS */
      340 
      341 	if offset >= bin (aste.msl, 9) * 1024 then do;	/* NEVER for MAKENOWN, remember */
      342 	     code = error_table_$boundviol;
      343 	     mc.resignal = "1"b;			/* New signal code */
      344 	     mc.fcode = bit (bin (out_of_bounds_sct_index, 17), 17);
      345 	     go to err0;
      346 	end;
      347 
      348 
      349 /* SEE IF SEG MUST BE MOVED TO ANOTHER PV. CALL SEG MOVER IF SO.  
      350*   If this is MAKEKNOWN entry, then makeknown_ will either (horrors) get
      351*   a segment_mover error, or the process will just take a typical seg_fault */
      352 
      353 	if aste.pack_ovfl then do;			/* Out of PV */
      354 	     call segment_mover (offset, astep, ep, segno, code);
      355 	     if code = error_table_$log_vol_full then do;
      356 		audit_eventflags = "0"b;
      357 		addr (audit_eventflags) -> audit_event_flags.cc_1_10 = "1"b;
      358 		call access_audit_$log_general ("seg_fault", level$get (), audit_eventflags, access_operations_$log_vol_full, "", code, null, 0, "");
      359 	     end;
      360 	     go to err1;				/* He unlocked the AST. Signal or retry */
      361 						/* as code is or is not 0 */
      362 	end;
      363 
      364 
      365 
      366 /* DOES THE PROCESS ALREADY HAVE A TRAILER FOR THIS SEGMENT */
      367 
      368 MAKE_TRAILER:
      369 	pts = sst$pts (bin (aste.ptsi, 3));		/* get page table size actually awarded */
      370 
      371 	call sdw_util_$get_address (addr (dseg$ (segno)), sdw_address);
      372 	if sdw_address = 0 then do;			/* Add a trailer if not connected */
      373 	     if rel (sst$tfreep) = ""b then
      374 		call syserr (1, "seg_fault: trailer storage area exhausted");
      375 
      376 	     strp = sst$tfreep;			/* Get pointer to first free trailer */
      377 	     if str.fp = "0"b then call syserr (1, "seg_fault: trailer list trap"); /* TRAP */
      378 	     sst$tfreep = ptr (strp, str.fp);		/* (setq tfreep (cdr tfreep)) */
      379 	     str.segno = bit (bin (segno, 18), 18);	/* Fill in the new trailer */
      380 	     str.dstep = pds$dstep;			/* ditto */
      381 	     str.fp, str.bp = "0"b;			/* ditto */
      382 	     call thread$lin (strp, aste.strp);		/* Thread the new trailer in */
      383 
      384 	     aste.gtus = aste.gtus & kste.tus;
      385 	     aste.gtms = aste.gtms & kste.tms;
      386 	     aste.explicit_deact_ok = aste.explicit_deact_ok & kste.explicit_deact_ok;
      387 	end;
      388 
      389 
      390 /* PREPARE A COPY OF THE SDW FOR THIS SEGMENT */
      391 
      392 	tsdw = get_ptrs_$given_astep (astep);		/* get sdw for this astep */
      393 	call sdw_util_$dissect (addr (tsdw), addr (sdwi));/* and prepare to modify it appropriately */
      394 
      395 	if kste.dirsw then do;
      396 
      397 /* DIR */
      398 
      399 	     string (sdwi.access) = "1010"b;		/* access in ring 0 RW with rb of 0,0,0 */
      400 	     sdwi.cache = "0"b;			/* directories not allowed in cache due to
      401*						   use of abs-segs at deactivation time */
      402 	end;
      403 
      404 /* SEG */
      405 
      406 	else do;
      407 	     call sdw_util_$dissect (addr (dseg$ (segno)), addr (orig_sdwi)); /* Get info from the current SDW */
      408 						/* This is where access & rings are stored betweentimes */
      409 
      410 /* COMPUTE ACCESS FIELD */
      411 
      412 	     string (sdwi.access) = string (orig_sdwi.access);
      413 	     mode = substr (string (orig_sdwi.access), 1, 3);
      414 	     string (sdwi.rings) = string (orig_sdwi.rings);
      415 	     if branch_entrypt_sw then		/* Set the entry bound */
      416 		sdwi.gate_entry_bound = binary (branch_entrypt_bound) + 1;
      417 						/* sdw_info is # of entrypoints, not max offset */
      418 
      419 /* COMPUTE ENCACHEABILITY OF SEGMENT - ASTEP IS VALID SINCE AST IS LOCKED */
      420 
      421 	     sdwi.cache = "1"b;			/* assume encacheability at first */
      422 						/* This will be ignored on the ADP */
      423 	     if aste.any_access_on then		/* if there is either one SDW or only
      424*						   read-permit SDW's */
      425 		if substr (mode, 3, 1) |		/* and we are adding write access */
      426 		     aste.write_access_on then do;	/* or there is 1 write SDW */
      427 						/* We mut take seg out of cache */
      428 		     call setfaults$cache (astep, "0"b);/* hit cache bits */
      429 		     sdwi.cache = "0"b;		/* we will not encache either */
      430 		     aste.any_access_on = "0"b;	/* inhibit further checks */
      431 		end;
      432 		else ;				/* adding 1 more read-only SDW */
      433 						/* any_access_on is off -
      434*						   could already be out of cache */
      435 	     else if aste.write_access_on then		/* is out of cache */
      436 		sdwi.cache = "0"b;
      437 	     else aste.any_access_on = "1"b;
      438 
      439 	     aste.write_access_on = aste.write_access_on | substr (mode, 3, 1);
      440 						/* indicate write access on */
      441 	end;
      442 
      443 	sdwi.size = min (pts, bin (aste.msl, 9)) * 1024;	/* set bound */
      444 
      445 /* STORE THE COPY OF THE SDW IN THE REAL SDW - UNLOCK THE AST - UNLOCK THE PARENT IF REQUIRED */
      446 
      447 	call sdw_util_$construct (addr (dseg$ (segno)), addr (sdwi)); /* Put the SDW back */
      448 
      449 err0:	call lock$unlock_ast;
      450 
      451 err1:	if lsw then call lock$dir_unlock (dp);		/* Unlock the directory */
      452 
      453 err:
      454 
      455 	call usage_values (pw2, time2);		/* get final value for seg fault metering */
      456 	sst$cpu_sf_time = sst$cpu_sf_time + time2 - time1;
      457 	sst$total_sf_pf = sst$total_sf_pf + pw2 - pw1;
      458 	sst$total_sf = sst$total_sf + 1;
      459 	pds$segment_faults = pds$segment_faults + 1;
      460 	if esw = MAKEKNOWN then do;
      461 	     sst$seg_fault_calls = sst$seg_fault_calls + 1;
      462 	     a_code = code;
      463 	     return;
      464 	end;
      465 
      466 	mc.errcode = code;
      467 
      468 finish:	call page$enter_data (segno, (seg_fault_end));	/* enter finish of seg_fault in trace */
      469 	return;
      470 
      471 makeknown_activate: entry (a_kstep, a_code);
      472 
      473 	call usage_values (pw1, time1);
      474 	esw = MAKEKNOWN;				/* our humble beginnings */
      475 	kstp = pds$kstp;
      476 	code = 0;
      477 	mcp = null;				/* trap bad reference */
      478 	scup = null;				/* ... */
      479 	ringno = 0;				/* why not ? */
      480 	offset = -1;				/* lower than lowest max seg length */
      481 	kstep = a_kstep;				/* do quick what takes normal entry sooo long */
      482 	ep = kste.entryp;
      483 	dp = ptr (ep, 0);
      484 	segno = kste.segno;
      485 	segptr = baseptr (segno);
      486 	go to COMMON;
      487  /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
      487 
      488  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  2     2 
  2     3 /* Created 740723 by PG */
  2     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  2     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  2     6 
  2     7 /* This structure defines the components of both an access
  2     8*   class and an access authorization as interpreted by the
  2     9*   Access Isolation Mechanism. */
  2    10 
  2    11 
  2    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  2    13        2 categories bit (36),				/* access categories */
  2    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  2    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  2    16         (3 ipc,					/* interprocess communication privilege */
  2    17          3 dir,					/* directory privilege */
  2    18          3 seg,					/* segment privilege */
  2    19          3 soos,					/* security out-of-service privilege */
  2    20          3 ring1,					/* ring 1 access privilege */
  2    21          3 rcp,					/* RCP resource access privilege */
  2    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  2    23          3 pad bit (11);
  2    24 
  2    25 
  2    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      488 
      489  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      489 
      490  /* BEGIN include file dc_find_dcls.incl.pl1 */
  4     2 
  4     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  4     4 /* Added a few more, October 1984. */
  4     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  4     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  4     7 
  4     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  4     9 
  4    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  4    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  4    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  4    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  4    14 
  4    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  4    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  4    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  4    18 
  4    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  4    20 
  4    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  4    22 
  4    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  4    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  4    25 
  4    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  4    27 
  4    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  4    29 
  4    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  4    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  4    32 
  4    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  4    34 
  4    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  4    36 
  4    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  4    38 
  4    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  4    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  4    41 
  4    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  4    44 
  4    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  4    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  4    47 
  4    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  4    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  4    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  4    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  4    52 
  4    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  4    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  4    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  4    58 
  4    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  4    60 
  4    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  4    62 
  4    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  4    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  4    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  4    66 
  4    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  4    68 
  4    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  4    70 
  4    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  4    72 
  4    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    74 
  4    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  4    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  4    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  4    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  4    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  4    82 
  4    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  4    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  4    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  4    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  4    87 
  4    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  4    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  4    90 
  4    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  4    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  4    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  4    94 
  4    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  4    96 
  4    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  4    98 
  4    99 /* END include file dc_find_dcls.incl.pl1 */
      490 
      491  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  5     2 
  5     3 
  5     4 /* Template for an entry. Length = 38 words */
  5     5 
  5     6 dcl  ep ptr;
  5     7 
  5     8 dcl 1 entry based (ep) aligned,
  5     9 
  5    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  5    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  5    12 
  5    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  5    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  5    15 
  5    16     2 uid bit (36),					/* unique id of entry */
  5    17 
  5    18     2 dtem bit (36),				/* date-time entry modified */
  5    19 
  5    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  5    21     2 pad0 bit (17),
  5    22     2 nnames fixed bin (17),				/* number of names for this entry */
  5    23 
  5    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  5    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  5    26 
  5    27     2 author,					/* user who created branch */
  5    28       3 pers_rp bit (18),				/* name of user who created branch */
  5    29       3 proj_rp bit (18),				/* project of user who created branch */
  5    30 
  5    31       3 tag char (1),				/* tag of user who created branch */
  5    32       3 pad1 char (3),
  5    33 
  5    34     2 primary_name bit (504),				/* first name on name list */
  5    35 
  5    36     2 dtd bit (36),					/* date time dumped */
  5    37 
  5    38     2 pad2 bit (36),
  5    39 
  5    40 
  5    41 /* the declarations below are for branch only */
  5    42 
  5    43 
  5    44     2 pvid bit (36),				/* physical volume id */
  5    45 
  5    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  5    47     2 pad3 bit (18),
  5    48 
  5    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  5    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  5    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  5    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  5    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  5    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  5    55     2 audit_flag bit (1),				/* segment must be audited for security */
  5    56     2 security_oosw bit (1),				/* security out of service switch */
  5    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  5    58     2 master_dir bit (1),				/* TRUE for master directory */
  5    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  5    60     2 pad4 bit (11),
  5    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  5    62 
  5    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  5    64 
  5    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  5    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  5    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  5    68 
  5    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  5    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  5    71 
  5    72     2 bc_author,					/* user who last set the bit count */
  5    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  5    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  5    75 
  5    76       3 tag char (1),				/* tag of user who set the bit count */
  5    77       3 pad5 bit (2),
  5    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  5    79 
  5    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  5    81 
  5    82     2 pad6 bit (36),
  5    83 
  5    84     2 checksum bit (36),				/* checksum from dtd */
  5    85 
  5    86     2 owner bit (36);				/* uid of containing directory */
  5    87 
  5    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      491 
      492  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  6     2 /* Modified 8/74 for NSS */
  6     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  6     4 /* Modified 3/82 BIM for change pclock */
  6     5 /* format: style3 */
  6     6 
  6     7 /* Template for the directory header. Length = 64 words. */
  6     8 
  6     9 dcl  dp ptr;
  6    10 
  6    11 dcl 1 dir based (dp) aligned,
  6    12 
  6    13    2 modify bit (36),				/* Process ID of last modifier */
  6    14    2 type bit (18) unaligned,			/* type of object = dir header */
  6    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  6    16     2 dtc (3),					/* date-time checked by salvager array */
  6    17       3 date bit (36),				/* the date */
  6    18       3 error bit (36),				/* what errors were discovered */
  6    19 
  6    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  6    21 
  6    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  6    23 
  6    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  6    25 
  6    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  6    27 
  6    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  6    29     2 version_number fixed bin (17),			/* version number of header */
  6    30 
  6    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  6    32     2 pad2 bit (18),
  6    33 
  6    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  6    35     2 pad3 bit (18),
  6    36 
  6    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  6    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  6    39 
  6    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  6    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  6    42 
  6    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  6    44     2 dir_count fixed bin (17),			/* number of directory branches */
  6    45 
  6    46     2 lcount fixed bin (17),				/* number of links */
  6    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  6    48 
  6    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  6    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  6    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  6    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  6    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  6    54     2 pad4 bit (14),
  6    55 
  6    56     2 iacl_count (0:7),
  6    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  6    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  6    59 
  6    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  6    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  6    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  6    63 
  6    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  6    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  6    66 
  6    67     2 htsize fixed bin (17),				/* size of hash table */
  6    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  6    69 
  6    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  6    71     2 pad6 fixed bin (17),
  6    72 
  6    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  6    74     2 pad7 bit (18)) unaligned,
  6    75 
  6    76     2 dts bit (36),					/* date-time directory last salvaged */
  6    77 
  6    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  6    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  6    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  6    81     2 checksum bit (36),				/* checksummed from uid on */
  6    82     2 owner bit (36);				/* uid of parent dir */
  6    83 
  6    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  6    85 
  6    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      492 
      493  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  7     2 
  7     3 /*
  7     4*Modified March 1976 by R. Bratt 
  7     5*Modified November 1984 to remove hdr, Keith Loepere. */
  7     6 
  7     7 
  7     8 /****^  HISTORY COMMENTS:
  7     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  7    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  7    11*     Add warning on use of kste.entryp.
  7    12*                                                   END HISTORY COMMENTS */
  7    13 
  7    14 
  7    15 dcl  pds$kstp ext ptr,
  7    16     (kstp, kstep) ptr;
  7    17 
  7    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  7    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  7    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  7    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  7    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  7    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  7    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  7    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  7    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  7    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  7    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  7    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  7    30     2 unused_2 bit (9) unaligned,
  7    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  7    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  7    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  7    34     2 end_of_kst bit (36);
  7    35 
  7    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  7    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  7    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  7    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  7    40     2 entryp ptr unaligned,				/* branch pointer */
  7    41 						/* See WARNING below for requirements to use entryp. */
  7    42     2 uid bit (36) aligned,				/* unique identifier */
  7    43     2 access_information unaligned,
  7    44       3 dtbm bit (36),				/* date time branch modified */
  7    45       3 extended_access bit (33),			/* extended access from the branch */
  7    46       3 access bit (3),				/* rew */
  7    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  7    48     2 pad1 bit (3) unaligned,
  7    49     2 flags unaligned,
  7    50       3 dirsw bit (1),				/* directory switch */
  7    51       3 allow_write bit (1),				/* set if initiated with write permission */
  7    52       3 priv_init bit (1),				/* privileged initiation */
  7    53       3 tms bit (1),				/* transparent modification switch */
  7    54       3 tus bit (1),				/* transparent usage switch */
  7    55       3 tpd bit (1),				/* transparent paging device switch */
  7    56       3 audit bit (1),				/* audit switch */
  7    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  7    58       3 pad bit (3),
  7    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  7    60 
  7    61 
  7    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    63 /*							       */
  7    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  7    65 /* entry associated with the kst entry, you must first validate its value    */
  7    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  7    67 /* the containing directory.  The containing directory must remain locked    */
  7    68 /* during the entire period when kste.entryp and the directory entry are     */
  7    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  7    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  7    71 /* directory since the dir entry could have been moved within the directory  */
  7    72 /* by another processor.					       */
  7    73 /*							       */
  7    74 /* If you only need a pointer to the directory containing the associated     */
  7    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  7    76 /*    pointer (kste.entryp, 0)				       */
  7    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  7    78 /*							       */
  7    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    80 
  7    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      493 
      494  /* BEGIN INCLUDE FILE lvt.incl.pl1 -- Written Jan. 1976 by R. Bratt       */
  8     2 /*
  8     3*   This include file defines the format of the hardcore L_ogical V_olume T_able (LVT).
  8     4**/
  8     5 
  8     6 dcl  lvt$ ext;
  8     7 dcl  lvtp ptr;
  8     8 dcl  lvtep ptr;
  8     9 
  8    10 dcl 1 lvt aligned based (lvtp),
  8    11     2 max_lvtex fixed bin (17),			/* maximum number of LVs describable */
  8    12     2 high_water_lvtex fixed bin (17),			/* highest LVT index assigned */
  8    13     2 free_lvtep ptr,				/* pointer to  first free lvte  */
  8    14     2 pad1 (4) bit (36),
  8    15     2 ht (0:63) ptr unal,				/* lvid hash table */
  8    16     2 lvtes (1:1 refer (lvt.max_lvtex)) like lvte;	/* LVT entries */
  8    17 
  8    18 dcl 1 lvte aligned based (lvtep),			/* logical volume table entry */
  8    19     2 lvtep ptr unaligned,				/* lvid hash thread */
  8    20     2 pvtex fixed bin (17),				/* thread of mounted PVs */
  8    21     2 lvid bit (36),				/* logical volume id */
  8    22     2 access_class aligned,				/* access isolation mechanism stuff */
  8    23       3 min bit (72),				/* minimum access class allowed on LV */
  8    24       3 max bit (72),				/* maximum access class allowed on volume */
  8    25     2 flags unaligned,				/* flags */
  8    26       3 public bit (1),				/* => anyone can connect to this LV */
  8    27       3 read_only bit (1),				/* => no writes on this LV */
  8    28       3 pad bit (16),
  8    29       3 cycle_pvtx fixed bin (17);			/* pvtx for next per_process seg */
  8    30 
  8    31 /* END INCLUDE FILE lvt.incl.pl1                                                    */
      494 
      495  /*  */
  9     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  9     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  9     4 /* Modified 07/07/76 by Morris for fault register data */
  9     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  9     6 /* Modified '82 to make values constant */
  9     7 
  9     8 /* words 0-15 pointer registers */
  9     9 
  9    10 dcl  mcp ptr;
  9    11 
  9    12 dcl 1 mc based (mcp) aligned,
  9    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  9    14    (2 regs,					/* registers */
  9    15       3 x (0:7) bit (18),				/* index registers */
  9    16       3 a bit (36),					/* accumulator */
  9    17       3 q bit (36),					/* q-register */
  9    18       3 e bit (8),					/* exponent */
  9    19       3 pad1 bit (28),
  9    20       3 t bit (27),					/* timer register */
  9    21       3 pad2 bit (6),
  9    22       3 ralr bit (3),				/* ring alarm register */
  9    23 
  9    24     2 scu (0:7) bit (36),
  9    25 
  9    26     2 mask bit (72),				/* mem controller mask at time of fault */
  9    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  9    28     2 errcode fixed bin (35),				/* fault handler's error code */
  9    29     2 fim_temp,
  9    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  9    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  9    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  9    33     2 fault_reg bit (36),				/* fault register */
  9    34     2 pad2 bit (1),
  9    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  9    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  9    37     2 fault_time bit (54),				/* time of fault */
  9    38 
  9    39     2 eis_info (0:7) bit (36)) unaligned;
  9    40 
  9    41 
  9    42 dcl (apx fixed bin init (0),
  9    43      abx fixed bin init (1),
  9    44      bpx fixed bin init (2),
  9    45      bbx fixed bin init (3),
  9    46      lpx fixed bin init (4),
  9    47      lbx fixed bin init (5),
  9    48      spx fixed bin init (6),
  9    49      sbx fixed bin init (7)) internal static options (constant);
  9    50 
  9    51 
  9    52 
  9    53 
  9    54 dcl  scup ptr;
  9    55 
  9    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  9    57 
  9    58 
  9    59 /*	WORD (0)		*/
  9    60 
  9    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  9    62       3 prr bit (3),				/* procedure ring register */
  9    63       3 psr bit (15),				/* procedure segment register */
  9    64       3 p bit (1),					/* procedure privileged bit */
  9    65 
  9    66     2 apu,					/* APPENDING UNIT STATUS */
  9    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  9    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  9    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  9    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  9    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  9    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  9    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  9    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  9    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  9    76       3 ptw bit (1),				/* Fetch of PTW */
  9    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  9    78       3 fap bit (1),				/* Fetch of final address paged */
  9    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  9    80       3 fabs bit (1),				/* Fetch of final address absolute */
  9    81 
  9    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  9    83 
  9    84 
  9    85 /*	WORD (1)		*/
  9    86 
  9    87     2 fd,						/* FAULT  DATA */
  9    88       3 iro bit (1),				/* illegal ring order */
  9    89       3 oeb bit (1),				/* out of execute bracket */
  9    90       3 e_off bit (1),				/* no execute */
  9    91       3 orb bit (1),				/* out of read bracket */
  9    92       3 r_off bit (1),				/* no read */
  9    93       3 owb bit (1),				/* out of write bracket */
  9    94       3 w_off bit (1),				/* no write */
  9    95       3 no_ga bit (1),				/* not a gate */
  9    96       3 ocb bit (1),				/* out of call bracket */
  9    97       3 ocall bit (1),				/* outward call */
  9    98       3 boc bit (1),				/* bad outward call */
  9    99       3 inret bit (1),				/* inward return */
  9   100       3 crt bit (1),				/* cross ring transfer */
  9   101       3 ralr bit (1),				/* ring alarm register */
  9   102       3 am_er bit (1),				/* associative memory fault */
  9   103       3 oosb bit (1),				/* out of segment bounds */
  9   104       3 paru bit (1),				/* processor parity upper */
  9   105       3 parl bit (1),				/* processor parity lower */
  9   106       3 onc_1 bit (1),				/* op not complete type 1 */
  9   107       3 onc_2 bit (1),				/* op not complete type 2 */
  9   108 
  9   109     2 port_stat,					/* PORT  STATUS */
  9   110       3 ial bit (4),				/* illegal action lines */
  9   111       3 iac bit (3),				/* illegal action channel */
  9   112       3 con_chan bit (3),				/* connect channel */
  9   113 
  9   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  9   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  9   116 
  9   117 
  9   118 /*	WORD (2)		*/
  9   119 
  9   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  9   121       3 trr bit (3),				/* temporary ring register */
  9   122       3 tsr bit (15),				/* temporary segment register */
  9   123 
  9   124     2 pad2 bit (9),
  9   125 
  9   126     2 cpu_no bit (3),				/* CPU number */
  9   127 
  9   128     2 delta bit (6),				/* tally modification DELTA */
  9   129 
  9   130 
  9   131 /*	WORD (3)		*/
  9   132 
  9   133     2 word3 bit (18),
  9   134 
  9   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  9   136       3 tsna,					/* Word 1 status */
  9   137         4 prn bit (3),				/* Word 1  PR  number */
  9   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  9   139       3 tsnb,					/* Word 2  status */
  9   140         4 prn bit (3),				/* Word 2  PR  number */
  9   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  9   142       3 tsnc,					/* Word 3  status */
  9   143         4 prn bit (3),				/* Word 3  PR  number */
  9   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  9   145 
  9   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  9   147 
  9   148 
  9   149 /* 	WORD (4)		*/
  9   150 
  9   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  9   152 
  9   153     2 ir,						/* INDICATOR  REGISTERS */
  9   154       3 zero bit (1),				/* zero indicator */
  9   155       3 neg bit (1),				/* negative indicator */
  9   156       3 carry bit (1),				/* carryry indicator */
  9   157       3 ovfl bit (1),				/* overflow indicator */
  9   158       3 eovf bit (1),				/* eponent overflow */
  9   159       3 eufl bit (1),				/* exponent underflow */
  9   160       3 oflm bit (1),				/* overflow mask */
  9   161       3 tro bit (1),				/* tally runout */
  9   162       3 par bit (1),				/* parity error */
  9   163       3 parm bit (1),				/* parity mask */
  9   164       3 bm bit (1),					/* ^bar mode */
  9   165       3 tru bit (1),				/* truncation mode */
  9   166       3 mif bit (1),				/* multi-word instruction mode */
  9   167       3 abs bit (1),				/* absolute mode */
  9   168       3 hex bit (1),				/* hexadecimal exponent mode */
  9   169       3 pad bit (3),
  9   170 
  9   171 
  9   172 /*	WORD (5)		*/
  9   173 
  9   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  9   175 
  9   176     2 cu,						/* CONTROL UNIT STATUS */
  9   177       3 rf bit (1),					/* on first cycle of repeat instr */
  9   178       3 rpt bit (1),				/* repeat instruction */
  9   179       3 rd bit (1),					/* repeat double instruction */
  9   180       3 rl bit (1),					/* repeat link instruciton */
  9   181       3 pot bit (1),				/* IT  modification */
  9   182       3 pon bit (1),				/* return type instruction */
  9   183       3 xde bit (1),				/* XDE from Even location */
  9   184       3 xdo bit (1),				/* XDE from Odd  location */
  9   185       3 poa bit (1),				/* operation preparation */
  9   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  9   187       3 its bit (1),				/* ITS modification */
  9   188       3 if bit (1),					/* fault occured during instruction fetch */
  9   189 
  9   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  9   191 
  9   192 
  9   193 /*	WORDS (6,7)	*/
  9   194 
  9   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  9   196 
  9   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  9   198 
  9   199 
  9   200 
  9   201 
  9   202 
  9   203 
  9   204 /*	ALTERNATE   SCU  DECLARATION		*/
  9   205 
  9   206 
  9   207 dcl 1 scux based (scup) aligned,
  9   208 
  9   209    (2 pad0 bit (36),
  9   210 
  9   211     2 fd,						/* GROUP II  FAULT DATA */
  9   212       3 isn bit (1),				/* illegal segment number */
  9   213       3 ioc bit (1),				/* illegal op  code  */
  9   214       3 ia_am bit (1),				/* illegal address - modifier */
  9   215       3 isp bit (1),				/* illegal slave  procedure */
  9   216       3 ipr bit (1),				/* illegal procedure */
  9   217       3 nea bit (1),				/* non existent address */
  9   218       3 oobb bit (1),				/* out of bounds */
  9   219       3 pad bit (29),
  9   220 
  9   221     2 pad2 bit (36),
  9   222 
  9   223     2 pad3a bit (18),
  9   224 
  9   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  9   226       3 prn bit (3),				/* PR  number */
  9   227       3 prv bit (1),				/* PR  valid bit */
  9   228 
  9   229     2 pad3b bit (6)) unaligned,
  9   230 
  9   231     2 pad45 (0:1) bit (36),
  9   232 
  9   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  9   234 
  9   235 
  9   236 
  9   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      495 
      496  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
 10     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 10     3 
 10     4 dcl  sdw_info_ptr pointer;
 10     5 
 10     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
 10     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
 10     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
 10     9 
 10    10     2 access unaligned,				/* REWP */
 10    11       3 read bit (1) unaligned,
 10    12       3 execute bit (1) unaligned,
 10    13       3 write bit (1) unaligned,
 10    14       3 privileged bit (1) unaligned,
 10    15 
 10    16     2 pad1 bit (32) unaligned,
 10    17 
 10    18     2 rings unaligned,				/* Ring brackets */
 10    19       3 r1 bit (3) unaligned,
 10    20       3 r2 bit (3) unaligned,
 10    21       3 r3 bit (3) unaligned,
 10    22 
 10    23     2 pad2 bit (27) unaligned,
 10    24 
 10    25     2 flags aligned,
 10    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
 10    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
 10    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
 10    29       3 pad3 bit (33) unaligned,
 10    30 
 10    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
 10    32 
 10    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
      496 
      497  /* BEGIN INCLUDE FILE  static_handlers.incl.pl1  */
 11     2 
 11     3 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 11     4 
 11     5 /* HISTORY:
 11     6*Written by S. H. Webber, 06/20/75.
 11     7*Modified:
 11     8*12/15/83 by Benson Margulies:  added undefined_pointer_sct_index and
 11     9*	  pgt_sct_index.
 11    10*06/11/84 by Lee A. Newcomb:  added dm_shutdown_warning_sct_index and
 11    11*            dm_user_shutdown_sct_index for handling of Data Management
 11    12*            shutdown.
 11    13*08/22/84 by R. Michael Tague:  Removed dm_shutdown_warning_sct_index and
 11    14*            dm_user_shutdown_sct_index.  Added
 11    15*            system_shutdown_scheduled_sct_index and
 11    16*            dm_shutdown_scheduled_sct_index.
 11    17**/
 11    18 
 11    19 
 11    20 /****^  HISTORY COMMENTS:
 11    21*  1) change(85-11-13,Herbst), approve(87-07-21,MCR7697),
 11    22*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
 11    23*     Add system_message_sct_index.
 11    24*                                                   END HISTORY COMMENTS */
 11    25 
 11    26 
 11    27 dcl  (
 11    28      shutdown_sct_index	        init (0),
 11    29      store_sct_index	        init (1),
 11    30      mme1_sct_index		        init (2),
 11    31      fault_tag_1_sct_index	        init (3),
 11    32      timer_runout_sct_index	        init (4),
 11    33      command_sct_index	        init (5),
 11    34      derail_sct_index	        init (6),
 11    35      lockup_sct_index	        init (7),
 11    36      connect_sct_index	        init (8),
 11    37      parity_sct_index	        init (9),
 11    38      illegal_procedure_sct_index      init (10),
 11    39      op_not_complete_sct_index        init (11),
 11    40      startup_sct_index	        init (12),
 11    41      ovrflo_sct_index	        init (13),
 11    42      zerodivide_sct_index	        init (14),
 11    43      execute_sct_index	        init (15),
 11    44      seg_fault_error_sct_index        init (16),
 11    45      page_fault_error_sct_index       init (17),
 11    46      directed_fault_2_sct_index       init (18),
 11    47      directed_fault_3_sct_index       init (19),
 11    48      accessviolation_sct_index        init (20),
 11    49      mme2_sct_index		        init (21),
 11    50      mme3_sct_index		        init (22),
 11    51      mme4_sct_index		        init (23),
 11    52      linkage_error_sct_index	        init (24),
 11    53      fault_tag_3_sct_index	        init (25),
 11    54      undefined_fault_sct_index        init (26),
 11    55      trouble_sct_index	        init (31),
 11    56      illegal_opcode_sct_index	        init (32),
 11    57      simfault_000000_sct_index        init (33),
 11    58      illegal_modifier_sct_index       init (34),
 11    59      illegal_ring_order_sct_index     init (35),
 11    60      not_in_execute_bracket_sct_index init (36),
 11    61      no_execute_permission_sct_index  init (37),
 11    62      not_in_read_bracket_sct_index    init (38),
 11    63      no_read_permission_sct_index     init (39),
 11    64      not_in_write_bracket_sct_index   init (40),
 11    65      no_write_permission_sct_index    init (41),
 11    66      not_a_gate_sct_index	        init (42),
 11    67      not_in_call_bracket_sct_index    init (43),
 11    68      outward_call_sct_index	        init (44),
 11    69      bad_outward_call_sct_index       init (45),
 11    70      inward_return_sct_index	        init (46),
 11    71      cross_ring_transfer_sct_index    init (47),
 11    72      ring_alarm_fault_sct_index       init (48),
 11    73      am_fault_sct_index	        init (49),
 11    74      out_of_bounds_sct_index	        init (50),
 11    75      fixedoverflow_sct_index	        init (51),
 11    76      overflow_sct_index	        init (52),
 11    77      underflow_sct_index	        init (53),
 11    78      stringsize_sct_index	        init (54),
 11    79      other_illegal_proc_sct_index     init (55),
 11    80      storage_sct_index	        init (56),
 11    81      packed_pointer_fault_sct_index   init (57),
 11    82      lot_fault_sct_index	        init (58),
 11    83      isot_fault_sct_index	        init (59),
 11    84      system_packed_pointer_sct_index  init (60),
 11    85      quit_sct_index		        init (61),
 11    86      alrm_sct_index		        init (62),
 11    87      cput_sct_index		        init (63),
 11    88      record_quota_overflow_sct_index  init (64),
 11    89      size_sct_index		        init (65),
 11    90      neti_sct_index		        init (66),
 11    91      other_command_sct_index	        init (67),
 11    92      susp_sct_index		        init (68),
 11    93      term_sct_index		        init (69),
 11    94      wkp_sct_index		        init (70),
 11    95      undefined_pointer_sct_index      init (71),
 11    96      pgt_sct_index		        init (72),
 11    97      system_shutdown_scheduled_sct_index
 11    98 	                            init (73),
 11    99      dm_shutdown_scheduled_sct_index  init (74),
 11   100      system_message_sct_index	        init (75)
 11   101      )			        fixed bin (17) int static options (constant);
 11   102 
 11   103 /* END INCLUDE FILE  static_handlers.incl.pl1 */
      497 
      498  
 12     2 /*  BEGIN INCLUDE FILE ... str.incl.pl1 ... last modified March 1970 */
 12     3 
 12     4 dcl str_seg$ ext,
 12     5     strp ptr;
 12     6 
 12     7 dcl 1 str based (strp) aligned,		/* segment or process trailer declaration */
 12     8 
 12     9    (2 fp bit (18),				/* forward ast trailer rel pointer */
 12    10     2 bp bit (18),				/* backward ast trailer rel pointer*/
 12    11 
 12    12     2 segno bit (18),			/* segment number*/
 12    13     2 dstep bit (18)) unaligned;		/* rel pointer to ring 0 dste */
 12    14  
 12    15 dcl stra (0:8000) bit (72) based (strp) aligned;
 12    16 
 12    17 /*  END INCLUDE FILE ... str.incl.pl1 */
 12    18 
      498 
      499  /* BEGIN INCLUDE FILE trace_types.incl.pl1  --  Last modified Jan 1982 */
 13     2 
 13     3      dcl	   (page_fault_type	      init (0),
 13     4 	   seg_fault_start	      init (2),
 13     5 	   seg_fault_end	      init (3),
 13     6 	   linkage_fault_start    init (4),
 13     7 	   linkage_fault_end      init (5),
 13     8 	   boundfault_start	      init (6),
 13     9 	   boundfault_end	      init (7),
 13    10 	   signaller_type	      init (8),
 13    11 	   restart_fault_type     init (9),
 13    12 	   reschedule_type	      init (10),
 13    13 	   marker_type	      init (11),
 13    14 	   interrupt_type	      init (12),
 13    15 	   extended_page_fault_type init (15)) fixed bin int static options (constant);
 13    16 
 13    17 
 13    18 /* END INCLUDE FILE trace_types.incl.pl1 */
      499 
      500 
      501 
      502 /* BEGIN MESSAGE DOCUMENTATION
      503*
      504*   Message:
      505*   seg_fault: illegal segfault on cpu X
      506*
      507*   S:	$info
      508*
      509*   T:	$run
      510*
      511*   M:	The SCU data
      512*   stored by processor X
      513*   indicates that
      514*   a segment fault has occurred
      515*   but the SDW indicated by the SCU data
      516*   has no directed fault indicator.
      517*   $err
      518*   The system attempts to retry the faulting instruction.
      519*
      520*   A:	Inform field engineering personnel.
      521*   If this message persists, attempt to delete the CPU.
      522*
      523*
      524*   Message:
      525*   seg_fault: trailer storage area exhausted
      526*
      527*   S:	$crash
      528*
      529*   T:	$run
      530*
      531*   M:	There are no more free entries available in the system trailer
      532*   segment, str_seg. This may be indicative of software- or hardware-induced
      533*   damage to the SST or str_seg, or may be indicative of a number of
      534*   logged-in processes which is vastly too large. A more likely cause is
      535*   insufficiently large str_seg. The size of the str_seg can be changed
      536*   by the TBLS STR card in the config deck.
      537*   $err
      538*   $crashes
      539*
      540*   A:	$recover
      541*   It may be necessary to increase the size of the str_seg by the TBLS STR
      542*   card in the config deck.
      543*   Be sure to get a dump.
      544*
      545*
      546*   Message:
      547*   seg_fault: trailer list trap
      548*
      549*   S:	$crash
      550*
      551*   T:	$run
      552*
      553*   M:	An attempt was made to
      554*   set sst$tfreep to zero.
      555*   The supervisor checks for this
      556*   situation and crashes here
      557*   when one entry remains in the trailer segment
      558*   in order to trap an elusive bug
      559*   which used to cause "trailer storage area exhausted" crashes
      560*   when the trailer segment was not full.
      561*   $err
      562*   $crashes
      563*
      564*   A:	$recover
      565*   Be sure to get a dump.
      566*
      567*   END MESSAGE DOCUMENTATION */
      568 
      569      end seg_fault;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0808.5  seg_fault.pl1                     >spec>install>1112>seg_fault.pl1
487          1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
488          2    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
489          3    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
490          4    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
491          5    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
492          6    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
493          7    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
494          8    11/30/76  1555.4  lvt.incl.pl1                      >ldd>include>lvt.incl.pl1
495          9    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
496         10    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
497         11    08/06/87  0913.5  static_handlers.incl.pl1          >ldd>include>static_handlers.incl.pl1
498         12    05/06/74  1751.6  str.incl.pl1                      >ldd>include>str.incl.pl1
499         13    03/29/82  1006.9  trace_types.incl.pl1              >ldd>include>trace_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FAULT                                  constant        fixed bin(17,0)          initial dcl 181 ref 192
MAKEKNOWN                              constant        fixed bin(17,0)          initial dcl 182 ref 255 319 460 474
a_code                                 parameter       fixed bin(35,0)          dcl 97 set ref 462* 471
a_kstep                                parameter       pointer                  dcl 98 ref 471 481
a_mcptr                                parameter       pointer                  dcl 99 ref 14 195
access                    2     000126 automatic       structure                level 2 in structure "sdwi" packed packed unaligned
                                                                                  dcl 120 in procedure "seg_fault" set ref 399* 412*
access                    2     000112 automatic       structure                level 2 in structure "orig_sdwi" packed packed
                                                                                  unaligned dcl 113 in procedure "seg_fault" set ref
                                                                                  412 413
access_audit_$log_general       000070 constant        entry                    external dcl 156 ref 358
access_operations_$log_vol_full 000010 external static bit(36)                  dcl 129 set ref 358*
activate$activate_long          000072 constant        entry                    external dcl 157 ref 316
activated_sw                    000100 automatic       bit(1)                   dcl 103 set ref 316* 319
active_all_rings_data$stack_base_segno
                                000012 external static fixed bin(18,0)          dcl 130 ref 222 222 222 225
addr                                                   builtin function         dcl 186 ref 196 208 208 277 357 371 371 393 393 393
                                                                                  393 407 407 407 407 447 447 447 447
aim_template                           based           structure                level 1 dcl 2-12
allow_256K_connect        7(26)        based           bit(1)                   level 2 packed packed unaligned dcl 7-18 ref 333
any_access_on             5(06)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 set ref 423
                                                                                  430* 437*
aste                                   based           structure                level 1 dcl 3-11
astep                           000146 automatic       pointer                  dcl 3-9 set ref 249* 316* 326 333 341 353 354* 368
                                                                                  382 384 384 385 385 386 386 392* 423 423 428* 430
                                                                                  435 437 439 439 443
audit_event_flags                      based           structure                level 1 dcl 1-5
audit_eventflags                000101 automatic       bit(36)                  dcl 104 set ref 356* 357 358*
baseptr                                                builtin function         dcl 186 ref 232 485
bin                                                    builtin function         dcl 186 ref 198 205 206 210 210 217 333 341 344 368
                                                                                  379 443
binary                                                 builtin function         dcl 186 ref 415
bit                                                    builtin function         dcl 186 ref 344 379
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 12-7 set ref
                                                                                  381*
branch_entrypt_bound            000102 automatic       bit(14)                  packed unaligned dcl 105 set ref 294* 415
branch_entrypt_sw               000103 automatic       bit(1)                   packed unaligned dcl 106 set ref 295* 415
ca                        5            based           bit(18)                  level 2 packed packed unaligned dcl 9-56 ref 217
cache                     4(02) 000126 automatic       bit(1)                   level 3 packed packed unaligned dcl 120 set ref 400*
                                                                                  421* 429* 435*
cc_1_10                   0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 1-5 set ref 357*
code                            000104 automatic       fixed bin(35,0)          dcl 107 set ref 193* 233* 234 248 264* 265 266 266*
                                                                                  267 279* 284* 285 307* 308 310* 311 316* 317 327*
                                                                                  335* 342* 354* 355 358* 462 466 476*
cpu_no                    2(27)        based           bit(3)                   level 2 packed packed unaligned dcl 9-56 ref 210 210
cu                        5(18)        based           structure                level 2 packed packed unaligned dcl 9-56
damaged                  13(19)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 326
dc_find$seg_fault               000144 constant        entry                    external dcl 4-97 ref 284
dir                                    based           structure                level 1 dcl 6-11
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 5-8 in procedure "seg_fault" ref 283
dirsw                     7(12)        based           bit(1)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 7-36 in procedure "seg_fault" ref 289 302 326
                                                                                  333 395
dp                              000152 automatic       pointer                  dcl 6-9 set ref 268* 272* 307 310 451* 483*
dseg$                           000014 external static fixed bin(71,0)          array dcl 131 set ref 208 208 371 371 407 407 447
                                                                                  447
dstep                     1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 12-7 set ref
                                                                                  380*
entry                                  based           structure                level 1 dcl 5-8
entryp                    3            based           pointer                  level 2 packed packed unaligned dcl 7-36 ref 482
entrypt_bound            32(22)        based           bit(14)                  level 2 packed packed unaligned dcl 5-8 ref 294
entrypt_sw               32(08)        based           bit(1)                   level 2 packed packed unaligned dcl 5-8 ref 295
ep                              000150 automatic       pointer                  dcl 5-6 set ref 264* 268* 272 277 283 284* 294 295
                                                                                  302 302 316* 354* 482* 483
errcode                  43            based           fixed bin(35,0)          level 2 packed packed unaligned dcl 9-12 set ref
                                                                                  197* 466*
error_table_$big_seg            000016 external static fixed bin(35,0)          dcl 132 ref 335
error_table_$boundviol          000020 external static fixed bin(35,0)          dcl 133 ref 342
error_table_$log_vol_full       000022 external static fixed bin(35,0)          dcl 134 ref 355
error_table_$mylock             000024 external static fixed bin(35,0)          dcl 135 ref 266
error_table_$oosw               000026 external static fixed bin(35,0)          dcl 136 ref 279
error_table_$seg_busted         000030 external static fixed bin(35,0)          dcl 137 ref 327
error_table_$seg_deleted        000032 external static fixed bin(35,0)          dcl 138 ref 267
esw                             000105 automatic       fixed bin(17,0)          dcl 108 set ref 192* 255 319 460 474*
explicit_deact_ok         7(19)        based           bit(1)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 7-36 in procedure "seg_fault" ref 386
explicit_deact_ok         5(09)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "seg_fault" set ref 386* 386
fcode                    44(19)        based           bit(17)                  level 3 packed packed unaligned dcl 9-12 set ref
                                                                                  344*
fim_temp                 44            based           structure                level 2 packed packed unaligned dcl 9-12
flags                     7            based           structure                level 2 in structure "lvte" packed packed unaligned
                                                                                  dcl 8-18 in procedure "seg_fault"
flags                     7(12)        based           structure                level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 7-36 in procedure "seg_fault"
flags                     4     000126 automatic       structure                level 2 in structure "sdwi" dcl 120 in procedure
                                                                                  "seg_fault"
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 12-7 set ref 377
                                                                                  378 381*
gate_entry_bound          5     000126 automatic       fixed bin(14,0)          level 2 dcl 120 set ref 415*
get_kstep                       000074 constant        entry                    external dcl 158 ref 233
get_ptrs_$given_astep           000076 constant        entry                    external dcl 159 ref 392
gtms                      5(03)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 set ref
                                                                                  385* 385
gtus                      5(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 set ref
                                                                                  384* 384
if                        5(29)        based           bit(1)                   level 3 packed packed unaligned dcl 9-56 ref 205
infcount                  7(23)        based           fixed bin(12,0)          level 2 packed packed unaligned dcl 7-36 set ref 302
                                                                                  312*
kst                                    based           structure                level 1 dcl 7-18
kste                                   based           structure                level 1 dcl 7-36
kstep                           000156 automatic       pointer                  dcl 7-15 set ref 233* 241 284* 289 302 302 312 326
                                                                                  333 384 385 386 395 481* 482 484
kstp                            000154 automatic       pointer                  dcl 7-15 set ref 194* 333 475*
level$get                       000100 constant        entry                    external dcl 160 ref 358 358
lock$dir_unlock                 000102 constant        entry                    external dcl 161 ref 451
lock$lock_ast                   000104 constant        entry                    external dcl 162 ref 247
lock$unlock_ast                 000106 constant        entry                    external dcl 163 ref 449
logical_volume_manager$lvtep    000110 constant        entry                    external dcl 164 ref 307
lsw                             000106 automatic       bit(1)                   dcl 109 set ref 246* 255* 263* 265* 451
lvte                                   based           structure                level 1 dcl 8-18
lvtep                           000160 automatic       pointer                  dcl 8-8 set ref 307* 309
lvx                             000107 automatic       fixed bin(8,0)           dcl 110 set ref 310* 312
makestack                       000112 constant        entry                    external dcl 165 ref 225
master_dir               32(09)        based           bit(1)                   level 2 packed packed unaligned dcl 5-8 ref 302
mc                                     based           structure                level 1 dcl 9-12
mcp                             000162 automatic       pointer                  dcl 9-10 set ref 195* 196 197 343 344 466 477*
min                                                    builtin function         dcl 186 ref 443
mode                            000110 automatic       bit(36)                  dcl 111 set ref 413* 423 439
msl                       4            based           bit(9)                   level 2 packed packed unaligned dcl 3-11 ref 333 341
                                                                                  443
null                                                   builtin function         dcl 186 ref 222 268 358 358 477 478
offset                          000111 automatic       fixed bin(18,0)          dcl 112 set ref 217* 341 354* 480*
orig_sdwi                       000112 automatic       structure                level 1 dcl 113 set ref 407 407
out_of_bounds_sct_index                constant        fixed bin(17,0)          initial dcl 11-27 ref 344
pack_ovfl                13(20)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 353
page$enter_data                 000114 constant        entry                    external dcl 166 ref 215 468
pds$access_authorization        000034 external static bit(72)                  dcl 139 set ref 277
pds$dstep                       000036 external static bit(18)                  packed unaligned dcl 140 ref 380
pds$kstp                        000146 external static pointer                  dcl 7-15 ref 194 475
pds$segment_faults              000040 external static fixed bin(35,0)          dcl 141 set ref 459* 459
pds$stacks                      000042 external static pointer                  array dcl 142 ref 222
ppr                                    based           structure                level 2 packed packed unaligned dcl 9-56
private_logical_volume$lvx      000116 constant        entry                    external dcl 167 ref 310
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 2-12
prr                                    based           bit(3)                   level 3 packed packed unaligned dcl 9-56 ref 198
psr                       0(03)        based           bit(15)                  level 3 packed packed unaligned dcl 9-56 ref 205
ptr                                                    builtin function         dcl 186 ref 272 378 483
pts                             000120 automatic       fixed bin(17,0)          dcl 114 set ref 368* 443
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 3-11 ref 368
public                    7            based           bit(1)                   level 3 packed packed unaligned dcl 8-18 ref 309
pvt$root_lvid                   000044 external static bit(36)                  dcl 143 ref 302
pw1                             000121 automatic       fixed bin(17,0)          dcl 115 set ref 191* 457 473*
pw2                             000122 automatic       fixed bin(17,0)          dcl 116 set ref 453* 457
rel                                                    builtin function         dcl 186 ref 373
resignal                 44(18)        based           bit(1)                   level 3 packed packed unaligned dcl 9-12 set ref
                                                                                  343*
ringno                          000123 automatic       fixed bin(17,0)          dcl 117 set ref 198* 479*
rings                     3     000126 automatic       structure                level 2 in structure "sdwi" packed packed unaligned
                                                                                  dcl 120 in procedure "seg_fault" set ref 414*
rings                     3     000112 automatic       structure                level 2 in structure "orig_sdwi" packed packed
                                                                                  unaligned dcl 113 in procedure "seg_fault" set ref
                                                                                  414
scu                                    based           structure                level 1 dcl 9-56 in procedure "seg_fault"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 9-12 in procedure "seg_fault" set
                                                                                  ref 196
scup                            000164 automatic       pointer                  dcl 9-54 set ref 196* 198 205 205 206 210 210 217
                                                                                  478*
sdw_address                     000124 automatic       fixed bin(26,0)          dcl 118 set ref 371* 372
sdw_info                               based           structure                level 1 dcl 10-6
sdw_util_$construct             000120 constant        entry                    external dcl 168 ref 447
sdw_util_$dissect               000122 constant        entry                    external dcl 169 ref 393 407
sdw_util_$get_address           000124 constant        entry                    external dcl 170 ref 371
sdw_util_$get_valid             000126 constant        entry                    external dcl 171 ref 208
sdw_valid                       000125 automatic       bit(1)                   dcl 119 set ref 208* 209
sdwi                            000126 automatic       structure                level 1 dcl 120 set ref 393 393 447 447
security_oosw            32(07)        based           bit(1)                   level 2 packed packed unaligned dcl 5-8 ref 277
seg_fault_end                          constant        fixed bin(17,0)          initial dcl 13-3 ref 468
seg_fault_start                        constant        fixed bin(17,0)          initial dcl 13-3 ref 215
segment_mover                   000130 constant        entry                    external dcl 172 ref 354
segno                           000134 automatic       fixed bin(17,0)          dcl 121 in procedure "seg_fault" set ref 205* 206*
                                                                                  208 208 215* 222 222 222 225 232 233* 354* 371 371
                                                                                  379 407 407 447 447 468* 484* 485
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 7-36 in procedure "seg_fault" ref 484
segno                     1            based           bit(18)                  level 2 in structure "str" packed packed unaligned
                                                                                  dcl 12-7 in procedure "seg_fault" set ref 379*
segptr                          000136 automatic       pointer                  dcl 122 set ref 232* 264* 485*
setfaults$cache                 000132 constant        entry                    external dcl 173 ref 428
size                      1     000126 automatic       fixed bin(19,0)          level 2 dcl 120 set ref 443*
sons_lvid                41            based           bit(36)                  level 2 in structure "entry" dcl 5-8 in procedure
                                                                                  "seg_fault" ref 302
sons_lvid                12            based           bit(36)                  level 2 in structure "dir" dcl 6-11 in procedure
                                                                                  "seg_fault" set ref 307* 310*
soos                      1(21)        based           bit(1)                   level 3 packed packed unaligned dcl 2-12 ref 277
sst$cpu_sf_time                 000046 external static fixed bin(71,0)          dcl 144 set ref 456* 456
sst$makeknown_activations       000050 external static fixed bin(35,0)          dcl 145 set ref 319* 319
sst$pts                         000052 external static fixed bin(17,0)          array dcl 146 ref 368
sst$root_astep                  000054 external static pointer                  dcl 147 ref 249
sst$seg_fault_calls             000064 external static fixed bin(35,0)          dcl 151 set ref 461* 461
sst$tfreep                      000056 external static pointer                  dcl 148 set ref 373 376 378*
sst$total_sf                    000062 external static fixed bin(35,0)          dcl 150 set ref 458* 458
sst$total_sf_pf                 000060 external static fixed bin(35,0)          dcl 149 set ref 457* 457
str                                    based           structure                level 1 dcl 12-7
string                                                 builtin function         dcl 186 set ref 399* 412* 412 413 414* 414
strp                            000166 automatic       pointer                  dcl 12-4 in procedure "seg_fault" set ref 376* 377
                                                                                  378 378 379 380 381 381 382*
strp                      2            based           bit(18)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "seg_fault" set ref 382*
substr                                                 builtin function         dcl 186 ref 210 210 413 423 439
sum$getbranch_root_my           000134 constant        entry                    external dcl 174 ref 264
sys_info$seg_size_256K          000066 external static fixed bin(19,0)          dcl 152 ref 333
syserr                          000136 constant        entry                    external dcl 175 ref 210 373 377
thread$lin                      000140 constant        entry                    external dcl 176 ref 382
time1                           000140 automatic       fixed bin(71,0)          dcl 123 set ref 191* 456 473*
time2                           000142 automatic       fixed bin(71,0)          dcl 124 set ref 453* 456
tms                       7(15)        based           bit(1)                   level 3 packed packed unaligned dcl 7-36 ref 385
tpr                       2            based           structure                level 2 packed packed unaligned dcl 9-56
tsdw                            000144 automatic       fixed bin(71,0)          dcl 125 set ref 392* 393 393
tsr                       2(03)        based           bit(15)                  level 3 packed packed unaligned dcl 9-56 ref 206
tus                       7(16)        based           bit(1)                   level 3 packed packed unaligned dcl 7-36 ref 384
uid                       4            based           bit(36)                  level 2 dcl 7-36 ref 241
usage_values                    000142 constant        entry                    external dcl 177 ref 191 453 473
write_access_on           5(07)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 set ref 423
                                                                                  435 439* 439

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 4-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 4-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 4-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 4-13
abx                                    internal static fixed bin(17,0)          initial dcl 9-42
accessviolation_sct_index              internal static fixed bin(17,0)          initial dcl 11-27
alrm_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
am_fault_sct_index                     internal static fixed bin(17,0)          initial dcl 11-27
apx                                    internal static fixed bin(17,0)          initial dcl 9-42
asta                                   based           bit(432)                 array dcl 3-86
aste_part                              based           structure                level 1 dcl 3-89
bad_outward_call_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
bbx                                    internal static fixed bin(17,0)          initial dcl 9-42
boundfault_end                         internal static fixed bin(17,0)          initial dcl 13-3
boundfault_start                       internal static fixed bin(17,0)          initial dcl 13-3
bpx                                    internal static fixed bin(17,0)          initial dcl 9-42
command_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
connect_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
cput_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
cross_ring_transfer_sct_index          internal static fixed bin(17,0)          initial dcl 11-27
dc_find$dir_for_append          000000 constant        entry                    external dcl 4-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 4-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 4-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 4-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 4-21
dc_find$dir_read                000000 constant        entry                    external dcl 4-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 4-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 4-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 4-28
dc_find$dir_write               000000 constant        entry                    external dcl 4-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 4-31
dc_find$finished                000000 constant        entry                    external dcl 4-33
dc_find$link_target             000000 constant        entry                    external dcl 4-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 4-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 4-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 4-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 4-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 4-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 4-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 4-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 4-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 4-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 4-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 4-51
dc_find$obj_delete              000000 constant        entry                    external dcl 4-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 4-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 4-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 4-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 4-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 4-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 4-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 4-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 4-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 4-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 4-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 4-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 4-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 4-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 4-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 4-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 4-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 4-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 4-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 4-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 4-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 4-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 4-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 4-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 4-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 4-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 4-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 4-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 4-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 4-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 4-95
derail_sct_index                       internal static fixed bin(17,0)          initial dcl 11-27
directed_fault_2_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
directed_fault_3_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
dm_shutdown_scheduled_sct_index        internal static fixed bin(17,0)          initial dcl 11-27
execute_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
extended_page_fault_type               internal static fixed bin(17,0)          initial dcl 13-3
fault_tag_1_sct_index                  internal static fixed bin(17,0)          initial dcl 11-27
fault_tag_3_sct_index                  internal static fixed bin(17,0)          initial dcl 11-27
fixedoverflow_sct_index                internal static fixed bin(17,0)          initial dcl 11-27
illegal_modifier_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
illegal_opcode_sct_index               internal static fixed bin(17,0)          initial dcl 11-27
illegal_procedure_sct_index            internal static fixed bin(17,0)          initial dcl 11-27
illegal_ring_order_sct_index           internal static fixed bin(17,0)          initial dcl 11-27
interrupt_type                         internal static fixed bin(17,0)          initial dcl 13-3
inward_return_sct_index                internal static fixed bin(17,0)          initial dcl 11-27
isot_fault_sct_index                   internal static fixed bin(17,0)          initial dcl 11-27
lbx                                    internal static fixed bin(17,0)          initial dcl 9-42
linkage_error_sct_index                internal static fixed bin(17,0)          initial dcl 11-27
linkage_fault_end                      internal static fixed bin(17,0)          initial dcl 13-3
linkage_fault_start                    internal static fixed bin(17,0)          initial dcl 13-3
lockup_sct_index                       internal static fixed bin(17,0)          initial dcl 11-27
lot_fault_sct_index                    internal static fixed bin(17,0)          initial dcl 11-27
lpx                                    internal static fixed bin(17,0)          initial dcl 9-42
lvt                                    based           structure                level 1 dcl 8-10
lvt$                                   external static fixed bin(17,0)          dcl 8-6
lvtp                                   automatic       pointer                  dcl 8-7
marker_type                            internal static fixed bin(17,0)          initial dcl 13-3
mme1_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
mme2_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
mme3_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
mme4_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
neti_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
no_execute_permission_sct_index        internal static fixed bin(17,0)          initial dcl 11-27
no_read_permission_sct_index           internal static fixed bin(17,0)          initial dcl 11-27
no_write_permission_sct_index          internal static fixed bin(17,0)          initial dcl 11-27
not_a_gate_sct_index                   internal static fixed bin(17,0)          initial dcl 11-27
not_in_call_bracket_sct_index          internal static fixed bin(17,0)          initial dcl 11-27
not_in_execute_bracket_sct_index       internal static fixed bin(17,0)          initial dcl 11-27
not_in_read_bracket_sct_index          internal static fixed bin(17,0)          initial dcl 11-27
not_in_write_bracket_sct_index         internal static fixed bin(17,0)          initial dcl 11-27
op_not_complete_sct_index              internal static fixed bin(17,0)          initial dcl 11-27
other_command_sct_index                internal static fixed bin(17,0)          initial dcl 11-27
other_illegal_proc_sct_index           internal static fixed bin(17,0)          initial dcl 11-27
outward_call_sct_index                 internal static fixed bin(17,0)          initial dcl 11-27
overflow_sct_index                     internal static fixed bin(17,0)          initial dcl 11-27
ovrflo_sct_index                       internal static fixed bin(17,0)          initial dcl 11-27
packed_pointer_fault_sct_index         internal static fixed bin(17,0)          initial dcl 11-27
page_fault_error_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
page_fault_type                        internal static fixed bin(17,0)          initial dcl 13-3
parity_sct_index                       internal static fixed bin(17,0)          initial dcl 11-27
pgt_sct_index                          internal static fixed bin(17,0)          initial dcl 11-27
quit_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
record_quota_overflow_sct_index        internal static fixed bin(17,0)          initial dcl 11-27
reschedule_type                        internal static fixed bin(17,0)          initial dcl 13-3
restart_fault_type                     internal static fixed bin(17,0)          initial dcl 13-3
ring_alarm_fault_sct_index             internal static fixed bin(17,0)          initial dcl 11-27
sbx                                    internal static fixed bin(17,0)          initial dcl 9-42
scux                                   based           structure                level 1 dcl 9-207
sdw_info_ptr                           automatic       pointer                  dcl 10-4
seg_aste                               based           structure                level 1 dcl 3-96
seg_fault_error_sct_index              internal static fixed bin(17,0)          initial dcl 11-27
shutdown_sct_index                     internal static fixed bin(17,0)          initial dcl 11-27
signaller_type                         internal static fixed bin(17,0)          initial dcl 13-3
simfault_000000_sct_index              internal static fixed bin(17,0)          initial dcl 11-27
size_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
spx                                    internal static fixed bin(17,0)          initial dcl 9-42
startup_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
storage_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
store_sct_index                        internal static fixed bin(17,0)          initial dcl 11-27
str_seg$                               external static fixed bin(17,0)          dcl 12-4
stra                                   based           bit(72)                  array dcl 12-15
stringsize_sct_index                   internal static fixed bin(17,0)          initial dcl 11-27
susp_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
system_message_sct_index               internal static fixed bin(17,0)          initial dcl 11-27
system_packed_pointer_sct_index        internal static fixed bin(17,0)          initial dcl 11-27
system_shutdown_scheduled_sct_index    internal static fixed bin(17,0)          initial dcl 11-27
term_sct_index                         internal static fixed bin(17,0)          initial dcl 11-27
timer_runout_sct_index                 internal static fixed bin(17,0)          initial dcl 11-27
trouble_sct_index                      internal static fixed bin(17,0)          initial dcl 11-27
undefined_fault_sct_index              internal static fixed bin(17,0)          initial dcl 11-27
undefined_pointer_sct_index            internal static fixed bin(17,0)          initial dcl 11-27
underflow_sct_index                    internal static fixed bin(17,0)          initial dcl 11-27
version_number_2                       internal static fixed bin(17,0)          initial dcl 6-84
wkp_sct_index                          internal static fixed bin(17,0)          initial dcl 11-27
zerodivide_sct_index                   internal static fixed bin(17,0)          initial dcl 11-27

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000304 constant        label                    dcl 241 ref 486
MAKE_TRAILER                    000764 constant        label                    dcl 368
err                             001405 constant        label                    dcl 453 ref 234 248 267
err0                            001367 constant        label                    dcl 449 ref 328 336 345
err1                            001374 constant        label                    dcl 451 ref 280 285 308 311 317 360
finish                          001460 constant        label                    dcl 468 ref 226
makeknown_activate              001500 constant        entry                    external dcl 471
seg_audit                       000413 constant        label                    dcl 284 ref 269
seg_fault                       000064 constant        entry                    external dcl 14

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2336        2506    1556        2346
Length      3230    1556       150         505     557           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
seg_fault                           196 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
seg_fault                000100 activated_sw                seg_fault
                         000101 audit_eventflags            seg_fault
                         000102 branch_entrypt_bound        seg_fault
                         000103 branch_entrypt_sw           seg_fault
                         000104 code                        seg_fault
                         000105 esw                         seg_fault
                         000106 lsw                         seg_fault
                         000107 lvx                         seg_fault
                         000110 mode                        seg_fault
                         000111 offset                      seg_fault
                         000112 orig_sdwi                   seg_fault
                         000120 pts                         seg_fault
                         000121 pw1                         seg_fault
                         000122 pw2                         seg_fault
                         000123 ringno                      seg_fault
                         000124 sdw_address                 seg_fault
                         000125 sdw_valid                   seg_fault
                         000126 sdwi                        seg_fault
                         000134 segno                       seg_fault
                         000136 segptr                      seg_fault
                         000140 time1                       seg_fault
                         000142 time2                       seg_fault
                         000144 tsdw                        seg_fault
                         000146 astep                       seg_fault
                         000150 ep                          seg_fault
                         000152 dp                          seg_fault
                         000154 kstp                        seg_fault
                         000156 kstep                       seg_fault
                         000160 lvtep                       seg_fault
                         000162 mcp                         seg_fault
                         000164 scup                        seg_fault
                         000166 strp                        seg_fault

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_$log_general     activate$activate_long        dc_find$seg_fault             get_kstep
get_ptrs_$given_astep         level$get                     lock$dir_unlock               lock$lock_ast
lock$unlock_ast               logical_volume_manager$lvtep  makestack                     page$enter_data
private_logical_volume$lvx    sdw_util_$construct           sdw_util_$dissect             sdw_util_$get_address
sdw_util_$get_valid           segment_mover                 setfaults$cache               sum$getbranch_root_my
syserr                        thread$lin                    usage_values

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$log_vol_full                             active_all_rings_data$stack_base_segno
dseg$                         error_table_$big_seg          error_table_$boundviol        error_table_$log_vol_full
error_table_$mylock           error_table_$oosw             error_table_$seg_busted       error_table_$seg_deleted
pds$access_authorization      pds$dstep                     pds$kstp                      pds$segment_faults
pds$stacks                    pvt$root_lvid                 sst$cpu_sf_time               sst$makeknown_activations
sst$pts                       sst$root_astep                sst$seg_fault_calls           sst$tfreep
sst$total_sf                  sst$total_sf_pf               sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000061       191 000071       192 000101       193 000103       194 000104       195 000110       196 000114
    197 000116       198 000120       205 000123       206 000133       208 000137       209 000152       210 000155
    212 000212       215 000213       217 000226       222 000232       225 000252       226 000263       232 000264
    233 000270       234 000302       241 000304       246 000310       247 000311       248 000316       249 000320
    250 000324       255 000325       263 000332       264 000333       265 000352       266 000357       267 000364
    268 000366       269 000371       272 000372       277 000374       279 000405       280 000407       283 000410
    284 000413       285 000426       289 000430       294 000437       295 000443       302 000447       307 000465
    308 000500       309 000502       310 000506       311 000522       312 000524       316 000531       317 000546
    319 000550       326 000563       327 000576       328 000601       333 000602       335 000617       336 000621
    341 000622       342 000630       343 000633       344 000636       345 000645       353 000646       354 000651
    355 000670       356 000674       357 000675       358 000677       360 000763       368 000764       371 000772
    372 001007       373 001011       376 001037       377 001043       378 001067       379 001075       380 001103
    381 001106       382 001112       384 001123       385 001141       386 001155       392 001171       393 001202
    395 001217       399 001223       400 001227       402 001231       407 001232       412 001250       413 001254
    414 001257       415 001261       421 001267       423 001271       428 001303       429 001316       430 001320
    432 001323       435 001324       437 001332       439 001334       443 001341       447 001351       449 001367
    451 001374       453 001405       456 001416       457 001423       458 001432       459 001436       460 001442
    461 001445       462 001451       463 001454       466 001455       468 001460       469 001473       471 001474
    473 001505       474 001516       475 001520       476 001524       477 001525       478 001527       479 001530
    480 001531       481 001533       482 001537       483 001541       484 001543       485 001547       486 001552


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
