	COMPILATION LISTING OF SEGMENT retv_copy
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1030.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style1,ind5,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       14 
       15 retv_copy: proc (a_dirname, a_ename, a_auth, a_userid, a_level, a_vtocep, a_objectp, a_attributes, a_code);
       16 
       17 /* This routine provides a controlled method of copying data from a temp orary buffer
       18*   in an outer ring either into an existant or non-existant object, regardless of whether that object is
       19*   a segment or a directory */
       20 
       21 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       22 /*									*/
       23 /* Status:								*/
       24 /* 0) Created by Dave Vinograd in the distant past.				*/
       25 /* 1) Modified: 8/18/82 by GA Texada to fix phx13506				*/
       26 /* 2) Modified: 8/08/83 by E. N. Kittlitz for setfaults$if_active pvid, vtocx args	*/
       27 /* 3) Modified: 7/6/84 by Keith Loepere to use the new dc_find.			*/
       28 /* 4) Modified: 10/15/84 by Keith Loepere to explicitly activate dir on makeknown_,	*/
       29 /*		also for auditing info.					*/
       30 /* 5) Modified: 12/13/84 by Keith Loepere to reload dir quota also.			*/
       31 /*									*/
       32 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       33 
       34 /* Parameters */
       35 
       36 dcl a_attributes	     bit (36);
       37 dcl a_auth	     bit (72) aligned;
       38 dcl a_code	     fixed bin (35);
       39 dcl a_dirname	     char (*) aligned;
       40 dcl a_ename	     char (*) aligned;
       41 dcl a_level	     fixed bin;
       42 dcl a_objectp	     ptr;
       43 dcl a_userid	     char (*) aligned;
       44 dcl a_vtocep	     ptr;
       45 
       46 /* Variables */
       47 
       48 dcl attributes	     bit (36);
       49 dcl code		     fixed bin (35);
       50 dcl del_code	     fixed bin (35);
       51 dcl del_ename	     char (32);
       52 dcl del_pname	     char (168);
       53 dcl dir_pvid	     bit (36) aligned;
       54 dcl dir_uid	     bit (36) aligned;
       55 dcl dir_vtocx	     fixed bin;
       56 dcl dirl		     bit (1) aligned;
       57 dcl dirname	     char (168);
       58 dcl dirsw		     bit (1);
       59 dcl ec		     fixed bin (35);
       60 dcl ename		     char (32);
       61 dcl found		     bit (1);
       62 dcl hold		     bit (1);
       63 dcl i		     fixed bin;
       64 dcl ignore	     fixed bin (35);
       65 dcl inf_received	     (0:1) fixed bin (18);
       66 dcl 1 input_vtoce	     like vtoce aligned;
       67 dcl 1 local_audit_user_info like audit_user_info aligned;
       68 dcl 1 local_dir_header   like dir aligned;
       69 dcl 1 local_makeknown_info like makeknown_info aligned;
       70 dcl 1 local_quota_cell   like quota_cell aligned;
       71 dcl 1 local_vtoce	     like vtoce aligned;
       72 dcl mismatch	     bit (1);
       73 dcl ncd		     fixed bin;
       74 dcl new_ep	     ptr;
       75 dcl new_vtoce	     bit (1);
       76 dcl nid		     fixed bin;
       77 dcl objectp	     ptr;
       78 dcl old_ep	     ptr;
       79 dcl old_uid	     bit (36) aligned;
       80 dcl par_ep	     ptr;
       81 dcl par_pvid	     bit (36) aligned;
       82 dcl par_quota	     (0:1) fixed bin (18);
       83 dcl par_received	     (0:1) fixed bin (18);
       84 dcl par_uid	     bit (36) aligned;
       85 dcl par_vtocx	     fixed bin;
       86 dcl pardirl	     bit (1) aligned;
       87 dcl pvid		     bit (36) aligned;
       88 dcl pvtx		     fixed bin;
       89 dcl quota_type	     fixed bin;
       90 dcl segno		     fixed bin;
       91 dcl segptr	     ptr;
       92 dcl skip_list	     (1500) bit (36) aligned;
       93 dcl skip_list_cnt	     fixed bin init (0);
       94 dcl skip_list_idx	     fixed bin;
       95 dcl target_dirl	     bit (1);
       96 dcl target_dp	     ptr;
       97 dcl 1 temp_quota_cell    like quota_cell aligned;
       98 dcl uid		     bit (36) aligned;
       99 dcl vtocx		     fixed bin;
      100 
      101 /* Based */
      102 
      103 dcl dates_set	     defined attributes position (1) bit (1);
      104 dcl dump_info_set	     defined attributes position (3) bit (1);
      105 dcl dump_switches_set    defined attributes position (2) bit (1);
      106 dcl page		     (512) bit (72) aligned based;
      107 dcl pc_switches_set	     defined attributes position (4) bit (1);
      108 dcl quota_set	     defined attributes position (5) bit (1);
      109 
      110 /* External */
      111 
      112 dcl error_table_$action_not_performed ext fixed bin (35);
      113 dcl error_table_$argerr  ext fixed bin (35);
      114 dcl error_table_$fulldir ext fixed bin (35);
      115 dcl error_table_$invalidsegno ext fixed bin (35);
      116 dcl error_table_$segknown ext fixed bin (35);
      117 dcl error_table_$vtoce_connection_fail ext fixed bin (35);
      118 dcl sys_info$max_seg_size ext fixed bin;
      119 
      120 /* Entries */
      121 
      122 dcl create_vtoce	     entry (ptr, bit (36) aligned, fixed bin, fixed bin (35));
      123 dcl del_dir_tree$retv    entry (char (*), char (*), fixed bin (35));
      124 dcl delentry$retv	     entry (char (*), char (*), fixed bin (35));
      125 dcl get_kstep	     entry (fixed bin, ptr, fixed bin (35));
      126 dcl get_pvtx	     entry (bit (36) aligned, fixed bin (35)) returns (fixed bin);
      127 dcl get_pvtx$release_pvtx entry (bit (36) aligned, fixed bin);
      128 dcl grab_aste	     entry (ptr, fixed bin, fixed bin (35), ptr);
      129 dcl lock$dir_lock_read   entry (ptr, fixed bin (35));
      130 dcl lock$dir_unlock	     entry (ptr);
      131 dcl makeknown_	     entry (ptr, fixed bin, fixed bin, fixed bin (35));
      132 dcl makeunknown_	     entry (fixed bin, bit (36) aligned, bit (1) aligned, fixed bin (35));
      133 dcl mountedp	     entry (bit (36) aligned) returns (fixed bin (35));
      134 dcl setfaults$disconnect entry (fixed bin);
      135 dcl setfaults$if_active  entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (1));
      136 dcl sum$getbranch	     entry (ptr, bit (36), ptr, fixed bin (35));
      137 dcl syserr$error_code    entry options (variable);
      138 dcl truncate_vtoce$hold  entry (ptr, fixed bin, fixed bin (35));
      139 dcl vtoc_attributes$get_quota entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin, fixed bin (35));
      140 dcl vtoc_attributes$set_dates entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36), bit (36), fixed bin (35));
      141 dcl vtoc_attributes$set_dump_info entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36), (3) bit (36),
      142 		     fixed bin (35));
      143 dcl vtoc_attributes$set_dump_switches entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin, fixed bin,
      144 		     fixed bin (35));
      145 dcl vtoc_attributes$set_max_lth entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (9), bit (1),
      146 		     fixed bin (35));
      147 dcl vtoc_attributes$set_pc_switches entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36), bit (36),
      148 		     fixed bin (35));
      149 dcl vtoc_attributes$set_quota entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin, fixed bin (35));
      150 dcl vtoc_man$get_vtoce   entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr, fixed bin (35));
      151 
      152 /* Misc */
      153 
      154 dcl bad_dir_	     condition;
      155 dcl cleanup	     condition;
      156 
      157 dcl (addr, baseptr, fixed, null, ptr, rel, rtrim, substr, unspec) builtin;
      158 
      159 	audit_user_info_ptr = addr (local_audit_user_info);
      160 	unspec (audit_user_info) = "0"b;
      161 
      162 /* copy input args */
      163 	dirname = a_dirname;
      164 	ename = a_ename;
      165 	objectp = a_objectp;
      166 	audit_user_info.version = audit_user_info_version_1;
      167 	audit_user_info.user_id = a_userid;
      168 	audit_user_info.ring = a_level;
      169 	audit_user_info.process_id = "0"b;		/* may not be logged on */
      170 	audit_user_info.authorization_range(2),		/* use auth as max_auth until we can get real max_auth */
      171 	     audit_user_info.authorization = a_auth;
      172 	audit_user_info.audit_flags = (36)"1"b;		/* audit anything until we can get the real audit flags */
      173 	input_vtoce = a_vtocep -> vtoce;
      174 						/* initialize control variables */
      175 	target_dirl, dirl, pardirl, hold, new_vtoce = "0"b;
      176 	attributes = "0"b;
      177 	code = 0;
      178 	segno = -1;
      179 	astep, dp, kstep = null;
      180 						/* be prepared for vtoce connection failures */
      181 	on cleanup begin;
      182 		code = error_table_$action_not_performed;
      183 		if kstep ^= null then call revert_kst_access;
      184 		goto fin;
      185 	     end;
      186 
      187 /* If the object to be copied is a directory then lock it, even though it may not exist. */
      188 
      189 	if input_vtoce.dirsw then do;
      190 		unspec (local_dir_header) = "0"b;
      191 		target_dp = addr (local_dir_header);
      192 		local_dir_header.uid = input_vtoce.uid;
      193 		call lock$dir_lock_read (target_dp, code);
      194 		if code ^= 0 then goto fin;
      195 		target_dirl = "1"b;
      196 	     end;
      197 
      198 /* set aste.ehs on outer ring buffer so we will not segfault while dir is locked */
      199 
      200 	call grab_aste (objectp, sys_info$max_seg_size, code, astep);
      201 	if code ^= 0 then goto fin;
      202 						/* locate entry */
      203 	call dc_find$obj_volume_retrieve (dirname, ename, audit_user_info_ptr, ep, code);
      204 	if code ^= 0 then goto fin;
      205 	dp = ptr (ep, 0);
      206 	dirl = "1"b;
      207 						/* check if object and entry match */
      208 	if entry.uid ^= input_vtoce.uid then do;
      209 		code = error_table_$vtoce_connection_fail;
      210 		goto fin;
      211 	     end;
      212 						/* links don't have objects */
      213 	if ^entry.bs then do;
      214 		code = error_table_$action_not_performed;
      215 		goto fin;
      216 	     end;
      217 	if ^entry.dirsw then do;			/* ensure that the logical volume is mounted	*/
      218 		code = mountedp (dir.sons_lvid);	/* before we truncate the target vtoce.		*/
      219 		if code ^= 0 then goto fin;		/* Thank you Steve Harris			*/
      220 	     end;
      221 
      222 	if entry.dirsw then do;			/* Get some quota info and save it. */
      223 		call sum$getbranch (dp, "0"b, par_ep, code);
      224 		if code ^= 0 then goto fin;
      225 		pardirl = "1"b;
      226 
      227 		par_uid = par_ep -> entry.uid;
      228 		par_vtocx = par_ep -> entry.vtocx;
      229 		par_pvid = par_ep -> entry.pvid;
      230 		qcp = addr (local_quota_cell);
      231 		do quota_type = 0 to 1;
      232 		     call vtoc_attributes$get_quota (par_uid, par_pvid, par_vtocx, qcp, quota_type, code);
      233 		     if code ^= 0 then goto fin;
      234 		     par_received (quota_type) = quota_cell.received;
      235 		     par_quota (quota_type) = quota_cell.quota;
      236 		end;
      237 						/* all done with parent so unlock */
      238 		call lock$dir_unlock (ptr (par_ep, 0));
      239 		pardirl = "0"b;
      240 	     end;
      241 
      242 /* Check to see if entry has vtoce. If not create a new one and set a flag */
      243 
      244 	pvid = entry.pvid;
      245 	uid = entry.uid;
      246 	pvtx = get_pvtx (pvid, code);
      247 	if code ^= 0 then goto fin;
      248 	vtocx = entry.vtocx;
      249 	vtocep = addr (local_vtoce);
      250 	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "100"b, vtocep, code);
      251 	if code ^= 0 then goto fin;
      252 	if entry.uid ^= vtoce.uid then do;		/* no vtoce */
      253 		call create_vtoce (ep, pvid, vtocx, code);
      254 		if code ^= 0 then goto fin;
      255 		entry.vtocx = vtocx;
      256 		entry.pvid = pvid;
      257 		pvtx = get_pvtx (pvid, code);
      258 		if code ^= 0 then goto fin;
      259 		new_vtoce = "1"b;
      260 	     end;
      261 						/* Make the entry known */
      262 	makeknown_infop = addr (local_makeknown_info);
      263 	makeknown_info.uid = uid;
      264 	makeknown_info.entryp = ep;
      265 	makeknown_info.activate, makeknown_info.dirsw = entry.dirsw;
      266 	makeknown_info.rsw = "0"b;
      267 	makeknown_info.allow_write = "1"b;
      268 	makeknown_info.priv_init = "1"b;
      269 	makeknown_info.audit = "0"b;
      270 	call makeknown_ (makeknown_infop, segno, (0), code);
      271 	if code ^= 0 then do;
      272 		if code = error_table_$segknown then code = 0;
      273 		else goto fin;
      274 	     end;
      275 						/* Fudge access in KST entry */
      276 	call force_kst_access;
      277 	if code ^= 0 then goto fin;
      278 	segptr = baseptr (segno);
      279 
      280 /* If the old object exists and it's a dir then there may entries in it that are in the newer copy.
      281*   If so then they should be preserved, not lost. Simiarly if the old directory has entries that the new
      282*   copy does not then they should be deleted.  */
      283 
      284 	mismatch = "1"b;
      285 	if ^new_vtoce & entry.dirsw then
      286 	     do while (mismatch);
      287 		call reset_new_dir;
      288 		if code ^= 0 then goto fin;
      289 	     end;
      290 						/* Truncate the object but hold the pvol its on */
      291 	call truncate_vtoce$hold (ep, 0, code);
      292 	if code ^= 0 then goto fin;
      293 	hold = "1"b;
      294 						/* Set the max length prior to the copy */
      295 	call vtoc_attributes$set_max_lth (uid, pvid, vtocx, fixed (input_vtoce.msl, 9), "1"b, code);
      296 	if code ^= 0 then goto fin;
      297 						/* Copy each non null page from the buffer */
      298 	do i = 0 to fixed (input_vtoce.csl, 9) - 1;
      299 	     if substr (input_vtoce.fm (i), 1, 1) = "0"b then
      300 		ptr (segptr, i * 1024) -> page = ptr (objectp, i * 1024) -> page;
      301 	end;
      302 						/* Reset dir header */
      303 	if entry.dirsw then do;
      304 		segptr -> dir.pvid = pvid;
      305 		segptr -> dir.vtocx = vtocx;
      306 	     end;
      307 						/* cleanup */
      308 	call revert_kst_access;
      309 	call makeunknown_ (segno, "0"b, ("0"b), ignore);
      310 						/* reset dates from input vtoce */
      311 	call vtoc_attributes$set_dates (uid, pvid, vtocx, input_vtoce.dtu, input_vtoce.dtm, ec);
      312 	dates_set = (ec ^= 0);
      313 						/* reset dump control switches from input vtoce */
      314 	if input_vtoce.nid = "1"b then nid = 1; else nid = -1;
      315 	if input_vtoce.ncd = "1"b then ncd = 1; else ncd = -1;
      316 	call vtoc_attributes$set_dump_switches (uid, pvid, vtocx, nid, ncd, ec);
      317 	dump_switches_set = (ec ^= 0);
      318 						/* and dump info */
      319 	call vtoc_attributes$set_dump_info (uid, pvid, vtocx, input_vtoce.dtd, input_vtoce.volid, ec);
      320 	dump_info_set = (ec ^= 0);
      321 						/* and pc control switches */
      322 	call vtoc_attributes$set_pc_switches (uid, pvid, vtocx, input_vtoce.dnzp || input_vtoce.gtpd, "11"b, ec);
      323 	pc_switches_set = (ec ^= 0);
      324 
      325 /* Now we check if the directory being copied will
      326*   create  new quota. If its a new vtoce we first reset the quota info from the input vtoce, otherwise just take
      327*   the quota and recieved. Next we check to see that the total recieved at this level is less then or equal to
      328*   the ammount the parent ditributed. If this fails we set the quota to 1. We must set it to 1 (and
      329*   manufacture some quota) or delete the directory for if we set it to 0 we would destroy the quota tree.
      330**/
      331 
      332 	if entry.dirsw then do;
      333 		qcp = addr (local_quota_cell);
      334 		call compute_inf_received;
      335 		if ec ^= 0 then goto q_done;
      336 		do quota_type = 0 to 1;
      337 		     call vtoc_attributes$get_quota (uid, pvid, vtocx, qcp, quota_type, ec);
      338 		     if ec ^= 0 then goto q_done;
      339 		     if new_vtoce then do;
      340 			     quota_cell.quota = input_vtoce.quota (quota_type);
      341 			     quota_cell.used = input_vtoce.used (quota_type);
      342 			     quota_cell.received = input_vtoce.received (quota_type);
      343 			     quota_cell.tup = input_vtoce.trp_time (quota_type);
      344 			     quota_cell.trp = input_vtoce.trp (quota_type);
      345 			     quota_cell.pad = 0;
      346 			end;
      347 		     else do;
      348 			     quota_cell.quota = input_vtoce.quota (quota_type);
      349 			     quota_cell.received = input_vtoce.received (quota_type);
      350 			end;
      351 		     if inf_received (quota_type) + par_quota (quota_type) + input_vtoce.received (quota_type) <= par_received (quota_type) then
      352 			call vtoc_attributes$set_quota (uid, pvid, vtocx, qcp, quota_type, ec);
      353 		     else do;
      354 			     quota_set = "1"b;
      355 			     quota_cell.quota = 1;
      356 			     call vtoc_attributes$set_quota (uid, pvid, vtocx, qcp, quota_type, ec);
      357 			     goto q_next;
      358 			end;
      359 q_done:		     quota_set = quota_set | (ec ^= 0);
      360 q_next:		end;
      361 	     end;
      362 
      363 fin:
      364 						/* cleanup, unlock, deference, and return args */
      365 	if hold then call get_pvtx$release_pvtx (pvid, pvtx);
      366 	if target_dirl then call lock$dir_unlock (target_dp);
      367 	if dp ^= null then call dc_find$finished (dp, dirl);
      368 	if pardirl then call lock$dir_unlock (ptr (par_ep, 0));
      369 	if astep ^= null then aste.ehs = "0"b;
      370 	a_attributes = attributes;
      371 ret:	a_code = code;
      372 	return;
      373 
      374 force_kst_access: proc;
      375 
      376 /* This proc locates the KST entry for segno, and forces the access so we can use it. It also set faults all other users.
      377*   users. Since we already have the directory locked, the access can not be change nor can any
      378*   user recoonect to the segment */
      379 
      380 	call get_kstep (segno, kstep, code);
      381 	if code ^= 0 then return;
      382 	kste.dtbm = entry.dtem;
      383 	kste.access = "101"b;
      384 	call setfaults$if_active (uid, pvid, vtocx, "0"b);
      385 	return;
      386 
      387      end force_kst_access;
      388 
      389 revert_kst_access: proc;
      390 
      391 /* This proc resets the KST entry and disconnects it from us */
      392 
      393 	kste.dtbm = (36)"1"b;
      394 	call setfaults$disconnect (segno);
      395 	return;
      396 
      397      end revert_kst_access;
      398 
      399 compute_inf_received: proc;
      400 
      401 /* This proc sums the recieved quota for all directory entries inferior to some directory */
      402 
      403 dcl nentries	     fixed bin;
      404 dcl ok		     fixed bin (35);
      405 dcl seen		     fixed bin;
      406 
      407 	inf_received (*) = 0;
      408 	nentries = dir.lcount + dir.seg_count + dir.dir_count;
      409 	seen = 0;
      410 	do ep = ptr (dp, dir.entryfrp) repeat (ptr (dp, entry.efrp)) while (rel (ep) ^= "0"b);
      411 	     seen = seen + 1;
      412 	     if seen > nentries then signal bad_dir_;
      413 	     if entry.bs then
      414 		if entry.owner ^= dir.uid then signal bad_dir_;
      415 		else ;
      416 	     else if link.owner ^= dir.uid
      417 		     | link.type ^= LINK_TYPE then signal bad_dir_;
      418 	     if entry.dirsw then do;
      419 		     if entry.type ^= DIR_TYPE then signal bad_dir_;
      420 		     dir_vtocx = entry.vtocx;
      421 		     dir_pvid = entry.pvid;
      422 		     dir_uid = entry.uid;
      423 		     qcp = addr (temp_quota_cell);
      424 		     do quota_type = 0 to 1;
      425 			call vtoc_attributes$get_quota (dir_uid, dir_pvid, dir_vtocx, qcp, quota_type, ok);
      426 			if ok = 0 then inf_received (quota_type) = inf_received (quota_type) + quota_cell.received;
      427 		     end;
      428 		end;
      429 	end;
      430 	return;
      431 
      432      end compute_inf_received;
      433 
      434 reset_new_dir: proc;
      435 
      436 /* This proc compares the old and new copies of a directory. For each uid match  it resets
      437*   the vtoce pointer. For each entry in the old not in the new it deletes it. This deletion operation is made without
      438*   access control checks. If deletion won't work the fact is logged with the reason. Of course when the copy
      439*   is made the subtrees will be automaticaly deleted, in the sense that they won't be found */
      440 
      441 dcl nentries1	     fixed bin;
      442 dcl nentries2	     fixed bin;
      443 dcl seen1		     fixed bin;
      444 dcl seen2		     fixed bin;
      445 
      446 	mismatch = "0"b;
      447 reset_loop: seen2 = 0;
      448 	nentries2 = segptr -> dir.lcount + segptr -> dir.dir_count + segptr -> dir.seg_count;
      449 	do old_ep = ptr (segptr, segptr -> dir.entryfrp) repeat (ptr (segptr, old_ep -> entry.efrp))
      450 	     while (rel (old_ep) ^= "0"b);
      451 	     seen2 = seen2 + 1;
      452 	     if seen2 > nentries2 then signal bad_dir_;
      453 	     seen1 = 0;
      454 	     nentries1 = objectp -> dir.lcount + objectp -> dir.dir_count + objectp -> dir.seg_count;
      455 	     do new_ep = ptr (objectp, objectp -> dir.entryfrp) repeat (ptr (objectp, new_ep -> entry.efrp))
      456 		while (rel (new_ep) ^= "0"b & new_ep -> entry.uid ^= old_ep -> entry.uid);
      457 		seen1 = seen1 + 1;
      458 		if seen1 > nentries1 then do;
      459 			code = error_table_$argerr;
      460 			return;
      461 		     end;
      462 	     end;
      463 	     if rel (new_ep) ^= "0"b then do;		/* entry in old and in new */
      464 		     new_ep -> entry.pvid = old_ep -> entry.pvid;
      465 		     new_ep -> entry.vtocx = old_ep -> entry.vtocx;
      466 		end;
      467 	     else if ^on_skip_list () then do;		/* entry in old but not in new - delete it */
      468 		     mismatch = "1"b;
      469 		     del_ename = ptr (old_ep, old_ep -> entry.name_frp) -> names.name;
      470 		     if dirname = ">" then del_pname = ">" || ename;
      471 		     else del_pname = rtrim (dirname) || ">" || ename;
      472 		     old_uid = old_ep -> entry.uid;
      473 		     dirsw = old_ep -> entry.dirsw;
      474 		     call lock$dir_unlock (segptr);	/* for delentry/del_dir_tree to work */
      475 		     target_dirl = "0"b;
      476 		     call dc_find$finished (dp, "1"b);
      477 		     dp = null;
      478 		     dirl = "0"b;
      479 		     if dirsw then do;
      480 subtree:			     call del_dir_tree$retv (del_pname, del_ename, del_code);
      481 			     if del_code ^= 0 then goto delerr;
      482 			end;
      483 		     call delentry$retv (del_pname, del_ename, del_code);
      484 		     if del_code = error_table_$fulldir then goto subtree;
      485 		     if del_code ^= 0 then do;
      486 delerr:			     call syserr$error_code (4, del_code, "retv_copy: deleting ^a>^a without recovering resources",
      487 				del_pname, del_ename);
      488 			     call add_to_skip_list;
      489 			end;
      490 		     call lock$dir_lock_read (segptr, code);
      491 		     if code ^= 0 then return;
      492 		     target_dirl = "1"b;
      493 		     call dc_find$obj_volume_retrieve (dirname, ename, audit_user_info_ptr, ep, code);
      494 		     if code ^= 0 then return;
      495 		     dirl = "1"b;
      496 		     if ep -> entry.uid ^= uid then do;	/* where did our dir go? */
      497 			code = error_table_$invalidsegno;
      498 			return;
      499 		     end;
      500 		     dp = ptr (ep, 0);
      501 		     goto reset_loop;
      502 		end;
      503 	end;
      504 	return;
      505 
      506      end reset_new_dir;
      507 
      508 on_skip_list: proc returns (bit (1));
      509 	found = "0"b;
      510 	do skip_list_idx = 1 to skip_list_cnt while (skip_list (skip_list_idx) ^= old_uid);
      511 	end;
      512 	if skip_list_idx <= skip_list_cnt then found = "1"b;
      513 	return (found);
      514 
      515      end on_skip_list;
      516 
      517 add_to_skip_list: proc;
      518 	skip_list_cnt = skip_list_cnt + 1;
      519 	skip_list (skip_list_cnt) = old_uid;
      520 	return;
      521 
      522      end add_to_skip_list;
      523  /* begin include file - access_audit_user_info.incl.pl1 */
  1     2 
  1     3 /* 85-01-21 EJ Sharpe - changed (min max)_auth to auth range */
  1     4 /* 85-01-07 EJ Sharpe - added min_authorization */
  1     5 /* 84-10-09 EJ Sharpe - created */
  1     6 
  1     7 /* The structure defined here is passed to the access_audit_
  1     8*entrypoints which deal with proxy users:
  1     9**/
  1    10 
  1    11 dcl audit_user_info_ptr	pointer;
  1    12 
  1    13 dcl 1 audit_user_info  based (audit_user_info_ptr) aligned,
  1    14       2 version		char (8),
  1    15       2 user_id		char (32),
  1    16       2 ring		fixed bin (3) uns unal,
  1    17       2 pad		bit (33) unal,
  1    18       2 process_id		bit (36) aligned,
  1    19       2 authorization	bit (72) aligned,
  1    20       2 authorization_range	(2) bit (72) aligned,
  1    21       2 audit_flags		bit (36) aligned;
  1    22 
  1    23 dcl audit_user_info_version_1	char (8) init ("adtusrv1")
  1    24 	internal static options (constant);
  1    25 
  1    26 /* end include file - access_audit_user_info.incl.pl1 */
      523 
      524  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      524 
      525  /* BEGIN include file dc_find_dcls.incl.pl1 */
  3     2 
  3     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  3     4 /* Added a few more, October 1984. */
  3     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  3     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  3     7 
  3     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  3     9 
  3    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  3    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  3    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  3    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  3    14 
  3    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  3    18 
  3    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  3    20 
  3    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  3    22 
  3    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  3    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  3    25 
  3    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  3    27 
  3    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  3    29 
  3    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    32 
  3    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  3    34 
  3    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  3    36 
  3    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  3    38 
  3    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    41 
  3    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    44 
  3    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    47 
  3    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    52 
  3    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  3    58 
  3    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  3    60 
  3    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  3    62 
  3    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  3    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  3    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  3    66 
  3    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  3    68 
  3    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  3    70 
  3    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    72 
  3    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    74 
  3    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  3    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    82 
  3    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    87 
  3    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  3    90 
  3    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  3    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  3    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  3    94 
  3    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    96 
  3    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  3    98 
  3    99 /* END include file dc_find_dcls.incl.pl1 */
      525 
      526  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      526 
      527  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  5     2 /* Modified 8/74 for NSS */
  5     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  5     4 /* Modified 3/82 BIM for change pclock */
  5     5 /* format: style3 */
  5     6 
  5     7 /* Template for the directory header. Length = 64 words. */
  5     8 
  5     9 dcl  dp ptr;
  5    10 
  5    11 dcl 1 dir based (dp) aligned,
  5    12 
  5    13    2 modify bit (36),				/* Process ID of last modifier */
  5    14    2 type bit (18) unaligned,			/* type of object = dir header */
  5    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  5    16     2 dtc (3),					/* date-time checked by salvager array */
  5    17       3 date bit (36),				/* the date */
  5    18       3 error bit (36),				/* what errors were discovered */
  5    19 
  5    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  5    21 
  5    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  5    23 
  5    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  5    25 
  5    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  5    27 
  5    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  5    29     2 version_number fixed bin (17),			/* version number of header */
  5    30 
  5    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  5    32     2 pad2 bit (18),
  5    33 
  5    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  5    35     2 pad3 bit (18),
  5    36 
  5    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  5    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  5    39 
  5    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  5    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  5    42 
  5    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  5    44     2 dir_count fixed bin (17),			/* number of directory branches */
  5    45 
  5    46     2 lcount fixed bin (17),				/* number of links */
  5    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  5    48 
  5    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  5    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  5    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  5    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  5    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  5    54     2 pad4 bit (14),
  5    55 
  5    56     2 iacl_count (0:7),
  5    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  5    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  5    59 
  5    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  5    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  5    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  5    63 
  5    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  5    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  5    66 
  5    67     2 htsize fixed bin (17),				/* size of hash table */
  5    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  5    69 
  5    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  5    71     2 pad6 fixed bin (17),
  5    72 
  5    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  5    74     2 pad7 bit (18)) unaligned,
  5    75 
  5    76     2 dts bit (36),					/* date-time directory last salvaged */
  5    77 
  5    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  5    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  5    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  5    81     2 checksum bit (36),				/* checksummed from uid on */
  5    82     2 owner bit (36);				/* uid of parent dir */
  5    83 
  5    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  5    85 
  5    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      527 
      528  /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  6     2 
  6     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  6     4 
  6     5 
  6     6 dcl 1 link based (ep) aligned,
  6     7 
  6     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  6     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  6    10 
  6    11     2 type bit (18),				/* type = dir link */
  6    12     2 size fixed bin (17),				/* size of link in words */
  6    13 
  6    14     2 uid bit (36),					/* unique id of entry */
  6    15 
  6    16     2 dtem bit (36),				/* date-time entry modified */
  6    17 
  6    18     2 bs bit (1),					/* entry switch = 1 if entry */
  6    19     2 pad0 bit (17),
  6    20     2 nnames fixed bin (17),				/* number of names for this entry */
  6    21 
  6    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  6    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  6    24 
  6    25     2 author,					/* user who created entry */
  6    26       3 pers_rp bit (18),				/* name of user who created entry */
  6    27       3 proj_rp bit (18),				/* project of user who created entry */
  6    28 
  6    29       3 tag char (1),				/* tag of user who created entry */
  6    30       3 pad1 char (3),
  6    31 
  6    32     2 primary_name bit (504),				/* first name on name list */
  6    33 
  6    34     2 dtd bit (36),					/* date time dumped */
  6    35 
  6    36     2 pad2 bit (36),
  6    37 
  6    38 
  6    39 /* the declarations below are only applicable to links */
  6    40 
  6    41     2 pad3 bit (18),
  6    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  6    43 
  6    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  6    45 
  6    46     2 checksum bit (36),				/* checksum from uid */
  6    47 
  6    48     2 owner bit (36);				/* uid of containing directory */
  6    49 
  6    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
      528 
      529  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  7     2 
  7     3 /* Template for names of branches or links. Length = 14 words. */
  7     4 
  7     5 dcl np ptr;
  7     6 
  7     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  7     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  7     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  7    10 
  7    11     2 type bit (18) unaligned,			/* type = dir name */
  7    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  7    13 
  7    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  7    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  7    16 
  7    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  7    18     2 pad3 bit (18) unal,
  7    19 
  7    20     2 name char(32) aligned,
  7    21 
  7    22     2 checksum bit (36),				/* checksum from entry_rp */
  7    23 
  7    24     2 owner bit (36);				/* uid of entry */
  7    25 
  7    26 
  7    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      529 
      530  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  8     2 
  8     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  8     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  8     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  8     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  8     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  8     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  8     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  8    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  8    11 
  8    12 dcl  access_name_type fixed bin static options (constant) init (1);
  8    13 dcl  acle_type fixed bin static options (constant) init (2);
  8    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  8    15 dcl  dir_type fixed bin static options (constant) init (4);
  8    16 dcl  link_type fixed bin static options (constant) init (5);
  8    17 dcl  name_type fixed bin static options (constant) init (6);
  8    18 dcl  seg_type fixed bin static options (constant) init (7);
  8    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  8    20 
  8    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      530 
      531  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  9     2 
  9     3 /*
  9     4*Modified March 1976 by R. Bratt 
  9     5*Modified November 1984 to remove hdr, Keith Loepere. */
  9     6 
  9     7 
  9     8 /****^  HISTORY COMMENTS:
  9     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  9    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  9    11*     Add warning on use of kste.entryp.
  9    12*                                                   END HISTORY COMMENTS */
  9    13 
  9    14 
  9    15 dcl  pds$kstp ext ptr,
  9    16     (kstp, kstep) ptr;
  9    17 
  9    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  9    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  9    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  9    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  9    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  9    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  9    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  9    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  9    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  9    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  9    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  9    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  9    30     2 unused_2 bit (9) unaligned,
  9    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  9    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  9    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  9    34     2 end_of_kst bit (36);
  9    35 
  9    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  9    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  9    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  9    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  9    40     2 entryp ptr unaligned,				/* branch pointer */
  9    41 						/* See WARNING below for requirements to use entryp. */
  9    42     2 uid bit (36) aligned,				/* unique identifier */
  9    43     2 access_information unaligned,
  9    44       3 dtbm bit (36),				/* date time branch modified */
  9    45       3 extended_access bit (33),			/* extended access from the branch */
  9    46       3 access bit (3),				/* rew */
  9    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  9    48     2 pad1 bit (3) unaligned,
  9    49     2 flags unaligned,
  9    50       3 dirsw bit (1),				/* directory switch */
  9    51       3 allow_write bit (1),				/* set if initiated with write permission */
  9    52       3 priv_init bit (1),				/* privileged initiation */
  9    53       3 tms bit (1),				/* transparent modification switch */
  9    54       3 tus bit (1),				/* transparent usage switch */
  9    55       3 tpd bit (1),				/* transparent paging device switch */
  9    56       3 audit bit (1),				/* audit switch */
  9    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  9    58       3 pad bit (3),
  9    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  9    60 
  9    61 
  9    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    63 /*							       */
  9    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  9    65 /* entry associated with the kst entry, you must first validate its value    */
  9    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  9    67 /* the containing directory.  The containing directory must remain locked    */
  9    68 /* during the entire period when kste.entryp and the directory entry are     */
  9    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  9    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  9    71 /* directory since the dir entry could have been moved within the directory  */
  9    72 /* by another processor.					       */
  9    73 /*							       */
  9    74 /* If you only need a pointer to the directory containing the associated     */
  9    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  9    76 /*    pointer (kste.entryp, 0)				       */
  9    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  9    78 /*							       */
  9    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    80 
  9    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      531 
      532  /*  BEGIN INCLUDE FILE - - - makeknown_info.incl.pl1 - - - last modified March 1975 by R. Bratt - - - */
 10     2 /* Modified October 1984 for explicit activate flag and to remove 
 10     3*   detectable flag, Keith Loepere. */
 10     4 
 10     5 dcl  makeknown_infop ptr;
 10     6 
 10     7 dcl 1 makeknown_info aligned based (makeknown_infop),
 10     8     2 uid bit (36) aligned,
 10     9     2 entryp ptr unaligned,
 10    10     2 flags unaligned,
 10    11       3 dirsw bit (1),
 10    12       3 rsw bit (1),
 10    13       3 allow_write bit (1),
 10    14       3 priv_init bit (1),
 10    15       3 audit bit (1),
 10    16       3 activate bit (1);			/* Use only for directory initiation within directory control */
 10    17 
 10    18 /*   END INCLUDE FILE makeknown_info.incl.pl1 - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      532 
      533  /* BEGIN INCLUDE FILE ... quota_cell.incl.pl1 ... February 1982 */
 11     2 
 11     3 dcl 1 quota_cell based (qcp) aligned,			/* Argument used by vtoc_attributes$(get set)_quota */
 11     4     2 quota fixed bin (35),				/* Record quota */
 11     5     2 used fixed bin (35),				/* Current use */
 11     6     2 received fixed bin (35),			/* Quota moved down */
 11     7     2 tup bit (36),					/* Clock time of update */
 11     8     2 trp fixed bin (71),				/* Time-page-product, in page-seconds */
 11     9     2 pad fixed bin,
 11    10     2 terminal_quota_sw bit (1);			/* TRUE if terminal quota */
 11    11 
 11    12 dcl  qcp ptr;
 11    13 
 11    14 /* END INCLUDE FILE ... quota_cell */
      533 
      534  /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
 12     2 
 12     3 dcl  sdwp ptr;
 12     4 
 12     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
 12     6 
 12     7    (2 add bit (24),					/* main memory address of page table */
 12     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
 12     9     2 df bit (1),					/* directed fault bit (0 => fault) */
 12    10     2 df_no bit (2),				/* directed fault number */
 12    11 
 12    12     2 pad1 bit (1),
 12    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
 12    14     2 access,					/* access bits */
 12    15       3 read bit (1),				/* read permission bit */
 12    16       3 execute bit (1),				/* execute permission bit */
 12    17       3 write bit (1),				/* write permission bit */
 12    18       3 privileged bit (1),				/* privileged bit */
 12    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
 12    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
 12    21     2 cache bit (1),				/* cache enable bit */
 12    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
 12    23 
 12    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
 12    25 
 12    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      534 
      535  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 13     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 13     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 13     4 
 13     5 dcl  vtocep ptr;
 13     6 
 13     7 dcl 1 vtoce based (vtocep) aligned,
 13     8 
 13     9 
 13    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 13    11 
 13    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 13    13 
 13    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 13    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 13    16     2 records bit (9),				/* number of records used by the seg in second storage */
 13    17     2 pad2 bit (9),
 13    18 
 13    19     2 dtu bit (36),					/* date and time segment was last used */
 13    20 
 13    21     2 dtm bit (36),					/* date and time segment was last modified */
 13    22 
 13    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 13    24     2 deciduous bit (1),				/* true if hc_sdw */
 13    25     2 nid bit (1),					/* no incremental dump switch */
 13    26     2 dnzp bit (1),					/* Dont null zero pages */
 13    27     2 gtpd bit (1),					/* Global transparent paging device */
 13    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 13    29     2 damaged bit (1),				/* TRUE if contents damaged */
 13    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 13    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 13    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 13    33     2 pad3 bit (8),
 13    34     2 dirsw bit (1),				/* directory switch */
 13    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 13    36     2 pad4 bit (16)) unaligned,			/* not used */
 13    37 
 13    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 13    39 
 13    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 13    41 
 13    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 13    43 
 13    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 13    45 
 13    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 13    47 
 13    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 13    49 
 13    50 
 13    51 
 13    52 
 13    53 
 13    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 13    55 
 13    56     2 pad6 (10) bit (36),				/* not used */
 13    57 
 13    58     2 ncd bit (1),					/* no complete dump switch */
 13    59     2 pad7 bit (17),
 13    60     2 pad8 bit (18),
 13    61 
 13    62     2 dtd bit (36),					/* date-time-dumped */
 13    63 
 13    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 13    65 
 13    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 13    67 
 13    68 
 13    69 
 13    70 
 13    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 13    72 
 13    73     2 primary_name char (32),				/* primary name of the segment */
 13    74 
 13    75     2 time_created bit (36),				/* time the segment was created */
 13    76 
 13    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 13    78 
 13    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 13    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 13    81 
 13    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 13    83 
 13    84     2 access_class bit (72),				/* access class in branch */
 13    85     2 perm_flags aligned,
 13    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 13    87       3 pad9 bit (35) unal,
 13    88     2 owner bit (36);				/* pvid of this volume */
 13    89 
 13    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 13    91 
 13    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 13    93     2 pad1 bit (7*36),
 13    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 13    95     2 pad2 bit (184*36);
 13    96 
 13    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      535 
      536 
      537 
      538 /* BEGIN MESSAGE DOCUMENTATION
      539*
      540*   Message:
      541*   retv_copy: deleting PATH without recovering resources ERROR_MESSAGE
      542*
      543*   S: $log
      544*
      545*   T: Volume retrieval
      546*
      547*   M: While retrieving a segment,
      548*   the retriever attempted to delete an old copy
      549*   of a segment before using a newer one.
      550*   The deletion attempt failed.
      551*   Space may be wasted on the volume
      552*   until a sweep_pv -gc is done.
      553*
      554*   A: Note for volume administrator.
      555*
      556*   END MESSAGE DOCUMENTATION */
      557 
      558      end retv_copy;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  retv_copy.pl1                     >spec>install>1110>retv_copy.pl1
523          1    02/12/85  1429.5  access_audit_user_info.incl.pl1   >ldd>include>access_audit_user_info.incl.pl1
524          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
525          3    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
526          4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
527          5    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
528          6    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
529          7    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
530          8    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
531          9    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
532         10    01/30/85  1523.9  makeknown_info.incl.pl1           >ldd>include>makeknown_info.incl.pl1
533         11    05/27/82  1525.9  quota_cell.incl.pl1               >ldd>include>quota_cell.incl.pl1
534         12    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
535         13    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 8-6 ref 419
LINK_TYPE                              constant        bit(18)                  initial packed unaligned dcl 8-7 ref 416
a_attributes                           parameter       bit(36)                  packed unaligned dcl 36 set ref 15 370*
a_auth                                 parameter       bit(72)                  dcl 37 ref 15 170
a_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 15 371*
a_dirname                              parameter       char                     dcl 39 ref 15 163
a_ename                                parameter       char                     dcl 40 ref 15 164
a_level                                parameter       fixed bin(17,0)          dcl 41 ref 15 168
a_objectp                              parameter       pointer                  dcl 42 ref 15 165
a_userid                               parameter       char                     dcl 43 ref 15 167
a_vtocep                               parameter       pointer                  dcl 44 ref 15 173
access                    6(33)        based           bit(3)                   level 3 packed packed unaligned dcl 9-36 set ref
                                                                                  383*
access_information        5            based           structure                level 2 packed packed unaligned dcl 9-36
activate                  2(05)        based           bit(1)                   level 3 packed packed unaligned dcl 10-7 set ref
                                                                                  265*
addr                                                   builtin function         dcl 157 ref 159 191 230 249 262 333 423
allow_write               2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 10-7 set ref
                                                                                  267*
aste                                   based           structure                level 1 dcl 2-11
astep                           004244 automatic       pointer                  dcl 2-9 set ref 179* 200* 369 369
attributes                      000100 automatic       bit(36)                  packed unaligned dcl 48 set ref 176* 312* 312 317*
                                                                                  317 320* 320 323* 323 354* 354 359* 359 359 359
                                                                                  370
audit                     2(04)        based           bit(1)                   level 3 packed packed unaligned dcl 10-7 set ref
                                                                                  269*
audit_flags              22            based           bit(36)                  level 2 dcl 1-13 set ref 172*
audit_user_info                        based           structure                level 1 dcl 1-13 set ref 160*
audit_user_info_ptr             004242 automatic       pointer                  dcl 1-11 set ref 159* 160 166 167 168 169 170 170
                                                                                  172 203* 493*
audit_user_info_version_1       000000 constant        char(8)                  initial packed unaligned dcl 1-23 ref 166
authorization            14            based           bit(72)                  level 2 dcl 1-13 set ref 170*
authorization_range      16            based           bit(72)                  array level 2 dcl 1-13 set ref 170*
bad_dir_                        000000 stack reference condition                dcl 154 ref 412 413 416 419 452
baseptr                                                builtin function         dcl 157 ref 278
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 213 413
cleanup                         004234 stack reference condition                dcl 155 ref 181
code                            000101 automatic       fixed bin(35,0)          dcl 49 set ref 177* 182* 193* 194 200* 201 203* 204
                                                                                  209* 214* 218* 219 223* 224 232* 233 246* 247 250*
                                                                                  251 253* 254 257* 258 270* 271 272 272* 277 288
                                                                                  291* 292 295* 296 371 380* 381 459* 490* 491 493*
                                                                                  494 497*
create_vtoce                    000026 constant        entry                    external dcl 122 ref 253
csl                       2(09) 000264 automatic       bit(9)                   level 2 packed packed unaligned dcl 66 set ref 298
dates_set                              defined         bit(1)                   packed unaligned dcl 103 set ref 312*
dc_find$finished                000110 constant        entry                    external dcl 3-33 ref 367 476
dc_find$obj_volume_retrieve     000112 constant        entry                    external dcl 3-95 ref 203 493
del_code                        000102 automatic       fixed bin(35,0)          dcl 50 set ref 480* 481 483* 484 485 486*
del_dir_tree$retv               000030 constant        entry                    external dcl 123 ref 480
del_ename                       000103 automatic       char(32)                 packed unaligned dcl 51 set ref 469* 480* 483* 486*
del_pname                       000113 automatic       char(168)                packed unaligned dcl 52 set ref 470* 471* 480* 483*
                                                                                  486*
delentry$retv                   000032 constant        entry                    external dcl 124 ref 483
dir                                    based           structure                level 1 dcl 5-11
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 ref 408 448
                                                                                  454
dir_pvid                        000165 automatic       bit(36)                  dcl 53 set ref 421* 425*
dir_uid                         000166 automatic       bit(36)                  dcl 54 set ref 422* 425*
dir_vtocx                       000167 automatic       fixed bin(17,0)          dcl 55 set ref 420* 425*
dirl                            000170 automatic       bit(1)                   dcl 56 set ref 175* 206* 367* 478* 495*
dirname                         000171 automatic       char(168)                packed unaligned dcl 57 set ref 163* 203* 470 471
                                                                                  493*
dirsw                           000243 automatic       bit(1)                   packed unaligned dcl 58 in procedure "retv_copy" set
                                                                                  ref 473* 479
dirsw                     2            based           bit(1)                   level 3 in structure "makeknown_info" packed packed
                                                                                  unaligned dcl 10-7 in procedure "retv_copy" set
                                                                                  ref 265*
dirsw                     5(18) 000264 automatic       bit(1)                   level 2 in structure "input_vtoce" packed packed
                                                                                  unaligned dcl 66 in procedure "retv_copy" set ref
                                                                                  189
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "retv_copy" ref 217 222 265
                                                                                  285 303 332 418 473
dnzp                      5(03) 000264 automatic       bit(1)                   level 2 packed packed unaligned dcl 66 set ref 322
dp                              004250 automatic       pointer                  dcl 5-9 set ref 179* 205* 218 223* 367 367* 408 408
                                                                                  408 410 410 413 416 429 476* 477* 500*
dtbm                      5            based           bit(36)                  level 3 packed packed unaligned dcl 9-36 set ref
                                                                                  382* 393*
dtd                     233     000264 automatic       bit(36)                  level 2 packed packed unaligned dcl 66 set ref 319*
dtem                      3            based           bit(36)                  level 2 dcl 4-8 ref 382
dtm                       4     000264 automatic       bit(36)                  level 2 packed packed unaligned dcl 66 set ref 311*
dtu                       3     000264 automatic       bit(36)                  level 2 packed packed unaligned dcl 66 set ref 311*
dump_info_set                          defined         bit(1)                   packed unaligned dcl 104 set ref 320*
dump_switches_set                      defined         bit(1)                   packed unaligned dcl 105 set ref 317*
ec                              000244 automatic       fixed bin(35,0)          dcl 59 set ref 311* 312 316* 317 319* 320 322* 323
                                                                                  335 337* 338 351* 356* 359
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 4-8 ref 429 462
                                                                                  503
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  369*
ename                           000245 automatic       char(32)                 packed unaligned dcl 60 set ref 164* 203* 470 471
                                                                                  493*
entry                                  based           structure                level 1 dcl 4-8
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 5-11 ref 410 449
                                                                                  455
entryp                    1            based           pointer                  level 2 packed packed unaligned dcl 10-7 set ref
                                                                                  264*
ep                              004246 automatic       pointer                  dcl 4-6 set ref 203* 205 208 213 217 222 244 245 248
                                                                                  252 253* 255 256 264 265 285 291* 303 332 382 410*
                                                                                  410* 413 413 416 416 418 419 420 421 422* 429 493*
                                                                                  496 500
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 112 ref 182 214
error_table_$argerr             000012 external static fixed bin(35,0)          dcl 113 ref 459
error_table_$fulldir            000014 external static fixed bin(35,0)          dcl 114 ref 484
error_table_$invalidsegno       000016 external static fixed bin(35,0)          dcl 115 ref 497
error_table_$segknown           000020 external static fixed bin(35,0)          dcl 116 ref 272
error_table_$vtoce_connection_fail
                                000022 external static fixed bin(35,0)          dcl 117 ref 209
fixed                                                  builtin function         dcl 157 ref 295 295 298
flags                     2            based           structure                level 2 packed packed unaligned dcl 10-7
fm                       20     000264 automatic       bit(18)                  array level 2 packed packed unaligned dcl 66 set ref
                                                                                  299
found                           000255 automatic       bit(1)                   packed unaligned dcl 61 set ref 509* 512* 513
get_kstep                       000034 constant        entry                    external dcl 125 ref 380
get_pvtx                        000036 constant        entry                    external dcl 126 ref 246 257
get_pvtx$release_pvtx           000040 constant        entry                    external dcl 127 ref 363
grab_aste                       000042 constant        entry                    external dcl 128 ref 200
gtpd                      5(04) 000264 automatic       bit(1)                   level 2 packed packed unaligned dcl 66 set ref 322
hold                            000256 automatic       bit(1)                   packed unaligned dcl 62 set ref 175* 293* 363
i                               000257 automatic       fixed bin(17,0)          dcl 63 set ref 298* 299 299 299*
ignore                          000260 automatic       fixed bin(35,0)          dcl 64 set ref 309*
inf_received                    000262 automatic       fixed bin(18,0)          array dcl 65 set ref 351 407* 426* 426
input_vtoce                     000264 automatic       structure                level 1 dcl 66 set ref 173*
kste                                   based           structure                level 1 dcl 9-36
kstep                           004252 automatic       pointer                  dcl 9-15 set ref 179* 183 380* 382 383 393
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 ref 408 448
                                                                                  454
link                                   based           structure                level 1 dcl 6-6
local_audit_user_info           000564 automatic       structure                level 1 dcl 67 set ref 159
local_dir_header                000607 automatic       structure                level 1 dcl 68 set ref 190* 191
local_makeknown_info            000707 automatic       structure                level 1 dcl 69 set ref 262
local_quota_cell                000712 automatic       structure                level 1 dcl 70 set ref 230 333
local_vtoce                     000722 automatic       structure                level 1 dcl 71 set ref 249
lock$dir_lock_read              000044 constant        entry                    external dcl 129 ref 193 490
lock$dir_unlock                 000046 constant        entry                    external dcl 130 ref 238 366 368 474
makeknown_                      000050 constant        entry                    external dcl 131 ref 270
makeknown_info                         based           structure                level 1 dcl 10-7
makeknown_infop                 004254 automatic       pointer                  dcl 10-5 set ref 262* 263 264 265 265 266 267 268
                                                                                  269 270*
makeunknown_                    000052 constant        entry                    external dcl 132 ref 309
mismatch                        001222 automatic       bit(1)                   packed unaligned dcl 72 set ref 284* 285 446* 468*
mountedp                        000054 constant        entry                    external dcl 133 ref 218
msl                       2     000264 automatic       bit(9)                   level 2 packed packed unaligned dcl 66 set ref 295
                                                                                  295
name                      4            based           char(32)                 level 2 dcl 7-7 ref 469
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 4-8 ref 469
names                                  based           structure                level 1 dcl 7-7
ncd                     232     000264 automatic       bit(1)                   level 2 in structure "input_vtoce" packed packed
                                                                                  unaligned dcl 66 in procedure "retv_copy" set ref
                                                                                  315
ncd                             001223 automatic       fixed bin(17,0)          dcl 73 in procedure "retv_copy" set ref 315* 315*
                                                                                  316*
nentries                        004300 automatic       fixed bin(17,0)          dcl 403 set ref 408* 412
nentries1                       004322 automatic       fixed bin(17,0)          dcl 441 set ref 454* 458
nentries2                       004323 automatic       fixed bin(17,0)          dcl 442 set ref 448* 452
new_ep                          001224 automatic       pointer                  dcl 74 set ref 455* 455 455* 462 463 464 465
new_vtoce                       001226 automatic       bit(1)                   packed unaligned dcl 75 set ref 175* 259* 285 339
nid                       5(02) 000264 automatic       bit(1)                   level 2 in structure "input_vtoce" packed packed
                                                                                  unaligned dcl 66 in procedure "retv_copy" set ref
                                                                                  314
nid                             001227 automatic       fixed bin(17,0)          dcl 76 in procedure "retv_copy" set ref 314* 314*
                                                                                  316*
null                                                   builtin function         dcl 157 ref 179 183 367 369 477
objectp                         001230 automatic       pointer                  dcl 77 set ref 165* 200* 299 454 454 454 455 455 462
ok                              004301 automatic       fixed bin(35,0)          dcl 404 set ref 425* 426
old_ep                          001232 automatic       pointer                  dcl 78 set ref 449* 449* 455 464 465 469 469 472
                                                                                  473* 503
old_uid                         001234 automatic       bit(36)                  dcl 79 set ref 472* 510 519
owner                                  based           bit(36)                  level 2 in structure "link" dcl 6-6 in procedure
                                                                                  "retv_copy" ref 416
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "retv_copy" ref 413
pad                       6            based           fixed bin(17,0)          level 2 dcl 11-3 set ref 345*
page                                   based           bit(72)                  array dcl 106 set ref 299* 299
par_ep                          001236 automatic       pointer                  dcl 80 set ref 223* 227 228 229 238 238 368 368
par_pvid                        001240 automatic       bit(36)                  dcl 81 set ref 229* 232*
par_quota                       001242 automatic       fixed bin(18,0)          array dcl 82 set ref 235* 351
par_received                    001244 automatic       fixed bin(18,0)          array dcl 83 set ref 234* 351
par_uid                         001246 automatic       bit(36)                  dcl 84 set ref 227* 232*
par_vtocx                       001247 automatic       fixed bin(17,0)          dcl 85 set ref 228* 232*
pardirl                         001250 automatic       bit(1)                   dcl 86 set ref 175* 225* 239* 368
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-6 ref 416
pc_switches_set                        defined         bit(1)                   packed unaligned dcl 107 set ref 323*
priv_init                 2(03)        based           bit(1)                   level 3 packed packed unaligned dcl 10-7 set ref
                                                                                  268*
process_id               13            based           bit(36)                  level 2 dcl 1-13 set ref 169*
ptr                                                    builtin function         dcl 157 ref 205 238 238 299 299 368 368 410 429 449
                                                                                  455 462 469 500 503
pvid                            001251 automatic       bit(36)                  dcl 87 in procedure "retv_copy" set ref 244* 246*
                                                                                  250* 253* 256 257* 295* 304 311* 316* 319* 322*
                                                                                  337* 351* 356* 363* 384*
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "retv_copy" set ref 229 244
                                                                                  256* 421 464* 464
pvid                     11            based           bit(36)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "retv_copy" set ref 304*
pvtx                            001252 automatic       fixed bin(17,0)          dcl 88 set ref 246* 250* 257* 363*
qcp                             004256 automatic       pointer                  dcl 11-12 set ref 230* 232* 234 235 333* 337* 340
                                                                                  341 342 343 344 345 348 349 351* 355 356* 423*
                                                                                  425* 426
quota                     7     000264 automatic       fixed bin(18,0)          array level 2 in structure "input_vtoce" packed
                                                                                  packed unsigned unaligned dcl 66 in procedure
                                                                                  "retv_copy" set ref 340 348
quota                                  based           fixed bin(35,0)          level 2 in structure "quota_cell" dcl 11-3
                                                                                  in procedure "retv_copy" set ref 235 340* 348*
                                                                                  355*
quota_cell                             based           structure                level 1 dcl 11-3
quota_set                              defined         bit(1)                   packed unaligned dcl 108 set ref 354* 359* 359
quota_type                      001253 automatic       fixed bin(17,0)          dcl 89 set ref 231* 232* 234 235* 336* 337* 340 341
                                                                                  342 343 344 348 349 351 351 351 351 351* 356* 424*
                                                                                  425* 426 426*
received                 11     000264 automatic       fixed bin(18,0)          array level 2 in structure "input_vtoce" packed
                                                                                  packed unsigned unaligned dcl 66 in procedure
                                                                                  "retv_copy" set ref 342 349 351
received                  2            based           fixed bin(35,0)          level 2 in structure "quota_cell" dcl 11-3
                                                                                  in procedure "retv_copy" set ref 234 342* 349* 426
rel                                                    builtin function         dcl 157 ref 410 449 455 463
ring                     12            based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 1-13
                                                                                  set ref 168*
rsw                       2(01)        based           bit(1)                   level 3 packed packed unaligned dcl 10-7 set ref
                                                                                  266*
rtrim                                                  builtin function         dcl 157 ref 471
sdw                                    based           structure                level 1 dcl 12-5
seen                            004302 automatic       fixed bin(17,0)          dcl 405 set ref 409* 411* 411 412
seen1                           004324 automatic       fixed bin(17,0)          dcl 443 set ref 453* 457* 457 458
seen2                           004325 automatic       fixed bin(17,0)          dcl 444 set ref 447* 451* 451 452
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 ref 408 448
                                                                                  454
segno                           001254 automatic       fixed bin(17,0)          dcl 90 set ref 178* 270* 278 309* 380* 394*
segptr                          001256 automatic       pointer                  dcl 91 set ref 278* 299 304 305 448 448 448 449 449
                                                                                  474* 490* 503
setfaults$disconnect            000056 constant        entry                    external dcl 134 ref 394
setfaults$if_active             000060 constant        entry                    external dcl 135 ref 384
skip_list                       001260 automatic       bit(36)                  array dcl 92 set ref 510 519*
skip_list_cnt                   004214 automatic       fixed bin(17,0)          initial dcl 93 set ref 93* 510 512 518* 518 519
skip_list_idx                   004215 automatic       fixed bin(17,0)          dcl 94 set ref 510* 510* 512
sons_lvid                12            based           bit(36)                  level 2 dcl 5-11 set ref 218*
substr                                                 builtin function         dcl 157 ref 299
sum$getbranch                   000062 constant        entry                    external dcl 136 ref 223
sys_info$max_seg_size           000024 external static fixed bin(17,0)          dcl 118 set ref 200*
syserr$error_code               000064 constant        entry                    external dcl 137 ref 486
target_dirl                     004216 automatic       bit(1)                   packed unaligned dcl 95 set ref 175* 195* 366 475*
                                                                                  492*
target_dp                       004220 automatic       pointer                  dcl 96 set ref 191* 193* 366*
temp_quota_cell                 004222 automatic       structure                level 1 dcl 97 set ref 423
trp                       4            based           fixed bin(71,0)          level 2 in structure "quota_cell" dcl 11-3
                                                                                  in procedure "retv_copy" set ref 344*
trp                      12     000264 automatic       fixed bin(71,0)          array level 2 in structure "input_vtoce" packed
                                                                                  packed unaligned dcl 66 in procedure "retv_copy"
                                                                                  set ref 344
trp_time                 16     000264 automatic       bit(36)                  array level 2 packed packed unaligned dcl 66 set ref
                                                                                  343
truncate_vtoce$hold             000066 constant        entry                    external dcl 138 ref 291
tup                       3            based           bit(36)                  level 2 dcl 11-3 set ref 343*
type                      1            based           bit(18)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 6-6 in procedure "retv_copy" ref 416
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "retv_copy" ref 419
uid                       1            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 13-7 in procedure "retv_copy" ref 252
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "retv_copy" ref 413 416
uid                      10     000607 automatic       bit(36)                  level 2 in structure "local_dir_header" dcl 68
                                                                                  in procedure "retv_copy" set ref 192*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "retv_copy" ref 208 227 245 252 422 455 455 472
                                                                                  496
uid                             004232 automatic       bit(36)                  dcl 98 in procedure "retv_copy" set ref 245* 263
                                                                                  295* 311* 316* 319* 322* 337* 351* 356* 384* 496
uid                       1     000264 automatic       bit(36)                  level 2 in structure "input_vtoce" packed packed
                                                                                  unaligned dcl 66 in procedure "retv_copy" set ref
                                                                                  192 208
uid                                    based           bit(36)                  level 2 in structure "makeknown_info" dcl 10-7
                                                                                  in procedure "retv_copy" set ref 263*
unspec                                                 builtin function         dcl 157 set ref 160* 190*
used                     10     000264 automatic       fixed bin(18,0)          array level 2 in structure "input_vtoce" packed
                                                                                  packed unsigned unaligned dcl 66 in procedure
                                                                                  "retv_copy" set ref 341
used                      1            based           fixed bin(35,0)          level 2 in structure "quota_cell" dcl 11-3
                                                                                  in procedure "retv_copy" set ref 341*
user_id                   2            based           char(32)                 level 2 dcl 1-13 set ref 167*
version                                based           char(8)                  level 2 dcl 1-13 set ref 166*
volid                   234     000264 automatic       bit(36)                  array level 2 packed packed unaligned dcl 66 set ref
                                                                                  319*
vtoc_attributes$get_quota       000070 constant        entry                    external dcl 139 ref 232 337 425
vtoc_attributes$set_dates       000072 constant        entry                    external dcl 140 ref 311
vtoc_attributes$set_dump_info   000074 constant        entry                    external dcl 141 ref 319
vtoc_attributes$set_dump_switches
                                000076 constant        entry                    external dcl 143 ref 316
vtoc_attributes$set_max_lth     000100 constant        entry                    external dcl 145 ref 295
vtoc_attributes$set_pc_switches 000102 constant        entry                    external dcl 147 ref 322
vtoc_attributes$set_quota       000104 constant        entry                    external dcl 149 ref 351 356
vtoc_man$get_vtoce              000106 constant        entry                    external dcl 150 ref 250
vtoce                                  based           structure                level 1 dcl 13-7 ref 173
vtocep                          004260 automatic       pointer                  dcl 13-5 set ref 249* 250* 252
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "retv_copy" set ref 228 248
                                                                                  255* 420 465* 465
vtocx                           004233 automatic       fixed bin(17,0)          dcl 99 in procedure "retv_copy" set ref 248* 250*
                                                                                  253* 255 295* 305 311* 316* 319* 322* 337* 351*
                                                                                  356* 384*
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 5-11 in procedure "retv_copy" set ref 305*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 8-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 8-4
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 3-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 3-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 3-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 3-13
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 8-5
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 8-10
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 8-8
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 8-9
access_name_type                       internal static fixed bin(17,0)          initial dcl 8-12
acle_type                              internal static fixed bin(17,0)          initial dcl 8-13
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
dc_find$dir_for_append          000000 constant        entry                    external dcl 3-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 3-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 3-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 3-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 3-21
dc_find$dir_read                000000 constant        entry                    external dcl 3-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 3-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 3-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 3-28
dc_find$dir_write               000000 constant        entry                    external dcl 3-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 3-31
dc_find$link_target             000000 constant        entry                    external dcl 3-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 3-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 3-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 3-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 3-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 3-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 3-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 3-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 3-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 3-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 3-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 3-51
dc_find$obj_delete              000000 constant        entry                    external dcl 3-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 3-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 3-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 3-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 3-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 3-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 3-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 3-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 3-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 3-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 3-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 3-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 3-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 3-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 3-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 3-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 3-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 3-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 3-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 3-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 3-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 3-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 3-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 3-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 3-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 3-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 3-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 3-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 3-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 3-93
dc_find$seg_fault               000000 constant        entry                    external dcl 3-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 8-14
dir_type                               internal static fixed bin(17,0)          initial dcl 8-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 8-19
kst                                    based           structure                level 1 dcl 9-18
kstp                                   automatic       pointer                  dcl 9-15
link_type                              internal static fixed bin(17,0)          initial dcl 8-16
name_type                              internal static fixed bin(17,0)          initial dcl 8-17
np                                     automatic       pointer                  dcl 7-5
pds$kstp                               external static pointer                  dcl 9-15
sdwa                                   based           structure                array level 1 dcl 12-24
sdwp                                   automatic       pointer                  dcl 12-3
seg_aste                               based           structure                level 1 dcl 2-96
seg_type                               internal static fixed bin(17,0)          initial dcl 8-18
seg_vtoce                              based           structure                level 1 dcl 13-92
version_number_2                       internal static fixed bin(17,0)          initial dcl 5-84
vtoce_parts                            based           bit(2304)                array dcl 13-90

NAMES DECLARED BY EXPLICIT CONTEXT.
add_to_skip_list                002566 constant        entry                    internal dcl 517 ref 488
compute_inf_received            001662 constant        entry                    internal dcl 399 ref 334
delerr                          002412 constant        label                    dcl 486 ref 481
fin                             001477 constant        label                    dcl 363 ref 184 194 201 204 210 215 219 224 233 247
                                                                                  251 254 258 272 277 288 292 296
force_kst_access                001572 constant        entry                    internal dcl 374 ref 276
on_skip_list                    002535 constant        entry                    internal dcl 508 ref 467
q_done                          001471 constant        label                    dcl 359 ref 335 338
q_next                          001475 constant        label                    dcl 360 ref 357
reset_loop                      002065 constant        label                    dcl 447 ref 501
reset_new_dir                   002063 constant        entry                    internal dcl 434 ref 287
ret                             001567 constant        label                    dcl 371
retv_copy                       000051 constant        entry                    external dcl 15
revert_kst_access               001642 constant        entry                    internal dcl 389 ref 183 308
subtree                         002340 constant        label                    dcl 480 ref 484

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3242        3356    2605        3252
Length      4052    2605       114         457     434           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
retv_copy                          2414 external procedure  is an external procedure.  
on unit on line 181                  64 on unit               
force_kst_access                        internal procedure  shares stack frame of external procedure retv_copy.  
revert_kst_access                    68 internal procedure  is called by several nonquick procedures.  
compute_inf_received                    internal procedure  shares stack frame of external procedure retv_copy.  
reset_new_dir                           internal procedure  shares stack frame of external procedure retv_copy.  
on_skip_list                            internal procedure  shares stack frame of external procedure retv_copy.  
add_to_skip_list                        internal procedure  shares stack frame of external procedure retv_copy.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
retv_copy                000100 attributes                  retv_copy
                         000101 code                        retv_copy
                         000102 del_code                    retv_copy
                         000103 del_ename                   retv_copy
                         000113 del_pname                   retv_copy
                         000165 dir_pvid                    retv_copy
                         000166 dir_uid                     retv_copy
                         000167 dir_vtocx                   retv_copy
                         000170 dirl                        retv_copy
                         000171 dirname                     retv_copy
                         000243 dirsw                       retv_copy
                         000244 ec                          retv_copy
                         000245 ename                       retv_copy
                         000255 found                       retv_copy
                         000256 hold                        retv_copy
                         000257 i                           retv_copy
                         000260 ignore                      retv_copy
                         000262 inf_received                retv_copy
                         000264 input_vtoce                 retv_copy
                         000564 local_audit_user_info       retv_copy
                         000607 local_dir_header            retv_copy
                         000707 local_makeknown_info        retv_copy
                         000712 local_quota_cell            retv_copy
                         000722 local_vtoce                 retv_copy
                         001222 mismatch                    retv_copy
                         001223 ncd                         retv_copy
                         001224 new_ep                      retv_copy
                         001226 new_vtoce                   retv_copy
                         001227 nid                         retv_copy
                         001230 objectp                     retv_copy
                         001232 old_ep                      retv_copy
                         001234 old_uid                     retv_copy
                         001236 par_ep                      retv_copy
                         001240 par_pvid                    retv_copy
                         001242 par_quota                   retv_copy
                         001244 par_received                retv_copy
                         001246 par_uid                     retv_copy
                         001247 par_vtocx                   retv_copy
                         001250 pardirl                     retv_copy
                         001251 pvid                        retv_copy
                         001252 pvtx                        retv_copy
                         001253 quota_type                  retv_copy
                         001254 segno                       retv_copy
                         001256 segptr                      retv_copy
                         001260 skip_list                   retv_copy
                         004214 skip_list_cnt               retv_copy
                         004215 skip_list_idx               retv_copy
                         004216 target_dirl                 retv_copy
                         004220 target_dp                   retv_copy
                         004222 temp_quota_cell             retv_copy
                         004232 uid                         retv_copy
                         004233 vtocx                       retv_copy
                         004242 audit_user_info_ptr         retv_copy
                         004244 astep                       retv_copy
                         004246 ep                          retv_copy
                         004250 dp                          retv_copy
                         004252 kstep                       retv_copy
                         004254 makeknown_infop             retv_copy
                         004256 qcp                         retv_copy
                         004260 vtocep                      retv_copy
                         004300 nentries                    compute_inf_received
                         004301 ok                          compute_inf_received
                         004302 seen                        compute_inf_received
                         004322 nentries1                   reset_new_dir
                         004323 nentries2                   reset_new_dir
                         004324 seen1                       reset_new_dir
                         004325 seen2                       reset_new_dir

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           signal_op           enable_op           shorten_stack
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
create_vtoce                  dc_find$finished              dc_find$obj_volume_retrieve   del_dir_tree$retv
delentry$retv                 get_kstep                     get_pvtx                      get_pvtx$release_pvtx
grab_aste                     lock$dir_lock_read            lock$dir_unlock               makeknown_
makeunknown_                  mountedp                      setfaults$disconnect          setfaults$if_active
sum$getbranch                 syserr$error_code             truncate_vtoce$hold           vtoc_attributes$get_quota
vtoc_attributes$set_dates     vtoc_attributes$set_dump_info vtoc_attributes$set_dump_switches
vtoc_attributes$set_max_lth   vtoc_attributes$set_pc_switches                             vtoc_attributes$set_quota
vtoc_man$get_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$argerr           error_table_$fulldir
error_table_$invalidsegno     error_table_$segknown         error_table_$vtoce_connection_fail
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000042        93 000076       159 000077       160 000101       163 000104       164 000112       165 000117
    166 000122       167 000126       168 000133       169 000140       170 000141       172 000150       173 000152
    175 000157       176 000164       177 000165       178 000166       179 000170       181 000174       182 000210
    183 000213       184 000224       189 000227       190 000232       191 000235       192 000237       193 000241
    194 000252       195 000254       200 000256       201 000273       203 000275       204 000314       205 000316
    206 000320       208 000322       209 000326       210 000331       213 000332       214 000335       215 000340
    217 000341       218 000344       219 000355       222 000357       223 000363       224 000402       225 000404
    227 000406       228 000411       229 000414       230 000416       231 000420       232 000425       233 000446
    234 000450       235 000454       236 000456       238 000460       239 000471       244 000472       245 000475
    246 000477       247 000512       248 000514       249 000520       250 000522       251 000545       252 000547
    253 000554       254 000571       255 000573       256 000577       257 000601       258 000614       259 000616
    262 000620       263 000622       264 000624       265 000626       266 000642       267 000644       268 000646
    269 000650       270 000652       271 000670       272 000672       276 000676       277 000677       278 000701
    284 000705       285 000707       287 000720       288 000721       289 000723       291 000724       292 000740
    293 000742       295 000744       296 000772       298 000774       299 001005       301 001025       303 001027
    304 001033       305 001036       308 001041       309 001045       311 001066       312 001107       314 001114
    314 001124       315 001126       315 001135       316 001137       317 001160       319 001166       320 001207
    322 001215       323 001252       332 001260       333 001264       334 001266       335 001267       336 001271
    337 001275       338 001316       339 001320       340 001322       341 001333       342 001342       343 001350
    344 001353       345 001361       346 001362       348 001363       349 001374       351 001403       354 001443
    355 001445       356 001447       357 001470       359 001471       360 001475       363 001477       366 001512
    367 001523       368 001540       369 001553       370 001562       371 001567       372 001571       374 001572
    380 001573       381 001606       382 001611       383 001615       384 001621       385 001640       389 001641
    393 001647       394 001653       395 001661       399 001662       407 001663       408 001674       409 001711
    410 001712       411 001722       412 001723       413 001731       415 001744       416 001745       418 001767
    419 001773       420 002002       421 002006       422 002010       423 002012       424 002014       425 002021
    426 002042       427 002052       429 002054       430 002062       434 002063       446 002064       447 002065
    448 002066       449 002103       451 002112       452 002113       453 002121       454 002122       455 002137
    457 002154       458 002155       459 002160       460 002163       462 002164       463 002172       464 002174
    465 002200       466 002202       467 002203       468 002210       469 002212       470 002222       471 002242
    472 002302       473 002305       474 002310       475 002317       476 002320       477 002333       478 002335
    479 002336       480 002340       481 002361       483 002363       484 002404       485 002410       486 002412
    488 002450       490 002451       491 002462       492 002465       493 002467       494 002506       495 002511
    496 002513       497 002517       498 002522       500 002523       501 002525       503 002526       504 002534
    508 002535       509 002537       510 002540       511 002552       512 002554       513 002560       517 002566
    518 002567       519 002570       520 002573


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
