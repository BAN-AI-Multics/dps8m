	COMPILATION LISTING OF SEGMENT backup_load
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0935.0 mst Sat
	    Options: optimize map

        1 
        2 /****^  ***********************************************************
        3*        *                                                         *
        4*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        5*        *                                                         *
        6*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        7*        *                                                         *
        8*        * Copyright (c) 1972 by Massachusetts Institute of        *
        9*        * Technology and Honeywell Information Systems, Inc.      *
       10*        *                                                         *
       11*        *********************************************************** */
       12 
       13 /* The hierarchy reloader/retriever */
       14 
       15 /* Created:  February 1969 by R. C. Daley. */
       16 /* Modified: 16 June 1970 by R. H. Campbell */
       17 /* Modified: 21 October 1970 by R. J. Feiertag */
       18 /* Modified: 10 May 1971 by R. A. Tilden */
       19 /* Modified: 11 Nov 1973 by E. Stone to allow selected users to use 256K segs */
       20 /* Modified: 22 July 1974 by R. E. Mullen for sec_seg + sec_dir types */
       21 /* Modified: 21 October 1974 by A. Kobziar to handle access_mode field */
       22 /* Modified: February 1975 by R. E. Mullen for tape, cpu, and paging speedups */
       23 /* Modified: July 1975 by R. Bratt for new KST cleanup scheme, to burn our bridges behind us, to cleanup, and to fix an
       24*   IACL reloading bug */
       25 /* Modified: Autumn 1975 by R. E. Mullen to retune for NSS by not calling status_long for access_mode and to not set max
       26*   length and entrybound when already set by create_branch_ */
       27 /* Modified: February 1976 by R. Bratt to improve KST cleanup */
       28 /* Modified: May 1976 by R. Bratt to handle deleted PVs */
       29 /* Modified: September 1976 by R. Bratt to not do KST cleanup ditty */
       30 /* Modified: 2 November 1977 by S. Herbst to add backup_load_ entry point */
       31 /* Modified: 3 August 1979 by S. Herbst to add -trim and fix bugs */
       32 /* Modified: 17 July 1980 by S. Herbst to test for phcs_ and hphcs_ access */
       33 /* Modified: 6 November 1980 by G. Palter for version 3 backup_control structure */
       34 /* Modified: 8 January 1981 by G.  Palter to fix a bug which prevented reloading all entries in a directory which already
       35*   existed online if the reloading process didn't already have "sma" access on the directory */
       36 /* Modified: December 1981 by C. Hornig to remove calls to hphcs_$set_dir_size */
       37 /* Modified: 21 January 1982 by S. Herbst to test for access to system_privilege_ in addition to phcs_ and hphcs_ */
       38 /* Modified: 5 February 1982 by S. Herbst to retrieve an entire MSF without haing to specify ">**" */
       39 /* Modified: 23 March 1982 by S. Herbst to omit date comparision on second pass for directories */
       40 /* Modified: May 1982 by Benson I. Margulies to do ACLs straight forwardly */
       41 /* Modified: July 1982 by G. Palter to add features for IMFT support of AIM: enforce a minimum ring for all created
       42*   branches, restore the access class of the branch even if in debug mode, and translate access classes between systems */
       43 /* BIM: 10/82: removed acl printing */
       44 /* BIM: 2/83: Consider status_for_backup version 0 equivalent to 2 to */
       45 /* clean up after hardcore bug in 10.0 */
       46 /* Modified February 1983, E. N. Kittlitz. 256K segments */
       47 /* Modified 1985-03-21, BIM: fixed prehistoric busted condition handler.
       48*   -------- -- Fixed not to force access in no-reload mode.
       49*   phx18650 -- does not reset transparency switches.
       50*   phx17329 -- mishandling empty acls.
       51*   phx17310 -- unitialized variables in cross-dumping.
       52*   phx16651 -- rqovers on the map do not always get to level 2.
       53*   phx13714 -- catching command_error conditions */
       54 
       55 /****^  HISTORY COMMENTS:
       56*  1) change(87-07-15,GDixon), approve(87-07-15,MCR7617),
       57*     audit(87-07-16,RBarstad), install(87-07-16,MR12.1-1041):
       58*     Modified for change to backup_record_types.incl.pl1.
       59*  2) change(88-05-11,Lippard), approve(88-05-02,MCR7881),
       60*     audit(88-06-15,Fawcett), install(88-08-02,MR12.2-1074):
       61*     Changed to add reloading of the audit_flag attribute. This changed the
       62*     reload_set_version to 2.
       63*                                                   END HISTORY COMMENTS */
       64 
       65 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       66 
       67 
       68 backup_load:
       69      procedure ();
       70 
       71 dcl  (i, n, hcnt, scnt, type, htype) fixed bin,		/* temporary storage */
       72      (old_trans_sw, sys_type, ts) fixed bin (2),		/* Save previous settings of transparent switches. */
       73      bc fixed bin,					/* Segment bit count. */
       74      dtd_test bit (36) aligned,			/* time from  backup to test for later copy */
       75      (dtp, dtd, dtu, dtem, dtsm) fixed bin (52),		/* Storage for various times. */
       76      (np, ap, segptr, bp, aclp, ix) ptr,
       77      pp ptr,					/* Use in an incl file. */
       78      dump_date char (24),				/* Storage for conversion of time record written. */
       79      ring fixed bin (3),				/* ring number for reloading initial ACLs */
       80      old_dname char (168) varying init (""),		/* Previous directory name. */
       81      new_dir bit (1) aligned init ("1"b),		/* set if name header needs printing */
       82      optionsw fixed bin (2),				/* Copy of option switch. */
       83      save_ename char (32) aligned,			/* real pri name of reloaded seg */
       84      save_elen fixed bin,
       85      MRS fixed bin init (0),				/* if nonzero must read seg still */
       86      FRS fixed bin init (0),				/* if nonzero reload directly to target seg, else pdir */
       87      INITIALIZER bit (1) aligned init ("0"b),		/* "1"b => user has total access */
       88      hs_dirname char (168) varying aligned init (""),	/* last dir for which HAVE_SMA was called */
       89      hs_bit bit (1) init ("0"b),			/* result of HAVE_SMA call */
       90      USERID char (32),				/* used by HAVE_SMA intl proc */
       91      access_class bit (72) aligned,			/* access class of branch */
       92      (a_code, dir_priv_code, code) fixed bin (35),
       93      control_ptr ptr,				/* ptr to control structure for backup_load_ */
       94      octal_string character (32) aligned,
       95      dirname_dirname character (168),
       96      dirname_ename character (32);
       97 dcl  old_256K_switch bit (2) aligned;
       98 
       99 dcl  (cleanup, record_quota_overflow) condition;
      100 
      101 dcl  label_index fixed bin;
      102 
      103 dcl  temp_dir char (168) aligned,			/* TEMPORARY CODE */
      104      temp_entry char (32) aligned,			/* TEMPORARY CODE */
      105      temp_length fixed bin;				/* TEMPORARY CODE */
      106 
      107 
      108 dcl  stptr ptr;					/* pointer to status_long return area */
      109 dcl  1 status aligned,				/* status long return area */
      110        (
      111        2 type bit (2),
      112        2 nnames bit (16),
      113        2 nrp bit (18),
      114        2 dtm bit (36),
      115        2 dtu bit (36),
      116        2 mode bit (5),
      117        2 padding bit (13),
      118        2 records bit (18),
      119        2 dtd bit (36),
      120        2 dtem bit (36),
      121        2 acct bit (36),
      122        2 curlen bit (12),
      123        2 bitcnt bit (24),
      124        2 did bit (4),
      125        2 mdid bit (4),
      126        2 copysw bit (1),
      127        2 pad2 bit (9),
      128        2 rbs (0:2) bit (6),
      129        2 uid bit (36)
      130        ) unaligned;
      131 
      132 dcl  1 inacl_info aligned,
      133        2 sia_relp (0:7) bit (18),
      134        2 sia_count (0:7) fixed bin,
      135        2 dia_relp (0:7) bit (18),
      136        2 dia_count (0:7) fixed bin;
      137 
      138 
      139 dcl  rings (3) fixed bin (3);				/* Ring brackets for non directory segments */
      140 
      141 dcl  reload_init bit (1) static initial ("1"b);		/* Internal static. */
      142 
      143 dcl  line char (300) static,				/* Output line(s) buffer. */
      144      line_pointer ptr static,				/* Pointer to line buffer. */
      145      (hp, seg_buff) ptr static;
      146 
      147 dcl  (phcs_sw, hphcs_sw, system_priv_sw) bit (1) init ("0"b);
      148 						/* for testing access to gates */
      149 dcl  text char (32) varying;
      150 
      151 dcl  (
      152      error_table_$namedup,
      153      error_table_$noentry,
      154      error_table_$pvid_not_found,
      155      error_table_$vtoce_connection_fail,
      156      error_table_$moderr,
      157      error_table_$no_dir,
      158      error_table_$no_info,
      159      error_table_$no_e_permission,
      160      error_table_$incorrect_access,
      161      error_table_$rqover
      162      ) ext fixed bin (35);
      163 
      164 dcl  sys_info$access_class_ceiling ext bit (72) aligned;
      165 dcl  sys_info$default_max_length ext fixed bin (35);
      166 dcl  sys_info$seg_size_256K fixed bin (19) ext;
      167 
      168 dcl  linkage_error condition;
      169 
      170 dcl  (addr, bit, clock, divide, fixed, max, min, null, pointer, substr, unspec, verify) builtin;
      171 
      172 dcl  test_entry entry variable;
      173 
      174 dcl  backup_control_mgr_$initiate entry (pointer, fixed binary (35)),
      175      backup_control_mgr_$terminate entry (pointer),
      176      backup_load_dir_list$build_tree
      177 	entry (char (168) aligned, char (*) aligned, fixed bin, fixed bin (24), fixed bin (2), char (*) aligned,
      178 	bit (72) aligned, fixed bin (35)),
      179      backup_load_dir_list entry (ptr, fixed bin (35)),
      180      backup_map_$name_line entry (ptr, fixed bin (21)),
      181      backup_map_$beginning_line entry (fixed bin (52), ptr, fixed bin),
      182      backup_map_$detail_line2
      183 	entry (char (32) aligned, fixed bin (9), char (10) aligned, fixed bin (52), fixed bin (52), fixed bin (52),
      184 	fixed bin (52), fixed bin (52)),
      185      (
      186      backup_map_$directory_line,
      187      backup_map_$on_line
      188      ) entry (ptr, fixed bin),
      189      backup_map_$error_line entry () options (variable),
      190      backup_map_$fs_error_line entry (fixed bin (35), char (*) aligned, char (*) aligned, char (*) aligned),
      191      backup_map_$terminal_line entry (fixed bin (52), fixed bin (35)),
      192      backup_util$add_names entry (char (168) aligned, char (32) aligned, ptr, fixed bin, bit (1)),
      193      backup_util$delete_name entry (char (168) aligned, char (32) aligned, fixed bin (35)),
      194      backup_util$give_access entry (char (168) aligned, char (32) aligned, fixed bin (35)),
      195      backup_util$idline entry (char (*), char (*), ptr, fixed bin),
      196      bk_input$input_init entry (fixed bin (35)),
      197      bk_input$rd_tape entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35)),
      198      bk_retrieve$check_retrieval ext entry (fixed bin),
      199      bk_retrieve$flag_msf entry (fixed bin),
      200      bk_retrieve$parse_retrieval_control ext entry (char (168), fixed bin, ptr, fixed bin),
      201      bk_retrieve$parse_structure entry (ptr, fixed bin),
      202      bk_retrieve$report_retrieval ext entry,
      203      convert_aim_attributes_ entry (bit (72) aligned, character (32) aligned),
      204      cu_$arg_count entry (fixed bin),
      205      cu_$arg_list_ptr entry (ptr),
      206      cu_$level_get entry returns (fixed bin (3)),
      207      hcs_$set_256K_switch entry (bit (2) aligned, bit (2) aligned, fixed bin (35)),
      208      hcs_$proc_info entry (bit (36) aligned, char (32), char (32), bit (36) aligned),
      209      bk_arg_reader_$reload_arg_reader entry (fixed bin, ptr, fixed bin (35)),
      210      date_time_ entry (fixed bin (52), char (*)),
      211      unique_chars_ entry (bit (*) aligned) returns (char (15) aligned),
      212      expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      213 
      214 dcl  hphcs_$set_for_reloader entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35)),
      215      hphcs_$delentry_file entry (char (*) aligned, char (*) aligned, fixed bin (35)),
      216      hcs_$set_copysw entry (char (*) aligned, char (*) aligned, bit (1) aligned, fixed bin (35)),
      217      hcs_$set_entry_bound entry (char (*) aligned, char (*) aligned, fixed bin (14), fixed bin (35)),
      218      hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
      219      hcs_$chname_file entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35)),
      220      hcs_$list_inacl_all entry (char (*) aligned, ptr, ptr, ptr, fixed bin (35)),
      221      hcs_$set_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35)),
      222      phcs_$set_max_length entry (char (*) aligned, char (*) aligned, fixed bin (19), fixed bin (35)),
      223 						/* TEMPORARY CODE */
      224      hcs_$fs_get_path_name entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35)),
      225 						/* TEMPORARY CODE */
      226      hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35)),
      227      hcs_$set_safety_sw entry (char (*) aligned, char (*) aligned, bit (1), fixed bin (35)),
      228      (
      229      hcs_$replace_acl,
      230      hcs_$replace_dir_acl
      231      ) entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1), fixed bin (35)),
      232      (
      233      hcs_$replace_inacl,
      234      hcs_$replace_dir_inacl
      235      ) entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1), fixed bin (3), fixed bin (35)),
      236      (
      237      hcs_$set_ring_brackets,
      238      hcs_$set_dir_ring_brackets
      239      ) entry (char (*) aligned, char (*) aligned, (3) fixed bin (3), fixed bin (35)),
      240      hcs_$status_minf entry (char (*) aligned, char (*) aligned, fixed bin (1), fixed bin (2), fixed bin, fixed bin (35)),
      241      hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin (5), fixed bin (5), fixed bin (35)),
      242      hcs_$status_long entry (char (*) aligned, char (*) aligned, fixed bin (1), ptr, ptr, fixed bin (35)),
      243      hcs_$terminate_noname entry (ptr, fixed bin (35)),
      244      hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
      245      hcs_$initiate
      246 	entry (char (*) aligned, char (*) aligned, char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      247      pathname_ entry (character (*), character (*)) returns (character (168)),
      248      system_privilege_$dir_priv_off entry (fixed binary (35)),
      249      system_privilege_$dir_priv_on entry (fixed binary (35)),
      250      system_privilege_$initiate
      251 	entry (char (*) aligned, char (*) aligned, char (*), fixed bin, fixed bin (2), ptr, fixed bin (35)),
      252      system_privilege_$set_entry_audit_switch
      253 	entry (char (*), char (*), bit (1), fixed bin (35)),
      254      translate_aim_attributes_ entry (pointer, bit (72) aligned, pointer, bit (72) aligned, fixed binary (35));
      255 
      256 dcl  (
      257      bk_input$input_finish,
      258      com_err_,
      259      ioa_$rsnnl,
      260      ioa_$rs,
      261      hphcs_$suspend_quota,
      262      hphcs_$restore_quota
      263      ) external entry options (variable);
      264 
      265 dcl  hphcs_$fs_get_trans_sw entry (fixed bin (2), fixed bin (2));
      266 
      267 dcl  mover (scnt) based;				/* To move words into new segment */
      268 dcl  call_limiter fixed bin (14);
      269 
      270 /**/
      271 
  1     1 /* include backup_dir_list */
  1     2 /* Created by R H Campbell. */
  1     3 /* Modified 15 June 1970, R H Campbell, 30 March l971, R A Tilden. */
  1     4 /* Last modified by Kobziar 2/10/75 to add access_class */
  1     5 /* Last modified by Greenberg 11/4/76 for vtoc_error bit */
  1     6 dcl 1 br (1000) based aligned,			/* branch array returned by list_dir */
  1     7     2 (vtoc_error bit (1),				/* Vtoc error on this entry */
  1     8      pad1 bit (1), uid bit (70),
  1     9      pad2 bit (20), dtu bit (52),
  1    10      pad3 bit (20), dtm bit (52),
  1    11      pad4 bit (20), dtd bit (52),
  1    12      pad5 bit (20), dtbm bit (52),
  1    13      access_class bit (72),
  1    14      dirsw bit (1), optionsw bit (2), bc bit (24), consistsw bit (2), mode bit (5), usage bit (2),
  1    15      usagect bit (17), nomore bit (1), (cl, ml) bit (9),
  1    16      acct bit (36),
  1    17     (hlim, llim) bit (17),
  1    18      multiple_class bit (1), pad7 bit (1),
  1    19     (rb1, rb2, rb3) bit (6), pad8 bit (18),
  1    20     (pad9, namerp) bit (18),
  1    21      ix bit (18), dump_me bit (1), nnames bit (17)) unaligned;  /* ix is pointer to i'th (sorted) entry. */
  1    22 
  1    23 dcl  nnames fixed bin;				/* Number of elements in name array. */
  1    24 
  1    25 dcl 1 name (1000 /* nnames */) based aligned,
  1    26     2 size bit (17),
  1    27     2 string character (32);
  1    28 
  1    29 dcl 1 lk (1) based aligned,				/* link array returned by list_dir */
  1    30     2 (pad1 bit (2), uid bit (70),
  1    31      pad2 bit (20), dtu bit (52),
  1    32      pad3 bit (20), dtm bit (52),
  1    33      pad4 bit (20), dtd bit (52),
  1    34     (pathnamerp, namerp) bit (18),
  1    35      ix bit (18), dump_me bit (1), nnames bit (17)) unaligned;  /* ix is pointer to i'th (sorted) entry. */
  1    36 
  1    37 dcl 1 path based (pp) aligned, 			/* path name structure from list_dir (one per link) */
  1    38     2 size bit (17),
  1    39     2 author character(32),				/* author of link, and */
  1    40     2 name character (168);				/* path name. */
  1    41 
  1    42 dcl 1 old_path based (pp) aligned,			/* path name as it existed prior to inclusion of author */
  1    43     2 size bit (17),
  1    44     2 name character (168);
  1    45 						/* end backup_dir_list */
      272 
      273 
  2     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  2     6*     install(87-03-30,MR12.1-1018):
  2     7*     added a writing_map switch to indicate when the dump map is being written.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  2    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  2    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  2    14 
  2    15 /* Hierarchy dumper/reloader static data */
  2    16 
  2    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  2    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  2    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  2    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  2    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  2    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  2    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  2    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  2    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  2    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  2    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  2    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  2    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  2    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  2    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  2    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  2    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  2    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  2    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  2    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  2    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  2    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  2    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  2    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  2    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  2    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  2    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  2    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  2    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  2    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  2    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  2    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  2    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  2    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  2    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  2    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  2    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  2    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  2    55*						   requests satisfied (loading) */
  2    56      bk_ss_$operator char(32),			/* operator name */
  2    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  2    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  2    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  2    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  2    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  2    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  2    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  2    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  2    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  2    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  2    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  2    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  2    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  2    70      bk_ss_$rname char(168),				/* retrieval file name */
  2    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  2    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  2    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  2    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  2    75      bk_ss_$segptr pointer,
  2    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  2    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  2    78      bk_ss_$sp pointer,
  2    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  2    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  2    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  2    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  2    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  2    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  2    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  2    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  2    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  2    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  2    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  2    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  2    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  2    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  2    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  2    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  2    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  2    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  2    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  2    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  2    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  2   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  2   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  2   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  2   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  2   104 	external static;
  2   105 
  2   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
      274 
      275 
  3     1 
  3     2 /* . . . BEGIN INCLUDE FILE . . . bk_nss_info . . . */
  3     3 
  3     4 /* Created Fall '75 RE Mullen for intrim NSS dumper */
  3     5 /* This structure is allocated in each dump record. */
  3     6 
  3     7 dcl 1 bk_nss_info aligned based,
  3     8     2 version fixed bin,
  3     9     2 lvname char (32) aligned,
  3    10     2 pvname char (32) aligned,
  3    11     2 lvid bit (36) aligned,
  3    12     2 pvid bit (36) aligned;				/* limit of version = 1 struct */
  3    13 
  3    14 
  3    15 dcl 1 bk_dq_info aligned based,
  3    16     2 version fixed bin,
  3    17     2 quota fixed bin,
  3    18     2 ltrp fixed bin (71),
  3    19     2 tlu bit (36) aligned,
  3    20     2 inf_acct fixed bin,
  3    21     2 term_acct fixed bin (1),
  3    22     2 used fixed bin;
  3    23 
  3    24 
  3    25 
  3    26 /* . . . END INCLUDE FILE  bk_nss_info . . . */
  3    27 
  3    28 
      276 
      277 
  4     1 /*	BEGIN INCLUDE FILE ... reload_set_info.incl.pl1 ... last modified March 1976 by R. Bratt */
  4     2 
  4     3 
  4     4 
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(88-05-11,Lippard), approve(88-05-02,MCR7881),
  4     8*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  4     9*     Add audit_flag and the should_set audit_flag. This changes the version
  4    10*      number to 2.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 
  4    14 /* This structure is input to set$set_for_reloader. */
  4    15 
  4    16 dcl  reload_set_version_2 fixed bin int static init (2);
  4    17 
  4    18 dcl 1 reload_set_info aligned,
  4    19     2 version fixed bin,				/* set by caller, checked by callee */
  4    20     2 should_set,					/* if should_set.item then set item */
  4    21       3 safety_sw bit (1) unal,
  4    22       3 audit_flag bit (1) unal,
  4    23       3 actind bit (1) unal,
  4    24       3 actime bit (1) unal,
  4    25       3 author bit (1) unal,
  4    26       3 bc_author bit (1) unal,
  4    27       3 max_length bit (1) unal,
  4    28       3 entry_bound bit (1) unal,
  4    29       3 dtem bit (1) unal,
  4    30       3 dtd bit (1) unal,
  4    31       3 dtu bit (1) unal,
  4    32       3 dtm bit (1) unal,
  4    33       3 tpd bit (1) unal,
  4    34       3 pad bit (24) unaligned,
  4    35     2 safety_sw bit (1) aligned,			/* safety switch */
  4    36     2 audit_flag bit (1) aligned,			/* segment must be audited */
  4    37     2 actind bit (18) aligned,			/* activity indicator */
  4    38     2 actime bit (36) aligned,			/* activity time */
  4    39     2 author char (32) aligned,
  4    40     2 author_code fixed bin (35),			/* ^0 => erred setting author */
  4    41     2 bc_author char (32) aligned,
  4    42     2 bc_author_code fixed bin (35),			/* ^0 => erred setting bc_author */
  4    43     2 max_length fixed bin (19),
  4    44     2 max_length_code fixed bin (35),			/* ^0 => erred setting max length */
  4    45     2 entry_bound fixed bin (14),
  4    46     2 entry_bound_code fixed bin (35),			/* ^0 => erred setting epb */
  4    47     2 dtem bit (36) aligned,				/* date time dumped */
  4    48     2 dtd bit (36) aligned,				/* date time dumped */
  4    49     2 dtu bit (36) aligned,				/* date time used */
  4    50     2 dtm bit (36) aligned,				/* date time contents modified */
  4    51     2 tpd bit (1) aligned;				/* transparent paging device switch */
  4    52 
  4    53 /* END INCLUDE FILE ... reload_set_info.incl.pl1 */
      278 
      279 
  5     1 /* include backup_fs_times */
  5     2 /* Created by R H Campbell. */
  5     3 /* Modified 15 June 1970, R H Campbell. */
  5     4 dcl 1 times, 					/* Structure of times for set$backup_times. */
  5     5     2 (dtem, 					/* Time entry last modified. */
  5     6      dtd, 					/* Time entry last dumped. */
  5     7      dtu, 					/* Time segment last used. */
  5     8      dtm) fixed binary (52); 				/* Time segment last modified. */
  5     9 						/* end backup_fs_times */
      280 
      281 
  6     1 /* BEGIN INCLUDE FILE ... backup_control.incl.pl1 */
  6     2 /* Modified: July 1982 by G. Palter to add features for proper support of AIM in IMFT (version 4) */
  6     3 /* Modified: August 1983 by Robert Coren to add minimum access class enforcement */
  6     4 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  6     5 
  6     6 /* Hierarchy dumper/reloader subroutine control structure */
  6     7 
  6     8 dcl 1 backup_control aligned based (backup_control_ptr),
  6     9     2 header,					/* allows people to use like (!) */
  6    10       3 version character (8) unaligned,
  6    11       3 tape_entry entry (character (*)) variable,	/* returns next tape label */
  6    12       3 data_iocb pointer,				/* -> I/O switch to use for dumping/loading if preattached */
  6    13       3 maximum_access_class bit (72) aligned,		/* maximum access class for anything to be dumped */
  6    14       3 minimum_access_class bit (72) aligned,		/* minimum access class for anything to be dumped */
  6    15       3 maximum_dir_access_class bit (72) aligned,	/* no directory above this access class is dumped */
  6    16       3 user_for_access_check,			/* data required to validate user's access */
  6    17         4 id character (32) unaligned,			/* Person.Project.tag */
  6    18         4 authorization bit (72),			/* the user's process authorization */
  6    19         4 ring fixed binary,				/* the user's ring o execution */
  6    20       3 minimum_ring fixed binary,			/* no ring bracket is set below this value */
  6    21       3 aim_translations,				/* data required to translate AIM attributes on the tape */
  6    22         4 source_attributes_ptr pointer,
  6    23         4 target_attributes_ptr pointer,
  6    24       3 options aligned,
  6    25         4 map_sw  bit(1) unaligned,			/* ON to write map segment */
  6    26         4 debug_sw bit (1) unaligned,			/* ON to check quotas and not trim subtrees */
  6    27         4 no_reload_sw bit (1) unaligned,		/* ON to not load for backup_load_ */
  6    28         4 hold_sw bit (1) unaligned,			/* ON to not demount tape afterwards */
  6    29         4 preattached bit (1) unaligned,		/* ON => perform loading/dumping to supplied I/O switch */
  6    30         4 error_file bit (1) unaligned,			/* ON => generate an error file anyway */
  6    31         4 first bit (1) unaligned,			/* ON => for reload, stop after all requests satisfied */
  6    32         4 caller_handles_conditions bit (1) unaligned,	/* ON => caller of backup_dump_ handles faults */
  6    33         4 allow_dir_overwrite bit (1) unaligned,		/* ON => allow reloaded seg to overwrite a dir */
  6    34         4 enforce_max_access_class bit (1) unaligned,	/* ON => do not dump anything above given access class */
  6    35         4 dont_dump_upgraded_dirs bit (1) unaligned,	/* ON => do not dump directories above given access class */
  6    36         4 check_effective_access bit (1) unaligned,	/* ON => do not dump branches specified user can't touch */
  6    37         4 restore_access_class bit (1) unaligned,		/* ON => restore AIM attributes even in debug mode */
  6    38         4 enforce_minimum_ring bit (1) unaligned,		/* ON => do not give anything ring bracket below minimum */
  6    39         4 translate_access_class bit (1) unaligned,	/* ON => translate access classes read from tape */
  6    40         4 enforce_min_access_class bit (1) unaligned,	/* ON => do not dump anything below given access class */
  6    41         4 upgrade_to_user_auth bit (1) unaligned,		/* ON => set access class of branch being dumped to user's authorization */
  6    42         4 pad bit (19) unaligned,
  6    43       3 request_count fixed binary,			/* # of entries to load or dump */
  6    44     2 requests (backup_control_request_count refer (backup_control.request_count)),
  6    45       3 path character (168) unaligned,			/* pathname of object to be dumped/loaded */
  6    46       3 new_path character (168) unaligned,		/* pathname for object when reloading if not same as above */
  6    47       3 switches aligned,
  6    48         4 no_primary_sw bit (1) unaligned,		/* do not use primary pathname */
  6    49         4 trim_sw bit (1) unaligned,			/* trim target directories */
  6    50         4 pad bit (34) unaligned,
  6    51       3 found bit(1) aligned,				/* ON => found on tape by backup_load_ (output) */
  6    52       3 loaded bit (1) aligned,			/* ON => loaded by backup_load_ (output) */
  6    53       3 status_code fixed binary (35),			/* ON => per-entry status code (output) */
  6    54       3 error_name character (65) unaligned;		/* ON => some information about what happened (output) */
  6    55 
  6    56 dcl  backup_control_ptr pointer;
  6    57 
  6    58 dcl backup_control_request_count fixed binary;		/* for allocations */
  6    59 
  6    60 dcl BACKUP_CONTROL_VERSION_5 character (8) static options (constant) initial ("hbc_0005");
  6    61 
  6    62 /* END INCLUDE FILE ... backup_control.incl.pl1 */
      282 
      283 
  7     1 
  7     2 /* Begin include file ... backup_preamble_header.incl.pl1 */
  7     3 /* Modified 1/29/73 by N. I. Morris */
  7     4 /* Modified 7/15/74 by R. E. Mullen */
  7     5 /* Modified 10/10/74 by A. Kobziar */
  7     6 
  7     7 dcl 1 h based aligned,				/* backup preamble (segment header) */
  7     8 
  7     9     2 dlen fixed binary,
  7    10     2 dname character (168),
  7    11     2 elen fixed binary,
  7    12     2 ename character (32),
  7    13     2 bitcnt fixed binary (24),
  7    14     2 record_type fixed binary,			/* Logical record type. */
  7    15     2 dtd fixed binary (52),				/* Date and time dump occurred. */
  7    16     2 dumper_id character (32),			/* Identification of dumper procedure. */
  7    17 
  7    18     2 bp bit (18),					/* Pointer to branches. */
  7    19     2 bc fixed binary,				/* Branch count. */
  7    20     2 lp bit (18),					/* Pointer to links. */
  7    21     2 lc fixed binary,				/* Link count. */
  7    22     2 aclp bit (18),				/* Pointer to ACL or CACL */
  7    23     2 aclc fixed binary,				/* ACL count. */
  7    24     2 actind bit (18),				/* File activity indicator */
  7    25     2 actime bit (36),				/* File activity time */
  7    26 
  7    27     2 quota fixed binary,				/* Record quota for directory_list record. */
  7    28     2 trp fixed binary (35),				/* Time-record product .. */
  7    29     2 tlu fixed binary (35),				/* Time last updated .. */
  7    30     2 inf_acct fixed binary,				/* Inferior account switch .. */
  7    31     2 term_acct fixed binary (1),			/* Terminal account switch .. */
  7    32     2 pad1 (3),					/* To even out area to 0 mod 8 */
  7    33 
  7    34     2 max_length fixed bin (18),			/* Max. length of segment */
  7    35     2 switches unal,
  7    36       3 safety_sw bit (1) unal,			/* Segment safety switch */
  7    37       3 entrypt_sw bit (1) unal,			/* "1"b -> call limiter enabled */
  7    38       3 security_oosw bit(1) unal,			/* security out-of-service */
  7    39       3 audit_flag bit(1) unal,			/* flag for seg reference auditing */
  7    40       3 multiple_class bit (1) unal,			/* system segment: access class may be higher than parent's */
  7    41       3 pad2 bit(2) unal,				/* =pad2 in dir_entry */
  7    42       3 master_dir bit (1) unal,			/* "1"b => was master dir */
  7    43       3 tpd bit (1) unal,				/* TRUE => never put on paging device */
  7    44       3 sw_pad bit (13) unal,				/* padding in this structure */
  7    45     2 entrypt_bound bit (14) unal,			/* Call limiter. */
  7    46     2 access_class bit(72),				/* access class of entry */
  7    47     2 spad bit(36),					/* last word of dir entry */
  7    48     2 status_version fixed bin,			/* version of status_for_backup struct */
  7    49     2 nss_info_relp bit (18) aligned,			/* NONZERO => NSS INFO */
  7    50     2 dq_info_relp bit (18) aligned,				/* NONZERO => DIRQUOTA INFO */
  7    51 
  7    52     2 inaclp (0:7) bit (18),				/* Pointer to initial ACL for each ring. */
  7    53     2 inaclc (0:7) fixed bin,				/* Initial ACL count for each ring. */
  7    54     2 dir_inaclp (0:7) bit (18),			/* Directory initial ACL pointer for each ring. */
  7    55     2 dir_inaclc (0:7) fixed bin,			/* Directory initial ACL count for each ring. */
  7    56 
  7    57     2 bitcount_author char (32),			/* last modifier of the bit count */
  7    58 
  7    59     2 list_area /* area */ (65408);			/* Area for list_dir and readacl. */
  7    60 
  7    61 dcl  author char (32) aligned based;			/* Author of entry */
  7    62 						/* N. B.  Author is an overlay starting at h.quota */
  7    63 
  7    64 /* End of include file ... backup_preamble_header.incl.pl1 */
  7    65 
      284 
      285 
  8     1 /*  BEGIN:   backup_record_types.incl.pl1		  *  *  *  *  *  */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
  8     6*     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
  8     7*     Converted internal static variables to named constants.  Renamed
  8     8*     record_type array to RECORD_TYPE, to avoid naming conflict with
  8     9*     backup_preamble_header.incl.pl1's h.record_type variable.
  8    10*                                                   END HISTORY COMMENTS */
  8    11 
  8    12 
  8    13 /* Created June 1970, R H Campbell. */
  8    14 /* Modified 1/16/73 by N. I. Morris	*/
  8    15 /* Modified 7/17/75 by R. Bratt */
  8    16 /* Modified 11/04/83 by G. Dixon - better comments */
  8    17 
  8    18 dcl  ndc_segment fixed binary int static options(constant) initial (1);
  8    19 						/* Record of segment with NDC attributes */
  8    20 dcl  ndc_directory fixed binary int static options(constant) initial (2);
  8    21 						/* Record of directory with NDC attributes */
  8    22 dcl  ndc_directory_list fixed binary int static options(constant) initial (3);
  8    23 						/* Record of directory list with initial ACL */
  8    24 dcl  sec_seg fixed binary int static options(constant) initial(19);
  8    25 						/* Seg with security & call_limiter */
  8    26 dcl  sec_dir fixed binary int static options(constant) initial(20);
  8    27 						/* Dir with security & call_limiter */
  8    28 
  8    29 dcl  RECORD_TYPE (0: 20) character (10) aligned		/* Name of the record types. */
  8    30      int static options(constant)
  8    31      initial (*, "NDC seg", "NDC dir", "NDC dirlst", *, *, *, *,
  8    32 	    *, *, *, *, *, *, *, *,
  8    33 	    *, *, *, "SEG", "DIR");
  8    34 
  8    35 /* The following is an excerpt from a backup map showing the relationship
  8    36*   between entries in the backup map and the named constants given above.
  8    37*   I don't know under what conditions the ndc_seg and ndc_dir named constants
  8    38*   are ever used.  (G. Dixon)
  8    39*
  8    40*			        Map Excerpt
  8    41*   		 ---------------------------------------------
  8    42*Named Constant       ENTRY NAME                   BLOCKS REC_TYPE  
  8    43*
  8    44*sec_dir		 >library_dir_dir>system_library_unbundled
  8    45*		  object			     0 directory 
  8    46*			 o
  8    47*sec_dir		  source			     0 directory
  8    48*		           s
  8    49*
  8    50*ndc_directory_list	 >library_dir_dir>system_library_unbundled>object
  8    51*				               0 directory 
  8    52*sec_seg		  bound_gcos_tss_.1.archive	   104 segment   
  8    53*
  8    54*
  8    55*ndc_directory_list   >library_dir_dir>system_library_unbundled>source
  8    56*				               0 directory
  8    57*sec_seg               bound_gcos_tss_.1.s.archive	   134 segment
  8    58*
  8    59*
  8    60*						          */
  8    61 
  8    62 
  8    63 /*  END OF:  backup_record_types.incl.pl1		  *  *  *  *  *  */
      286 
      287 
      288 /**/
      289 	bk_ss_$sub_entry = "0"b;
      290 
      291 	if bk_ss_$myname = " " then bk_ss_$myname = "backup_load";
      292 						/* set up name if called directly */
      293 
      294 /*	read in arguments and set switches		*/
      295 
      296 	call cu_$arg_count (i);			/* Get the number of input arguments */
      297 	if i ^= 0 then do;				/* Don't bother if no args */
      298 	     call cu_$arg_list_ptr (ap);		/* Get pointer to argument list */
      299 	     call bk_arg_reader_$reload_arg_reader (1, ap, code);
      300 						/* Do the work */
      301 	     if code ^= 0 then do;			/* Uh Oh, Trouble */
      302 		call com_err_ (code, "backup_load", "");
      303 		return;
      304 	     end;
      305 	end;
      306 	if ^bk_ss_$debugsw then do;			/* check phcs_ and hphcs_ access */
      307 	     phcs_sw, hphcs_sw = "0"b;
      308 	     on linkage_error
      309 		begin;
      310 		phcs_sw = "1"b;
      311 		go to TRY2;
      312 	     end;
      313 	     test_entry = phcs_$set_max_length;		/* test access to phcs_ gate */
      314 TRY2:
      315 	     on linkage_error
      316 		begin;
      317 		hphcs_sw = "1"b;
      318 		go to TRY3;
      319 	     end;
      320 	     test_entry = hphcs_$delentry_file;		/* test access to hphcs_ gate */
      321 TRY3:
      322 	     on linkage_error
      323 		begin;
      324 		system_priv_sw = "1"b;
      325 		go to TRY4;
      326 	     end;
      327 	     test_entry = system_privilege_$initiate;	/* test access to system_privilege_ gate */
      328 TRY4:
      329 	     revert linkage_error;
      330 	     if phcs_sw | hphcs_sw | system_priv_sw then do;
      331 		text = "";
      332 		call com_err_ (error_table_$moderr, bk_ss_$myname, "^[phcs_ ^]^[hphcs_ ^]^[system_privilege_^]
      333 Use -debug control argument to avoid calling privileged gates.", phcs_sw, hphcs_sw, system_priv_sw);
      334 		go to RETURN;
      335 	     end;
      336 	end;
      337 	old_256K_switch = ""b;			/* initialize for cleanup */
      338 	on cleanup
      339 	     begin;
      340 	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      341 	end;
      342 	go to COMMON;
      343 
      344 
      345 backup_load_:
      346      entry (control_ptr, a_code);
      347 
      348 	bk_ss_$sub_entry = "1"b;
      349 	a_code = 0;
      350 
      351 	call backup_control_mgr_$initiate (control_ptr, a_code);
      352 	if a_code ^= 0 then return;
      353 
      354 	dir_priv_code = -1;				/* for cleanup handler */
      355 	old_256K_switch = ""b;			/* ditto */
      356 	on condition (cleanup)
      357 	     begin;
      358 	     if dir_priv_code = 0 then call system_privilege_$dir_priv_off ((0));
      359 	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      360 	     call backup_control_mgr_$terminate (control_ptr);
      361 	end;
      362 
      363 	if bk_ss_$control_ptr -> backup_control.debug_sw then do;
      364 	     bk_ss_$debugsw = "1"b;
      365 	     bk_ss_$trimsw = "0"b;
      366 	end;
      367 	else bk_ss_$debugsw = "0"b;
      368 
      369 	bk_ss_$mapsw = bk_ss_$control_ptr -> backup_control.map_sw;
      370 	bk_ss_$no_reload = bk_ss_$control_ptr -> backup_control.no_reload_sw;
      371 	bk_ss_$holdsw = bk_ss_$control_ptr -> backup_control.hold_sw;
      372 	bk_ss_$allow_dir_overwrite = bk_ss_$control_ptr -> backup_control.allow_dir_overwrite;
      373 	bk_ss_$preattached = bk_ss_$control_ptr -> backup_control.preattached;
      374 	if bk_ss_$preattached then bk_ss_$data_iocb = bk_ss_$control_ptr -> backup_control.data_iocb;
      375 	bk_ss_$sub_entry_errfile = bk_ss_$control_ptr -> backup_control.error_file;
      376 	bk_ss_$onlysw = bk_ss_$control_ptr -> backup_control.first;
      377 
      378 	bk_ss_$restore_access_class = bk_ss_$control_ptr -> backup_control.restore_access_class;
      379 	if bk_ss_$restore_access_class then do;		/* turn on directory privilege */
      380 	     on condition (linkage_error)
      381 		begin;
      382 		a_code = error_table_$moderr;
      383 		go to RETURN;
      384 	     end;
      385 	     call system_privilege_$dir_priv_on (dir_priv_code);
      386 	     if (dir_priv_code ^= 0) & (dir_priv_code ^= 1) then do;
      387 		a_code = code;			/* couldn't get it */
      388 		go to RETURN;
      389 	     end;
      390 	     revert condition (linkage_error);
      391 	end;
      392 
      393 	bk_ss_$enforce_minimum_ring = bk_ss_$control_ptr -> backup_control.enforce_minimum_ring;
      394 	if bk_ss_$enforce_minimum_ring then bk_ss_$minimum_ring = bk_ss_$control_ptr -> backup_control.minimum_ring;
      395 
      396 	bk_ss_$translate_access_class = bk_ss_$control_ptr -> backup_control.translate_access_class;
      397 	if bk_ss_$translate_access_class then do;
      398 	     bk_ss_$source_attributes_ptr = bk_ss_$control_ptr -> backup_control.source_attributes_ptr;
      399 	     bk_ss_$target_attributes_ptr = bk_ss_$control_ptr -> backup_control.target_attributes_ptr;
      400 	end;
      401 
      402 	do i = 1 to bk_ss_$control_ptr -> backup_control.request_count;
      403 	     if verify (bk_ss_$control_ptr -> backup_control.new_path (i), " ") = 0 then
      404 		bk_ss_$control_ptr -> backup_control.new_path (i) = "";
      405 						/* can't have new pathname all zeros */
      406 	     bk_ss_$control_ptr -> backup_control.found (i) = "0"b;
      407 	     bk_ss_$control_ptr -> backup_control.loaded (i) = "0"b;
      408 	     bk_ss_$control_ptr -> backup_control.status_code (i) = 0;
      409 	     bk_ss_$control_ptr -> backup_control.error_name = "";
      410 	end;
      411 
      412 	bk_ss_$qchecksw = "1"b;
      413 
      414 	if bk_ss_$control_ptr -> backup_control.request_count = 0 then
      415 	     bk_ss_$retrievesw = "0"b;
      416 	else bk_ss_$retrievesw = "1"b;
      417 
      418 	bk_ss_$myname = "backup_load_";
      419 
      420 COMMON:
      421 	call hcs_$set_256K_switch ("11"b, old_256K_switch, code);
      422 						/* enable 256K connnections, ignore code */
      423 	if reload_init then do;
      424 	     call hcs_$make_seg ("", "reload_preamble", "", 01011b, hp, code);
      425 	     call hcs_$make_seg ("", "reload_temp", "", 01011b, seg_buff, code);
      426 						/* Make segment buffer. */
      427 						/* THE FOLLOWING TWELVE LINES SHOULD BE REMOVED WHEN 256K SEGMENTS ARE INSTALLED. */
      428 	     if ^bk_ss_$debugsw then do;		/* TEMPORARY CODE */
      429 		call hcs_$fs_get_path_name (seg_buff, temp_dir, temp_length, temp_entry, code);
      430 						/* TEMPORARY CODE */
      431 		on linkage_error
      432 		     begin;
      433 		     if bk_ss_$sub_entry then
      434 			call backup_map_$fs_error_line (error_table_$no_e_permission, (bk_ss_$myname), ">sl1",
      435 			     "phcs_$set_max_length");
      436 		     else call com_err_ (error_table_$no_e_permission, bk_ss_$myname,
      437 			     ">sl1>phcs_$set_max_length^/Use -debug control argument.");
      438 		     go to RETURN;
      439 		end;
      440 		call phcs_$set_max_length (temp_dir, temp_entry, sys_info$seg_size_256K, code);
      441 						/* TEMPORARY CODE */
      442 		revert linkage_error;
      443 	     end;					/* TEMPORARY CODE */
      444 
      445 	     call hcs_$set_max_length_seg (seg_buff, sys_info$seg_size_256K, code);
      446 	     line_pointer = addr (line);		/* Set up pointer to line buffer. */
      447 	     reload_init = ""b;
      448 	end;
      449 
      450 start:
      451 	if bk_ss_$retrievesw then do;			/* Is this a retrieval */
      452 	     if bk_ss_$sub_entry then
      453 		call bk_retrieve$parse_structure (hp, label_index);
      454 	     else call bk_retrieve$parse_retrieval_control (bk_ss_$rname, bk_ss_$rsize, hp, label_index);
      455 						/* pass retrieve seg name */
      456 						/* and preamble seg pointer for init */
      457 	     go to loc_label (label_index);		/* go to appropriate place on return */
      458 	end;
      459 
      460 loc_label (1):
      461 parsed:
      462 	if ^bk_ss_$debugsw then do;			/* Check if this can be done. */
      463 	     if ^bk_ss_$qchecksw then			/* Now check if it should be done */
      464 		call hphcs_$suspend_quota;		/* Disable quota-checking. */
      465 	     call hphcs_$fs_get_trans_sw (11b, old_trans_sw);
      466 						/* Set transparent usage, modification switches. */
      467 	     if (bk_ss_$myname = "reload") | (bk_ss_$myname = "iload") then do;
      468 		if ^bk_ss_$qchecksw then
      469 		     if ^bk_ss_$no_reload then FRS = 1; /* reload to target diectly */
      470 	     end;
      471 	end;
      472 	call hcs_$proc_info ((""b), USERID, (""), (""b)); /* pid, pdir, lockid not needed */
      473 	if USERID = "Initializer.SysDaemon.z" then INITIALIZER = "1"b;
      474 	call bk_input$input_init (code);		/* initialize tape read package */
      475 	if code ^= 0 then do;
      476 	     call backup_map_$fs_error_line (code, "backup_load", "bk_input$input_init", "");
      477 	     if bk_ss_$sub_entry then a_code = code;
      478 	     go to terminate;			/* Give up. */
      479 	end;
      480 	n = 0;					/* set length of id line */
      481 	if bk_ss_$mapsw then			/* Are we preparing a map listing? */
      482 						/* Format id line */
      483 	     call backup_util$idline (substr (bk_ss_$rname, 1, bk_ss_$rsize), "5 May 1982.", line_pointer, n);
      484 
      485 	stptr = addr (status);			/* get pointer to status_long return structure */
      486 
      487 	dtp = clock;				/* Get starting time. */
      488 	call backup_map_$beginning_line (dtp, line_pointer, n);
      489 						/* Begin reload. */
      490 
      491 
      492 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Main Processing Loop */
      493 
      494 
      495 loc_label (2):
      496 next:						/* get first of next logical record */
      497 	if MRS ^= 0 then do;			/* must complete read of last seg */
      498 	     call bk_input$rd_tape (null (), (0), seg_buff, scnt, code);
      499 	     if code = 2 then code = 0;		/* ok if run onto new tape */
      500 	     if code ^= 0 then go to TAPE_DONE;
      501 	     call hcs_$truncate_seg (seg_buff, 0, (code));/* throw away data */
      502 	     MRS = 0;				/* done with flushing read */
      503 	end;
      504 
      505 	if FRS = 0 then do;
      506 	     call bk_input$rd_tape (hp, hcnt, seg_buff, scnt, code);
      507 						/* read hdr, read seg to pdir */
      508 	end;
      509 	else do;					/* read hdr only, seg to pdir later */
      510 	     call bk_input$rd_tape (hp, hcnt, null (), scnt, code);
      511 						/* just header */
      512 	     if scnt > 0 then MRS = 1;		/* remember to read seg later */
      513 	end;
      514 
      515 
      516 TAPE_DONE:
      517 	if code ^= 0 then do;			/* check for end of last reload tape */
      518 	     if code = 1 then code = 0;		/* Is this the end of the last tape? */
      519 	     if bk_ss_$sub_entry then a_code = code;
      520 
      521 /*	finish up and quit */
      522 
      523 loc_label (3):
      524 stop:
      525 	     call bk_input$input_finish;		/* if done, clean up i/o */
      526 loc_label (4):
      527 terminate:
      528 	     if bk_ss_$retrievesw then call bk_retrieve$report_retrieval;
      529 						/* Report if doing a retrieval. */
      530 loc_label (5):
      531 reported:
      532 	     if ^bk_ss_$debugsw then do;		/* Is this a real run? */
      533 		if ^bk_ss_$qchecksw then		/* Should we restore quota checking? */
      534 		     call hphcs_$restore_quota;	/* Enable quota-checking. */
      535 		call hphcs_$fs_get_trans_sw (old_trans_sw, ts);
      536 						/* Restore switch settings. */
      537 	     end;
      538 	     dtp = clock;				/* Get stopping time. */
      539 	     call backup_map_$terminal_line (dtp, code);	/* Type normal or abnormal termination comment. */
      540 	     call hcs_$truncate_seg (hp, 0, code);	/* Clean up the buffer segments. */
      541 	     call hcs_$truncate_seg (seg_buff, 0, code);	/* .. */
      542 	     if bk_ss_$myname = "backup_load" | bk_ss_$myname = "backup_load_" then bk_ss_$myname = " ";
      543 						/* reset name if we set it */
      544 RETURN:
      545 	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      546 	     if bk_ss_$sub_entry then do;
      547 		if dir_priv_code = 0 then call system_privilege_$dir_priv_off ((0));
      548 		call backup_control_mgr_$terminate (control_ptr);
      549 	     end;
      550 	     return;				/* end of job */
      551 	end;					/* make check for physical volume recovery */
      552 						/* and skip if pvnames don't match */
      553 /**** CORRECT FOR BUG IN 10.0 WHERE status_version = 0 but SHOULD = 2. */
      554 
      555 	if hp -> h.status_version = 0 then hp -> h.status_version = 2;
      556 
      557 	if bk_ss_$pvsw & hp -> h.status_version >= 2 & hp -> h.nss_info_relp ^= "0"b then
      558 	     if pointer (hp, hp -> h.nss_info_relp) -> bk_nss_info.pvname ^= bk_ss_$pvname then go to next;
      559 
      560 	htype = hp -> h.record_type;			/* Pick up record type. */
      561 	dtp = hp -> h.dtd;				/* pickup date and time record dumped */
      562 	dtd_test = substr (bit (dtp, 52), 1, 36);	/* convert it to bit 36 for testing */
      563 
      564 	call CHECK_FOR_NEW_DIRECTORY ();
      565 
      566 	if bk_ss_$retrievesw then do;			/* If retrieval check for correct seg */
      567 	     if bk_ss_$datesw			/* Has a comparison date been given? */
      568 		then
      569 		if dtp < bk_ss_$date then go to next;	/* Must be copy dumped on or after the given date */
      570 	     call bk_retrieve$check_retrieval (label_index);
      571 	     go to loc_label (label_index);		/* if match go to checked else to next */
      572 	end;
      573 
      574 
      575 	else if htype = ndc_directory_list then go to checked;
      576 						/* 2nd pass for directory */
      577 
      578 /*	On reload check dates to see if later version already present	*/
      579 
      580 	else do;					/* Reload not retrieve */
      581 	     if ^bk_ss_$no_reload then do;
      582 get_dates:
      583 		call hcs_$status_long (hp -> h.dname, hp -> h.ename, 0, stptr, null, code);
      584 						/* get branch data */
      585 		if code ^= 0 then
      586 		     if code = error_table_$noentry then go to checked;
      587 						/* New Segment */
      588 		     else if code = error_table_$no_dir then go to checked;
      589 						/* New segment in reload */
      590 		     else if code = error_table_$moderr | code = error_table_$incorrect_access then do;
      591 give_acc:
      592 			call backup_util$give_access (hp -> h.dname, hp -> h.ename, code);
      593 						/* Try to give ourselves access */
      594 			if code ^= 0 then do;
      595 			     call backup_map_$fs_error_line (code, "add_acl_entries backup_util$give_access",
      596 				hp -> h.dname, hp -> h.ename);
      597 			     go to next;
      598 			end;
      599 			else go to get_dates;	/* Go try again */
      600 		     end;				/* end of easily recognizable errors */
      601 		     else if ^bk_ss_$debugsw
      602 			& (code = error_table_$pvid_not_found | code = error_table_$vtoce_connection_fail) then do;
      603 			call hphcs_$delentry_file (hp -> h.dname, hp -> h.ename, code);
      604 			if code = 0 then go to checked;
      605 			if code = error_table_$moderr | code = error_table_$incorrect_access
      606 			     | code = error_table_$no_info then
      607 			     goto give_acc;
      608 			call backup_map_$fs_error_line (code, "hphcs_$delentry_file", hp -> h.dname, hp -> h.ename);
      609 			go to next;
      610 		     end;
      611 
      612 		     else do;			/* Strange error so give up */
      613 			call backup_map_$fs_error_line (code, "hcs_$status_long", hp -> h.dname, hp -> h.ename);
      614 			go to next;
      615 		     end;
      616 
      617 /*	Now actually check the dates		*/
      618 
      619 		if dtd_test < status.dtm then		/* if dump earlier than seg in system */
      620 		     if dtd_test < status.dtem then	/* and earlier than branch in system */
      621 			if ^bk_ss_$ignore_dates then	/* and the system dates are not unmeaningless */
      622 			     go to next;		/* then go get next */
      623 	     end;					/* finished with date testing */
      624 	end;
      625 
      626 /*	Now start checking segment type on tape */
      627 
      628 loc_label (6):
      629 checked:
      630 	type = 0;					/* Set up type for build_tree. */
      631 
      632 	if (htype = ndc_directory | htype = ndc_directory_list | htype = sec_dir) & hp -> h.bitcnt ^= 0 then
      633 						/* MSF */
      634 	     call bk_retrieve$flag_msf (bk_ss_$retrieval_index);
      635 
      636 	if bk_ss_$translate_access_class then do;	/* translate access class read from tape */
      637 	     call translate_aim_attributes_ (bk_ss_$source_attributes_ptr, hp -> h.access_class,
      638 		bk_ss_$target_attributes_ptr, access_class, code);
      639 	     if code ^= 0 then do;
      640 		call convert_aim_attributes_ (hp -> h.access_class, octal_string);
      641 		call backup_map_$error_line (code, bk_ss_$myname, "Attempting to translate access class ^a for ^a.",
      642 		     octal_string, pathname_ ((hp -> h.dname), (hp -> h.ename)));
      643 		go to next;
      644 	     end;
      645 	     hp -> h.access_class = access_class;
      646 	end;
      647 
      648 	if htype = ndc_directory_list then do;		/* Is it the results of list_dir? */
      649 
      650 /* Directory listing:  clean it out if "trim" was specified and reload the links */
      651 
      652 do_directory_list:
      653 	     type = 3;				/* Set up type code. */
      654 	     optionsw = 0;				/* Set up option switch. */
      655 	     call PRINT_HEADER ();
      656 
      657 	     if (htype = ndc_directory_list) & ^bk_ss_$no_reload then
      658 		if ^HAVE_SMA () then do;		/* force access so reload will work properly */
      659 		     call expand_pathname_ ((hp -> h.dname), dirname_dirname, dirname_ename, (0));
      660 						/* get it as two pieces */
      661 		     call backup_util$give_access ((dirname_dirname), (dirname_ename), code);
      662 		     if code ^= 0 then do;
      663 			call backup_map_$fs_error_line (code, "backup_util$give_access", hp -> h.dname, "");
      664 			go to next;		/* forget trying the rest: don't have sma on the dir */
      665 		     end;
      666 		end;
      667 
      668 	     if bk_ss_$qchecksw then
      669 		on record_quota_overflow
      670 		     begin;
      671 		     code = error_table_$rqover;
      672 		     if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
      673 		     call UNCREATE;
      674 		     go to no_dir;
      675 		end;
      676 	     if bk_ss_$sub_entry then bk_ss_$trimsw = bk_ss_$control_ptr -> backup_control.trim_sw (bk_ss_$path_index);
      677 	     call backup_load_dir_list (hp, code);	/* Go process the record. */
      678 	     if bk_ss_$qchecksw then revert record_quota_overflow;
      679 	     if code ^= 0 then do;			/* Comment if any errors. */
      680 no_dir:
      681 		call backup_map_$fs_error_line (code, "backup_load_dir_list", hp -> h.dname, "");
      682 		go to next;
      683 	     end;
      684 
      685 
      686 /* Replace Initial ACL in as many rings as possible */
      687 
      688 	     if (htype = ndc_directory_list) & ^bk_ss_$no_reload then do;
      689 		unspec (inacl_info) = "0"b;		/* see if have to delete any existing ones */
      690 		call hcs_$list_inacl_all (hp -> h.dname, null, null, addr (inacl_info), code);
      691 		if code ^= 0 then do;
      692 		     call backup_map_$fs_error_line (code, "hcs_$list_inacl_all", hp -> h.dname, "");
      693 		     do ring = 0 to 7;		/* mark non zero to force setting */
      694 			inacl_info.sia_count (ring) = 1;
      695 			inacl_info.dia_count (ring) = 1;
      696 		     end;
      697 		end;
      698 
      699 		do ring = cu_$level_get () to 7;	/* Replace all initial ACL's from this ring on up. */
      700 		     if (hp -> h.inaclc (ring) > 0) | (inacl_info.sia_count (ring) > 0) then do;
      701 			if hp -> h.inaclc (ring) = 0 then
      702 			     aclp = null ();
      703 			else aclp = pointer (hp, hp -> h.inaclp (ring));
      704 						/* Get a pointer to initial ACL. */
      705 			call hcs_$replace_inacl (hp -> h.dname, "", aclp, hp -> h.inaclc (ring), "1"b, ring, code);
      706 			if code ^= 0 then		/* Replace the initial ACL. */
      707 			     call backup_map_$fs_error_line (code, "hcs_$replace_inacl", hp -> h.dname, "");
      708 		     end;
      709 
      710 		     if (hp -> h.dir_inaclc (ring) > 0) | (inacl_info.dia_count (ring) > 0) then do;
      711 			if hp -> h.inaclc (ring) = 0 then
      712 			     aclp = null ();
      713 			else aclp = pointer (hp, hp -> h.dir_inaclp (ring));
      714 						/* Get a pointer to directory initial ACL. */
      715 			call hcs_$replace_dir_inacl (hp -> h.dname, "", aclp, hp -> h.dir_inaclc (ring), "1"b, ring,
      716 			     code);
      717 			if code ^= 0 then		/* Replace the directory initial ACL. */
      718 			     call backup_map_$fs_error_line (code, "hcs_$replace_dir_inacl", hp -> h.dname, "");
      719 		     end;
      720 		end;
      721 	     end;
      722 
      723 	     go to next;
      724 	end;
      725 	bp = pointer (hp, hp -> h.bp);		/* Get pointer to branch info. */
      726 	np = pointer (hp, bp -> br (1).namerp);		/* Get pointer to name array. */
      727 	optionsw = fixed (bp -> br (1).optionsw, 2);	/* Get option switch for call. */
      728 
      729 
      730 /*	check for segment type record		*/
      731 
      732 	if (htype = ndc_segment) | (htype = sec_seg) then go to load_it;
      733 						/* Is the record of a complete segment? */
      734 
      735 
      736 /*	check for directory type information in this record */
      737 
      738 	if (htype = ndc_directory) | (htype = sec_dir) then do;
      739 						/* Is it a directory's info? */
      740 do_directory:
      741 	     if bk_ss_$no_reload then go to load_it;
      742 	     type = 2;				/* Set up type for build_tree. */
      743 
      744 	     do i = 1 to fixed (bp -> br (1).nnames, 17); /* Examine each name. */
      745 		ix = addr (np -> name (i));		/* Get pointer to this name element. */
      746 		call hcs_$status_minf (hp -> h.dname, ix -> name (1).string, 0, sys_type, bc, code);
      747 		if code ^= 0 then do;		/* Error detected? */
      748 		     if code ^= error_table_$noentry then
      749 						/* Entry missing, OK. */
      750 			if code ^= error_table_$no_dir then
      751 						/* Directory missing, OK. */
      752 			     call backup_map_$fs_error_line (code, "status_minf in backup_load",
      753 						/* Give comment. */
      754 				hp -> h.dname, ix -> name (1).string);
      755 		end;
      756 		else if sys_type = 2 then do;		/* Entry exists, is it a directory? */
      757 
      758 
      759 /*	See if a directory with a conflicting name exists.
      760*   If so, then assume that it is the directory we are trying
      761*   to reload so add all reload info (names acls etc.) to it. */
      762 
      763 		     if i > 1 then do;		/* Ignore swap on first name. */
      764 			np -> name (1).size = ix -> name (1).size;
      765 						/* Replace first name with current one. */
      766 			np -> name (1).string = ix -> name (1).string;
      767 						/* .. */
      768 			ix -> name (1).size = bit (hp -> h.elen, 17);
      769 						/* Replace name with (first) name in header. */
      770 			ix -> name (1).string = hp -> h.ename;
      771 						/* .. */
      772 			hp -> h.elen = fixed (np -> name (1).size, 17);
      773 						/* Replace name in header with this one. */
      774 			hp -> h.ename = np -> name (1).string;
      775 						/* .. */
      776 		     end;
      777 		     go to load_it;			/* Go do normal processing. */
      778 		end;
      779 	     end;
      780 	     go to load_it;				/* Go load the info. */
      781 	end;
      782 	call date_time_ (dtp, dump_date);		/* Convert the dump date. */
      783 	call ioa_$rs ("Unrecognized record type ^d written ^a by ^a:^/^a>^a^/", line, n, htype, dump_date,
      784 	     hp -> h.dumper_id, hp -> h.dname, hp -> h.ename);
      785 	call backup_map_$on_line (line_pointer, n);
      786 	go to next;				/* Go try the next record. */
      787 
      788 
      789 /* * * * * * * * * * * * * * * * * * * * * Make entry for this segment or link. */
      790 
      791 
      792 load_it:
      793 	if MRS ^= 0 then do;			/* seg reload direct to target */
      794 	     if ^(HAVE_SMA ()) then do;		/* dont dare */
      795 		call bk_input$rd_tape (null (), (0), seg_buff, scnt, code);
      796 		MRS = 0;
      797 		if code ^= 0 then do;
      798 		     if code = 2 then code = 0;
      799 		     if code = 0 then
      800 			go to next;
      801 		     else go to TAPE_DONE;
      802 		end;
      803 	     end;
      804 	     else do;
      805 		save_ename = hp -> h.ename;		/* save real pri name */
      806 		save_elen = hp -> h.elen;		/* and its length */
      807 		hp -> h.ename = unique_chars_ (""b) || substr (save_ename, 1, 17);
      808 						/* make funny name */
      809 		hp -> h.elen = min (32, 15 + save_elen);
      810 	     end;
      811 	end;
      812 
      813 	if (htype = sec_seg) | (htype = sec_dir) then do;
      814 	     access_class = hp -> h.access_class;
      815 	     if (access_class & (^sys_info$access_class_ceiling)) ^= "0"b then go to set_ac;
      816 						/* pre AIM */
      817 	     if htype = sec_seg then do;
      818 		if hp -> h.switches.multiple_class then type = 4;
      819 						/* a upgraded segment */
      820 	     end;
      821 	     else do;
      822 		if hp -> h.switches.multiple_class then type = 5;
      823 						/* a upgraded directory */
      824 	     end;
      825 	end;
      826 	else do;
      827 set_ac:
      828 	     access_class = "0"b;			/* old branch */
      829 	end;
      830 	if bk_ss_$sub_entry then bk_ss_$trimsw = bk_ss_$control_ptr -> backup_control.trim_sw (bk_ss_$path_index);
      831 	bk_ss_$hp = hp;
      832 	call backup_load_dir_list$build_tree (hp -> h.dname, hp -> h.ename, type, hp -> h.bitcnt, optionsw, "",
      833 	     access_class, code);
      834 	if code ^= 0 then do;
      835 	     call backup_map_$fs_error_line (code, "build_tree", hp -> h.dname, hp -> h.ename);
      836 	     if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
      837 	     go to next;				/* and go get next logical record */
      838 	end;
      839 
      840 	else if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "1"b;
      841 
      842 	unspec (reload_set_info) = "0"b;
      843 	reload_set_info.version = reload_set_version_2;
      844 
      845 	if ((htype = ndc_segment) | (htype = sec_seg)) then do;
      846 	     if ^bk_ss_$debugsw then do;
      847 		if hp -> h.max_length ^= sys_info$default_max_length then do;
      848 						/* only set if create_branch_ didn't */
      849 						/* already set correct value */
      850 						/* thus possibly avoiding setfault */
      851 		     reload_set_info.should_set.max_length = "1"b;
      852 		     reload_set_info.max_length = hp -> h.max_length;
      853 		end;
      854 	     end;
      855 	     else if ^bk_ss_$no_reload then do;
      856 		call hcs_$set_max_length ((hp -> h.dname), (hp -> h.ename), (hp -> h.max_length), code);
      857 		if code ^= 0 then			/* Attempt to set max length of segment. */
      858 		     call backup_map_$fs_error_line (code, "hcs_$set_max_length", hp -> dname, hp -> ename);
      859 	     end;
      860 	end;					/*
      861*						   /*	SKIP SEGMENT INITIATION AND COPYING IF NOT RELOADING
      862*						   /*									*/
      863 	if ^bk_ss_$no_reload then
      864 	     if scnt > 0 then do;			/* Any segment to reload? */
      865 		if MRS = 0 then do;			/* has been read to pdir already */
      866 		     if bk_ss_$debugsw & ^bk_ss_$restore_access_class then
      867 			call hcs_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
      868 		     else call system_privilege_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
      869 		     if code ^= 0 then do;
      870 			call backup_map_$fs_error_line (code, "initiate", hp -> h.dname, hp -> h.ename);
      871 			go to next;		/* go get next logical record */
      872 		     end;
      873 
      874 		     if bk_ss_$qchecksw		/* If checking quotas */
      875 		     then do;
      876 			on record_quota_overflow call handle_rqo;
      877 			segptr -> mover = seg_buff -> mover;
      878 						/* move it from temp seg */
      879 			revert record_quota_overflow; /* revert the condition */
      880 		     end;
      881 
      882 		     else segptr -> mover = seg_buff -> mover;
      883 						/* reload segment from temp i/o segment */
      884 
      885 		     call hcs_$terminate_noname (segptr, code);
      886 						/* terminate segment after reloading */
      887 		     if code ^= 0 then		/* Print comment for error in terminate. */
      888 			call backup_map_$fs_error_line (code, "terminate_noname", hp -> h.dname, hp -> h.ename);
      889 		end;
      890 
      891 
      892 		else do;				/* must still read seg & rename */
      893 
      894 		     if bk_ss_$debugsw & ^bk_ss_$restore_access_class then
      895 			call hcs_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
      896 		     else call system_privilege_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
      897 		     if code ^= 0 then do;
      898 			call backup_map_$fs_error_line (code, "initiate", hp -> h.dname, hp -> h.ename);
      899 
      900 			call UNCREATE;
      901 			go to next;
      902 		     end;				/* seg has been initiated, actually couldn't fail.. */
      903 		     if bk_ss_$qchecksw then on record_quota_overflow call handle_rqo;
      904 		     call bk_input$rd_tape (null (), (0), segptr, scnt, code);
      905 						/* read data into seg */
      906 		     if bk_ss_$qchecksw then revert record_quota_overflow;
      907 		     MRS = 0;			/* remember this is done */
      908 		     if code ^= 0 then do;		/* tape trouble or EOT */
      909 			call UNCREATE;
      910 			if code = 2 then code = 0;
      911 			if code ^= 0 then
      912 			     go to TAPE_DONE;	/* err or no more tapes */
      913 			else go to next;
      914 		     end;				/* code from tape nonzero */
      915 
      916 		     call hcs_$terminate_noname (segptr, code);
      917 		     if code ^= 0 then
      918 			call backup_map_$fs_error_line (code, "terminate", hp -> h.dname, hp -> h.ename);
      919 						/* now must put pri name on seg */
      920 		     call hcs_$chname_file (hp -> h.dname, hp -> h.ename, hp -> h.ename, save_ename, code);
      921 		     if code ^= 0 then do;
      922 			if code = error_table_$namedup then do;
      923 						/* only sensible err */
      924 			     call backup_util$delete_name (hp -> h.dname, save_ename, code);
      925 			     if code ^= 0 then do;	/* can't happen */
      926 uncreate:
      927 				if bk_ss_$sub_entry then do;
      928 				     bk_ss_$control_ptr -> backup_control.status_code (bk_ss_$path_index) =
      929 					error_table_$namedup;
      930 				     bk_ss_$control_ptr -> backup_control.error_name (bk_ss_$path_index) =
      931 					"backup_util$delete_name";
      932 				     bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
      933 				end;
      934 				call UNCREATE;
      935 				go to next;
      936 			     end;
      937 			     else do;		/* name was deleted */
      938 				call hcs_$chname_file (hp -> h.dname, hp -> h.ename, hp -> h.ename, save_ename,
      939 				     code);
      940 				if code ^= 0 then go to uncreate;
      941 			     end;
      942 			end;
      943 			else go to uncreate;
      944 		     end;
      945 		     hp -> h.ename = save_ename;
      946 		     hp -> h.elen = save_elen;
      947 		end;				/* end loading seg from tape */
      948 	     end;					/* end loading seg */
      949 	dtd = fixed (bp -> br (1).dtd, 52);		/* Get times from branch structure. */
      950 	dtu = fixed (bp -> br (1).dtu, 52);
      951 	dtem = fixed (bp -> br (1).dtbm, 52);
      952 	dtsm = fixed (bp -> br (1).dtm, 52);
      953 	call PRINT_HEADER ();
      954 	if bk_ss_$mapsw then
      955 	     call backup_map_$detail_line2 (hp -> h.ename, divide (scnt + 1023, 1024, 9, 0), RECORD_TYPE (htype), dtp,
      956 		dtem, dtd, dtu, dtsm);
      957 
      958 /* Distribute the no_reload checks so that maps can be better */
      959 
      960 	if (htype = sec_seg) | (htype = sec_dir) | (htype = ndc_segment) | (htype = ndc_directory) then
      961 	     if ^bk_ss_$debugsw then do;		/* Insert author and activity if possible */
      962 
      963 
      964 /*	set the author		*/
      965 
      966 		reload_set_info.should_set.author = "1"b;
      967 		reload_set_info.author = addr (hp -> h.quota) -> author;
      968 
      969 	     end;
      970 
      971 
      972 /*	set bitcount author and safety switch as well as the audit_flag */
      973 
      974 	if (htype = sec_seg) | (htype = sec_dir) | (htype = ndc_segment) | (htype = ndc_directory) then do;
      975 	     if ^bk_ss_$debugsw then do;		/* Cannot set bitcount author in debug mode. */
      976 		reload_set_info.should_set.bc_author = "1"b;
      977 		reload_set_info.bc_author = hp -> h.bitcount_author;
      978 		reload_set_info.should_set.safety_sw = "1"b;
      979 		reload_set_info.safety_sw = hp -> h.switches.safety_sw;
      980 		reload_set_info.should_set.audit_flag = "1"b;
      981 		reload_set_info.audit_flag = hp -> h.switches.audit_flag;
      982 	     end;
      983 
      984 	     else do;
      985 		if ^bk_ss_$no_reload then do;
      986 		     call hcs_$set_safety_sw (hp -> dname, hp -> ename, (hp -> h.safety_sw), code);
      987 		     if code ^= 0 & code ^= error_table_$incorrect_access then
      988 			call backup_map_$fs_error_line (code, "hcs_$set_safety_sw", hp -> dname, hp -> ename);
      989                           call system_privilege_$set_entry_audit_switch ((hp -> dname), (hp -> ename), (hp -> h.audit_flag), code);
      990 		      if code ^= 0 then call backup_map_$fs_error_line (code, "system_privilege_$set_entry_audit_switch", hp -> dname, hp -> ename);
      991 		end;
      992 	     end;
      993 	end;
      994 
      995 
      996 	if htype = sec_seg then do;
      997 	     if hp -> h.switches.entrypt_sw = "0"b then
      998 		call_limiter = 0;			/* not to be used */
      999 	     else call_limiter = fixed (hp -> h.entrypt_bound, 14);
     1000 	     if ^bk_ss_$debugsw then do;
     1001 		if call_limiter ^= 0 then do;		/* avoid setfault if possible */
     1002 		     reload_set_info.should_set.entry_bound = "1"b;
     1003 		     reload_set_info.entry_bound = call_limiter;
     1004 		end;
     1005 	     end;
     1006 	     else do;
     1007 		if ^bk_ss_$no_reload then do;
     1008 		     call hcs_$set_entry_bound (hp -> h.dname, hp -> h.ename, call_limiter, code);
     1009 		     if code ^= 0 & code ^= error_table_$incorrect_access then
     1010 			call backup_map_$fs_error_line (code, "hcs_$set_entry_bound", hp -> h.dname, hp -> h.ename);
     1011 		end;
     1012 	     end;
     1013 	end;					/*	add names		*/
     1014 
     1015 	i = fixed (bp -> br (1).nnames, 17);		/* how many names are there? */
     1016 	if i > 1 then call backup_util$add_names (hp -> h.dname, hp -> h.ename, np, i, "1"b);
     1017 
     1018 
     1019 /*	replace the acl 	*/
     1020 
     1021 	if hp -> h.aclc = 0 then
     1022 	     aclp = null ();
     1023 	else aclp = pointer (hp, hp -> h.aclp);		/* Get pointer to array. */
     1024 	code = 0;
     1025 
     1026 	if (htype = ndc_segment) | (htype = sec_seg) then do;
     1027 	     if ^bk_ss_$no_reload then do;
     1028 		call hcs_$replace_acl (hp -> h.dname, hp -> h.ename, aclp, hp -> h.aclc, "1"b, code);
     1029 		if code ^= 0 & code ^= error_table_$incorrect_access then
     1030 		     call backup_map_$fs_error_line (code, "hcs_$replace_acl", hp -> h.dname, hp -> h.ename);
     1031 		go to set_rb;			/* Now set the ring brackets. */
     1032 	     end;
     1033 	end;
     1034 	else if (htype = ndc_directory) | (htype = sec_dir) then do;
     1035 	     if ^bk_ss_$no_reload then do;
     1036 		call hcs_$replace_dir_acl (hp -> h.dname, hp -> h.ename, aclp, hp -> h.aclc, "0"b, code);
     1037 
     1038 		if code ^= 0 & code ^= error_table_$incorrect_access then
     1039 		     call backup_map_$fs_error_line (code, "hcs_$replace_dir_acl", hp -> h.dname, hp -> h.ename);
     1040 		go to set_rb;
     1041 	     end;
     1042 	end;
     1043 
     1044 /* Now reload the ring brackets */
     1045 
     1046 	if bp -> br (1).rb1 = ""b then do;		/* if from old tape and no ring brackets defined */
     1047 	     i = 0;				/* set flag indicating default ring brackets set */
     1048 	     rings (1), rings (2), rings (3) = 4;	/* 4 rather than 5? questionable! */
     1049 	end;
     1050 	else do;					/* pick up ring brackets from branch information */
     1051 set_rb:
     1052 	     i = 1;				/* set flag */
     1053 	     rings (1) = fixed (bp -> br (1).rb1, 6);
     1054 	     rings (2) = fixed (bp -> br (1).rb2, 6);
     1055 	     rings (3) = fixed (bp -> br (1).rb3, 6);
     1056 	end;
     1057 
     1058 	if bk_ss_$enforce_minimum_ring then do;
     1059 	     rings (1) = max (bk_ss_$minimum_ring, rings (1));
     1060 	     rings (2) = max (bk_ss_$minimum_ring, rings (2));
     1061 	     rings (3) = max (bk_ss_$minimum_ring, rings (3));
     1062 	end;
     1063 
     1064 	if ^bk_ss_$no_reload then
     1065 	     if bp -> br (1).dirsw then
     1066 		call hcs_$set_dir_ring_brackets (hp -> h.dname, hp -> h.ename, rings, code);
     1067 	     else call hcs_$set_ring_brackets (hp -> h.dname, hp -> h.ename, rings, code);
     1068 	call print_rbs (rings);
     1069 	if code ^= 0 & code ^= error_table_$incorrect_access then
     1070 	     call backup_map_$fs_error_line (code, "set_ring_brackets", hp -> h.dname, hp -> h.ename);
     1071 	else if i = 0 then do;			/* check flag and put line in map (but not typed on-line) */
     1072 	     call ioa_$rs ("Default ring brackets assigned to ^a>^a", line, n, hp -> h.dname, hp -> h.ename);
     1073 	     call backup_map_$directory_line (line_pointer, n);
     1074 	end;
     1075 
     1076 
     1077 	if code = error_table_$incorrect_access then
     1078 	     call backup_map_$fs_error_line (code, "ACL, ring brackets, safety switch", hp -> h.dname, hp -> h.ename);
     1079 
     1080 /*	set times		*/
     1081 
     1082 	times.dtem = fixed (bp -> br (1).dtbm, 52);	/* Copy time modified from entry. */
     1083 	if ^bk_ss_$retrievesw then			/* Restore dtd if reload */
     1084 	     times.dtd = dtp;			/* Get time dumped from header. */
     1085 	else times.dtd = 0;				/* On retrieval set dtd to 0, force dumping */
     1086 	times.dtu = fixed (bp -> br (1).dtu, 52);	/* Copy time used from entry. */
     1087 	times.dtm = fixed (bp -> br (1).dtm, 52);	/* Copy time segment modified from entry. */
     1088 	if ^bk_ss_$no_reload then
     1089 	     if ^bk_ss_$debugsw then do;		/* Do if really reloading */
     1090 		reload_set_info.should_set.tpd = "1"b;
     1091 		reload_set_info.tpd = hp -> h.switches.tpd;
     1092 		reload_set_info.should_set.dtem, reload_set_info.should_set.dtd, reload_set_info.should_set.dtu,
     1093 		     reload_set_info.should_set.dtm = "1"b;
     1094 		reload_set_info.dtem = substr(bit (times.dtem, 52),1,36);
     1095 		reload_set_info.dtd = substr(bit (times.dtd, 52),1,36);
     1096 		reload_set_info.dtu = substr(bit (times.dtu, 52),1,36);
     1097 		reload_set_info.dtm = substr(bit (times.dtm, 52),1,36);
     1098 		call hphcs_$set_for_reloader (hp -> h.dname, hp -> h.ename, addr (reload_set_info), code);
     1099 		if code ^= 0 then
     1100 		     call backup_map_$fs_error_line (code, "hphcs_$set_for_reloader", hp -> h.dname, hp -> h.ename);
     1101 
     1102 		if reload_set_info.author_code ^= 0 then
     1103 		     call backup_map_$fs_error_line ((reload_set_info.author_code), "set_for_reloader(author)",
     1104 			hp -> h.dname, hp -> h.ename);
     1105 
     1106 		if reload_set_info.bc_author_code ^= 0 then
     1107 		     call backup_map_$fs_error_line ((reload_set_info.bc_author_code), "set_for_reloader(bc_author)",
     1108 			hp -> h.dname, hp -> h.ename);
     1109 
     1110 		if reload_set_info.max_length_code ^= 0 then
     1111 		     call backup_map_$fs_error_line ((reload_set_info.max_length_code),
     1112 			"set_for_reloader(max_length)", hp -> h.dname, hp -> h.ename);
     1113 
     1114 		if reload_set_info.entry_bound_code ^= 0 then
     1115 		     call backup_map_$fs_error_line ((reload_set_info.entry_bound_code),
     1116 			"set_for_reloader(entry_bound)", hp -> h.dname, hp -> h.ename);
     1117 
     1118 	     end;
     1119 
     1120 	go to next;				/* segment reloaded, get next logical record */
     1121 
     1122 /**/
     1123 
     1124 CHECK_FOR_NEW_DIRECTORY:
     1125      proc ();
     1126 	if hp -> h.dname ^= old_dname then do;
     1127 	     old_dname = substr (hp -> h.dname, 1, hp -> h.dlen);
     1128 	     new_dir = "1"b;
     1129 	end;
     1130 	return;
     1131      end CHECK_FOR_NEW_DIRECTORY;
     1132 
     1133 PRINT_HEADER:
     1134      proc ();
     1135 	if new_dir then do;
     1136 	     if bk_ss_$mapsw then call backup_map_$directory_line (addr (hp -> h.dname), hp -> h.dlen);
     1137 	     new_dir = "0"b;
     1138 	end;
     1139 	return;
     1140      end PRINT_HEADER;
     1141 
     1142 /* -------------------------------------------------- */
     1143 
     1144 HAVE_SMA:
     1145      proc returns (bit (1) aligned);
     1146 
     1147 
     1148 /* intl proc to make sure we have sma on parent before appending a unique
     1149*   named branch for later rename .
     1150*   get_user_effmode is called to get the mode, rather than
     1151*   status_ in order to avoid vtoc io.  However get user effmode
     1152*   does not correctly return the initializers access.   We know
     1153*   that access_mode, when really computing access will give the
     1154*   initializer access.  For this reason, and for the sake of efficiency,
     1155*   we do not wish to check the users access if the user is the
     1156*   initializer.
     1157*   For all other users we must check the access to make sure sma is
     1158*   there.  However if the directory for which access is to be computed
     1159*   is the same directory for which we las computed access, then we can
     1160*   just return the previously computed value.  This is another optimization.
     1161*   If the user is not initializer then if the directory is new then
     1162*   if the access computation is successful then we will remember that
     1163*   new dirname and access to it.
     1164*   10/01/75 -- RE Mullen */
     1165 
     1166 dcl  ckdir char (168);
     1167 dcl  ckent char (32);
     1168 dcl  ckcode fixed bin (35);
     1169 dcl  effmode fixed bin (5);
     1170 	if INITIALIZER then return ("1"b);		/* always true */
     1171 	else if substr (hp -> h.dname, 1, hp -> h.dlen) = hs_dirname then return (hs_bit);
     1172 						/* access known */
     1173 						/* try to determine access */
     1174 	call expand_pathname_ (substr (hp -> h.dname, 1, hp -> h.dlen), ckdir, ckent, ckcode);
     1175 	if ckcode ^= 0 then return ("0"b);
     1176 	call hcs_$get_user_effmode (ckdir, ckent, USERID, cu_$level_get (), effmode, ckcode);
     1177 	if ckcode ^= 0 then
     1178 	     return ("0"b);
     1179 	else do;					/* update assoc mem */
     1180 	     if (bit (effmode) & "01011"b) = "01011"b then
     1181 		hs_bit = "1"b;
     1182 	     else hs_bit = "0"b;
     1183 	     hs_dirname = substr (hp -> h.dname, 1, hp -> h.dlen);
     1184 						/* remember name */
     1185 	end;
     1186 
     1187 	return (hs_bit);				/* tell caller the result */
     1188 
     1189      end HAVE_SMA;
     1190 
     1191 
     1192 
     1193 /* ----------------------------------------------------------- */
     1194 
     1195 
     1196 UNCREATE:
     1197      proc;					/* to delete seg mistakenly appended */
     1198 
     1199 dcl  hcs_$delentry_file entry (char (*) aligned, char (*) aligned, fixed bin (35));
     1200 dcl  uccode fixed bin (35);
     1201 
     1202 	call hcs_$set_copysw (hp -> h.dname, hp -> h.ename, "0"b, uccode);
     1203 	call hcs_$delentry_file (hp -> h.dname, hp -> h.ename, uccode);
     1204 	if uccode ^= 0 then call backup_map_$fs_error_line (uccode, "deleting temp_seg", hp -> h.dname, hp -> h.ename);
     1205 
     1206      end UNCREATE;
     1207 
     1208 
     1209 handle_rqo:
     1210      proc;					/* record_quota_overflow handler */
     1211 
     1212 
     1213 	code = error_table_$rqover;			/* set the error */
     1214 	call backup_map_$fs_error_line (code, "backup_load", hp -> h.dname, hp -> h.ename);
     1215 	call UNCREATE;
     1216 	if bk_ss_$sub_entry then do;
     1217 	     bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
     1218 	     go to next;
     1219 	end;
     1220 	go to next;
     1221 
     1222      end handle_rqo;
     1223 
     1224 /**/
     1225 
     1226 /* Prints ACLs and ring brackets for reload map */
     1227 
     1228 printers:
     1229      procedure ();
     1230 
     1231 declare  text character (168);
     1232 declare  text_l fixed binary (21);
     1233 
  9     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  9     2 /* format: style3,indcomtxt,idind30 */
  9     3 
  9     4 declare   acl_ptr                       pointer;
  9     5 declare   acl_count                     fixed bin;
  9     6 
  9     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  9     8           2 version                     char (8) aligned,
  9     9           2 count                       fixed bin,
  9    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  9    11 
  9    12 declare 1 general_acl_entry             based,
  9    13           2 access_name                 character (32) unaligned,
  9    14           2 mode                        bit (36) aligned,
  9    15           2 status_code                 fixed bin (35);
  9    16 
  9    17 
  9    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  9    19           2 version                     char (8) aligned,
  9    20           2 count                       fixed bin,
  9    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  9    22 
  9    23 declare 1 general_extended_acl_entry    aligned based,
  9    24           2 access_name                 character (32) unaligned,
  9    25           2 mode                        bit (36) aligned,
  9    26           2 extended_mode               bit (36) aligned,
  9    27           2 status_code                 fixed bin (35);
  9    28 
  9    29 
  9    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  9    31           2 version                     char (8) aligned,
  9    32           2 count                       fixed bin,
  9    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  9    34 
  9    35 declare 1 general_delete_acl_entry      aligned based,
  9    36           2 access_name                 character (32) unaligned,
  9    37           2 status_code                 fixed bin (35);
  9    38 
  9    39 
  9    40 declare 1 segment_acl                   aligned based (acl_ptr),
  9    41           2 version                     fixed bin,
  9    42           2 count                       fixed bin,
  9    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  9    44 
  9    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  9    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  9    47 
  9    48 
  9    49 declare 1 directory_acl                 aligned based (acl_ptr),
  9    50           2 version                     fixed bin,
  9    51           2 count                       fixed bin,
  9    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  9    53 
  9    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  9    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  9    56 
  9    57 
  9    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  9    59           2 version                     fixed bin,
  9    60           2 count                       fixed bin,
  9    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  9    62 
  9    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  9    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  9    65 
  9    66 
  9    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  9    68           DIR_ACL_VERSION_1             init ("dra1"),
  9    69           DELETE_ACL_VERSION_1          init ("dla1"))
  9    70                                         char (4) int static options (constant);
  9    71 
  9    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  9    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  9    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  9    75                                         char (8) internal static options (constant);
  9    76 
  9    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  9    78 
  9    79 /* End include file acl_structures.incl.pl1 */
     1234 
     1235 
     1236 
     1237 /* Print ring brackets */
     1238 
     1239 print_rbs:
     1240      entry (rings);
     1241 
     1242 declare  rings (3) fixed binary (3) parameter;
     1243 
     1244 	call ioa_$rsnnl ("Ring Brackets:^35t^(^d ^)", text, text_l, rings);
     1245 	call backup_map_$name_line (addr (text), text_l);
     1246 
     1247 	return;
     1248 
     1249      end printers;
     1250 
     1251      end backup_load;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0807.4  backup_load.pl1                   >spec>install>1111>backup_load.pl1
272          1    12/07/76  1740.3  backup_dir_list.incl.pl1          >ldd>include>backup_dir_list.incl.pl1
274          2    04/02/87  2006.7  bk_ss_.incl.pl1                   >ldd>include>bk_ss_.incl.pl1
276          3    06/11/76  1057.9  bk_nss_info.incl.pl1              >ldd>include>bk_nss_info.incl.pl1
278          4    08/04/88  2054.1  reload_set_info.incl.pl1          >ldd>include>reload_set_info.incl.pl1
280          5    05/06/74  1741.7  backup_fs_times.incl.pl1          >ldd>include>backup_fs_times.incl.pl1
282          6    11/21/83  1219.2  backup_control.incl.pl1           >ldd>include>backup_control.incl.pl1
284          7    04/29/76  1058.2  backup_preamble_header.incl.pl1   >ldd>include>backup_preamble_header.incl.pl1
286          8    07/16/87  1755.4  backup_record_types.incl.pl1      >ldd>include>backup_record_types.incl.pl1
1234         9    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FRS                             000240 automatic       fixed bin(17,0)          initial dcl 71 set ref 71* 468* 505
INITIALIZER                     000241 automatic       bit(1)                   initial dcl 71 set ref 71* 473* 1170
MRS                             000237 automatic       fixed bin(17,0)          initial dcl 71 set ref 71* 495 502* 512* 792 796*
                                                                                  865 907*
RECORD_TYPE                     000006 constant        char(10)                 initial array dcl 8-29 set ref 954*
USERID                          000316 automatic       char(32)                 packed unaligned dcl 71 set ref 472* 473 1176*
a_code                                 parameter       fixed bin(35,0)          dcl 71 set ref 345 349* 351* 352 382* 387* 477* 519*
access_class            122            based           bit(72)                  level 2 in structure "h" dcl 7-7 in procedure
                                                                                  "backup_load" set ref 637* 640* 645* 814
access_class                    000326 automatic       bit(72)                  dcl 71 in procedure "backup_load" set ref 637* 645
                                                                                  814* 815 827* 832*
aclc                    105            based           fixed bin(17,0)          level 2 dcl 7-7 set ref 1021 1028* 1036*
aclp                    104            based           bit(18)                  level 2 in structure "h" dcl 7-7 in procedure
                                                                                  "backup_load" ref 1023
aclp                            000136 automatic       pointer                  dcl 71 in procedure "backup_load" set ref 701* 703*
                                                                                  705* 711* 713* 715* 1021* 1023* 1028* 1036*
addr                                                   builtin function         dcl 170 ref 446 485 690 690 745 967 1098 1098 1136
                                                                                  1136 1245 1245
aim_translations         32            based           structure                level 3 dcl 6-8
allow_dir_overwrite      36(08)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 372
ap                              000130 automatic       pointer                  dcl 71 set ref 298* 299*
audit_flag              121(03)        based           bit(1)                   level 3 in structure "h" packed packed unaligned
                                                                                  dcl 7-7 in procedure "backup_load" ref 981 989
audit_flag                4     000635 automatic       bit(1)                   level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 981*
audit_flag                1(01) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 980*
author                    1(04) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 966*
author                                 based           char(32)                 dcl 7-61 in procedure "backup_load" ref 967
author                    7     000635 automatic       char(32)                 level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 967*
author_code              17     000635 automatic       fixed bin(35,0)          level 2 dcl 4-18 set ref 1102 1102
backup_control                         based           structure                level 1 dcl 6-8
backup_control_mgr_$initiate    000164 constant        entry                    external dcl 174 ref 351
backup_control_mgr_$terminate   000166 constant        entry                    external dcl 174 ref 360 548
backup_load_dir_list            000172 constant        entry                    external dcl 174 ref 677
backup_load_dir_list$build_tree 000170 constant        entry                    external dcl 174 ref 832
backup_map_$beginning_line      000176 constant        entry                    external dcl 174 ref 488
backup_map_$detail_line2        000200 constant        entry                    external dcl 174 ref 954
backup_map_$directory_line      000202 constant        entry                    external dcl 174 ref 1073 1136
backup_map_$error_line          000206 constant        entry                    external dcl 174 ref 641
backup_map_$fs_error_line       000210 constant        entry                    external dcl 174 ref 433 476 595 608 613 663 680 692
                                                                                  706 717 748 835 857 870 887 898 917 987 990 1009
                                                                                  1029 1038 1069 1077 1099 1102 1106 1110 1114 1204
                                                                                  1214
backup_map_$name_line           000174 constant        entry                    external dcl 174 ref 1245
backup_map_$on_line             000204 constant        entry                    external dcl 174 ref 785
backup_map_$terminal_line       000212 constant        entry                    external dcl 174 ref 539
backup_util$add_names           000214 constant        entry                    external dcl 174 ref 1016
backup_util$delete_name         000216 constant        entry                    external dcl 174 ref 924
backup_util$give_access         000220 constant        entry                    external dcl 174 ref 591 661
backup_util$idline              000222 constant        entry                    external dcl 174 ref 481
bc                              000111 automatic       fixed bin(17,0)          dcl 71 set ref 746*
bc_author                20     000635 automatic       char(32)                 level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 977*
bc_author                 1(05) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 976*
bc_author_code           30     000635 automatic       fixed bin(35,0)          level 2 dcl 4-18 set ref 1106 1106
bit                                                    builtin function         dcl 170 ref 562 768 1094 1095 1096 1097 1180
bitcnt                   64            based           fixed bin(24,0)          level 2 dcl 7-7 set ref 632 832*
bitcount_author         170            based           char(32)                 level 2 dcl 7-7 ref 977
bk_arg_reader_$reload_arg_reader
                                000256 constant        entry                    external dcl 174 ref 299
bk_input$input_finish           000362 constant        entry                    external dcl 256 ref 523
bk_input$input_init             000224 constant        entry                    external dcl 174 ref 474
bk_input$rd_tape                000226 constant        entry                    external dcl 174 ref 498 506 510 795 904
bk_nss_info                            based           structure                level 1 dcl 3-7
bk_retrieve$check_retrieval     000230 constant        entry                    external dcl 174 ref 570
bk_retrieve$flag_msf            000232 constant        entry                    external dcl 174 ref 632
bk_retrieve$parse_retrieval_control
                                000234 constant        entry                    external dcl 174 ref 454
bk_retrieve$parse_structure     000236 constant        entry                    external dcl 174 ref 452
bk_retrieve$report_retrieval    000240 constant        entry                    external dcl 174 ref 526
bk_ss_$allow_dir_overwrite      000400 external static bit(1)                   dcl 2-17 set ref 372*
bk_ss_$control_ptr              000402 external static pointer                  dcl 2-17 ref 363 369 370 371 372 373 374 375 376 378
                                                                                  393 394 396 398 399 402 403 403 406 407 408 409
                                                                                  414 672 676 830 836 840 928 930 932 1217
bk_ss_$data_iocb                000404 external static pointer                  dcl 2-17 set ref 374*
bk_ss_$date                     000406 external static fixed bin(52,0)          dcl 2-17 ref 567
bk_ss_$datesw                   000410 external static bit(1)                   dcl 2-17 ref 567
bk_ss_$debugsw                  000412 external static bit(1)                   dcl 2-17 set ref 306 364* 367* 428 460 530 601 846
                                                                                  866 894 960 975 1000 1088
bk_ss_$enforce_minimum_ring     000464 external static bit(1)                   dcl 2-17 set ref 393* 394 1058
bk_ss_$holdsw                   000414 external static bit(1)                   dcl 2-17 set ref 371*
bk_ss_$hp                       000416 external static pointer                  dcl 2-17 set ref 831*
bk_ss_$ignore_dates             000420 external static bit(1)                   dcl 2-17 ref 619
bk_ss_$mapsw                    000422 external static bit(1)                   dcl 2-17 set ref 369* 481 954 1136
bk_ss_$minimum_ring             000466 external static fixed bin(17,0)          dcl 2-17 set ref 394* 1059 1060 1061
bk_ss_$myname                   000424 external static char(16)                 packed unaligned dcl 2-17 set ref 291 291* 332* 418*
                                                                                  433 436* 467 467 542 542 542* 641*
bk_ss_$no_reload                000426 external static bit(1)                   dcl 2-17 set ref 370* 468 581 657 688 740 855 863
                                                                                  985 1007 1027 1035 1064 1088
bk_ss_$onlysw                   000430 external static bit(1)                   dcl 2-17 set ref 376*
bk_ss_$path_index               000432 external static fixed bin(17,0)          dcl 2-17 ref 672 676 830 836 840 928 930 932 1217
bk_ss_$preattached              000434 external static bit(1)                   dcl 2-17 set ref 373* 374
bk_ss_$pvname                   000440 external static char(32)                 dcl 2-17 ref 557
bk_ss_$pvsw                     000436 external static bit(1)                   dcl 2-17 ref 557
bk_ss_$qchecksw                 000442 external static bit(1)                   dcl 2-17 set ref 412* 463 468 533 668 678 874 903
                                                                                  906
bk_ss_$restore_access_class     000462 external static bit(1)                   dcl 2-17 set ref 378* 379 866 894
bk_ss_$retrieval_index          000444 external static fixed bin(17,0)          dcl 2-17 set ref 632*
bk_ss_$retrievesw               000446 external static bit(1)                   dcl 2-17 set ref 414* 416* 450 526 566 1083
bk_ss_$rname                    000450 external static char(168)                packed unaligned dcl 2-17 set ref 454* 481 481
bk_ss_$rsize                    000452 external static fixed bin(17,0)          dcl 2-17 set ref 454* 481 481
bk_ss_$source_attributes_ptr    000472 external static pointer                  dcl 2-17 set ref 398* 637*
bk_ss_$sub_entry                000454 external static bit(1)                   dcl 2-17 set ref 289* 348* 433 452 477 519 546 672
                                                                                  676 830 836 840 926 1216
bk_ss_$sub_entry_errfile        000456 external static bit(1)                   dcl 2-17 set ref 375*
bk_ss_$target_attributes_ptr    000474 external static pointer                  dcl 2-17 set ref 399* 637*
bk_ss_$translate_access_class   000470 external static bit(1)                   dcl 2-17 set ref 396* 397 636
bk_ss_$trimsw                   000460 external static bit(1)                   dcl 2-17 set ref 365* 676* 830*
bp                      100            based           bit(18)                  level 2 in structure "h" dcl 7-7 in procedure
                                                                                  "backup_load" ref 725
bp                              000134 automatic       pointer                  dcl 71 in procedure "backup_load" set ref 725* 726
                                                                                  727 744 949 950 951 952 1015 1046 1053 1054 1055
                                                                                  1064 1082 1086 1087
br                                     based           structure                array level 1 dcl 1-6
call_limiter                    000634 automatic       fixed bin(14,0)          dcl 268 set ref 997* 999* 1001 1003 1008*
ckcode                          001020 automatic       fixed bin(35,0)          dcl 1168 set ref 1174* 1175 1176* 1177
ckdir                           000736 automatic       char(168)                packed unaligned dcl 1166 set ref 1174* 1176*
ckent                           001010 automatic       char(32)                 packed unaligned dcl 1167 set ref 1174* 1176*
cleanup                         000426 stack reference condition                dcl 99 ref 338 356
clock                                                  builtin function         dcl 170 ref 487 538
code                            000331 automatic       fixed bin(35,0)          dcl 71 set ref 299* 301 302* 387 420* 424* 425* 429*
                                                                                  440* 445* 474* 475 476* 477 498* 499 499* 500 501
                                                                                  506* 510* 516 518 518* 519 539* 540* 541* 582* 585
                                                                                  585 588 590 590 591* 594 595* 601 601 603* 604 605
                                                                                  605 605 608* 613* 637* 639 641* 661* 662 663* 671*
                                                                                  677* 679 680* 690* 691 692* 705* 706 706* 715* 717
                                                                                  717* 746* 747 748 748 748* 795* 797 798 798* 799
                                                                                  832* 834 835* 856* 857 857* 866* 868* 869 870*
                                                                                  885* 887 887* 894* 896* 897 898* 904* 908 910 910*
                                                                                  911 916* 917 917* 920* 921 922 924* 925 938* 940
                                                                                  986* 987 987 987* 989* 990 990* 1008* 1009 1009
                                                                                  1009* 1024* 1028* 1029 1029 1029* 1036* 1038 1038
                                                                                  1038* 1064* 1067* 1069 1069 1069* 1077 1077* 1098*
                                                                                  1099 1099* 1213* 1214*
com_err_                        000364 constant        entry                    external dcl 256 ref 302 332 436
control_ptr                            parameter       pointer                  dcl 71 set ref 345 351* 360* 548*
convert_aim_attributes_         000242 constant        entry                    external dcl 174 ref 640
cu_$arg_count                   000244 constant        entry                    external dcl 174 ref 296
cu_$arg_list_ptr                000246 constant        entry                    external dcl 174 ref 298
cu_$level_get                   000250 constant        entry                    external dcl 174 ref 699 1176 1176
data_iocb                 6            based           pointer                  level 3 dcl 6-8 ref 374
date_time_                      000260 constant        entry                    external dcl 174 ref 782
debug_sw                 36(01)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 363
delete_acl_entry                       based           structure                level 1 dcl 9-63
dia_count                30     000542 automatic       fixed bin(17,0)          array level 2 dcl 132 set ref 695* 710
dir_inaclc              160            based           fixed bin(17,0)          array level 2 dcl 7-7 set ref 710 715*
dir_inaclp              150            based           bit(18)                  array level 2 dcl 7-7 ref 713
dir_priv_code                   000330 automatic       fixed bin(35,0)          dcl 71 set ref 354* 358 385* 386 386 547
directory_acl_entry                    based           structure                level 1 dcl 9-54
dirname_dirname                 000342 automatic       char(168)                packed unaligned dcl 71 set ref 659* 661
dirname_ename                   000414 automatic       char(32)                 packed unaligned dcl 71 set ref 659* 661
dirsw                    14            based           bit(1)                   array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  1064
divide                                                 builtin function         dcl 170 ref 954 954
dlen                                   based           fixed bin(17,0)          level 2 dcl 7-7 set ref 1127 1136* 1171 1174 1174
                                                                                  1183
dname                     1            based           char(168)                level 2 dcl 7-7 set ref 582* 591* 595* 603* 608*
                                                                                  613* 641 641 659 663* 680* 690* 692* 705* 706*
                                                                                  715* 717* 746* 748* 783* 832* 835* 856 857* 866*
                                                                                  868* 870* 887* 894* 896* 898* 917* 920* 924* 938*
                                                                                  986* 987* 989 990* 1008* 1009* 1016* 1028* 1029*
                                                                                  1036* 1038* 1064* 1067* 1069* 1072* 1077* 1098*
                                                                                  1099* 1102* 1106* 1110* 1114* 1126 1127 1136 1136
                                                                                  1171 1174 1174 1183 1202* 1203* 1204* 1214*
dtbm                     10(20)        based           bit(52)                  array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  951 1082
dtd                      66            based           fixed bin(52,0)          level 2 in structure "h" dcl 7-7 in procedure
                                                                                  "backup_load" ref 561
dtd                       1(09) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1092*
dtd                             000116 automatic       fixed bin(52,0)          dcl 71 in procedure "backup_load" set ref 949* 954*
dtd                       2     000700 automatic       fixed bin(52,0)          level 2 in structure "times" dcl 5-4 in procedure
                                                                                  "backup_load" set ref 1083* 1085* 1095
dtd                       6(20)        based           bit(52)                  array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 1-6 in procedure "backup_load" ref
                                                                                  949
dtd                      36     000635 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1095*
dtd_test                        000112 automatic       bit(36)                  dcl 71 set ref 562* 619 619
dtem                      1(08) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1092*
dtem                            000122 automatic       fixed bin(52,0)          dcl 71 in procedure "backup_load" set ref 951* 954*
dtem                      5     000530 automatic       bit(36)                  level 2 in structure "status" packed packed
                                                                                  unaligned dcl 109 in procedure "backup_load" set
                                                                                  ref 619
dtem                            000700 automatic       fixed bin(52,0)          level 2 in structure "times" dcl 5-4 in procedure
                                                                                  "backup_load" set ref 1082* 1094
dtem                     35     000635 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1094*
dtm                       1(11) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1092*
dtm                       4(20)        based           bit(52)                  array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 1-6 in procedure "backup_load" ref
                                                                                  952 1087
dtm                       1     000530 automatic       bit(36)                  level 2 in structure "status" packed packed
                                                                                  unaligned dcl 109 in procedure "backup_load" set
                                                                                  ref 619
dtm                      40     000635 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1097*
dtm                       6     000700 automatic       fixed bin(52,0)          level 2 in structure "times" dcl 5-4 in procedure
                                                                                  "backup_load" set ref 1087* 1097
dtp                             000114 automatic       fixed bin(52,0)          dcl 71 set ref 487* 488* 538* 539* 561* 562 567 782*
                                                                                  954* 1083
dtsm                            000124 automatic       fixed bin(52,0)          dcl 71 set ref 952* 954*
dtu                             000120 automatic       fixed bin(52,0)          dcl 71 in procedure "backup_load" set ref 950* 954*
dtu                       1(10) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1092*
dtu                       2(20)        based           bit(52)                  array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 1-6 in procedure "backup_load" ref
                                                                                  950 1086
dtu                      37     000635 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1096*
dtu                       4     000700 automatic       fixed bin(52,0)          level 2 in structure "times" dcl 5-4 in procedure
                                                                                  "backup_load" set ref 1086* 1096
dump_date                       000142 automatic       char(24)                 packed unaligned dcl 71 set ref 782* 783*
dumper_id                70            based           char(32)                 level 2 dcl 7-7 set ref 783*
effmode                         001021 automatic       fixed bin(5,0)           dcl 1169 set ref 1176* 1180
elen                     53            based           fixed bin(17,0)          level 2 dcl 7-7 set ref 768 772* 806 809* 946*
ename                    54            based           char(32)                 level 2 dcl 7-7 set ref 582* 591* 595* 603* 608*
                                                                                  613* 641 641 770 774* 783* 805 807* 832* 835* 856
                                                                                  857* 866* 868* 870* 887* 894* 896* 898* 917* 920*
                                                                                  920* 938* 938* 945* 954* 986* 987* 989 990* 1008*
                                                                                  1009* 1016* 1028* 1029* 1036* 1038* 1064* 1067*
                                                                                  1069* 1072* 1077* 1098* 1099* 1102* 1106* 1110*
                                                                                  1114* 1202* 1203* 1204* 1214*
enforce_minimum_ring     36(13)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 393
entry_bound              33     000635 automatic       fixed bin(14,0)          level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1003*
entry_bound               1(07) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1002*
entry_bound_code         34     000635 automatic       fixed bin(35,0)          level 2 dcl 4-18 set ref 1114 1114
entrypt_bound           121(22)        based           bit(14)                  level 2 packed packed unaligned dcl 7-7 ref 999
entrypt_sw              121(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-7 ref 997
error_file               36(05)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 375
error_name              170            based           char(65)                 array level 3 packed packed unaligned dcl 6-8 set
                                                                                  ref 409* 930*
error_table_$incorrect_access   000152 external static fixed bin(35,0)          dcl 151 ref 590 605 987 1009 1029 1038 1069 1077
error_table_$moderr             000142 external static fixed bin(35,0)          dcl 151 set ref 332* 382 590 605
error_table_$namedup            000132 external static fixed bin(35,0)          dcl 151 ref 922 928
error_table_$no_dir             000144 external static fixed bin(35,0)          dcl 151 ref 588 748
error_table_$no_e_permission    000150 external static fixed bin(35,0)          dcl 151 set ref 433* 436*
error_table_$no_info            000146 external static fixed bin(35,0)          dcl 151 ref 605
error_table_$noentry            000134 external static fixed bin(35,0)          dcl 151 ref 585 748
error_table_$pvid_not_found     000136 external static fixed bin(35,0)          dcl 151 ref 601
error_table_$rqover             000154 external static fixed bin(35,0)          dcl 151 ref 671 1213
error_table_$vtoce_connection_fail
                                000140 external static fixed bin(35,0)          dcl 151 ref 601
expand_pathname_                000264 constant        entry                    external dcl 174 ref 659 1174
first                    36(06)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 376
fixed                                                  builtin function         dcl 170 ref 727 744 772 949 950 951 952 999 1015
                                                                                  1053 1054 1055 1082 1086 1087
found                   165            based           bit(1)                   array level 3 dcl 6-8 set ref 406*
general_acl_entry                      based           structure                level 1 unaligned dcl 9-12
general_delete_acl_entry               based           structure                level 1 dcl 9-35
general_extended_acl_entry             based           structure                level 1 dcl 9-23
h                                      based           structure                level 1 dcl 7-7
hcnt                            000102 automatic       fixed bin(17,0)          dcl 71 set ref 506* 510*
hcs_$chname_file                000300 constant        entry                    external dcl 214 ref 920 938
hcs_$delentry_file              000476 constant        entry                    external dcl 1199 ref 1203
hcs_$fs_get_path_name           000310 constant        entry                    external dcl 214 ref 429
hcs_$get_user_effmode           000334 constant        entry                    external dcl 214 ref 1176
hcs_$initiate                   000344 constant        entry                    external dcl 214 ref 866 894
hcs_$list_inacl_all             000302 constant        entry                    external dcl 214 ref 690
hcs_$make_seg                   000276 constant        entry                    external dcl 214 ref 424 425
hcs_$proc_info                  000254 constant        entry                    external dcl 174 ref 472
hcs_$replace_acl                000316 constant        entry                    external dcl 214 ref 1028
hcs_$replace_dir_acl            000320 constant        entry                    external dcl 214 ref 1036
hcs_$replace_dir_inacl          000324 constant        entry                    external dcl 214 ref 715
hcs_$replace_inacl              000322 constant        entry                    external dcl 214 ref 705
hcs_$set_256K_switch            000252 constant        entry                    external dcl 174 ref 340 359 420 544
hcs_$set_copysw                 000272 constant        entry                    external dcl 214 ref 1202
hcs_$set_dir_ring_brackets      000330 constant        entry                    external dcl 214 ref 1064
hcs_$set_entry_bound            000274 constant        entry                    external dcl 214 ref 1008
hcs_$set_max_length             000304 constant        entry                    external dcl 214 ref 856
hcs_$set_max_length_seg         000312 constant        entry                    external dcl 214 ref 445
hcs_$set_ring_brackets          000326 constant        entry                    external dcl 214 ref 1067
hcs_$set_safety_sw              000314 constant        entry                    external dcl 214 ref 986
hcs_$status_long                000336 constant        entry                    external dcl 214 ref 582
hcs_$status_minf                000332 constant        entry                    external dcl 214 ref 746
hcs_$terminate_noname           000340 constant        entry                    external dcl 214 ref 885 916
hcs_$truncate_seg               000342 constant        entry                    external dcl 214 ref 501 540 541
header                                 based           structure                level 2 dcl 6-8
hold_sw                  36(03)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 371
hp                              000126 internal static pointer                  dcl 143 set ref 424* 452* 454* 506* 510* 540* 555
                                                                                  555 557 557 557 557 560 561 582 582 591 591 595
                                                                                  595 603 603 608 608 613 613 632 637 640 641 641
                                                                                  641 641 645 659 663 677* 680 690 692 700 701 703
                                                                                  703 705 705 706 710 711 713 713 715 715 717 725
                                                                                  725 726 746 748 768 770 772 774 783 783 783 805
                                                                                  806 807 809 814 818 822 831 832 832 832 835 835
                                                                                  847 852 856 856 856 857 857 866 866 868 868 870
                                                                                  870 887 887 894 894 896 896 898 898 917 917 920
                                                                                  920 920 924 938 938 938 945 946 954 967 977 979
                                                                                  981 986 986 986 987 987 989 989 989 990 990 997
                                                                                  999 1008 1008 1009 1009 1016 1016 1021 1023 1023
                                                                                  1028 1028 1028 1029 1029 1036 1036 1036 1038 1038
                                                                                  1064 1064 1067 1067 1069 1069 1072 1072 1077 1077
                                                                                  1091 1098 1098 1099 1099 1102 1102 1106 1106 1110
                                                                                  1110 1114 1114 1126 1127 1127 1136 1136 1136 1171
                                                                                  1171 1174 1174 1174 1174 1183 1183 1202 1202 1203
                                                                                  1203 1204 1204 1214 1214
hphcs_$delentry_file            000270 constant        entry                    external dcl 214 ref 320 603
hphcs_$fs_get_trans_sw          000376 constant        entry                    external dcl 265 ref 465 535
hphcs_$restore_quota            000374 constant        entry                    external dcl 256 ref 533
hphcs_$set_for_reloader         000266 constant        entry                    external dcl 214 ref 1098
hphcs_$suspend_quota            000372 constant        entry                    external dcl 256 ref 463
hphcs_sw                        000606 automatic       bit(1)                   initial packed unaligned dcl 147 set ref 147* 307*
                                                                                  317* 330 332*
hs_bit                          000315 automatic       bit(1)                   initial packed unaligned dcl 71 set ref 71* 1171
                                                                                  1180* 1182* 1187
hs_dirname                      000242 automatic       varying char(168)        initial dcl 71 set ref 71* 1171 1183*
htype                           000105 automatic       fixed bin(17,0)          dcl 71 set ref 560* 575 632 632 632 648 657 688 732
                                                                                  732 738 738 783* 813 813 817 845 845 954 960 960
                                                                                  960 960 974 974 974 974 996 1026 1026 1034 1034
i                               000100 automatic       fixed bin(17,0)          dcl 71 set ref 296* 297 402* 403 403 406 407 408*
                                                                                  744* 745 763* 1015* 1016 1016* 1047* 1051* 1071
inacl_info                      000542 automatic       structure                level 1 dcl 132 set ref 689* 690 690
inaclc                  140            based           fixed bin(17,0)          array level 2 dcl 7-7 set ref 700 701 705* 711
inaclp                  130            based           bit(18)                  array level 2 dcl 7-7 ref 703
ioa_$rs                         000370 constant        entry                    external dcl 256 ref 783 1072
ioa_$rsnnl                      000366 constant        entry                    external dcl 256 ref 1244
ix                              000140 automatic       pointer                  dcl 71 set ref 745* 746 748 764 766 768 770
label_index                     000442 automatic       fixed bin(17,0)          dcl 101 set ref 452* 454* 457 570* 571
line                            000011 internal static char(300)                packed unaligned dcl 143 set ref 446 783* 1072*
line_pointer                    000124 internal static pointer                  dcl 143 set ref 446* 481* 488* 785* 1073*
linkage_error                   000622 stack reference condition                dcl 168 ref 308 314 321 328 380 390 431 442
loaded                  166            based           bit(1)                   array level 3 dcl 6-8 set ref 407* 672* 836* 840*
                                                                                  932* 1217*
map_sw                   36            based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 369
max                                                    builtin function         dcl 170 ref 1059 1060 1061
max_length               31     000635 automatic       fixed bin(19,0)          level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 852*
max_length                1(06) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 851*
max_length              120            based           fixed bin(18,0)          level 2 in structure "h" dcl 7-7 in procedure
                                                                                  "backup_load" ref 847 852 856
max_length_code          32     000635 automatic       fixed bin(35,0)          level 2 dcl 4-18 set ref 1110 1110
min                                                    builtin function         dcl 170 ref 809
minimum_ring             31            based           fixed bin(17,0)          level 3 dcl 6-8 ref 394
mover                                  based           fixed bin(17,0)          array dcl 267 set ref 877* 877 882* 882
multiple_class          121(04)        based           bit(1)                   level 3 packed packed unaligned dcl 7-7 ref 818 822
n                               000101 automatic       fixed bin(17,0)          dcl 71 set ref 480* 481* 488* 783* 785* 1072* 1073*
name                                   based           structure                array level 1 dcl 1-25 set ref 745
namerp                   21(18)        based           bit(18)                  array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  726
ndc_directory                          constant        fixed bin(17,0)          initial dcl 8-20 ref 632 738 960 974 1034
ndc_directory_list                     constant        fixed bin(17,0)          initial dcl 8-22 ref 575 632 648 657 688
ndc_segment                            constant        fixed bin(17,0)          initial dcl 8-18 ref 732 845 960 974 1026
new_dir                         000224 automatic       bit(1)                   initial dcl 71 set ref 71* 1128* 1135 1137*
new_path                112            based           char(168)                array level 3 packed packed unaligned dcl 6-8 set
                                                                                  ref 403 403*
nnames                   22(19)        based           bit(17)                  array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  744 1015
no_reload_sw             36(02)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 370
np                              000126 automatic       pointer                  dcl 71 set ref 726* 745 764 766 772 774 1016*
nss_info_relp           126            based           bit(18)                  level 2 dcl 7-7 ref 557 557
null                                                   builtin function         dcl 170 ref 498 498 510 510 582 582 690 690 690 690
                                                                                  701 711 795 795 904 904 1021
octal_string                    000332 automatic       char(32)                 dcl 71 set ref 640* 641*
old_256K_switch                 000424 automatic       bit(2)                   dcl 97 set ref 337* 340* 355* 359* 420* 544*
old_dname                       000151 automatic       varying char(168)        initial dcl 71 set ref 71* 1126 1127*
old_trans_sw                    000106 automatic       fixed bin(2,0)           dcl 71 set ref 465* 535*
options                  36            based           structure                level 3 dcl 6-8
optionsw                 14(01)        based           bit(2)                   array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 1-6 in procedure "backup_load" ref
                                                                                  727
optionsw                        000225 automatic       fixed bin(2,0)           dcl 71 in procedure "backup_load" set ref 654* 727*
                                                                                  832*
pathname_                       000346 constant        entry                    external dcl 214 ref 641 641
phcs_$set_max_length            000306 constant        entry                    external dcl 214 ref 313 440
phcs_sw                         000605 automatic       bit(1)                   initial packed unaligned dcl 147 set ref 147* 307*
                                                                                  310* 330 332*
pointer                                                builtin function         dcl 170 ref 557 703 713 725 726 1023
preattached              36(04)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 373
pvname                   11            based           char(32)                 level 2 dcl 3-7 ref 557
quota                   110            based           fixed bin(17,0)          level 2 dcl 7-7 set ref 967
rb1                      20            based           bit(6)                   array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  1046 1053
rb2                      20(06)        based           bit(6)                   array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  1054
rb3                      20(12)        based           bit(6)                   array level 2 packed packed unaligned dcl 1-6 ref
                                                                                  1055
record_quota_overflow           000434 stack reference condition                dcl 99 ref 668 678 876 879 903 906
record_type              65            based           fixed bin(17,0)          level 2 dcl 7-7 ref 560
reload_init                     000010 internal static bit(1)                   initial packed unaligned dcl 141 set ref 423 447*
reload_set_info                 000635 automatic       structure                level 1 dcl 4-18 set ref 842* 1098 1098
reload_set_version_2                   constant        fixed bin(17,0)          initial dcl 4-16 ref 843
request_count            37            based           fixed bin(17,0)          level 3 dcl 6-8 ref 402 409 414
requests                 40            based           structure                array level 2 dcl 6-8
restore_access_class     36(12)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 378
ring                            000150 automatic       fixed bin(3,0)           dcl 71 set ref 693* 694 695* 699* 700 700 701 703
                                                                                  705 705* 710 710 711 713 715 715*
rings                                  parameter       fixed bin(3,0)           array dcl 1242 in procedure "printers" set ref 1239
                                                                                  1244*
rings                           000602 automatic       fixed bin(3,0)           array dcl 139 in procedure "backup_load" set ref
                                                                                  1048* 1048* 1048* 1053* 1054* 1055* 1059* 1059
                                                                                  1060* 1060 1061* 1061 1064* 1067* 1068*
safety_sw                 1     000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 978*
safety_sw                 3     000635 automatic       bit(1)                   level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 979*
safety_sw               121            based           bit(1)                   level 3 in structure "h" packed packed unaligned
                                                                                  dcl 7-7 in procedure "backup_load" ref 979 986
save_elen                       000236 automatic       fixed bin(17,0)          dcl 71 set ref 806* 809 946
save_ename                      000226 automatic       char(32)                 dcl 71 set ref 805* 807 920* 924* 938* 945
scnt                            000103 automatic       fixed bin(17,0)          dcl 71 set ref 498* 506* 510* 512 795* 863 877 882
                                                                                  904* 954 954
sec_dir                                constant        fixed bin(17,0)          initial dcl 8-26 ref 632 738 813 960 974 1034
sec_seg                                constant        fixed bin(17,0)          initial dcl 8-24 ref 732 813 817 845 960 974 996
                                                                                  1026
seg_buff                        000130 internal static pointer                  dcl 143 set ref 425* 429* 445* 498* 501* 506* 541*
                                                                                  795* 877 882
segment_acl_entry                      based           structure                level 1 dcl 9-45
segptr                          000132 automatic       pointer                  dcl 71 set ref 866* 868* 877 882 885* 894* 896* 904*
                                                                                  916*
should_set                1     000635 automatic       structure                level 2 dcl 4-18
sia_count                10     000542 automatic       fixed bin(17,0)          array level 2 dcl 132 set ref 694* 700
size                                   based           bit(17)                  array level 2 dcl 1-25 set ref 764* 764 768* 772
source_attributes_ptr
                         32            based           pointer                  level 4 dcl 6-8 ref 398
status                          000530 automatic       structure                level 1 dcl 109 set ref 485
status_code             167            based           fixed bin(35,0)          array level 3 dcl 6-8 set ref 408* 928*
status_version          125            based           fixed bin(17,0)          level 2 dcl 7-7 set ref 555 555* 557
stptr                           000526 automatic       pointer                  dcl 108 set ref 485* 582*
string                    1            based           char(32)                 array level 2 dcl 1-25 set ref 746* 748* 766* 766
                                                                                  770* 774
substr                                                 builtin function         dcl 170 ref 481 481 562 807 1094 1095 1096 1097 1127
                                                                                  1171 1174 1174 1183
switches                164            based           structure                array level 3 in structure "backup_control" dcl 6-8
                                                                                  in procedure "backup_load"
switches                121            based           structure                level 2 in structure "h" packed packed unaligned
                                                                                  dcl 7-7 in procedure "backup_load"
sys_info$access_class_ceiling   000156 external static bit(72)                  dcl 164 ref 815
sys_info$default_max_length     000160 external static fixed bin(35,0)          dcl 165 ref 847
sys_info$seg_size_256K          000162 external static fixed bin(19,0)          dcl 166 set ref 440* 445*
sys_type                        000107 automatic       fixed bin(2,0)           dcl 71 set ref 746* 756
system_priv_sw                  000607 automatic       bit(1)                   initial packed unaligned dcl 147 set ref 147* 324*
                                                                                  330 332*
system_privilege_$dir_priv_off  000350 constant        entry                    external dcl 214 ref 358 547
system_privilege_$dir_priv_on   000352 constant        entry                    external dcl 214 ref 385
system_privilege_$initiate      000354 constant        entry                    external dcl 214 ref 327 868 896
system_privilege_$set_entry_audit_switch
                                000356 constant        entry                    external dcl 214 ref 989
target_attributes_ptr
                         34            based           pointer                  level 4 dcl 6-8 ref 399
temp_dir                        000443 automatic       char(168)                dcl 103 set ref 429* 440*
temp_entry                      000515 automatic       char(32)                 dcl 103 set ref 429* 440*
temp_length                     000525 automatic       fixed bin(17,0)          dcl 103 set ref 429*
test_entry                      000630 automatic       entry variable           dcl 172 set ref 313* 320* 327*
text                            001030 automatic       char(168)                packed unaligned dcl 1231 in procedure "printers"
                                                                                  set ref 1244* 1245 1245
text                            000610 automatic       varying char(32)         dcl 149 in procedure "backup_load" set ref 331*
text_l                          001102 automatic       fixed bin(21,0)          dcl 1232 set ref 1244* 1245*
times                           000700 automatic       structure                level 1 unaligned dcl 5-4
tpd                       1(12) 000635 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure "backup_load" set
                                                                                  ref 1090*
tpd                     121(08)        based           bit(1)                   level 3 in structure "h" packed packed unaligned
                                                                                  dcl 7-7 in procedure "backup_load" ref 1091
tpd                      41     000635 automatic       bit(1)                   level 2 in structure "reload_set_info" dcl 4-18
                                                                                  in procedure "backup_load" set ref 1091*
translate_access_class
                         36(14)        based           bit(1)                   level 4 packed packed unaligned dcl 6-8 ref 396
translate_aim_attributes_       000360 constant        entry                    external dcl 214 ref 637
trim_sw                 164(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 6-8 ref
                                                                                  676 830
ts                              000110 automatic       fixed bin(2,0)           dcl 71 set ref 535*
type                            000104 automatic       fixed bin(17,0)          dcl 71 set ref 628* 652* 742* 818* 822* 832*
uccode                          000100 automatic       fixed bin(35,0)          dcl 1200 set ref 1202* 1203* 1204 1204*
unique_chars_                   000262 constant        entry                    external dcl 174 ref 807
unspec                                                 builtin function         dcl 170 set ref 689* 842*
verify                                                 builtin function         dcl 170 ref 403
version                         000635 automatic       fixed bin(17,0)          level 2 dcl 4-18 set ref 843*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 9-77
BACKUP_CONTROL_VERSION_5               internal static char(8)                  initial packed unaligned dcl 6-60
DELETE_ACL_VERSION_1                   internal static char(4)                  initial packed unaligned dcl 9-67
DIR_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 9-67
GENERAL_ACL_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 9-72
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial packed unaligned dcl 9-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial packed unaligned dcl 9-72
SEG_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 9-67
acl_count                              automatic       fixed bin(17,0)          dcl 9-5
acl_ptr                                automatic       pointer                  dcl 9-4
backup_control_ptr                     automatic       pointer                  dcl 6-56
backup_control_request_count           automatic       fixed bin(17,0)          dcl 6-58
bk_dq_info                             based           structure                level 1 dcl 3-15
bk_ss_$areap                           external static pointer                  dcl 2-17
bk_ss_$brief_mapsw                     external static bit(1)                   dcl 2-17
bk_ss_$caller_handles_conditions       external static bit(1)                   dcl 2-17
bk_ss_$check_effective_access          external static bit(1)                   dcl 2-17
bk_ss_$control_name                    external static char(168)                packed unaligned dcl 2-17
bk_ss_$cross_retrievesw                external static bit(1)                   dcl 2-17
bk_ss_$dir_trim                        external static bit(1)                   dcl 2-17
bk_ss_$dont_dump_upgraded_dirs         external static bit(1)                   dcl 2-17
bk_ss_$dprint_destination              external static char(24)                 packed unaligned dcl 2-17
bk_ss_$dprint_destination_setsw        external static bit(1)                   dcl 2-17
bk_ss_$dprint_heading                  external static char(64)                 packed unaligned dcl 2-17
bk_ss_$dprint_heading_setsw            external static bit(1)                   dcl 2-17
bk_ss_$dprint_queue                    external static fixed bin(17,0)          dcl 2-17
bk_ss_$dprint_request_type             external static char(24)                 packed unaligned dcl 2-17
bk_ss_$dprint_request_type_setsw       external static bit(1)                   dcl 2-17
bk_ss_$dprintsw                        external static bit(1)                   dcl 2-17
bk_ss_$dtdsw                           external static bit(1)                   dcl 2-17
bk_ss_$ename                           external static char(32)                 dcl 2-17
bk_ss_$enforce_max_access_class        external static bit(1)                   dcl 2-17
bk_ss_$enforce_min_access_class        external static bit(1)                   dcl 2-17
bk_ss_$err_label                       external static label variable           dcl 2-17
bk_ss_$err_onlinesw                    external static bit(1)                   dcl 2-17
bk_ss_$error                           external static fixed bin(17,0)          dcl 2-17
bk_ss_$maximum_access_class            external static bit(72)                  dcl 2-17
bk_ss_$maximum_dir_access_class        external static bit(72)                  dcl 2-17
bk_ss_$minimum_access_class            external static bit(72)                  dcl 2-17
bk_ss_$namesw                          external static bit(1)                   dcl 2-17
bk_ss_$no_contin                       external static bit(1)                   dcl 2-17
bk_ss_$no_output                       external static bit(1)                   dcl 2-17
bk_ss_$no_primary                      external static bit(1)                   dcl 2-17
bk_ss_$no_setlvid                      external static bit(1)                   dcl 2-17
bk_ss_$ntapes                          external static fixed bin(17,0)          dcl 2-17
bk_ss_$operator                        external static char(32)                 packed unaligned dcl 2-17
bk_ss_$pathsw                          external static bit(1)                   dcl 2-17
bk_ss_$quotasw                         external static bit(1)                   dcl 2-17
bk_ss_$restart_dumpsw                  external static bit(1)                   dcl 2-17
bk_ss_$restart_path                    external static char(168)                dcl 2-17
bk_ss_$restart_plen                    external static fixed bin(17,0)          dcl 2-17
bk_ss_$rlen                            external static fixed bin(17,0)          dcl 2-17
bk_ss_$save_path                       external static char(168)                packed unaligned dcl 2-17
bk_ss_$save_plen                       external static fixed bin(17,0)          dcl 2-17
bk_ss_$save_time                       external static fixed bin(52,0)          dcl 2-17
bk_ss_$segptr                          external static pointer                  dcl 2-17
bk_ss_$set_dtd                         external static bit(1)                   dcl 2-17
bk_ss_$set_dtd_explicit                external static bit(1)                   dcl 2-17
bk_ss_$sp                              external static pointer                  dcl 2-17
bk_ss_$tapesw                          external static bit(1)                   dcl 2-17
bk_ss_$upgrade_to_user_auth            external static bit(1)                   dcl 2-17
bk_ss_$user_authorization              external static bit(72)                  dcl 2-17
bk_ss_$user_id                         external static char(32)                 packed unaligned dcl 2-17
bk_ss_$user_ring                       external static fixed bin(17,0)          dcl 2-17
bk_ss_$volume_set_name                 external static char(32)                 packed unaligned dcl 2-17
bk_ss_$wakeup_interval                 external static fixed bin(52,0)          dcl 2-17
bk_ss_$wasnt_known                     external static bit(1)                   dcl 2-17
bk_ss_$writing_map                     external static bit(1)                   dcl 2-17
delete_acl                             based           structure                level 1 dcl 9-58
delete_acl_array                       based           structure                array level 1 dcl 9-64
directory_acl                          based           structure                level 1 dcl 9-49
directory_acl_array                    based           structure                array level 1 dcl 9-55
general_acl                            based           structure                level 1 dcl 9-7
general_delete_acl                     based           structure                level 1 dcl 9-30
general_extended_acl                   based           structure                level 1 dcl 9-18
lk                                     based           structure                array level 1 dcl 1-29
nnames                                 automatic       fixed bin(17,0)          dcl 1-23
old_path                               based           structure                level 1 dcl 1-42
path                                   based           structure                level 1 dcl 1-37
pp                                     automatic       pointer                  dcl 71
segment_acl                            based           structure                level 1 dcl 9-40
segment_acl_array                      based           structure                array level 1 dcl 9-46

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_FOR_NEW_DIRECTORY         010006 constant        entry                    internal dcl 1124 ref 564
COMMON                          001603 constant        label                    dcl 420 ref 342
HAVE_SMA                        010054 constant        entry                    internal dcl 1144 ref 657 794
PRINT_HEADER                    010031 constant        entry                    internal dcl 1133 ref 655 953
RETURN                          002674 constant        label                    dcl 544 ref 334 383 388 438
TAPE_DONE                       002543 constant        label                    dcl 516 ref 500 801 911
TRY2                            001023 constant        label                    dcl 314 ref 311
TRY3                            001052 constant        label                    dcl 321 ref 318
TRY4                            001101 constant        label                    dcl 328 ref 325
UNCREATE                        010242 constant        entry                    internal dcl 1196 ref 673 900 909 934 1215
backup_load                     000661 constant        entry                    external dcl 68
backup_load_                    001214 constant        entry                    external dcl 345
checked                         003304 constant        label                    dcl 628 ref 575 585 588 604
do_directory                    004355 constant        label                    dcl 740
do_directory_list               003461 constant        label                    dcl 652
get_dates                       003023 constant        label                    dcl 582 ref 594
give_acc                        003076 constant        label                    dcl 591 ref 605
handle_rqo                      010360 constant        entry                    internal dcl 1209 ref 876 903
load_it                         004633 constant        label                    dcl 792 ref 732 740 777 780
loc_label                       000000 constant        label                    array(6) dcl 460 ref 457 571
next                            002424 constant        label                    dcl 495 ref 557 567 597 609 614 619 643 664 682 723
                                                                                  786 799 837 871 901 913 935 1120 1218 1220
no_dir                          003704 constant        label                    dcl 680 ref 674
parsed                          002167 constant        label                    dcl 460
print_rbs                       010447 constant        entry                    internal dcl 1239 ref 1068
printers                        010445 constant        entry                    internal dcl 1228
reported                        002572 constant        label                    dcl 530
set_ac                          004776 constant        label                    dcl 827 ref 815
set_rb                          007147 constant        label                    dcl 1051 ref 1031 1040
start                           002134 constant        label                    dcl 450
stop                            002556 constant        label                    dcl 523
terminate                       002563 constant        label                    dcl 526 ref 478
uncreate                        006137 constant        label                    dcl 926 ref 922 940

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12346       13046   10532       12356
Length     14066   10532       500        1004    1613         122

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
backup_load                         836 external procedure  is an external procedure.  
on unit on line 308                  64 on unit               
on unit on line 314                  64 on unit               
on unit on line 321                  64 on unit               
on unit on line 338                  74 on unit               
on unit on line 356                  78 on unit               
on unit on line 380                  64 on unit               
on unit on line 431                 108 on unit               
on unit on line 668                  64 on unit               
on unit on line 876                  64 on unit               
on unit on line 903                  64 on unit               
CHECK_FOR_NEW_DIRECTORY                 internal procedure  shares stack frame of external procedure backup_load.  
PRINT_HEADER                            internal procedure  shares stack frame of external procedure backup_load.  
HAVE_SMA                                internal procedure  shares stack frame of external procedure backup_load.  
UNCREATE                            102 internal procedure  is called by several nonquick procedures.  
handle_rqo                           86 internal procedure  is called by several nonquick procedures.  
printers                                internal procedure  shares stack frame of external procedure backup_load.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 reload_init                 backup_load
000011 line                        backup_load
000124 line_pointer                backup_load
000126 hp                          backup_load
000130 seg_buff                    backup_load

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
UNCREATE                 000100 uccode                      UNCREATE
backup_load              000100 i                           backup_load
                         000101 n                           backup_load
                         000102 hcnt                        backup_load
                         000103 scnt                        backup_load
                         000104 type                        backup_load
                         000105 htype                       backup_load
                         000106 old_trans_sw                backup_load
                         000107 sys_type                    backup_load
                         000110 ts                          backup_load
                         000111 bc                          backup_load
                         000112 dtd_test                    backup_load
                         000114 dtp                         backup_load
                         000116 dtd                         backup_load
                         000120 dtu                         backup_load
                         000122 dtem                        backup_load
                         000124 dtsm                        backup_load
                         000126 np                          backup_load
                         000130 ap                          backup_load
                         000132 segptr                      backup_load
                         000134 bp                          backup_load
                         000136 aclp                        backup_load
                         000140 ix                          backup_load
                         000142 dump_date                   backup_load
                         000150 ring                        backup_load
                         000151 old_dname                   backup_load
                         000224 new_dir                     backup_load
                         000225 optionsw                    backup_load
                         000226 save_ename                  backup_load
                         000236 save_elen                   backup_load
                         000237 MRS                         backup_load
                         000240 FRS                         backup_load
                         000241 INITIALIZER                 backup_load
                         000242 hs_dirname                  backup_load
                         000315 hs_bit                      backup_load
                         000316 USERID                      backup_load
                         000326 access_class                backup_load
                         000330 dir_priv_code               backup_load
                         000331 code                        backup_load
                         000332 octal_string                backup_load
                         000342 dirname_dirname             backup_load
                         000414 dirname_ename               backup_load
                         000424 old_256K_switch             backup_load
                         000442 label_index                 backup_load
                         000443 temp_dir                    backup_load
                         000515 temp_entry                  backup_load
                         000525 temp_length                 backup_load
                         000526 stptr                       backup_load
                         000530 status                      backup_load
                         000542 inacl_info                  backup_load
                         000602 rings                       backup_load
                         000605 phcs_sw                     backup_load
                         000606 hphcs_sw                    backup_load
                         000607 system_priv_sw              backup_load
                         000610 text                        backup_load
                         000630 test_entry                  backup_load
                         000634 call_limiter                backup_load
                         000635 reload_set_info             backup_load
                         000700 times                       backup_load
                         000736 ckdir                       HAVE_SMA
                         001010 ckent                       HAVE_SMA
                         001020 ckcode                      HAVE_SMA
                         001021 effmode                     HAVE_SMA
                         001030 text                        printers
                         001102 text_l                      printers

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
backup_control_mgr_$initiate  backup_control_mgr_$terminate backup_load_dir_list
backup_load_dir_list$build_tree                             backup_map_$beginning_line    backup_map_$detail_line2
backup_map_$directory_line    backup_map_$error_line        backup_map_$fs_error_line     backup_map_$name_line
backup_map_$on_line           backup_map_$terminal_line     backup_util$add_names         backup_util$delete_name
backup_util$give_access       backup_util$idline            bk_arg_reader_$reload_arg_reader
bk_input$input_finish         bk_input$input_init           bk_input$rd_tape              bk_retrieve$check_retrieval
bk_retrieve$flag_msf          bk_retrieve$parse_retrieval_control                         bk_retrieve$parse_structure
bk_retrieve$report_retrieval  com_err_                      convert_aim_attributes_       cu_$arg_count
cu_$arg_list_ptr              cu_$level_get                 date_time_                    expand_pathname_
hcs_$chname_file              hcs_$delentry_file            hcs_$fs_get_path_name         hcs_$get_user_effmode
hcs_$initiate                 hcs_$list_inacl_all           hcs_$make_seg                 hcs_$proc_info
hcs_$replace_acl              hcs_$replace_dir_acl          hcs_$replace_dir_inacl        hcs_$replace_inacl
hcs_$set_256K_switch          hcs_$set_copysw               hcs_$set_dir_ring_brackets    hcs_$set_entry_bound
hcs_$set_max_length           hcs_$set_max_length_seg       hcs_$set_ring_brackets        hcs_$set_safety_sw
hcs_$status_long              hcs_$status_minf              hcs_$terminate_noname         hcs_$truncate_seg
hphcs_$delentry_file          hphcs_$fs_get_trans_sw        hphcs_$restore_quota          hphcs_$set_for_reloader
hphcs_$suspend_quota          ioa_$rs                       ioa_$rsnnl                    pathname_
phcs_$set_max_length          system_privilege_$dir_priv_off                              system_privilege_$dir_priv_on
system_privilege_$initiate    system_privilege_$set_entry_audit_switch                    translate_aim_attributes_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$allow_dir_overwrite    bk_ss_$control_ptr            bk_ss_$data_iocb              bk_ss_$date
bk_ss_$datesw                 bk_ss_$debugsw                bk_ss_$enforce_minimum_ring   bk_ss_$holdsw
bk_ss_$hp                     bk_ss_$ignore_dates           bk_ss_$mapsw                  bk_ss_$minimum_ring
bk_ss_$myname                 bk_ss_$no_reload              bk_ss_$onlysw                 bk_ss_$path_index
bk_ss_$preattached            bk_ss_$pvname                 bk_ss_$pvsw                   bk_ss_$qchecksw
bk_ss_$restore_access_class   bk_ss_$retrieval_index        bk_ss_$retrievesw             bk_ss_$rname
bk_ss_$rsize                  bk_ss_$source_attributes_ptr  bk_ss_$sub_entry              bk_ss_$sub_entry_errfile
bk_ss_$target_attributes_ptr  bk_ss_$translate_access_class bk_ss_$trimsw                 error_table_$incorrect_access
error_table_$moderr           error_table_$namedup          error_table_$no_dir           error_table_$no_e_permission
error_table_$no_info          error_table_$noentry          error_table_$pvid_not_found   error_table_$rqover
error_table_$vtoce_connection_fail                          sys_info$access_class_ceiling sys_info$default_max_length
sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     71 000643       147 000653        68 000660       289 000667       291 000671       296 000701       297 000707
    298 000711       299 000720       301 000735       302 000737       303 000765       306 000766       307 000771
    308 000774       310 001010       311 001013       313 001016       314 001023       317 001037       318 001042
    320 001045       321 001052       324 001066       325 001071       327 001074       328 001101       330 001102
    331 001113       332 001114       334 001152       337 001153       338 001154       340 001170       341 001206
    342 001207       345 001210       348 001222       349 001225       351 001227       352 001237       354 001242
    355 001244       356 001245       358 001261       359 001273       360 001312       361 001323       363 001324
    364 001332       365 001334       366 001335       367 001336       369 001337       370 001342       371 001346
    372 001352       373 001356       374 001362       375 001365       376 001373       378 001377       379 001403
    380 001404       382 001420       383 001424       385 001427       386 001436       387 001442       388 001445
    390 001446       393 001447       394 001456       396 001461       397 001465       398 001466       399 001470
    402 001474       403 001505       406 001534       407 001540       408 001541       409 001542       410 001563
    412 001565       414 001570       416 001576       418 001577       420 001603       423 001620       424 001623
    425 001664       428 001727       429 001732       431 001762       433 001776       436 002041       438 002064
    440 002067       442 002114       445 002115       446 002130       447 002133       450 002134       452 002136
    454 002151       457 002165       460 002167       463 002172       465 002200       467 002213       468 002225
    472 002233       473 002255       474 002263       475 002272       476 002274       477 002331       478 002337
    480 002340       481 002341       485 002404       487 002407       488 002411       495 002424       498 002426
    499 002450       500 002454       501 002456       502 002473       505 002474       506 002476       508 002515
    510 002516       512 002537       516 002543       518 002545       519 002550       523 002556       526 002563
    530 002572       533 002575       535 002603       538 002614       539 002616       540 002627       541 002643
    542 002657       544 002674       546 002712       547 002715       548 002726       550 002736       555 002737
    557 002745       560 002763       561 002765       562 002767       564 002775       566 002776       567 003001
    570 003006       571 003014       575 003016       581 003021       582 003023       585 003063       588 003070
    590 003072       591 003076       594 003112       595 003114       597 003145       601 003146       603 003154
    604 003175       605 003177       608 003206       609 003241       613 003242       614 003273       619 003274
    628 003304       632 003305       636 003326       637 003331       639 003350       640 003352       641 003364
    643 003450       645 003451       648 003456       652 003461       654 003463       655 003464       657 003465
    659 003500       661 003532       662 003553       663 003555       664 003611       668 003612       671 003631
    672 003634       673 003643       674 003650       676 003653       677 003666       678 003676       679 003702
    680 003704       682 003735       688 003736       689 003743       690 003746       691 004002       692 004004
    693 004040       694 004045       695 004050       696 004051       699 004053       700 004065       701 004074
    703 004102       705 004106       706 004150       710 004203       711 004212       713 004217       715 004223
    717 004265       720 004323       723 004325       725 004326       726 004333       727 004340       732 004344
    738 004351       740 004355       742 004357       744 004361       745 004371       746 004375       747 004434
    748 004436       755 004474       756 004475       763 004500       764 004503       766 004505       768 004512
    770 004521       772 004524       774 004527       777 004532       779 004533       780 004535       782 004536
    783 004552       785 004621       786 004632       792 004633       794 004635       795 004642       796 004664
    797 004665       798 004667       799 004672       801 004674       803 004675       805 004676       806 004703
    807 004705       809 004731       813 004737       814 004744       815 004751       817 004757       818 004762
    820 004767       822 004770       825 004775       827 004776       830 005000       831 005013       832 005015
    834 005062       835 005064       836 005117       837 005127       840 005130       842 005141       843 005144
    845 005146       846 005153       847 005155       851 005161       852 005163       854 005164       855 005165
    856 005167       857 005224       863 005262       865 005267       866 005271       868 005342       869 005406
    870 005410       871 005440       874 005441       876 005444       877 005466       879 005476       880 005477
    882 005500       885 005507       887 005517       889 005553       894 005554       896 005625       897 005671
    898 005673       900 005723       901 005727       903 005730       904 005755       906 005777       907 006003
    908 006004       909 006006       910 006012       911 006016       913 006020       916 006021       917 006031
    920 006065       921 006115       922 006117       924 006122       925 006135       926 006137       928 006142
    930 006151       932 006155       934 006156       935 006162       938 006163       940 006213       945 006215
    946 006222       949 006224       950 006231       951 006235       952 006241       953 006245       954 006246
    960 006304       966 006330       967 006332       974 006336       975 006340       976 006343       977 006345
    978 006351       979 006353       980 006356       981 006360       982 006364       985 006365       986 006367
    987 006417       989 006454       990 006514       996 006547       997 006552       999 006561      1000 006564
   1001 006566      1002 006570      1003 006572      1005 006573      1007 006574      1008 006576      1009 006622
   1015 006662      1016 006666      1021 006712      1023 006721      1024 006725      1026 006726      1027 006733
   1028 006735      1029 006773      1031 007031      1033 007032      1034 007033      1035 007037      1036 007041
   1038 007077      1040 007134      1046 007135      1047 007141      1048 007142      1049 007146      1051 007147
   1053 007151      1054 007155      1055 007161      1058 007165      1059 007170      1060 007175      1061 007202
   1064 007207      1067 007242      1068 007267      1069 007271      1071 007332      1072 007334      1073 007371
   1077 007402      1082 007436      1083 007443      1085 007451      1086 007453      1087 007457      1088 007463
   1090 007467      1091 007471      1092 007476      1094 007506      1095 007514      1096 007522      1097 007530
   1098 007536      1099 007564      1102 007622      1106 007661      1110 007715      1114 007751      1120 010005
   1124 010006      1126 010007      1127 010016      1128 010026      1130 010030      1133 010031      1135 010032
   1136 010034      1137 010052      1139 010053      1144 010054      1170 010056      1171 010063      1174 010076
   1175 010131      1176 010137      1177 010203      1180 010210      1182 010222      1183 010223      1187 010235
   1196 010241      1202 010247      1203 010276      1204 010320      1206 010356      1209 010357      1213 010365
   1214 010370      1215 010422      1216 010427      1217 010432      1218 010437      1220 010442      1228 010445
   1239 010446      1244 010451      1245 010502      1247 010515


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
