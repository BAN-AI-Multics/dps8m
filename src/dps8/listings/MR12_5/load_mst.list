	COMPILATION LISTING OF SEGMENT load_mst
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0951.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
       12*     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1091):
       13*     Correct error message documentation.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 load_mst: proc;
       18 
       19 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       20 
       21 /* This program reads in collection 1.2 and takes the segments called
       22*foo.ascii and puts them into the bootload file system.  Collection 1.5 is
       23*read in and built into the address space.  Collections 2.0 and
       24*3.0 are then read into the mst area of the bce partition for warm boots. */
       25 
       26 /* Initially code by Keith Loepere April Fools Day 1983.  (That was a Friday).
       27*Modified by Keith Loepere, October 1983 for collection 2 and 3 reading to disk.
       28*Modified by Keith Loepere, July 1984 to set sentinel in bkpt_page.
       29*Modified by Keith Loepere, January 1985, for allow permanent collection 1.5 segs. */
       30 
       31 dcl  addr				builtin;
       32 dcl  addrel			builtin;
       33 dcl  ai_linkage$			external static;
       34 dcl  as_linkage$			external static;	/* combined linkage segments */
       35 dcl  baseptr			builtin;
       36 dcl  bce_abs_seg$add		entry (fixed bin (15));
       37 dcl  1 bce_command_seg_info		aligned static,	/* description of bce commands on disk 
       38*	- a call to init_commands threads these into the address space */
       39        2 pre_linked			bit (1) aligned,	/* else must pre-link at init_commands time */
       40        2 number			fixed bin init (0),
       41        2 entries			(100),
       42          3 segnum			fixed bin (15),
       43          3 starting_record		fixed bin (18),	/* on disk */
       44          3 length			fixed bin,	/* in pages */
       45          3 permanent		bit (1) aligned;	/* copy into perm seg */
       46 dcl  bin				builtin;
       47 dcl  bit				builtin;
       48 dcl  bootload_fs_$flush_sys		entry;
       49 dcl  bootload_fs_$put_ptr		entry (char (*), fixed bin (21), bit (1) aligned, ptr, fixed bin (35));
       50 dcl  code				fixed bin (35);
       51 dcl  1 control_word			aligned based,	/* MST control word */
       52      ( 2 type			fixed bin (17),	/* control word type */
       53        2 count			fixed bin (18) uns
       54        )				unaligned;	/* count of words following */
       55 dcl  copy				bit (9437184 /* 256 * 1024 * 36 */) aligned based; /* used to make copy of coll 1.5 seg into perm one */
       56 dcl  copying_sdw			fixed bin (71);	/* sdw to make copy with - has rw access */
       57 dcl  definitions_$			ext;		/* definitions segment */
       58 dcl  dimension			builtin;
       59 dcl  disk_mst_seg$			bit (9437184 /* 256 * 1024 * 36 */) aligned ext; /* used to map onto mst area of disk */
       60 dcl  disk_mst_seg_sdw		fixed bin (71);	/* sdw for disk_mst_seg */
       61 dcl  divide			builtin;
       62 dcl  expect_defs			bit (1) aligned;	/* definitions expected switch */
       63 dcl  expect_link			bit (1) aligned;	/* linkage section expected switch */
       64 dcl  header_area			(1000) fixed bin (35); /* area into which segment header is read */
       65 dcl  header_ptr			ptr;		/* pointer to header area */
       66 dcl  index			builtin;
       67 dcl  last_sltep			ptr;		/* pointer to previous slt entry */
       68 dcl  length			builtin;
       69 dcl  link_ptr			ptr;		/* pointer to linkage section */
       70 dcl  load_control_word		entry (fixed bin, fixed bin (18)) variable; /* entry variable to get a control word from mst, possibly saving it in mst disk area */
       71 dcl  load_header			entry (ptr, fixed bin (18)) variable; /* entry variable to read a segment header from the mst, possibly saving it to mst disk area */
       72 dcl  load_segment			entry (ptr, fixed bin (18)) variable; /* entry variable to read a segment from the mst saving it where appropriate */
       73 dcl  1 lot$			ext like lot;	/* linkage offset table */
       74 dcl  make_sdw			entry (fixed bin (15), fixed bin (71), ptr, ptr);
       75 dcl  make_sdw$no_pages		entry (fixed bin (15), fixed bin (71), ptr, ptr);
       76 dcl  map_onto_disk			entry (fixed bin, fixed bin (18), fixed bin, ptr, bit (1) aligned);
       77 dcl  mod				builtin;
       78 dcl  next_partition_word		fixed bin (26);	/* next word in mst area to receive mst tape word */
       79 dcl  null				builtin;
       80 dcl  page_table			(0:255) bit (36) aligned based (ptp); /* for disk_mst_seg */
       81 dcl  partition_left			fixed bin (26);	/* words left in mst disk area */
       82 dcl  pc$cleanup			entry (ptr);
       83 dcl  pc_wired$write			entry (ptr, fixed bin, fixed bin);
       84 dcl  perm_seg_astep			ptr;
       85 dcl  perm_seg_ptp			ptr;
       86 dcl  perm_seg_sdw			fixed bin (71);	/* used for permanent copy made of coll 1.5 segs */
       87 dcl  pmut$camp			entry;
       88 dcl  pmut$swap_sdw			entry (ptr, ptr);
       89 dcl  pre_link_hc			entry;
       90 dcl  ptp				ptr;		/* ptr to page table for disk_mst_seg */
       91 dcl  ptw_num			fixed bin;	/* loop var on page table creations */
       92 dcl  ptw_util_$make_disk		entry (ptr, fixed bin (20));
       93 dcl  ptw_util_$make_null_disk		entry (ptr, fixed bin (20));
       94 dcl  pvt$root_pvtx			fixed bin ext;
       95 dcl  rtrim			builtin;
       96 dcl  sdw_util_$set_access		entry (ptr, bit (4) unal);
       97 dcl  seg_number			fixed bin (15);	/* segment number of segment being loaded */
       98 dcl  seg_ptr			ptr;		/* pointer to segment being loaded */
       99 dcl  segno			builtin;
      100 dcl  size				builtin;
      101 dcl  slot_num			fixed bin;	/* in bce_command_seg_info */
      102 dcl  slt$				external static;
      103 dcl  slt_manager$build_entry		entry (ptr) returns (ptr);
      104 dcl  start_partition_record		fixed bin (20);	/* first mst record that disk_mst_seg maps onto */
      105 dcl  substr			builtin;
      106 dcl  sys_boot_info$bce_part_frec	fixed bin (20) ext;
      107 dcl  sys_boot_info$bce_part_nrec	fixed bin (20) ext;
      108 dcl  sys_boot_info$mst_past_bce_frec	fixed bin (20) ext;
      109 dcl  syserr			entry options (variable);
      110 dcl  syserr$error_code		entry options (variable);
      111 dcl  tape_reader			entry (ptr, fixed bin (18));
      112 dcl  text_no			fixed bin (15);	/* text segment number */
      113 dcl  text_ptr			ptr;		/* pointer to text segment */
      114 dcl  wi_linkage$			external static;
      115 dcl  wordno			builtin;
      116 dcl  ws_linkage$			external static;
      117 
      118 /* Start by reading collection 1.2 into the file partition. */
      119 
      120 	load_control_word = read_control_word;
      121 	load_header = tape_reader;
      122 	load_segment = load_file_segment;
      123 	call load_collection;			/* collection 1.2! */
      124 	call bootload_fs_$flush_sys;			/* force out file sys */
      125 
      126 	next_partition_word = 0;
      127 	start_partition_record = 0;
      128 	partition_left = (sys_boot_info$bce_part_nrec - MST_AREA_RECORDX) * 1024;
      129 	call make_sdw$no_pages (segno (addr (disk_mst_seg$)), disk_mst_seg_sdw, astep, ptp);
      130 	aste.pvtx = pvt$root_pvtx;
      131 	call pmut$swap_sdw (addr (disk_mst_seg$), addr (disk_mst_seg_sdw));
      132 
      133 /* Load in bce commands (collection 1.5).  They are activated later (init_commands). */
      134 
      135 	bce_command_seg_info.number = 0;
      136 	bce_command_seg_info.pre_linked = "0"b;
      137 
      138 	expect_defs = "0"b;				/* Initialize the control switches */
      139 	expect_link = "0"b;
      140 
      141 	sltp = addr (slt$);				/* Get a pointer to SLT structure. */
      142 	lotp = addr (lot$);				/* Get a pointer to the LOT. */
      143 	definitions_ptr = addr (definitions_$);
      144 
      145 	load_control_word = read_control_word;
      146 	load_header = tape_reader;
      147 	load_segment = load_command_seg;
      148 	call load_collection;
      149 	sys_boot_info$mst_past_bce_frec = sys_boot_info$bce_part_frec + MST_AREA_RECORDX + start_partition_record;
      150 
      151 /* Now read in collections 2.0 and 3.0 to disk. */
      152 
      153 	aste.csl, aste.msl = "0"b;
      154 	load_control_word = save_control_word;
      155 	load_header = save_header;
      156 	load_segment = load_mst_segment;
      157 	call load_collection;			/* collection 2.0 */
      158 	call load_collection;			/* collection 3.0 */
      159 	call pc$cleanup (astep);			/* force write pages left */
      160 
      161 	call syserr (ANNOUNCE, "load_mst: ^d. out of ^d. pages used in disk mst area.",
      162 	     divide (next_partition_word + 1023, 1024, 20), sys_boot_info$bce_part_nrec - MST_AREA_RECORDX);
      163 
      164 	disk_mst_seg_sdw = 0;			/* cleanup */
      165 	call pmut$swap_sdw (addr (disk_mst_seg$), addr (disk_mst_seg_sdw));
      166 	return;
      167 
      168 init_commands: entry;
      169 
      170 /* Build astes for bce command segs.  Pre-link them if necessary. */
      171 
      172 	do slot_num = 1 to bce_command_seg_info.number;
      173 	     call map_onto_disk (pvt$root_pvtx, bce_command_seg_info.starting_record (slot_num), bce_command_seg_info.length (slot_num), baseptr (bce_command_seg_info.segnum (slot_num)), "1"b);
      174 	     call bce_abs_seg$add (bce_command_seg_info.segnum (slot_num));
      175 	end;
      176 	if ^bce_command_seg_info.pre_linked then do;
      177 	     call pre_link_hc;
      178 	     bce_command_seg_info.pre_linked = "1"b;
      179 	end;
      180 	return;
      181 
      182 make_permanent: entry;
      183 
      184 /* Build permanent astes for permanent collection 1.5 segs.  Copy the disk
      185*version into permanent segment. */
      186 
      187 	sltp = addr (slt$);
      188 	call make_sdw$no_pages (segno (addr (disk_mst_seg$)), disk_mst_seg_sdw, astep, ptp);
      189 	aste.pvtx = pvt$root_pvtx;
      190 	call pmut$swap_sdw (addr (disk_mst_seg$), addr (disk_mst_seg_sdw));
      191 
      192 	do slot_num = 1 to bce_command_seg_info.number;
      193 	     if bce_command_seg_info.permanent (slot_num) then do;
      194 		do ptw_num = 0 to bce_command_seg_info.length (slot_num) - 1; /* establish disk area */
      195 		     call ptw_util_$make_disk (addr (page_table (ptw_num)), bce_command_seg_info.starting_record (slot_num) + ptw_num);
      196 		end;
      197 		aste.csl, aste.msl = bit (bin (bce_command_seg_info.length (slot_num), 9), 9);
      198 		call pmut$camp;
      199 
      200 /* copy this seg into perm seg */
      201 
      202 		seg_number = bce_command_seg_info.segnum (slot_num);
      203 		sltep = addr (slt.seg (seg_number));
      204 		slte.abs_seg = "0"b;		/* We don't manage disk anymore */
      205 		call make_sdw (seg_number, perm_seg_sdw, perm_seg_astep, perm_seg_ptp);
      206 		copying_sdw = perm_seg_sdw;
      207 		call sdw_util_$set_access (addr (copying_sdw), "1010"b); /* force rw onto copy */
      208 
      209 		seg_ptr = baseptr (seg_number);
      210 		call pmut$swap_sdw (seg_ptr, addr (copying_sdw));
      211 
      212 		substr (seg_ptr -> copy, 1, 36 * 1024 * bce_command_seg_info.length (slot_num)) =
      213 		     substr (disk_mst_seg$, 1, 36 * 1024 * bce_command_seg_info.length (slot_num));
      214 
      215 		call pmut$swap_sdw (seg_ptr, addr (perm_seg_sdw)); /* set real sdw */
      216 		call pc_wired$write (perm_seg_astep, 0, -1); /* Flush to disk */
      217 		call pc$cleanup (astep);		/* cleanup disk_mst_seg */
      218 	     end;
      219 	end;
      220 
      221 	disk_mst_seg_sdw = 0;			/* cleanup */
      222 	call pmut$swap_sdw (addr (disk_mst_seg$), addr (disk_mst_seg_sdw));
      223 	return;
      224 
      225 load_collection: proc;
      226 
      227 /* Routine, given the entry variables load_control_word, load_header and
      228*load_segment, which reads from the mst and puts the entities into their
      229*proper places. */
      230 
      231 dcl  count			fixed bin (18);	/* length of record on MST */
      232 dcl  type				fixed bin;	/* type of record on MST */
      233 
      234 	header_ptr = addr (header_area);		/* Generate pointer to header area. */
      235 
      236 /* Read control word and dispatch on it. */
      237 
      238 	call load_control_word (type, count);		/* Read a control word. */
      239 	do while (type ^= 2);
      240 	     if type ^= 0 then call syserr (CRASH, "load_mst: unknown control type ^d", type);
      241 
      242 /* Process header record. */
      243 
      244 	     if count > size (header_area) then		/* Error if header is too large ... */
      245 		call syserr (CRASH, "load_mst: bad header size ^d", count);
      246 						/* ... or too small. */
      247 
      248 	     call load_header (header_ptr, count);	/* Read in the header. */
      249 
      250 	     call load_control_word (type, count);	/* Read in next control word. */
      251 	     if type ^= 1 then			/* It must be a segment control word. */
      252 		call syserr (CRASH, "load_mst: unexpected control type ^d", type);
      253 
      254 	     call load_segment (header_ptr, count);	/* Load in the segment. */
      255 	     call load_control_word (type, count);	/* next thing */
      256 	end;
      257 
      258 /* Process collection record. */
      259 
      260 	call load_control_word (type, count);		/* Read the collection mark. */
      261 	return;
      262      end;
      263 
      264 load_command_seg: proc (header_ptr, count);
      265 
      266 /* Read in a collection 1.5 object.  Place it on disk or thread linkage areas
      267*accordingly.  Build the table bce_command_seg_info. The equivalent of 
      268*segment_loader from collection 2.0. */
      269 
      270 dcl  count			fixed bin (18) parameter; /* length of record on MST */
      271 dcl  header_ptr			ptr parameter;	/* to mst seg info */
      272 
      273 	if header_ptr -> slte.link_sect then do;
      274 	     if ^expect_link then call syserr (CRASH, "load_mst: Unexpected linkage.");
      275 	     expect_link = "0"b;			/* Turn off switch. */
      276 	     expect_defs = "1"b;			/* Defs should come next. */
      277 
      278 	     if last_sltep -> slte.combine_link then do;
      279 		if last_sltep -> slte.link_sect_wired then
      280 		     if last_sltep -> slte.init_seg then hclsp = addr (wi_linkage$);
      281 		     else hclsp = addr (ws_linkage$);
      282 		else if last_sltep -> slte.init_seg then hclsp = addr (ai_linkage$);
      283 		else hclsp = addr (as_linkage$);
      284 		seg_ptr = hclsp -> hc_linkage_seg.next_free_ptr; /* Get pointer to end of combined linkage. */
      285 		hclsp -> hc_linkage_seg.next_free_ptr = addrel (seg_ptr, count + mod (count, 2)); /* Update pointer to next free even loc. */
      286 
      287 		call tape_reader (seg_ptr, count);	/* Read in the linkage section into place. */
      288 	     end;
      289 
      290 	     else call load_bce_segment;
      291 
      292 	     link_ptr = seg_ptr;			/* Save pointer to linkage. */
      293 	     lot.lp (text_no) = link_ptr;		/* Set LOT entry. */
      294 	     link_ptr -> linkage_header.segment_number = text_no;
      295 						/* Save text segment number in linkage header. */
      296 	end;
      297 
      298 	else if header_ptr -> slte.defs then do;
      299 	     if ^expect_defs then call syserr (CRASH, "load_mst: Unexpected defs.");
      300 	     expect_defs = "0"b;
      301 
      302 	     seg_ptr = definitions.next_free_ptr;	/* Get pointer to end of definitions. */
      303 	     definitions.next_free_ptr = addrel (seg_ptr, count); /* Update pointer to next free. */
      304 
      305 	     call tape_reader (seg_ptr, count);		/* Read definitions into place. */
      306 
      307 	     definitions.dot (text_no).offset = wordno (seg_ptr);
      308 	     definitions.dot (text_no).length = count;	/* Fill in offset table entry. */
      309 
      310 	     link_ptr -> linkage_header.def_ptr = seg_ptr;/* Set correct defs pointer. */
      311 	end;
      312 
      313 	else do;					/* Must be text, or something. */
      314 	     if expect_link | expect_defs then call syserr (CRASH, "load_mst: Missing linkage or defs.");
      315 	     expect_link = header_ptr -> slte.link_provided; /* Set switch. */
      316 
      317 	     call load_bce_segment;			/* Load in the segment. */
      318 	     text_ptr = seg_ptr;			/* Save pointer to the text. */
      319 	     text_no = segno (text_ptr);		/* Also, get text segment number. */
      320 	end;
      321 
      322 	last_sltep = sltep;				/* Save pointer to last SLT entry. */
      323 
      324 	return;
      325 
      326 load_bce_segment: proc;
      327 
      328 /* Load a segment into the next set of pages in mst area on disk. */
      329 
      330 dcl  seg_len			fixed bin;
      331 
      332 	     seg_ptr = slt_manager$build_entry (header_ptr); /* Build new entry in SLT. */
      333 	     if seg_ptr = null () then call syserr (CRASH, "load_mst: error from slt_manager$build_entry");
      334 
      335 	     seg_number = segno (seg_ptr);		/* Get segment number of new segment. */
      336 
      337 	     sltep = addr (slt.seg (seg_number));
      338 	     slte.abs_seg = "1"b;			/* We manage disk. */
      339 	     seg_len, slte_uns.max_length = slte_uns.cur_length;
      340 	     if substr (slte.access, 2, 1) then do;	/* e access => breakpoinatble */
      341 		slte.breakpointable = "1"b;
      342 		slte_uns.cur_length, slte_uns.max_length, seg_len = seg_len + 1;
      343 	     end;
      344 
      345 	     bce_command_seg_info.number = bce_command_seg_info.number + 1;
      346 	     if bce_command_seg_info.number > dimension (bce_command_seg_info.entries, 1) then call syserr (CRASH, "load_mst: too many bce command segments.");
      347 	     if seg_len * 1024 > partition_left then call syserr (CRASH, "load_mst: Out of space in mst area of bce partition.");
      348 
      349 	     bce_command_seg_info.segnum (bce_command_seg_info.number) = seg_number;
      350 	     bce_command_seg_info.starting_record (bce_command_seg_info.number) = sys_boot_info$bce_part_frec + MST_AREA_RECORDX + start_partition_record;
      351 	     bce_command_seg_info.length (bce_command_seg_info.number) = seg_len;
      352 	     bce_command_seg_info.permanent (bce_command_seg_info.number) = ^slte.temp_seg;
      353 
      354 	     do ptw_num = 0 to seg_len - 1;		/* establish disk area */
      355 		call ptw_util_$make_null_disk (addr (page_table (ptw_num)), sys_boot_info$bce_part_frec + MST_AREA_RECORDX + start_partition_record + ptw_num);
      356 	     end;
      357 	     aste.csl, aste.msl = bit (bin (seg_len, 9), 9);
      358 	     call pmut$camp;
      359 	     start_partition_record = start_partition_record + seg_len;
      360 	     next_partition_word = next_partition_word + seg_len * 1024;
      361 	     partition_left = partition_left - seg_len * 1024;
      362 
      363 	     call tape_reader (addr (disk_mst_seg$), count); /* Slurp in the new segment. */
      364 
      365 	     if slte.breakpointable then		/* place sentinel to avoid nulling of bkpt_page */
      366 		addrel (addr (disk_mst_seg$), (seg_len - 1) * 1024) -> bkpt_page.sentinel = BKPT_page_sentinel;
      367 
      368 	     call pc$cleanup (astep);			/* Flush to disk */
      369 	     return;
      370 	end;
      371      end;
      372 
      373 load_file_segment: proc (header_ptr, count);
      374 
      375 /* entry to load a segment from the mst into a slot in the bce file system. */
      376 
      377 dcl  count			fixed bin (18);	/* number of words to read */
      378 dcl  file_length			fixed bin (21);	/* file lth in chars */
      379 dcl  file_name			char (32);	/* after stripping optional suffix */
      380 dcl  file_name_lth			fixed bin;	/* length of file_name trimmed */
      381 dcl  header_ptr			ptr;		/* to slte/nameseg entry pair */
      382 
      383 	sltep = header_ptr;
      384 	namep = addrel (sltep, size (slte));
      385 	file_name_lth = length (rtrim (segnam.names (1).name)); /* trim optional ".ascii" suffix */
      386 	if index (segnam.names (1).name, ".ascii") = file_name_lth - length (".ascii") + 1 then file_name_lth = file_name_lth - length (".ascii");
      387 	file_name = substr (segnam.names (1).name, 1, file_name_lth);
      388 	file_length = divide (slte_uns.bit_count, 9, 21); /* determine char lth */
      389 	if divide (file_length + 3, 4, 18) < count then file_length = count * 4; /* num words used by bc less than words on tape - bc lied */
      390 	seg_ptr = null;
      391 	call bootload_fs_$put_ptr (file_name, file_length, "0"b, seg_ptr, code); /* find ptr to room in file space */
      392 	if seg_ptr = null then call syserr$error_code (ANNOUNCE, code, "load_mst: ^a can't be placed into file partition.", segnam.names (1).name);
      393 	call tape_reader (seg_ptr, count);		/* read into allocated space */
      394 	return;
      395      end;
      396 
      397 load_mst_segment: proc (header_ptr, count);
      398 
      399 /* read segment from mst appending onto mst area */
      400 
      401 dcl  count			fixed bin (18);	/* words to read */
      402 dcl  header_ptr			ptr;		/* to slte/name_seg entry pair */
      403 dcl  segment_ptr			ptr;		/* dummy returned ptr to seg read */
      404 
      405 	call read_and_save (segment_ptr, count);
      406 	return;
      407      end;
      408 
      409 read_and_save: proc (saved_ptr, count);
      410 
      411 /* Read a count number of words from the tape.  Append it to what is in the 
      412*partition.  Return a pointer to these words (paged area). The idea is to build 
      413*a paged segment onto the set of pages within which the segment will be loaded.
      414*A pointer to the actual area is returned. */
      415 
      416 dcl  count			fixed bin (18);	/* number of words to read and save */
      417 dcl  last_partition_record		fixed bin (20);	/* record holding last word of where newly read in words would go */
      418 dcl  last_partition_word		fixed bin (26);	/* last word used in partition by this new read block */
      419 dcl  saved_ptr			ptr;		/* return ptr to words read */
      420 
      421 	if partition_left < count then call syserr (CRASH, "load_mst: Out of space in mst area of bce partition.");
      422 
      423 	last_partition_word = next_partition_word + count - 1;
      424 	last_partition_record = divide (last_partition_word, 1024, 20);
      425 	if last_partition_record - start_partition_record > 255 then do;
      426 
      427 /* We can't grow our abs seg to hold this new unit.
      428*Flush the old to disk and re-map the abs seg. */
      429 
      430 	     call pc$cleanup (astep);
      431 	     start_partition_record = divide (next_partition_word, 1024, 20);
      432 	     call ptw_util_$make_disk (addr (page_table (0)), sys_boot_info$bce_part_frec + MST_AREA_RECORDX + start_partition_record); /* keep old page */
      433 	     aste.csl, aste.msl = "000000001"b;
      434 	end;
      435 
      436 /* grow abs seg to encompass new words */
      437 
      438 	do ptw_num = bin (aste.csl, 9) to last_partition_record - start_partition_record;
      439 	     call ptw_util_$make_null_disk (addr (page_table (ptw_num)), sys_boot_info$bce_part_frec + MST_AREA_RECORDX + start_partition_record + ptw_num);
      440 	end;
      441 	aste.csl, aste.msl = bit (bin (last_partition_record - start_partition_record + 1, 9), 9);
      442 	call pmut$camp;
      443 
      444 	saved_ptr = addrel (addr (disk_mst_seg$), next_partition_word - start_partition_record * 1024);
      445 	call tape_reader (saved_ptr, count);		/* read into mst area */
      446 	partition_left = partition_left - count;	/* gobble space */
      447 	next_partition_word = last_partition_word + 1;
      448 	return;
      449      end;
      450 
      451 read_control_word: proc (type, count);
      452 
      453 /* read a control word from the mst */
      454 
      455 dcl  count			fixed bin (18);	/* count of following record */
      456 dcl  1 my_control_word		aligned like control_word;
      457 dcl  type				fixed bin;	/* control word type */
      458 
      459 	call tape_reader (addr (my_control_word), 1);
      460 	type = my_control_word.type;
      461 	count = my_control_word.count;
      462 	return;
      463      end;
      464 
      465 save_control_word: proc (type, count);
      466 
      467 /* read a control word from the mst and save in mst area */
      468 
      469 dcl  count			fixed bin (18);	/* count field */
      470 dcl  type				fixed bin;	/* type field */
      471 dcl  word_ptr			ptr;		/* ptr to word read and saved */
      472 
      473 	call read_and_save (word_ptr, 1);
      474 	type = word_ptr -> control_word.type;
      475 	count = word_ptr -> control_word.count;
      476 	return;
      477      end;
      478 
      479 save_header: proc (header_ptr, count);
      480 
      481 /* read in and save a segment header from the mst */
      482 
      483 dcl  count			fixed bin (18);	/* count of words to read */
      484 dcl  header_ptr			ptr;		/* ptr to area in which to read */
      485 dcl  header_read			(count) bit (36) aligned based; /* what read */
      486 dcl  read_ptr			ptr;		/* ptr to area saved in mst area */
      487 
      488 	call read_and_save (read_ptr, count);
      489 	header_ptr -> header_read = read_ptr -> header_read;
      490 	return;
      491      end;
      492  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      492 
      493  /* BEGIN include file bce_breakpoint_page.incl.pl1 */
  2     2 
  2     3 /* Description of hardcore breakpoint information saved in breakpoint_page.
  2     4*Keith Loepere, December 1983. */
  2     5 /* Sentinel added, July 1984 by Keith Loepere. */
  2     6 
  2     7 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  2     8 
  2     9 dcl  1 bkpt_page		        aligned based (bkpt_page_ptr),
  2    10        2 header		        aligned,
  2    11          3 mc_		        aligned like mc,
  2    12          3 mode_reg		        bit (36) aligned,
  2    13          3 cache_mode_reg	        bit (36) aligned,
  2    14          3 dbr		        bit (72) aligned,
  2    15          3 bar		        bit (36) aligned,
  2    16          3 sentinel		        char (4) unal,
  2    17          3 pad		        (10) bit (36),
  2    18        2 bkpts		        (120) aligned like breakpoint;
  2    19 dcl  bkpt_page_ptr		        ptr;
  2    20 
  2    21 dcl  1 breakpoint		        aligned based (breakpoint_ptr),
  2    22        2 breakpoint_drl	        bit (36),		/* drl -1 => breakpoint */
  2    23        2 instructions	        (4) bit (36),
  2    24        2 tra_back_offset	        fixed bin (18) unal uns,
  2    25        2 tra_back		        bit (18) unal,	/* tra back to original code */
  2    26        2 original_instr_ptr	        ptr unal,		/* ptr to where original instruction was */
  2    27        2 original_instr	        bit (36);		/* real instruction moved */
  2    28 dcl  breakpoint_ptr		        ptr;
  2    29 
  2    30 dcl  BKPT_page_sentinel	        char (4) static options (constant) init ("bkpt");
  2    31 
  2    32 /* END include file bce_breakpoint_page.incl.pl1 */
      493 
      494  /* BEGIN include file bce_partition_layout.incl.pl1
  3     2*This is the layout of the bce partition for bootload Multics.
  3     3*Written September 1983 by Keith Loepere. */
  3     4 
  3     5 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  3     6 
  3     7 dcl  BCE_PART_LTH		        init (2200) fixed bin internal static options (constant);  /* This is the default value. */
  3     8 dcl  SAVED_IMAGE_RECORDX	        init (0) fixed bin internal static options (constant);
  3     9 dcl  CRASH_HANDLER_RECORDX	        init (512) fixed bin internal static options (constant);
  3    10 dcl  BCE_PAGING_AREA_RECORDX	        init (1024) fixed bin internal static options (constant);
  3    11 dcl  BCE_PAGING_AREA_LTH	        init (128) fixed bin internal static options (constant);
  3    12 dcl  MST_AREA_RECORDX	        init (1152) fixed bin internal static options (constant);
  3    13 
  3    14 /* END include file bce_partition_layout.incl.pl1 */
      494 
      495  /* Begin include file hc_definitions_seg.incl.pl1 BIM 7/82 */
  4     2 /* format: style3 */
  4     3 
  4     4 declare	definitions_ptr	ptr;
  4     5 
  4     6 declare	1 definitions	aligned based (definitions_ptr),
  4     7 	  2 next_free_ptr	pointer,			/* next section, starts after table */
  4     8 	  2 dot		(2:511) aligned,		/* definitions_offset_table */
  4     9 	    3 offset	fixed bin (18) uns unal,	/* in this segment */
  4    10 	    3 length	fixed bin unal,
  4    11 	  2 first_free	bit (0) aligned;
  4    12 
  4    13 /* End include file hc_definitions_seg.incl.pl1 */
      495 
      496  /* Begin include file hc_linkage_seg.incl.pl1 */
  5     2 /* BIM 7/82 */
  5     3 
  5     4 /* format: style3 */
  5     5 
  5     6 declare	hclsp		ptr;
  5     7 declare	1 hc_linkage_seg	aligned based (hclsp),
  5     8 	  2 next_free_ptr	pointer,
  5     9 	  2 free_area	bit (36) aligned;
  5    10 
  5    11 /* End include file hc_linkage_seg */
      496 
      497  /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  6     2 /* modified by M. Weaver 3/77 */
  6     3 
  6     4 dcl  lotp ptr;
  6     5 
  6     6 dcl 1 lot based (lotp) aligned,
  6     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  6     8 
  6     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  6    10 						/* lot fault has fault code = 0 and offset = 0 */
  6    11 
  6    12 dcl  isotp ptr;
  6    13 dcl 1 isot based (isotp) aligned,
  6    14     2 isp (0:9999) ptr unaligned;
  6    15 
  6    16 dcl 1 isot1 (0 :9999) aligned based,
  6    17     2 flags unaligned,
  6    18       3 fault bit (2) unaligned,
  6    19       3 system bit (1) unaligned,
  6    20       3 mbz bit (6) unaligned,
  6    21     2 fault_code fixed bin (8) unaligned,
  6    22     2 static_offset bit (18) unaligned;
  6    23 
  6    24 
  6    25 /* END INCLUDE FILE  lot.incl.pl1 */
      497 
      498  /*  */
  7     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  7     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  7     4 /* Modified 07/07/76 by Morris for fault register data */
  7     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  7     6 /* Modified '82 to make values constant */
  7     7 
  7     8 /* words 0-15 pointer registers */
  7     9 
  7    10 dcl  mcp ptr;
  7    11 
  7    12 dcl 1 mc based (mcp) aligned,
  7    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  7    14    (2 regs,					/* registers */
  7    15       3 x (0:7) bit (18),				/* index registers */
  7    16       3 a bit (36),					/* accumulator */
  7    17       3 q bit (36),					/* q-register */
  7    18       3 e bit (8),					/* exponent */
  7    19       3 pad1 bit (28),
  7    20       3 t bit (27),					/* timer register */
  7    21       3 pad2 bit (6),
  7    22       3 ralr bit (3),				/* ring alarm register */
  7    23 
  7    24     2 scu (0:7) bit (36),
  7    25 
  7    26     2 mask bit (72),				/* mem controller mask at time of fault */
  7    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  7    28     2 errcode fixed bin (35),				/* fault handler's error code */
  7    29     2 fim_temp,
  7    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  7    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  7    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  7    33     2 fault_reg bit (36),				/* fault register */
  7    34     2 pad2 bit (1),
  7    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  7    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  7    37     2 fault_time bit (54),				/* time of fault */
  7    38 
  7    39     2 eis_info (0:7) bit (36)) unaligned;
  7    40 
  7    41 
  7    42 dcl (apx fixed bin init (0),
  7    43      abx fixed bin init (1),
  7    44      bpx fixed bin init (2),
  7    45      bbx fixed bin init (3),
  7    46      lpx fixed bin init (4),
  7    47      lbx fixed bin init (5),
  7    48      spx fixed bin init (6),
  7    49      sbx fixed bin init (7)) internal static options (constant);
  7    50 
  7    51 
  7    52 
  7    53 
  7    54 dcl  scup ptr;
  7    55 
  7    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  7    57 
  7    58 
  7    59 /*	WORD (0)		*/
  7    60 
  7    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  7    62       3 prr bit (3),				/* procedure ring register */
  7    63       3 psr bit (15),				/* procedure segment register */
  7    64       3 p bit (1),					/* procedure privileged bit */
  7    65 
  7    66     2 apu,					/* APPENDING UNIT STATUS */
  7    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  7    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  7    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  7    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  7    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  7    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  7    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  7    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  7    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  7    76       3 ptw bit (1),				/* Fetch of PTW */
  7    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  7    78       3 fap bit (1),				/* Fetch of final address paged */
  7    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  7    80       3 fabs bit (1),				/* Fetch of final address absolute */
  7    81 
  7    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  7    83 
  7    84 
  7    85 /*	WORD (1)		*/
  7    86 
  7    87     2 fd,						/* FAULT  DATA */
  7    88       3 iro bit (1),				/* illegal ring order */
  7    89       3 oeb bit (1),				/* out of execute bracket */
  7    90       3 e_off bit (1),				/* no execute */
  7    91       3 orb bit (1),				/* out of read bracket */
  7    92       3 r_off bit (1),				/* no read */
  7    93       3 owb bit (1),				/* out of write bracket */
  7    94       3 w_off bit (1),				/* no write */
  7    95       3 no_ga bit (1),				/* not a gate */
  7    96       3 ocb bit (1),				/* out of call bracket */
  7    97       3 ocall bit (1),				/* outward call */
  7    98       3 boc bit (1),				/* bad outward call */
  7    99       3 inret bit (1),				/* inward return */
  7   100       3 crt bit (1),				/* cross ring transfer */
  7   101       3 ralr bit (1),				/* ring alarm register */
  7   102       3 am_er bit (1),				/* associative memory fault */
  7   103       3 oosb bit (1),				/* out of segment bounds */
  7   104       3 paru bit (1),				/* processor parity upper */
  7   105       3 parl bit (1),				/* processor parity lower */
  7   106       3 onc_1 bit (1),				/* op not complete type 1 */
  7   107       3 onc_2 bit (1),				/* op not complete type 2 */
  7   108 
  7   109     2 port_stat,					/* PORT  STATUS */
  7   110       3 ial bit (4),				/* illegal action lines */
  7   111       3 iac bit (3),				/* illegal action channel */
  7   112       3 con_chan bit (3),				/* connect channel */
  7   113 
  7   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  7   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  7   116 
  7   117 
  7   118 /*	WORD (2)		*/
  7   119 
  7   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  7   121       3 trr bit (3),				/* temporary ring register */
  7   122       3 tsr bit (15),				/* temporary segment register */
  7   123 
  7   124     2 pad2 bit (9),
  7   125 
  7   126     2 cpu_no bit (3),				/* CPU number */
  7   127 
  7   128     2 delta bit (6),				/* tally modification DELTA */
  7   129 
  7   130 
  7   131 /*	WORD (3)		*/
  7   132 
  7   133     2 word3 bit (18),
  7   134 
  7   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  7   136       3 tsna,					/* Word 1 status */
  7   137         4 prn bit (3),				/* Word 1  PR  number */
  7   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  7   139       3 tsnb,					/* Word 2  status */
  7   140         4 prn bit (3),				/* Word 2  PR  number */
  7   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  7   142       3 tsnc,					/* Word 3  status */
  7   143         4 prn bit (3),				/* Word 3  PR  number */
  7   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  7   145 
  7   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  7   147 
  7   148 
  7   149 /* 	WORD (4)		*/
  7   150 
  7   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  7   152 
  7   153     2 ir,						/* INDICATOR  REGISTERS */
  7   154       3 zero bit (1),				/* zero indicator */
  7   155       3 neg bit (1),				/* negative indicator */
  7   156       3 carry bit (1),				/* carryry indicator */
  7   157       3 ovfl bit (1),				/* overflow indicator */
  7   158       3 eovf bit (1),				/* eponent overflow */
  7   159       3 eufl bit (1),				/* exponent underflow */
  7   160       3 oflm bit (1),				/* overflow mask */
  7   161       3 tro bit (1),				/* tally runout */
  7   162       3 par bit (1),				/* parity error */
  7   163       3 parm bit (1),				/* parity mask */
  7   164       3 bm bit (1),					/* ^bar mode */
  7   165       3 tru bit (1),				/* truncation mode */
  7   166       3 mif bit (1),				/* multi-word instruction mode */
  7   167       3 abs bit (1),				/* absolute mode */
  7   168       3 hex bit (1),				/* hexadecimal exponent mode */
  7   169       3 pad bit (3),
  7   170 
  7   171 
  7   172 /*	WORD (5)		*/
  7   173 
  7   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  7   175 
  7   176     2 cu,						/* CONTROL UNIT STATUS */
  7   177       3 rf bit (1),					/* on first cycle of repeat instr */
  7   178       3 rpt bit (1),				/* repeat instruction */
  7   179       3 rd bit (1),					/* repeat double instruction */
  7   180       3 rl bit (1),					/* repeat link instruciton */
  7   181       3 pot bit (1),				/* IT  modification */
  7   182       3 pon bit (1),				/* return type instruction */
  7   183       3 xde bit (1),				/* XDE from Even location */
  7   184       3 xdo bit (1),				/* XDE from Odd  location */
  7   185       3 poa bit (1),				/* operation preparation */
  7   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  7   187       3 its bit (1),				/* ITS modification */
  7   188       3 if bit (1),					/* fault occured during instruction fetch */
  7   189 
  7   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  7   191 
  7   192 
  7   193 /*	WORDS (6,7)	*/
  7   194 
  7   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  7   196 
  7   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  7   198 
  7   199 
  7   200 
  7   201 
  7   202 
  7   203 
  7   204 /*	ALTERNATE   SCU  DECLARATION		*/
  7   205 
  7   206 
  7   207 dcl 1 scux based (scup) aligned,
  7   208 
  7   209    (2 pad0 bit (36),
  7   210 
  7   211     2 fd,						/* GROUP II  FAULT DATA */
  7   212       3 isn bit (1),				/* illegal segment number */
  7   213       3 ioc bit (1),				/* illegal op  code  */
  7   214       3 ia_am bit (1),				/* illegal address - modifier */
  7   215       3 isp bit (1),				/* illegal slave  procedure */
  7   216       3 ipr bit (1),				/* illegal procedure */
  7   217       3 nea bit (1),				/* non existent address */
  7   218       3 oobb bit (1),				/* out of bounds */
  7   219       3 pad bit (29),
  7   220 
  7   221     2 pad2 bit (36),
  7   222 
  7   223     2 pad3a bit (18),
  7   224 
  7   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  7   226       3 prn bit (3),				/* PR  number */
  7   227       3 prv bit (1),				/* PR  valid bit */
  7   228 
  7   229     2 pad3b bit (6)) unaligned,
  7   230 
  7   231     2 pad45 (0:1) bit (36),
  7   232 
  7   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  7   234 
  7   235 
  7   236 
  7   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      498 
      499  /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  8     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  8     7*     Modified to add partial_link structure for an object MSF partially snapped
  8     8*     link.
  8     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  8    10*     install(86-11-20,MR12.0-1222):
  8    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 
  8    15 /* format: style3 */
  8    16 /* everything you ever wanted in a linkage section */
  8    17 
  8    18 /*
  8    19* Last Modified (Date and Reason):
  8    20*  15 Nov 1971 by C Garman 
  8    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  8    22*   6/75 by S.Webber to comment existing structures better
  8    23*   9/77 by M. Weaver to add run_depth to link
  8    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  8    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  8    26**/
  8    27 
  8    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  8    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  8    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  8    31 	  2 mbz		bit (6) unal,
  8    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  8    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  8    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  8    35 	  2 mbz2		bit (12) unal,
  8    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  8    37 
  8    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  8    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  8    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  8    41 	  2 mbz1		bit (12) unal,
  8    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  8    43 	  
  8    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  8    45 	  2 mbz2		bit (3) unal,
  8    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  8    47 	  2 mbz3		bit (3) unal,
  8    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  8    49 
  8    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  8    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  8    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  8    53 	  2 original_linkage_ptr
  8    54 			ptr unal,			/* pointer to linkage section in object segment */
  8    55 	  2 unused	bit (72),
  8    56 	  2 stats,
  8    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  8    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  8    59 	    3 segment_number
  8    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  8    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  8    62 
  8    63 declare	1 linkage_header_flags
  8    64 			aligned based,		/* overlay of def_ptr for flags */
  8    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  8    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  8    67 	  2 perprocess_static
  8    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  8    69 	  2 pad2		bit (6) unaligned;
  8    70 
  8    71 declare	1 virgin_linkage_header
  8    72 			aligned based,		/* template for linkage header in object segment */
  8    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  8    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  8    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  8    76 						/* offset of definition section */
  8    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  8    78 						/* offset of trap-at-first-reference offset array */
  8    79 	  2 filled_in_later bit (144),
  8    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  8    81 						/* offset of first link */
  8    82 	  2 linkage_section_lng
  8    83 			fixed bin (18) unsigned unaligned,
  8    84 						/* length of linkage section */
  8    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  8    86 						/* will be segment number of copied linkage */
  8    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  8    88 						/* length of static section */
  8    89 
  8    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  8    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  8    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  8    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  8    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  8    95 						/* LINK18, offset of link defining procedure to call */
  8    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  8    97 						/* LINK18, offser of link defining argument list for trap proc */
  8    98 
  8    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  8   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  8   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  8   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  8   103 
  8   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      499 
      500  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  9     2 
  9     3 /* Declarations for Segment Loading Table header and array.
  9     4*
  9     5*   Used by Initialization and MST Checker subroutines */
  9     6 
  9     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  9     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  9     9     namep ptr,					/* pointer to segment name list block */
  9    10     pathp ptr,					/* pointer to segment's directory path name */
  9    11     aclp ptr;					/* pointer to acl structure */
  9    12 
  9    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  9    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  9    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  9    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  9    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  9    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  9    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  9    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  9    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  9    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  9    23 
  9    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  9    25 
  9    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  9    27 	2 pad bit (18) unal,
  9    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  9    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  9    30 
  9    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  9    32 	2 count fixed bin (17),			/* number of segment names in this block */
  9    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  9    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  9    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  9    36 	  3 pad bit (5) unal,
  9    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  9    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  9    39 
  9    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  9    41 	2 size fixed bin (17),			/* length of pathname */
  9    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  9    43 	2 acls fixed bin;				/* ACL list starts here */
  9    44 
  9    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  9    46 	2 count fixed bin,				/* number of entries in acl list */
  9    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  9    48 	  3 userid char (32),			/* user specification */
  9    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  9    50 	  3 pad bit (36) aligned,
  9    51 	  3 code fixed bin;
  9    52 
  9    53 
  9    54 /* END INCLUDE FILE slt.incl.pl1 */
      500 
      501  /* BEGIN INCLUDE FILE slte.incl.pl1 */
 10     2 /* Declaration for Segment Loading Table Entry structure.
 10     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
 10     4 /* modified 5/4/76 by Noel I. Morris	*/
 10     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
 10     6 /* format: style3 */
 10     7 
 10     8 dcl	sltep		ptr;
 10     9 
 10    10 dcl	1 slte_uns	based (sltep) aligned,
 10    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 10    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 10    13 /**** End of word 1 */
 10    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
 10    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 10    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 10    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
 10    18 	  2 layout_seg	bit (1),			/* mailbox & such */
 10    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
 10    20 	  2 pad1		bit (3),			/* unused */
 10    21 	  2 wired		bit (1),			/* segment is wired if ON */
 10    22 	  2 paged		bit (1),			/* segment is paged if ON */
 10    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
 10    24 	  2 pad3		bit (2),
 10    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 10    26 /**** End of 1st half of word 2 */
 10    27 	  2 pad4		bit (3),
 10    28 	  2 branch_required bit (1),			/* path name supplied if ON */
 10    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 10    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 10    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 10    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 10    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 10    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 10    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 10    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 10    37 /***** End of word 2 */
 10    38 	  2 pad5		bit (6),
 10    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
 10    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
 10    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
 10    42 /***** End of word 3 */
 10    43 	  2 pad7		bit (3),
 10    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
 10    45 	  2 bit_count	fixed bin (24) uns
 10    46 	  )		unaligned;		/* bitcount of segment */
 10    47 
 10    48 dcl	1 slte		based (sltep) aligned,
 10    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 10    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 10    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
 10    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 10    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 10    54 	  2 firmware_seg    bit (1),
 10    55 	  2 layout_seg      bit (1),
 10    56 	  2 breakpointable  bit (1),
 10    57 	  2 pad2		bit (3),
 10    58 	  2 wired		bit (1),			/* segment is wired if ON */
 10    59 	  2 paged		bit (1),			/* segment is paged if ON */
 10    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
 10    61 	  2 pad3		bit (2),
 10    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 10    63 	  2 pad4		bit (3),
 10    64 	  2 branch_required bit (1),			/* path name supplied if ON */
 10    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 10    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 10    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 10    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 10    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 10    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 10    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 10    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 10    73 	  2 pad5		bit (6),
 10    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
 10    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
 10    76 	  2 segno		bit (18),			/* text/link segment number */
 10    77 	  2 pad6		bit (3),
 10    78 	  2 max_length	bit (9),			/* maximum length for segment */
 10    79 	  2 bit_count	bit (24)
 10    80 	  )		unaligned;		/* bitcount of segment */
 10    81 
 10    82 /* END INCLUDE FILE slte.incl.pl1 */
      501 
      502  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 11     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 11     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 11     4 
 11     5 /* This include file has an ALM version.  Keep 'em in sync! */
 11     6 
 11     7 dcl (
 11     8 
 11     9 /* The following constants define the message action codes.  This indicates
 11    10*how a message is to be handled.  */
 11    11 
 11    12      SYSERR_CRASH_SYSTEM	init (1),			
 11    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 11    14 
 11    15      SYSERR_TERMINATE_PROCESS	init (2),
 11    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 11    17 
 11    18      SYSERR_PRINT_WITH_ALARM	init (3),
 11    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 11    20 
 11    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 11    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 11    23 
 11    24      SYSERR_LOG_OR_PRINT	init (4),
 11    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 11    26 
 11    27      SYSERR_LOG_OR_DISCARD	init (5),
 11    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 11    29 
 11    30 
 11    31 /* The following constants are added to the normal severities to indicate
 11    32*different sorting classes of messages.  */
 11    33 
 11    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 11    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 11    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 11    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 11    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 11    39 	) fixed bin internal static options (constant);
 11    40 
 11    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      502 
      503 
      504 
      505 /* BEGIN MESSAGE DOCUMENTATION
      506*
      507*   Message:
      508*   load_mst: Out of space in mst area of bce partition.
      509*
      510*   S: $crash
      511*
      512*   T: $init
      513*
      514*   M: There is not enough room in the mst area of the bce partition to
      515*   hold collections 2.0 and 3.0.
      516*
      517*   A: The size of this area will need to be increased.
      518*   $boot_tape
      519*
      520*   Message:
      521*   load_mst: NAME can't be placed into file partition.
      522*
      523*   S: $crash
      524*
      525*   T: $init
      526*
      527*   M: An error occurred while adding the named file from the mst into the
      528*   bootload Multics file system.
      529*
      530*   A: $recover
      531*   $boot_tape
      532*
      533*   Message:
      534*   load_mst: unexpected control type TTT
      535*
      536*   S: $crash
      537*
      538*   T: $init
      539*
      540*   M: A segment control word was found out of sequence on the bootload tape.
      541*
      542*   A: $recover
      543*   $boot_tape
      544*
      545*   Message:
      546*   load_mst: bad header size SSS
      547*
      548*   S: $crash
      549*
      550*   T: $init
      551*
      552*   M: A bad segment header was found on the bootload tape.
      553*
      554*   A: $recover
      555*   $boot_tape
      556*
      557*   Message:
      558*   load_mst: unknown control type TTT
      559*
      560*   S: $crash
      561*
      562*   T: $init
      563*
      564*   M: A bad segment control word was found on the bootload tape.
      565*
      566*   A: $recover
      567*   $boot_tape
      568*
      569*   Message:
      570*   load_mst: XXX. out of WWW. pages used in disk mst area.
      571*
      572*   S: $info
      573*
      574*   M: This message shows the amount of the mst area of the bce partition that 
      575*   is used to hold the mst.
      576*
      577*   A: $ignore
      578*   $boot_tape
      579*
      580*   Message:
      581*   load_mst: Unexpected DEFS/LINKAGE
      582*
      583*   S: $crash
      584*
      585*   T: $init
      586*
      587*   M: A linkage or definitions section was found out of sequence in the mst source.
      588*
      589*   A: $recover
      590*   $boot_tape
      591*
      592*   Message:
      593*   load_mst: Missing linkage or defs.
      594*
      595*   S: $crash
      596*
      597*   T: $init
      598*
      599*   M: A linkage or definitions section which should be in the
      600*   mst source appears to be missing.
      601*
      602*   A: $recover
      603*   $boot_tape
      604*
      605*   Message:
      606*   load_mst: error from slt_manager$build_entry
      607*
      608*   S: $crash
      609*
      610*   T: $init
      611*
      612*   M: $err
      613*
      614*   A: $recover
      615*   $boot_tape
      616*
      617*   Message:
      618*   load_mst: too many bce command segments.
      619*
      620*   S: $crash
      621*
      622*   T: $init
      623*
      624*   M: An exceptionally large number of segments appeared in collection 1.5.
      625*   This probably indicates an error in the mst.
      626*
      627*   A: $recover
      628*   $boot_tape
      629*
      630*   END MESSAGE DOCUMENTATION */
      631 
      632      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0816.1  load_mst.pl1                      >spec>install>1112>load_mst.pl1
492          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
493          2    11/18/84  1346.2  bce_breakpoint_page.incl.pl1      >ldd>include>bce_breakpoint_page.incl.pl1
494          3    07/11/84  0937.3  bce_partition_layout.incl.pl1     >ldd>include>bce_partition_layout.incl.pl1
495          4    10/20/82  0938.5  hc_definitions_seg.incl.pl1       >ldd>include>hc_definitions_seg.incl.pl1
496          5    10/20/82  0938.6  hc_linkage_seg.incl.pl1           >ldd>include>hc_linkage_seg.incl.pl1
497          6    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
498          7    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
499          8    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
500          9    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
501         10    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
502         11    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000023 constant        fixed bin(17,0)          initial dcl 11-7 set ref 161* 392*
BKPT_page_sentinel              000000 constant        char(4)                  initial packed unaligned dcl 2-30 ref 365
CRASH                           000025 constant        fixed bin(17,0)          initial dcl 11-7 set ref 240* 244* 251* 274* 299*
                                                                                  314* 333* 346* 347* 421*
MST_AREA_RECORDX                       constant        fixed bin(17,0)          initial dcl 3-12 ref 128 149 161 350 355 432 439
abs_seg                   1(05)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 set ref
                                                                                  204* 338*
access                    1            based           bit(4)                   level 2 packed packed unaligned dcl 10-48 ref 340
addr                                                   builtin function         dcl 31 ref 129 129 131 131 131 131 141 142 143 165
                                                                                  165 165 165 187 188 188 190 190 190 190 195 195
                                                                                  203 207 207 210 210 215 215 222 222 222 222 234
                                                                                  279 281 282 283 337 355 355 363 363 365 432 432
                                                                                  439 439 444 459 459
addrel                                                 builtin function         dcl 32 ref 285 303 365 384 444
ai_linkage$                     000632 external static fixed bin(17,0)          dcl 33 set ref 282
as_linkage$                     000634 external static fixed bin(17,0)          dcl 34 set ref 283
aste                                   based           structure                level 1 dcl 1-11
astep                           002126 automatic       pointer                  dcl 1-9 set ref 129* 130 153 153 159* 188* 189 197
                                                                                  197 217* 357 357 368* 430* 433 433 438 441 441
baseptr                                                builtin function         dcl 35 ref 173 173 209
bce_abs_seg$add                 000636 constant        entry                    external dcl 36 ref 174
bce_command_seg_info            000010 internal static structure                level 1 dcl 37
bin                                                    builtin function         dcl 46 ref 197 357 438 441
bit                                                    builtin function         dcl 47 ref 197 357 441
bit_count                 3(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 10-10
                                                                                  ref 388
bkpt_page                              based           structure                level 1 dcl 2-9
bootload_fs_$flush_sys          000640 constant        entry                    external dcl 48 ref 124
bootload_fs_$put_ptr            000642 constant        entry                    external dcl 49 ref 391
breakpoint                             based           structure                level 1 dcl 2-21
breakpointable            1(08)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 set ref
                                                                                  341* 365
code                            000100 automatic       fixed bin(35,0)          dcl 50 set ref 391* 392*
combine_link              1(27)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 278
control_word                           based           structure                level 1 dcl 51
copy                                   based           bit(9437184)             dcl 55 set ref 212*
copying_sdw                     000102 automatic       fixed bin(71,0)          dcl 56 set ref 206* 207 207 210 210
count                                  parameter       fixed bin(18,0)          dcl 377 in procedure "load_file_segment" set ref 373
                                                                                  389 389 393*
count                     0(18) 000100 automatic       fixed bin(18,0)          level 2 in structure "my_control_word" packed packed
                                                                                  unsigned unaligned dcl 456 in procedure
                                                                                  "read_control_word" set ref 461
count                                  parameter       fixed bin(18,0)          dcl 270 in procedure "load_command_seg" set ref 264
                                                                                  285 285 287* 303 305* 308 363*
count                           002156 automatic       fixed bin(18,0)          dcl 231 in procedure "load_collection" set ref 238*
                                                                                  244 244* 248* 250* 254* 255* 260*
count                                  parameter       fixed bin(18,0)          dcl 455 in procedure "read_control_word" set ref 451
                                                                                  461*
count                                  parameter       fixed bin(18,0)          dcl 483 in procedure "save_header" set ref 479 488*
                                                                                  489
count                     0(18)        based           fixed bin(18,0)          level 2 in structure "control_word" packed packed
                                                                                  unsigned unaligned dcl 51 in procedure "load_mst"
                                                                                  ref 475
count                                  parameter       fixed bin(18,0)          dcl 401 in procedure "load_mst_segment" set ref 397
                                                                                  405*
count                                  parameter       fixed bin(18,0)          dcl 416 in procedure "read_and_save" set ref 409 421
                                                                                  423 445* 446
count                                  parameter       fixed bin(18,0)          dcl 469 in procedure "save_control_word" set ref 465
                                                                                  475*
csl                      12            based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  153* 197* 357* 433* 438 441*
cur_length                2            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 10-10
                                                                                  set ref 339 342*
def_ptr                                based           pointer                  level 2 dcl 8-50 set ref 310*
definitions                            based           structure                level 1 dcl 4-6
definitions_$                   000644 external static fixed bin(17,0)          dcl 57 set ref 143
definitions_ptr                 002130 automatic       pointer                  dcl 4-4 set ref 143* 302 303 307 308
defs                      1(29)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 298
dimension                                              builtin function         dcl 58 ref 346
disk_mst_seg$                   000646 external static bit(9437184)             dcl 59 set ref 129 129 131 131 165 165 188 188 190
                                                                                  190 212 222 222 363 363 365 444
disk_mst_seg_sdw                000104 automatic       fixed bin(71,0)          dcl 60 set ref 129* 131 131 164* 165 165 188* 190
                                                                                  190 221* 222 222
divide                                                 builtin function         dcl 61 ref 161 161 388 389 424 431
dot                       2            based           structure                array level 2 dcl 4-6
entries                   2     000010 internal static structure                array level 2 dcl 37 set ref 346
expect_defs                     000106 automatic       bit(1)                   dcl 62 set ref 138* 276* 299 300* 314
expect_link                     000107 automatic       bit(1)                   dcl 63 set ref 139* 274 275* 314 315*
file_length                     000100 automatic       fixed bin(21,0)          dcl 378 set ref 388* 389 389* 391*
file_name                       000101 automatic       char(32)                 packed unaligned dcl 379 set ref 387* 391*
file_name_lth                   000111 automatic       fixed bin(17,0)          dcl 380 set ref 385* 386 386* 386 387
hc_linkage_seg                         based           structure                level 1 dcl 5-7
hclsp                           002132 automatic       pointer                  dcl 5-6 set ref 279* 281* 282* 283* 284 285
header                                 based           structure                level 2 dcl 2-9
header_area                     000110 automatic       fixed bin(35,0)          array dcl 64 set ref 234 244
header_ptr                             parameter       pointer                  dcl 484 in procedure "save_header" ref 479 489
header_ptr                             parameter       pointer                  dcl 271 in procedure "load_command_seg" set ref 264
                                                                                  273 298 315 332*
header_ptr                             parameter       pointer                  dcl 381 in procedure "load_file_segment" ref 373 383
header_ptr                             parameter       pointer                  dcl 402 in procedure "load_mst_segment" ref 397
header_ptr                      002060 automatic       pointer                  dcl 65 in procedure "load_mst" set ref 234* 248*
                                                                                  254*
header_read                            based           bit(36)                  array dcl 485 set ref 489* 489
index                                                  builtin function         dcl 66 ref 386
init_seg                  1(22)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 279
                                                                                  282
last_partition_record           000100 automatic       fixed bin(20,0)          dcl 417 set ref 424* 425 438 441
last_partition_word             000101 automatic       fixed bin(26,0)          dcl 418 set ref 423* 424 447
last_sltep                      002062 automatic       pointer                  dcl 67 set ref 278 279 279 282 322*
length                                                 builtin function         dcl 68 in procedure "load_mst" ref 385 386 386
length                    2(18)        based           fixed bin(17,0)          array level 3 in structure "definitions" packed
                                                                                  packed unaligned dcl 4-6 in procedure "load_mst"
                                                                                  set ref 308*
length                    4     000010 internal static fixed bin(17,0)          array level 3 in structure "bce_command_seg_info"
                                                                                  dcl 37 in procedure "load_mst" set ref 173* 194
                                                                                  197 212 212 351*
link_provided             1(24)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 315
link_ptr                        002064 automatic       pointer                  dcl 69 set ref 292* 293 294 310
link_sect                 1(25)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 273
link_sect_wired           1(26)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 279
linkage_header                         based           structure                level 1 dcl 8-50
load_control_word               002066 automatic       entry variable           dcl 70 set ref 120* 145* 154* 238 250 255 260
load_header                     002072 automatic       entry variable           dcl 71 set ref 121* 146* 155* 248
load_segment                    002076 automatic       entry variable           dcl 72 set ref 122* 147* 156* 254
lot                                    based           structure                level 1 dcl 6-6
lot$                            000650 external static structure                level 1 packed packed unaligned dcl 73 set ref 142
lotp                            002134 automatic       pointer                  dcl 6-4 set ref 142* 293
lp                                     based           pointer                  array level 2 packed packed unaligned dcl 6-6 set
                                                                                  ref 293*
make_sdw                        000652 constant        entry                    external dcl 74 ref 205
make_sdw$no_pages               000654 constant        entry                    external dcl 75 ref 129 188
map_onto_disk                   000656 constant        entry                    external dcl 76 ref 173
max_length                3(03)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 10-10
                                                                                  set ref 339* 342*
mc                                     based           structure                level 1 dcl 7-12
mod                                                    builtin function         dcl 77 ref 285
msl                       4            based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  153* 197* 357* 433* 441*
my_control_word                 000100 automatic       structure                level 1 dcl 456 set ref 459 459
name                      2            based           char(32)                 array level 3 packed packed unaligned dcl 9-31 set
                                                                                  ref 385 386 387 392*
namep                           002140 automatic       pointer                  dcl 9-7 set ref 384* 385 386 387 392
names                     1            based           structure                array level 2 dcl 9-31
next_free_ptr                          based           pointer                  level 2 in structure "definitions" dcl 4-6
                                                                                  in procedure "load_mst" set ref 302 303*
next_free_ptr                          based           pointer                  level 2 in structure "hc_linkage_seg" dcl 5-7
                                                                                  in procedure "load_mst" set ref 284 285*
next_partition_word             002102 automatic       fixed bin(26,0)          dcl 78 set ref 126* 161 161 360* 360 423 431 444
                                                                                  447*
null                                                   builtin function         dcl 79 ref 333 390 392
number                    1     000010 internal static fixed bin(17,0)          initial level 2 dcl 37 set ref 135* 172 192 345* 345
                                                                                  346 349 350 351 352
offset                    2            based           fixed bin(18,0)          array level 3 packed packed unsigned unaligned
                                                                                  dcl 4-6 set ref 307*
page_table                             based           bit(36)                  array dcl 80 set ref 195 195 355 355 432 432 439 439
partition_left                  002103 automatic       fixed bin(26,0)          dcl 81 set ref 128* 347 361* 361 421 446* 446
pc$cleanup                      000660 constant        entry                    external dcl 82 ref 159 217 368 430
pc_wired$write                  000662 constant        entry                    external dcl 83 ref 216
perm_seg_astep                  002104 automatic       pointer                  dcl 84 set ref 205* 216*
perm_seg_ptp                    002106 automatic       pointer                  dcl 85 set ref 205*
perm_seg_sdw                    002110 automatic       fixed bin(71,0)          dcl 86 set ref 205* 206 215 215
permanent                 5     000010 internal static bit(1)                   array level 3 dcl 37 set ref 193 352*
pmut$camp                       000664 constant        entry                    external dcl 87 ref 198 358 442
pmut$swap_sdw                   000666 constant        entry                    external dcl 88 ref 131 165 190 210 215 222
pre_link_hc                     000670 constant        entry                    external dcl 89 ref 177
pre_linked                      000010 internal static bit(1)                   level 2 dcl 37 set ref 136* 176 178*
ptp                             002112 automatic       pointer                  dcl 90 set ref 129* 188* 195 195 355 355 432 432 439
                                                                                  439
ptw_num                         002114 automatic       fixed bin(17,0)          dcl 91 set ref 194* 195 195 195* 354* 355 355 355*
                                                                                  438* 439 439 439*
ptw_util_$make_disk             000672 constant        entry                    external dcl 92 ref 195 432
ptw_util_$make_null_disk        000674 constant        entry                    external dcl 93 ref 355 439
pvt$root_pvtx                   000676 external static fixed bin(17,0)          dcl 94 set ref 130 173* 189
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  130* 189*
read_ptr                        000100 automatic       pointer                  dcl 486 set ref 488* 489
rtrim                                                  builtin function         dcl 95 ref 385
saved_ptr                              parameter       pointer                  dcl 419 set ref 409 444* 445*
sdw_util_$set_access            000700 constant        entry                    external dcl 96 ref 207
seg                      10            based           structure                array level 2 dcl 9-13 set ref 203 337
seg_len                         000106 automatic       fixed bin(17,0)          dcl 330 set ref 339* 342 342* 347 351 354 357 359
                                                                                  360 361 365
seg_number                      002115 automatic       fixed bin(15,0)          dcl 97 set ref 202* 203 205* 209 335* 337 349
seg_ptr                         002116 automatic       pointer                  dcl 98 set ref 209* 210* 212 215* 284* 285 287* 292
                                                                                  302* 303 305* 307 310 318 332* 333 335 390* 391*
                                                                                  392 393*
segment_number            7            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 8-50
                                                                                  set ref 294*
segment_ptr                     000100 automatic       pointer                  dcl 403 set ref 405*
segnam                                 based           structure                level 1 dcl 9-31
segno                                                  builtin function         dcl 99 ref 129 129 188 188 319 335
segnum                    2     000010 internal static fixed bin(15,0)          array level 3 dcl 37 set ref 173 173 174* 202 349*
sentinel                 65            based           char(4)                  level 3 packed packed unaligned dcl 2-9 set ref 365*
size                                                   builtin function         dcl 100 ref 244 384
slot_num                        002120 automatic       fixed bin(17,0)          dcl 101 set ref 172* 173 173 173 173 174* 192* 193
                                                                                  194 195 197 202 212 212*
slt                                    based           structure                level 1 dcl 9-13
slt$                            000702 external static fixed bin(17,0)          dcl 102 set ref 141 187
slt_manager$build_entry         000704 constant        entry                    external dcl 103 ref 332
slte                                   based           structure                level 1 dcl 10-48 set ref 384
slte_uns                               based           structure                level 1 dcl 10-10
sltep                           002142 automatic       pointer                  dcl 10-8 set ref 203* 204 322 337* 338 339 339 340
                                                                                  341 342 342 352 365 383* 384 384 388
sltp                            002136 automatic       pointer                  dcl 9-7 set ref 141* 187* 203 337
start_partition_record          002121 automatic       fixed bin(20,0)          dcl 104 set ref 127* 149 350 355 359* 359 425 431*
                                                                                  432 438 439 441 444
starting_record           3     000010 internal static fixed bin(18,0)          array level 3 dcl 37 set ref 173* 195 350*
stats                     6            based           structure                level 2 dcl 8-50
substr                                                 builtin function         dcl 105 set ref 212* 212 340 387
sys_boot_info$bce_part_frec     000706 external static fixed bin(20,0)          dcl 106 ref 149 350 355 432 439
sys_boot_info$bce_part_nrec     000710 external static fixed bin(20,0)          dcl 107 ref 128 161
sys_boot_info$mst_past_bce_frec 000712 external static fixed bin(20,0)          dcl 108 set ref 149*
syserr                          000714 constant        entry                    external dcl 109 ref 161 240 244 251 274 299 314 333
                                                                                  346 347 421
syserr$error_code               000716 constant        entry                    external dcl 110 ref 392
tape_reader                     000720 constant        entry                    external dcl 111 ref 121 146 287 305 363 393 445 459
temp_seg                  1(23)        based           bit(1)                   level 2 packed packed unaligned dcl 10-48 ref 352
text_no                         002122 automatic       fixed bin(15,0)          dcl 112 set ref 293 294 307 308 319*
text_ptr                        002124 automatic       pointer                  dcl 113 set ref 318* 319
type                            002157 automatic       fixed bin(17,0)          dcl 232 in procedure "load_collection" set ref 238*
                                                                                  239 240 240* 250* 251 251* 255* 260*
type                                   parameter       fixed bin(17,0)          dcl 457 in procedure "read_control_word" set ref 451
                                                                                  460*
type                                   parameter       fixed bin(17,0)          dcl 470 in procedure "save_control_word" set ref 465
                                                                                  474*
type                                   based           fixed bin(17,0)          level 2 in structure "control_word" packed packed
                                                                                  unaligned dcl 51 in procedure "load_mst" ref 474
type                            000100 automatic       fixed bin(17,0)          level 2 in structure "my_control_word" packed packed
                                                                                  unaligned dcl 456 in procedure "read_control_word"
                                                                                  set ref 460
wi_linkage$                     000722 external static fixed bin(17,0)          dcl 114 set ref 279
word_ptr                        000100 automatic       pointer                  dcl 471 set ref 473* 474 475
wordno                                                 builtin function         dcl 115 ref 307
ws_linkage$                     000724 external static fixed bin(17,0)          dcl 116 set ref 281

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BCE_PAGING_AREA_LTH                    internal static fixed bin(17,0)          initial dcl 3-11
BCE_PAGING_AREA_RECORDX                internal static fixed bin(17,0)          initial dcl 3-10
BCE_PART_LTH                           internal static fixed bin(17,0)          initial dcl 3-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 11-7
CRASH_HANDLER_RECORDX                  internal static fixed bin(17,0)          initial dcl 3-9
FAULT_TAG_1                            internal static bit(6)                   initial packed unaligned dcl 8-100
FAULT_TAG_2                            internal static bit(6)                   initial packed unaligned dcl 8-101
FAULT_TAG_3                            internal static bit(6)                   initial packed unaligned dcl 8-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 8-99
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 11-7
LOG                                    internal static fixed bin(17,0)          initial dcl 11-7
SAVED_IMAGE_RECORDX                    internal static fixed bin(17,0)          initial dcl 3-8
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 11-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 11-7
abx                                    internal static fixed bin(17,0)          initial dcl 7-42
aclp                                   automatic       pointer                  dcl 9-7
acls                                   based           structure                level 1 dcl 9-45
apx                                    internal static fixed bin(17,0)          initial dcl 7-42
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
bbx                                    internal static fixed bin(17,0)          initial dcl 7-42
bkpt_page_ptr                          automatic       pointer                  dcl 2-19
bpx                                    internal static fixed bin(17,0)          initial dcl 7-42
breakpoint_ptr                         automatic       pointer                  dcl 2-28
fr_traps                               based           structure                level 1 dcl 8-90
isot                                   based           structure                level 1 dcl 6-13
isot1                                  based           structure                array level 1 dcl 6-16
isotp                                  automatic       pointer                  dcl 6-12
lbx                                    internal static fixed bin(17,0)          initial dcl 7-42
linkage_header_flags                   based           structure                level 1 dcl 8-63
lot_fault                              internal static bit(36)                  initial dcl 6-9
lpx                                    internal static fixed bin(17,0)          initial dcl 7-42
mcp                                    automatic       pointer                  dcl 7-10
name_seg                               based           structure                level 1 dcl 9-26
names_ptr                              automatic       pointer                  dcl 9-7
object_link                            based           structure                level 1 dcl 8-28
partial_link                           based           structure                level 1 dcl 8-38
path                                   based           structure                level 1 dcl 9-40
pathp                                  automatic       pointer                  dcl 9-7
sbx                                    internal static fixed bin(17,0)          initial dcl 7-42
scu                                    based           structure                level 1 dcl 7-56
scup                                   automatic       pointer                  dcl 7-54
scux                                   based           structure                level 1 dcl 7-207
seg_aste                               based           structure                level 1 dcl 1-96
spx                                    internal static fixed bin(17,0)          initial dcl 7-42
virgin_linkage_header                  based           structure                level 1 dcl 8-71

NAMES DECLARED BY EXPLICIT CONTEXT.
init_commands                   000453 constant        entry                    external dcl 168
load_bce_segment                001556 constant        entry                    internal dcl 326 ref 290 317
load_collection                 001067 constant        entry                    internal dcl 225 ref 123 148 157 158
load_command_seg                001262 constant        entry                    internal dcl 264 ref 147
load_file_segment               002101 constant        entry                    internal dcl 373 ref 122
load_mst                        000213 constant        entry                    external dcl 17
load_mst_segment                002275 constant        entry                    internal dcl 397 ref 156
make_permanent                  000547 constant        entry                    external dcl 182
read_and_save                   002316 constant        entry                    internal dcl 409 ref 405 473 488
read_control_word               002535 constant        entry                    internal dcl 451 ref 120 145
save_control_word               002567 constant        entry                    internal dcl 465 ref 154
save_header                     002620 constant        entry                    internal dcl 479 ref 155

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3322        4250    2657        3332
Length      4752    2657       726         465     443         622

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
load_mst                           1220 external procedure  is an external procedure.  
load_collection                         internal procedure  shares stack frame of external procedure load_mst.  
load_command_seg                    144 internal procedure  is assigned to an entry variable.  
load_bce_segment                        internal procedure  shares stack frame of internal procedure load_command_seg.  
load_file_segment                   116 internal procedure  is assigned to an entry variable.  
load_mst_segment                     74 internal procedure  is assigned to an entry variable.  
read_and_save                        94 internal procedure  is called by several nonquick procedures.  
read_control_word                    74 internal procedure  is assigned to an entry variable.  
save_control_word                    76 internal procedure  is assigned to an entry variable.  
save_header                          74 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 bce_command_seg_info        load_mst

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
load_command_seg         000106 seg_len                     load_bce_segment
load_file_segment        000100 file_length                 load_file_segment
                         000101 file_name                   load_file_segment
                         000111 file_name_lth               load_file_segment
load_mst                 000100 code                        load_mst
                         000102 copying_sdw                 load_mst
                         000104 disk_mst_seg_sdw            load_mst
                         000106 expect_defs                 load_mst
                         000107 expect_link                 load_mst
                         000110 header_area                 load_mst
                         002060 header_ptr                  load_mst
                         002062 last_sltep                  load_mst
                         002064 link_ptr                    load_mst
                         002066 load_control_word           load_mst
                         002072 load_header                 load_mst
                         002076 load_segment                load_mst
                         002102 next_partition_word         load_mst
                         002103 partition_left              load_mst
                         002104 perm_seg_astep              load_mst
                         002106 perm_seg_ptp                load_mst
                         002110 perm_seg_sdw                load_mst
                         002112 ptp                         load_mst
                         002114 ptw_num                     load_mst
                         002115 seg_number                  load_mst
                         002116 seg_ptr                     load_mst
                         002120 slot_num                    load_mst
                         002121 start_partition_record      load_mst
                         002122 text_no                     load_mst
                         002124 text_ptr                    load_mst
                         002126 astep                       load_mst
                         002130 definitions_ptr             load_mst
                         002132 hclsp                       load_mst
                         002134 lotp                        load_mst
                         002136 sltp                        load_mst
                         002140 namep                       load_mst
                         002142 sltep                       load_mst
                         002156 count                       load_collection
                         002157 type                        load_collection
load_mst_segment         000100 segment_ptr                 load_mst_segment
read_and_save            000100 last_partition_record       read_and_save
                         000101 last_partition_word         read_and_save
read_control_word        000100 my_control_word             read_control_word
save_control_word        000100 word_ptr                    save_control_word
save_header              000100 read_ptr                    save_header

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        call_int_other      return_mac          mdfx1
ext_entry           int_entry           set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bce_abs_seg$add               bootload_fs_$flush_sys        bootload_fs_$put_ptr          make_sdw
make_sdw$no_pages             map_onto_disk                 pc$cleanup                    pc_wired$write
pmut$camp                     pmut$swap_sdw                 pre_link_hc                   ptw_util_$make_disk
ptw_util_$make_null_disk      sdw_util_$set_access          slt_manager$build_entry       syserr
syserr$error_code             tape_reader

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
ai_linkage$                   as_linkage$                   definitions_$                 disk_mst_seg$
lot$                          pvt$root_pvtx                 slt$                          sys_boot_info$bce_part_frec
sys_boot_info$bce_part_nrec   sys_boot_info$mst_past_bce_frec                             wi_linkage$
ws_linkage$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000212       120 000220       121 000223       122 000227       123 000232       124 000233       126 000240
    127 000241       128 000242       129 000247       130 000271       131 000276       135 000312       136 000314
    138 000315       139 000316       141 000317       142 000321       143 000323       145 000325       146 000330
    147 000334       148 000337       149 000340       153 000345       154 000351       155 000354       156 000357
    157 000362       158 000363       159 000364       161 000373       164 000432       165 000434       166 000451
    168 000452       172 000460       173 000471       174 000520       175 000531       176 000533       177 000536
    178 000542       180 000545       182 000546       187 000554       188 000557       189 000601       190 000606
    192 000622       193 000633       194 000637       195 000647       196 000667       197 000671       198 000703
    202 000707       203 000714       204 000720       205 000722       206 000736       207 000740       209 000755
    210 000761       212 000774       215 001006       216 001020       217 001036       219 001045       221 001047
    222 001051       223 001066       225 001067       234 001070       238 001072       239 001102       240 001105
    244 001132       248 001161       250 001171       251 001201       254 001227       255 001237       256 001247
    260 001250       261 001260       264 001261       273 001267       274 001275       275 001317       276 001321
    278 001323       279 001327       281 001341       282 001345       283 001354       284 001357       285 001361
    287 001371       288 001401       290 001402       292 001403       293 001407       294 001412       296 001415
    298 001416       299 001421       300 001443       302 001445       303 001450       305 001455       307 001466
    308 001475       310 001501       311 001503       314 001504       315 001530       317 001540       318 001541
    319 001545       322 001551       324 001555       326 001556       332 001557       333 001572       335 001617
    337 001624       338 001630       339 001632       340 001641       341 001644       342 001646       345 001662
    346 001664       347 001706       349 001733       350 001742       351 001746       352 001750       354 001756
    355 001766       356 002006       357 002011       358 002020       359 002025       360 002030       361 002032
    363 002035       365 002051       368 002070       369 002077       373 002100       383 002106       384 002113
    385 002116       386 002130       387 002144       388 002151       389 002155       390 002164       391 002166
    392 002220       393 002260       394 002273       397 002274       405 002302       406 002314       409 002315
    421 002323       423 002347       424 002355       425 002357       430 002362       431 002371       432 002375
    433 002414       438 002422       439 002436       440 002456       441 002461       442 002473       444 002500
    445 002513       446 002524       447 002530       448 002533       451 002534       459 002542       460 002556
    461 002562       462 002565       465 002566       473 002574       474 002607       475 002613       476 002616
    479 002617       488 002625       489 002637       490 002650


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
