	COMPILATION LISTING OF SEGMENT wired_shutdown
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0943.4 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 wired_shutdown$wired_emergency: procedure;
       14 
       15 /* Created by Bernard Greenberg, 03/29/76, when he removed
       16*   wired_shutdown from wired_shutdown and unwired it. What is left
       17*   is a pl1-coded transitional interface between
       18*   ESD and shutdown */
       19 
       20 /*  Modified 06/07/76 by Greenberg for vtoc_man$stabilize */
       21 /*  Modified 03/14/77 by Greenberg for ESD with drive down */
       22 /*  Modified 02/28/82 by J. Bongiovanni to eliminate use of FSDCT, reset PVT entries */
       23 /*  Modified March 1982 by J. Bongiovanni to call shutdown_file_system */
       24 /*  Modified August 1982 by J. Bongiovanni to reset scavenge */
       25 /*  Modified 830620 for new ocdcm_$drain_io call... -E. A. Ranzenbach */
       26 /*  Modified 8/83 for pmut$bce - K. Loepere */
       27 /*  Modified  84-01-17 BIM for get_pvtx$reset. */
       28 
       29 dcl  pc$flush entry;
       30 dcl  page$reset_pvte entry (ptr);
       31 dcl  pmut$bce entry;
       32 dcl  ocdcm_$drain_io entry ();
       33 dcl  syserr entry options (variable);
       34 dcl  vtoc_man$stabilize entry;
       35 dcl  get_pvtx$reset entry;
       36 dcl  pmut$set_mask entry (fixed bin (71), fixed bin (71));
       37 dcl  fsout_vol entry (fixed bin, fixed bin);
       38 dcl  shutdown_file_system entry;
       39 dcl  control char (8) static internal init ("tooearly");
       40 
       41 
       42 dcl  scs$open_level fixed bin (71) ext;
       43 
       44 dcl  pvt$shutdown_state fixed bin external,
       45      pvt$esd_state fixed bin external,
       46      pvt$n_entries fixed bin external,
       47      sst$root_pvtx fixed bin external;
       48 			  
       49 
       50 dcl  save_mask fixed bin (71);
       51 dcl  condition_ entry (char (*), entry);
       52 dcl  pvtx fixed bin;
       53 
       54 /* This portion of emergency shutdown gets entered on the
       55*   shutdown_stack after preliminary resetting has been
       56*   accomplished.					 */
       57 
       58 	call condition_ ("any_other", handler);
       59 	call pmut$set_mask (scs$open_level, save_mask);	/* Open mask to allow I/O interrupts. */
       60 
       61 	if control = "tooearly" | sst$root_pvtx = 0 then do;
       62 	     call syserr (0, "esd before fs enabled");
       63 shut:	     call syserr (0, "shutdown complete");
       64 	     call ocdcm_$drain_io;					/* quies the console...		*/
       65 	     do while ("1"b);
       66 		call pmut$bce;
       67 	     end;
       68 	end;
       69 
       70 	pvt_arrayp = addr (pvt$array);
       71 
       72 	if ^pvt_array (sst$root_pvtx).used then do;
       73 	     call syserr (0, "system already shut down");
       74 	     go to shut;
       75 	end;
       76 
       77 	vtoc_buffer_segp = addr (vtoc_buffer_seg$);	/* Mark trouble pv, perhaps */
       78 	if vtoc_buffer.unsafe_pvtx > 0 then do;
       79 	     pvt_array (vtoc_buffer.unsafe_pvtx).vol_trouble_count = pvt_array (vtoc_buffer.unsafe_pvtx).vol_trouble_count + 1;
       80 	     vtoc_buffer.unsafe_pvtx = 0;
       81 	end;
       82 
       83 	do pvtx = 1 to pvt$n_entries;
       84 	     pvtep = addr (pvt_array (pvtx));
       85 	     if pvte.used
       86 		then do;
       87 		pvte.scav_check_address = "0"b;
       88 		pvte.scavenger_block_rel = ""b;
       89 		call page$reset_pvte (pvtep);
       90 	     end;
       91 	end;
       92 
       93 	call get_pvtx$reset; /* mark trouble for all held pvte's 
       94*			    and release all held pvtes. */
       95 
       96 	call syserr (0, "begin emergency shutdown part 1.");
       97 
       98 
       99 	pvt$shutdown_state = 1;			/* Indicate that esd part 1 started */
      100 	pvt$esd_state = 1;				/* System in ESD */
      101 	call fsout_vol (sst$root_pvtx, 0);		/* Get this fact out */
      102 
      103 	call pc$flush;				/* Flush out all pages in core. */
      104 	pvt$shutdown_state = 2;			/* Indicate that emergency shutdown part 1 is successful. */
      105 	pvt$esd_state = 2;
      106 	call fsout_vol (sst$root_pvtx, 0);
      107 
      108 	call syserr (0, "emergency shutdown part 1 complete.");
      109 
      110 	call vtoc_man$stabilize;			/* Get VTOC buffers in shape */
      111 	call shutdown_file_system;			/* Try to complete a normal shutdown now. */
      112 	return;					/* Should never happen */
      113 
      114 enable:	entry;
      115 	control = "enabled";
      116 	return;
      117 
      118 handler:	proc (mcptr, condname, coptr, infoptr, cont);
      119 
      120 dcl (mcptr, coptr, infoptr) ptr;
      121 dcl  condname char (*);
      122 dcl  cont bit (1);
      123 
      124 	     call syserr (1, "wired_shutdown: ^a fault during emergency shutdown", condname);
      125 
      126 	end handler;
      127 
      128 	 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  1     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1     8*     Add the support for subvolumes
  1     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  1    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  1    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  1    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  1    14*     Added inconsistent_dbm bit for determining the status of volume
  1    15*     dumper bit maps.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18      dcl	   pvt$array	      aligned external;
  1    19      dcl	   pvt$max_n_entries      fixed bin external;
  1    20 
  1    21      dcl	   pvt_arrayp	      ptr;
  1    22      dcl	   pvtep		      ptr;
  1    23 
  1    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  1    25 
  1    26      dcl	   1 pvte		      based (pvtep) aligned,
  1    27 
  1    28 	     2 pvid	      bit (36),		/* physical volume ID */
  1    29 
  1    30 	     2 lvid	      bit (36),		/* logical volume ID */
  1    31 
  1    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  1    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  1    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  1    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  1    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  1    37 	     2 pad3	      bit (2) unaligned,
  1    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  1    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  1    40 
  1    41 
  1    42 
  1    43 	     2 devname	      char (4),		/* device name */
  1    44 
  1    45 	     (2 device_type	      fixed bin (8),	/* device type */
  1    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  1    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  1    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  1    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  1    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  1    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  1    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  1    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  1    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  1    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  1    56 	     2 scav_check_address
  1    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  1    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  1    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  1    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  1    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  1    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  1    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  1    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  1    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  1    66 
  1    67 
  1    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  1    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  1    70 
  1    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  1    72 
  1    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  1    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  1    75 
  1    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  1    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  1    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  1    79 	     2 records_per_cyl    fixed bin,
  1    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  1    81 	     2 sv_name            char (2) aligned,
  1    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  1    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  1    84 
  1    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  1    86 	     2 pad2	      bit (18) unaligned,
  1    87 
  1    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  1    89 
  1    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  1    91 
  1    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  1    93 
  1    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  1    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  1    96 
  1    97 
  1    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  1    99 
  1   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  1   101 
  1   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  1   103 
  1   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  1   105 
  1   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  1   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  1   108 
  1   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  1   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  1   111 
  1   112 
  1   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  1   114 	   VOLMAP_ASYNC_READ      init (1),
  1   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  1   116 
  1   117 
  1   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      128 
      129 	 /*  START OF:	vtoc_buffer.incl.pl1   November 1982      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3      
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  2     7*     audit(86-05-27,GDixon), install(86-07-18,MR12.0-1098):
  2     8*     Add the software read-alter-rewrite when needed for devices that do only
  2     9*     512 word IO.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 dcl	   vtoc_buffer_seg$	      ext;
  2    14 
  2    15      dcl	   vtoc_buffer_segp	      ptr;
  2    16      dcl	   vtoc_buf_descp	      ptr;
  2    17      dcl	   vtoc_bufp	      ptr;
  2    18      dcl	   vtoc_buf_desc_arrayp   ptr;
  2    19      dcl	   vtoc_buf_arrayp	      ptr;
  2    20 
  2    21      dcl	   vtoc_buf_n_buffers     fixed bin;
  2    22      dcl	   vtoc_buf_n_buckets     fixed bin;
  2    23 
  2    24 
  2    25      dcl	   1 vtoc_buffer	      aligned based (vtoc_buffer_segp),
  2    26 
  2    27 	     2 lock,				/* Global lock for VTOC buffers */
  2    28 	       3 processid	      bit (36) aligned,	/* Owner */
  2    29 	       3 wait_event	      bit (36) aligned,	/* For lock */
  2    30 	       3 notify_sw	      bit (1) aligned,	/* ON => notify on unlock */
  2    31 
  2    32 	     2 n_bufs	      fixed bin,		/* Number of full VTOCE buffers */
  2    33 	     2 n_hash_buckets     fixed bin,		/* Number of hash table buckets */
  2    34 	     2 hash_mask	      bit (36) aligned,	/* Mask for hash algorithm */
  2    35 	     2 abs_addr	      fixed bin (24),	/* Absolute address of vtoc_buffer_seg */
  2    36 	     2 wait_event_constant fixed bin (36) uns unal,    /* Constant to add to part index to form wait event */
  2    37 	     2 buf_desc_offset    bit (18),		/* Offset of buf_desc */
  2    38 	     2 buf_offset	      bit (18),		/* Offset of buf */
  2    39 	     2 hash_table_offset  bit (18),		/* Offset of hash_table */
  2    40 	     2 search_index	      fixed bin,		/* Roving pointer for buffer selection */
  2    41 	     2 unsafe_pvtx	      fixed bin,		/* PVTE index with update in progress */
  2    42 	     2 scavenger_free_p_clock
  2    43                                     fixed bin (35),	/* Pseudo-Clock for scavenger-free-other-allocate race */
  2    44 	     2 meters,
  2    45 	       3 call_get	      fixed bin (35),	/* Calls to get_vtoce */
  2    46 	       3 call_put	      fixed bin (35),	/* Calls to put_vtoce */
  2    47 	       3 call_alloc	      fixed bin (35),	/* Calls to alloc_and_put_vtoce */
  2    48 	       3 call_free	      fixed bin (35),	/* Calls to free_vtoce */
  2    49 	       3 call_await	      fixed bin (35),	/* Calls to await_vtoce */
  2    50 	       3 steps	      fixed bin (35),	/* Steps through buffer allocation */
  2    51 	       3 skip_os	      fixed bin (35),	/* Skipped because out-of-service */
  2    52 	       3 skip_hot	      fixed bin (35),	/* Skipped because buffer hot */
  2    53 	       3 skip_wait	      fixed bin (35),	/* Skipped because notify_sw set */
  2    54 	       3 disk_reads	      fixed bin (35),	/* Number of same */
  2    55 	       3 disk_writes      fixed bin (35),	/* Number of same */
  2    56 	       3 get_buffer_calls fixed bin (35),	/* Number of calls to GET_BUFFER */
  2    57 	       3 get_buffer_hits  fixed bin (35),	/* Number times VTOCE in buffer */
  2    58 	       3 wait_calls	      fixed bin (35),	/* Number of calls to WAIT */
  2    59 	       3 wait_os	      fixed bin (35),	/* Number of times had to wait */
  2    60 	       3 scavenger_free_checks
  2    61                                     fixed bin (35),	/* Number of times had to check pseudo-clock */
  2    62 	       3 scavenger_free_losses
  2    63                                     fixed bin (35),	/* Number of times race lost between scavenger freeing and other allocate */
  2    64 	       3 soft_rar	      fixed bin (35),         /* Nunber of times a software read_alter_rewrite performed */
  2    65 
  2    66 	       3 pad (14)	      fixed bin (35),
  2    67 
  2    68 	     2 hash_table	      (vtoc_buf_n_buckets refer (vtoc_buffer.n_hash_buckets)) bit (18) aligned,
  2    69 
  2    70 
  2    71 	     2 buf_desc	      (vtoc_buf_n_buffers refer (vtoc_buffer.n_bufs)) aligned like vtoc_buf_desc,
  2    72 
  2    73 	     2 buffer	      (vtoc_buf_n_buffers refer (vtoc_buffer.n_bufs)) aligned like vtoce_buffer;
  2    74 
  2    75 
  2    76 
  2    77      dcl	   1 vtoc_buf_desc_array  (vtoc_buffer.n_bufs) aligned based (vtoc_buf_desc_arrayp) like vtoc_buf_desc;
  2    78 
  2    79 
  2    80      dcl	   1 vtoc_buf_desc	      aligned based (vtoc_buf_descp),
  2    81 	     2 pvtx	      fixed bin (17) unal,	/* PVTE index */
  2    82 	     2 vtocx	      fixed bin (17) unal,	/* VTOCE Index */
  2    83 	     2 parts_used	      bit (3) unal,		/* Mask of parts used or os */
  2    84 	     2 err	      bit (1) unal,		/* ON => I/O error on buffer */
  2    85 	     2 notify_sw	      bit (1) unal,		/* ON => notify requied on I/O completion */
  2    86 	     2 write_sw	      bit (1) unal,		/* ON => write I/O */
  2    87 	     2 os		      bit (1) unal,		/* ON => I/O in progress */
  2    88 	     2 ioq	      bit (1) unal,		/* ON => I/O has been requested */
  2    89 	     2 used	      bit (1) unal,		/* ON => this descriptor is in use */
  2    90 	     2 pad	      bit (9) unal,
  2    91 	     2 wait_index	      fixed bin (17) unal,	/* Buffer index for forming wait event */
  2    92 	     2 ht_thread	      bit (18) unal,	/* Offset of next entry in hash table */
  2    93 	     2 buf_rel	      bit (18) unal;	/* Offset of buffer in segment */
  2    94 
  2    95      dcl	   1 vtoce_buffer_array   (vtoc_buffer.n_bufs) aligned based (vtoc_buf_arrayp) like vtoce_buffer;
  2    96 
  2    97      dcl	   1 vtoce_buffer	      aligned based (vtoc_bufp),
  2    98 	     2 parts	      (3) aligned,
  2    99 	       3 words	      (64) bit (36) aligned;
  2   100 
  2   101 
  2   102      dcl	   N_PARTS_PER_VTOCE      fixed bin int static options (constant) init (3);
  2   103      dcl	   VTOCE_PART_SIZE	      fixed bin int static options (constant) init (64);
  2   104      dcl	   VTOCE_BUFFER_SIZE      fixed bin int static options (constant) init (3 * 64);
  2   105      dcl	   N_VTOCE_PER_RECORD     fixed bin int static options (constant) init (5);
  2   106      dcl	   N_SECTOR_PER_VTOCE     fixed bin int static options (constant) init (3);
  2   107 
  2   108 
  2   109 /*  END OF:	vtoc_buffer.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      129 
      130 
      131 
      132 
      133 /* BEGIN MESSAGE DOCUMENTATION
      134*
      135*   Message:
      136*   esd before fs enabled
      137*
      138*   S: $info
      139*
      140*   T: Emergency shutdown
      141*
      142*   M: The system crashed before the storage system was accessed by
      143*   Multics. An ESD was attempted, but no ESD is necessary.
      144*   The "shutdown complete" message will always follow.
      145*
      146*   A: Reboot the system.
      147*
      148*   Message:
      149*   shutdown complete
      150*
      151*   S: $info
      152*
      153*   T: Emergency shutdown
      154*
      155*   M: Emergency shutdown is complete; this message was
      156*   preceded by either "esd before fs enabled" or
      157*   "system already shut down":
      158*   no ESD was necessary.
      159*
      160*   A: Reboot the system.
      161*
      162*   Message:
      163*   system already shut down
      164*
      165*   S: $info
      166*
      167*   T: Emergency shutdown
      168*
      169*   M: An attempt to perform emergency shutdown was made after
      170*   a previous attempt, or normal shutdown, succeeded. No ESD
      171*   is necessary in this case. The "shutdown complete" message
      172*   follows.
      173*
      174*   A: $ignore
      175*
      176*   Message:
      177*   begin emergency shutdown part 1
      178*
      179*   S: $info
      180*
      181*   T: Emergency shutdown
      182*
      183*   M: The system emergency shutdown environment has been
      184*   successfully established. An attempt will be made to write
      185*   out all of memory and flush the paging device.
      186*
      187*   A: $ignore
      188*
      189*   Message:
      190*   emergency shutdown part 1 complete
      191*
      192*   S: $info
      193*
      194*   T: Emergency shutdown
      195*
      196*   M: All of memory has been written out once, and those
      197*   pages on the paging device which could be written out to
      198*   operative drives flushed. All segments and directories will
      199*   now be deactivated, and all drives shut down.
      200*
      201*   A: $ignore
      202*
      203*   Message:
      204*   wired_shutdown: FFF fault during emergency shutdown
      205*
      206*   S: $crash
      207*
      208*   T: Emergency shutdown
      209*
      210*   M: An unexpected fault has occured during emergency
      211*   shutdown.  Emergency shutdown
      212*   cannot complete.
      213*
      214*   A: Get a dump for system programmers. If an disk dump was taken
      215*   of the preceding crash, get a dump to paper via the bce dump facility.
      216*   Re-attempt ESD as many times as necessary.
      217*
      218*   END MESSAGE DOCUMENTATION */
      219 
      220 
      221      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0856.8  wired_shutdown.pl1                >spec>install>1115>wired_shutdown.pl1
128          1    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
129          2    07/24/86  2051.8  vtoc_buffer.incl.pl1              >ldd>include>vtoc_buffer.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
condition_                      000050 constant        entry                    external dcl 51 ref 58
condname                               parameter       char                     packed unaligned dcl 121 set ref 118 124*
cont                                   parameter       bit(1)                   packed unaligned dcl 122 ref 118
control                         000010 internal static char(8)                  initial packed unaligned dcl 39 set ref 61 115*
coptr                                  parameter       pointer                  dcl 120 ref 118
fsout_vol                       000032 constant        entry                    external dcl 37 ref 101 106
get_pvtx$reset                  000026 constant        entry                    external dcl 35 ref 93
infoptr                                parameter       pointer                  dcl 120 ref 118
mcptr                                  parameter       pointer                  dcl 120 ref 118
ocdcm_$drain_io                 000020 constant        entry                    external dcl 32 ref 64
page$reset_pvte                 000014 constant        entry                    external dcl 30 ref 89
pc$flush                        000012 constant        entry                    external dcl 29 ref 103
pmut$bce                        000016 constant        entry                    external dcl 31 ref 66
pmut$set_mask                   000030 constant        entry                    external dcl 36 ref 59
pvt$array                       000052 external static fixed bin(17,0)          dcl 1-18 set ref 70
pvt$esd_state                   000042 external static fixed bin(17,0)          dcl 44 set ref 100* 105*
pvt$n_entries                   000044 external static fixed bin(17,0)          dcl 44 ref 83
pvt$shutdown_state              000040 external static fixed bin(17,0)          dcl 44 set ref 99* 104*
pvt_array                              based           structure                array level 1 dcl 1-24 set ref 84
pvt_arrayp                      000104 automatic       pointer                  dcl 1-21 set ref 70* 72 79 79 84
pvte                                   based           structure                level 1 dcl 1-26
pvtep                           000106 automatic       pointer                  dcl 1-22 set ref 84* 85 87 88 89*
pvtx                            000102 automatic       fixed bin(17,0)          dcl 52 set ref 83* 84*
save_mask                       000100 automatic       fixed bin(71,0)          dcl 50 set ref 59*
scav_check_address        4(27)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 set ref 87*
scavenger_block_rel      33(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-26 set ref 88*
scs$open_level                  000036 external static fixed bin(71,0)          dcl 42 set ref 59*
shutdown_file_system            000034 constant        entry                    external dcl 38 ref 111
sst$root_pvtx                   000046 external static fixed bin(17,0)          dcl 44 set ref 61 72 101* 106*
syserr                          000022 constant        entry                    external dcl 33 ref 62 63 73 96 108 124
unsafe_pvtx              14            based           fixed bin(17,0)          level 2 dcl 2-25 set ref 78 79 79 80*
used                      4(18)        based           bit(1)                   array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 1-24 in procedure
                                                                                  "wired_shutdown$wired_emergency" set ref 72
used                      4(18)        based           bit(1)                   level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 1-26 in procedure
                                                                                  "wired_shutdown$wired_emergency" ref 85
vol_trouble_count        33            based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 1-24 set
                                                                                  ref 79* 79
vtoc_buf_desc                          based           structure                level 1 dcl 2-80
vtoc_buffer                            based           structure                level 1 dcl 2-25
vtoc_buffer_seg$                000054 external static fixed bin(17,0)          dcl 2-13 set ref 77
vtoc_buffer_segp                000110 automatic       pointer                  dcl 2-15 set ref 77* 78 79 79 80
vtoc_man$stabilize              000024 constant        entry                    external dcl 34 ref 110
vtoce_buffer                           based           structure                level 1 dcl 2-97

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
N_PARTS_PER_VTOCE                      internal static fixed bin(17,0)          initial dcl 2-102
N_SECTOR_PER_VTOCE                     internal static fixed bin(17,0)          initial dcl 2-106
N_VTOCE_PER_RECORD                     internal static fixed bin(17,0)          initial dcl 2-105
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 1-113
VTOCE_BUFFER_SIZE                      internal static fixed bin(17,0)          initial dcl 2-104
VTOCE_PART_SIZE                        internal static fixed bin(17,0)          initial dcl 2-103
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 1-19
vtoc_buf_arrayp                        automatic       pointer                  dcl 2-19
vtoc_buf_desc_array                    based           structure                array level 1 dcl 2-77
vtoc_buf_desc_arrayp                   automatic       pointer                  dcl 2-18
vtoc_buf_descp                         automatic       pointer                  dcl 2-16
vtoc_buf_n_buckets                     automatic       fixed bin(17,0)          dcl 2-22
vtoc_buf_n_buffers                     automatic       fixed bin(17,0)          dcl 2-21
vtoc_bufp                              automatic       pointer                  dcl 2-17
vtoce_buffer_array                     based           structure                array level 1 dcl 2-95

NAMES DECLARED BY EXPLICIT CONTEXT.
enable                          000461 constant        entry                    external dcl 114
handler                         000473 constant        entry                    internal dcl 118 ref 58 58
shut                            000175 constant        label                    dcl 63 ref 74
wired_shutdown$wired_emergency  000103 constant        entry                    external dcl 13

NAME DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 70 77 84

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1010        1066     536        1020
Length      1324     536        56         221     251           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
wired_shutdown$wired_emergency
                                    104 external procedure  is an external procedure.  
handler                              94 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 control                     wired_shutdown$wired_emergency

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
wired_shutdown$wired_emergency
                         000100 save_mask                   wired_shutdown$wired_emergency
                         000102 pvtx                        wired_shutdown$wired_emergency
                         000104 pvt_arrayp                  wired_shutdown$wired_emergency
                         000106 pvtep                       wired_shutdown$wired_emergency
                         000110 vtoc_buffer_segp            wired_shutdown$wired_emergency

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    fsout_vol                     get_pvtx$reset                ocdcm_$drain_io
page$reset_pvte               pc$flush                      pmut$bce                      pmut$set_mask
shutdown_file_system          syserr                        vtoc_man$stabilize

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pvt$array                     pvt$esd_state                 pvt$n_entries                 pvt$shutdown_state
scs$open_level                sst$root_pvtx                 vtoc_buffer_seg$


CONSTANTS
000535  aa     777777777377

000000  aa     524000000062

000001  aa     516000000001

000002  aa     526077777777

000003  aa     464000000000

000004  aa     524000000043

000005  aa     524000000040

000006  aa     524000000030

000007  aa     524000000021

000010  aa     524000000025

000011  aa     404000000005

000012  aa     500000000000

000013  aa     524000000011

000014  aa  145 156 141 142	enab
000015  aa  154 145 144 040	led 

000016  aa  164 157 157 145	tooe
000017  aa  141 162 154 171	arly

000020  aa  141 156 171 137	any_
000021  aa  157 164 150 145	othe
000022  aa  162 000 000 000	r

000023  aa  163 150 165 164	shut
000024  aa  144 157 167 156	down
000025  aa  040 143 157 155	 com
000026  aa  160 154 145 164	plet
000027  aa  145 000 000 000	e

000030  aa  163 171 163 164	syst
000031  aa  145 155 040 141	em a
000032  aa  154 162 145 141	lrea
000033  aa  144 171 040 163	dy s
000034  aa  150 165 164 040	hut 
000035  aa  144 157 167 156	down

000036  aa  145 163 144 040	esd 
000037  aa  142 145 146 157	befo
000040  aa  162 145 040 146	re f
000041  aa  163 040 145 156	s en
000042  aa  141 142 154 145	able
000043  aa  144 000 000 000	d

000044  aa  142 145 147 151	begi
000045  aa  156 040 145 155	n em
000046  aa  145 162 147 145	erge
000047  aa  156 143 171 040	ncy 
000050  aa  163 150 165 164	shut
000051  aa  144 157 167 156	down
000052  aa  040 160 141 162	 par
000053  aa  164 040 061 056	t 1.

000054  aa  145 155 145 162	emer
000055  aa  147 145 156 143	genc
000056  aa  171 040 163 150	y sh
000057  aa  165 164 144 157	utdo
000060  aa  167 156 040 160	wn p
000061  aa  141 162 164 040	art 
000062  aa  061 040 143 157	1 co
000063  aa  155 160 154 145	mple
000064  aa  164 145 056 000	te.

000065  aa  167 151 162 145	wire
000066  aa  144 137 163 150	d_sh
000067  aa  165 164 144 157	utdo
000070  aa  167 156 072 040	wn: 
000071  aa  136 141 040 146	^a f
000072  aa  141 165 154 164	ault
000073  aa  040 144 165 162	 dur
000074  aa  151 156 147 040	ing 
000075  aa  145 155 145 162	emer
000076  aa  147 145 156 143	genc
000077  aa  171 040 163 150	y sh
000100  aa  165 164 144 157	utdo
000101  aa  167 156 000 000	wn

BEGIN PROCEDURE wired_shutdown$wired_emergency
ENTRY TO wired_shutdown$wired_emergency                     STATEMENT 1 ON LINE 13
wired_shutdown$wired_emergency: procedure;

000102  da     000233200000
000103  aa   000160 6270 00	eax7 	112
000104  aa  7 00034 3521 20	epp2 	pr7|28,*
000105  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000106  aa     000000000000
000107  aa     000000000000
						STATEMENT 1 ON LINE 58
	call condition_ ("any_other", handler);

000110  aa   777710 2370 04	ldaq 	-56,ic		000020 = 141156171137 157164150145
000111  aa  6 00114 7571 00	staq 	pr6|76
000112  aa   162000 2350 03	lda  	58368,du
000113  aa  6 00116 7551 00	sta  	pr6|78
000114  aa   000357 3520 04	epp2 	239,ic		000473 = 000140627000
000115  aa  6 00120 2521 00	spri2	pr6|80		cp.127
000116  aa  6 00122 6521 00	spri6	pr6|82		cp.127
000117  aa  6 00114 3521 00	epp2 	pr6|76
000120  aa  6 00126 2521 00	spri2	pr6|86
000121  aa  6 00120 3521 00	epp2 	pr6|80		cp.127
000122  aa  6 00130 2521 00	spri2	pr6|88
000123  aa   777670 3520 04	epp2 	-72,ic		000013 = 524000000011
000124  aa  6 00132 2521 00	spri2	pr6|90
000125  aa   777665 3520 04	epp2 	-75,ic		000012 = 500000000000
000126  aa  6 00134 2521 00	spri2	pr6|92
000127  aa  6 00124 6211 00	eax1 	pr6|84
000130  aa   010000 4310 07	fld  	4096,dl
000131  la  4 00050 3521 20	epp2 	pr4|40,*		condition_
000132  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 59
	call pmut$set_mask (scs$open_level, save_mask);

000133  aa  6 00044 3701 20	epp4 	pr6|36,*
000134  la  4 00036 3521 20	epp2 	pr4|30,*		scs$open_level
000135  aa  6 00126 2521 00	spri2	pr6|86
000136  aa  6 00100 3521 00	epp2 	pr6|64		save_mask
000137  aa  6 00130 2521 00	spri2	pr6|88
000140  aa  6 00124 6211 00	eax1 	pr6|84
000141  aa   010000 4310 07	fld  	4096,dl
000142  la  4 00030 3521 20	epp2 	pr4|24,*		pmut$set_mask
000143  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 61
	if control = "tooearly" | sst$root_pvtx = 0 then do;

000144  aa  6 00044 3701 20	epp4 	pr6|36,*
000145  ia  4 00010 2371 00	ldaq 	pr4|8		control
000146  aa   777650 1170 04	cmpaq	-88,ic		000016 = 164157157145 141162154171
000147  aa   000003 6000 04	tze  	3,ic		000152
000150  la  4 00046 2361 20	ldq  	pr4|38,*		sst$root_pvtx
000151  aa   000061 6010 04	tnz  	49,ic		000232
						STATEMENT 1 ON LINE 62
	     call syserr (0, "esd before fs enabled");

000152  aa  6 00117 4501 00	stz  	pr6|79
000153  aa   777663 2370 04	ldaq 	-77,ic		000036 = 145163144040 142145146157
000154  aa  6 00124 7571 00	staq 	pr6|84
000155  aa   777663 2370 04	ldaq 	-77,ic		000040 = 162145040146 163040145156
000156  aa  6 00126 7571 00	staq 	pr6|86
000157  aa   777663 2370 04	ldaq 	-77,ic		000042 = 141142154145 144000000000
000160  aa  6 00130 7571 00	staq 	pr6|88
000161  aa  6 00117 3521 00	epp2 	pr6|79
000162  aa  6 00140 2521 00	spri2	pr6|96
000163  aa  6 00124 3521 00	epp2 	pr6|84
000164  aa  6 00142 2521 00	spri2	pr6|98
000165  aa   777624 3520 04	epp2 	-108,ic		000011 = 404000000005
000166  aa  6 00144 2521 00	spri2	pr6|100
000167  aa   777621 3520 04	epp2 	-111,ic		000010 = 524000000025
000170  aa  6 00146 2521 00	spri2	pr6|102
000171  aa  6 00136 6211 00	eax1 	pr6|94
000172  aa   010000 4310 07	fld  	4096,dl
000173  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000174  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 63
shut:	     call syserr (0, "shutdown complete");

000175  aa  6 00117 4501 00	stz  	pr6|79
000176  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000177  aa   777625 00 0024	desc9a	-107,20		000023 = 163150165164
000200  aa  6 00136 00 0024	desc9a	pr6|94,20
000201  aa  6 00117 3521 00	epp2 	pr6|79
000202  aa  6 00126 2521 00	spri2	pr6|86
000203  aa  6 00136 3521 00	epp2 	pr6|94
000204  aa  6 00130 2521 00	spri2	pr6|88
000205  aa   777604 3520 04	epp2 	-124,ic		000011 = 404000000005
000206  aa  6 00132 2521 00	spri2	pr6|90
000207  aa   777600 3520 04	epp2 	-128,ic		000007 = 524000000021
000210  aa  6 00134 2521 00	spri2	pr6|92
000211  aa  6 00124 6211 00	eax1 	pr6|84
000212  aa   010000 4310 07	fld  	4096,dl
000213  aa  6 00044 3701 20	epp4 	pr6|36,*
000214  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000215  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 64
	     call ocdcm_$drain_io;

000216  aa  6 00056 6211 00	eax1 	pr6|46
000217  aa   000000 4310 07	fld  	0,dl
000220  aa  6 00044 3701 20	epp4 	pr6|36,*
000221  la  4 00020 3521 20	epp2 	pr4|16,*		ocdcm_$drain_io
000222  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 65
	     do while ("1"b);

000223  aa   000000 0110 03	nop  	0,du
						STATEMENT 1 ON LINE 66
		call pmut$bce;

000224  aa  6 00056 6211 00	eax1 	pr6|46
000225  aa   000000 4310 07	fld  	0,dl
000226  aa  6 00044 3701 20	epp4 	pr6|36,*
000227  la  4 00016 3521 20	epp2 	pr4|14,*		pmut$bce
000230  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 67
	     end;

000231  aa   777773 7100 04	tra  	-5,ic		000224
						STATEMENT 1 ON LINE 68
	end;

						STATEMENT 1 ON LINE 70
	pvt_arrayp = addr (pvt$array);

000232  aa  6 00044 3701 20	epp4 	pr6|36,*
000233  la  4 00052 3735 20	epp7 	pr4|42,*		pvt$array
000234  aa  6 00104 6535 00	spri7	pr6|68		pvt_arrayp
						STATEMENT 1 ON LINE 72
	if ^pvt_array (sst$root_pvtx).used then do;

000235  la  4 00046 2361 20	ldq  	pr4|38,*		sst$root_pvtx
000236  aa   000034 4020 07	mpy  	28,dl
000237  aa  6 00117 7561 00	stq  	pr6|79
000240  aa  7 77750 2351 06	lda  	pr7|-24,ql	pvt_array.used
000241  aa   400000 3150 07	cana 	131072,dl
000242  aa   000025 6010 04	tnz  	21,ic		000267
						STATEMENT 1 ON LINE 73
	     call syserr (0, "system already shut down");

000243  aa  6 00117 4501 00	stz  	pr6|79
000244  aa   777564 2370 04	ldaq 	-140,ic		000030 = 163171163164 145155040141
000245  aa  6 00124 7571 00	staq 	pr6|84
000246  aa   777564 2370 04	ldaq 	-140,ic		000032 = 154162145141 144171040163
000247  aa  6 00126 7571 00	staq 	pr6|86
000250  aa   777564 2370 04	ldaq 	-140,ic		000034 = 150165164040 144157167156
000251  aa  6 00130 7571 00	staq 	pr6|88
000252  aa  6 00117 3521 00	epp2 	pr6|79
000253  aa  6 00140 2521 00	spri2	pr6|96
000254  aa  6 00124 3521 00	epp2 	pr6|84
000255  aa  6 00142 2521 00	spri2	pr6|98
000256  aa   777533 3520 04	epp2 	-165,ic		000011 = 404000000005
000257  aa  6 00144 2521 00	spri2	pr6|100
000260  aa   777526 3520 04	epp2 	-170,ic		000006 = 524000000030
000261  aa  6 00146 2521 00	spri2	pr6|102
000262  aa  6 00136 6211 00	eax1 	pr6|94
000263  aa   010000 4310 07	fld  	4096,dl
000264  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000265  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 74
	     go to shut;

000266  aa   777707 7100 04	tra  	-57,ic		000175
						STATEMENT 1 ON LINE 75
	end;

						STATEMENT 1 ON LINE 77
	vtoc_buffer_segp = addr (vtoc_buffer_seg$);

000267  la  4 00054 3715 20	epp5 	pr4|44,*		vtoc_buffer_seg$
000270  aa  6 00110 6515 00	spri5	pr6|72		vtoc_buffer_segp
						STATEMENT 1 ON LINE 78
	if vtoc_buffer.unsafe_pvtx > 0 then do;

000271  aa  5 00014 2361 00	ldq  	pr5|12		vtoc_buffer.unsafe_pvtx
000272  aa   000012 6044 04	tmoz 	10,ic		000304
						STATEMENT 1 ON LINE 79
	     pvt_array (vtoc_buffer.unsafe_pvtx).vol_trouble_count = pvt_array (vtoc_buffer.unsafe_pvtx).vol_trouble_count + 1;

000273  aa   000034 4020 07	mpy  	28,dl
000274  aa  7 77777 2351 06	lda  	pr7|-1,ql		pvt_array.vol_trouble_count
000275  aa   000000 6270 06	eax7 	0,ql
000276  aa   000066 7330 00	lrs  	54
000277  aa   000001 0760 07	adq  	1,dl
000300  aa   000066 7370 00	lls  	54
000301  aa  7 77777 3535 17	epp3 	pr7|-1,7		pvt_array.vol_trouble_count
000302  aa  3 00000 5511 60	stba 	pr3|0,60		pvt_array.vol_trouble_count
						STATEMENT 1 ON LINE 80
	     vtoc_buffer.unsafe_pvtx = 0;

000303  aa  5 00014 4501 00	stz  	pr5|12		vtoc_buffer.unsafe_pvtx
						STATEMENT 1 ON LINE 81
	end;

						STATEMENT 1 ON LINE 83
	do pvtx = 1 to pvt$n_entries;

000304  la  4 00044 2361 20	ldq  	pr4|36,*		pvt$n_entries
000305  aa  6 00112 7561 00	stq  	pr6|74
000306  aa   000001 2360 07	ldq  	1,dl
000307  aa  6 00102 7561 00	stq  	pr6|66		pvtx
000310  aa  6 00102 2361 00	ldq  	pr6|66		pvtx
000311  aa  6 00112 1161 00	cmpq 	pr6|74
000312  aa   000025 6054 04	tpnz 	21,ic		000337
						STATEMENT 1 ON LINE 84
	     pvtep = addr (pvt_array (pvtx));

000313  aa   000034 4020 07	mpy  	28,dl
000314  aa  6 00104 3735 20	epp7 	pr6|68,*		pvt_arrayp
000315  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
000316  aa  6 00106 6535 00	spri7	pr6|70		pvtep
						STATEMENT 1 ON LINE 85
	     if pvte.used
		then do;

000317  aa  7 00004 2351 00	lda  	pr7|4		pvte.used
000320  aa   400000 3150 07	cana 	131072,dl
000321  aa   000014 6000 04	tze  	12,ic		000335
						STATEMENT 1 ON LINE 87
		pvte.scav_check_address = "0"b;

000322  aa   000213 2350 04	lda  	139,ic		000535 = 777777777377
000323  aa  7 00004 3551 00	ansa 	pr7|4		pvte.scav_check_address
						STATEMENT 1 ON LINE 88
		pvte.scavenger_block_rel = ""b;

000324  aa   777777 2350 03	lda  	262143,du
000325  aa  7 00033 3551 00	ansa 	pr7|27		pvte.scavenger_block_rel
						STATEMENT 1 ON LINE 89
		call page$reset_pvte (pvtep);

000326  aa  6 00106 3521 00	epp2 	pr6|70		pvtep
000327  aa  6 00122 2521 00	spri2	pr6|82
000330  aa  6 00120 6211 00	eax1 	pr6|80
000331  aa   004000 4310 07	fld  	2048,dl
000332  aa  6 00044 3701 20	epp4 	pr6|36,*
000333  la  4 00014 3521 20	epp2 	pr4|12,*		page$reset_pvte
000334  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 90
	     end;

						STATEMENT 1 ON LINE 91
	end;

000335  aa  6 00102 0541 00	aos  	pr6|66		pvtx
000336  aa   777752 7100 04	tra  	-22,ic		000310
						STATEMENT 1 ON LINE 93
	call get_pvtx$reset;

000337  aa  6 00056 6211 00	eax1 	pr6|46
000340  aa   000000 4310 07	fld  	0,dl
000341  aa  6 00044 3701 20	epp4 	pr6|36,*
000342  la  4 00026 3521 20	epp2 	pr4|22,*		get_pvtx$reset
000343  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 96
	call syserr (0, "begin emergency shutdown part 1.");

000344  aa  6 00117 4501 00	stz  	pr6|79
000345  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000346  aa   777477 00 0040	desc9a	-193,32		000044 = 142145147151
000347  aa  6 00136 00 0040	desc9a	pr6|94,32
000350  aa  6 00117 3521 00	epp2 	pr6|79
000351  aa  6 00126 2521 00	spri2	pr6|86
000352  aa  6 00136 3521 00	epp2 	pr6|94
000353  aa  6 00130 2521 00	spri2	pr6|88
000354  aa   777435 3520 04	epp2 	-227,ic		000011 = 404000000005
000355  aa  6 00132 2521 00	spri2	pr6|90
000356  aa   777427 3520 04	epp2 	-233,ic		000005 = 524000000040
000357  aa  6 00134 2521 00	spri2	pr6|92
000360  aa  6 00124 6211 00	eax1 	pr6|84
000361  aa   010000 4310 07	fld  	4096,dl
000362  aa  6 00044 3701 20	epp4 	pr6|36,*
000363  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000364  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 99
	pvt$shutdown_state = 1;

000365  aa   000001 2360 07	ldq  	1,dl
000366  aa  6 00044 3701 20	epp4 	pr6|36,*
000367  la  4 00040 7561 20	stq  	pr4|32,*		pvt$shutdown_state
						STATEMENT 1 ON LINE 100
	pvt$esd_state = 1;

000370  la  4 00042 7561 20	stq  	pr4|34,*		pvt$esd_state
						STATEMENT 1 ON LINE 101
	call fsout_vol (sst$root_pvtx, 0);

000371  aa  6 00117 4501 00	stz  	pr6|79
000372  la  4 00046 3521 20	epp2 	pr4|38,*		sst$root_pvtx
000373  aa  6 00126 2521 00	spri2	pr6|86
000374  aa  6 00117 3521 00	epp2 	pr6|79
000375  aa  6 00130 2521 00	spri2	pr6|88
000376  aa  6 00124 6211 00	eax1 	pr6|84
000377  aa   010000 4310 07	fld  	4096,dl
000400  la  4 00032 3521 20	epp2 	pr4|26,*		fsout_vol
000401  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 103
	call pc$flush;

000402  aa  6 00056 6211 00	eax1 	pr6|46
000403  aa   000000 4310 07	fld  	0,dl
000404  aa  6 00044 3701 20	epp4 	pr6|36,*
000405  la  4 00012 3521 20	epp2 	pr4|10,*		pc$flush
000406  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 104
	pvt$shutdown_state = 2;

000407  aa   000002 2360 07	ldq  	2,dl
000410  aa  6 00044 3701 20	epp4 	pr6|36,*
000411  la  4 00040 7561 20	stq  	pr4|32,*		pvt$shutdown_state
						STATEMENT 1 ON LINE 105
	pvt$esd_state = 2;

000412  la  4 00042 7561 20	stq  	pr4|34,*		pvt$esd_state
						STATEMENT 1 ON LINE 106
	call fsout_vol (sst$root_pvtx, 0);

000413  aa  6 00117 4501 00	stz  	pr6|79
000414  la  4 00046 3521 20	epp2 	pr4|38,*		sst$root_pvtx
000415  aa  6 00140 2521 00	spri2	pr6|96
000416  aa  6 00117 3521 00	epp2 	pr6|79
000417  aa  6 00142 2521 00	spri2	pr6|98
000420  aa  6 00136 6211 00	eax1 	pr6|94
000421  aa   010000 4310 07	fld  	4096,dl
000422  la  4 00032 3521 20	epp2 	pr4|26,*		fsout_vol
000423  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 108
	call syserr (0, "emergency shutdown part 1 complete.");

000424  aa  6 00117 4501 00	stz  	pr6|79
000425  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000426  aa   777427 00 0044	desc9a	-233,36		000054 = 145155145162
000427  aa  6 00124 00 0044	desc9a	pr6|84,36
000430  aa  6 00117 3521 00	epp2 	pr6|79
000431  aa  6 00140 2521 00	spri2	pr6|96
000432  aa  6 00124 3521 00	epp2 	pr6|84
000433  aa  6 00142 2521 00	spri2	pr6|98
000434  aa   777355 3520 04	epp2 	-275,ic		000011 = 404000000005
000435  aa  6 00144 2521 00	spri2	pr6|100
000436  aa   777346 3520 04	epp2 	-282,ic		000004 = 524000000043
000437  aa  6 00146 2521 00	spri2	pr6|102
000440  aa  6 00136 6211 00	eax1 	pr6|94
000441  aa   010000 4310 07	fld  	4096,dl
000442  aa  6 00044 3701 20	epp4 	pr6|36,*
000443  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000444  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 110
	call vtoc_man$stabilize;

000445  aa  6 00056 6211 00	eax1 	pr6|46
000446  aa   000000 4310 07	fld  	0,dl
000447  aa  6 00044 3701 20	epp4 	pr6|36,*
000450  la  4 00024 3521 20	epp2 	pr4|20,*		vtoc_man$stabilize
000451  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 111
	call shutdown_file_system;

000452  aa  6 00056 6211 00	eax1 	pr6|46
000453  aa   000000 4310 07	fld  	0,dl
000454  aa  6 00044 3701 20	epp4 	pr6|36,*
000455  la  4 00034 3521 20	epp2 	pr4|28,*		shutdown_file_system
000456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 112
	return;

000457  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO enable                                             STATEMENT 1 ON LINE 114
enable:	entry;

000460  da     000240200000
000461  aa   000160 6270 00	eax7 	112
000462  aa  7 00034 3521 20	epp2 	pr7|28,*
000463  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000464  aa     000000000000
000465  aa     000000000000
						STATEMENT 1 ON LINE 115
	control = "enabled";

000466  aa   777326 2370 04	ldaq 	-298,ic		000014 = 145156141142 154145144040
000467  aa  6 00044 3701 20	epp4 	pr6|36,*
000470  ia  4 00010 7571 00	staq 	pr4|8		control
						STATEMENT 1 ON LINE 116
	return;

000471  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 221
     end;

BEGIN PROCEDURE handler
ENTRY TO handler                                            STATEMENT 1 ON LINE 118
handler:	proc (mcptr, condname, coptr, infoptr, cont);

000472  da     000245200000
000473  aa   000140 6270 00	eax7 	96
000474  aa  7 00034 3521 20	epp2 	pr7|28,*
000475  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
000476  aa     000012000000
000477  aa     000000000000
000500  aa  6 00042 3735 20	epp7 	pr6|34,*
000501  aa  7 00002 2361 20	ldq  	pr7|2,*
000502  aa   000002 6040 04	tmi  	2,ic		000504
000503  aa   777777 3760 07	anq  	262143,dl
000504  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000505  aa  6 00100 7561 00	stq  	pr6|64
						STATEMENT 1 ON LINE 124
	     call syserr (1, "wired_shutdown: ^a fault during emergency shutdown", condname);

000506  aa   000001 2360 07	ldq  	1,dl
000507  aa  6 00101 7561 00	stq  	pr6|65
000510  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000511  aa   777355 00 0064	desc9a	-275,52		000065 = 167151162145
000512  aa  6 00102 00 0064	desc9a	pr6|66,52
000513  aa  6 00101 3521 00	epp2 	pr6|65
000514  aa  6 00122 2521 00	spri2	pr6|82
000515  aa  6 00102 3521 00	epp2 	pr6|66
000516  aa  6 00124 2521 00	spri2	pr6|84
000517  aa  6 00032 3715 20	epp5 	pr6|26,*
000520  aa  5 00004 3521 20	epp2 	pr5|4,*		condname
000521  aa  6 00126 2521 00	spri2	pr6|86
000522  aa   777267 3520 04	epp2 	-329,ic		000011 = 404000000005
000523  aa  6 00130 2521 00	spri2	pr6|88
000524  aa   777254 3520 04	epp2 	-340,ic		000000 = 524000000062
000525  aa  6 00132 2521 00	spri2	pr6|90
000526  aa  7 00002 3521 20	epp2 	pr7|2,*
000527  aa  6 00134 2521 00	spri2	pr6|92
000530  aa  6 00120 6211 00	eax1 	pr6|80
000531  aa   014000 4310 07	fld  	6144,dl
000532  la  4 00022 3521 20	epp2 	pr4|18,*		syserr
000533  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 126
	end handler;

000534  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE handler
  END PROCEDURE wired_shutdown$wired_emergency


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
