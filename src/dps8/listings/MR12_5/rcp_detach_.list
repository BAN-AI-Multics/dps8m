	COMPILATION LISTING OF SEGMENT rcp_detach_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0950.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
       16*     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
       17*     Add MCA support
       18*                                                   END HISTORY COMMENTS */
       19 
       20 rcp_detach_:
       21      procedure;
       22 
       23 /*	This program implements the rcp_$detach entry point.
       24*   *	It is also an internal interface of RCP.
       25*   *	Created on 12/11/74 by Bill Silver.
       26*   *	Modified 1/79 by R.J.C. Kissel to fix the mount timer bug.
       27*   *	Modified 830818 to delete admin_gate_$give_console... -E. A. Ranzenbach
       28*   *	Modified 841005 to interface to rcp_control_ instead of rcp_initializer_ ... -M. M. Pozzo
       29*   *      Modified 1985-04-03 by Paul Farley & RAF to add support for MCA as device_type (8).
       30*   *
       31*   *	This program contains the following entry points:
       32*   *	     1.	detach  -  Detach and possible unassign a device.
       33*   *	     2.	force_detach  -  Detach a device that is being forcedly unassigned.
       34**/
       35 
       36 /*		ARGUMENT  DATA		*/
       37 
       38 	dcl     arg_comment		 char (*);	/* (I) Caller's comment. */
       39 	dcl     arg_disposition	 bit (*);		/* (I) ON => retain,  OFF => default. */
       40 	dcl     arg_ecode		 fixed bin (35);	/* (O) error_table_ code. */
       41 	dcl     arg_error_count	 fixed bin;	/* (I) User ring error count for attachment. */
       42 	dcl     arg_rcp_id		 bit (36) aligned;	/* (I) ID used to identify RCS entry. */
       43 	dcl     arg_rcse_ptr	 ptr;		/* (I) Pointer to attachment RCSE. */
       44 
       45 
       46 /*		AUTOMATIC  DATA		*/
       47 
       48 	dcl     disposition		 bit (1);		/* Assignment disposition. */
       49 	dcl     device_off		 bit (18) aligned;
       50 						/* Offset of RCSE device entry. */
       51 	dcl     force_detach_entry	 bit (1);		/* set if force_detach entry */
       52 	dcl     volume_off		 bit (18) aligned;
       53 						/* Offset of RCSE volume entry. */
       54 	dcl     rcp_id		 bit (36) aligned;	/* Used to copy rcp_id argument. */
       55 	dcl     process_id		 bit (36) aligned;
       56 						/* Process id requesting operation by RCP */
       57 
       58 	dcl     device_name		 char (32);	/* Device name for rcp_control_ */
       59 	dcl     operation		 bit (36) aligned;	/* Operation being requested of rcp_control_ */
       60 
       61 	dcl     arcse_ptr		 ptr;		/* Pointer to assignment RCS entry. */
       62 	dcl     caller_level	 fixed bin;	/* Caller's validation level. */
       63 	dcl     dcode		 fixed bin (35);	/* A dummy error_table code. */
       64 	dcl     ecode		 fixed bin (35);	/* error_table_ code. */
       65 	dcl     error_count		 fixed bin (17);	/* Number of errors during attachment. */
       66 	dcl     ioi_index		 fixed bin;	/* Used in final call to IOI. */
       67 
       68 
       69 /*		BASED  DATA		*/
       70 
       71 	dcl     1 arcse		 based (arcse_ptr) like rcse aligned;
       72 						/* Used to reference assignment RCS entry. */
       73 
       74 
       75 /*		EXTERNAL ENTRIES CALLED	*/
       76 
       77 	dcl     cleanup		 condition;	/* Used to set up cleanup handler. */
       78 
       79 	dcl     (addr, ptr)		 builtin;
       80 
       81 	dcl     error_table_$bad_arg	 fixed bin (35) external;
       82 	dcl     error_table_$force_unassign
       83 				 fixed bin (35) external;
       84 
       85 	dcl     access_operations_$rcp_error_count bit (36) aligned ext static;
       86 	dcl     access_operations_$rcp_unassign bit (36) aligned ext static;
       87 
       88 	dcl     admin_gate_$ioi_detach entry (fixed bin, fixed bin (35));
       89 	dcl     admin_gate_$syserr	 entry options (variable);
       90 	dcl     cu_$level_get	 entry (fixed bin);
       91 	dcl     cu_$level_set	 entry (fixed bin);
       92 	dcl     get_ring_		 entry returns (fixed bin);
       93 	dcl     mca_attach_$finish_detach entry (fixed bin, bit (1), fixed bin (35));
       94 	dcl     rcp_comment_	 entry (ptr);
       95 	dcl     rcp_control_	 entry (bit (36) aligned, bit (18) aligned, bit (18) aligned, char (*), fixed bin (17),
       96 				 bit (36) aligned, fixed bin (35));
       97 	dcl     rcp_rcse_$free	 entry (ptr, fixed bin (35));
       98 	dcl     rcp_validate_	 entry (bit (36) aligned, fixed bin, ptr, fixed bin (35));
       99 	dcl     rcp_pointers_$data	 entry () returns (ptr);
      100 	dcl     rcp_mount_timer_$reset entry (bit (18) aligned, fixed bin (35));
      101 						/*						*/
  1     1 /*	Begin  include file ... rcp_data.incl.pl1
  1     2*   *
  1     3*   *	Created on 09/06/74 by Bill Silver.
  1     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  1     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  1     6*   *	It contains information about all of the devices and volumes managed by RCP.
  1     7*   *	This include file references rcp_com_seg.incl.pl1.
  1     8*
  1     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  1    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  1    11*   *	Modified on 12/09/78 to add removable media bit.
  1    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  1    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  1    14*   *	Modified 11/84 by Paul Farley to add fips flag.
  1    15*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  1    16**/
  1    17 
  1    18 /****^  HISTORY COMMENTS:
  1    19*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1    20*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  1    21*     Support FIPS and IMU.
  1    22*                                                   END HISTORY COMMENTS */
  1    23 
  1    24 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  1    25 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  1    26 dcl  device_ptr ptr;				/* Points to a device entry. */
  1    27 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  1    28 
  1    29 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  1    30     2 lock_info like lock_info,			/* Data used to lock this segment. */
  1    31     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  1    32     2 modes like rcp_init_flags unaligned,
  1    33     2 tot_dtypes fixed bin,				/* Number of known device types. */
  1    34     2 tot_devices fixed bin,				/* Total number of devices configured. */
  1    35     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  1    36     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  1    37     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  1    38     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  1    39     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  1    40     2 accounting_pid bit (36),			/* ID of accounting process */
  1    41     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  1    42     2 pad (7) fixed bin,
  1    43     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  1    44      like dtype,					/* See structure below. */
  1    45     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  1    46      like device,					/* See structure below. */
  1    47     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  1    48      like volume,					/* See structure below. */
  1    49     2 end bit (36) aligned;				/* End of rcp_data. */
  1    50 
  1    51 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  1    52     2 device_type char (32),				/* Name of this device type. */
  1    53     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  1    54     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  1    55     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  1    56     2 first_off bit (18),				/* Offset of first device entry. */
  1    57     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  1    58 
  1    59 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  1    60     2 device_name char (8),				/* Name of device associated with this entry. */
  1    61     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  1    62     2 dtypex fixed bin,				/* Device type index. */
  1    63     2 model fixed bin,				/* Device model number. */
  1    64     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    65     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    66     2 state_time fixed bin (71),			/* Time device put into current state. */
  1    67     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  1    68*						   3 => storage system, 4 => reserved */
  1    69 
  1    70 /*	*	*	*	*	** Following fields are unique to device entry. */
  1    71 
  1    72     2 unassign_state fixed bin,			/* State to return when unassigning. */
  1    73     2 acs_name char (12),				/* Entry name of ACS for this device. */
  1    74     2 next_off bit (18),				/* Offset of next entry for this device type. */
  1    75     2 iom_num fixed bin,				/* IOM number for this device. */
  1    76     2 chan_num fixed bin,				/* Channel number for this device. */
  1    77     2 num_channels fixed bin,				/* Num channels that may address device. */
  1    78     2 flags,					/* Special info flags. */
  1    79      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  1    80       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  1    81       3 reservable bit (1),				/* ON => may be reserved for system process. */
  1    82       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  1    83       3 mounting bit (1),				/* ON => mount pending. */
  1    84       3 writing bit (1),				/* ON => mounting for writing. */
  1    85       3 attached bit (1) unal,			/* ON => device is attached. */
  1    86       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  1    87       3 fips bit (1),				/* ON => FIPS device. */
  1    88       3 no_protect bit (1),				/* ON => device has no protect sw. */
  1    89       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  1    90       3 unused bit (25)) unal,
  1    91     2 process_id bit (36),				/* ID of assigned process. */
  1    92     2 group_id char (32),				/* Process group ID. */
  1    93     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  1    94     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  1    95     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  1    96     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  1    97     2 reservation_id fixed bin (71),
  1    98     2 reserved_by char (32),				/* Who made this reservation. */
  1    99     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  1   100 
  1   101 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  1   102     2 process_id bit (36),				/* "0"b => unassigned. */
  1   103     2 volume_name char (32),				/* Volume name. */
  1   104     2 vtypex fixed bin,				/* Volume type index. */
  1   105     2 group_id char (32),				/* This is used for the reserved_for field. */
  1   106     2 reserved_by char (32),
  1   107     2 reservation_id fixed bin (71),
  1   108     2 state_time fixed bin (71),			/* Same as for a device. */
  1   109     2 state fixed bin,				/* Same as for a device. */
  1   110     2 unassign_state fixed bin,			/* State to return when unassigning. */
  1   111     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  1   112 
  2     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2     2 
  2     3 /* Created on 04/24/78 by Michael R. Jordan */
  2     4 /* Modified 04/10/79 by C. D. Tavares */
  2     5 
  2     6 dcl  rifp ptr;
  2     7 
  2     8 dcl 1 rcp_init_flags based (rifp),
  2     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  2    10     2 pad1 bit (2) unaligned,				/* obsolete */
  2    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  2    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  2    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  2    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  2    15 
  2    16 dcl (No_authentication initial (0),
  2    17      Nominal_authentication initial (1),
  2    18      Automatic_authentication initial (2),
  2    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  2    20 
  2    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  2    22     ("none", "nominal", "automatic", "manual");
  2    23 
  2    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  1   113 
  1   114 
  1   115 /*	End of include file ... rcp_data.incl.pl1	*/
      102 
  3     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  3     2*   *
  3     3*   *	Created on 11/20/74 by Bill Silver.
  3     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  3     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  3     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  3     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  3     8*   *	Modified 11/84 by Paul Farley to add fips flag.
  3     9*   *      Modified 1/3/85 by Fawcett to allow room for mca device type
  3    10*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  3    11*   *	This include file defines the Resource Control Package communication segment.
  3    12*   *	This segment is used to communicate requests between the various internal
  3    13*   *	parts of RCP.
  3    14**/
  3    15 
  3    16 /****^  HISTORY COMMENTS:
  3    17*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3    18*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  3    19*     Support MCA and FIPS.
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  3    23 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  3    24 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  3    25 
  3    26 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  3    27    (2 id_count fixed bin (17),			/* Unique count index. */
  3    28     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  3    29 
  3    30 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  3    31     2 lock_info like lock_info,			/* Data used to lock this segment. */
  3    32     2 ws_maxs (8) fixed bin (19),			/* Max IOI workspace size in words. */
  3    33     2 ws_pmaxs (8) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  3    34     2 to_maxs (8) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  3    35     2 sys_directory char (32),			/* Directory  used to define a system process. */
  3    36     2 sys_acs char (32),				/* Entry name used to define a system process. */
  3    37     2 acs_directory char (32),			/* Directory containing device ACSs. */
  3    38     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  3    39     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  3    40     2 num_entries fixed bin,				/* Total number of entries. */
  3    41     2 first_free_off bit (18),			/* Offset of first free entry. */
  3    42     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  3    43      like rcse,					/* See structure below. */
  3    44     2 end bit (36);					/* End of rcp_com_seg. */
  3    45 
  3    46 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  3    47     2 lock bit (36),				/* The lock itself. */
  3    48     2 num_locks fixed bin (35),			/* Number of times locked. */
  3    49     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  3    50     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  3    51     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  3    52     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  3    53     2 starting_time fixed bin (71);			/* Time metering started. */
  3    54 
  3    55 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  3    56     2 device_name char (8),				/* Name of device associated with this entry. */
  3    57     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  3    58     2 dtypex fixed bin,				/* Device type index. */
  3    59     2 model fixed bin,				/* Device model number. */
  3    60     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  3    61     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  3    62     2 state_time fixed bin (71),			/* Time device put into current state. */
  3    63     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  3    64 						/* 3 - attaching  4 - attached   5 - completed. */
  3    65 
  3    66 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  3    67     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  3    68     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  3    69     2 user_off bit (18),				/* Offset of next entry in user list. */
  3    70     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  3    71     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  3    72     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  3    73     2 caller_level fixed bin,				/* Caller's validation level. */
  3    74     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  3    75     2 flags,					/* Special info flags. */
  3    76      (3 device bit (1),				/* ON => assigning a specific device. */
  3    77       3 priv bit (1),				/* ON => attached with IOI privilege. */
  3    78       3 system bit (1),				/* ON => assigned to a system process. */
  3    79       3 t_and_d bit (1),				/* ON => T&D attachment. */
  3    80       3 volume bit (1),				/* ON => volume associated with this device. */
  3    81       3 writing bit (1),				/* ON => writing on volume. */
  3    82       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  3    83       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  3    84       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  3    85       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  3    86       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  3    87       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  3    88       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  3    89       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  3    90       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  3    91       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  3    92       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  3    93       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  3    94       3 fips bit (1),				/* ON => FIPS device. */
  3    95       3 no_protect bit (1),				/* ON => device has no protect sw. */
  3    96       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  3    97       3 unused bit (6),
  3    98       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  3    99       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  3   100     2 rcp_id bit (36),				/* ID of this entry. */
  3   101     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  3   102     2 process_id bit (36),				/* ID of calling process. */
  3   103     2 group_id char (32),				/* Group ID of calling process. */
  3   104     2 ecode fixed bin (35),				/* Assignment error code. */
  3   105     2 version_num fixed bin,				/* Device info version number. */
  3   106     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  3   107     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  3   108     2 ioi_index fixed bin,				/* IOI device index. */
  3   109     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  3   110     2 caller_comment char (64);			/* Caller's comment. */
  3   111 
  3   112 /*	End of include file ... rcp_com_seg.incl.pl1	*/
      103 
      104 
      105 detach:
      106      entry (arg_rcp_id, arg_disposition, arg_error_count, arg_comment, arg_ecode);
      107 
      108 /*	This entry implements the rcp_$detach entry point.  It is also called by
      109*   *	RCP programs.  This entry point will detach the device associated with the
      110*   *	specified RCSE entry.  Depending upon the disposition specified in the
      111*   *	call and the disposition specified in the associated assignment RCSE we
      112*   *	will also unassign the device.  In all cases where there is a volume
      113*   *	attached on this drive we will unassign the volume.
      114**/
      115 
      116 	call SETUP;
      117 	force_detach_entry = "0"b;
      118 	call cu_$level_get (caller_level);		/* Get caller's validation level. */
      119 	on cleanup
      120 	     begin;				/* Cleanup if any trouble. */
      121 		call cu_$level_set (caller_level);	/* Reset validation level to caller level. */
      122 	     end;
      123 	call cu_$level_set (get_ring_ ());		/* Set validation level to RCP level. */
      124 
      125 	rcp_id = arg_rcp_id;			/* Copy arguments. */
      126 	disposition = arg_disposition;
      127 	error_count = arg_error_count;
      128 
      129 	call rcp_validate_ (rcp_id, caller_level, rcse_ptr, ecode);
      130 	if ecode ^= 0				/* Is rcp_id OK? */
      131 	then
      132 	     if ecode = error_table_$force_unassign then
      133 		;
      134 	     else goto RETURN;			/* No. */
      135 
      136 	if rcse.kind ^= 1				/* Is this an attachment entry? */
      137 	then do;					/* No. */
      138 		ecode = error_table_$bad_arg;
      139 		goto RETURN;
      140 	     end;
      141 
      142 	if rcse.ioi_index ^= 0			/* Is device attached to IOI? */
      143 	then do;					/* Yes, detach it. */
      144 		call DETACH;			/* Detach and tell operator. */
      145 		call admin_gate_$syserr (0, "RCP: Detached ^a from ^a", rcse.device_name, rcse.group_id);
      146 
      147 		call rcp_mount_timer_$reset (rcse.device_off, dcode);
      148 						/* Make sure and stop all check mount messages, ignore dcode. */
      149 
      150 		if error_count > 0			/* Report any errors. */
      151 		then
      152 		     if rcse.volume_name = "" then
      153 			call admin_gate_$syserr (0, "RCP: Errors (^a) = ^d", rcse.device_name, error_count);
      154 		     else call admin_gate_$syserr (0, "RCP: Errors (^a, volume ^a) = ^d", rcse.device_name,
      155 			     rcse.volume_name, error_count);
      156 	     end;
      157 
      158 	rcse.caller_comment = arg_comment;		/* Get comment argument. */
      159 	call rcp_comment_ (rcse_ptr);			/* Type caller's comment. */
      160 
      161 	arcse_ptr = ptr (rcse_ptr, rcse.rcse_off);	/* Get pointer to assignment RCS entry. */
      162 	if ^disposition				/* Should we use default disposition? */
      163 	then
      164 	     disposition = arcse.disposition;		/* Yes, get it from assignment entry. */
      165 
      166 	device_off,				/* No device or volume specified yet. */
      167 	     volume_off = "0"b;
      168 
      169 	if error_count > 0				/* Are there any errors to report? */
      170 	then do;					/* Yes, for now just update error count. */
      171 		operation = access_operations_$rcp_error_count;
      172 		device_off = arcse.device_off;
      173 	     end;
      174 
      175 	if ^disposition				/* Should we unassign the device? */
      176 	then do;					/* Yes, rcp_initializer_ will do it. */
      177 		operation = access_operations_$rcp_unassign;
      178 		device_off = arcse.device_off;	/* Get RCPD offset of device. */
      179 		call rcp_rcse_$free (arcse_ptr, dcode);
      180 		if ecode = 0			/* If no previous error use this error code. */
      181 		then
      182 		     ecode = dcode;
      183 	     end;
      184 	else do;
      185 		arcse.rcse_off = "0"b;		/* No, just show that device no longer attached. */
      186 		device_off = "0"b;			/* Don't unassign this device! */
      187 	     end;
      188 
      189 	if rcse.flags.volume			/* Is there a volume to unassign? */
      190 	then do;					/* Yes, rcp_initializer_ will do it. */
      191 		operation = access_operations_$rcp_unassign;
      192 		volume_off = rcse.volume_off;		/* Get RCPD offset of volume. */
      193 	     end;
      194 
      195 	call rcp_rcse_$free (rcse_ptr, dcode);		/* Always free attachment entry. */
      196 	if ecode = 0 then
      197 	     ecode = dcode;
      198 
      199 	if operation ^= ""b				/* Is there any reason to call rcp_control_? */
      200 	then do;					/* Yes, something for it to do. */
      201 		call rcp_control_ (operation, volume_off, device_off, device_name, error_count, process_id, ecode);
      202 	     end;
      203 
      204 RETURN:
      205 	arg_ecode = ecode;
      206 	call cu_$level_set (caller_level);
      207 	return;					/*						*/
      208 force_detach:
      209      entry (arg_rcse_ptr);
      210 
      211 /*	This entry point is an internal interface of RCP.  It is called to
      212*   *	detach a device that is being forcedly unassigned.  Freeing the
      213*   *	attachment RCSE and the unassignment of the device and any volume
      214*   *	mounted on it must be done by the caller.
      215**/
      216 
      217 	call SETUP;
      218 	force_detach_entry = "1"b;
      219 	rcse_ptr = arg_rcse_ptr;			/* Get pointer to attachment RCSE. */
      220 
      221 	if rcse.ioi_index = 0			/* Is device actually attached via IOI? */
      222 	then
      223 	     return;				/* No, we don't have to do anything. */
      224 
      225 	call DETACH;				/* Now go and detach the device. */
      226 
      227 /* Tell operator about force detachment. */
      228 	call admin_gate_$syserr (0, "RCP: Force Detached ^a from ^a", rcse.device_name, rcse.group_id);
      229 	return;
      230 
      231 
      232 
      233 
      234 
      235 SETUP:
      236      procedure;
      237 
      238 	device_off = ""b;
      239 	volume_off = ""b;
      240 	process_id = ""b;
      241 	device_name = "";
      242 	operation = ""b;
      243 	error_count = 0;
      244 
      245      end SETUP;
      246 
      247 
      248 DETACH:
      249      procedure;
      250 
      251 /*	This procedure is called to perform the actual device detachment.
      252*   *	What we have to do depends upon the device type.
      253**/
      254 	ioi_index = rcse.ioi_index;			/* Save IOI index. */
      255 	rcse.ioi_index = 0;				/* Make sure IOI never called again by RCP. */
      256 	goto DTYPE (rcse.dtypex);			/* Process according to device type. */
      257 
      258 DTYPE (1):					/* TAPE */
      259 	call admin_gate_$ioi_detach (ioi_index, ecode);
      260 	if rcp_pointers_$data () -> rcpd.modes.unload_on_detach then
      261 	     call UNLOAD_DEVICE ();
      262 	return;
      263 
      264 DTYPE (2):					/* DISK */
      265 	call admin_gate_$ioi_detach (ioi_index, ecode);
      266 	call UNLOAD_DEVICE ();
      267 	return;
      268 
      269 DTYPE (8):					/* MCA */
      270 	call mca_attach_$finish_detach (ioi_index, force_detach_entry, ecode);
      271 DTYPE (3):					/* CONSOLE */
      272 DTYPE (4):					/* PRINTER */
      273 DTYPE (5):					/* PUNCH */
      274 DTYPE (6):					/* READER */
      275 DTYPE (7):					/* SPECIAL */
      276 	call admin_gate_$ioi_detach (ioi_index, ecode);
      277 
      278      end DETACH;
      279 
      280 /*
      281*
      282*   This internal procedure gets the device_ptr for the device being detached
      283*   and unloades that device by calling rcp_unload_.  This entry is
      284*   normally called with rcp_data locked, but, in this case, the data base
      285*   does not need to be locked.  This is due to the fact that no one can be
      286*   using this device entry except this user until rcp_initializer_ resets
      287*   its state.
      288*
      289**/
      290 
      291 
      292 UNLOAD_DEVICE:
      293      proc ();
      294 
      295 
      296 	dcl     rcp_pointers_$data	 entry () returns (ptr);
      297 	dcl     rcp_unload_$unload_device
      298 				 entry (ptr, bit (1));
      299 
      300 
      301 	if rcse.rcse_off = "0"b then
      302 	     return;				/* Cannot get to needed rcse. */
      303 	arcse_ptr = ptr (rcse_ptr, rcse.rcse_off);	/* Get ptr to device rcse. */
      304 	if arcse.device_off = "0"b then
      305 	     return;				/* Cannot get to device entry. */
      306 	device_ptr = ptr (rcp_pointers_$data (), rcse.device_off);
      307 	device.flags.attached = "0"b;			/* Mark it as _n_o_t attached. */
      308 	call rcp_unload_$unload_device (device_ptr, "0"b);/* Unload the device. */
      309 	return;
      310 
      311 
      312      end UNLOAD_DEVICE;
      313 
      314 /* BEGIN MESSAGE DOCUMENTATION
      315*
      316*   Message:
      317*   RCP: Detached DEVICE from PERSON.PROJ.T
      318*
      319*   S:	$info
      320*
      321*   T:	$run
      322*
      323*   M:	The user of DEVICE has detached it.
      324*
      325*   A:	If DEVICE is a disk drive, demount the volume on it and store it in the library.
      326*
      327*
      328*   Message:
      329*   RCP: Force Detached DEVICE from PERSON.PROJ.T
      330*
      331*   S:	$info
      332*
      333*   T:	$run
      334*
      335*   M:	The user PERSON.PROJ.T has terminated abnormally.
      336*   This may be due to an automatic logout or a process termination.
      337*
      338*   A:	If DEVICE is a disk drive, demount the volume on it and store it in the library.
      339*
      340*
      341*   Message:
      342*   RCP: Errors (DEVICE) = NN
      343*
      344*   S:	$info
      345*
      346*   T:	$run
      347*
      348*   M:	When DEVICE was detached, its error counter was nonzero.
      349*   This may be due to a problem with DEVICE or with the user program.
      350*
      351*   A:	$ignore
      352*
      353*
      354*   Message:
      355*   RCP: Errors (DEVICE, volume VOL) = NN
      356*
      357*   S:	$info
      358*
      359*   T:	$run
      360*
      361*   M:	When DEVICE was detached, its error counter was nonzero.
      362*   The errors may be due to a problem with DEVICE,
      363*   with the volume VOLUME,
      364*   or with the user program.
      365*
      366*   A:	$ignore
      367*
      368*
      369*   Message:
      370*   RCP: Unloading volume VOLUME from device DEVICE
      371*
      372*   S:	$info
      373*
      374*   T:	$run
      375*
      376*   M:	The specified VOLUME is being demounted by RCP.
      377*
      378*   A:	Return the specified VOLUME to the library.
      379*
      380*
      381*   Message:
      382*   RCP: Manually unload volume VOLUME from device DEVICE
      383*
      384*   S:	$beep
      385*
      386*   T:	$run
      387*
      388*   M:	RCP could not unload the specified volume from the device on which it was loaded.
      389*
      390*   A:	Manually unload the volume from the device and return the volume to the library for storage.
      391*
      392*
      393*   END MESSAGE DOCUMENTATION */
      394 
      395      end rcp_detach_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0805.9  rcp_detach_.pl1                   >spec>install>1111>rcp_detach_.pl1
102          1    03/27/86  1120.0  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
1-113        2    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
103          3    03/27/86  1120.0  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
access_operations_$rcp_error_count
                                000014 external static bit(36)                  dcl 85 ref 171
access_operations_$rcp_unassign 000016 external static bit(36)                  dcl 86 ref 177 191
admin_gate_$ioi_detach          000020 constant        entry                    external dcl 88 ref 258 264 271
admin_gate_$syserr              000022 constant        entry                    external dcl 89 ref 145 150 154 228
arcse                                  based           structure                level 1 dcl 71
arcse_ptr                       000120 automatic       pointer                  dcl 61 set ref 161* 162 172 178 179* 185 303* 304
arg_comment                            parameter       char                     packed unaligned dcl 38 ref 105 158
arg_disposition                        parameter       bit                      packed unaligned dcl 39 ref 105 126
arg_ecode                              parameter       fixed bin(35,0)          dcl 40 set ref 105 204*
arg_error_count                        parameter       fixed bin(17,0)          dcl 41 ref 105 127
arg_rcp_id                             parameter       bit(36)                  dcl 42 ref 105 125
arg_rcse_ptr                           parameter       pointer                  dcl 43 ref 208 219
attached                 35(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-59 set ref
                                                                                  307*
caller_comment           64            based           char(64)                 level 2 dcl 3-55 set ref 158*
caller_level                    000122 automatic       fixed bin(17,0)          dcl 62 set ref 118* 121* 129* 206*
cleanup                         000130 stack reference condition                dcl 77 ref 119
cu_$level_get                   000024 constant        entry                    external dcl 90 ref 118
cu_$level_set                   000026 constant        entry                    external dcl 91 ref 121 123 206
dcode                           000123 automatic       fixed bin(35,0)          dcl 63 set ref 147* 179* 180 195* 196
device                                 based           structure                level 1 dcl 1-59
device_name                            based           char(8)                  level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_" set ref 145* 150* 154* 228*
device_name                     000106 automatic       char(32)                 packed unaligned dcl 58 in procedure "rcp_detach_"
                                                                                  set ref 201* 241*
device_off               30            based           bit(18)                  level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_" set ref 147* 306
device_off                      000101 automatic       bit(18)                  dcl 49 in procedure "rcp_detach_" set ref 166* 172*
                                                                                  178* 186* 201* 238*
device_off               30            based           bit(18)                  level 2 in structure "arcse" dcl 71 in procedure
                                                                                  "rcp_detach_" ref 172 178 304
device_ptr                      000136 automatic       pointer                  dcl 1-26 set ref 306* 307 308*
disposition                     000100 automatic       bit(1)                   packed unaligned dcl 48 in procedure "rcp_detach_"
                                                                                  set ref 126* 162 162* 175
disposition              34            based           bit(1)                   level 2 in structure "arcse" dcl 71 in procedure
                                                                                  "rcp_detach_" ref 162
dtype                                  based           structure                level 1 dcl 1-51
dtypex                   12            based           fixed bin(17,0)          level 2 dcl 3-55 ref 256
ecode                           000124 automatic       fixed bin(35,0)          dcl 64 set ref 129* 130 130 138* 180 180* 196 196*
                                                                                  201* 204 258* 264* 269* 271*
error_count                     000125 automatic       fixed bin(17,0)          dcl 65 set ref 127* 150 150* 154* 169 201* 243*
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 81 ref 138
error_table_$force_unassign     000012 external static fixed bin(35,0)          dcl 82 ref 130
flags                    35            based           structure                level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_"
flags                    35            based           structure                level 2 in structure "device" dcl 1-59 in procedure
                                                                                  "rcp_detach_"
force_detach_entry              000102 automatic       bit(1)                   packed unaligned dcl 51 set ref 117* 218* 269*
get_ring_                       000030 constant        entry                    external dcl 92 ref 123 123
group_id                 43            based           char(32)                 level 2 dcl 3-55 set ref 145* 228*
ioi_index                60            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_" set ref 142 221 254 255*
ioi_index                       000126 automatic       fixed bin(17,0)          dcl 66 in procedure "rcp_detach_" set ref 254* 258*
                                                                                  264* 269* 271*
kind                     25            based           fixed bin(17,0)          level 2 dcl 3-55 ref 136
lock_info                              based           structure                level 1 dcl 3-46
mca_attach_$finish_detach       000032 constant        entry                    external dcl 93 ref 269
modes                    14(01)        based           structure                level 2 packed packed unaligned dcl 1-29
operation                       000116 automatic       bit(36)                  dcl 59 set ref 171* 177* 191* 199 201* 242*
process_id                      000105 automatic       bit(36)                  dcl 55 set ref 201* 240*
ptr                                                    builtin function         dcl 79 ref 161 303 306
rcp_comment_                    000034 constant        entry                    external dcl 94 ref 159
rcp_control_                    000036 constant        entry                    external dcl 95 ref 201
rcp_id                          000104 automatic       bit(36)                  dcl 54 set ref 125* 129*
rcp_init_flags                         based           structure                level 1 packed packed unaligned dcl 2-8
rcp_mount_timer_$reset          000046 constant        entry                    external dcl 100 ref 147
rcp_pointers_$data              000044 constant        entry                    external dcl 99 in procedure "rcp_detach_" ref 260
rcp_pointers_$data              000050 constant        entry                    external dcl 296 in procedure "UNLOAD_DEVICE" ref
                                                                                  306
rcp_rcse_$free                  000040 constant        entry                    external dcl 97 ref 179 195
rcp_unload_$unload_device       000052 constant        entry                    external dcl 297 ref 308
rcp_validate_                   000042 constant        entry                    external dcl 98 ref 129
rcpd                                   based           structure                level 1 dcl 1-29
rcse                                   based           structure                level 1 dcl 3-55
rcse_off                 32            based           bit(18)                  level 2 in structure "arcse" dcl 71 in procedure
                                                                                  "rcp_detach_" set ref 185*
rcse_off                 32            based           bit(18)                  level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_" ref 161 301 303
rcse_ptr                        000140 automatic       pointer                  dcl 3-24 set ref 129* 136 142 145 145 147 150 150
                                                                                  154 154 158 159* 161 161 189 192 195* 219* 221 228
                                                                                  228 254 255 256 301 303 303 306
unload_on_detach         14(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-29 ref 260
volume                   35(04)        based           bit(1)                   level 3 in structure "rcse" packed packed unaligned
                                                                                  dcl 3-55 in procedure "rcp_detach_" ref 189
volume                                 based           structure                level 1 dcl 1-101 in procedure "rcp_detach_"
volume_name               2            based           char(32)                 level 2 dcl 3-55 set ref 150 154*
volume_off               31            based           bit(18)                  level 2 in structure "rcse" dcl 3-55 in procedure
                                                                                  "rcp_detach_" ref 192
volume_off                      000103 automatic       bit(18)                  dcl 52 in procedure "rcp_detach_" set ref 166* 192*
                                                                                  201* 239*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 2-16
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 2-16
No_authentication                      internal static fixed bin(17,0)          initial dcl 2-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 2-16
addr                                                   builtin function         dcl 79
authentication_level_names             internal static char(12)                 initial array packed unaligned dcl 2-21
based_rcp_id                           based           structure                level 1 dcl 3-26
dtype_ptr                              automatic       pointer                  dcl 1-25
lock_info_ptr                          automatic       pointer                  dcl 3-22
rcpd_ptr                               automatic       pointer                  dcl 1-24
rcs                                    based           structure                level 1 dcl 3-30
rcs_ptr                                automatic       pointer                  dcl 3-23
rifp                                   automatic       pointer                  dcl 2-6
volume_ptr                             automatic       pointer                  dcl 1-27

NAMES DECLARED BY EXPLICIT CONTEXT.
DETACH                          000671 constant        entry                    internal dcl 248 ref 144 225
DTYPE                           000000 constant        label                    array(8) dcl 258 ref 256
RETURN                          000567 constant        label                    dcl 204 ref 130 139
SETUP                           000657 constant        entry                    internal dcl 235 ref 116 217
UNLOAD_DEVICE                   000766 constant        entry                    internal dcl 292 ref 260 266
detach                          000100 constant        entry                    external dcl 105
force_detach                    000605 constant        entry                    external dcl 208
rcp_detach_                     000065 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1316        1372    1035        1326
Length      1646    1035        54         240     261           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_detach_                         234 external procedure  is an external procedure.  
on unit on line 119                  68 on unit               
SETUP                                   internal procedure  shares stack frame of external procedure rcp_detach_.  
DETACH                                  internal procedure  shares stack frame of external procedure rcp_detach_.  
UNLOAD_DEVICE                           internal procedure  shares stack frame of external procedure rcp_detach_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_detach_              000100 disposition                 rcp_detach_
                         000101 device_off                  rcp_detach_
                         000102 force_detach_entry          rcp_detach_
                         000103 volume_off                  rcp_detach_
                         000104 rcp_id                      rcp_detach_
                         000105 process_id                  rcp_detach_
                         000106 device_name                 rcp_detach_
                         000116 operation                   rcp_detach_
                         000120 arcse_ptr                   rcp_detach_
                         000122 caller_level                rcp_detach_
                         000123 dcode                       rcp_detach_
                         000124 ecode                       rcp_detach_
                         000125 error_count                 rcp_detach_
                         000126 ioi_index                   rcp_detach_
                         000136 device_ptr                  rcp_detach_
                         000140 rcse_ptr                    rcp_detach_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry           ext_entry_desc
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$ioi_detach        admin_gate_$syserr            cu_$level_get                 cu_$level_set
get_ring_                     mca_attach_$finish_detach     rcp_comment_                  rcp_control_
rcp_mount_timer_$reset        rcp_pointers_$data            rcp_pointers_$data            rcp_rcse_$free
rcp_unload_$unload_device     rcp_validate_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$rcp_error_count                          access_operations_$rcp_unassign
error_table_$bad_arg          error_table_$force_unassign




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000064       105 000072       116 000120       117 000121       118 000122       119 000131       121 000145
    122 000154       123 000155       125 000173       126 000176       127 000204       129 000206       130 000223
    136 000230       138 000234       139 000237       142 000240       144 000242       145 000243       147 000300
    150 000312       154 000356       158 000412       159 000421       161 000430       162 000435       166 000441
    169 000443       171 000445       172 000450       175 000452       177 000454       178 000457       179 000461
    180 000471       183 000475       185 000476       186 000477       189 000500       191 000504       192 000507
    195 000511       196 000522       199 000526       201 000530       204 000567       206 000572       207 000601
    208 000602       217 000612       218 000613       219 000615       221 000621       225 000623       228 000624
    229 000656       235 000657       238 000660       239 000661       240 000662       241 000663       242 000666
    243 000667       245 000670       248 000671       254 000672       255 000675       256 000676       258 000700
    260 000711       262 000725       264 000726       266 000737       267 000740       269 000741       271 000754
    278 000765       292 000766       301 000767       303 000773       304 000776       306 001001       307 001016
    308 001020       309 001033


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
