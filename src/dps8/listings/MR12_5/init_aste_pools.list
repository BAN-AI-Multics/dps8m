	COMPILATION LISTING OF SEGMENT init_aste_pools
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0957.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* format: style2 */
        9 
       10 
       11 init_aste_pools: proc ();
       12 
       13 /* format: off */
       14 
       15 /* This procedure initializes all the ASTEs and initializes them. It also sets
       16*   up some pointers in the (currently unpaged) name table, as well. */
       17 
       18 /* Written 03/24/81, W. Olin Sibert, extracted from init_sst and made more efficient
       19*   Modified 04/17/81, WOS, for ptw_util_$make_null
       20*   */
       21 
       22 /* format: on */
       23 
       24 dcl  page_idx fixed bin;
       25 dcl  pool_idx fixed bin;
       26 dcl  aste_idx fixed bin;
       27 dcl  aste_size fixed bin (10);
       28 dcl  aste_count fixed bin;
       29 dcl (prev_aste_offset, next_aste_offset) fixed bin (18) unsigned;
       30 dcl (first_astep, last_astep) pointer;
       31 dcl  astnoff fixed bin (18);
       32 dcl  ptp pointer;
       33 
       34 dcl 1 template_aste aligned automatic,
       35     2 aste_part like aste aligned,
       36     2 page_table (256) bit (36) aligned;
       37 
       38 dcl  template_ptw bit (36) aligned;
       39 
       40 dcl 1 aste_threads aligned automatic,			/* Used to generate the threads */
       41     2 next fixed bin (18) unsigned unaligned,
       42     2 prev fixed bin (18) unsigned unaligned;
       43 
       44 dcl  based_thread_word bit (36) aligned based;		/* For assigning the threads to word zero of the ASTE */
       45 dcl  aste_overlay (aste_size) bit (36) aligned based;	/* For assigning the whole ASTE */
       46 
       47 dcl  ptw_util_$make_null entry (pointer, bit (22) aligned);
       48 
       49 dcl (addr, addrel, binary, bit, rel) builtin;
       50 
       51 /*  */
       52 
       53 	sstp = addr (sst_seg$);			/* Initialize */
       54 	sstnp = addr (sst_names_$);
       55 
       56 	unspec (template_aste) = ""b; 		/* Initialize the template */
       57 	template_aste.marker = "02"b3;		/* Put DF2 in the last word of the ASTE */
       58 
       59 	call ptw_util_$make_null (addr (template_ptw), init_sst_null_addr); /* Fabricate a PTW */
       60 
       61 	template_aste.page_table (*) = template_ptw;	/* All init_sst ptws are the same */
       62 
       63 	astnoff = 0;				/* SST names start at zero */
       64 	astep = sst.astap;				/* Beginning of ASTE array */
       65 
       66 	do pool_idx = 0 to 3;
       67 	     aste_count = binary (sst.no_aste (pool_idx), 18);
       68 	     aste_size = size (aste) + sst.pts (pool_idx);
       69 
       70 	     first_astep = astep;			/* And its first and last members */
       71 	     last_astep = addrel (first_astep, (aste_count - 1) * aste_size);
       72 
       73 	     template_aste.ptsi = bit (binary (pool_idx, 2), 2); /* Set up the template properly for this pool */
       74 
       75 	     sstnp -> sstnt.ast_offsets (pool_idx) = binary (rel (astep), 18); /* Initialize pool base */
       76 	     sstnp -> sstnt.ast_name_offsets (pool_idx) = astnoff; /* set up array index base aswell */
       77 	     sstnp -> sstnt.ast_sizes (pool_idx) = aste_size; /* set up ASTE size for easy calc. */
       78 	     astnoff = astnoff + aste_count;		/* SSTNT initialization */
       79 
       80 	     aste_threads.prev = binary (rel (first_astep), 18) - aste_size; /* Use these to thread in "by hand" */
       81 	     aste_threads.next = binary (rel (first_astep), 18) + aste_size;
       82 
       83 	     do aste_idx = 1 to aste_count;		/* loop through for number of entries for this size */
       84 		astep -> aste_overlay = addr (template_aste) -> aste_overlay;
       85 		astep -> based_thread_word = unspec (aste_threads); /* "thread" it in */
       86 		aste_threads.next = aste_threads.next + aste_size; /* and update to the next ASTE */
       87 		aste_threads.prev = aste_threads.prev + aste_size;
       88 		astep = addrel (astep, aste_size);	/* and point to the next one */
       89 		end;				/* of a single pool */
       90 
       91 	     first_astep -> aste.bp = rel (last_astep);	/* Thread in the first and last ASTEs properly */
       92 	     last_astep -> aste.fp = rel (first_astep);
       93 
       94 	     sst.ausedp (pool_idx) = rel (first_astep);	/* And initialize the list pointer */
       95 	     end; 				/* of loop through pools */
       96 
       97 	return;
       98 
       99 /* format: off */
      100 
      101  /* BEGIN INCLUDE FILE ... system_types.incl.pl1 ... 03/23/81 ... W. Olin Sibert */
  1     2 
  1     3 dcl  L68_SYSTEM	fixed bin (17) internal static options (constant) init (1);
  1     4 dcl  ADP_SYSTEM	fixed bin (17) internal static options (constant) init (2);
  1     5 
  1     6 dcl  SYSTEM_TYPE_NAME (2) char (8) internal static options (constant) init
  1     7     ("Level68", "ADP");
  1     8 
  1     9 /* END INCLUDE FILE ... system_types.incl.pl1 */
      101 
      102  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      102 
      103  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  3     2 /* Added segmove values, Benson Margulies, 84-01 */
  3     3 
  3     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  3     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  3     6      get_aste_null_addr init			("3770110"b3),
  3     7      make_sdw_null_addr init			("3770120"b3),
  3     8      put_aste_null_addr init			("3770130"b3),
  3     9      page_bad_pd_null_addr init		("3770150"b3),
  3    10      list_deposit_null_addr init		("3770160"b3),
  3    11      get_file_map_null_addr init		("3770170"b3),
  3    12      fill_page_table_null_addr init		("3770200"b3),
  3    13      init_sst_null_addr init			("3770210"b3),
  3    14      get_file_map_vt_null_addr init		("3770220"b3),
  3    15      unprotected_null_addr init		("3770230"b3),
  3    16      page_bad_null_addr init			("3770240"b3),
  3    17      page_problem_null_addr init		("3770250"b3),
  3    18      page_parity_null_addr init		("3770260"b3),
  3    19      page_devparity_null_addr init		("3770270"b3),
  3    20      segmove_old_addr_null_addr init              ("3770300"b3),
  3    21      segmove_new_addr_null_addr init		("3770310"b3),
  3    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  3    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  3    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  3    25 
  3    26 dcl (create_vtoce_null_addr init		("777777"b3),
  3    27      update_vtoce_null_addr init		("777776"b3),
  3    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  3    29      truncate_vtoce_null_addr init		("777002"b3),
  3    30      pv_salv_null_addr init			("777004"b3),
  3    31      pv_scav_null_addr init			("777006"b3),
  3    32      volume_reloader_null_addr init		("777774"b3),
  3    33      volume_retriever_null_addr init		("777773"b3),
  3    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  3    35 
  3    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
      103 
      104  /* Begin include file sstnt.incl.pl1   */
  4     2 
  4     3 /* Created 10/03/74 by Bernard Greenberg */
  4     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  4     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  4     6 
  4     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  4     8 
  4     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  4    10 
  4    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  4    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  4    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  4    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  4    15     2 pad1 (5) fixed bin,
  4    16 
  4    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  4    18      ast_name_offsets,				/* Starting index for names at each level */
  4    19      ast_offsets,					/* Starting rel addr of each AST region */
  4    20      pad2) (0 : 3) fixed bin,
  4    21 
  4    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  4    23 
  4    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  4    25 
  4    26 dcl  nm_astep ptr;					/* astep to be used */
  4    27 
  4    28 /* End include file sstnt.incl.pl1 */
      104 
      105  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  5     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  5     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  5     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  5     5 
  5     6 dcl  sst_seg$ external;
  5     7 dcl  sstp ptr;
  5     8 
  5     9 dcl 1 sst based (sstp) aligned,
  5    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  5    11 
  5    12 /* SST HEADER */
  5    13 
  5    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  5    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  5    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  5    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  5    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  5    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  5    20 
  5    21     2 ptl bit (36),					/* global page table loop lock */
  5    22     2 astl bit (36),				/* global ast allocation block lock */
  5    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  5    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  5    25     2 nused fixed bin,				/* number of pages on used list */
  5    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  5    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  5    28 
  5    29     2 astap ptr,					/* aste array pointer */
  5    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  5    31     2 astsize fixed bin,				/* size of an AST entry */
  5    32     2 cmesize fixed bin,				/* size of a CME entry */
  5    33     2 root_astep ptr,				/* pointer to the root AST entry */
  5    34 
  5    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  5    36     2 level (0:3),					/* per-list information about ASTE's */
  5    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  5    38 
  5    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  5    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  5    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  5    42     2 strsize fixed bin,				/* Trailer size in words. */
  5    43 
  5    44 /* CORE MAP HEADER */
  5    45 
  5    46     2 cmp ptr,					/* pointer to start of core map */
  5    47     2 usedp bit (18),				/* pointer to first used core block */
  5    48     2 wtct fixed bin,				/* count of pages being written */
  5    49 
  5    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  5    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  5    52 						/* MISC */
  5    53 
  5    54     2 double_write fixed bin,				/* trigger for store through scheme */
  5    55 						/* 0 = no double writes,
  5    56*						   1 = all non-pd pages get written,
  5    57*						   2 = all directories get written */
  5    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  5    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  5    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  5    61 
  5    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  5    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  5    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  5    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  5    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  5    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  5    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  5    69 
  5    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  5    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  5    72 
  5    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  5    74 
  5    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  5    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  5    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  5    78 
  5    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  5    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  5    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  5    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  5    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  5    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  5    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  5    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  5    87 
  5    88 
  5    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  5    90 
  5    91     2 steps fixed bin,				/* number of steps taken around used list */
  5    92     2 needc fixed bin,				/* number of times core page needed */
  5    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  5    94     2 ctwait fixed bin,				/* number of times write counter was full */
  5    95     2 wired fixed bin,				/* number of pages wired by pc */
  5    96     2 laps fixed bin,				/* number of times around used list */
  5    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  5    98     2 skipu fixed bin,				/* because of being used */
  5    99 
  5   100     2 skipm fixed bin,				/* because of being modified */
  5   101     2 skipos fixed bin,				/* because out of service */
  5   102     2 aused fixed bin,				/* number of AST entries on used list */
  5   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  5   104     2 deact_count fixed bin,				/* count of deactivations */
  5   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  5   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  5   107 
  5   108     2 reads (8) fixed bin,				/* number of reads for each did */
  5   109     2 writes (8) fixed bin,				/* number of writes for each did */
  5   110 
  5   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  5   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  5   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  5   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  5   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  5   116     2 total_sf fixed bin,				/* total number of seg_faults */
  5   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  5   118     2 post_list_size fixed bin,
  5   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  5   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  5   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  5   122     2 pre_page_list_size fixed bin,
  5   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  5   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  5   125 
  5   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  5   127 
  5   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  5   129 
  5   130 /* MAIN MEMORY USAGE INFORMATION */
  5   131 
  5   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  5   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  5   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  5   135     2 recopies fixed bin,				/* number of times recopied because modified */
  5   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  5   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  5   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  5   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  5   140 
  5   141 /*  AST METERS  */
  5   142 
  5   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  5   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  5   145 
  5   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  5   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  5   148     2 asearches fixed bin,				/* count of full searches made */
  5   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  5   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  5   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  5   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  5   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  5   154 
  5   155     2 alaps fixed bin,				/* lap counter for AST list */
  5   156     2 updates fixed bin,				/* calls to updateb */
  5   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  5   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  5   159     2 total_bf fixed bin,				/* count of bound faults */
  5   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  5   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  5   162 
  5   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  5   164 
  5   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  5   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  5   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  5   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  5   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  5   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  5   171 
  5   172 /* PRE-PAGE METERS */
  5   173 
  5   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  5   175 
  5   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  5   177 
  5   178 
  5   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  5   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  5   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  5   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  5   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  5   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  5   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  5   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  5   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  5   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  5   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  5   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  5   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  5   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  5   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  5   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  5   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  5   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  5   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  5   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  5   199     2 activations fixed bin,				/* total count of activations */
  5   200     2 dir_activations fixed bin,			/* count of directory activations */
  5   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  5   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  5   203     2 evict_recover_data,				/* see evict_page.alm */
  5   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  5   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  5   206 
  5   207 /* Data for metering force_write facility 08/19/78 */
  5   208 
  5   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  5   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  5   211     2 fw_none fixed bin,				/* Force write wrote none */
  5   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  5   213 
  5   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  5   215     2 pf_unlock_ptl_meterings fixed bin,
  5   216 
  5   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  5   218     2 backup_activations fixed bin (35),		/* activations for backup */
  5   219     2 metering_flags aligned,				/* small chunks of misc. information */
  5   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  5   221       3 pad bit (35) unal,
  5   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  5   223 
  5   224 /* METERS FOR STACK TRUNCATION */
  5   225 
  5   226     2 (stk_truncate_should_didnt,			/* counts */
  5   227        stk_truncate_should_did,
  5   228        stk_truncate_shouldnt_didnt,
  5   229        stk_truncate_shouldnt_did) fixed bin (35),
  5   230     2 stk_pages_truncated fixed bin (35),
  5   231     2 stk_pages_truncated_in_core fixed bin (35),
  5   232 
  5   233 /* SUPPORT FOR PC SEGMOVES */
  5   234 
  5   235     2 segmove_lock aligned,
  5   236       3 pid bit (36) aligned,
  5   237       3 event bit (36) aligned,
  5   238       3 notify bit (1) aligned,
  5   239     2 segmove_io_limit fixed bin, /* max read aheads */
  5   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  5   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  5   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  5   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  5   244 
  5   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  5   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  5   247     2 segmove_vtocx fixed bin,			/* ditto */
  5   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  5   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  5   250 
  5   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  5   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  5   253     2 trace_sw aligned,				/* tracing control flags */
  5   254       3 pad_trace bit (32) unaligned,
  5   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  5   256       3 tty_trace bit (1) unaligned,
  5   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  5   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  5   259     2 new_pages fixed bin,				/* newly created pages */
  5   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  5   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  5   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  5   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  5   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  5   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  5   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  5   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  5   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  5   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  5   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  5   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  5   272 
  5   273 /* END INCLUDE FILE sst.incl.pl1 */
      105 
      106 
      107 	end init_aste_pools;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0815.8  init_aste_pools.pl1               >spec>install>1112>init_aste_pools.pl1
101          1    06/19/81  2115.0  system_types.incl.pl1             >ldd>include>system_types.incl.pl1
102          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
103          3    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
104          4    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
105          5    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 49 ref 53 54 59 59 84
addrel                                                 builtin function         dcl 49 ref 71 88
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 4-11 set ref 76*
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 4-11 set ref 75*
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 4-11 set ref 77*
astap                    30            based           pointer                  level 2 dcl 5-9 ref 64
aste                                   based           structure                level 1 dcl 2-11 set ref 68
aste_count                      000103 automatic       fixed bin(17,0)          dcl 28 set ref 67* 71 78 83
aste_idx                        000101 automatic       fixed bin(17,0)          dcl 26 set ref 83*
aste_overlay                           based           bit(36)                  array dcl 45 set ref 84* 84
aste_part                       000111 automatic       structure                level 2 dcl 34
aste_size                       000102 automatic       fixed bin(10,0)          dcl 27 set ref 68* 71 77 80 81 84 86 87 88
aste_threads                    000526 automatic       structure                level 1 dcl 40 set ref 85
astep                           000530 automatic       pointer                  dcl 2-9 set ref 64* 68 70 75 84 85 88* 88
astnoff                         000110 automatic       fixed bin(18,0)          dcl 31 set ref 63* 76 78* 78
ausedp                   44            based           bit(18)                  array level 3 packed packed unaligned dcl 5-9 set
                                                                                  ref 94*
based_thread_word                      based           bit(36)                  dcl 44 set ref 85*
binary                                                 builtin function         dcl 49 ref 67 73 75 80 81
bit                                                    builtin function         dcl 49 ref 73
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-11 set ref 91*
first_astep                     000104 automatic       pointer                  dcl 30 set ref 70* 71 80 81 91 92 94
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 2-11 set ref 92*
init_sst_null_addr              000000 constant        bit(22)                  initial dcl 3-4 set ref 59*
last_astep                      000106 automatic       pointer                  dcl 30 set ref 71* 91 92
level                    44            based           structure                array level 2 dcl 5-9
marker                   13(30) 000111 automatic       bit(6)                   level 3 packed packed unaligned dcl 34 set ref 57*
next                            000526 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 40 set
                                                                                  ref 81* 86* 86
no_aste                  44(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 5-9 ref 67
page_table               14     000111 automatic       bit(36)                  array level 2 dcl 34 set ref 61*
pool_idx                        000100 automatic       fixed bin(17,0)          dcl 25 set ref 66* 67 68 73 75 76 77 94*
prev                      0(18) 000526 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 40 set
                                                                                  ref 80* 87* 87
pts                      40            based           fixed bin(17,0)          array level 2 dcl 5-9 ref 68
ptsi                     13(28) 000111 automatic       bit(2)                   level 3 packed packed unaligned dcl 34 set ref 73*
ptw_util_$make_null             000010 constant        entry                    external dcl 47 ref 59
rel                                                    builtin function         dcl 49 ref 75 80 81 91 92 94
sst                                    based           structure                level 1 dcl 5-9
sst_names_$                     000012 external static fixed bin(17,0)          dcl 4-7 set ref 54
sst_seg$                        000014 external static fixed bin(17,0)          dcl 5-6 set ref 53
sstnp                           000532 automatic       pointer                  dcl 4-9 set ref 54* 75 76 77
sstnt                                  based           structure                level 1 dcl 4-11
sstp                            000534 automatic       pointer                  dcl 5-7 set ref 53* 64 67 68 94
template_aste                   000111 automatic       structure                level 1 dcl 34 set ref 56* 84
template_ptw                    000525 automatic       bit(36)                  dcl 38 set ref 59 59 61

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADP_SYSTEM                             internal static fixed bin(17,0)          initial dcl 1-4
L68_SYSTEM                             internal static fixed bin(17,0)          initial dcl 1-3
SYSTEM_TYPE_NAME                       internal static char(8)                  initial array packed unaligned dcl 1-6
append_null_addr                       internal static bit(22)                  initial dcl 3-4
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 3-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 3-26
fill_page_table_null_addr              internal static bit(22)                  initial dcl 3-4
get_aste_null_addr                     internal static bit(22)                  initial dcl 3-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 3-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 3-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 3-4
list_deposit_null_addr                 internal static bit(22)                  initial dcl 3-4
make_sdw_null_addr                     internal static bit(22)                  initial dcl 3-4
next_aste_offset                       automatic       fixed bin(18,0)          unsigned dcl 29
nm_astep                               automatic       pointer                  dcl 4-26
page_bad_null_addr                     internal static bit(22)                  initial dcl 3-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 3-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 3-4
page_idx                               automatic       fixed bin(17,0)          dcl 24
page_parity_null_addr                  internal static bit(22)                  initial dcl 3-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 3-4
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 3-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 3-4
prev_aste_offset                       automatic       fixed bin(18,0)          unsigned dcl 29
ptp                                    automatic       pointer                  dcl 32
ptsi_a                                 automatic       fixed bin(17,0)          dcl 4-24
put_aste_null_addr                     internal static bit(22)                  initial dcl 3-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 3-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 3-26
salv_truncate_null_addr                internal static bit(18)                  initial dcl 3-26
seg_aste                               based           structure                level 1 dcl 2-96
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 3-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 3-4
sstnmx                                 automatic       fixed bin(17,0)          dcl 4-24
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 3-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 3-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 3-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 3-26
volume_reloader_null_addr              internal static bit(18)                  initial dcl 3-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 3-26

NAME DECLARED BY EXPLICIT CONTEXT.
init_aste_pools                 000002 constant        entry                    external dcl 11

NAMES DECLARED BY CONTEXT OR IMPLICATION.
size                                                   builtin function         ref 68
unspec                                                 builtin function         ref 56 85

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       254         272     202         264
Length       532     202        16         224      51           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_aste_pools                     361 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_aste_pools          000100 pool_idx                    init_aste_pools
                         000101 aste_idx                    init_aste_pools
                         000102 aste_size                   init_aste_pools
                         000103 aste_count                  init_aste_pools
                         000104 first_astep                 init_aste_pools
                         000106 last_astep                  init_aste_pools
                         000110 astnoff                     init_aste_pools
                         000111 template_aste               init_aste_pools
                         000525 template_ptw                init_aste_pools
                         000526 aste_threads                init_aste_pools
                         000530 astep                       init_aste_pools
                         000532 sstnp                       init_aste_pools
                         000534 sstp                        init_aste_pools

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ptw_util_$make_null

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
sst_names_$                   sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000001        53 000007        54 000011        56 000013        57 000016        59 000020        61 000032
     63 000043        64 000044        66 000047        67 000053        68 000057        70 000063        71 000065
     73 000073        75 000103        76 000107        77 000111        78 000113        80 000115        81 000122
     83 000126        84 000135        85 000143        86 000145        87 000152        88 000156        89 000161
     91 000163        92 000167        94 000172        95 000177        97 000201


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
