	COMPILATION LISTING OF SEGMENT ncp_io_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1319.9 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1976 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   * Copyright (c) 1972 by Massachusetts Institute of        *
        9*   * Technology and Honeywell Information Systems, Inc.      *
       10*   *                                                         *
       11*   *********************************************************** */
       12 
       13 
       14 ncp_io_:
       15           procedure ();
       16 
       17 /*             This procedure contains the read, status, and write entry        */
       18 /*        points.  They are isolated into this one module to reduce paging.     */
       19 
       20 /*        Originally created by D. M. Wells, 1975.03.24                         */
       21 
       22           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
       23 
       24      declare
       25          (P_sock_state fixed binary (6),
       26           P_num_bytes fixed binary (24),
       27           P_num_bytes_trans fixed binary (24),
       28           P_error_code fixed binary (35),                   /* a standard Multics status code                 */
       29           P_sock_indx bit (36),
       30           P_foreign_socket bit (64),
       31           P_buff_ptr pointer)
       32                parameter;
       33 
       34           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
       35 
       36      declare
       37          (bytesize fixed binary (8),
       38           num_msgs fixed binary (17),
       39           num_xfrd fixed binary (24),
       40           status bit (18),
       41           start_ptr pointer,
       42           procp pointer,
       43           sock_ptr pointer)
       44                automatic;
       45 
       46      declare
       47           1 global_data aligned like gdt;
       48 
       49           /* * * * * BASED & TEMPLATE DECLARATIONS * * * * */
       50 
       51      declare
       52           based_bit_array (0 : 9437183) bit (1)
       53                based;
       54 
       55           /* * * * * EXTERNAL STATIC DECLARATIONS  * * * * */
       56 
       57      declare
       58          (ncp_params_$min_bit_allocation fixed binary (32),
       59           ncp_params_$min_msg_allocation fixed binary (16))
       60                external static;
       61 
       62      declare
       63          (error_table_$area_too_small,
       64           error_table_$net_bad_gender,
       65           error_table_$net_invalid_state,
       66           error_table_$net_socket_closed)
       67                fixed binary (35) external static;
       68 
       69           /* * * * * ENTRY & PROCEDURE DECLARATIONS  * * * */
       70 
       71      declare
       72           condition_ constant entry (char (*), entry),
       73           imp_read$imp_read_with_message_count constant entry (fixed bin (17), ptr,
       74                     fixed bin (24), fixed bin (24), fixed bin (17), fixed bin (35)),
       75           imp_read_order constant entry (fixed bin (17), fixed bin (17), ptr, bit (18), fixed bin (35)),
       76           imp_write constant entry (fixed bin (17), ptr, fixed bin (24), fixed bin (24), fixed bin (35)),
       77           ncp_access_$change_socket_state constant entry (ptr, fixed bin (6), fixed bin (35)),
       78           ncp_access_$unassign_link constant entry (ptr, fixed bin (35)),
       79           ncp_access_$signal_process constant entry (ptr, fixed bin (1), fixed bin (35)),
       80           ncp_connection_$allocate_read constant entry (ptr, fixed bin (35)),
       81           ncp_error_$any_other_handler constant entry options (variable),
       82           ncp_lock_$lock_unlock constant entry (ptr, fixed bin (35)),
       83           ncp_tbop_$process_call constant entry (ptr),
       84           ncp_util_$enter_user_NCP_environment constant entry (ptr, ptr, fixed bin (35)),
       85           ncp_util_$exit_NCP_environment constant entry (ptr, ptr, fixed bin (35)),
       86           ncp_util_$find_socket_from_index constant entry (bit (36), bit (1), ptr, fixed bin (35));
       87 
       88      declare
       89           (addr, binary, null, string, substr)
       90                builtin;
       91 
       92           /* * * * * STACK REFERENCES  * * * * * * * * * * */
       93 
       94      declare
       95           cleanup condition;
       96 
       97           /* * * * * INCLUDE FILES * * * * * * * * * * * * */
       98 
       99           
  1     2 /*        BEGIN include file "ncp_connection_dcls.incl.pl1" --                  */
  1     3 
  1     4 /*             This include file contains declarations for the structures       */
  1     5 /*        maintained by the NCP which contain information about Host-Host       */
  1     6 /*        connections.  Currently, this is the information about sockets,       */
  1     7 /*        hosts, and requests-for-connection.                                   */
  1     8 
  1     9 /*        Originally created by D. M. Wells, Summer, 1975.                      */
  1    10 /*	Modified by B. Greenberg, Spring '78 for new leader support */
  1    11 /*	        Modified by C. Hornig, July 1979 for new host number format */
  1    12 
  1    13      declare
  1    14           1 socket aligned based,                           /* information we keep on a per-socket basis      */
  1    15              2 event_channel fixed binary (71),             /* event channel of using process                 */
  1    16              2 overseer_event_channel fixed binary (71),    /* event chanel of overseer process               */
  1    17              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    18              2 process_id bit (36) aligned,                 /* process id of using process                    */
  1    19              2 overseer_process_id bit (36) aligned,        /* process id of overseer process                 */
  1    20              2 bit_allocation fixed binary (32),            /* bit allocation outstanding on attached link    */
  1    21              2 msg_allocation fixed binary (16),            /* message allocation outstanding on link         */
  1    22 
  1    23              2 local_socket unaligned like socket.foreign_socket,     /* identification of local socket       */
  1    24              2 foreign_socket unaligned,                    /* identification of foreign socket               */
  1    25 	      3 host,				/* id of this host				*/
  1    26 	        4 net bit (8),			/* network id				*/
  1    27 	        4 host bit (8),			/* port on imp				*/
  1    28 	        4 imp bit (16),			/* imp id					*/
  1    29                 3 socket_num bit (32),                      /* actual socket number                           */
  1    30                 3 pad bit (8),
  1    31 
  1    32              2 rfc_queue fixed binary (17) unaligned,       /* RFC table index of next block for this         */
  1    33                                                             /* socket, 0 if queue is empty                    */
  1    34              2 link_number fixed binary (17) unaligned,     /* number of link assigned for connection         */
  1    35 
  1    36              2 host_entry_index fixed binary (17) unaligned,          /* index in host table of foreign       */
  1    37                                                                       /* host involved in connection          */
  1    38              2 impdim_index fixed binary (17) unaligned,    /* index by which IMPDIM knows about connection   */
  1    39              2 state bit (6) unaligned,                     /* finite-state-machine information               */
  1    40              2 byte_size bit (8) unaligned,                 /* byte-size of connections                       */
  1    41              2 send_gender bit (1) unaligned,               /* on iff this is a transmit socket               */
  1    42              2 allow_interrupts bit (1) unaligned,          /* on iff INS and INR should be signalled to user */
  1    43              2 deactivate bit (1) unaligned,                /* on iff this socket should be deactivated when  */
  1    44                                                             /* matching network messages are finally received */
  1    45              2 allow_rfc_queuing bit (1) unaligned,         /* on iff we should allow multiple outstanding    */
  1    46                                                             /* RFC's for this socket                          */
  1    47              2 extra_bits bit (12) unaligned,
  1    48 
  1    49              2 overseer_validation_level bit (3) unaligned,           /* ring of highest overseer control     */
  1    50              2 validation_level bit (3) unaligned,                    /* ring of highest operator control     */
  1    51 
  1    52              2 overseer_lock_id bit (36) aligned,           /* lock id of the overseer process                */
  1    53              2 umodes bit (36) aligned,                     /* 36 bits that the users can play with           */
  1    54              2 time_state_changed fixed binary (71),        /* time that the socket state last changed        */
  1    55              2 signal_event_channel fixed binary (71),      /* chanel to signal over when get INS or INR      */
  1    56              2 socket_index bit (36) aligned,               /* the handle we gave user for future reference   */
  1    57              2 history aligned,                             /* state of socket over recent past history       */
  1    58                 3 num_state_changes fixed binary (11) unaligned,      /* small field, so only keep mod        */
  1    59                 3 prev_state (0 : 3) fixed binary (5) unaligned;      /* past N states, kept in rotation      */
  1    60 
  1    61      declare
  1    62           1 host aligned based,                             /* information we retain about a foreign host     */
  1    63              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    64              2 rcv_link_index fixed binary (17) unaligned,  /* impdim index of read link for control msgs     */
  1    65              2 xmit_link_index fixed binary (17) unaligned, /* impdim index of write link for control msgs    */
  1    66              2 read_links_assigned bit (32) unaligned,      /* a bit is on iff we have assigned that link     */
  1    67              2 read_link_padd bit (4) unaligned,
  1    68 	   2 xhost_number_pad bit (9) unaligned,
  1    69              2 host_state bit (6) unaligned,                /* stae of communications with this host          */
  1    70              2 previous_host_state bit (6) unaligned,       /* last state of this host                        */
  1    71              2 state_pad bit (15) unaligned,
  1    72              2 time_state_changed fixed binary (71),        /* time when host state last changed              */
  1    73              2 read_links_used bit (32) unaligned,          /* bit is on if link has been used "recently"     */
  1    74              2 read_link_used_pad bit (4) unaligned,
  1    75              2 num_connections fixed binary (17) unaligned, /* times we attached links for this host          */
  1    76              2 hash_index fixed binary (17) unaligned,      /* table index of this host entry                 */
  1    77 	   2 host_number fixed bin (32) aligned,	/* host number of this host			*/
  1    78 	   2 host_number_pad fixed bin (35);
  1    79 
  1    80      declare
  1    81           1 rcvd_rfc aligned based,                         /* info about a rcvd Request for Connection       */
  1    82              2 foreign_socket unaligned like socket.foreign_socket,   /* foreign socket in RFC msg            */
  1    83              2 foreign_hosts_choice fixed binary (17) unaligned,      /* link or size that other host chose   */
  1    84              2 next_entry fixed binary (17) unaligned,                /* next RFC entry in queue for socket   */
  1    85              2 padding (1) fixed binary (35);
  1    86 
  1    87      declare
  1    88 	1 host_address based aligned,			/* Form of a host address			*/
  1    89 	   2 net bit (8) unaligned,			/* Netwwork ID				*/
  1    90 	   2 host bit (8) unaligned,			/* Host Port				*/
  1    91 	   2 imp bit (16) unaligned;			/* IMP ID					*/
  1    92 				/* Duplicated because of PL/I multi-like restriction */
  1    93 
  1    94 /*        END of include file ncp_connection_dcls.incl.pl1                      */
  1    95 
       99 
      100           
  2     2 /*             "ncp_constants_dcls.incl.pl1" -- include file to       */
  2     3 /*        declare some constants used throughout the Multics Network  */
  2     4 /*        Control Program (NCP).                                      */
  2     5 
  2     6 /*        Originally created by D. M. Wells, 1975, May 19.            */
  2     7 
  2     8      declare
  2     9          (NCP_DOWN            initial (0),                  /* the NCP has been shutdown normally             */
  2    10           NCP_UP_IMP_DOWN     initial (1),                  /* the NCP is up, but the IMP is unreachable      */
  2    11           NCP_UP              initial (2),                  /* the NCP is up and running normally             */
  2    12           NCP_CRASHED         initial (-1))                 /* the NCP has crashed itself                     */
  2    13                fixed binary (3) internal static options (constant);
  2    14 
  2    15      declare
  2    16          (READ_GENDER         initial ("0"b),               /* Read sockets are even numbers                  */
  2    17           WRITE_GENDER        initial ("1"b))               /* Write sockets ar odd numbers                   */
  2    18                bit (1) internal static options (constant);
  2    19 
  2    20      declare
  2    21          (HOST_OFF            initial (0),                  /* this host is not enabled for communications    */
  2    22           HOST_UP             initial (1),                  /* Host is up and everything ok                   */
  2    23           HOST_RST            initial (2),                  /* a Host-Host RST command has been sent          */
  2    24           HOST_DOWN           initial (3),                  /* Foreign host is down                           */
  2    25           HOST_ON             initial (4))                  /* Foreign host is enabled, but not RST yet       */
  2    26                fixed binary (6) internal static options (constant);
  2    27 
  2    28      declare
  2    29          (SOCK_UNASSIGNED     initial (0),                  /* This socket entry is not in use currently      */
  2    30           SOCK_ASSIGNED       initial (1),                  /* Socket has been assigned and is quiescent      */
  2    31           SOCK_LISTENING      initial (2),                  /* Socket is listening for incoming-RFCs          */
  2    32           SOCK_RFC_RCVD       initial (3),                  /* Socket has received RFC from foreign socket    */
  2    33           SOCK_RFC_ABORTED    initial (4),                  /* CLS  received for unacknowledged RFC           */
  2    34           SOCK_RFC_SENT       initial (5),                  /* RFC sent to foreign socket, but no reply       */
  2    35           SOCK_CONNECTED      initial (6),                  /* Socket is connected to foreign socket          */
  2    36           SOCK_CLS_WAIT       initial (7),                  /* CLS issued, waiting for reply CLS              */
  2    37                                                             /* State 8 is not currently defined               */
  2    38           SOCK_DATA_WAIT      initial (9),                  /* User requested close, but data still here      */
  2    39           SOCK_RFNM_WAIT      initial (10),                 /* User requested close, but waiting on last RFNM */
  2    40           SOCK_CLS_READ       initial (11),                 /* CLS received, but data still in buffers        */
  2    41                                                             /* State 12 is not currently defined              */
  2    42           SOCK_BROKEN         initial (13),                 /* Socket has been involved in some NCP anomaly   */
  2    43           SOCK_RESET          initial (14))                 /* Socket was connected to host that was reset    */
  2    44                fixed binary (6) internal static options (constant);
  2    45 
  2    46      declare
  2    47          (SOCK_INDX_MASK      initial ("000000777777"b3),   /* mask to get out actual array index             */
  2    48           SOCK_UNIQUE_MASK    initial ("377777000000"b3))   /* mask to get out incrementing part of indx      */
  2    49                bit (36) internal static options (constant);
  2    50 
  2    51      declare
  2    52          (ANY_TRACING         initial ("400000000000"b3),             /* if any tracing is occurring          */
  2    53           PRINTER_TRACING     initial ("200000000000"b3),             /* if tracing to the ptr is happening   */
  2    54           SYSERR_LOG_TRACING  initial ("100000000000"b3),             /* if tracing to syserr log mechanism   */
  2    55 
  2    56           TRACE_CTL_MSGS      initial ("004000000000"b3),             /* if host-host ctl msgs should be trcd */
  2    57           TRACE_PROCESS_INFO  initial ("002000000000"b3),             /* if process control should be trcd    */
  2    58           TRACE_DATA_FLOW     initial ("001000000000"b3),             /* if flow of user data to be traced    */
  2    59 
  2    60           TRACE_NCP_RING      initial ("000400000000"b3),             /* if ncp_ring_ should be traced        */
  2    61           TRACE_NCP_ACCESS    initial ("000200000000"b3),             /* if ncp_access_ should be traced      */
  2    62           TRACE_NCP_DAEMON    initial ("000100000000"b3),             /* if ncp_daemon_ should be traced      */
  2    63           TRACE_NCP_CONTROL   initial ("000040000000"b3),             /* if ncp_control_ should be traced     */
  2    64           TRACE_NCP_TBOP      initial ("000020000000"b3),             /* if ncp_tbop_ should be traced        */
  2    65           TRACE_NCP_IO        initial ("000010000000"b3))             /* if ncp_io_ should be traced          */
  2    66                bit (36) aligned internal static options (constant);
  2    67 
  2    68 /*        end of include file "ncp_constants_dcls.incl.pl1            */
  2    69 
      100 
      101           
  3     2 /*        BEGIN include file ncp_process_dcls.incl.pl1 --                       */
  3     3 
  3     4 /*             This include file contains declarations of per-process data.     */
  3     5 
  3     6 /*        Originally created by D. M. Wells, Jan, 1976 from a previously        */
  3     7 /*                  existing include file.                                      */
  3     8 
  3     9      declare
  3    10           1 gdt aligned based,                              /* this holds data to/from outside world          */
  3    11              2 init_sw fixed binary (30),                   /* set to 620998 iff initialized properly.        */
  3    12                                                             /* This particular value has  no significance     */
  3    13              2 error_code fixed binary (35),                /* a code returned by internal modules            */
  3    14              2 request_code fixed binary (12),              /* type of request to be performed (input)        */
  3    15              2 ncp_idx bit (36) unaligned,                  /* handle of socket to be manipulated (input)     */
  3    16              2 state fixed binary (6),                      /* state of the socket (output)                   */
  3    17              2 privilege_code fixed binary (2),             /* = 0 unpriv, = 1 priv, = 2 daemon               */
  3    18              2 nbytes fixed binary (24),                    /* number of bytes of data presented (input)      */
  3    19              2 nelemt fixed binary (24),                    /* number of bytes transmitted (output)           */
  3    20 
  3    21              2 areap pointer,                               /* pointer to a supplied area (input)             */
  3    22              2 fsoc bit (64) unaligned,                     /* foreign socket associated with this request    */
  3    23              2 fsoc_pad bit (8) unaligned,
  3    24              2 abort_location label,                        /* label to goto on procedure abort               */
  3    25 
  3    26              2 host_tbl_index fixed binary (17),            /* host_tbl index of foreign host                 */
  3    27              2 proc_id_arg bit (36),                        /* process id argument                            */
  3    28              2 entry_time fixed binary (71),                /* time NCP was entered by this call              */
  3    29              2 entry_type fixed binary (17),                /* 1, 2 daemon; 3 userid; 4 process_rq;           */
  3    30                                                             /* 5 global_chnchn; 6 socket_state; 7 micro       */
  3    31              2 nprocs_sw fixed binary (30),                 /* = 459248 if nprocs cell was properly set       */
  3    32              2 event_chn fixed binary (71),                 /* event_channel argument                         */
  3    33 
  3    34              2 proc_tbp pointer,                            /* pointer to this process's static info block    */
  3    35              2 global_queue aligned,                        /* impdim global queue info struct                */
  3    36                 3 gq_type fixed binary (17),                /* imp_global_state substructure begins here      */
  3    37                 3 gq_imp_state character (8) unaligned,     /* state of our IMP (up, down?)                   */
  3    38                 3 gq_message bit (32) aligned,              /* special message sent by IMP                    */
  3    39 
  3    40                 3 gq_imp_index fixed binary (17),           /* imp_dim index of this link                     */
  3    41                 3 gq_host_id fixed binary (32),             /* host identifier of a foreign host              */
  3    42                 3 gq_link fixed binary (8),                 /* link number of this link                       */
  3    43                 3 gq_status aligned,                        /* of this link returned by imp_global_state      */
  3    44                    4 sba (0 : 17) bit (1) unaligned,        /* status bits from imp dim                       */
  3    45 
  3    46              2 spaceg2 (14) fixed binary (17);
  3    47 
  3    48      declare
  3    49           1 pdt aligned based,                              /* information about each process using NCP       */
  3    50              2 gdtp pointer,                                /* points to this call's global_data base         */
  3    51              2 returnp label,                               /* return label for non-local error goto          */
  3    52 
  3    53              2 multuid character (32) unaligned,            /* process group id                               */
  3    54 
  3    55              2 netuid bit (24),                             /* Network id of this process                     */
  3    56              2 lockid bit (36),                             /* lock id of process,  = ""b iff unassigned      */
  3    57              2 processid bit (36),                          /* process id of this process                     */
  3    58              2 error_recur fixed binary (17),               /* number of ncp error recursions                 */
  3    59              2 global_ev_chn fixed binary (71),             /* this process gets changes of NCP state         */
  3    60              2 num_activations fixed binary (17),
  3    61              2 proc_devx fixed binary (12),
  3    62              2 spacep2 (2) fixed binary (17);
  3    63 
  3    64      declare
  3    65           1 error_snapshot aligned based,                   /* snapshot of process info for an NCP error      */
  3    66              2 ewho character (32) unaligned,               /* process group id of detecting process          */
  3    67              2 econdition character (32) unaligned,         /* condition signalled                            */
  3    68 
  3    69              2 etime fixed binary (71),                     /* time of error                                  */
  3    70              2 error_number fixed binary (17),
  3    71              2 spacee1 (5) fixed binary (17),
  3    72 
  3    73              2 mc_cond (32) bit (36) aligned,               /* machine conditions                             */
  3    74              2 if_data (8) fixed binary (17),               /* space for software supplied data               */
  3    75              2 proc_slot aligned like pdt,                  /* copy of proc_tbl entry for this process        */
  3    76              2 gdt_data aligned like gdt,                   /* copy of ncp_global_data at time of error       */
  3    77              2 associated_data (24) bit (36) aligned;       /* add'l info -- usually copy of socket entry     */
  3    78 
  3    79 /*        END include file ncp_process_dcls.incl.pl1 --                         */
  3    80 
      101 
      102 
      103 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      104 
      105 return_error:
      106           call complete_metering ();
      107 
      108           return;
      109 
      110           /* * * * * * * * * * * * * * * * * * * * * * * * */
      111 
      112                                                   /*      This entry is called to read data from the network  */
      113                                                   /* into a user-supplied buffer.                             */
      114 
      115 ncp_read:
      116           entry (P_sock_indx, P_buff_ptr, P_num_bytes, P_num_bytes_trans, P_sock_state, P_error_code);
      117 
      118           P_error_code = 0;
      119           P_sock_state = 0;
      120           P_num_bytes_trans = 0;
      121 
      122           global_data.ncp_idx = P_sock_indx;
      123           global_data.areap = P_buff_ptr;
      124           global_data.nbytes = P_num_bytes;
      125 
      126           global_data.request_code = 13;
      127 
      128           call make_global_data_valid ();
      129 
      130           sock_ptr = null ();
      131           call condition_ ("any_other", ncp_error_$any_other_handler);
      132 
      133           sock_ptr = find_and_lock_socket (global_data.ncp_idx);
      134 
      135           if sock_ptr -> socket.send_gender ^= READ_GENDER
      136           then do;
      137                call unlock_socket ();
      138 
      139                P_error_code = error_table_$net_bad_gender;
      140                goto return_error;
      141                end;
      142 
      143           if (global_data.state ^= SOCK_CONNECTED) & (global_data.state ^= SOCK_CLS_READ)
      144           then do;
      145                call unlock_socket ();
      146 
      147                P_sock_state = global_data.state;
      148                P_error_code = error_table_$net_invalid_state;
      149                goto return_error;
      150                end;
      151 
      152           global_data.nelemt = 0;
      153           bytesize = binary (sock_ptr -> socket.byte_size, 8);
      154 
      155           num_xfrd = -1;                                    /* cause loop to happen at least once             */
      156           do start_ptr = global_data.areap
      157                     repeat (addr (global_data.areap -> based_bit_array (global_data.nelemt * bytesize)))
      158                     while (num_xfrd ^= 0);
      159                call imp_read$imp_read_with_message_count ((sock_ptr -> socket.impdim_index), start_ptr,
      160                          global_data.nbytes - global_data.nelemt, num_xfrd, num_msgs, global_data.error_code);
      161                global_data.nelemt = global_data.nelemt + num_xfrd;
      162 
      163                sock_ptr -> socket.msg_allocation = sock_ptr -> socket.msg_allocation - num_msgs;
      164                sock_ptr -> socket.bit_allocation = sock_ptr -> socket.bit_allocation - num_xfrd * bytesize;
      165                end;
      166 
      167           if global_data.nelemt ^= 0
      168           then if global_data.error_code ^= 0
      169                then if global_data.error_code = error_table_$area_too_small
      170                     then global_data.error_code = 0;
      171 
      172           if global_data.error_code ^= 0
      173           then do;
      174                call unlock_socket ();
      175 
      176                P_num_bytes_trans = global_data.nelemt;
      177                P_sock_state = global_data.state;
      178                P_error_code = global_data.error_code;
      179                goto return_error;
      180                end;
      181 
      182           if (global_data.state = SOCK_CONNECTED)
      183           then do;
      184                if (sock_ptr -> socket.msg_allocation < ncp_params_$min_msg_allocation)
      185                          | (sock_ptr -> socket.bit_allocation < ncp_params_$min_bit_allocation)
      186                then call ncp_connection_$allocate_read (sock_ptr, global_data.error_code);
      187                end;
      188           else do;                                          /* state is 11                          */
      189                if global_data.nelemt = 0
      190                then do;
      191                     call imp_read_order ((sock_ptr -> socket.impdim_index), 4, null (), status, (0));
      192                     if ^ substr (status, 12, 1) then if ^ substr (status, 17, 1)
      193                     then do;
      194                          call ncp_access_$unassign_link (sock_ptr, (0));
      195                          call ncp_access_$change_socket_state (sock_ptr, SOCK_ASSIGNED, (0));
      196                          global_data.state = binary (sock_ptr -> socket.state, 6);
      197 
      198                          call ncp_access_$signal_process (sock_ptr, 1, (0));
      199                          end;
      200                     end;
      201                end;
      202 
      203           call unlock_socket ();
      204 
      205           call complete_metering ();
      206 
      207           P_sock_state = global_data.state;
      208           P_num_bytes_trans = global_data.nelemt;
      209 
      210           P_error_code = global_data.error_code;
      211 
      212           return;
      213 
      214           /* * * * * * * * * * * * * * * * * * * * * * * * */
      215 
      216                                                   /*      This entry will return the state of the socket and  */
      217                                                   /* also the foreign socket (if any) to which it is (or was  */
      218                                                   /* last) connected.                                         */
      219 
      220 ncp_state:
      221           entry (P_sock_indx, P_foreign_socket, P_sock_state, P_error_code);
      222 
      223           P_error_code = 0;
      224           P_sock_state = 0;
      225           P_foreign_socket = ""b;
      226 
      227           global_data.ncp_idx = P_sock_indx;
      228 
      229           global_data.request_code = 14;
      230           global_data.entry_type = 7;
      231           global_data.privilege_code = 0;
      232 
      233           call make_global_data_valid ();
      234 
      235           sock_ptr = null ();
      236           call condition_ ("any_other", ncp_error_$any_other_handler);
      237 
      238           sock_ptr = find_and_lock_socket (global_data.ncp_idx);
      239 
      240           global_data.fsoc = string (sock_ptr -> socket.foreign_socket);
      241           call unlock_socket ();
      242           if (global_data.state = SOCK_RFC_RCVD) | (global_data.state = SOCK_RFC_ABORTED)
      243           then call ncp_tbop_$process_call (procp);
      244 
      245           call complete_metering ();
      246 
      247           P_sock_state = global_data.state;
      248           P_foreign_socket = global_data.fsoc;
      249 
      250           P_error_code = global_data.error_code;
      251 
      252           return;
      253 
      254           /* * * * * * * * * * * * * * * * * * * * * * * * */
      255 
      256                                                   /*      This entry will attempt to write data from          */
      257                                                   /* the user supplied buffer to the network.                 */
      258 
      259 ncp_write:
      260           entry (P_sock_indx, P_buff_ptr, P_num_bytes, P_num_bytes_trans, P_sock_state, P_error_code);
      261 
      262           P_error_code = 0;
      263           P_sock_state = 0;
      264           P_num_bytes_trans = 0;
      265 
      266 
      267           global_data.request_code = 15;
      268 
      269           global_data.ncp_idx = P_sock_indx;
      270           global_data.areap = P_buff_ptr;
      271           global_data.nbytes = P_num_bytes;
      272 
      273           call make_global_data_valid ();
      274 
      275           sock_ptr = null ();
      276           call condition_ ("any_other", ncp_error_$any_other_handler);
      277 
      278           sock_ptr = find_and_lock_socket (global_data.ncp_idx);
      279 
      280           if sock_ptr -> socket.send_gender ^= WRITE_GENDER
      281           then do;
      282                call unlock_socket ();
      283                P_error_code = error_table_$net_bad_gender;
      284                goto return_error;
      285                end;
      286 
      287           if global_data.state ^= SOCK_CONNECTED
      288           then do;
      289                call unlock_socket ();
      290 
      291                P_sock_state = global_data.state;
      292                P_error_code = error_table_$net_invalid_state;
      293                goto return_error;
      294                end;
      295 
      296           call imp_write ((sock_ptr -> socket.impdim_index), global_data.areap, global_data.nbytes, global_data.nelemt, global_data.error_code);
      297 
      298           call unlock_socket ();
      299 
      300           call complete_metering ();
      301 
      302           P_num_bytes_trans = global_data.nelemt;
      303           P_sock_state = global_data.state;
      304           P_error_code = global_data.error_code;
      305 
      306           return;
      307 
      308 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      309 
      310 find_and_lock_socket:
      311           procedure (p_socket_indx) returns (ptr);
      312 
      313           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
      314 
      315      declare
      316           p_socket_indx bit (36)
      317                parameter;
      318 
      319           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
      320 
      321      declare
      322           entry_ptr pointer
      323                automatic;
      324 
      325           /* * * * * * * * * * * * * * * * * * * * * * * * */
      326 
      327           call ncp_util_$find_socket_from_index (p_socket_indx, "0"b, entry_ptr, global_data.error_code);
      328           if global_data.error_code ^= 0
      329           then do;
      330                P_error_code = global_data.error_code;
      331                goto return_error;
      332                end;
      333 
      334           global_data.state = binary (entry_ptr -> socket.state, 6);  /* set global version here              */
      335 
      336           return (entry_ptr);
      337 
      338 end;      /* end find_and_lock_socket                      */
      339 
      340 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      341 
      342 unlock_socket:
      343           procedure ();
      344 
      345           /* * * * * * * * * * * * * * * * * * * * * * * * */
      346 
      347           call ncp_lock_$lock_unlock (addr (sock_ptr -> socket.lock), (0));
      348 
      349           return;
      350 
      351 end;      /* end unlock_socket                             */
      352 
      353 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      354 
      355 complete_metering:
      356           procedure ();
      357 
      358           /* * * * * * * * * * * * * * * * * * * * * * * * */
      359 
      360           call ncp_util_$exit_NCP_environment (procp, addr (global_data), (0));
      361 
      362           return;
      363 
      364 end;      /* end complete_metering                         */
      365 
      366 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      367 
      368 make_global_data_valid:
      369           procedure ();
      370 
      371           /* * * * * * * * * * * * * * * * * * * * * * * * */
      372 
      373           global_data.proc_tbp = null;            /* null out */
      374           global_data.error_code = 0;                       /* init to "no error" */
      375           global_data.init_sw, global_data.nprocs_sw = 0;   /* set to "uninited" */
      376           global_data.abort_location = return_error;
      377 
      378           global_data.host_tbl_index = 0;
      379 
      380           call ncp_util_$enter_user_NCP_environment (procp, addr (global_data), global_data.error_code);
      381           if global_data.error_code ^= 0
      382           then do;
      383                P_error_code = global_data.error_code;
      384                goto return_error;
      385                end;
      386 
      387           return;
      388 
      389 end;      /* end make_global_data_valid                    */
      390 
      391 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      392 
      393           /* end ncp_io_                                   */
      394 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1129.4  ncp_io_.pl1                       >dumps>old_dumps>hardcore>ncp_io_.pl1
99           1    09/05/79  2206.3  ncp_connection_dcls.incl.pl1      >ldd>include>ncp_connection_dcls.incl.pl1
100          2    10/07/77  1700.0  ncp_constants_dcls.incl.pl1       >ldd>include>ncp_constants_dcls.incl.pl1
101          3    07/24/78  1704.7  ncp_process_dcls.incl.pl1         >ldd>include>ncp_process_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_buff_ptr                             parameter       pointer                  dcl 24 ref 115 123 259 270
P_error_code                           parameter       fixed bin(35,0)          dcl 24 set ref 115 118* 139* 148* 178* 210* 220 223*
                                                                                  250* 259 262* 283* 292* 304* 330* 383*
P_foreign_socket                       parameter       bit(64)                  unaligned dcl 24 set ref 220 225* 248*
P_num_bytes                            parameter       fixed bin(24,0)          dcl 24 ref 115 124 259 271
P_num_bytes_trans                      parameter       fixed bin(24,0)          dcl 24 set ref 115 120* 176* 208* 259 264* 302*
P_sock_indx                            parameter       bit(36)                  unaligned dcl 24 ref 115 122 220 227 259 269
P_sock_state                           parameter       fixed bin(6,0)           dcl 24 set ref 115 119* 147* 177* 207* 220 224* 247*
                                                                                  259 263* 291* 303*
READ_GENDER                            constant        bit(1)                   initial unaligned dcl 2-15 ref 135
SOCK_ASSIGNED                   000004 constant        fixed bin(6,0)           initial dcl 2-28 set ref 195*
SOCK_CLS_READ                          constant        fixed bin(6,0)           initial dcl 2-28 ref 143
SOCK_CONNECTED                         constant        fixed bin(6,0)           initial dcl 2-28 ref 143 182 287
SOCK_RFC_ABORTED                       constant        fixed bin(6,0)           initial dcl 2-28 ref 242
SOCK_RFC_RCVD                          constant        fixed bin(6,0)           initial dcl 2-28 ref 242
WRITE_GENDER                           constant        bit(1)                   initial unaligned dcl 2-15 ref 280
abort_location           14     000112 automatic       label variable           level 2 dcl 46 set ref 376*
addr                                                   builtin function         dcl 88 ref 165 347 347 360 360 380 380
areap                    10     000112 automatic       pointer                  level 2 dcl 46 set ref 123* 156 165 270* 296*
based_bit_array                        based           bit(1)                   array unaligned dcl 51 set ref 165
binary                                                 builtin function         dcl 88 ref 153 196 334
bit_allocation            7            based           fixed bin(32,0)          level 2 dcl 1-13 set ref 164* 164 184
byte_size                17(06)        based           bit(8)                   level 2 packed unaligned dcl 1-13 ref 153
bytesize                        000100 automatic       fixed bin(8,0)           dcl 36 set ref 153* 164 165
condition_                      000022 constant        entry                    external dcl 71 ref 131 236 276
entry_ptr                       000204 automatic       pointer                  dcl 321 set ref 327* 334 336
entry_type               24     000112 automatic       fixed bin(17,0)          level 2 dcl 46 set ref 230*
error_code                1     000112 automatic       fixed bin(35,0)          level 2 dcl 46 set ref 159* 167 167 167* 172 178
                                                                                  184* 210 250 296* 304 327* 328 330 374* 380* 381
                                                                                  383
error_table_$area_too_small     000014 external static fixed bin(35,0)          dcl 62 ref 167
error_table_$net_bad_gender     000016 external static fixed bin(35,0)          dcl 62 ref 139 283
error_table_$net_invalid_state  000020 external static fixed bin(35,0)          dcl 62 ref 148 292
foreign_socket           13            based           structure                level 2 packed unaligned dcl 1-13 ref 240
fsoc                     12     000112 automatic       bit(64)                  level 2 packed unaligned dcl 46 set ref 240* 248
gdt                                    based           structure                level 1 dcl 3-9
global_data                     000112 automatic       structure                level 1 dcl 46 set ref 360 360 380 380
host_tbl_index           20     000112 automatic       fixed bin(17,0)          level 2 dcl 46 set ref 378*
imp_read$imp_read_with_message_count
                                000024 constant        entry                    external dcl 71 ref 159
imp_read_order                  000026 constant        entry                    external dcl 71 ref 191
imp_write                       000030 constant        entry                    external dcl 71 ref 296
impdim_index             16(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-13 ref 159 191 296
init_sw                         000112 automatic       fixed bin(30,0)          level 2 dcl 46 set ref 375*
lock                      4            based           bit(36)                  level 2 dcl 1-13 set ref 347 347
msg_allocation           10            based           fixed bin(16,0)          level 2 dcl 1-13 set ref 163* 163 184
nbytes                    6     000112 automatic       fixed bin(24,0)          level 2 dcl 46 set ref 124* 159 271* 296*
ncp_access_$change_socket_state 000032 constant        entry                    external dcl 71 ref 195
ncp_access_$signal_process      000036 constant        entry                    external dcl 71 ref 198
ncp_access_$unassign_link       000034 constant        entry                    external dcl 71 ref 194
ncp_connection_$allocate_read   000040 constant        entry                    external dcl 71 ref 184
ncp_error_$any_other_handler    000042 constant        entry                    external dcl 71 ref 131 131 236 236 276 276
ncp_idx                   3     000112 automatic       bit(36)                  level 2 packed unaligned dcl 46 set ref 122* 133*
                                                                                  227* 238* 269* 278*
ncp_lock_$lock_unlock           000044 constant        entry                    external dcl 71 ref 347
ncp_params_$min_bit_allocation  000010 external static fixed bin(32,0)          dcl 57 ref 184
ncp_params_$min_msg_allocation  000012 external static fixed bin(16,0)          dcl 57 ref 184
ncp_tbop_$process_call          000046 constant        entry                    external dcl 71 ref 242
ncp_util_$enter_user_NCP_environment
                                000050 constant        entry                    external dcl 71 ref 380
ncp_util_$exit_NCP_environment  000052 constant        entry                    external dcl 71 ref 360
ncp_util_$find_socket_from_index
                                000054 constant        entry                    external dcl 71 ref 327
nelemt                    7     000112 automatic       fixed bin(24,0)          level 2 dcl 46 set ref 152* 159 161* 161 165 167 176
                                                                                  189 208 296* 302
nprocs_sw                25     000112 automatic       fixed bin(30,0)          level 2 dcl 46 set ref 375*
null                                                   builtin function         dcl 88 ref 130 191 191 235 275 373
num_msgs                        000101 automatic       fixed bin(17,0)          dcl 36 set ref 159* 163
num_xfrd                        000102 automatic       fixed bin(24,0)          dcl 36 set ref 155* 156 159* 161 164
p_socket_indx                          parameter       bit(36)                  unaligned dcl 315 set ref 310 327*
pdt                                    based           structure                level 1 dcl 3-48
privilege_code            5     000112 automatic       fixed bin(2,0)           level 2 dcl 46 set ref 231*
proc_tbp                 30     000112 automatic       pointer                  level 2 dcl 46 set ref 373*
procp                           000106 automatic       pointer                  dcl 36 set ref 242* 360* 380*
request_code              2     000112 automatic       fixed bin(12,0)          level 2 dcl 46 set ref 126* 229* 267*
send_gender              17(14)        based           bit(1)                   level 2 packed unaligned dcl 1-13 ref 135 280
sock_ptr                        000110 automatic       pointer                  dcl 36 set ref 130* 133* 135 153 159 163 163 164 164
                                                                                  184 184 184* 191 194* 195* 196 198* 235* 238* 240
                                                                                  275* 278* 280 296 347 347
socket                                 based           structure                level 1 dcl 1-13
start_ptr                       000104 automatic       pointer                  dcl 36 set ref 156* 159*
state                     4     000112 automatic       fixed bin(6,0)           level 2 in structure "global_data" dcl 46
                                                                                  in procedure "ncp_io_" set ref 143 143 147 177 182
                                                                                  196* 207 242 242 247 287 291 303 334*
state                    17            based           bit(6)                   level 2 in structure "socket" packed unaligned
                                                                                  dcl 1-13 in procedure "ncp_io_" ref 196 334
status                          000103 automatic       bit(18)                  unaligned dcl 36 set ref 191* 192 192
string                                                 builtin function         dcl 88 ref 240
substr                                                 builtin function         dcl 88 ref 192 192

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_TRACING                            internal static bit(36)                  initial dcl 2-51
HOST_DOWN                              internal static fixed bin(6,0)           initial dcl 2-20
HOST_OFF                               internal static fixed bin(6,0)           initial dcl 2-20
HOST_ON                                internal static fixed bin(6,0)           initial dcl 2-20
HOST_RST                               internal static fixed bin(6,0)           initial dcl 2-20
HOST_UP                                internal static fixed bin(6,0)           initial dcl 2-20
NCP_CRASHED                            internal static fixed bin(3,0)           initial dcl 2-8
NCP_DOWN                               internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP                                 internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP_IMP_DOWN                        internal static fixed bin(3,0)           initial dcl 2-8
PRINTER_TRACING                        internal static bit(36)                  initial dcl 2-51
SOCK_BROKEN                            internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CLS_WAIT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_DATA_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_INDX_MASK                         internal static bit(36)                  initial unaligned dcl 2-46
SOCK_LISTENING                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RESET                             internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_SENT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFNM_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_UNASSIGNED                        internal static fixed bin(6,0)           initial dcl 2-28
SOCK_UNIQUE_MASK                       internal static bit(36)                  initial unaligned dcl 2-46
SYSERR_LOG_TRACING                     internal static bit(36)                  initial dcl 2-51
TRACE_CTL_MSGS                         internal static bit(36)                  initial dcl 2-51
TRACE_DATA_FLOW                        internal static bit(36)                  initial dcl 2-51
TRACE_NCP_ACCESS                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_CONTROL                      internal static bit(36)                  initial dcl 2-51
TRACE_NCP_DAEMON                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_IO                           internal static bit(36)                  initial dcl 2-51
TRACE_NCP_RING                         internal static bit(36)                  initial dcl 2-51
TRACE_NCP_TBOP                         internal static bit(36)                  initial dcl 2-51
TRACE_PROCESS_INFO                     internal static bit(36)                  initial dcl 2-51
cleanup                         000000 stack reference condition                dcl 94
error_snapshot                         based           structure                level 1 dcl 3-64
error_table_$net_socket_closed         external static fixed bin(35,0)          dcl 62
host                                   based           structure                level 1 dcl 1-61
host_address                           based           structure                level 1 dcl 1-87
rcvd_rfc                               based           structure                level 1 dcl 1-80

NAMES DECLARED BY EXPLICIT CONTEXT.
complete_metering               001001 constant        entry                    internal dcl 355 ref 105 205 245 300
find_and_lock_socket            000726 constant        entry                    internal dcl 310 ref 133 238 278
make_global_data_valid          001021 constant        entry                    internal dcl 368 ref 128 233 273
ncp_io_                         000024 constant        entry                    external dcl 14
ncp_read                        000041 constant        entry                    external dcl 115
ncp_state                       000434 constant        entry                    external dcl 220
ncp_write                       000561 constant        entry                    external dcl 259
return_error                    000031 constant        label                    dcl 105 ref 140 149 179 284 293 331 376 384
unlock_socket                   000762 constant        entry                    internal dcl 342 ref 137 145 174 203 241 282 289 298

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1412        1470    1066        1422
Length      1756    1066        56         251     323           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ncp_io_                             232 external procedure  is an external procedure.  
find_and_lock_socket                    internal procedure  shares stack frame of external procedure ncp_io_.  
unlock_socket                           internal procedure  shares stack frame of external procedure ncp_io_.  
complete_metering                       internal procedure  shares stack frame of external procedure ncp_io_.  
make_global_data_valid                  internal procedure  shares stack frame of external procedure ncp_io_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ncp_io_                  000100 bytesize                    ncp_io_
                         000101 num_msgs                    ncp_io_
                         000102 num_xfrd                    ncp_io_
                         000103 status                      ncp_io_
                         000104 start_ptr                   ncp_io_
                         000106 procp                       ncp_io_
                         000110 sock_ptr                    ncp_io_
                         000112 global_data                 ncp_io_
                         000204 entry_ptr                   find_and_lock_socket

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    imp_read$imp_read_with_message_count                        imp_read_order
imp_write                     ncp_access_$change_socket_state                             ncp_access_$signal_process
ncp_access_$unassign_link     ncp_connection_$allocate_read ncp_error_$any_other_handler  ncp_lock_$lock_unlock
ncp_tbop_$process_call        ncp_util_$enter_user_NCP_environment
ncp_util_$exit_NCP_environment                              ncp_util_$find_socket_from_index

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$net_bad_gender   error_table_$net_invalid_state
ncp_params_$min_bit_allocation                              ncp_params_$min_msg_allocation


CONSTANTS
001056  aa     000004000000
001057  aa     000000000000
001060  aa     600000000041
001061  aa     000115000000
001062  aa     600000000041
001063  aa     000110000000

001064  aa     077777000043
001065  aa     000001000000

000000  aa     500000000000

000001  aa     524000000011

000002  aa     464000000000

000003  aa     516000000100

000004  aa     000000000001

000005  aa     516000000044

000006  aa     404000000043

000007  aa     404000000030

000010  aa     404000000006

000012  aa     000000000000
000013  aa     000000000000

000014  aa     077777000043
000015  aa     000001000000

000016  aa  143 154 145 141	clea
000017  aa  156 165 160 000	nup

000020  aa  141 156 171 137	any_
000021  aa  157 164 150 145	othe
000022  aa  162 000 000 000	r

BEGIN PROCEDURE ncp_io_
ENTRY TO ncp_io_                                            STATEMENT 1 ON LINE 14
ncp_io_:
          procedure ();

000023  da     000275200000
000024  aa   000360 6270 00	eax7 	240
000025  aa  7 00034 3521 20	epp2 	pr7|28,*
000026  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000027  aa     000000000000
000030  aa     000000000000
						STATEMENT 1 ON LINE 105
return_error:
          call complete_metering ();

000031  aa   000750 6700 04	tsp4 	488,ic		001001
						STATEMENT 1 ON LINE 108
          return;

000032  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ncp_read                                           STATEMENT 1 ON LINE 115
ncp_read:
          entry (P_sock_indx, P_buff_ptr, P_num_bytes, P_num_bytes_trans, P_sock_state, P_error_code);

000033  at     000006000005
000034  tt     000002000007
000035  tt     000007000010
000036  ta     000006000000
000037  ta     000033000000
000040  da     000303300000
000041  aa   000360 6270 00	eax7 	240
000042  aa  7 00034 3521 20	epp2 	pr7|28,*
000043  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000044  aa     000014000000
000045  aa     000000000000
000046  aa  6 00032 3735 20	epp7 	pr6|26,*
000047  aa  7 00012 3715 20	epp5 	pr7|10,*
000050  aa  6 00172 6515 00	spri5	pr6|122
000051  aa  7 00014 3535 20	epp3 	pr7|12,*
000052  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 118
          P_error_code = 0;

000053  aa  6 00174 4501 20	stz  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 119
          P_sock_state = 0;

000054  aa  6 00172 4501 20	stz  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 120
          P_num_bytes_trans = 0;

000055  aa  6 00032 3735 20	epp7 	pr6|26,*
000056  aa  7 00010 4501 20	stz  	pr7|8,*		P_num_bytes_trans
						STATEMENT 1 ON LINE 122
          global_data.ncp_idx = P_sock_indx;

000057  aa  7 00002 3715 20	epp5 	pr7|2,*
000060  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000061  aa  5 00000 00 0044	descb	pr5|0,36		P_sock_indx
000062  aa  6 00115 00 0044	descb	pr6|77,36		global_data.ncp_idx
						STATEMENT 1 ON LINE 123
          global_data.areap = P_buff_ptr;

000063  aa  7 00004 3535 20	epp3 	pr7|4,*		P_buff_ptr
000064  aa  3 00000 3535 20	epp3 	pr3|0,*		P_buff_ptr
000065  aa  6 00122 2535 00	spri3	pr6|82		global_data.areap
						STATEMENT 1 ON LINE 124
          global_data.nbytes = P_num_bytes;

000066  aa  7 00006 2361 20	ldq  	pr7|6,*		P_num_bytes
000067  aa  6 00120 7561 00	stq  	pr6|80		global_data.nbytes
						STATEMENT 1 ON LINE 126
          global_data.request_code = 13;

000070  aa   000015 2360 07	ldq  	13,dl
000071  aa  6 00114 7561 00	stq  	pr6|76		global_data.request_code
						STATEMENT 1 ON LINE 128
          call make_global_data_valid ();

000072  aa   000727 6700 04	tsp4 	471,ic		001021
						STATEMENT 1 ON LINE 130
          sock_ptr = null ();

000073  aa   777721 2370 04	ldaq 	-47,ic		000014 = 077777000043 000001000000
000074  aa  6 00110 7571 00	staq 	pr6|72		sock_ptr
						STATEMENT 1 ON LINE 131
          call condition_ ("any_other", ncp_error_$any_other_handler);

000075  aa   777723 2370 04	ldaq 	-45,ic		000020 = 141156171137 157164150145
000076  aa  6 00230 7571 00	staq 	pr6|152
000077  aa   162000 2350 03	lda  	58368,du
000100  aa  6 00232 7551 00	sta  	pr6|154
000101  aa  6 00044 3701 20	epp4 	pr6|36,*
000102  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_$any_other_handler
000103  aa  6 00234 2521 00	spri2	pr6|156		cp.158
000104  aa   000760 2370 04	ldaq 	496,ic		001064 = 077777000043 000001000000
000105  aa  6 00236 7571 00	staq 	pr6|158		cp.158
000106  aa  6 00230 3521 00	epp2 	pr6|152
000107  aa  6 00242 2521 00	spri2	pr6|162
000110  aa  6 00234 3521 00	epp2 	pr6|156		cp.158
000111  aa  6 00244 2521 00	spri2	pr6|164
000112  aa   777667 3520 04	epp2 	-73,ic		000001 = 524000000011
000113  aa  6 00246 2521 00	spri2	pr6|166
000114  aa   777664 3520 04	epp2 	-76,ic		000000 = 500000000000
000115  aa  6 00250 2521 00	spri2	pr6|168
000116  aa  6 00240 6211 00	eax1 	pr6|160
000117  aa   010000 4310 07	fld  	4096,dl
000120  la  4 00022 3521 20	epp2 	pr4|18,*		condition_
000121  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 133
          sock_ptr = find_and_lock_socket (global_data.ncp_idx);

000122  aa   000734 3520 04	epp2 	476,ic		001056 = 000004000000
000123  aa   000603 6700 04	tsp4 	387,ic		000726
						STATEMENT 1 ON LINE 135
          if sock_ptr -> socket.send_gender ^= READ_GENDER
          then do;

000124  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000125  aa  7 00017 2351 00	lda  	pr7|15		socket.send_gender
000126  aa   000010 3150 03	cana 	8,du
000127  aa   000006 6000 04	tze  	6,ic		000135
						STATEMENT 1 ON LINE 137
               call unlock_socket ();

000130  aa   000632 6700 04	tsp4 	410,ic		000762
						STATEMENT 1 ON LINE 139
               P_error_code = error_table_$net_bad_gender;

000131  aa  6 00044 3701 20	epp4 	pr6|36,*
000132  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$net_bad_gender
000133  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 140
               goto return_error;

000134  aa   777675 7100 04	tra  	-67,ic		000031
						STATEMENT 1 ON LINE 141
               end;

						STATEMENT 1 ON LINE 143
          if (global_data.state ^= SOCK_CONNECTED) & (global_data.state ^= SOCK_CLS_READ)
          then do;

000135  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000136  aa   000006 1160 07	cmpq 	6,dl
000137  aa   000012 6000 04	tze  	10,ic		000151
000140  aa   000013 1160 07	cmpq 	11,dl
000141  aa   000010 6000 04	tze  	8,ic		000151
						STATEMENT 1 ON LINE 145
               call unlock_socket ();

000142  aa   000620 6700 04	tsp4 	400,ic		000762
						STATEMENT 1 ON LINE 147
               P_sock_state = global_data.state;

000143  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000144  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 148
               P_error_code = error_table_$net_invalid_state;

000145  aa  6 00044 3701 20	epp4 	pr6|36,*
000146  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$net_invalid_state
000147  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 149
               goto return_error;

000150  aa   777661 7100 04	tra  	-79,ic		000031
						STATEMENT 1 ON LINE 150
               end;

						STATEMENT 1 ON LINE 152
          global_data.nelemt = 0;

000151  aa  6 00121 4501 00	stz  	pr6|81		global_data.nelemt
						STATEMENT 1 ON LINE 153
          bytesize = binary (sock_ptr -> socket.byte_size, 8);

000152  aa  7 00017 2351 00	lda  	pr7|15		socket.byte_size
000153  aa   000006 7350 00	als  	6
000154  aa   000100 7730 00	lrl  	64
000155  aa  6 00100 7561 00	stq  	pr6|64		bytesize
						STATEMENT 1 ON LINE 155
          num_xfrd = -1;

000156  aa   000001 3360 07	lcq  	1,dl
000157  aa  6 00102 7561 00	stq  	pr6|66		num_xfrd
						STATEMENT 1 ON LINE 156
          do start_ptr = global_data.areap
                    repeat (addr (global_data.areap -> based_bit_array (global_data.nelemt * bytesize)))
                    while (num_xfrd ^= 0);

000160  aa  6 00122 3715 20	epp5 	pr6|82,*		global_data.areap
000161  aa  6 00104 6515 00	spri5	pr6|68		start_ptr
000162  aa  6 00102 2361 00	ldq  	pr6|66		num_xfrd
000163  aa   000052 6000 04	tze  	42,ic		000235
						STATEMENT 1 ON LINE 159
               call imp_read$imp_read_with_message_count ((sock_ptr -> socket.impdim_index), start_ptr,
                         global_data.nbytes - global_data.nelemt, num_xfrd, num_msgs, global_data.error_code);

000164  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000165  aa  7 00016 2351 00	lda  	pr7|14		socket.impdim_index
000166  aa   000022 7350 00	als  	18
000167  aa   000066 7330 00	lrs  	54
000170  aa  6 00233 7561 00	stq  	pr6|155
000171  aa  6 00120 2361 00	ldq  	pr6|80		global_data.nbytes
000172  aa  6 00121 1761 00	sbq  	pr6|81		global_data.nelemt
000173  aa  6 00252 7561 00	stq  	pr6|170
000174  aa  6 00233 3521 00	epp2 	pr6|155
000175  aa  6 00256 2521 00	spri2	pr6|174
000176  aa  6 00104 3521 00	epp2 	pr6|68		start_ptr
000177  aa  6 00260 2521 00	spri2	pr6|176
000200  aa  6 00252 3521 00	epp2 	pr6|170
000201  aa  6 00262 2521 00	spri2	pr6|178
000202  aa  6 00102 3521 00	epp2 	pr6|66		num_xfrd
000203  aa  6 00264 2521 00	spri2	pr6|180
000204  aa  6 00101 3521 00	epp2 	pr6|65		num_msgs
000205  aa  6 00266 2521 00	spri2	pr6|182
000206  aa  6 00113 3521 00	epp2 	pr6|75		global_data.error_code
000207  aa  6 00270 2521 00	spri2	pr6|184
000210  aa  6 00254 6211 00	eax1 	pr6|172
000211  aa   030000 4310 07	fld  	12288,dl
000212  aa  6 00044 3701 20	epp4 	pr6|36,*
000213  la  4 00024 3521 20	epp2 	pr4|20,*		imp_read$imp_read_with_message_count
000214  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 161
               global_data.nelemt = global_data.nelemt + num_xfrd;

000215  aa  6 00102 2361 00	ldq  	pr6|66		num_xfrd
000216  aa  6 00121 0561 00	asq  	pr6|81		global_data.nelemt
						STATEMENT 1 ON LINE 163
               sock_ptr -> socket.msg_allocation = sock_ptr -> socket.msg_allocation - num_msgs;

000217  aa  6 00101 3361 00	lcq  	pr6|65		num_msgs
000220  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000221  aa  7 00010 0561 00	asq  	pr7|8		socket.msg_allocation
						STATEMENT 1 ON LINE 164
               sock_ptr -> socket.bit_allocation = sock_ptr -> socket.bit_allocation - num_xfrd * bytesize;

000222  aa  6 00102 2361 00	ldq  	pr6|66		num_xfrd
000223  aa  6 00100 4021 00	mpy  	pr6|64		bytesize
000224  aa  6 00252 7561 00	stq  	pr6|170
000225  aa  6 00252 3361 00	lcq  	pr6|170
000226  aa  7 00007 0561 00	asq  	pr7|7		socket.bit_allocation
						STATEMENT 1 ON LINE 165
               end;

000227  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000230  aa  6 00100 4021 00	mpy  	pr6|64		bytesize
000231  aa  6 00122 3521 20	epp2 	pr6|82,*		based_bit_array
000232  aa  2 00000 5035 06	abd  	pr2|0,ql
000233  aa  6 00104 2521 00	spri2	pr6|68		start_ptr
000234  aa   777726 7100 04	tra  	-42,ic		000162
						STATEMENT 1 ON LINE 167
          if global_data.nelemt ^= 0
          then if global_data.error_code ^= 0
               then if global_data.error_code = error_table_$area_too_small
                    then global_data.error_code = 0;

000235  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000236  aa   000007 6000 04	tze  	7,ic		000245
000237  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000240  aa   000005 6000 04	tze  	5,ic		000245
000241  aa  6 00044 3701 20	epp4 	pr6|36,*
000242  la  4 00014 1161 20	cmpq 	pr4|12,*		error_table_$area_too_small
000243  aa   000002 6010 04	tnz  	2,ic		000245
000244  aa  6 00113 4501 00	stz  	pr6|75		global_data.error_code
						STATEMENT 1 ON LINE 172
          if global_data.error_code ^= 0
          then do;

000245  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000246  aa   000012 6000 04	tze  	10,ic		000260
						STATEMENT 1 ON LINE 174
               call unlock_socket ();

000247  aa   000513 6700 04	tsp4 	331,ic		000762
						STATEMENT 1 ON LINE 176
               P_num_bytes_trans = global_data.nelemt;

000250  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000251  aa  6 00032 3735 20	epp7 	pr6|26,*
000252  aa  7 00010 7561 20	stq  	pr7|8,*		P_num_bytes_trans
						STATEMENT 1 ON LINE 177
               P_sock_state = global_data.state;

000253  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000254  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 178
               P_error_code = global_data.error_code;

000255  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000256  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 179
               goto return_error;

000257  aa   777552 7100 04	tra  	-150,ic		000031
						STATEMENT 1 ON LINE 180
               end;

						STATEMENT 1 ON LINE 182
          if (global_data.state = SOCK_CONNECTED)
          then do;

000260  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000261  aa   000006 1160 07	cmpq 	6,dl
000262  aa   000022 6010 04	tnz  	18,ic		000304
						STATEMENT 1 ON LINE 184
               if (sock_ptr -> socket.msg_allocation < ncp_params_$min_msg_allocation)
                         | (sock_ptr -> socket.bit_allocation < ncp_params_$min_bit_allocation)
               then call ncp_connection_$allocate_read (sock_ptr, global_data.error_code);

000263  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000264  aa  7 00010 2361 00	ldq  	pr7|8		socket.msg_allocation
000265  aa  6 00044 3701 20	epp4 	pr6|36,*
000266  la  4 00012 1161 20	cmpq 	pr4|10,*		ncp_params_$min_msg_allocation
000267  aa   000004 6040 04	tmi  	4,ic		000273
000270  aa  7 00007 2361 00	ldq  	pr7|7		socket.bit_allocation
000271  la  4 00010 1161 20	cmpq 	pr4|8,*		ncp_params_$min_bit_allocation
000272  aa   000123 6050 04	tpl  	83,ic		000415
000273  aa  6 00110 3521 00	epp2 	pr6|72		sock_ptr
000274  aa  6 00242 2521 00	spri2	pr6|162
000275  aa  6 00113 3521 00	epp2 	pr6|75		global_data.error_code
000276  aa  6 00244 2521 00	spri2	pr6|164
000277  aa  6 00240 6211 00	eax1 	pr6|160
000300  aa   010000 4310 07	fld  	4096,dl
000301  la  4 00040 3521 20	epp2 	pr4|32,*		ncp_connection_$allocate_read
000302  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 187
               end;

000303  aa   000112 7100 04	tra  	74,ic		000415
						STATEMENT 1 ON LINE 188
          else do;

						STATEMENT 1 ON LINE 189
               if global_data.nelemt = 0
               then do;

000304  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000305  aa   000110 6010 04	tnz  	72,ic		000415
						STATEMENT 1 ON LINE 191
                    call imp_read_order ((sock_ptr -> socket.impdim_index), 4, null (), status, (0));

000306  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000307  aa  7 00016 2351 00	lda  	pr7|14		socket.impdim_index
000310  aa   000022 7350 00	als  	18
000311  aa   000066 7330 00	lrs  	54
000312  aa  6 00252 7561 00	stq  	pr6|170
000313  aa   000004 2360 07	ldq  	4,dl
000314  aa  6 00233 7561 00	stq  	pr6|155
000315  aa   777477 3714 24	epp5 	-193,ic*
000316  aa  6 00272 6515 00	spri5	pr6|186
000317  aa  6 00253 4501 00	stz  	pr6|171
000320  aa  6 00252 3521 00	epp2 	pr6|170
000321  aa  6 00256 2521 00	spri2	pr6|174
000322  aa  6 00233 3521 00	epp2 	pr6|155
000323  aa  6 00260 2521 00	spri2	pr6|176
000324  aa  6 00272 3521 00	epp2 	pr6|186
000325  aa  6 00262 2521 00	spri2	pr6|178
000326  aa  6 00103 3521 00	epp2 	pr6|67		status
000327  aa  6 00264 2521 00	spri2	pr6|180
000330  aa  6 00253 3521 00	epp2 	pr6|171
000331  aa  6 00266 2521 00	spri2	pr6|182
000332  aa  6 00254 6211 00	eax1 	pr6|172
000333  aa   024000 4310 07	fld  	10240,dl
000334  aa  6 00044 3701 20	epp4 	pr6|36,*
000335  la  4 00026 3521 20	epp2 	pr4|22,*		imp_read_order
000336  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 192
                    if ^ substr (status, 12, 1) then if ^ substr (status, 17, 1)
                    then do;

000337  aa  6 00103 2351 00	lda  	pr6|67		status
000340  aa   000100 3150 03	cana 	64,du
000341  aa   000054 6010 04	tnz  	44,ic		000415
000342  aa  6 00103 2351 00	lda  	pr6|67		status
000343  aa   000002 3150 03	cana 	2,du
000344  aa   000051 6010 04	tnz  	41,ic		000415
						STATEMENT 1 ON LINE 194
                         call ncp_access_$unassign_link (sock_ptr, (0));

000345  aa  6 00253 4501 00	stz  	pr6|171
000346  aa  6 00110 3521 00	epp2 	pr6|72		sock_ptr
000347  aa  6 00242 2521 00	spri2	pr6|162
000350  aa  6 00253 3521 00	epp2 	pr6|171
000351  aa  6 00244 2521 00	spri2	pr6|164
000352  aa  6 00240 6211 00	eax1 	pr6|160
000353  aa   010000 4310 07	fld  	4096,dl
000354  aa  6 00044 3701 20	epp4 	pr6|36,*
000355  la  4 00034 3521 20	epp2 	pr4|28,*		ncp_access_$unassign_link
000356  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 195
                         call ncp_access_$change_socket_state (sock_ptr, SOCK_ASSIGNED, (0));

000357  aa  6 00253 4501 00	stz  	pr6|171
000360  aa  6 00110 3521 00	epp2 	pr6|72		sock_ptr
000361  aa  6 00242 2521 00	spri2	pr6|162
000362  aa   777422 3520 04	epp2 	-238,ic		000004 = 000000000001
000363  aa  6 00244 2521 00	spri2	pr6|164
000364  aa  6 00253 3521 00	epp2 	pr6|171
000365  aa  6 00246 2521 00	spri2	pr6|166
000366  aa  6 00240 6211 00	eax1 	pr6|160
000367  aa   014000 4310 07	fld  	6144,dl
000370  aa  6 00044 3701 20	epp4 	pr6|36,*
000371  la  4 00032 3521 20	epp2 	pr4|26,*		ncp_access_$change_socket_state
000372  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 196
                         global_data.state = binary (sock_ptr -> socket.state, 6);

000373  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000374  aa  7 00017 2351 00	lda  	pr7|15		socket.state
000375  aa   000102 7730 00	lrl  	66
000376  aa  6 00116 7561 00	stq  	pr6|78		global_data.state
						STATEMENT 1 ON LINE 198
                         call ncp_access_$signal_process (sock_ptr, 1, (0));

000377  aa   000001 2360 07	ldq  	1,dl
000400  aa  6 00253 7561 00	stq  	pr6|171
000401  aa  6 00233 4501 00	stz  	pr6|155
000402  aa  6 00110 3521 00	epp2 	pr6|72		sock_ptr
000403  aa  6 00242 2521 00	spri2	pr6|162
000404  aa  6 00253 3521 00	epp2 	pr6|171
000405  aa  6 00244 2521 00	spri2	pr6|164
000406  aa  6 00233 3521 00	epp2 	pr6|155
000407  aa  6 00246 2521 00	spri2	pr6|166
000410  aa  6 00240 6211 00	eax1 	pr6|160
000411  aa   014000 4310 07	fld  	6144,dl
000412  aa  6 00044 3701 20	epp4 	pr6|36,*
000413  la  4 00036 3521 20	epp2 	pr4|30,*		ncp_access_$signal_process
000414  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 199
                         end;

						STATEMENT 1 ON LINE 200
                    end;

						STATEMENT 1 ON LINE 201
               end;

						STATEMENT 1 ON LINE 203
          call unlock_socket ();

000415  aa   000345 6700 04	tsp4 	229,ic		000762
						STATEMENT 1 ON LINE 205
          call complete_metering ();

000416  aa   000363 6700 04	tsp4 	243,ic		001001
						STATEMENT 1 ON LINE 207
          P_sock_state = global_data.state;

000417  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000420  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 208
          P_num_bytes_trans = global_data.nelemt;

000421  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000422  aa  6 00032 3735 20	epp7 	pr6|26,*
000423  aa  7 00010 7561 20	stq  	pr7|8,*		P_num_bytes_trans
						STATEMENT 1 ON LINE 210
          P_error_code = global_data.error_code;

000424  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000425  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 212
          return;

000426  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ncp_state                                          STATEMENT 1 ON LINE 220
ncp_state:
          entry (P_sock_indx, P_foreign_socket, P_sock_state, P_error_code);

000427  at     000004000005
000430  tt     000003000010
000431  ta     000006000000
000432  ta     000427000000
000433  da     000311300000
000434  aa   000360 6270 00	eax7 	240
000435  aa  7 00034 3521 20	epp2 	pr7|28,*
000436  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000437  aa     000010000000
000440  aa     000000000000
000441  aa  6 00032 3735 20	epp7 	pr6|26,*
000442  aa  7 00006 3715 20	epp5 	pr7|6,*
000443  aa  6 00172 6515 00	spri5	pr6|122
000444  aa  7 00010 3535 20	epp3 	pr7|8,*
000445  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 223
          P_error_code = 0;

000446  aa  6 00174 4501 20	stz  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 224
          P_sock_state = 0;

000447  aa  6 00172 4501 20	stz  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 225
          P_foreign_socket = ""b;

000450  aa  6 00032 3735 20	epp7 	pr6|26,*
000451  aa  7 00004 3715 20	epp5 	pr7|4,*
000452  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
000453  aa   000000 00 0000	descb	0,0
000454  aa  5 00000 00 0100	descb	pr5|0,64		P_foreign_socket
						STATEMENT 1 ON LINE 227
          global_data.ncp_idx = P_sock_indx;

000455  aa  7 00002 3535 20	epp3 	pr7|2,*
000456  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000457  aa  3 00000 00 0044	descb	pr3|0,36		P_sock_indx
000460  aa  6 00115 00 0044	descb	pr6|77,36		global_data.ncp_idx
						STATEMENT 1 ON LINE 229
          global_data.request_code = 14;

000461  aa   000016 2360 07	ldq  	14,dl
000462  aa  6 00114 7561 00	stq  	pr6|76		global_data.request_code
						STATEMENT 1 ON LINE 230
          global_data.entry_type = 7;

000463  aa   000007 2360 07	ldq  	7,dl
000464  aa  6 00136 7561 00	stq  	pr6|94		global_data.entry_type
						STATEMENT 1 ON LINE 231
          global_data.privilege_code = 0;

000465  aa  6 00117 4501 00	stz  	pr6|79		global_data.privilege_code
						STATEMENT 1 ON LINE 233
          call make_global_data_valid ();

000466  aa   000333 6700 04	tsp4 	219,ic		001021
						STATEMENT 1 ON LINE 235
          sock_ptr = null ();

000467  aa   777325 2370 04	ldaq 	-299,ic		000014 = 077777000043 000001000000
000470  aa  6 00110 7571 00	staq 	pr6|72		sock_ptr
						STATEMENT 1 ON LINE 236
          call condition_ ("any_other", ncp_error_$any_other_handler);

000471  aa   777327 2370 04	ldaq 	-297,ic		000020 = 141156171137 157164150145
000472  aa  6 00230 7571 00	staq 	pr6|152
000473  aa   162000 2350 03	lda  	58368,du
000474  aa  6 00232 7551 00	sta  	pr6|154
000475  aa  6 00044 3701 20	epp4 	pr6|36,*
000476  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_$any_other_handler
000477  aa  6 00234 2521 00	spri2	pr6|156		cp.158
000500  aa   000364 2370 04	ldaq 	244,ic		001064 = 077777000043 000001000000
000501  aa  6 00236 7571 00	staq 	pr6|158		cp.158
000502  aa  6 00230 3521 00	epp2 	pr6|152
000503  aa  6 00242 2521 00	spri2	pr6|162
000504  aa  6 00234 3521 00	epp2 	pr6|156		cp.158
000505  aa  6 00244 2521 00	spri2	pr6|164
000506  aa   777273 3520 04	epp2 	-325,ic		000001 = 524000000011
000507  aa  6 00246 2521 00	spri2	pr6|166
000510  aa   777270 3520 04	epp2 	-328,ic		000000 = 500000000000
000511  aa  6 00250 2521 00	spri2	pr6|168
000512  aa  6 00240 6211 00	eax1 	pr6|160
000513  aa   010000 4310 07	fld  	4096,dl
000514  la  4 00022 3521 20	epp2 	pr4|18,*		condition_
000515  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 238
          sock_ptr = find_and_lock_socket (global_data.ncp_idx);

000516  aa   000340 3520 04	epp2 	224,ic		001056 = 000004000000
000517  aa   000207 6700 04	tsp4 	135,ic		000726
						STATEMENT 1 ON LINE 240
          global_data.fsoc = string (sock_ptr -> socket.foreign_socket);

000520  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000521  aa  7 00013 2351 00	lda  	pr7|11
000522  aa  7 00014 2361 00	ldq  	pr7|12
000523  aa  6 00124 6771 00	eraq 	pr6|84		global_data.fsoc
000524  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
000525  aa  6 00124 6551 00	ersa 	pr6|84		global_data.fsoc
000526  aa  6 00125 6561 00	ersq 	pr6|85		global_data.fsoc
						STATEMENT 1 ON LINE 241
          call unlock_socket ();

000527  aa   000233 6700 04	tsp4 	155,ic		000762
						STATEMENT 1 ON LINE 242
          if (global_data.state = SOCK_RFC_RCVD) | (global_data.state = SOCK_RFC_ABORTED)
          then call ncp_tbop_$process_call (procp);

000530  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000531  aa   000003 1160 07	cmpq 	3,dl
000532  aa   000003 6000 04	tze  	3,ic		000535
000533  aa   000004 1160 07	cmpq 	4,dl
000534  aa   000010 6010 04	tnz  	8,ic		000544
000535  aa  6 00106 3521 00	epp2 	pr6|70		procp
000536  aa  6 00236 2521 00	spri2	pr6|158
000537  aa  6 00234 6211 00	eax1 	pr6|156
000540  aa   004000 4310 07	fld  	2048,dl
000541  aa  6 00044 3701 20	epp4 	pr6|36,*
000542  la  4 00046 3521 20	epp2 	pr4|38,*		ncp_tbop_$process_call
000543  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 245
          call complete_metering ();

000544  aa   000235 6700 04	tsp4 	157,ic		001001
						STATEMENT 1 ON LINE 247
          P_sock_state = global_data.state;

000545  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000546  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 248
          P_foreign_socket = global_data.fsoc;

000547  aa  6 00032 3735 20	epp7 	pr6|26,*
000550  aa  7 00004 3715 20	epp5 	pr7|4,*
000551  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000552  aa  6 00124 00 0100	descb	pr6|84,64		global_data.fsoc
000553  aa  5 00000 00 0100	descb	pr5|0,64		P_foreign_socket
						STATEMENT 1 ON LINE 250
          P_error_code = global_data.error_code;

000554  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000555  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 252
          return;

000556  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ncp_write                                          STATEMENT 1 ON LINE 259
ncp_write:
          entry (P_sock_indx, P_buff_ptr, P_num_bytes, P_num_bytes_trans, P_sock_state, P_error_code);

000557  ta     000033000000
000560  da     000317300000
000561  aa   000360 6270 00	eax7 	240
000562  aa  7 00034 3521 20	epp2 	pr7|28,*
000563  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000564  aa     000014000000
000565  aa     000000000000
000566  aa  6 00032 3735 20	epp7 	pr6|26,*
000567  aa  7 00012 3715 20	epp5 	pr7|10,*
000570  aa  6 00172 6515 00	spri5	pr6|122
000571  aa  7 00014 3535 20	epp3 	pr7|12,*
000572  aa  6 00174 2535 00	spri3	pr6|124
						STATEMENT 1 ON LINE 262
          P_error_code = 0;

000573  aa  6 00174 4501 20	stz  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 263
          P_sock_state = 0;

000574  aa  6 00172 4501 20	stz  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 264
          P_num_bytes_trans = 0;

000575  aa  6 00032 3735 20	epp7 	pr6|26,*
000576  aa  7 00010 4501 20	stz  	pr7|8,*		P_num_bytes_trans
						STATEMENT 1 ON LINE 267
          global_data.request_code = 15;

000577  aa   000017 2360 07	ldq  	15,dl
000600  aa  6 00114 7561 00	stq  	pr6|76		global_data.request_code
						STATEMENT 1 ON LINE 269
          global_data.ncp_idx = P_sock_indx;

000601  aa  7 00002 3715 20	epp5 	pr7|2,*
000602  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000603  aa  5 00000 00 0044	descb	pr5|0,36		P_sock_indx
000604  aa  6 00115 00 0044	descb	pr6|77,36		global_data.ncp_idx
						STATEMENT 1 ON LINE 270
          global_data.areap = P_buff_ptr;

000605  aa  7 00004 3535 20	epp3 	pr7|4,*		P_buff_ptr
000606  aa  3 00000 3535 20	epp3 	pr3|0,*		P_buff_ptr
000607  aa  6 00122 2535 00	spri3	pr6|82		global_data.areap
						STATEMENT 1 ON LINE 271
          global_data.nbytes = P_num_bytes;

000610  aa  7 00006 2361 20	ldq  	pr7|6,*		P_num_bytes
000611  aa  6 00120 7561 00	stq  	pr6|80		global_data.nbytes
						STATEMENT 1 ON LINE 273
          call make_global_data_valid ();

000612  aa   000207 6700 04	tsp4 	135,ic		001021
						STATEMENT 1 ON LINE 275
          sock_ptr = null ();

000613  aa   777201 2370 04	ldaq 	-383,ic		000014 = 077777000043 000001000000
000614  aa  6 00110 7571 00	staq 	pr6|72		sock_ptr
						STATEMENT 1 ON LINE 276
          call condition_ ("any_other", ncp_error_$any_other_handler);

000615  aa   777203 2370 04	ldaq 	-381,ic		000020 = 141156171137 157164150145
000616  aa  6 00230 7571 00	staq 	pr6|152
000617  aa   162000 2350 03	lda  	58368,du
000620  aa  6 00232 7551 00	sta  	pr6|154
000621  aa  6 00044 3701 20	epp4 	pr6|36,*
000622  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_$any_other_handler
000623  aa  6 00234 2521 00	spri2	pr6|156		cp.158
000624  aa   000240 2370 04	ldaq 	160,ic		001064 = 077777000043 000001000000
000625  aa  6 00236 7571 00	staq 	pr6|158		cp.158
000626  aa  6 00230 3521 00	epp2 	pr6|152
000627  aa  6 00242 2521 00	spri2	pr6|162
000630  aa  6 00234 3521 00	epp2 	pr6|156		cp.158
000631  aa  6 00244 2521 00	spri2	pr6|164
000632  aa   777147 3520 04	epp2 	-409,ic		000001 = 524000000011
000633  aa  6 00246 2521 00	spri2	pr6|166
000634  aa   777144 3520 04	epp2 	-412,ic		000000 = 500000000000
000635  aa  6 00250 2521 00	spri2	pr6|168
000636  aa  6 00240 6211 00	eax1 	pr6|160
000637  aa   010000 4310 07	fld  	4096,dl
000640  la  4 00022 3521 20	epp2 	pr4|18,*		condition_
000641  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 278
          sock_ptr = find_and_lock_socket (global_data.ncp_idx);

000642  aa   000214 3520 04	epp2 	140,ic		001056 = 000004000000
000643  aa   000063 6700 04	tsp4 	51,ic		000726
						STATEMENT 1 ON LINE 280
          if sock_ptr -> socket.send_gender ^= WRITE_GENDER
          then do;

000644  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000645  aa  7 00017 2351 00	lda  	pr7|15		socket.send_gender
000646  aa   000016 7350 00	als  	14
000647  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000650  aa   400000 1150 03	cmpa 	131072,du
000651  aa   000006 6000 04	tze  	6,ic		000657
						STATEMENT 1 ON LINE 282
               call unlock_socket ();

000652  aa   000110 6700 04	tsp4 	72,ic		000762
						STATEMENT 1 ON LINE 283
               P_error_code = error_table_$net_bad_gender;

000653  aa  6 00044 3701 20	epp4 	pr6|36,*
000654  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$net_bad_gender
000655  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 284
               goto return_error;

000656  aa   777153 7100 04	tra  	-405,ic		000031
						STATEMENT 1 ON LINE 285
               end;

						STATEMENT 1 ON LINE 287
          if global_data.state ^= SOCK_CONNECTED
          then do;

000657  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000660  aa   000006 1160 07	cmpq 	6,dl
000661  aa   000010 6000 04	tze  	8,ic		000671
						STATEMENT 1 ON LINE 289
               call unlock_socket ();

000662  aa   000100 6700 04	tsp4 	64,ic		000762
						STATEMENT 1 ON LINE 291
               P_sock_state = global_data.state;

000663  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000664  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 292
               P_error_code = error_table_$net_invalid_state;

000665  aa  6 00044 3701 20	epp4 	pr6|36,*
000666  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$net_invalid_state
000667  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 293
               goto return_error;

000670  aa   777141 7100 04	tra  	-415,ic		000031
						STATEMENT 1 ON LINE 294
               end;

						STATEMENT 1 ON LINE 296
          call imp_write ((sock_ptr -> socket.impdim_index), global_data.areap, global_data.nbytes, global_data.nelemt, global_data.error_code);

000671  aa  7 00016 2351 00	lda  	pr7|14		socket.impdim_index
000672  aa   000022 7350 00	als  	18
000673  aa   000066 7330 00	lrs  	54
000674  aa  6 00233 7561 00	stq  	pr6|155
000675  aa  6 00233 3521 00	epp2 	pr6|155
000676  aa  6 00256 2521 00	spri2	pr6|174
000677  aa  6 00122 3521 00	epp2 	pr6|82		global_data.areap
000700  aa  6 00260 2521 00	spri2	pr6|176
000701  aa  6 00120 3521 00	epp2 	pr6|80		global_data.nbytes
000702  aa  6 00262 2521 00	spri2	pr6|178
000703  aa  6 00121 3521 00	epp2 	pr6|81		global_data.nelemt
000704  aa  6 00264 2521 00	spri2	pr6|180
000705  aa  6 00113 3521 00	epp2 	pr6|75		global_data.error_code
000706  aa  6 00266 2521 00	spri2	pr6|182
000707  aa  6 00254 6211 00	eax1 	pr6|172
000710  aa   024000 4310 07	fld  	10240,dl
000711  aa  6 00044 3701 20	epp4 	pr6|36,*
000712  la  4 00030 3521 20	epp2 	pr4|24,*		imp_write
000713  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 298
          call unlock_socket ();

000714  aa   000046 6700 04	tsp4 	38,ic		000762
						STATEMENT 1 ON LINE 300
          call complete_metering ();

000715  aa   000064 6700 04	tsp4 	52,ic		001001
						STATEMENT 1 ON LINE 302
          P_num_bytes_trans = global_data.nelemt;

000716  aa  6 00121 2361 00	ldq  	pr6|81		global_data.nelemt
000717  aa  6 00032 3735 20	epp7 	pr6|26,*
000720  aa  7 00010 7561 20	stq  	pr7|8,*		P_num_bytes_trans
						STATEMENT 1 ON LINE 303
          P_sock_state = global_data.state;

000721  aa  6 00116 2361 00	ldq  	pr6|78		global_data.state
000722  aa  6 00172 7561 20	stq  	pr6|122,*		P_sock_state
						STATEMENT 1 ON LINE 304
          P_error_code = global_data.error_code;

000723  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000724  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 306
          return;

000725  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 394
end;

BEGIN PROCEDURE find_and_lock_socket
ENTRY TO find_and_lock_socket                               STATEMENT 1 ON LINE 310
find_and_lock_socket:
          procedure (p_socket_indx) returns (ptr);

000726  aa  6 00176 6501 00	spri4	pr6|126
000727  aa  6 00200 2521 00	spri2	pr6|128
						STATEMENT 1 ON LINE 327
          call ncp_util_$find_socket_from_index (p_socket_indx, "0"b, entry_ptr, global_data.error_code);

000730  aa   000000 2350 07	lda  	0,dl
000731  aa  6 00274 7551 00	sta  	pr6|188
000732  aa  2 00002 3521 20	epp2 	pr2|2,*		p_socket_indx
000733  aa  6 00300 2521 00	spri2	pr6|192
000734  aa  6 00274 3521 00	epp2 	pr6|188
000735  aa  6 00302 2521 00	spri2	pr6|194
000736  aa  6 00204 3521 00	epp2 	pr6|132		entry_ptr
000737  aa  6 00304 2521 00	spri2	pr6|196
000740  aa  6 00113 3521 00	epp2 	pr6|75		global_data.error_code
000741  aa  6 00306 2521 00	spri2	pr6|198
000742  aa  6 00276 6211 00	eax1 	pr6|190
000743  aa   020000 4310 07	fld  	8192,dl
000744  aa  6 00044 3701 20	epp4 	pr6|36,*
000745  la  4 00054 3521 20	epp2 	pr4|44,*		ncp_util_$find_socket_from_index
000746  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 328
          if global_data.error_code ^= 0
          then do;

000747  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
000750  aa   000003 6000 04	tze  	3,ic		000753
						STATEMENT 1 ON LINE 330
               P_error_code = global_data.error_code;

000751  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 331
               goto return_error;

000752  aa   777057 7100 04	tra  	-465,ic		000031
						STATEMENT 1 ON LINE 332
               end;

						STATEMENT 1 ON LINE 334
          global_data.state = binary (entry_ptr -> socket.state, 6);

000753  aa  6 00204 3735 20	epp7 	pr6|132,*		entry_ptr
000754  aa  7 00017 2351 00	lda  	pr7|15		socket.state
000755  aa   000102 7730 00	lrl  	66
000756  aa  6 00116 7561 00	stq  	pr6|78		global_data.state
						STATEMENT 1 ON LINE 336
          return (entry_ptr);

000757  aa  6 00200 3715 20	epp5 	pr6|128,*
000760  aa  5 00004 6535 20	spri7	pr5|4,*
000761  aa  6 00176 6101 00	rtcd 	pr6|126
						STATEMENT 1 ON LINE 338
end;

  END PROCEDURE find_and_lock_socket
BEGIN PROCEDURE unlock_socket
ENTRY TO unlock_socket                                      STATEMENT 1 ON LINE 342
unlock_socket:
          procedure ();

000762  aa  6 00206 6501 00	spri4	pr6|134
						STATEMENT 1 ON LINE 347
          call ncp_lock_$lock_unlock (addr (sock_ptr -> socket.lock), (0));

000763  aa  6 00110 3735 20	epp7 	pr6|72,*		sock_ptr
000764  aa  7 00004 3735 00	epp7 	pr7|4		socket.lock
000765  aa  6 00310 6535 00	spri7	pr6|200
000766  aa  6 00312 4501 00	stz  	pr6|202
000767  aa  6 00310 3521 00	epp2 	pr6|200
000770  aa  6 00316 2521 00	spri2	pr6|206
000771  aa  6 00312 3521 00	epp2 	pr6|202
000772  aa  6 00320 2521 00	spri2	pr6|208
000773  aa  6 00314 6211 00	eax1 	pr6|204
000774  aa   010000 4310 07	fld  	4096,dl
000775  aa  6 00044 3701 20	epp4 	pr6|36,*
000776  la  4 00044 3521 20	epp2 	pr4|36,*		ncp_lock_$lock_unlock
000777  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 349
          return;

001000  aa  6 00206 6101 00	rtcd 	pr6|134
						STATEMENT 1 ON LINE 351
end;

  END PROCEDURE unlock_socket
BEGIN PROCEDURE complete_metering
ENTRY TO complete_metering                                  STATEMENT 1 ON LINE 355
complete_metering:
          procedure ();

001001  aa  6 00214 6501 00	spri4	pr6|140
						STATEMENT 1 ON LINE 360
          call ncp_util_$exit_NCP_environment (procp, addr (global_data), (0));

001002  aa  6 00112 3735 00	epp7 	pr6|74		global_data
001003  aa  6 00322 6535 00	spri7	pr6|210
001004  aa  6 00324 4501 00	stz  	pr6|212
001005  aa  6 00106 3521 00	epp2 	pr6|70		procp
001006  aa  6 00330 2521 00	spri2	pr6|216
001007  aa  6 00322 3521 00	epp2 	pr6|210
001010  aa  6 00332 2521 00	spri2	pr6|218
001011  aa  6 00324 3521 00	epp2 	pr6|212
001012  aa  6 00334 2521 00	spri2	pr6|220
001013  aa  6 00326 6211 00	eax1 	pr6|214
001014  aa   014000 4310 07	fld  	6144,dl
001015  aa  6 00044 3701 20	epp4 	pr6|36,*
001016  la  4 00052 3521 20	epp2 	pr4|42,*		ncp_util_$exit_NCP_environment
001017  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 362
          return;

001020  aa  6 00214 6101 00	rtcd 	pr6|140
						STATEMENT 1 ON LINE 364
end;

  END PROCEDURE complete_metering
BEGIN PROCEDURE make_global_data_valid
ENTRY TO make_global_data_valid                             STATEMENT 1 ON LINE 368
make_global_data_valid:
          procedure ();

001021  aa  6 00222 6501 00	spri4	pr6|146
						STATEMENT 1 ON LINE 373
          global_data.proc_tbp = null;

001022  aa   776772 2370 04	ldaq 	-518,ic		000014 = 077777000043 000001000000
001023  aa  6 00142 7571 00	staq 	pr6|98		global_data.proc_tbp
						STATEMENT 1 ON LINE 374
          global_data.error_code = 0;

001024  aa  6 00113 4501 00	stz  	pr6|75		global_data.error_code
						STATEMENT 1 ON LINE 375
          global_data.init_sw, global_data.nprocs_sw = 0;

001025  aa  6 00112 4501 00	stz  	pr6|74		global_data.init_sw
001026  aa  6 00137 4501 00	stz  	pr6|95		global_data.nprocs_sw
						STATEMENT 1 ON LINE 376
          global_data.abort_location = return_error;

001027  aa   777002 3520 04	epp2 	-510,ic		000031 = 000750670004
001030  aa  6 00126 2521 00	spri2	pr6|86		global_data.abort_location
001031  aa  6 00130 6521 00	spri6	pr6|88		global_data.abort_location
						STATEMENT 1 ON LINE 378
          global_data.host_tbl_index = 0;

001032  aa  6 00132 4501 00	stz  	pr6|90		global_data.host_tbl_index
						STATEMENT 1 ON LINE 380
          call ncp_util_$enter_user_NCP_environment (procp, addr (global_data), global_data.error_code);

001033  aa  6 00112 3735 00	epp7 	pr6|74		global_data
001034  aa  6 00336 6535 00	spri7	pr6|222
001035  aa  6 00106 3521 00	epp2 	pr6|70		procp
001036  aa  6 00342 2521 00	spri2	pr6|226
001037  aa  6 00336 3521 00	epp2 	pr6|222
001040  aa  6 00344 2521 00	spri2	pr6|228
001041  aa  6 00113 3521 00	epp2 	pr6|75		global_data.error_code
001042  aa  6 00346 2521 00	spri2	pr6|230
001043  aa  6 00340 6211 00	eax1 	pr6|224
001044  aa   014000 4310 07	fld  	6144,dl
001045  aa  6 00044 3701 20	epp4 	pr6|36,*
001046  la  4 00050 3521 20	epp2 	pr4|40,*		ncp_util_$enter_user_NCP_environment
001047  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 381
          if global_data.error_code ^= 0
          then do;

001050  aa  6 00113 2361 00	ldq  	pr6|75		global_data.error_code
001051  aa   000003 6000 04	tze  	3,ic		001054
						STATEMENT 1 ON LINE 383
               P_error_code = global_data.error_code;

001052  aa  6 00174 7561 20	stq  	pr6|124,*		P_error_code
						STATEMENT 1 ON LINE 384
               goto return_error;

001053  aa   776756 7100 04	tra  	-530,ic		000031
						STATEMENT 1 ON LINE 385
               end;

						STATEMENT 1 ON LINE 387
          return;

001054  aa  6 00222 6101 00	rtcd 	pr6|146
						STATEMENT 1 ON LINE 389
end;

  END PROCEDURE make_global_data_valid
  END PROCEDURE ncp_io_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
