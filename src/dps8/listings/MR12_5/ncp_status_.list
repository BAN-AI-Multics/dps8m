	COMPILATION LISTING OF SEGMENT ncp_status_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1320.5 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1976 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   * Copyright (c) 1972 by Massachusetts Institute of        *
        9*   * Technology and Honeywell Information Systems, Inc.      *
       10*   *                                                         *
       11*   *********************************************************** */
       12 
       13 
       14 ncp_status_:
       15           procedure ();
       16 
       17 /*             "ncp_status_" -- this procedure contains routines to return      */
       18 /*        status information to users about sockets and other items in the      */
       19 /*        Network Control Program's data bases.  Notice that we always return   */
       20 /*        an 'unspec'ed copy of the entry.  This means that pointers may not    */
       21 /*        be aligned on an even word boundary.  It also means that the compiler */
       22 /*        can use a bit copy mechanism rather than an item by item mechansim.   */
       23 /*        It also allows this program to not worry about the extra alignment    */
       24 /*        problems caused by that extra word left over in pointer assignments   */
       25 /*        to odd word boundaries.                                               */
       26 
       27 /*        Originally written by E. Meyer                              */
       28 /*        Last modified by D. M. Wells on 17 June, 1974 to update write allocations from  */
       29 /*             the IMP DIM (via an order call), and to do some cleanup of code.           */
       30 
       31           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
       32 
       33      declare
       34          (P_user_request fixed binary (12),                 /* indicates type of user request                 */
       35           P_ncp_state fixed binary (17),
       36           P_first_offset fixed binary (18),                 /* table offset or scan start location            */
       37           P_space_size fixed binary (19),                   /* word length of caller's area                   */
       38           P_error_code fixed binary (35),                   /* standard Multics error code                    */
       39           P_info_ptr pointer,
       40           P_space_ptr pointer)                                    /* pointer to the user's data storage space       */
       41                parameter;
       42 
       43           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
       44 
       45      declare
       46          ((array_indx, next_rfc, RQ, table_indx) fixed binary (17),
       47           (first_offset, table_start) fixed binary (17),
       48           offset_list (1024) fixed binary (17),
       49           (array_size, copy_size, space_size) fixed binary (19),
       50           err_code fixed binary (35),
       51           privilege bit (1),
       52           proc_id bit (36) aligned,
       53           (array_ptr, host_ptr, space_ptr, table_ptr) pointer,
       54           (epr, hpr, mpr, npr, rpr, sep, spr) pointer)
       55                automatic;
       56 
       57      declare
       58           1 host_copy aligned automatic like host;
       59 
       60      declare
       61           1 impdim_alloc_struc aligned automatic,
       62              2 bit_allocation fixed binary (16),
       63              2 msg_allocation fixed binary (32);
       64 
       65           /* * * * * TEXT SECTION REFERENCES * * * * * * * */
       66 
       67      declare
       68           GET_ALLOCATION_DATA initial (17)
       69                fixed binary (12) internal static options (constant);
       70 
       71           /* * * * * BASED & TEMPLATE DECLARATIONS * * * * */
       72 
       73      declare
       74           based_indx_list (copy_size) bit (36) aligned
       75                based;
       76 
       77      declare
       78           1 error_array (1) aligned based like error_snapshot,
       79           1 host_array (1) aligned based like host,
       80           1 rfc_array (1) aligned based like rcvd_rfc,
       81           1 socket_array (1) aligned based like socket;
       82 
       83      declare
       84           1 info_struc aligned based,                       /* user supplied space (output space)   */
       85              2 it (2),
       86                 3 offset fixed binary (17),                 /* offset from start of structure of this list    */
       87                 3 space_size fixed binary (19);             /* word length of this list             */
       88 
       89           /* * * * * EXTERNAL STATIC DECLARATIONS  * * * * */
       90 
       91      declare
       92           pds$process_id bit (36) aligned
       93                external static;
       94 
       95      declare
       96          (ncp_tables_$error_tbl,
       97           ncp_tables_$host_tbl,
       98           ncp_tables_$lock_tbl,
       99           ncp_tables_$meter_cells,
      100           ncp_tables_$ncp_data,
      101           ncp_tables_$proc_tbl,
      102           ncp_tables_$rfc_tbl,
      103           ncp_tables_$socket_tbl)
      104                external static;
      105 
      106      declare
      107          (error_table_$action_not_performed,
      108           error_table_$area_too_small,
      109           error_table_$bad_index,
      110           error_table_$bad_processid,
      111           error_table_$undefined_order_request)
      112                fixed binary (35) external static;
      113 
      114           /* * * * * ENTRY & PROCEDURE DECLARATIONS  * * * */
      115 
      116      declare
      117           imp_write_order constant entry (fixed bin (17), fixed bin (12), ptr, bit (18), fixed bin (35)),
      118           ncp_util_$find_host_entry constant entry (fixed bin (16), bit (1), ptr, fixed bin (35));
      119 
      120      declare
      121          (addr, addrel, binary, bit, hbound, lbound, mod, null, pointer, rel, size, unspec)
      122                builtin;
      123 
      124           /* * * * * INCLUDE FILES * * * * * * * * * * * * */
      125 
      126           
  1     2 /*        BEGIN include file "ncp_connection_dcls.incl.pl1" --                  */
  1     3 
  1     4 /*             This include file contains declarations for the structures       */
  1     5 /*        maintained by the NCP which contain information about Host-Host       */
  1     6 /*        connections.  Currently, this is the information about sockets,       */
  1     7 /*        hosts, and requests-for-connection.                                   */
  1     8 
  1     9 /*        Originally created by D. M. Wells, Summer, 1975.                      */
  1    10 /*	Modified by B. Greenberg, Spring '78 for new leader support */
  1    11 /*	        Modified by C. Hornig, July 1979 for new host number format */
  1    12 
  1    13      declare
  1    14           1 socket aligned based,                           /* information we keep on a per-socket basis      */
  1    15              2 event_channel fixed binary (71),             /* event channel of using process                 */
  1    16              2 overseer_event_channel fixed binary (71),    /* event chanel of overseer process               */
  1    17              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    18              2 process_id bit (36) aligned,                 /* process id of using process                    */
  1    19              2 overseer_process_id bit (36) aligned,        /* process id of overseer process                 */
  1    20              2 bit_allocation fixed binary (32),            /* bit allocation outstanding on attached link    */
  1    21              2 msg_allocation fixed binary (16),            /* message allocation outstanding on link         */
  1    22 
  1    23              2 local_socket unaligned like socket.foreign_socket,     /* identification of local socket       */
  1    24              2 foreign_socket unaligned,                    /* identification of foreign socket               */
  1    25 	      3 host,				/* id of this host				*/
  1    26 	        4 net bit (8),			/* network id				*/
  1    27 	        4 host bit (8),			/* port on imp				*/
  1    28 	        4 imp bit (16),			/* imp id					*/
  1    29                 3 socket_num bit (32),                      /* actual socket number                           */
  1    30                 3 pad bit (8),
  1    31 
  1    32              2 rfc_queue fixed binary (17) unaligned,       /* RFC table index of next block for this         */
  1    33                                                             /* socket, 0 if queue is empty                    */
  1    34              2 link_number fixed binary (17) unaligned,     /* number of link assigned for connection         */
  1    35 
  1    36              2 host_entry_index fixed binary (17) unaligned,          /* index in host table of foreign       */
  1    37                                                                       /* host involved in connection          */
  1    38              2 impdim_index fixed binary (17) unaligned,    /* index by which IMPDIM knows about connection   */
  1    39              2 state bit (6) unaligned,                     /* finite-state-machine information               */
  1    40              2 byte_size bit (8) unaligned,                 /* byte-size of connections                       */
  1    41              2 send_gender bit (1) unaligned,               /* on iff this is a transmit socket               */
  1    42              2 allow_interrupts bit (1) unaligned,          /* on iff INS and INR should be signalled to user */
  1    43              2 deactivate bit (1) unaligned,                /* on iff this socket should be deactivated when  */
  1    44                                                             /* matching network messages are finally received */
  1    45              2 allow_rfc_queuing bit (1) unaligned,         /* on iff we should allow multiple outstanding    */
  1    46                                                             /* RFC's for this socket                          */
  1    47              2 extra_bits bit (12) unaligned,
  1    48 
  1    49              2 overseer_validation_level bit (3) unaligned,           /* ring of highest overseer control     */
  1    50              2 validation_level bit (3) unaligned,                    /* ring of highest operator control     */
  1    51 
  1    52              2 overseer_lock_id bit (36) aligned,           /* lock id of the overseer process                */
  1    53              2 umodes bit (36) aligned,                     /* 36 bits that the users can play with           */
  1    54              2 time_state_changed fixed binary (71),        /* time that the socket state last changed        */
  1    55              2 signal_event_channel fixed binary (71),      /* chanel to signal over when get INS or INR      */
  1    56              2 socket_index bit (36) aligned,               /* the handle we gave user for future reference   */
  1    57              2 history aligned,                             /* state of socket over recent past history       */
  1    58                 3 num_state_changes fixed binary (11) unaligned,      /* small field, so only keep mod        */
  1    59                 3 prev_state (0 : 3) fixed binary (5) unaligned;      /* past N states, kept in rotation      */
  1    60 
  1    61      declare
  1    62           1 host aligned based,                             /* information we retain about a foreign host     */
  1    63              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  1    64              2 rcv_link_index fixed binary (17) unaligned,  /* impdim index of read link for control msgs     */
  1    65              2 xmit_link_index fixed binary (17) unaligned, /* impdim index of write link for control msgs    */
  1    66              2 read_links_assigned bit (32) unaligned,      /* a bit is on iff we have assigned that link     */
  1    67              2 read_link_padd bit (4) unaligned,
  1    68 	   2 xhost_number_pad bit (9) unaligned,
  1    69              2 host_state bit (6) unaligned,                /* stae of communications with this host          */
  1    70              2 previous_host_state bit (6) unaligned,       /* last state of this host                        */
  1    71              2 state_pad bit (15) unaligned,
  1    72              2 time_state_changed fixed binary (71),        /* time when host state last changed              */
  1    73              2 read_links_used bit (32) unaligned,          /* bit is on if link has been used "recently"     */
  1    74              2 read_link_used_pad bit (4) unaligned,
  1    75              2 num_connections fixed binary (17) unaligned, /* times we attached links for this host          */
  1    76              2 hash_index fixed binary (17) unaligned,      /* table index of this host entry                 */
  1    77 	   2 host_number fixed bin (32) aligned,	/* host number of this host			*/
  1    78 	   2 host_number_pad fixed bin (35);
  1    79 
  1    80      declare
  1    81           1 rcvd_rfc aligned based,                         /* info about a rcvd Request for Connection       */
  1    82              2 foreign_socket unaligned like socket.foreign_socket,   /* foreign socket in RFC msg            */
  1    83              2 foreign_hosts_choice fixed binary (17) unaligned,      /* link or size that other host chose   */
  1    84              2 next_entry fixed binary (17) unaligned,                /* next RFC entry in queue for socket   */
  1    85              2 padding (1) fixed binary (35);
  1    86 
  1    87      declare
  1    88 	1 host_address based aligned,			/* Form of a host address			*/
  1    89 	   2 net bit (8) unaligned,			/* Netwwork ID				*/
  1    90 	   2 host bit (8) unaligned,			/* Host Port				*/
  1    91 	   2 imp bit (16) unaligned;			/* IMP ID					*/
  1    92 				/* Duplicated because of PL/I multi-like restriction */
  1    93 
  1    94 /*        END of include file ncp_connection_dcls.incl.pl1                      */
  1    95 
      126 
      127           
  2     2 /*             "ncp_constants_dcls.incl.pl1" -- include file to       */
  2     3 /*        declare some constants used throughout the Multics Network  */
  2     4 /*        Control Program (NCP).                                      */
  2     5 
  2     6 /*        Originally created by D. M. Wells, 1975, May 19.            */
  2     7 
  2     8      declare
  2     9          (NCP_DOWN            initial (0),                  /* the NCP has been shutdown normally             */
  2    10           NCP_UP_IMP_DOWN     initial (1),                  /* the NCP is up, but the IMP is unreachable      */
  2    11           NCP_UP              initial (2),                  /* the NCP is up and running normally             */
  2    12           NCP_CRASHED         initial (-1))                 /* the NCP has crashed itself                     */
  2    13                fixed binary (3) internal static options (constant);
  2    14 
  2    15      declare
  2    16          (READ_GENDER         initial ("0"b),               /* Read sockets are even numbers                  */
  2    17           WRITE_GENDER        initial ("1"b))               /* Write sockets ar odd numbers                   */
  2    18                bit (1) internal static options (constant);
  2    19 
  2    20      declare
  2    21          (HOST_OFF            initial (0),                  /* this host is not enabled for communications    */
  2    22           HOST_UP             initial (1),                  /* Host is up and everything ok                   */
  2    23           HOST_RST            initial (2),                  /* a Host-Host RST command has been sent          */
  2    24           HOST_DOWN           initial (3),                  /* Foreign host is down                           */
  2    25           HOST_ON             initial (4))                  /* Foreign host is enabled, but not RST yet       */
  2    26                fixed binary (6) internal static options (constant);
  2    27 
  2    28      declare
  2    29          (SOCK_UNASSIGNED     initial (0),                  /* This socket entry is not in use currently      */
  2    30           SOCK_ASSIGNED       initial (1),                  /* Socket has been assigned and is quiescent      */
  2    31           SOCK_LISTENING      initial (2),                  /* Socket is listening for incoming-RFCs          */
  2    32           SOCK_RFC_RCVD       initial (3),                  /* Socket has received RFC from foreign socket    */
  2    33           SOCK_RFC_ABORTED    initial (4),                  /* CLS  received for unacknowledged RFC           */
  2    34           SOCK_RFC_SENT       initial (5),                  /* RFC sent to foreign socket, but no reply       */
  2    35           SOCK_CONNECTED      initial (6),                  /* Socket is connected to foreign socket          */
  2    36           SOCK_CLS_WAIT       initial (7),                  /* CLS issued, waiting for reply CLS              */
  2    37                                                             /* State 8 is not currently defined               */
  2    38           SOCK_DATA_WAIT      initial (9),                  /* User requested close, but data still here      */
  2    39           SOCK_RFNM_WAIT      initial (10),                 /* User requested close, but waiting on last RFNM */
  2    40           SOCK_CLS_READ       initial (11),                 /* CLS received, but data still in buffers        */
  2    41                                                             /* State 12 is not currently defined              */
  2    42           SOCK_BROKEN         initial (13),                 /* Socket has been involved in some NCP anomaly   */
  2    43           SOCK_RESET          initial (14))                 /* Socket was connected to host that was reset    */
  2    44                fixed binary (6) internal static options (constant);
  2    45 
  2    46      declare
  2    47          (SOCK_INDX_MASK      initial ("000000777777"b3),   /* mask to get out actual array index             */
  2    48           SOCK_UNIQUE_MASK    initial ("377777000000"b3))   /* mask to get out incrementing part of indx      */
  2    49                bit (36) internal static options (constant);
  2    50 
  2    51      declare
  2    52          (ANY_TRACING         initial ("400000000000"b3),             /* if any tracing is occurring          */
  2    53           PRINTER_TRACING     initial ("200000000000"b3),             /* if tracing to the ptr is happening   */
  2    54           SYSERR_LOG_TRACING  initial ("100000000000"b3),             /* if tracing to syserr log mechanism   */
  2    55 
  2    56           TRACE_CTL_MSGS      initial ("004000000000"b3),             /* if host-host ctl msgs should be trcd */
  2    57           TRACE_PROCESS_INFO  initial ("002000000000"b3),             /* if process control should be trcd    */
  2    58           TRACE_DATA_FLOW     initial ("001000000000"b3),             /* if flow of user data to be traced    */
  2    59 
  2    60           TRACE_NCP_RING      initial ("000400000000"b3),             /* if ncp_ring_ should be traced        */
  2    61           TRACE_NCP_ACCESS    initial ("000200000000"b3),             /* if ncp_access_ should be traced      */
  2    62           TRACE_NCP_DAEMON    initial ("000100000000"b3),             /* if ncp_daemon_ should be traced      */
  2    63           TRACE_NCP_CONTROL   initial ("000040000000"b3),             /* if ncp_control_ should be traced     */
  2    64           TRACE_NCP_TBOP      initial ("000020000000"b3),             /* if ncp_tbop_ should be traced        */
  2    65           TRACE_NCP_IO        initial ("000010000000"b3))             /* if ncp_io_ should be traced          */
  2    66                bit (36) aligned internal static options (constant);
  2    67 
  2    68 /*        end of include file "ncp_constants_dcls.incl.pl1            */
  2    69 
      127 
      128           
  3     2 /*        BEGIN include file ncp_data_dcls.incl.pl1 --                          */
  3     3 
  3     4 /*             This include file contains declarations of structures kept       */
  3     5 /*        in the NCP data base which aren't associated directly with            */
  3     6 /*        Network connections or process control.                               */
  3     7 
  3     8 /*        Originally created by D. M. Wells, Jan., 1976 by altering a           */
  3     9 /*                  previously existing include file.                           */
  3    10      declare
  3    11           1 ncp_dt aligned based,                           /* Information about global state of NCP          */
  3    12              2 ncp_ev_chan fixed binary (71),               /* event channel id of NCP Daemon process         */
  3    13              2 ncp_procid bit (36),                         /* process id of NCP Daemon process               */
  3    14              2 ncp_up fixed binary (2),                     /* -1 crashed, 0 uninit, 1 imp down, 2 up         */
  3    15              2 htbl_size fixed binary (17),                 /* max size of host table in entries              */
  3    16              2 rtbl_size fixed binary (17),                 /* max size of RFC table in entries               */
  3    17              2 stbl_size fixed binary (17),                 /* max size of socket table in entries            */
  3    18              2 size_pad fixed binary (17),
  3    19 
  3    20              2 htbl_gent fixed binary (17),                 /* max host entry used                            */
  3    21              2 rtbl_gent fixed binary (17),                 /* max RFC entry used                             */
  3    22              2 stbl_gent fixed binary (17),                 /* max socket entry used                          */
  3    23              2 gent_pad fixed binary (17),
  3    24 
  3    25              2 htbl_lock bit (36) aligned,                  /* lock for host table                            */
  3    26              2 rtbl_lock bit (36) aligned,                  /* lock for RFC table                             */
  3    27              2 stbl_lock bit (36) aligned,                  /* lock for socket table                          */
  3    28              2 lock_pad bit (36) aligned,
  3    29 
  3    30              2 state_change_reason character (32) unaligned,          /* reason for last state change         */
  3    31 
  3    32              2 ncp_devx fixed binary (12),                  /* IOAM devx of NCP pseudo-device                 */
  3    33              2 ncp_state_changes fixed binary (17),         /* number of times NCP has changed state          */
  3    34              2 spacen1 (14) fixed fixed binary (35),
  3    35 
  3    36              2 host_id fixed binary (32),                   /* network identifier of this Multics System      */
  3    37              2 crash_on_ncp_error bit (1) aligned,          /* on if should crash to trap ncp error */
  3    38              2 imp_state char (8) aligned,
  3    39              2 time_imp_state_changed fixed binary (71),
  3    40              2 time_ncp_state_changed fixed binary (71),
  3    41 
  3    42              2 imp_special_message bit (32),
  3    43              2 imp_state_change_count fixed binary (17),
  3    44              2 spacen3 (3) fixed binary (17),
  3    45              2 ptbl_size fixed binary (17),                 /* number of entries in process table             */
  3    46              2 ptbl_gent fixed binary (17),                 /* index of highest slot in use                   */
  3    47              2 ptbl_lock bit (36) aligned,                  /* lock word for "proc_tb"                        */
  3    48 
  3    49              2 access_dirname character (168) unaligned,              /* dir of access defining segment       */
  3    50              2 access_ename character (32) unaligned;                 /* entry of access defining segment     */
  3    51 
  3    52      declare
  3    53           1 meter_dt aligned based,                         /* various meters kept by the NCP                 */
  3    54              2 prev_user_call_time fixed binary (71),
  3    55              2 prev_daemon_call_time fixed binary (71),
  3    56              2 accu_time_in_ncp fixed binary (71),
  3    57              2 accu_time_since_user_call fixed binary (71),
  3    58 
  3    59              2 nprocs_in_ncp fixed binary (17),
  3    60              2 nprocs_inconsistent bit (1),
  3    61              2 ndaemon_calls fixed binary (17),
  3    62              2 ncalls (5) fixed binary (17),
  3    63 
  3    64              2 net_error_count fixed binary (17),
  3    65              2 ncp_wakeup_count (7) fixed binary (17),
  3    66 
  3    67              2 call_count (0: 31) fixed binary (17),
  3    68 
  3    69              2 ctl_mess_count (0: 15) fixed binary (17),
  3    70 
  3    71              2 tbop_mf_count (48) fixed binary (17),
  3    72 
  3    73              2 eco_time fixed binary (71),
  3    74              2 erp_time fixed binary (71),
  3    75              2 eco_host fixed binary (16),
  3    76              2 erp_host fixed binary (16),
  3    77              2 num_activations fixed binary (30),           /* number of socket activations performed         */
  3    78              2 num_processes fixed binary (30);             /* number of processes using the NCP              */
  3    79 
  3    80 /*        END include file ncp_data_dcls.incl.pl1 --                            */
  3    81 
      128 
      129           
  4     2 /*        BEGIN include file ncp_process_dcls.incl.pl1 --                       */
  4     3 
  4     4 /*             This include file contains declarations of per-process data.     */
  4     5 
  4     6 /*        Originally created by D. M. Wells, Jan, 1976 from a previously        */
  4     7 /*                  existing include file.                                      */
  4     8 
  4     9      declare
  4    10           1 gdt aligned based,                              /* this holds data to/from outside world          */
  4    11              2 init_sw fixed binary (30),                   /* set to 620998 iff initialized properly.        */
  4    12                                                             /* This particular value has  no significance     */
  4    13              2 error_code fixed binary (35),                /* a code returned by internal modules            */
  4    14              2 request_code fixed binary (12),              /* type of request to be performed (input)        */
  4    15              2 ncp_idx bit (36) unaligned,                  /* handle of socket to be manipulated (input)     */
  4    16              2 state fixed binary (6),                      /* state of the socket (output)                   */
  4    17              2 privilege_code fixed binary (2),             /* = 0 unpriv, = 1 priv, = 2 daemon               */
  4    18              2 nbytes fixed binary (24),                    /* number of bytes of data presented (input)      */
  4    19              2 nelemt fixed binary (24),                    /* number of bytes transmitted (output)           */
  4    20 
  4    21              2 areap pointer,                               /* pointer to a supplied area (input)             */
  4    22              2 fsoc bit (64) unaligned,                     /* foreign socket associated with this request    */
  4    23              2 fsoc_pad bit (8) unaligned,
  4    24              2 abort_location label,                        /* label to goto on procedure abort               */
  4    25 
  4    26              2 host_tbl_index fixed binary (17),            /* host_tbl index of foreign host                 */
  4    27              2 proc_id_arg bit (36),                        /* process id argument                            */
  4    28              2 entry_time fixed binary (71),                /* time NCP was entered by this call              */
  4    29              2 entry_type fixed binary (17),                /* 1, 2 daemon; 3 userid; 4 process_rq;           */
  4    30                                                             /* 5 global_chnchn; 6 socket_state; 7 micro       */
  4    31              2 nprocs_sw fixed binary (30),                 /* = 459248 if nprocs cell was properly set       */
  4    32              2 event_chn fixed binary (71),                 /* event_channel argument                         */
  4    33 
  4    34              2 proc_tbp pointer,                            /* pointer to this process's static info block    */
  4    35              2 global_queue aligned,                        /* impdim global queue info struct                */
  4    36                 3 gq_type fixed binary (17),                /* imp_global_state substructure begins here      */
  4    37                 3 gq_imp_state character (8) unaligned,     /* state of our IMP (up, down?)                   */
  4    38                 3 gq_message bit (32) aligned,              /* special message sent by IMP                    */
  4    39 
  4    40                 3 gq_imp_index fixed binary (17),           /* imp_dim index of this link                     */
  4    41                 3 gq_host_id fixed binary (32),             /* host identifier of a foreign host              */
  4    42                 3 gq_link fixed binary (8),                 /* link number of this link                       */
  4    43                 3 gq_status aligned,                        /* of this link returned by imp_global_state      */
  4    44                    4 sba (0 : 17) bit (1) unaligned,        /* status bits from imp dim                       */
  4    45 
  4    46              2 spaceg2 (14) fixed binary (17);
  4    47 
  4    48      declare
  4    49           1 pdt aligned based,                              /* information about each process using NCP       */
  4    50              2 gdtp pointer,                                /* points to this call's global_data base         */
  4    51              2 returnp label,                               /* return label for non-local error goto          */
  4    52 
  4    53              2 multuid character (32) unaligned,            /* process group id                               */
  4    54 
  4    55              2 netuid bit (24),                             /* Network id of this process                     */
  4    56              2 lockid bit (36),                             /* lock id of process,  = ""b iff unassigned      */
  4    57              2 processid bit (36),                          /* process id of this process                     */
  4    58              2 error_recur fixed binary (17),               /* number of ncp error recursions                 */
  4    59              2 global_ev_chn fixed binary (71),             /* this process gets changes of NCP state         */
  4    60              2 num_activations fixed binary (17),
  4    61              2 proc_devx fixed binary (12),
  4    62              2 spacep2 (2) fixed binary (17);
  4    63 
  4    64      declare
  4    65           1 error_snapshot aligned based,                   /* snapshot of process info for an NCP error      */
  4    66              2 ewho character (32) unaligned,               /* process group id of detecting process          */
  4    67              2 econdition character (32) unaligned,         /* condition signalled                            */
  4    68 
  4    69              2 etime fixed binary (71),                     /* time of error                                  */
  4    70              2 error_number fixed binary (17),
  4    71              2 spacee1 (5) fixed binary (17),
  4    72 
  4    73              2 mc_cond (32) bit (36) aligned,               /* machine conditions                             */
  4    74              2 if_data (8) fixed binary (17),               /* space for software supplied data               */
  4    75              2 proc_slot aligned like pdt,                  /* copy of proc_tbl entry for this process        */
  4    76              2 gdt_data aligned like gdt,                   /* copy of ncp_global_data at time of error       */
  4    77              2 associated_data (24) bit (36) aligned;       /* add'l info -- usually copy of socket entry     */
  4    78 
  4    79 /*        END include file ncp_process_dcls.incl.pl1 --                         */
  4    80 
      129 
      130           
  5     2 /*        BEGIN include file ncp_status_dcls.incl.pl1 --                        */
  5     3 
  5     4 /*             This include file contains declarations of structures filled     */
  5     5 /*	in by the NCP, but which are not strictly kept within the NCP.	*/
  5     6 
  5     7 /*        Originally created by D. M. Wells, Feb. 1976, by altering a           */
  5     8 /*                  previously existing include file.                           */
  5     9 
  5    10      declare
  5    11           1 network_status aligned based,         /* structure filled in by ncp_network_status                */
  5    12              2 imp_state character (8) unaligned,           /* state returned by imp dim                      */
  5    13              2 time_imp_state_changed fixed binary (71),    /* as recorded by network_daemon                  */
  5    14              2 imp_state_change_count fixed binary (17),    /* maintained by network_daemon                   */
  5    15              2 imp_special_message bit (32) aligned,        /* returned by IMP                                */
  5    16              2 time_ncp_state_changed fixed binary (71),    /* time it went up or down                        */
  5    17              2 ncp_state fixed binary (3),                  /* crashed, down, imp_down, up                    */
  5    18              2 network_error_count fixed binary (17),       /* num times default handler invoked              */
  5    19              2 local_host_id fixed binary (32);             /* identifier of our host                         */
  5    20 
  5    21 /*        END include file ncp_status_dcls.incl.pl1 --                          */
  5    22 
      130 
      131 
      132 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      133 
      134 ncp_network_status:
      135           entry (P_ncp_state, P_info_ptr, P_error_code);
      136 
      137 /* Returns concise info on current network state to any caller */
      138 
      139           P_error_code = 0;
      140           npr = addr (ncp_tables_$ncp_data);
      141           mpr = addr (ncp_tables_$meter_cells);
      142           P_ncp_state = npr -> ncp_dt.ncp_up;
      143           if P_info_ptr ^= null ()
      144           then do;                                          /* user wants more information                    */
      145                P_info_ptr -> network_status.imp_state = npr -> ncp_dt.imp_state;
      146                P_info_ptr -> network_status.time_imp_state_changed = npr -> ncp_dt.time_imp_state_changed;
      147                P_info_ptr -> network_status.imp_state_change_count = npr -> ncp_dt.imp_state_change_count;
      148                P_info_ptr -> network_status.imp_special_message = npr -> ncp_dt.imp_special_message;
      149                P_info_ptr -> network_status.time_ncp_state_changed = npr -> ncp_dt.time_ncp_state_changed;
      150                P_info_ptr -> network_status.ncp_state = npr -> ncp_dt.ncp_up;
      151                P_info_ptr -> network_status.network_error_count = mpr -> meter_dt.net_error_count;
      152                P_info_ptr -> network_status.local_host_id = npr -> ncp_dt.host_id;
      153                end;
      154 
      155           return;
      156 
      157           /* * * * * * * * * * * * * * * * * * * * */
      158 
      159 ncp_status:
      160           entry (P_user_request, P_first_offset, P_space_ptr, P_space_size, P_error_code);
      161 
      162           privilege = ""b;                                  /* This is the unprivileged user entry */
      163           goto status_common;
      164 
      165 
      166 ncp_priv_status:
      167           entry (P_user_request, P_first_offset, P_space_ptr, P_space_size, P_error_code);
      168 
      169           privilege = "1"b;                                 /* This entry is called through the privileged gate */
      170 
      171 status_common:
      172           P_error_code = 0;
      173 
      174           RQ = P_user_request;
      175           space_ptr = P_space_ptr;
      176           space_size = P_space_size;
      177           first_offset = P_first_offset;
      178 
      179           if first_offset < 0
      180           then do;
      181                P_error_code = error_table_$action_not_performed;
      182                return;
      183                end;
      184 
      185           if first_offset = 0
      186           then table_start = 1;                             /* user uses zero to get start of table           */
      187           else table_start = first_offset;
      188 
      189                                                   /* Although not all functions use array_ptr and array_indx, */
      190                                                   /* we will set them up here because it can be done safely   */
      191                                                   /* and it saves space and complication at those entry points.         */
      192           array_ptr = addrel (space_ptr, size (info_struc));
      193           array_size = space_size - size (info_struc);
      194           array_indx = 0;                                   /* initialize this to element before first in array         */
      195 
      196           if size (info_struc) > space_size
      197           then do;                                          /* Currently all entries require at least thi size          */
      198                P_error_code = error_table_$action_not_performed;
      199                return;
      200                end;
      201 
      202           npr = addr (ncp_tables_$ncp_data);
      203 
      204           if (RQ >= lbound (process_request, 1)) & (RQ <= hbound (process_request, 1))
      205           then goto process_request (RQ);
      206 
      207           if (RQ >= lbound (proc_copy_rq, 1)) & (RQ <= hbound (proc_copy_rq, 1))
      208           then goto proc_copy_rq (RQ);
      209 
      210           P_error_code = error_table_$undefined_order_request;
      211 
      212           return;
      213 
      214           /* * * * * * * * * * * * * * * * * * * * * * * * */
      215 
      216 process_request (1):                                        /* get NCP data                                   */
      217           if size (ncp_dt) > space_size
      218           then do;
      219                P_error_code = error_table_$action_not_performed;
      220                return;
      221                end;
      222 
      223           unspec (space_ptr -> ncp_dt) = unspec (npr -> ncp_dt);      /* give user copy of the NCP info       */
      224 
      225           return;
      226 
      227                     /* * * * * * * * * * * * * * * * * * * */
      228 
      229 process_request (2):                                        /* get metering data                              */
      230           if size (meter_dt) > space_size
      231           then do;
      232                P_error_code = error_table_$action_not_performed;
      233                return;
      234                end;
      235 
      236           unspec (space_ptr -> meter_dt) = unspec (addr (ncp_tables_$meter_cells) -> meter_dt);
      237 
      238           return;
      239 
      240                     /* * * * * * * * * * * * * * * * * * * */
      241 
      242 process_request (3):                                        /* get host table                                 */
      243           hpr = addr (ncp_tables_$host_tbl);
      244 
      245           space_ptr -> info_struc.it (1).offset = size (info_struc);
      246 
      247           do table_indx = table_start by 1 to npr -> ncp_dt.htbl_gent;
      248                if hpr -> host_array (table_indx).host_state ^= bit (binary (HOST_OFF, 6))
      249                then do;                                     /* found a host slot that is being used           */
      250                     if (array_indx + 1) * (size (host) + 1) > array_size
      251                     then do;
      252                          call store_indx_list (addr (array_ptr -> host_array (array_indx + 1)), array_indx);
      253                          P_error_code = error_table_$area_too_small;
      254                          return;
      255                          end;
      256 
      257                     array_indx = array_indx + 1;
      258                     offset_list (array_indx) = table_indx;
      259                     unspec (host_copy) = unspec (hpr -> host_array (table_indx));
      260                     unspec (array_ptr -> host_array (array_indx)) = unspec (host_copy);
      261                     end;
      262                end;
      263 
      264           call store_indx_list (addr (array_ptr -> host_array (array_indx + 1)), array_indx);
      265 
      266           return;
      267 
      268                     /* * * * * * * * * * * * * * * * * * */
      269 
      270 process_request (4):                                        /* get RFC table                                  */
      271           if ^ privilege
      272           then do;
      273                P_error_code = error_table_$bad_processid;
      274                return;
      275                end;
      276 
      277           rpr = addr (ncp_tables_$rfc_tbl);
      278 
      279           space_ptr -> info_struc.it (1).offset = size (info_struc);
      280 
      281           do table_indx = table_start by 1 to npr -> ncp_dt.rtbl_gent;
      282                if rpr -> rfc_array (table_indx).foreign_hosts_choice ^= 0
      283                then do;
      284                     if (array_indx + 1) * (size (rcvd_rfc) + 1) > array_size
      285                     then do;
      286                          call store_indx_list (addr (array_ptr -> rfc_array (array_indx + 1)), array_indx);
      287                          P_error_code = error_table_$area_too_small;
      288                          return;
      289                          end;
      290 
      291                     array_indx = array_indx + 1;
      292                     offset_list (array_indx) = table_indx;
      293                     unspec (array_ptr -> rfc_array (array_indx)) = unspec (rpr -> rfc_array (table_indx));
      294                     end;
      295                end;
      296 
      297           call store_indx_list (addr (array_ptr -> rfc_array (array_indx + 1)), array_indx);
      298 
      299           return;
      300 
      301                     /* * * * * * * * * * * * * * * * * * * */
      302 
      303 process_request (5):                                        /* get socket table                               */
      304           proc_id = pds$process_id;
      305           spr = addr (ncp_tables_$socket_tbl);
      306 
      307           space_ptr -> info_struc.it (1).offset = size (info_struc);
      308 
      309           do table_indx = table_start by 1 to npr -> ncp_dt.stbl_gent;
      310                sep = addr (spr -> socket_array (table_indx));
      311                if sep -> socket.state ^= bit (binary (SOCK_UNASSIGNED, 6))
      312                then do;
      313                     if (privilege) | (sep -> socket.overseer_process_id = proc_id) |(sep -> socket.process_id = proc_id)
      314                     then do;
      315                          if (array_indx + 1) * (size (socket) + 1) > array_size
      316                          then do;
      317                               call store_indx_list (addr (array_ptr -> socket_array (array_indx + 1)), array_indx);
      318                               P_error_code = error_table_$area_too_small;
      319                               return;
      320                               end;
      321 
      322                          call update_socket_allocations ();
      323 
      324                          array_indx = array_indx + 1;
      325                          offset_list (array_indx) = table_indx;
      326                          unspec (array_ptr -> socket_array (array_indx)) = unspec (sep -> socket);
      327                          end;
      328                     end;
      329                end;
      330 
      331           call store_indx_list (addr (array_ptr -> socket_array (array_indx + 1)), array_indx);
      332 
      333           return;
      334 
      335                     /* * * * * * * * * * * * * * * * * * * */
      336 
      337 process_request (6):                                        /* get socket data                                */
      338           if size (socket) > array_size
      339           then do;
      340                P_error_code = error_table_$action_not_performed;
      341                return;
      342                end;
      343 
      344           proc_id = pds$process_id;
      345 
      346           table_indx = first_offset;                         /* this is different than arrays        */
      347 
      348           if (table_indx <= 0) | (table_indx > npr -> ncp_dt.stbl_gent)
      349           then do;
      350                P_error_code = error_table_$bad_index;
      351                return;
      352                end;
      353 
      354           spr = addr (ncp_tables_$socket_tbl);
      355           sep = addr (spr -> socket_array (table_indx));                /* get pointer to socket table entry */
      356 
      357           if sep -> socket.state = bit (binary (SOCK_UNASSIGNED, 6))
      358           then do;
      359                P_error_code = error_table_$bad_index;
      360                return;
      361                end;
      362 
      363           if ^ privilege
      364           then do;                                          /* no privilege, must check process ids           */
      365                if (sep -> socket.process_id ^= proc_id) & (sep -> socket.overseer_process_id ^= proc_id)
      366                then do;
      367                     P_error_code = error_table_$bad_processid;
      368                     return;
      369                     end;
      370                end;
      371 
      372           call update_socket_allocations ();
      373 
      374           space_ptr -> info_struc.it (1).space_size = 1;
      375           space_ptr -> info_struc.it (1).offset = size (info_struc);
      376 
      377           unspec (array_ptr -> socket) = unspec (sep -> socket);
      378 
      379           space_ptr -> info_struc.it (2).offset = size (info_struc) + size (socket);
      380           array_ptr = addrel (space_ptr, size (info_struc) + size (socket));
      381                                                             /* the array for this one starts farther down     */
      382 
      383           rpr = addr (ncp_tables_$rfc_tbl);
      384 
      385           do next_rfc = sep -> socket.rfc_queue repeat (rpr -> rfc_array (next_rfc).next_entry)
      386                     while (next_rfc ^= 0);
      387                if (array_indx + 1) * size (rcvd_rfc) + size (socket) > array_size
      388                then do;
      389                     space_ptr -> info_struc.it (2).space_size = array_indx;
      390                     P_error_code = error_table_$area_too_small;
      391                     return;
      392                     end;
      393 
      394                array_indx = array_indx + 1;
      395                unspec (array_ptr -> rfc_array (array_indx)) = unspec (rpr -> rfc_array (next_rfc));
      396                end;
      397 
      398           space_ptr -> info_struc.it (2).space_size = array_indx;
      399 
      400           return;
      401 
      402                     /* * * * * * * * * * * * * * * * * * * */
      403 
      404 process_request (7):                                        /* get error table                                */
      405           mpr = addr (ncp_tables_$meter_cells);
      406           epr = addr (ncp_tables_$error_tbl);
      407 
      408           space_ptr -> info_struc.it (1).offset = size (info_struc);
      409           space_ptr -> info_struc.it (1).space_size = 1;
      410 
      411           do table_indx = table_start by 1 to min (mpr -> meter_dt.net_error_count, 8);
      412                if (array_indx + 1) * (size (error_snapshot) + 1) > array_size
      413                then do;
      414                     call store_indx_list (addr (array_ptr -> error_array (array_indx + 1)), array_indx);
      415                     P_error_code = error_table_$area_too_small;
      416                     return;
      417                     end;
      418 
      419                array_indx = array_indx + 1;
      420                offset_list (array_indx) = table_indx;
      421                unspec (array_ptr -> error_array (array_indx)) = unspec (epr -> error_array (table_indx));
      422                end;
      423 
      424           call store_indx_list (addr (array_ptr -> error_array (array_indx + 1)), array_indx);
      425 
      426           return;
      427 
      428                     /* * * * * * * * * * * * * * * * * * * */
      429 
      430 process_request (8):                              /* get host entry                                           */
      431           if size (host) > space_size
      432           then do;
      433                P_error_code = error_table_$action_not_performed;
      434                return;
      435                end;
      436 
      437           call ncp_util_$find_host_entry ((first_offset), "0"b, host_ptr, err_code);
      438           if err_code ^= 0
      439           then do;
      440                P_error_code = err_code;
      441                return;
      442                end;
      443 
      444           unspec (host_copy) = unspec (host_ptr -> host);
      445           unspec (space_ptr -> host) = unspec (host_copy);
      446 
      447           return;
      448 
      449                     /* * * * * * * * * * * * * * * * * * * */
      450 
      451 process_request (9):                              /* get process table                                        */
      452           P_error_code = error_table_$action_not_performed; /* not yet implmeneted        */
      453 
      454           return;
      455 
      456                     /* * * * * * * * * * * * * * * * * * * */
      457 
      458 /* REQUESTS 20 - 28 */
      459 /* for the copy_data P_user_requests, the following arguments have special meanings:
      460*   P_first_offset - specifies offset from indicated table start
      461*   P_space_ptr - points to the buffer into which the data are to be copied.
      462*   P_space_size - specifies the number of words to be copied.  */
      463 
      464 proc_copy_rq (20):                                          /* copy ncp_tables_                               */
      465           table_ptr = pointer (addr (ncp_tables_$ncp_data), ""b);
      466           goto copy_rq_common;
      467 
      468 proc_copy_rq (21):                                          /* copy ncp data                                  */
      469           table_ptr = addr (ncp_tables_$ncp_data);
      470           goto copy_rq_common;
      471 
      472 proc_copy_rq (22):                                          /* copy meter cells                               */
      473           table_ptr = addr (ncp_tables_$meter_cells);
      474           goto copy_rq_common;
      475 
      476 proc_copy_rq (23):                                          /* copy process table                             */
      477           table_ptr = addr (ncp_tables_$proc_tbl);
      478           goto copy_rq_common;
      479 
      480 proc_copy_rq (24):                                          /* copy lock table                                */
      481           table_ptr = addr (ncp_tables_$lock_tbl);
      482           goto copy_rq_common;
      483 
      484 proc_copy_rq (25):                                          /* copy host table                                */
      485           table_ptr = addr (ncp_tables_$host_tbl);
      486           goto copy_rq_common;
      487 
      488 proc_copy_rq (26):                                          /* copy RFC table                                 */
      489           table_ptr = addr (ncp_tables_$rfc_tbl);
      490           goto copy_rq_common;
      491 
      492 proc_copy_rq (27):                                          /* copy socket table                              */
      493           table_ptr = addr (ncp_tables_$socket_tbl);
      494           goto copy_rq_common;
      495 
      496 copy_rq_common:
      497           if ^ privilege
      498           then do;
      499                P_error_code = error_table_$bad_processid;
      500                return;
      501                end;
      502 
      503           copy_size = P_space_size;
      504           space_ptr = addrel (space_ptr, first_offset);
      505           space_ptr -> based_indx_list = table_ptr -> based_indx_list;
      506 
      507           P_error_code = 0;
      508 
      509           return;
      510 
      511 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      512 
      513 store_indx_list:
      514           procedure (p_indx_ptr, p_indx_size);
      515 
      516           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
      517 
      518      declare
      519          (p_indx_size fixed binary (17),
      520           p_indx_ptr pointer)
      521                parameter;
      522 
      523           /* * * * * * * * * * * * * * * * * * * * * * * * */
      524 
      525           space_ptr -> info_struc.it (2).offset = binary (rel (p_indx_ptr), 18) - binary (rel (space_ptr), 18);
      526 
      527           copy_size = p_indx_size;
      528           p_indx_ptr -> based_indx_list = addr (offset_list) -> based_indx_list;
      529 
      530           space_ptr -> info_struc.it (1).space_size = p_indx_size;
      531           space_ptr -> info_struc.it (2).space_size = p_indx_size;
      532 
      533           return;
      534 
      535 end;      /* end store_indx_list                            */
      536 
      537 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      538 
      539 update_socket_allocations:
      540           procedure ();
      541 
      542           /* * * * * * * * * * * * * * * * * * * * * * * * */
      543 
      544           if ^ sep -> socket.send_gender
      545           then return;                            /* this is a read socket, we know its allocation          */
      546 
      547           call imp_write_order ((sep -> socket.impdim_index), GET_ALLOCATION_DATA, addr (impdim_alloc_struc), (18)"0"b, err_code);
      548           if err_code ^= 0
      549           then return;                            /* IMP DIM wont tell us this, give up   */
      550 
      551           sep -> socket.bit_allocation = impdim_alloc_struc.bit_allocation;
      552           sep -> socket.msg_allocation = impdim_alloc_struc.msg_allocation;
      553 
      554           return;
      555 
      556 end;      /* end update_socket_allocations                  */
      557 
      558 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      559 
      560           /* end ncp_status_                                */
      561 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1129.5  ncp_status_.pl1                   >dumps>old_dumps>hardcore>ncp_status_.pl1
126          1    09/05/79  2206.3  ncp_connection_dcls.incl.pl1      >ldd>include>ncp_connection_dcls.incl.pl1
127          2    10/07/77  1700.0  ncp_constants_dcls.incl.pl1       >ldd>include>ncp_constants_dcls.incl.pl1
128          3    07/24/78  1704.7  ncp_data_dcls.incl.pl1            >ldd>include>ncp_data_dcls.incl.pl1
129          4    07/24/78  1704.7  ncp_process_dcls.incl.pl1         >ldd>include>ncp_process_dcls.incl.pl1
130          5    07/24/78  1704.7  ncp_status_dcls.incl.pl1          >ldd>include>ncp_status_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
GET_ALLOCATION_DATA             000021 constant        fixed bin(12,0)          initial dcl 67 set ref 547*
HOST_OFF                               constant        fixed bin(6,0)           initial dcl 2-20 ref 248
P_error_code                           parameter       fixed bin(35,0)          dcl 33 set ref 134 139* 159 166 171* 181* 198* 210*
                                                                                  219* 232* 253* 273* 287* 318* 340* 350* 359* 367*
                                                                                  390* 415* 433* 440* 451* 499* 507*
P_first_offset                         parameter       fixed bin(18,0)          dcl 33 ref 159 166 177
P_info_ptr                             parameter       pointer                  dcl 33 ref 134 143 145 146 147 148 149 150 151 152
P_ncp_state                            parameter       fixed bin(17,0)          dcl 33 set ref 134 142*
P_space_ptr                            parameter       pointer                  dcl 33 ref 159 166 175
P_space_size                           parameter       fixed bin(19,0)          dcl 33 ref 159 166 176 503
P_user_request                         parameter       fixed bin(12,0)          dcl 33 ref 159 166 174
RQ                              000102 automatic       fixed bin(17,0)          dcl 45 set ref 174* 204 204 204 207 207 207
SOCK_UNASSIGNED                        constant        fixed bin(6,0)           initial dcl 2-28 ref 311 357
addr                                                   builtin function         dcl 120 ref 140 141 202 236 242 252 252 264 264 277
                                                                                  286 286 297 297 305 310 317 317 331 331 354 355
                                                                                  383 404 406 414 414 424 424 464 468 472 476 480
                                                                                  484 488 492 528 547 547
addrel                                                 builtin function         dcl 120 ref 192 380 504
array_indx                      000100 automatic       fixed bin(17,0)          dcl 45 set ref 194* 250 252 252 252* 257* 257 258
                                                                                  260 264 264 264* 284 286 286 286* 291* 291 292 293
                                                                                  297 297 297* 315 317 317 317* 324* 324 325 326 331
                                                                                  331 331* 387 389 394* 394 395 398 412 414 414 414*
                                                                                  419* 419 420 421 424 424 424*
array_ptr                       002114 automatic       pointer                  dcl 45 set ref 192* 252 252 260 264 264 286 286 293
                                                                                  297 297 317 317 326 331 331 377 380* 395 414 414
                                                                                  421 424 424
array_size                      002106 automatic       fixed bin(19,0)          dcl 45 set ref 193* 250 284 315 337 387 412
based_indx_list                        based           bit(36)                  array dcl 73 set ref 505* 505 528* 528
binary                                                 builtin function         dcl 120 ref 248 311 357 525 525
bit                                                    builtin function         dcl 120 ref 248 311 357
bit_allocation            7            based           fixed bin(32,0)          level 2 in structure "socket" dcl 1-13 in procedure
                                                                                  "ncp_status_" set ref 551*
bit_allocation                  002154 automatic       fixed bin(16,0)          level 2 in structure "impdim_alloc_struc" dcl 60
                                                                                  in procedure "ncp_status_" set ref 551
copy_size                       002107 automatic       fixed bin(19,0)          dcl 45 set ref 503* 505 527* 528
epr                             002124 automatic       pointer                  dcl 45 set ref 406* 421
err_code                        002111 automatic       fixed bin(35,0)          dcl 45 set ref 437* 438 440 547* 548
error_array                            based           structure                array level 1 dcl 77 set ref 414 414 421* 421 424
                                                                                  424
error_snapshot                         based           structure                level 1 dcl 4-64 ref 412
error_table_$action_not_performed
                                000032 external static fixed bin(35,0)          dcl 106 ref 181 198 219 232 340 433 451
error_table_$area_too_small     000034 external static fixed bin(35,0)          dcl 106 ref 253 287 318 390 415
error_table_$bad_index          000036 external static fixed bin(35,0)          dcl 106 ref 350 359
error_table_$bad_processid      000040 external static fixed bin(35,0)          dcl 106 ref 273 367 499
error_table_$undefined_order_request
                                000042 external static fixed bin(35,0)          dcl 106 ref 210
first_offset                    000104 automatic       fixed bin(17,0)          dcl 45 set ref 177* 179 185 187 346 437 504
foreign_hosts_choice      2            based           fixed bin(17,0)          array level 2 packed unaligned dcl 77 set ref 282
foreign_socket           13            based           structure                level 2 in structure "socket" packed unaligned
                                                                                  dcl 1-13 in procedure "ncp_status_"
foreign_socket           13            based           structure                array level 2 in structure "socket_array" packed
                                                                                  unaligned dcl 77 in procedure "ncp_status_"
gdt                                    based           structure                level 1 dcl 4-9
hbound                                                 builtin function         dcl 120 ref 204 207
host                                   based           structure                level 1 dcl 1-61 set ref 250 430 444 445*
host_array                             based           structure                array level 1 dcl 77 set ref 252 252 259 260* 264
                                                                                  264
host_copy                       002142 automatic       structure                level 1 dcl 57 set ref 259* 260 444* 445
host_id                  50            based           fixed bin(32,0)          level 2 dcl 3-10 set ref 152
host_ptr                        002116 automatic       pointer                  dcl 45 set ref 437* 444
host_state                3(09)        based           bit(6)                   array level 2 packed unaligned dcl 77 set ref 248
hpr                             002126 automatic       pointer                  dcl 45 set ref 242* 248 259
htbl_gent                10            based           fixed bin(17,0)          level 2 dcl 3-10 set ref 247
imp_special_message       5            based           bit(32)                  level 2 in structure "network_status" dcl 5-10
                                                                                  in procedure "ncp_status_" set ref 148*
imp_special_message      60            based           bit(32)                  level 2 in structure "ncp_dt" dcl 3-10 in procedure
                                                                                  "ncp_status_" set ref 148
imp_state                              based           char(8)                  level 2 in structure "network_status" packed
                                                                                  unaligned dcl 5-10 in procedure "ncp_status_" set
                                                                                  ref 145*
imp_state                52            based           char(8)                  level 2 in structure "ncp_dt" dcl 3-10 in procedure
                                                                                  "ncp_status_" set ref 145
imp_state_change_count
                          4            based           fixed bin(17,0)          level 2 in structure "network_status" dcl 5-10
                                                                                  in procedure "ncp_status_" set ref 147*
imp_state_change_count
                         61            based           fixed bin(17,0)          level 2 in structure "ncp_dt" dcl 3-10 in procedure
                                                                                  "ncp_status_" set ref 147
imp_write_order                 000044 constant        entry                    external dcl 116 ref 547
impdim_alloc_struc              002154 automatic       structure                level 1 dcl 60 set ref 547 547
impdim_index             16(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-13 set ref 547
info_struc                             based           structure                level 1 dcl 83 set ref 192 193 196 245 279 307 375
                                                                                  379 380 408
it                                     based           structure                array level 2 dcl 83
lbound                                                 builtin function         dcl 120 ref 204 207
local_host_id            12            based           fixed bin(32,0)          level 2 dcl 5-10 set ref 152*
meter_dt                               based           structure                level 1 dcl 3-52 set ref 229 236* 236
mpr                             002130 automatic       pointer                  dcl 45 set ref 141* 151 404* 411
msg_allocation           10            based           fixed bin(16,0)          level 2 in structure "socket" dcl 1-13 in procedure
                                                                                  "ncp_status_" set ref 552*
msg_allocation            1     002154 automatic       fixed bin(32,0)          level 2 in structure "impdim_alloc_struc" dcl 60
                                                                                  in procedure "ncp_status_" set ref 552
ncp_dt                                 based           structure                level 1 dcl 3-10 set ref 216 223* 223
ncp_state                10            based           fixed bin(3,0)           level 2 dcl 5-10 set ref 150*
ncp_tables_$error_tbl           000012 external static fixed bin(17,0)          dcl 95 set ref 406
ncp_tables_$host_tbl            000014 external static fixed bin(17,0)          dcl 95 set ref 242 484
ncp_tables_$lock_tbl            000016 external static fixed bin(17,0)          dcl 95 set ref 480
ncp_tables_$meter_cells         000020 external static fixed bin(17,0)          dcl 95 set ref 141 236 404 472
ncp_tables_$ncp_data            000022 external static fixed bin(17,0)          dcl 95 set ref 140 202 464 468
ncp_tables_$proc_tbl            000024 external static fixed bin(17,0)          dcl 95 set ref 476
ncp_tables_$rfc_tbl             000026 external static fixed bin(17,0)          dcl 95 set ref 277 383 488
ncp_tables_$socket_tbl          000030 external static fixed bin(17,0)          dcl 95 set ref 305 354 492
ncp_up                    3            based           fixed bin(2,0)           level 2 dcl 3-10 set ref 142 150
ncp_util_$find_host_entry       000046 constant        entry                    external dcl 116 ref 437
net_error_count          20            based           fixed bin(17,0)          level 2 dcl 3-52 set ref 151 411
network_error_count      11            based           fixed bin(17,0)          level 2 dcl 5-10 set ref 151*
network_status                         based           structure                level 1 dcl 5-10
next_entry                2(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 77 set ref 396
next_rfc                        000101 automatic       fixed bin(17,0)          dcl 45 set ref 385* 385* 395* 396
npr                             002132 automatic       pointer                  dcl 45 set ref 140* 142 145 146 147 148 149 150 152
                                                                                  202* 223 247 281 309 348
null                                                   builtin function         dcl 120 ref 143
offset                                 based           fixed bin(17,0)          array level 3 dcl 83 set ref 245* 279* 307* 375*
                                                                                  379* 408* 525*
offset_list                     000106 automatic       fixed bin(17,0)          array dcl 45 set ref 258* 292* 325* 420* 528
overseer_process_id       6            based           bit(36)                  level 2 dcl 1-13 set ref 313 365
p_indx_ptr                             parameter       pointer                  dcl 518 ref 513 525 528
p_indx_size                            parameter       fixed bin(17,0)          dcl 518 ref 513 527 530 531
pds$process_id                  000010 external static bit(36)                  dcl 91 ref 303 344
pdt                                    based           structure                level 1 dcl 4-48
pointer                                                builtin function         dcl 120 ref 464
privilege                       002112 automatic       bit(1)                   unaligned dcl 45 set ref 162* 169* 270 313 363 496
proc_id                         002113 automatic       bit(36)                  dcl 45 set ref 303* 313 313 344* 365 365
process_id                5            based           bit(36)                  level 2 dcl 1-13 set ref 313 365
rcvd_rfc                               based           structure                level 1 dcl 1-80 ref 284 387
rel                                                    builtin function         dcl 120 ref 525 525
rfc_array                              based           structure                array level 1 dcl 77 set ref 286 286 293* 293 297
                                                                                  297 395* 395
rfc_queue                15            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-13 set ref 385
rpr                             002134 automatic       pointer                  dcl 45 set ref 277* 282 293 383* 395 396
rtbl_gent                11            based           fixed bin(17,0)          level 2 dcl 3-10 set ref 281
send_gender              17(14)        based           bit(1)                   level 2 packed unaligned dcl 1-13 set ref 544
sep                             002136 automatic       pointer                  dcl 45 set ref 310* 311 313 313 326 355* 357 365 365
                                                                                  377 385 544 547 551 552
size                                                   builtin function         dcl 120 ref 192 193 196 216 229 245 250 279 284 307
                                                                                  315 337 375 379 379 380 380 387 387 408 412 430
socket                                 based           structure                level 1 dcl 1-13 set ref 315 326 337 377* 377 379
                                                                                  380 387
socket_array                           based           structure                array level 1 dcl 77 set ref 310 317 317 326* 331
                                                                                  331 355
space_ptr                       002120 automatic       pointer                  dcl 45 set ref 175* 192 223 236 245 279 307 374 375
                                                                                  379 380 389 398 408 409 445 504* 504 505 525 525
                                                                                  530 531
space_size                      002110 automatic       fixed bin(19,0)          dcl 45 in procedure "ncp_status_" set ref 176* 193
                                                                                  196 216 229 430
space_size                1            based           fixed bin(19,0)          array level 3 in structure "info_struc" dcl 83
                                                                                  in procedure "ncp_status_" set ref 374* 389* 398*
                                                                                  409* 530* 531*
spr                             002140 automatic       pointer                  dcl 45 set ref 305* 310 354* 355
state                    17            based           bit(6)                   level 2 packed unaligned dcl 1-13 set ref 311 357
stbl_gent                12            based           fixed bin(17,0)          level 2 dcl 3-10 set ref 309 348
table_indx                      000103 automatic       fixed bin(17,0)          dcl 45 set ref 247* 248 258 259* 281* 282 292 293*
                                                                                  309* 310 325* 346* 348 348 355 411* 420 421*
table_ptr                       002122 automatic       pointer                  dcl 45 set ref 464* 468* 472* 476* 480* 484* 488*
                                                                                  492* 505
table_start                     000105 automatic       fixed bin(17,0)          dcl 45 set ref 185* 187* 247 281 309 411
time_imp_state_changed
                          2            based           fixed bin(71,0)          level 2 in structure "network_status" dcl 5-10
                                                                                  in procedure "ncp_status_" set ref 146*
time_imp_state_changed
                         54            based           fixed bin(71,0)          level 2 in structure "ncp_dt" dcl 3-10 in procedure
                                                                                  "ncp_status_" set ref 146
time_ncp_state_changed
                          6            based           fixed bin(71,0)          level 2 in structure "network_status" dcl 5-10
                                                                                  in procedure "ncp_status_" set ref 149*
time_ncp_state_changed
                         56            based           fixed bin(71,0)          level 2 in structure "ncp_dt" dcl 3-10 in procedure
                                                                                  "ncp_status_" set ref 149
unspec                                                 builtin function         dcl 120 set ref 223* 223 236* 236 259* 259 260* 260
                                                                                  293* 293 326* 326 377* 377 395* 395 421* 421 444*
                                                                                  444 445* 445

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_TRACING                            internal static bit(36)                  initial dcl 2-51
HOST_DOWN                              internal static fixed bin(6,0)           initial dcl 2-20
HOST_ON                                internal static fixed bin(6,0)           initial dcl 2-20
HOST_RST                               internal static fixed bin(6,0)           initial dcl 2-20
HOST_UP                                internal static fixed bin(6,0)           initial dcl 2-20
NCP_CRASHED                            internal static fixed bin(3,0)           initial dcl 2-8
NCP_DOWN                               internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP                                 internal static fixed bin(3,0)           initial dcl 2-8
NCP_UP_IMP_DOWN                        internal static fixed bin(3,0)           initial dcl 2-8
PRINTER_TRACING                        internal static bit(36)                  initial dcl 2-51
READ_GENDER                            internal static bit(1)                   initial unaligned dcl 2-15
SOCK_ASSIGNED                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_BROKEN                            internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CLS_READ                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CLS_WAIT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_CONNECTED                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_DATA_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_INDX_MASK                         internal static bit(36)                  initial unaligned dcl 2-46
SOCK_LISTENING                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RESET                             internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_ABORTED                       internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_RCVD                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFC_SENT                          internal static fixed bin(6,0)           initial dcl 2-28
SOCK_RFNM_WAIT                         internal static fixed bin(6,0)           initial dcl 2-28
SOCK_UNIQUE_MASK                       internal static bit(36)                  initial unaligned dcl 2-46
SYSERR_LOG_TRACING                     internal static bit(36)                  initial dcl 2-51
TRACE_CTL_MSGS                         internal static bit(36)                  initial dcl 2-51
TRACE_DATA_FLOW                        internal static bit(36)                  initial dcl 2-51
TRACE_NCP_ACCESS                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_CONTROL                      internal static bit(36)                  initial dcl 2-51
TRACE_NCP_DAEMON                       internal static bit(36)                  initial dcl 2-51
TRACE_NCP_IO                           internal static bit(36)                  initial dcl 2-51
TRACE_NCP_RING                         internal static bit(36)                  initial dcl 2-51
TRACE_NCP_TBOP                         internal static bit(36)                  initial dcl 2-51
TRACE_PROCESS_INFO                     internal static bit(36)                  initial dcl 2-51
WRITE_GENDER                           internal static bit(1)                   initial unaligned dcl 2-15
host_address                           based           structure                level 1 dcl 1-87
mod                                                    builtin function         dcl 120

NAMES DECLARED BY EXPLICIT CONTEXT.
copy_rq_common                  001214 constant        label                    dcl 496 ref 466 470 474 478 482 486 490 494
ncp_network_status              000045 constant        entry                    external dcl 134
ncp_priv_status                 000137 constant        entry                    external dcl 166
ncp_status                      000123 constant        entry                    external dcl 159
ncp_status_                     000033 constant        entry                    external dcl 14
proc_copy_rq                    000011 constant        label                    array(20:27) dcl 464 ref 207 207 207
process_request                 000000 constant        label                    array(9) dcl 216 ref 204 204 204
status_common                   000151 constant        label                    dcl 171 ref 163
store_indx_list                 001240 constant        entry                    internal dcl 513 ref 252 264 286 297 317 331 414 424
update_socket_allocations       001266 constant        entry                    internal dcl 539 ref 322 372

NAME DECLARED BY CONTEXT OR IMPLICATION.
min                                                    builtin function         ref 411

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1600        1650    1342        1610
Length      2174    1342        50         307     235           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ncp_status_                        1184 external procedure  is an external procedure.  
store_indx_list                         internal procedure  shares stack frame of external procedure ncp_status_.  
update_socket_allocations               internal procedure  shares stack frame of external procedure ncp_status_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ncp_status_              000100 array_indx                  ncp_status_
                         000101 next_rfc                    ncp_status_
                         000102 RQ                          ncp_status_
                         000103 table_indx                  ncp_status_
                         000104 first_offset                ncp_status_
                         000105 table_start                 ncp_status_
                         000106 offset_list                 ncp_status_
                         002106 array_size                  ncp_status_
                         002107 copy_size                   ncp_status_
                         002110 space_size                  ncp_status_
                         002111 err_code                    ncp_status_
                         002112 privilege                   ncp_status_
                         002113 proc_id                     ncp_status_
                         002114 array_ptr                   ncp_status_
                         002116 host_ptr                    ncp_status_
                         002120 space_ptr                   ncp_status_
                         002122 table_ptr                   ncp_status_
                         002124 epr                         ncp_status_
                         002126 hpr                         ncp_status_
                         002130 mpr                         ncp_status_
                         002132 npr                         ncp_status_
                         002134 rpr                         ncp_status_
                         002136 sep                         ncp_status_
                         002140 spr                         ncp_status_
                         002142 host_copy                   ncp_status_
                         002154 impdim_alloc_struc          ncp_status_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
imp_write_order               ncp_util_$find_host_entry

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$area_too_small   error_table_$bad_index
error_table_$bad_processid    error_table_$undefined_order_request                        ncp_tables_$error_tbl
ncp_tables_$host_tbl          ncp_tables_$lock_tbl          ncp_tables_$meter_cells       ncp_tables_$ncp_data
ncp_tables_$proc_tbl          ncp_tables_$rfc_tbl           ncp_tables_$socket_tbl        pds$process_id


CONSTANTS
001334  aa     000004000000
001335  aa     000000000000
001336  aa     600000000041
001337  aa     002202000000
001340  aa     600000000041
001341  aa     000100000000

000021  aa     000000000021

000022  aa     464000000000

000023  aa     404000000043

000024  aa     404000000023

000025  aa     404000000022

000026  aa     404000000021

000027  aa     404000000014

000030  aa     077777000043
000031  aa     000001000000

LABEL ARRAYS
000000  aa   000235 7100 04	tra  	157,ic		000235
000001  aa   000251 7100 04	tra  	169,ic		000252
000002  aa   000266 7100 04	tra  	182,ic		000270
000003  aa   000374 7100 04	tra  	252,ic		000377
000004  aa   000500 7100 04	tra  	320,ic		000504
000005  aa   000615 7100 04	tra  	397,ic		000622
000006  aa   000773 7100 04	tra  	507,ic		001001
000007  aa   001073 7100 04	tra  	571,ic		001102
000010  aa   001137 7100 04	tra  	607,ic		001147

000011  aa   001142 7100 04	tra  	610,ic		001153
000012  aa   001146 7100 04	tra  	614,ic		001160
000013  aa   001151 7100 04	tra  	617,ic		001164
000014  aa   001154 7100 04	tra  	620,ic		001170
000015  aa   001157 7100 04	tra  	623,ic		001174
000016  aa   001162 7100 04	tra  	626,ic		001200
000017  aa   001165 7100 04	tra  	629,ic		001204
000020  aa   001170 7100 04	tra  	632,ic		001210

BEGIN PROCEDURE ncp_status_
ENTRY TO ncp_status_                                        STATEMENT 1 ON LINE 14
ncp_status_:
          procedure ();

000032  da     000204200000
000033  aa   002240 6270 00	eax7 	1184
000034  aa  7 00034 3521 20	epp2 	pr7|28,*
000035  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000036  aa     000000000000
000037  aa     000000000000
						STATEMENT 1 ON LINE 134
ncp_network_status:
          entry (P_ncp_state, P_info_ptr, P_error_code);

000040  aa   000015 7100 04	tra  	13,ic		000055
ENTRY TO ncp_network_status                                 STATEMENT 1 ON LINE 134
ncp_network_status:
          entry (P_ncp_state, P_info_ptr, P_error_code);

000041  at     000003000026
000042  tt     000022000023
000043  ta     000041000000
000044  da     000214300000
000045  aa   002240 6270 00	eax7 	1184
000046  aa  7 00034 3521 20	epp2 	pr7|28,*
000047  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000050  aa     000006000000
000051  aa     000000000000
000052  aa  6 00032 3735 20	epp7 	pr6|26,*
000053  aa  7 00006 3715 20	epp5 	pr7|6,*
000054  aa  6 02156 6515 00	spri5	pr6|1134
						STATEMENT 1 ON LINE 139
          P_error_code = 0;

000055  aa  6 02156 4501 20	stz  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 140
          npr = addr (ncp_tables_$ncp_data);

000056  la  4 00022 3735 20	epp7 	pr4|18,*		ncp_tables_$ncp_data
000057  aa  6 02132 6535 00	spri7	pr6|1114		npr
						STATEMENT 1 ON LINE 141
          mpr = addr (ncp_tables_$meter_cells);

000060  la  4 00020 3715 20	epp5 	pr4|16,*		ncp_tables_$meter_cells
000061  aa  6 02130 6515 00	spri5	pr6|1112		mpr
						STATEMENT 1 ON LINE 142
          P_ncp_state = npr -> ncp_dt.ncp_up;

000062  aa  7 00003 2361 00	ldq  	pr7|3		ncp_dt.ncp_up
000063  aa  6 00032 3535 20	epp3 	pr6|26,*
000064  aa  3 00002 7561 20	stq  	pr3|2,*		P_ncp_state
						STATEMENT 1 ON LINE 143
          if P_info_ptr ^= null ()
          then do;

000065  aa  3 00004 2371 20	ldaq 	pr3|4,*		P_info_ptr
000066  aa   777742 6770 04	eraq 	-30,ic		000030 = 077777000043 000001000000
000067  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000070  aa   000025 6000 04	tze  	21,ic		000115
						STATEMENT 1 ON LINE 145
               P_info_ptr -> network_status.imp_state = npr -> ncp_dt.imp_state;

000071  aa  7 00052 2351 00	lda  	pr7|42		ncp_dt.imp_state
000072  aa  7 00053 2361 00	ldq  	pr7|43		ncp_dt.imp_state
000073  aa  3 00004 3515 20	epp1 	pr3|4,*		P_info_ptr
000074  aa  1 00000 3515 20	epp1 	pr1|0,*		P_info_ptr
000075  aa  1 00000 7551 00	sta  	pr1|0		network_status.imp_state
000076  aa  1 00001 7561 00	stq  	pr1|1		network_status.imp_state
						STATEMENT 1 ON LINE 146
               P_info_ptr -> network_status.time_imp_state_changed = npr -> ncp_dt.time_imp_state_changed;

000077  aa  7 00054 2371 00	ldaq 	pr7|44		ncp_dt.time_imp_state_changed
000100  aa  1 00002 7571 00	staq 	pr1|2		network_status.time_imp_state_changed
						STATEMENT 1 ON LINE 147
               P_info_ptr -> network_status.imp_state_change_count = npr -> ncp_dt.imp_state_change_count;

000101  aa  7 00061 2361 00	ldq  	pr7|49		ncp_dt.imp_state_change_count
000102  aa  1 00004 7561 00	stq  	pr1|4		network_status.imp_state_change_count
						STATEMENT 1 ON LINE 148
               P_info_ptr -> network_status.imp_special_message = npr -> ncp_dt.imp_special_message;

000103  aa  7 00060 2351 00	lda  	pr7|48		ncp_dt.imp_special_message
000104  aa  1 00005 7551 00	sta  	pr1|5		network_status.imp_special_message
						STATEMENT 1 ON LINE 149
               P_info_ptr -> network_status.time_ncp_state_changed = npr -> ncp_dt.time_ncp_state_changed;

000105  aa  7 00056 2371 00	ldaq 	pr7|46		ncp_dt.time_ncp_state_changed
000106  aa  1 00006 7571 00	staq 	pr1|6		network_status.time_ncp_state_changed
						STATEMENT 1 ON LINE 150
               P_info_ptr -> network_status.ncp_state = npr -> ncp_dt.ncp_up;

000107  aa  7 00003 2361 00	ldq  	pr7|3		ncp_dt.ncp_up
000110  aa  1 00010 7561 00	stq  	pr1|8		network_status.ncp_state
						STATEMENT 1 ON LINE 151
               P_info_ptr -> network_status.network_error_count = mpr -> meter_dt.net_error_count;

000111  aa  5 00020 2361 00	ldq  	pr5|16		meter_dt.net_error_count
000112  aa  1 00011 7561 00	stq  	pr1|9		network_status.network_error_count
						STATEMENT 1 ON LINE 152
               P_info_ptr -> network_status.local_host_id = npr -> ncp_dt.host_id;

000113  aa  7 00050 2361 00	ldq  	pr7|40		ncp_dt.host_id
000114  aa  1 00012 7561 00	stq  	pr1|10		network_status.local_host_id
						STATEMENT 1 ON LINE 153
               end;

						STATEMENT 1 ON LINE 155
          return;

000115  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ncp_status                                         STATEMENT 1 ON LINE 159
ncp_status:
          entry (P_user_request, P_first_offset, P_space_ptr, P_space_size, P_error_code);

000116  at     000005000027
000117  tt     000025000022
000120  tt     000024000023
000121  ta     000116000000
000122  da     000222300000
000123  aa   002240 6270 00	eax7 	1184
000124  aa  7 00034 3521 20	epp2 	pr7|28,*
000125  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000126  aa     000012000000
000127  aa     000000000000
000130  aa  6 00032 3735 20	epp7 	pr6|26,*
000131  aa  7 00012 3715 20	epp5 	pr7|10,*
000132  aa  6 02156 6515 00	spri5	pr6|1134
						STATEMENT 1 ON LINE 162
          privilege = ""b;

000133  aa  6 02112 4501 00	stz  	pr6|1098		privilege
						STATEMENT 1 ON LINE 163
          goto status_common;

000134  aa   000015 7100 04	tra  	13,ic		000151
ENTRY TO ncp_priv_status                                    STATEMENT 1 ON LINE 166
ncp_priv_status:
          entry (P_user_request, P_first_offset, P_space_ptr, P_space_size, P_error_code);

000135  ta     000116000000
000136  da     000231300000
000137  aa   002240 6270 00	eax7 	1184
000140  aa  7 00034 3521 20	epp2 	pr7|28,*
000141  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000142  aa     000012000000
000143  aa     000000000000
000144  aa  6 00032 3735 20	epp7 	pr6|26,*
000145  aa  7 00012 3715 20	epp5 	pr7|10,*
000146  aa  6 02156 6515 00	spri5	pr6|1134
						STATEMENT 1 ON LINE 169
          privilege = "1"b;

000147  aa   400000 2350 03	lda  	131072,du
000150  aa  6 02112 7551 00	sta  	pr6|1098		privilege
						STATEMENT 1 ON LINE 171
status_common:
          P_error_code = 0;

000151  aa  6 02156 4501 20	stz  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 174
          RQ = P_user_request;

000152  aa  6 00032 3735 20	epp7 	pr6|26,*
000153  aa  7 00002 2361 20	ldq  	pr7|2,*		P_user_request
000154  aa  6 00102 7561 00	stq  	pr6|66		RQ
						STATEMENT 1 ON LINE 175
          space_ptr = P_space_ptr;

000155  aa  7 00006 3715 20	epp5 	pr7|6,*		P_space_ptr
000156  aa  5 00000 3715 20	epp5 	pr5|0,*		P_space_ptr
000157  aa  6 02120 6515 00	spri5	pr6|1104		space_ptr
						STATEMENT 1 ON LINE 176
          space_size = P_space_size;

000160  aa  7 00010 2361 20	ldq  	pr7|8,*		P_space_size
000161  aa  6 02110 7561 00	stq  	pr6|1096		space_size
						STATEMENT 1 ON LINE 177
          first_offset = P_first_offset;

000162  aa  7 00004 2361 20	ldq  	pr7|4,*		P_first_offset
000163  aa  6 00104 7561 00	stq  	pr6|68		first_offset
						STATEMENT 1 ON LINE 179
          if first_offset < 0
          then do;

000164  aa   000005 6050 04	tpl  	5,ic		000171
						STATEMENT 1 ON LINE 181
               P_error_code = error_table_$action_not_performed;

000165  aa  6 00044 3701 20	epp4 	pr6|36,*
000166  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
000167  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 182
               return;

000170  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 183
               end;

						STATEMENT 1 ON LINE 185
          if first_offset = 0
          then table_start = 1;

000171  aa   000004 6010 04	tnz  	4,ic		000175
000172  aa   000001 2360 07	ldq  	1,dl
000173  aa  6 00105 7561 00	stq  	pr6|69		table_start
000174  aa   000002 7100 04	tra  	2,ic		000176
						STATEMENT 1 ON LINE 187
          else table_start = first_offset;

000175  aa  6 00105 7561 00	stq  	pr6|69		table_start
						STATEMENT 1 ON LINE 192
          array_ptr = addrel (space_ptr, size (info_struc));

000176  aa  5 00000 3521 00	epp2 	pr5|0
000177  aa   000004 0520 03	adwp2	4,du
000200  aa  6 02114 2521 00	spri2	pr6|1100		array_ptr
						STATEMENT 1 ON LINE 193
          array_size = space_size - size (info_struc);

000201  aa  6 02110 2361 00	ldq  	pr6|1096		space_size
000202  aa   000004 1760 07	sbq  	4,dl
000203  aa  6 02106 7561 00	stq  	pr6|1094		array_size
						STATEMENT 1 ON LINE 194
          array_indx = 0;

000204  aa  6 00100 4501 00	stz  	pr6|64		array_indx
						STATEMENT 1 ON LINE 196
          if size (info_struc) > space_size
          then do;

000205  aa   000004 2360 07	ldq  	4,dl
000206  aa  6 02110 1161 00	cmpq 	pr6|1096		space_size
000207  aa   000005 6044 04	tmoz 	5,ic		000214
						STATEMENT 1 ON LINE 198
               P_error_code = error_table_$action_not_performed;

000210  aa  6 00044 3701 20	epp4 	pr6|36,*
000211  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
000212  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 199
               return;

000213  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 200
               end;

						STATEMENT 1 ON LINE 202
          npr = addr (ncp_tables_$ncp_data);

000214  aa  6 00044 3701 20	epp4 	pr6|36,*
000215  la  4 00022 3535 20	epp3 	pr4|18,*		ncp_tables_$ncp_data
000216  aa  6 02132 2535 00	spri3	pr6|1114		npr
						STATEMENT 1 ON LINE 204
          if (RQ >= lbound (process_request, 1)) & (RQ <= hbound (process_request, 1))
          then goto process_request (RQ);

000217  aa  6 00102 2361 00	ldq  	pr6|66		RQ
000220  aa   000001 1160 07	cmpq 	1,dl
000221  aa   000004 6040 04	tmi  	4,ic		000225
000222  aa   000011 1160 07	cmpq 	9,dl
000223  aa   000002 6054 04	tpnz 	2,ic		000225
000224  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 207
          if (RQ >= lbound (proc_copy_rq, 1)) & (RQ <= hbound (proc_copy_rq, 1))
          then goto proc_copy_rq (RQ);

000225  aa   000024 1160 07	cmpq 	20,dl
000226  aa   000004 6040 04	tmi  	4,ic		000232
000227  aa   000033 1160 07	cmpq 	27,dl
000230  aa   000002 6054 04	tpnz 	2,ic		000232
000231  ta   777765 7100 06	tra  	-11,ql
						STATEMENT 1 ON LINE 210
          P_error_code = error_table_$undefined_order_request;

000232  la  4 00042 2361 20	ldq  	pr4|34,*		error_table_$undefined_order_request
000233  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 212
          return;

000234  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 216
process_request (1):                                        /* get NCP data                                   */
          if size (ncp_dt) > space_size
          then do;

000235  aa   000152 2360 07	ldq  	106,dl
000236  aa  6 02110 1161 00	cmpq 	pr6|1096		space_size
000237  aa   000005 6044 04	tmoz 	5,ic		000244
						STATEMENT 1 ON LINE 219
               P_error_code = error_table_$action_not_performed;

000240  aa  6 00044 3701 20	epp4 	pr6|36,*
000241  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
000242  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 220
               return;

000243  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 221
               end;

						STATEMENT 1 ON LINE 223
          unspec (space_ptr -> ncp_dt) = unspec (npr -> ncp_dt);

000244  aa  6 02120 3735 20	epp7 	pr6|1104,*	space_ptr
000245  aa  6 02132 3715 20	epp5 	pr6|1114,*	npr
000246  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000247  aa  5 00000 00 0650	desc9a	pr5|0,424
000250  aa  7 00000 00 0650	desc9a	pr7|0,424
						STATEMENT 1 ON LINE 225
          return;

000251  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 229
process_request (2):                                        /* get metering data                              */
          if size (meter_dt) > space_size
          then do;

000252  aa   000200 2360 07	ldq  	128,dl
000253  aa  6 02110 1161 00	cmpq 	pr6|1096		space_size
000254  aa   000005 6044 04	tmoz 	5,ic		000261
						STATEMENT 1 ON LINE 232
               P_error_code = error_table_$action_not_performed;

000255  aa  6 00044 3701 20	epp4 	pr6|36,*
000256  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
000257  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 233
               return;

000260  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 234
               end;

						STATEMENT 1 ON LINE 236
          unspec (space_ptr -> meter_dt) = unspec (addr (ncp_tables_$meter_cells) -> meter_dt);

000261  aa  6 02120 3735 20	epp7 	pr6|1104,*	space_ptr
000262  aa  6 00044 3701 20	epp4 	pr6|36,*
000263  la  4 00020 3715 20	epp5 	pr4|16,*
000264  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000265  aa  5 00000 00 1000	desc9a	pr5|0,512
000266  aa  7 00000 00 1000	desc9a	pr7|0,512
						STATEMENT 1 ON LINE 238
          return;

000267  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 242
process_request (3):                                        /* get host table                                 */
          hpr = addr (ncp_tables_$host_tbl);

000270  aa  6 00044 3701 20	epp4 	pr6|36,*
000271  la  4 00014 3735 20	epp7 	pr4|12,*		ncp_tables_$host_tbl
000272  aa  6 02126 6535 00	spri7	pr6|1110		hpr
						STATEMENT 1 ON LINE 245
          space_ptr -> info_struc.it (1).offset = size (info_struc);

000273  aa   000004 2360 07	ldq  	4,dl
000274  aa  6 02120 7561 20	stq  	pr6|1104,*	info_struc.offset
						STATEMENT 1 ON LINE 247
          do table_indx = table_start by 1 to npr -> ncp_dt.htbl_gent;

000275  aa  6 02132 3715 20	epp5 	pr6|1114,*	npr
000276  aa  5 00010 2361 00	ldq  	pr5|8		ncp_dt.htbl_gent
000277  aa  6 02160 7561 00	stq  	pr6|1136
000300  aa  6 00105 2361 00	ldq  	pr6|69		table_start
000301  aa  6 00103 7561 00	stq  	pr6|67		table_indx
000302  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000303  aa  6 02160 1161 00	cmpq 	pr6|1136
000304  aa   000064 6054 04	tpnz 	52,ic		000370
						STATEMENT 1 ON LINE 248
               if hpr -> host_array (table_indx).host_state ^= bit (binary (HOST_OFF, 6))
               then do;

000305  aa   000012 4020 07	mpy  	10,dl
000306  aa   000000 2350 07	lda  	0,dl
000307  aa   000002 6050 04	tpl  	2,ic		000311
000310  aa   000000 5310 00	neg  	0
000311  aa   000036 7350 00	als  	30
000312  aa  6 02200 7551 00	sta  	pr6|1152
000313  aa  6 02126 3735 20	epp7 	pr6|1110,*	hpr
000314  aa  7 77771 2351 06	lda  	pr7|-7,ql		host_array.host_state
000315  aa   000011 7350 00	als  	9
000316  aa  6 02201 7561 00	stq  	pr6|1153
000317  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
000320  aa  6 02200 1151 00	cmpa 	pr6|1152
000321  aa   000045 6000 04	tze  	37,ic		000366
						STATEMENT 1 ON LINE 250
                    if (array_indx + 1) * (size (host) + 1) > array_size
                    then do;

000322  aa   000013 2360 07	ldq  	11,dl
000323  aa  6 02200 7561 00	stq  	pr6|1152
000324  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000325  aa   000001 0760 07	adq  	1,dl
000326  aa  6 02200 4021 00	mpy  	pr6|1152
000327  aa  6 02202 7571 00	staq 	pr6|1154
000330  aa  6 02106 2351 00	lda  	pr6|1094		array_size
000331  aa   000044 7330 00	lrs  	36
000332  aa  6 02202 1171 00	cmpaq	pr6|1154
000333  aa   000013 6050 04	tpl  	11,ic		000346
						STATEMENT 1 ON LINE 252
                         call store_indx_list (addr (array_ptr -> host_array (array_indx + 1)), array_indx);

000334  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000335  aa   000012 4020 07	mpy  	10,dl
000336  aa  6 02114 3715 66	epp5 	pr6|1100,*ql	host_array
000337  aa  6 02202 6515 00	spri5	pr6|1154
000340  aa   000774 3520 04	epp2 	508,ic		001334 = 000004000000
000341  aa   000677 6700 04	tsp4 	447,ic		001240
						STATEMENT 1 ON LINE 253
                         P_error_code = error_table_$area_too_small;

000342  aa  6 00044 3701 20	epp4 	pr6|36,*
000343  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$area_too_small
000344  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 254
                         return;

000345  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 255
                         end;

						STATEMENT 1 ON LINE 257
                    array_indx = array_indx + 1;

000346  aa  6 00100 0541 00	aos  	pr6|64		array_indx
						STATEMENT 1 ON LINE 258
                    offset_list (array_indx) = table_indx;

000347  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000350  aa  6 00100 7271 00	lxl7 	pr6|64		array_indx
000351  aa  6 00105 7561 17	stq  	pr6|69,7		offset_list
						STATEMENT 1 ON LINE 259
                    unspec (host_copy) = unspec (hpr -> host_array (table_indx));

000352  aa  6 02201 7261 00	lxl6 	pr6|1153
000353  aa  7 77766 3715 16	epp5 	pr7|-10,6
000354  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000355  aa  5 00000 00 0050	desc9a	pr5|0,40
000356  aa  6 02142 00 0050	desc9a	pr6|1122,40
						STATEMENT 1 ON LINE 260
                    unspec (array_ptr -> host_array (array_indx)) = unspec (host_copy);

000357  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000360  aa   000012 4020 07	mpy  	10,dl
000361  aa  6 02114 3535 20	epp3 	pr6|1100,*	array_ptr
000362  aa  3 77766 3535 06	epp3 	pr3|-10,ql
000363  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000364  aa  6 02142 00 0050	desc9a	pr6|1122,40
000365  aa  3 00000 00 0050	desc9a	pr3|0,40
						STATEMENT 1 ON LINE 261
                    end;

						STATEMENT 1 ON LINE 262
               end;

000366  aa  6 00103 0541 00	aos  	pr6|67		table_indx
000367  aa   777713 7100 04	tra  	-53,ic		000302
						STATEMENT 1 ON LINE 264
          call store_indx_list (addr (array_ptr -> host_array (array_indx + 1)), array_indx);

000370  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000371  aa   000012 4020 07	mpy  	10,dl
000372  aa  6 02114 3735 66	epp7 	pr6|1100,*ql	host_array
000373  aa  6 02202 6535 00	spri7	pr6|1154
000374  aa   000740 3520 04	epp2 	480,ic		001334 = 000004000000
000375  aa   000643 6700 04	tsp4 	419,ic		001240
						STATEMENT 1 ON LINE 266
          return;

000376  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 270
process_request (4):                                        /* get RFC table                                  */
          if ^ privilege
          then do;

000377  aa  6 02112 2351 00	lda  	pr6|1098		privilege
000400  aa   000005 6010 04	tnz  	5,ic		000405
						STATEMENT 1 ON LINE 273
               P_error_code = error_table_$bad_processid;

000401  aa  6 00044 3701 20	epp4 	pr6|36,*
000402  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$bad_processid
000403  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 274
               return;

000404  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 275
               end;

						STATEMENT 1 ON LINE 277
          rpr = addr (ncp_tables_$rfc_tbl);

000405  aa  6 00044 3701 20	epp4 	pr6|36,*
000406  la  4 00026 3735 20	epp7 	pr4|22,*		ncp_tables_$rfc_tbl
000407  aa  6 02134 6535 00	spri7	pr6|1116		rpr
						STATEMENT 1 ON LINE 279
          space_ptr -> info_struc.it (1).offset = size (info_struc);

000410  aa   000004 2360 07	ldq  	4,dl
000411  aa  6 02120 7561 20	stq  	pr6|1104,*	info_struc.offset
						STATEMENT 1 ON LINE 281
          do table_indx = table_start by 1 to npr -> ncp_dt.rtbl_gent;

000412  aa  6 02132 3715 20	epp5 	pr6|1114,*	npr
000413  aa  5 00011 2361 00	ldq  	pr5|9		ncp_dt.rtbl_gent
000414  aa  6 02161 7561 00	stq  	pr6|1137
000415  aa  6 00105 2361 00	ldq  	pr6|69		table_start
000416  aa  6 00103 7561 00	stq  	pr6|67		table_indx
000417  aa   000000 0110 03	nop  	0,du
000420  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000421  aa  6 02161 1161 00	cmpq 	pr6|1137
000422  aa   000053 6054 04	tpnz 	43,ic		000475
						STATEMENT 1 ON LINE 282
               if rpr -> rfc_array (table_indx).foreign_hosts_choice ^= 0
               then do;

000423  aa   000002 7360 00	qls  	2
000424  aa  6 02134 3735 20	epp7 	pr6|1116,*	rpr
000425  aa  7 77776 2351 06	lda  	pr7|-2,ql		rfc_array.foreign_hosts_choice
000426  aa  6 02201 7561 00	stq  	pr6|1153
000427  aa   000066 7330 00	lrs  	54
000430  aa   000043 6000 04	tze  	35,ic		000473
						STATEMENT 1 ON LINE 284
                    if (array_indx + 1) * (size (rcvd_rfc) + 1) > array_size
                    then do;

000431  aa   000005 2360 07	ldq  	5,dl
000432  aa  6 02200 7561 00	stq  	pr6|1152
000433  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000434  aa   000001 0760 07	adq  	1,dl
000435  aa  6 02200 4021 00	mpy  	pr6|1152
000436  aa  6 02202 7571 00	staq 	pr6|1154
000437  aa  6 02106 2351 00	lda  	pr6|1094		array_size
000440  aa   000044 7330 00	lrs  	36
000441  aa  6 02202 1171 00	cmpaq	pr6|1154
000442  aa   000013 6050 04	tpl  	11,ic		000455
						STATEMENT 1 ON LINE 286
                         call store_indx_list (addr (array_ptr -> rfc_array (array_indx + 1)), array_indx);

000443  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000444  aa   000002 7360 00	qls  	2
000445  aa  6 02114 3715 66	epp5 	pr6|1100,*ql	rfc_array
000446  aa  6 02202 6515 00	spri5	pr6|1154
000447  aa   000665 3520 04	epp2 	437,ic		001334 = 000004000000
000450  aa   000570 6700 04	tsp4 	376,ic		001240
						STATEMENT 1 ON LINE 287
                         P_error_code = error_table_$area_too_small;

000451  aa  6 00044 3701 20	epp4 	pr6|36,*
000452  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$area_too_small
000453  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 288
                         return;

000454  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 289
                         end;

						STATEMENT 1 ON LINE 291
                    array_indx = array_indx + 1;

000455  aa  6 00100 0541 00	aos  	pr6|64		array_indx
						STATEMENT 1 ON LINE 292
                    offset_list (array_indx) = table_indx;

000456  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000457  aa  6 00100 7271 00	lxl7 	pr6|64		array_indx
000460  aa  6 00105 7561 17	stq  	pr6|69,7		offset_list
						STATEMENT 1 ON LINE 293
                    unspec (array_ptr -> rfc_array (array_indx)) = unspec (rpr -> rfc_array (table_indx));

000461  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000462  aa   000002 7360 00	qls  	2
000463  aa   000000 6260 06	eax6 	0,ql
000464  aa  6 02114 3715 20	epp5 	pr6|1100,*	array_ptr
000465  aa  6 02201 7251 00	lxl5 	pr6|1153
000466  aa  5 77774 3535 16	epp3 	pr5|-4,6
000467  aa  7 77774 3515 15	epp1 	pr7|-4,5
000470  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000471  aa  1 00000 00 0020	desc9a	pr1|0,16
000472  aa  3 00000 00 0020	desc9a	pr3|0,16
						STATEMENT 1 ON LINE 294
                    end;

						STATEMENT 1 ON LINE 295
               end;

000473  aa  6 00103 0541 00	aos  	pr6|67		table_indx
000474  aa   777724 7100 04	tra  	-44,ic		000420
						STATEMENT 1 ON LINE 297
          call store_indx_list (addr (array_ptr -> rfc_array (array_indx + 1)), array_indx);

000475  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000476  aa   000002 7360 00	qls  	2
000477  aa  6 02114 3735 66	epp7 	pr6|1100,*ql	rfc_array
000500  aa  6 02202 6535 00	spri7	pr6|1154
000501  aa   000633 3520 04	epp2 	411,ic		001334 = 000004000000
000502  aa   000536 6700 04	tsp4 	350,ic		001240
						STATEMENT 1 ON LINE 299
          return;

000503  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 303
process_request (5):                                        /* get socket table                               */
          proc_id = pds$process_id;

000504  aa  6 00044 3701 20	epp4 	pr6|36,*
000505  la  4 00010 2351 20	lda  	pr4|8,*		pds$process_id
000506  aa  6 02113 7551 00	sta  	pr6|1099		proc_id
						STATEMENT 1 ON LINE 305
          spr = addr (ncp_tables_$socket_tbl);

000507  la  4 00030 3735 20	epp7 	pr4|24,*		ncp_tables_$socket_tbl
000510  aa  6 02140 6535 00	spri7	pr6|1120		spr
						STATEMENT 1 ON LINE 307
          space_ptr -> info_struc.it (1).offset = size (info_struc);

000511  aa   000004 2360 07	ldq  	4,dl
000512  aa  6 02120 7561 20	stq  	pr6|1104,*	info_struc.offset
						STATEMENT 1 ON LINE 309
          do table_indx = table_start by 1 to npr -> ncp_dt.stbl_gent;

000513  aa  6 02132 3715 20	epp5 	pr6|1114,*	npr
000514  aa  5 00012 2361 00	ldq  	pr5|10		ncp_dt.stbl_gent
000515  aa  6 02162 7561 00	stq  	pr6|1138
000516  aa  6 00105 2361 00	ldq  	pr6|69		table_start
000517  aa  6 00103 7561 00	stq  	pr6|67		table_indx
000520  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000521  aa  6 02162 1161 00	cmpq 	pr6|1138
000522  aa   000071 6054 04	tpnz 	57,ic		000613
						STATEMENT 1 ON LINE 310
               sep = addr (spr -> socket_array (table_indx));

000523  aa   000030 4020 07	mpy  	24,dl
000524  aa  6 02140 3735 20	epp7 	pr6|1120,*	spr
000525  aa  7 77750 3735 06	epp7 	pr7|-24,ql	socket_array
000526  aa  6 02136 6535 00	spri7	pr6|1118		sep
						STATEMENT 1 ON LINE 311
               if sep -> socket.state ^= bit (binary (SOCK_UNASSIGNED, 6))
               then do;

000527  aa   000000 2350 07	lda  	0,dl
000530  aa   000002 6050 04	tpl  	2,ic		000532
000531  aa   000000 5310 00	neg  	0
000532  aa   000036 7350 00	als  	30
000533  aa  6 02201 7551 00	sta  	pr6|1153
000534  aa  7 00017 2351 00	lda  	pr7|15		socket.state
000535  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
000536  aa  6 02201 1151 00	cmpa 	pr6|1153
000537  aa   000052 6000 04	tze  	42,ic		000611
						STATEMENT 1 ON LINE 313
                    if (privilege) | (sep -> socket.overseer_process_id = proc_id) |(sep -> socket.process_id = proc_id)
                    then do;

000540  aa  6 02112 2351 00	lda  	pr6|1098		privilege
000541  aa   000007 6010 04	tnz  	7,ic		000550
000542  aa  7 00006 2351 00	lda  	pr7|6		socket.overseer_process_id
000543  aa  6 02113 1151 00	cmpa 	pr6|1099		proc_id
000544  aa   000004 6000 04	tze  	4,ic		000550
000545  aa  7 00005 2351 00	lda  	pr7|5		socket.process_id
000546  aa  6 02113 1151 00	cmpa 	pr6|1099		proc_id
000547  aa   000042 6010 04	tnz  	34,ic		000611
						STATEMENT 1 ON LINE 315
                         if (array_indx + 1) * (size (socket) + 1) > array_size
                         then do;

000550  aa   000031 2360 07	ldq  	25,dl
000551  aa  6 02201 7561 00	stq  	pr6|1153
000552  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000553  aa   000001 0760 07	adq  	1,dl
000554  aa  6 02201 4021 00	mpy  	pr6|1153
000555  aa  6 02202 7571 00	staq 	pr6|1154
000556  aa  6 02106 2351 00	lda  	pr6|1094		array_size
000557  aa   000044 7330 00	lrs  	36
000560  aa  6 02202 1171 00	cmpaq	pr6|1154
000561  aa   000013 6050 04	tpl  	11,ic		000574
						STATEMENT 1 ON LINE 317
                              call store_indx_list (addr (array_ptr -> socket_array (array_indx + 1)), array_indx);

000562  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000563  aa   000030 4020 07	mpy  	24,dl
000564  aa  6 02114 3715 66	epp5 	pr6|1100,*ql	socket_array
000565  aa  6 02202 6515 00	spri5	pr6|1154
000566  aa   000546 3520 04	epp2 	358,ic		001334 = 000004000000
000567  aa   000451 6700 04	tsp4 	297,ic		001240
						STATEMENT 1 ON LINE 318
                              P_error_code = error_table_$area_too_small;

000570  aa  6 00044 3701 20	epp4 	pr6|36,*
000571  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$area_too_small
000572  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 319
                              return;

000573  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 320
                              end;

						STATEMENT 1 ON LINE 322
                         call update_socket_allocations ();

000574  aa   000472 6700 04	tsp4 	314,ic		001266
						STATEMENT 1 ON LINE 324
                         array_indx = array_indx + 1;

000575  aa  6 00100 0541 00	aos  	pr6|64		array_indx
						STATEMENT 1 ON LINE 325
                         offset_list (array_indx) = table_indx;

000576  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
000577  aa  6 00100 7271 00	lxl7 	pr6|64		array_indx
000600  aa  6 00105 7561 17	stq  	pr6|69,7		offset_list
						STATEMENT 1 ON LINE 326
                         unspec (array_ptr -> socket_array (array_indx)) = unspec (sep -> socket);

000601  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000602  aa   000030 4020 07	mpy  	24,dl
000603  aa  6 02114 3735 20	epp7 	pr6|1100,*	array_ptr
000604  aa  7 77750 3735 06	epp7 	pr7|-24,ql
000605  aa  6 02136 3715 20	epp5 	pr6|1118,*	sep
000606  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000607  aa  5 00000 00 0140	desc9a	pr5|0,96
000610  aa  7 00000 00 0140	desc9a	pr7|0,96
						STATEMENT 1 ON LINE 327
                         end;

						STATEMENT 1 ON LINE 328
                    end;

						STATEMENT 1 ON LINE 329
               end;

000611  aa  6 00103 0541 00	aos  	pr6|67		table_indx
000612  aa   777706 7100 04	tra  	-58,ic		000520
						STATEMENT 1 ON LINE 331
          call store_indx_list (addr (array_ptr -> socket_array (array_indx + 1)), array_indx);

000613  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000614  aa   000030 4020 07	mpy  	24,dl
000615  aa  6 02114 3735 66	epp7 	pr6|1100,*ql	socket_array
000616  aa  6 02202 6535 00	spri7	pr6|1154
000617  aa   000515 3520 04	epp2 	333,ic		001334 = 000004000000
000620  aa   000420 6700 04	tsp4 	272,ic		001240
						STATEMENT 1 ON LINE 333
          return;

000621  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 337
process_request (6):                                        /* get socket data                                */
          if size (socket) > array_size
          then do;

000622  aa   000030 2360 07	ldq  	24,dl
000623  aa  6 02106 1161 00	cmpq 	pr6|1094		array_size
000624  aa   000005 6044 04	tmoz 	5,ic		000631
						STATEMENT 1 ON LINE 340
               P_error_code = error_table_$action_not_performed;

000625  aa  6 00044 3701 20	epp4 	pr6|36,*
000626  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
000627  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 341
               return;

000630  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 342
               end;

						STATEMENT 1 ON LINE 344
          proc_id = pds$process_id;

000631  aa  6 00044 3701 20	epp4 	pr6|36,*
000632  la  4 00010 2351 20	lda  	pr4|8,*		pds$process_id
000633  aa  6 02113 7551 00	sta  	pr6|1099		proc_id
						STATEMENT 1 ON LINE 346
          table_indx = first_offset;

000634  aa  6 00104 2361 00	ldq  	pr6|68		first_offset
000635  aa  6 00103 7561 00	stq  	pr6|67		table_indx
						STATEMENT 1 ON LINE 348
          if (table_indx <= 0) | (table_indx > npr -> ncp_dt.stbl_gent)
          then do;

000636  aa   000004 6044 04	tmoz 	4,ic		000642
000637  aa  6 02132 3735 20	epp7 	pr6|1114,*	npr
000640  aa  7 00012 1161 00	cmpq 	pr7|10		ncp_dt.stbl_gent
000641  aa   000004 6044 04	tmoz 	4,ic		000645
						STATEMENT 1 ON LINE 350
               P_error_code = error_table_$bad_index;

000642  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$bad_index
000643  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 351
               return;

000644  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 352
               end;

						STATEMENT 1 ON LINE 354
          spr = addr (ncp_tables_$socket_tbl);

000645  la  4 00030 3715 20	epp5 	pr4|24,*		ncp_tables_$socket_tbl
000646  aa  6 02140 6515 00	spri5	pr6|1120		spr
						STATEMENT 1 ON LINE 355
          sep = addr (spr -> socket_array (table_indx));

000647  aa   000030 4020 07	mpy  	24,dl
000650  aa  5 77750 3535 06	epp3 	pr5|-24,ql	socket_array
000651  aa  6 02136 2535 00	spri3	pr6|1118		sep
						STATEMENT 1 ON LINE 357
          if sep -> socket.state = bit (binary (SOCK_UNASSIGNED, 6))
          then do;

000652  aa   000000 2350 07	lda  	0,dl
000653  aa   000002 6050 04	tpl  	2,ic		000655
000654  aa   000000 5310 00	neg  	0
000655  aa   000036 7350 00	als  	30
000656  aa  6 02201 7551 00	sta  	pr6|1153
000657  aa  3 00017 2351 00	lda  	pr3|15		socket.state
000660  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
000661  aa  6 02201 1151 00	cmpa 	pr6|1153
000662  aa   000004 6010 04	tnz  	4,ic		000666
						STATEMENT 1 ON LINE 359
               P_error_code = error_table_$bad_index;

000663  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$bad_index
000664  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 360
               return;

000665  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 361
               end;

						STATEMENT 1 ON LINE 363
          if ^ privilege
          then do;

000666  aa  6 02112 2351 00	lda  	pr6|1098		privilege
000667  aa   000012 6010 04	tnz  	10,ic		000701
						STATEMENT 1 ON LINE 365
               if (sep -> socket.process_id ^= proc_id) & (sep -> socket.overseer_process_id ^= proc_id)
               then do;

000670  aa  3 00005 2351 00	lda  	pr3|5		socket.process_id
000671  aa  6 02113 1151 00	cmpa 	pr6|1099		proc_id
000672  aa   000007 6000 04	tze  	7,ic		000701
000673  aa  3 00006 2351 00	lda  	pr3|6		socket.overseer_process_id
000674  aa  6 02113 1151 00	cmpa 	pr6|1099		proc_id
000675  aa   000004 6000 04	tze  	4,ic		000701
						STATEMENT 1 ON LINE 367
                    P_error_code = error_table_$bad_processid;

000676  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$bad_processid
000677  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 368
                    return;

000700  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 369
                    end;

						STATEMENT 1 ON LINE 370
               end;

						STATEMENT 1 ON LINE 372
          call update_socket_allocations ();

000701  aa   000365 6700 04	tsp4 	245,ic		001266
						STATEMENT 1 ON LINE 374
          space_ptr -> info_struc.it (1).space_size = 1;

000702  aa   000001 2360 07	ldq  	1,dl
000703  aa  6 02120 3735 20	epp7 	pr6|1104,*	space_ptr
000704  aa  7 00001 7561 00	stq  	pr7|1		info_struc.space_size
						STATEMENT 1 ON LINE 375
          space_ptr -> info_struc.it (1).offset = size (info_struc);

000705  aa   000004 2360 07	ldq  	4,dl
000706  aa  7 00000 7561 00	stq  	pr7|0		info_struc.offset
						STATEMENT 1 ON LINE 377
          unspec (array_ptr -> socket) = unspec (sep -> socket);

000707  aa  6 02114 3715 20	epp5 	pr6|1100,*	array_ptr
000710  aa  6 02136 3535 20	epp3 	pr6|1118,*	sep
000711  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000712  aa  3 00000 00 0140	desc9a	pr3|0,96
000713  aa  5 00000 00 0140	desc9a	pr5|0,96
						STATEMENT 1 ON LINE 379
          space_ptr -> info_struc.it (2).offset = size (info_struc) + size (socket);

000714  aa   000030 0760 07	adq  	24,dl
000715  aa  7 00002 7561 00	stq  	pr7|2		info_struc.offset
						STATEMENT 1 ON LINE 380
          array_ptr = addrel (space_ptr, size (info_struc) + size (socket));

000716  aa   000034 2360 07	ldq  	28,dl
000717  aa  7 00000 3521 06	epp2 	pr7|0,ql
000720  aa   000000 0520 03	adwp2	0,du
000721  aa  6 02114 2521 00	spri2	pr6|1100		array_ptr
						STATEMENT 1 ON LINE 383
          rpr = addr (ncp_tables_$rfc_tbl);

000722  aa  6 00044 3701 20	epp4 	pr6|36,*
000723  la  4 00026 3715 20	epp5 	pr4|22,*		ncp_tables_$rfc_tbl
000724  aa  6 02134 6515 00	spri5	pr6|1116		rpr
						STATEMENT 1 ON LINE 385
          do next_rfc = sep -> socket.rfc_queue repeat (rpr -> rfc_array (next_rfc).next_entry)
                    while (next_rfc ^= 0);

000725  aa  3 00015 2351 00	lda  	pr3|13		socket.rfc_queue
000726  aa   000066 7330 00	lrs  	54
000727  aa  6 00101 7561 00	stq  	pr6|65		next_rfc
000730  aa  6 00101 2361 00	ldq  	pr6|65		next_rfc
000731  aa   000044 6000 04	tze  	36,ic		000775
						STATEMENT 1 ON LINE 387
               if (array_indx + 1) * size (rcvd_rfc) + size (socket) > array_size
               then do;

000732  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000733  aa   000001 0760 07	adq  	1,dl
000734  aa   000004 4020 07	mpy  	4,dl
000735  aa   000030 0330 07	adl  	24,dl
000736  aa  6 02202 7571 00	staq 	pr6|1154
000737  aa  6 02106 2351 00	lda  	pr6|1094		array_size
000740  aa   000044 7330 00	lrs  	36
000741  aa  6 02202 1171 00	cmpaq	pr6|1154
000742  aa   000010 6050 04	tpl  	8,ic		000752
						STATEMENT 1 ON LINE 389
                    space_ptr -> info_struc.it (2).space_size = array_indx;

000743  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000744  aa  6 02120 3735 20	epp7 	pr6|1104,*	space_ptr
000745  aa  7 00003 7561 00	stq  	pr7|3		info_struc.space_size
						STATEMENT 1 ON LINE 390
                    P_error_code = error_table_$area_too_small;

000746  aa  6 00044 3701 20	epp4 	pr6|36,*
000747  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$area_too_small
000750  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 391
                    return;

000751  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 392
                    end;

						STATEMENT 1 ON LINE 394
               array_indx = array_indx + 1;

000752  aa  6 00100 0541 00	aos  	pr6|64		array_indx
						STATEMENT 1 ON LINE 395
               unspec (array_ptr -> rfc_array (array_indx)) = unspec (rpr -> rfc_array (next_rfc));

000753  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000754  aa   000002 7360 00	qls  	2
000755  aa   000000 6270 06	eax7 	0,ql
000756  aa  6 00101 2361 00	ldq  	pr6|65		next_rfc
000757  aa   000002 7360 00	qls  	2
000760  aa   000000 6260 06	eax6 	0,ql
000761  aa  6 02114 3735 20	epp7 	pr6|1100,*	array_ptr
000762  aa  6 02134 3715 20	epp5 	pr6|1116,*	rpr
000763  aa  7 77774 3535 17	epp3 	pr7|-4,7
000764  aa  5 77774 3515 16	epp1 	pr5|-4,6
000765  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000766  aa  1 00000 00 0020	desc9a	pr1|0,16
000767  aa  3 00000 00 0020	desc9a	pr3|0,16
						STATEMENT 1 ON LINE 396
               end;

000770  aa  5 77776 2351 16	lda  	pr5|-2,6		rfc_array.next_entry
000771  aa   000022 7350 00	als  	18
000772  aa   000066 7330 00	lrs  	54
000773  aa  6 00101 7561 00	stq  	pr6|65		next_rfc
000774  aa   777734 7100 04	tra  	-36,ic		000730
						STATEMENT 1 ON LINE 398
          space_ptr -> info_struc.it (2).space_size = array_indx;

000775  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
000776  aa  6 02120 3735 20	epp7 	pr6|1104,*	space_ptr
000777  aa  7 00003 7561 00	stq  	pr7|3		info_struc.space_size
						STATEMENT 1 ON LINE 400
          return;

001000  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 404
process_request (7):                                        /* get error table                                */
          mpr = addr (ncp_tables_$meter_cells);

001001  aa  6 00044 3701 20	epp4 	pr6|36,*
001002  la  4 00020 3735 20	epp7 	pr4|16,*		ncp_tables_$meter_cells
001003  aa  6 02130 6535 00	spri7	pr6|1112		mpr
						STATEMENT 1 ON LINE 406
          epr = addr (ncp_tables_$error_tbl);

001004  la  4 00012 3715 20	epp5 	pr4|10,*		ncp_tables_$error_tbl
001005  aa  6 02124 6515 00	spri5	pr6|1108		epr
						STATEMENT 1 ON LINE 408
          space_ptr -> info_struc.it (1).offset = size (info_struc);

001006  aa   000004 2360 07	ldq  	4,dl
001007  aa  6 02120 7561 20	stq  	pr6|1104,*	info_struc.offset
						STATEMENT 1 ON LINE 409
          space_ptr -> info_struc.it (1).space_size = 1;

001010  aa   000001 2360 07	ldq  	1,dl
001011  aa  6 02120 3535 20	epp3 	pr6|1104,*	space_ptr
001012  aa  3 00001 7561 00	stq  	pr3|1		info_struc.space_size
						STATEMENT 1 ON LINE 411
          do table_indx = table_start by 1 to min (mpr -> meter_dt.net_error_count, 8);

001013  aa  7 00020 2361 00	ldq  	pr7|16		meter_dt.net_error_count
001014  aa   000010 1160 07	cmpq 	8,dl
001015  aa   000002 6040 04	tmi  	2,ic		001017
001016  aa   000010 2360 07	ldq  	8,dl
001017  aa  6 02163 7561 00	stq  	pr6|1139
001020  aa  6 00105 2361 00	ldq  	pr6|69		table_start
001021  aa  6 00103 7561 00	stq  	pr6|67		table_indx
001022  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
001023  aa  6 02163 1161 00	cmpq 	pr6|1139
001024  aa   000047 6054 04	tpnz 	39,ic		001073
						STATEMENT 1 ON LINE 412
               if (array_indx + 1) * (size (error_snapshot) + 1) > array_size
               then do;

001025  aa   000241 2360 07	ldq  	161,dl
001026  aa  6 02200 7561 00	stq  	pr6|1152
001027  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
001030  aa   000001 0760 07	adq  	1,dl
001031  aa  6 02200 4021 00	mpy  	pr6|1152
001032  aa  6 02202 7571 00	staq 	pr6|1154
001033  aa  6 02106 2351 00	lda  	pr6|1094		array_size
001034  aa   000044 7330 00	lrs  	36
001035  aa  6 02202 1171 00	cmpaq	pr6|1154
001036  aa   000013 6050 04	tpl  	11,ic		001051
						STATEMENT 1 ON LINE 414
                    call store_indx_list (addr (array_ptr -> error_array (array_indx + 1)), array_indx);

001037  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
001040  aa   000240 4020 07	mpy  	160,dl
001041  aa  6 02114 3735 66	epp7 	pr6|1100,*ql	error_array
001042  aa  6 02202 6535 00	spri7	pr6|1154
001043  aa   000271 3520 04	epp2 	185,ic		001334 = 000004000000
001044  aa   000174 6700 04	tsp4 	124,ic		001240
						STATEMENT 1 ON LINE 415
                    P_error_code = error_table_$area_too_small;

001045  aa  6 00044 3701 20	epp4 	pr6|36,*
001046  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$area_too_small
001047  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 416
                    return;

001050  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 417
                    end;

						STATEMENT 1 ON LINE 419
               array_indx = array_indx + 1;

001051  aa  6 00100 0541 00	aos  	pr6|64		array_indx
						STATEMENT 1 ON LINE 420
               offset_list (array_indx) = table_indx;

001052  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
001053  aa  6 00100 7271 00	lxl7 	pr6|64		array_indx
001054  aa  6 00105 7561 17	stq  	pr6|69,7		offset_list
						STATEMENT 1 ON LINE 421
               unspec (array_ptr -> error_array (array_indx)) = unspec (epr -> error_array (table_indx));

001055  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
001056  aa   000240 4020 07	mpy  	160,dl
001057  aa   000000 6260 06	eax6 	0,ql
001060  aa  6 00103 2361 00	ldq  	pr6|67		table_indx
001061  aa   000240 4020 07	mpy  	160,dl
001062  aa  6 02114 3735 20	epp7 	pr6|1100,*	array_ptr
001063  aa  7 77540 3735 16	epp7 	pr7|-160,6
001064  aa  6 02124 3715 20	epp5 	pr6|1108,*	epr
001065  aa  5 77540 3715 06	epp5 	pr5|-160,ql
001066  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001067  aa  5 00000 00 1200	desc9a	pr5|0,640
001070  aa  7 00000 00 1200	desc9a	pr7|0,640
						STATEMENT 1 ON LINE 422
               end;

001071  aa  6 00103 0541 00	aos  	pr6|67		table_indx
001072  aa   777730 7100 04	tra  	-40,ic		001022
						STATEMENT 1 ON LINE 424
          call store_indx_list (addr (array_ptr -> error_array (array_indx + 1)), array_indx);

001073  aa  6 00100 2361 00	ldq  	pr6|64		array_indx
001074  aa   000240 4020 07	mpy  	160,dl
001075  aa  6 02114 3735 66	epp7 	pr6|1100,*ql	error_array
001076  aa  6 02202 6535 00	spri7	pr6|1154
001077  aa   000235 3520 04	epp2 	157,ic		001334 = 000004000000
001100  aa   000140 6700 04	tsp4 	96,ic		001240
						STATEMENT 1 ON LINE 426
          return;

001101  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 430
process_request (8):                              /* get host entry                                           */
          if size (host) > space_size
          then do;

001102  aa   000012 2360 07	ldq  	10,dl
001103  aa  6 02110 1161 00	cmpq 	pr6|1096		space_size
001104  aa   000005 6044 04	tmoz 	5,ic		001111
						STATEMENT 1 ON LINE 433
               P_error_code = error_table_$action_not_performed;

001105  aa  6 00044 3701 20	epp4 	pr6|36,*
001106  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
001107  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 434
               return;

001110  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 435
               end;

						STATEMENT 1 ON LINE 437
          call ncp_util_$find_host_entry ((first_offset), "0"b, host_ptr, err_code);

001111  aa  6 00104 2361 00	ldq  	pr6|68		first_offset
001112  aa  6 02200 7561 00	stq  	pr6|1152
001113  aa   000000 2350 07	lda  	0,dl
001114  aa  6 02201 7551 00	sta  	pr6|1153
001115  aa  6 02200 3521 00	epp2 	pr6|1152
001116  aa  6 02206 2521 00	spri2	pr6|1158
001117  aa  6 02201 3521 00	epp2 	pr6|1153
001120  aa  6 02210 2521 00	spri2	pr6|1160
001121  aa  6 02116 3521 00	epp2 	pr6|1102		host_ptr
001122  aa  6 02212 2521 00	spri2	pr6|1162
001123  aa  6 02111 3521 00	epp2 	pr6|1097		err_code
001124  aa  6 02214 2521 00	spri2	pr6|1164
001125  aa  6 02204 6211 00	eax1 	pr6|1156
001126  aa   020000 4310 07	fld  	8192,dl
001127  aa  6 00044 3701 20	epp4 	pr6|36,*
001130  la  4 00046 3521 20	epp2 	pr4|38,*		ncp_util_$find_host_entry
001131  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 438
          if err_code ^= 0
          then do;

001132  aa  6 02111 2361 00	ldq  	pr6|1097		err_code
001133  aa   000003 6000 04	tze  	3,ic		001136
						STATEMENT 1 ON LINE 440
               P_error_code = err_code;

001134  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 441
               return;

001135  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 442
               end;

						STATEMENT 1 ON LINE 444
          unspec (host_copy) = unspec (host_ptr -> host);

001136  aa  6 02116 3735 20	epp7 	pr6|1102,*	host_ptr
001137  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001140  aa  7 00000 00 0050	desc9a	pr7|0,40
001141  aa  6 02142 00 0050	desc9a	pr6|1122,40
						STATEMENT 1 ON LINE 445
          unspec (space_ptr -> host) = unspec (host_copy);

001142  aa  6 02120 3715 20	epp5 	pr6|1104,*	space_ptr
001143  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001144  aa  6 02142 00 0050	desc9a	pr6|1122,40
001145  aa  5 00000 00 0050	desc9a	pr5|0,40
						STATEMENT 1 ON LINE 447
          return;

001146  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 451
process_request (9):                              /* get process table                                        */
          P_error_code = error_table_$action_not_performed;

001147  aa  6 00044 3701 20	epp4 	pr6|36,*
001150  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$action_not_performed
001151  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 454
          return;

001152  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 464
proc_copy_rq (20):                                          /* copy ncp_tables_                               */
          table_ptr = pointer (addr (ncp_tables_$ncp_data), ""b);

001153  aa  6 00044 3701 20	epp4 	pr6|36,*
001154  la  4 00022 3735 20	epp7 	pr4|18,*		ncp_tables_$ncp_data
001155  aa  7 00000 3525 00	epbp2	pr7|0
001156  aa  6 02122 2521 00	spri2	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 466
          goto copy_rq_common;

001157  aa   000035 7100 04	tra  	29,ic		001214
						STATEMENT 1 ON LINE 468
proc_copy_rq (21):                                          /* copy ncp data                                  */
          table_ptr = addr (ncp_tables_$ncp_data);

001160  aa  6 00044 3701 20	epp4 	pr6|36,*
001161  la  4 00022 3735 20	epp7 	pr4|18,*		ncp_tables_$ncp_data
001162  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 470
          goto copy_rq_common;

001163  aa   000031 7100 04	tra  	25,ic		001214
						STATEMENT 1 ON LINE 472
proc_copy_rq (22):                                          /* copy meter cells                               */
          table_ptr = addr (ncp_tables_$meter_cells);

001164  aa  6 00044 3701 20	epp4 	pr6|36,*
001165  la  4 00020 3735 20	epp7 	pr4|16,*		ncp_tables_$meter_cells
001166  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 474
          goto copy_rq_common;

001167  aa   000025 7100 04	tra  	21,ic		001214
						STATEMENT 1 ON LINE 476
proc_copy_rq (23):                                          /* copy process table                             */
          table_ptr = addr (ncp_tables_$proc_tbl);

001170  aa  6 00044 3701 20	epp4 	pr6|36,*
001171  la  4 00024 3735 20	epp7 	pr4|20,*		ncp_tables_$proc_tbl
001172  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 478
          goto copy_rq_common;

001173  aa   000021 7100 04	tra  	17,ic		001214
						STATEMENT 1 ON LINE 480
proc_copy_rq (24):                                          /* copy lock table                                */
          table_ptr = addr (ncp_tables_$lock_tbl);

001174  aa  6 00044 3701 20	epp4 	pr6|36,*
001175  la  4 00016 3735 20	epp7 	pr4|14,*		ncp_tables_$lock_tbl
001176  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 482
          goto copy_rq_common;

001177  aa   000015 7100 04	tra  	13,ic		001214
						STATEMENT 1 ON LINE 484
proc_copy_rq (25):                                          /* copy host table                                */
          table_ptr = addr (ncp_tables_$host_tbl);

001200  aa  6 00044 3701 20	epp4 	pr6|36,*
001201  la  4 00014 3735 20	epp7 	pr4|12,*		ncp_tables_$host_tbl
001202  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 486
          goto copy_rq_common;

001203  aa   000011 7100 04	tra  	9,ic		001214
						STATEMENT 1 ON LINE 488
proc_copy_rq (26):                                          /* copy RFC table                                 */
          table_ptr = addr (ncp_tables_$rfc_tbl);

001204  aa  6 00044 3701 20	epp4 	pr6|36,*
001205  la  4 00026 3735 20	epp7 	pr4|22,*		ncp_tables_$rfc_tbl
001206  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 490
          goto copy_rq_common;

001207  aa   000005 7100 04	tra  	5,ic		001214
						STATEMENT 1 ON LINE 492
proc_copy_rq (27):                                          /* copy socket table                              */
          table_ptr = addr (ncp_tables_$socket_tbl);

001210  aa  6 00044 3701 20	epp4 	pr6|36,*
001211  la  4 00030 3735 20	epp7 	pr4|24,*		ncp_tables_$socket_tbl
001212  aa  6 02122 6535 00	spri7	pr6|1106		table_ptr
						STATEMENT 1 ON LINE 494
          goto copy_rq_common;

001213  aa   000001 7100 04	tra  	1,ic		001214
						STATEMENT 1 ON LINE 496
copy_rq_common:
          if ^ privilege
          then do;

001214  aa  6 02112 2351 00	lda  	pr6|1098		privilege
001215  aa   000004 6010 04	tnz  	4,ic		001221
						STATEMENT 1 ON LINE 499
               P_error_code = error_table_$bad_processid;

001216  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$bad_processid
001217  aa  6 02156 7561 20	stq  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 500
               return;

001220  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 501
               end;

						STATEMENT 1 ON LINE 503
          copy_size = P_space_size;

001221  aa  6 00032 3735 20	epp7 	pr6|26,*
001222  aa  7 00010 2361 20	ldq  	pr7|8,*		P_space_size
001223  aa  6 02107 7561 00	stq  	pr6|1095		copy_size
						STATEMENT 1 ON LINE 504
          space_ptr = addrel (space_ptr, first_offset);

001224  aa  6 00104 2361 00	ldq  	pr6|68		first_offset
001225  aa  6 02120 3521 66	epp2 	pr6|1104,*ql	space_ptr
001226  aa   000000 0520 03	adwp2	0,du
001227  aa  6 02120 2521 00	spri2	pr6|1104		space_ptr
						STATEMENT 1 ON LINE 505
          space_ptr -> based_indx_list = table_ptr -> based_indx_list;

001230  aa  6 02107 2361 00	ldq  	pr6|1095		copy_size
001231  aa   000002 7360 00	qls  	2
001232  aa  6 02122 3715 20	epp5 	pr6|1106,*	table_ptr
001233  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
001234  aa  5 00000 00 0006	desc9a	pr5|0,ql		based_indx_list
001235  aa  2 00000 00 0006	desc9a	pr2|0,ql		based_indx_list
						STATEMENT 1 ON LINE 507
          P_error_code = 0;

001236  aa  6 02156 4501 20	stz  	pr6|1134,*	P_error_code
						STATEMENT 1 ON LINE 509
          return;

001237  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 561
end;

BEGIN PROCEDURE store_indx_list
ENTRY TO store_indx_list                                    STATEMENT 1 ON LINE 513
store_indx_list:
          procedure (p_indx_ptr, p_indx_size);

001240  aa  6 02164 6501 00	spri4	pr6|1140
001241  aa  6 02166 2521 00	spri2	pr6|1142
						STATEMENT 1 ON LINE 525
          space_ptr -> info_struc.it (2).offset = binary (rel (p_indx_ptr), 18) - binary (rel (space_ptr), 18);

001242  aa  6 02120 6351 20	eaa  	pr6|1104,*	space_ptr
001243  aa   000066 7730 00	lrl  	54
001244  aa  6 02216 7561 00	stq  	pr6|1166
001245  aa  2 00002 3735 20	epp7 	pr2|2,*		p_indx_ptr
001246  aa  7 00000 3735 20	epp7 	pr7|0,*		p_indx_ptr
001247  aa  7 00000 6351 00	eaa  	pr7|0		p_indx_ptr
001250  aa   000066 7730 00	lrl  	54
001251  aa  6 02216 1761 00	sbq  	pr6|1166
001252  aa  6 02120 3715 20	epp5 	pr6|1104,*	space_ptr
001253  aa  5 00002 7561 00	stq  	pr5|2		info_struc.offset
						STATEMENT 1 ON LINE 527
          copy_size = p_indx_size;

001254  aa  2 00004 2361 20	ldq  	pr2|4,*		p_indx_size
001255  aa  6 02107 7561 00	stq  	pr6|1095		copy_size
						STATEMENT 1 ON LINE 528
          p_indx_ptr -> based_indx_list = addr (offset_list) -> based_indx_list;

001256  aa   000002 7360 00	qls  	2
001257  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
001260  aa  6 00106 00 0006	desc9a	pr6|70,ql		based_indx_list
001261  aa  7 00000 00 0006	desc9a	pr7|0,ql		based_indx_list
						STATEMENT 1 ON LINE 530
          space_ptr -> info_struc.it (1).space_size = p_indx_size;

001262  aa  2 00004 2361 20	ldq  	pr2|4,*		p_indx_size
001263  aa  5 00001 7561 00	stq  	pr5|1		info_struc.space_size
						STATEMENT 1 ON LINE 531
          space_ptr -> info_struc.it (2).space_size = p_indx_size;

001264  aa  5 00003 7561 00	stq  	pr5|3		info_struc.space_size
						STATEMENT 1 ON LINE 533
          return;

001265  aa  6 02164 6101 00	rtcd 	pr6|1140
						STATEMENT 1 ON LINE 535
end;

  END PROCEDURE store_indx_list
BEGIN PROCEDURE update_socket_allocations
ENTRY TO update_socket_allocations                          STATEMENT 1 ON LINE 539
update_socket_allocations:
          procedure ();

001266  aa  6 02172 6501 00	spri4	pr6|1146
						STATEMENT 1 ON LINE 544
          if ^ sep -> socket.send_gender
          then return;

001267  aa  6 02136 3735 20	epp7 	pr6|1118,*	sep
001270  aa  7 00017 2351 00	lda  	pr7|15		socket.send_gender
001271  aa   000010 3150 03	cana 	8,du
001272  aa   000002 6010 04	tnz  	2,ic		001274
001273  aa  6 02172 6101 00	rtcd 	pr6|1146
						STATEMENT 1 ON LINE 547
          call imp_write_order ((sep -> socket.impdim_index), GET_ALLOCATION_DATA, addr (impdim_alloc_struc), (18)"0"b, err_code);

001274  aa  7 00016 2351 00	lda  	pr7|14		socket.impdim_index
001275  aa   000022 7350 00	als  	18
001276  aa   000066 7330 00	lrs  	54
001277  aa  6 02217 7561 00	stq  	pr6|1167
001300  aa  6 02154 3715 00	epp5 	pr6|1132		impdim_alloc_struc
001301  aa  6 02220 6515 00	spri5	pr6|1168
001302  aa   000000 2350 07	lda  	0,dl
001303  aa  6 02222 7551 00	sta  	pr6|1170
001304  aa  6 02217 3521 00	epp2 	pr6|1167
001305  aa  6 02226 2521 00	spri2	pr6|1174
001306  aa   776513 3520 04	epp2 	-693,ic		000021 = 000000000021
001307  aa  6 02230 2521 00	spri2	pr6|1176
001310  aa  6 02220 3521 00	epp2 	pr6|1168
001311  aa  6 02232 2521 00	spri2	pr6|1178
001312  aa  6 02222 3521 00	epp2 	pr6|1170
001313  aa  6 02234 2521 00	spri2	pr6|1180
001314  aa  6 02111 3521 00	epp2 	pr6|1097		err_code
001315  aa  6 02236 2521 00	spri2	pr6|1182
001316  aa  6 02224 6211 00	eax1 	pr6|1172
001317  aa   024000 4310 07	fld  	10240,dl
001320  aa  6 00044 3701 20	epp4 	pr6|36,*
001321  la  4 00044 3521 20	epp2 	pr4|36,*		imp_write_order
001322  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 548
          if err_code ^= 0
          then return;

001323  aa  6 02111 2361 00	ldq  	pr6|1097		err_code
001324  aa   000002 6000 04	tze  	2,ic		001326
001325  aa  6 02172 6101 00	rtcd 	pr6|1146
						STATEMENT 1 ON LINE 551
          sep -> socket.bit_allocation = impdim_alloc_struc.bit_allocation;

001326  aa  6 02154 2361 00	ldq  	pr6|1132		impdim_alloc_struc.bit_allocation
001327  aa  6 02136 3735 20	epp7 	pr6|1118,*	sep
001330  aa  7 00007 7561 00	stq  	pr7|7		socket.bit_allocation
						STATEMENT 1 ON LINE 552
          sep -> socket.msg_allocation = impdim_alloc_struc.msg_allocation;

001331  aa  6 02155 2361 00	ldq  	pr6|1133		impdim_alloc_struc.msg_allocation
001332  aa  7 00010 7561 00	stq  	pr7|8		socket.msg_allocation
						STATEMENT 1 ON LINE 554
          return;

001333  aa  6 02172 6101 00	rtcd 	pr6|1146
						STATEMENT 1 ON LINE 556
end;

  END PROCEDURE update_socket_allocations
  END PROCEDURE ncp_status_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
