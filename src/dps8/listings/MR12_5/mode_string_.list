	COMPILATION LISTING OF SEGMENT mode_string_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0956.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* The mode_string_ subroutine is a general way to handle mode strings.
       14*   It was described in MCR 4670, and approved 15 October 1980
       15*
       16*   Designed, Coded by James R. Davis
       17*   Modified 12 January 1981 by J. Spencer Love for quoted strings
       18*
       19*   modes are separated from each other by commas
       20*   the first nonwhite character in the string is the beginning of the first mode
       21*   the end of the last mode precedes the first unquoted period or is the last nonwhite character
       22*
       23*   A mode may be one of these forms:
       24*
       25*   MODE             boolean mode (true)
       26*   ^MODE            boolean mode (false)
       27*   MODE=XXX         XXX may be char or decimal digits, XXX may be quoted
       28*   MODEnnn          nnn must be decimal digits
       29**/
       30 
       31 /* format:  style3,ll122,idind30,ifthenstmt */
       32 
       33 mode_string_$parse:
       34      procedure (P_string, P_areap, P_mode_string_info_ptr, P_status);
       35 
       36 declare	P_areap			ptr parameter,
       37 	P_status			fixed bin (35) parameter,
       38 	P_excludes		(*) char (*) parameter,
       39 	P_mode_name		char (*) parameter,
       40 	P_mode_value_ptr		ptr parameter,
       41 	P_mode_string_info_ptr	ptr parameter,
       42 	P_mode_string_info_ptr2	ptr parameter,
       43 	P_string			char (*) parameter;
       44 
       45 declare	(addr, addrel, char, hbound, index, lbound, length, ltrim, maxlength, null, substr, reverse, rtrim, unspec,
       46 	verify)			builtin;
       47 
       48 declare	cleanup			condition;
       49 
       50 declare	(counting_modes, dummy)	bit (1) aligned,
       51 	modes2			ptr,
       52 	modex			fixed bin,
       53 	must_cleanup		bit (1) aligned,
       54 	status			fixed bin (35),
       55 	string_len		fixed bin (21),
       56 	string_pos		fixed bin (21);	/* length of P_string used */
       57 
       58 declare	1 auto_mode		aligned like mode_value;
       59 
       60 declare	based_area		area based (areap),
       61 	areap			ptr;
       62 
       63 declare	BREAKS			char (10) static options (constant) initial (".,=^""
       64 	 "),					/* DOT COMMA EQUALS INVERT QUOTE NL VT FF TAB SPACE */
       65 	NUMERIC			char (12) static options (constant) init ("0123456789+-"),
       66 	LEGAL_CHARS		char (89) static options (constant)
       67 				initial (
       68 				"!#$%&'()*+-/0123456789:;<>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]_`abcdefghijklmnopqrstuvwxyz{|}~"
       69 				),
       70 	QUOTE			char (1) static options (constant) initial ("""");
       71 
       72 declare	(
       73 	error_table_$bad_mode_syntax,
       74 	error_table_$mode_string_truncated,
       75 	error_table_$undefined_mode,
       76 	error_table_$unimplemented_version
       77 	)			fixed bin (35) external;
       78 
       79 declare	cv_dec_check_		entry (char (*), fixed bin (35)) returns (fixed bin (35)),
       80 	get_system_free_area_	entry () returns (ptr),
       81 	requote_string_		entry (char (*)) returns (char (*));
       82 
  1     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  1     2 
  1     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  1     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  1     5 
  1     6 declare	mode_value_ptr		ptr,
  1     7 	number_of_modes		fixed bin;
  1     8 
  1     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  1    10 	  2 version		fixed bin,
  1    11 	  2 number		fixed bin,
  1    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  1    13 
  1    14 declare	mode_string_info_ptr	ptr;
  1    15 
  1    16 declare	1 mode_value		aligned based (mode_value_ptr),
  1    17 	  2 version		fixed bin,
  1    18 	  2 mode_name		char (32) unaligned,
  1    19 	  2 flags,
  1    20 	    3 boolean_valuep	bit (1) unaligned,
  1    21 	    3 numeric_valuep	bit (1) unaligned,
  1    22 	    3 char_valuep		bit (1) unaligned,
  1    23 	    3 boolean_value		bit (1) unaligned,
  1    24 	    3 pad1		bit (32) unaligned,
  1    25 	  2 numeric_value		fixed bin (35),
  1    26 	  2 char_value		char (32) varying,
  1    27 	  2 code			fixed bin (35),
  1    28 	  2 pad2			bit (36);
  1    29 
  1    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  1    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  1    32 
  1    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
       83 
       84 
       85 /* mode_string_$parse:
       86*   procedure (P_string, P_areap, P_mode_string_info_ptr, P_status); */
       87 
       88 	areap = P_areap;
       89 	if areap = null () then areap = get_system_free_area_ ();
       90 
       91 	must_cleanup = "1"b;
       92 	mode_string_info_ptr = null ();
       93 
       94 	number_of_modes = 0;
       95 	string_len = length (rtrim (P_string));
       96 	string_pos = 0;				/* scan from beginning of string */
       97 
       98 	counting_modes = "1"b;
       99 	do while (parse_mode (auto_mode));
      100 	end;					/* count modes -- don't do hard work */
      101 	counting_modes = "0"b;
      102 
      103 	on cleanup call parse_cleanup ();
      104 
      105 	allocate mode_string_info in (based_area);
      106 	mode_string_info.version = mode_string_info_version_2;
      107 
      108 	string_pos = 0;				/* start over from beginning for second scan */
      109 	number_of_modes = 0;			/* mode count used to permit special case "." */
      110 
      111 	do modex = 1 to mode_string_info.number;
      112 	     dummy = parse_mode (mode_string_info.modes (modex));
      113 	end;					/* ignore "more left" result, already have mode count */
      114 
      115 	P_mode_string_info_ptr = mode_string_info_ptr;
      116 	P_status = 0;
      117 
      118 	return;
      119 
      120 parse_cleanup:
      121      procedure ();
      122 
      123 	P_mode_string_info_ptr = null ();		/* if we are here, caller gets nothing */
      124 	if mode_string_info_ptr ^= null then free mode_string_info;
      125 
      126 	return;
      127 
      128      end parse_cleanup;
      129 
      130 mode_string_$get:
      131      entry (P_mode_string_info_ptr, P_string, P_status);
      132 
      133 	mode_string_info_ptr = P_mode_string_info_ptr;
      134 
      135 	if mode_string_info.version ^= mode_string_info_version_2 then call unsupported_version ();
      136 
      137 	string_pos = 0;
      138 	do modex = 1 to mode_string_info.number;
      139 	     call cons (mode_string_info.modes (modex));
      140 	end;
      141 
      142 (nostringsize):
      143 	substr (P_string, string_pos + 1) = ".";	/* clear out rest of string */
      144 	P_status = 0;
      145 
      146 	return;
      147 
      148 
      149 
      150 mode_string_$get_error:
      151      entry (P_mode_string_info_ptr, P_string, P_status);
      152 
      153 	mode_string_info_ptr = P_mode_string_info_ptr;
      154 
      155 	if mode_string_info.version ^= mode_string_info_version_2 then call unsupported_version ();
      156 
      157 	string_pos = 0;
      158 	do modex = 1 to mode_string_info.number;
      159 	     if mode_string_info.modes (modex).code ^= 0 then call cons (mode_string_info.modes (modex));
      160 	end;
      161 
      162 (nostringsize):
      163 	substr (P_string, string_pos + 1) = ".";	/* clear out rest of string */
      164 	P_status = 0;
      165 
      166 	return;
      167 
      168 mode_string_$delete:
      169      entry (P_mode_string_info_ptr, P_excludes, P_string, P_status);
      170 
      171 	mode_string_info_ptr = P_mode_string_info_ptr;
      172 	if mode_string_info.version ^= mode_string_info_version_2 then call unsupported_version ();
      173 
      174 	string_pos = 0;
      175 	do modex = 1 to mode_string_info.number;
      176 	     if ^excludep (mode_string_info.modes (modex).mode_name) then call cons (mode_string_info.modes (modex));
      177 	end;
      178 
      179 (nostringsize):
      180 	substr (P_string, string_pos + 1) = ".";
      181 	P_status = 0;
      182 
      183 	return;
      184 
      185 excludep:
      186      procedure (name) returns (bit (1) aligned);
      187 
      188 declare	name			char (32) parameter;
      189 declare	idx			fixed bin;
      190 
      191 	do idx = lbound (P_excludes, 1) to hbound (P_excludes, 1);
      192 	     if P_excludes (idx) = name then return ("1"b);
      193 	end;
      194 
      195 	return ("0"b);
      196 
      197      end excludep;
      198 
      199 /* This entrypoint finds the value of a single mode.  The value is returned in a mode_value structure which
      200*   is allocated by our caller.  If the pointer is null, just the error code is returned indicating whether or
      201*   not the mode named could be found in the mode string.  Otherwise, full info is returned.  The version
      202*   number must be filled in by our caller. */
      203 
      204 mode_string_$get_mode:
      205      entry (P_string, P_mode_name, P_mode_value_ptr, P_status);
      206 
      207 	mode_value_ptr = P_mode_value_ptr;
      208 
      209 	if mode_value_ptr ^= null ()
      210 	then if mode_value.version ^= mode_value_version_3 then call unsupported_version ();
      211 
      212 	counting_modes, must_cleanup = "0"b;
      213 	number_of_modes = 0;
      214 	string_len = length (rtrim (P_string));
      215 	string_pos = 0;
      216 
      217 	do while (parse_mode (auto_mode));
      218 	     if auto_mode.mode_name = P_mode_name then go to FOUND_MODE;
      219 	end;
      220 
      221 	if number_of_modes > 0
      222 	then if auto_mode.mode_name = P_mode_name then go to FOUND_MODE;
      223 
      224 	P_status = error_table_$undefined_mode;
      225 
      226 	return;
      227 
      228 FOUND_MODE:
      229 	if mode_value_ptr ^= null () then mode_value = auto_mode;
      230 
      231 	P_status = 0;
      232 
      233 	return;
      234 
      235 mode_string_$combine:
      236      entry (P_mode_string_info_ptr, P_mode_string_info_ptr2, P_string, P_status);
      237 
      238 	mode_string_info_ptr = P_mode_string_info_ptr;
      239 	modes2 = P_mode_string_info_ptr2;
      240 
      241 	if mode_string_info_ptr ^= null ()
      242 	then if mode_string_info.version ^= mode_string_info_version_2 then call unsupported_version ();
      243 
      244 	if modes2 ^= null ()
      245 	then if modes2 -> mode_string_info.version ^= mode_string_info_version_2 then call unsupported_version ();
      246 
      247 	string_pos = 0;
      248 	if mode_string_info_ptr ^= null ()
      249 	then if modes2 ^= null ()
      250 	     then do modex = 1 to mode_string_info.number;
      251 		     if ^present_in_second (mode_string_info.modes (modex).mode_name)
      252 		     then call cons (mode_string_info.modes (modex));
      253 		end;				/* loop thru first */
      254 	     else do modex = 1 to mode_string_info.number;
      255 		     call cons (mode_string_info.modes (modex));
      256 		end;
      257 
      258 	if modes2 ^= null ()
      259 	then do modex = 1 to modes2 -> mode_string_info.number;
      260 		call cons (modes2 -> mode_string_info.modes (modex));
      261 	     end;
      262 
      263 (nostringsize):
      264 	substr (P_string, string_pos + 1) = ".";
      265 	P_status = 0;
      266 
      267 	return;
      268 
      269 present_in_second:
      270      procedure (mn) returns (bit (1) aligned);
      271 declare	mn			char (32) parameter;
      272 declare	mx			fixed bin;
      273 
      274 	do mx = 1 to modes2 -> mode_string_info.number;
      275 	     if mn = modes2 -> mode_string_info.modes (mx).mode_name then return ("1"b);
      276 	end;
      277 
      278 	return ("0"b);				/* fell out */
      279 
      280      end present_in_second;
      281 
      282 parse_mode:
      283      procedure (P_mode) returns (bit (1) aligned);
      284 
      285 declare	1 P_mode			parameter aligned like mode_value,
      286 	1 mode_name		aligned,
      287 	  2 len			fixed bin (21),
      288 	  2 pos			fixed bin (21),
      289 	1 value			aligned like mode_name,
      290 	break			fixed bin,
      291 	(bool_value, bool_valuep, more_left, two_tokens)
      292 				bit (1) aligned,
      293 	char_value_overlay		char (length (P_mode.char_value)) based (addrel (addr (P_mode.char_value), 1));
      294 
      295 	unspec (P_mode) = ""b;			/* Initialize */
      296 	P_mode.version = mode_value_version_3;
      297 	bool_value, bool_valuep, two_tokens = "0"b;
      298 	mode_name.len = 0;
      299 
      300 GET_MODE_NAME:
      301 	call get_token (mode_name);
      302 	go to FIRST_TOKEN (break);
      303 
      304 FIRST_TOKEN (-1):					/* ILLEGAL CHAR */
      305 	call syntax_error ();
      306 
      307 FIRST_TOKEN (0):					/* DOT, legal as first char but not after COMMA */
      308 	if string_pos < string_len then call syntax_error ();
      309 	more_left = "0"b;
      310 	if mode_name.len > 0 then go to HAVE_ATOMIC_MODE;
      311 	if number_of_modes > 0 | bool_valuep then call syntax_error ();
      312 	return ("0"b);
      313 
      314 FIRST_TOKEN (1):					/* COMMA */
      315 	if mode_name.len = 0 then call syntax_error ();
      316 	go to HAVE_ATOMIC_MODE;
      317 
      318 FIRST_TOKEN (2):					/* EQUALS */
      319 	if mode_name.len = 0 then call syntax_error ();
      320 	number_of_modes = number_of_modes + 1;
      321 	two_tokens = "1"b;
      322 	value.len = 0;
      323 	go to GET_VALUE;
      324 
      325 FIRST_TOKEN (3):					/* INVERT */
      326 	if mode_name.len > 0 then call syntax_error ();
      327 	bool_valuep = "1"b;
      328 	bool_value = ^bool_value;
      329 	go to GET_MODE_NAME;
      330 
      331 FIRST_TOKEN (4):					/* QUOTE */
      332 	call syntax_error ();
      333 
      334 FIRST_TOKEN (5):					/* NEWLINE */
      335 FIRST_TOKEN (6):					/* VERTICAL TAB */
      336 FIRST_TOKEN (7):					/* FORMFEED */
      337 FIRST_TOKEN (8):					/* TAB */
      338 FIRST_TOKEN (9):					/* SPACE */
      339 	go to GET_MODE_NAME;
      340 
      341 GET_VALUE:
      342 	call get_token (value);
      343 	go to SECOND_TOKEN (break);
      344 
      345 SECOND_TOKEN (-1):					/* ILLEGAL_CHAR */
      346 	call syntax_error ();
      347 
      348 SECOND_TOKEN (0):					/* DOT */
      349 	if string_pos < string_len then call syntax_error ();
      350 	more_left = "0"b;
      351 
      352 SECOND_TOKEN (1):					/* COMMA */
      353 	if counting_modes then return (more_left);
      354 	if value.len > 0
      355 	then if verify (substr (P_string, value.pos + 1, value.len), NUMERIC) - 1 < 0 then P_mode.numeric_valuep = "1"b;
      356 	go to HAVE_VALUE;
      357 
      358 SECOND_TOKEN (2):					/* EQUALS */
      359 SECOND_TOKEN (3):					/* INVERT */
      360 	call syntax_error ();
      361 
      362 SECOND_TOKEN (4):					/* QUOTE */
      363 	if value.len > 0 then call syntax_error ();
      364 
      365 	P_mode.char_valuep = "1"b;
      366 
      367 	do while ("1"b);
      368 	     value.len = index (substr (P_string, string_pos + 1), QUOTE) - 1;
      369 	     if value.len < 0 then call syntax_error ();	/* Punt if no matching quote */
      370 
      371 	     if value.len + length (P_mode.char_value) > maxlength (P_mode.char_value) then call syntax_error ();
      372 	     P_mode.char_value = P_mode.char_value || substr (P_string, string_pos + 1, value.len);
      373 	     string_pos = string_pos + value.len + 1;	/* Gobble up everything to quote and step over it */
      374 
      375 	     if string_pos >= string_len then go to AT_END_OF_STRING;
      376 	     if substr (P_string, string_pos + 1, 1) ^= QUOTE
      377 	     then do while ("1"b);			/* Have whole string, now get break character */
      378 		     call get_token (mode_name);	/* get error if token_len > 0 */
      379 		     if break = 0 /* DOT */ & string_pos >= string_len then go to AT_END_OF_STRING;
      380 		     if break = 1 /* COMMA */ then go to HAVE_MODE;
      381 		     if break < 5 /* not WHITESPACE */ then call syntax_error ();
      382 		end;
      383 
      384 	     if length (P_mode.char_value) >= maxlength (P_mode.char_value) then call syntax_error ();
      385 	     P_mode.char_value = P_mode.char_value || QUOTE;
      386 	     string_pos = string_pos + 1;		/* Double quote.  Append a quote and look again */
      387 	end;
      388 
      389 AT_END_OF_STRING:
      390 	more_left = "0"b;
      391 	go to HAVE_MODE;
      392 
      393 SECOND_TOKEN (5):					/* NEWLINE */
      394 SECOND_TOKEN (6):					/* VERTICAL TAB */
      395 SECOND_TOKEN (7):					/* FORMFEED */
      396 SECOND_TOKEN (8):					/* TAB */
      397 SECOND_TOKEN (9):					/* SPACE */
      398 	go to GET_VALUE;
      399 
      400 HAVE_ATOMIC_MODE:
      401 	number_of_modes = number_of_modes + 1;
      402 
      403 	if counting_modes then return (more_left);
      404 
      405 	value.len = verify (reverse (substr (P_string, mode_name.pos + 1, mode_name.len)), NUMERIC) - 1;
      406 	if value.len < 0 then call syntax_error ();	/* Forbid numeric mode names */
      407 	else if value.len = 0
      408 	then do;					/* Boolean is the default */
      409 		P_mode.boolean_valuep = "1"b;
      410 		P_mode.boolean_value = ^bool_value;	/* started out false */
      411 		go to HAVE_MODE;
      412 	     end;
      413 
      414 	value.pos = mode_name.pos + mode_name.len - value.len;
      415 	mode_name.len = mode_name.len - value.len;
      416 	P_mode.numeric_valuep = "1"b;
      417 
      418 HAVE_VALUE:
      419 	if bool_valuep then call syntax_error ();	/* have ^MODEnnn or ^MODE=XXX */
      420 
      421 	if value.len > maxlength (P_mode.char_value) then call syntax_error ();
      422 	if value.len > 0 then P_mode.char_value = substr (P_string, value.pos + 1, value.len);
      423 
      424 	if P_mode.numeric_valuep
      425 	then begin;				/* All numeric, lets see if its a number */
      426 		P_mode.numeric_value = cv_dec_check_ (char_value_overlay, status);
      427 		if status ^= 0			/* we have MODE2+2 or numeric overflow */
      428 		then if two_tokens
      429 		     then do;			/* Permit foo=+ to be a character value */
      430 			     P_mode.char_valuep = "1"b;
      431 			     P_mode.numeric_valuep = "0"b;
      432 			end;
      433 		     else call syntax_error ();	/* Make foo+ an error */
      434 	     end;
      435 	else P_mode.char_valuep = "1"b;
      436 
      437 HAVE_MODE:
      438 	if mode_name.len > maxlength (P_mode.mode_name) then call syntax_error ();
      439 	P_mode.mode_name = substr (P_string, mode_name.pos + 1, mode_name.len);
      440 
      441 	return (more_left);
      442 
      443 get_token:
      444      procedure (P_token);
      445 
      446 declare	1 P_token			aligned parameter like mode_name;
      447 declare	1 token			aligned like mode_name;
      448 
      449 	token.pos = string_pos;
      450 
      451 	token.len = verify (substr (P_string, string_pos + 1, string_len - string_pos), LEGAL_CHARS) - 1;
      452 	if token.len < 0
      453 	then do;
      454 		token.len = string_len - string_pos;
      455 		string_pos = string_len;
      456 		break = 0;			/* DOT - end of mode string */
      457 		more_left = "0"b;
      458 	     end;
      459 	else do;
      460 		break = index (BREAKS, substr (P_string, string_pos + token.len + 1, 1)) - 1;
      461 		string_pos = string_pos + token.len + 1;
      462 		more_left = "1"b;
      463 	     end;
      464 
      465 	if token.len = 0 then return;			/* Just return break character */
      466 	if P_token.len > 0 then call syntax_error ();	/* Only one token to a token */
      467 
      468 	P_token = token;
      469 
      470 	return;
      471 
      472      end get_token;
      473 
      474      end parse_mode;
      475 
      476 cons:
      477      procedure (P_mode);
      478 
      479 declare	1 P_mode			like mode_value aligned parameter,
      480 	char_value_overlay		char (length (P_mode.char_value)) based (addrel (addr (P_mode.char_value), 1)),
      481 	modestr			char (101) varying; /* comma + invert + 32 + equals + 66 */
      482 
      483 	if string_pos = 0
      484 	then modestr = "";
      485 	else modestr = ",";
      486 
      487 	if P_mode.boolean_valuep & ^P_mode.boolean_value then modestr = modestr || "^";
      488 
      489 	modestr = modestr || rtrim (P_mode.mode_name);
      490 
      491 	if P_mode.numeric_valuep
      492 	then do;
      493 		modestr = modestr || "=";
      494 		modestr = modestr || rtrim (ltrim (char (P_mode.numeric_value)));
      495 	     end;
      496 	else if P_mode.char_valuep
      497 	then do;
      498 		modestr = modestr || "=";
      499 		if verify (P_mode.char_value, LEGAL_CHARS) - 1 ^< 0 | verify (P_mode.char_value, NUMERIC) - 1 < 0
      500 		then modestr = modestr || requote_string_ (char_value_overlay);
      501 		else modestr = modestr || P_mode.char_value;
      502 	     end;
      503 
      504 	if string_pos + length (modestr) > maxlength (P_string)
      505 	then do;
      506 (nostringsize):
      507 		substr (P_string, string_pos + 1) = ".";/* clear out rest of string */
      508 		P_status = error_table_$mode_string_truncated;
      509 		go to EGRESS;
      510 	     end;
      511 
      512 	substr (P_string, string_pos + 1, length (modestr)) = modestr;
      513 	string_pos = string_pos + length (modestr);
      514 
      515 	return;
      516 
      517      end cons;
      518 
      519 /* The following internal procedures are to facilitate debugging:
      520*   If an error occurs a breakpoint set in one of them will permit the site of
      521*   the error to be derived from a stack trace.  This code is left in the
      522*   production version since it isn't much less efficient than a GOTO and
      523*   the error cases needn't be superfast anyway.  */
      524 
      525 syntax_error:
      526      procedure ();
      527 
      528 	if must_cleanup then call parse_cleanup ();
      529 	P_status = error_table_$bad_mode_syntax;
      530 
      531 	go to EGRESS;
      532 
      533      end syntax_error;
      534 
      535 
      536 unsupported_version:
      537      procedure ();
      538 
      539 	P_status = error_table_$unimplemented_version;
      540 
      541 	go to EGRESS;
      542 
      543      end unsupported_version;
      544 
      545 
      546 EGRESS:
      547 	return;
      548 
      549      end mode_string_$parse;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.9  mode_string_.pl1                  >spec>install>1110>mode_string_.pl1
83           1    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAKS                          000060 constant        char(10)                 initial packed unaligned dcl 63 ref 460
LEGAL_CHARS                     000026 constant        char(89)                 initial packed unaligned dcl 63 ref 451 499
NUMERIC                         000055 constant        char(12)                 initial packed unaligned dcl 63 ref 354 405 499
P_areap                                parameter       pointer                  dcl 36 ref 33 88
P_excludes                             parameter       char                     array packed unaligned dcl 36 ref 168 191 191 192
P_mode                                 parameter       structure                level 1 dcl 479 in procedure "cons" set ref 476
P_mode                                 parameter       structure                level 1 dcl 285 in procedure "parse_mode" set ref
                                                                                  282 295*
P_mode_name                            parameter       char                     packed unaligned dcl 36 ref 204 218 221
P_mode_string_info_ptr                 parameter       pointer                  dcl 36 set ref 33 115* 123* 130 133 150 153 168 171
                                                                                  235 238
P_mode_string_info_ptr2                parameter       pointer                  dcl 36 ref 235 239
P_mode_value_ptr                       parameter       pointer                  dcl 36 ref 204 207
P_status                               parameter       fixed bin(35,0)          dcl 36 set ref 33 116* 130 144* 150 164* 168 181*
                                                                                  204 224* 231* 235 265* 508* 529* 539*
P_string                               parameter       char                     packed unaligned dcl 36 set ref 33 95 130 142* 150
                                                                                  162* 168 179* 204 214 235 263* 354 368 372 376 405
                                                                                  422 439 451 460 504 506* 512*
P_token                                parameter       structure                level 1 dcl 446 set ref 443 468*
QUOTE                           003040 constant        char(1)                  initial packed unaligned dcl 63 ref 368 376 385
addr                                                   builtin function         dcl 45 ref 426 499
addrel                                                 builtin function         dcl 45 ref 426 499
areap                           000146 automatic       pointer                  dcl 60 set ref 88* 89 89* 105
auto_mode                       000117 automatic       structure                level 1 dcl 58 set ref 99* 217* 228
based_area                             based           area(1024)               dcl 60 ref 105
bool_value                      000231 automatic       bit(1)                   dcl 285 set ref 297* 328* 328 410
bool_valuep                     000232 automatic       bit(1)                   dcl 285 set ref 297* 311 327* 418
boolean_value            11(03)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 479 in procedure "cons" ref 487
boolean_value            11(03)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 285 in procedure "parse_mode" set
                                                                                  ref 410*
boolean_valuep           11            parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 479 in procedure "cons" ref 487
boolean_valuep           11            parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 285 in procedure "parse_mode" set
                                                                                  ref 409*
break                           000230 automatic       fixed bin(17,0)          dcl 285 set ref 302 343 379 380 381 456* 460*
char                                                   builtin function         dcl 45 ref 494
char_value               13            parameter       varying char(32)         level 2 in structure "P_mode" dcl 285 in procedure
                                                                                  "parse_mode" set ref 371 371 372* 372 384 384 385*
                                                                                  385 421 422* 426 426 426
char_value               13            parameter       varying char(32)         level 2 in structure "P_mode" dcl 479 in procedure
                                                                                  "cons" set ref 499 499 499 499 499 501
char_value_overlay                     based           char                     packed unaligned dcl 479 in procedure "cons" set ref
                                                                                  499*
char_value_overlay                     based           char                     packed unaligned dcl 285 in procedure "parse_mode"
                                                                                  set ref 426*
char_valuep              11(02)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 285 in procedure "parse_mode" set
                                                                                  ref 365* 430* 435*
char_valuep              11(02)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 479 in procedure "cons" ref 496
cleanup                         000100 stack reference condition                dcl 48 ref 103
code                     26            based           fixed bin(35,0)          array level 3 dcl 1-9 set ref 159
counting_modes                  000106 automatic       bit(1)                   dcl 50 set ref 98* 101* 212* 352 403
cv_dec_check_                   000020 constant        entry                    external dcl 79 ref 426
dummy                           000107 automatic       bit(1)                   dcl 50 set ref 112*
error_table_$bad_mode_syntax    000010 external static fixed bin(35,0)          dcl 72 ref 529
error_table_$mode_string_truncated
                                000012 external static fixed bin(35,0)          dcl 72 ref 508
error_table_$undefined_mode     000014 external static fixed bin(35,0)          dcl 72 ref 224
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 72 ref 539
flags                    11            parameter       structure                level 2 in structure "P_mode" dcl 285 in procedure
                                                                                  "parse_mode"
flags                    11            parameter       structure                level 2 in structure "P_mode" dcl 479 in procedure
                                                                                  "cons"
get_system_free_area_           000022 constant        entry                    external dcl 79 ref 89
hbound                                                 builtin function         dcl 45 ref 191
idx                             000204 automatic       fixed bin(17,0)          dcl 189 set ref 191* 192*
index                                                  builtin function         dcl 45 ref 368 460
lbound                                                 builtin function         dcl 45 ref 191
len                             000224 automatic       fixed bin(21,0)          level 2 in structure "mode_name" dcl 285
                                                                                  in procedure "parse_mode" set ref 298* 310 314 318
                                                                                  325 405 414 415* 415 437 439
len                                    parameter       fixed bin(21,0)          level 2 in structure "P_token" dcl 446 in procedure
                                                                                  "get_token" set ref 466
len                             000226 automatic       fixed bin(21,0)          level 2 in structure "value" dcl 285 in procedure
                                                                                  "parse_mode" set ref 322* 354 354 362 368* 369 371
                                                                                  372 373 405* 406 407 414 415 421 422 422
len                             000244 automatic       fixed bin(21,0)          level 2 in structure "token" dcl 447 in procedure
                                                                                  "get_token" set ref 451* 452 454* 460 461 465
length                                                 builtin function         dcl 45 ref 95 214 371 384 426 426 499 499 504 512
                                                                                  513
ltrim                                                  builtin function         dcl 45 ref 494
maxlength                                              builtin function         dcl 45 ref 371 384 421 437 504
mn                                     parameter       char(32)                 packed unaligned dcl 271 ref 269 275
mode_name                 1            parameter       char(32)                 level 2 in structure "P_mode" packed packed
                                                                                  unaligned dcl 285 in procedure "parse_mode" set
                                                                                  ref 437 439*
mode_name                 1            parameter       char(32)                 level 2 in structure "P_mode" packed packed
                                                                                  unaligned dcl 479 in procedure "cons" ref 489
mode_name                       000224 automatic       structure                level 1 dcl 285 in procedure "parse_mode" set ref
                                                                                  300* 378*
mode_name                 3            based           char(32)                 array level 3 in structure "mode_string_info" packed
                                                                                  packed unaligned dcl 1-9 in procedure
                                                                                  "mode_string_$parse" set ref 176* 251* 275
mode_name                 1     000117 automatic       char(32)                 level 2 in structure "auto_mode" packed packed
                                                                                  unaligned dcl 58 in procedure "mode_string_$parse"
                                                                                  set ref 218 221
mode_string_info                       based           structure                level 1 dcl 1-9 set ref 105 124
mode_string_info_ptr            000154 automatic       pointer                  dcl 1-14 set ref 92* 105* 106 111 112 115 124 124
                                                                                  133* 135 138 139 153* 155 158 159 159 171* 172 175
                                                                                  176 176 238* 241 241 248 248 251 251 254 255
mode_string_info_version_2             constant        fixed bin(17,0)          initial dcl 1-30 ref 106 135 155 172 241 244
mode_value                             based           structure                level 1 dcl 1-16 set ref 228*
mode_value_ptr                  000150 automatic       pointer                  dcl 1-6 set ref 207* 209 209 228 228
mode_value_version_3                   constant        fixed bin(17,0)          initial dcl 1-30 ref 209 296
modes                     2            based           structure                array level 2 dcl 1-9 set ref 112* 139* 159* 176*
                                                                                  251* 255* 260*
modes2                          000110 automatic       pointer                  dcl 50 set ref 239* 244 244 248 258 258 260 274 275
modestr                         000254 automatic       varying char(101)        dcl 479 set ref 483* 485* 487* 487 489* 489 493* 493
                                                                                  494* 494 498* 498 499* 499 501* 501 504 512 512
                                                                                  513
modex                           000112 automatic       fixed bin(17,0)          dcl 50 set ref 111* 112* 138* 139* 158* 159 159*
                                                                                  175* 176 176* 248* 251 251* 254* 255* 258* 260*
more_left                       000233 automatic       bit(1)                   dcl 285 set ref 309* 350* 352 389* 403 441 457* 462*
must_cleanup                    000113 automatic       bit(1)                   dcl 50 set ref 91* 212* 528
mx                              000214 automatic       fixed bin(17,0)          dcl 272 set ref 274* 275*
name                                   parameter       char(32)                 packed unaligned dcl 188 ref 185 192
null                                                   builtin function         dcl 45 ref 89 92 123 124 209 228 241 244 248 248 258
number                    1            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 105* 111 124 138 158 175 248
                                                                                  254 258 274
number_of_modes                 000152 automatic       fixed bin(17,0)          dcl 1-6 set ref 94* 105 105 109* 213* 221 311 320*
                                                                                  320 400* 400
numeric_value            12            parameter       fixed bin(35,0)          level 2 in structure "P_mode" dcl 479 in procedure
                                                                                  "cons" ref 494
numeric_value            12            parameter       fixed bin(35,0)          level 2 in structure "P_mode" dcl 285 in procedure
                                                                                  "parse_mode" set ref 426*
numeric_valuep           11(01)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 479 in procedure "cons" ref 491
numeric_valuep           11(01)        parameter       bit(1)                   level 3 in structure "P_mode" packed packed
                                                                                  unaligned dcl 285 in procedure "parse_mode" set
                                                                                  ref 354* 416* 424 431*
pos                       1     000226 automatic       fixed bin(21,0)          level 2 in structure "value" dcl 285 in procedure
                                                                                  "parse_mode" set ref 354 414* 422
pos                       1     000244 automatic       fixed bin(21,0)          level 2 in structure "token" dcl 447 in procedure
                                                                                  "get_token" set ref 449*
pos                       1     000224 automatic       fixed bin(21,0)          level 2 in structure "mode_name" dcl 285
                                                                                  in procedure "parse_mode" set ref 405 414 439
requote_string_                 000024 constant        entry                    external dcl 79 ref 499
reverse                                                builtin function         dcl 45 ref 405
rtrim                                                  builtin function         dcl 45 ref 95 214 489 494
status                          000114 automatic       fixed bin(35,0)          dcl 50 set ref 426* 427
string_len                      000115 automatic       fixed bin(21,0)          dcl 50 set ref 95* 214* 307 348 375 379 451 454 455
string_pos                      000116 automatic       fixed bin(21,0)          dcl 50 set ref 96* 108* 137* 142 157* 162 174* 179
                                                                                  215* 247* 263 307 348 368 372 373* 373 375 376 379
                                                                                  386* 386 449 451 451 454 455* 460 461* 461 483 504
                                                                                  506 512 513* 513
substr                                                 builtin function         dcl 45 set ref 142* 162* 179* 263* 354 368 372 376
                                                                                  405 422 439 451 460 506* 512*
token                           000244 automatic       structure                level 1 dcl 447 set ref 468
two_tokens                      000234 automatic       bit(1)                   dcl 285 set ref 297* 321* 427
unspec                                                 builtin function         dcl 45 set ref 295*
value                           000226 automatic       structure                level 1 dcl 285 set ref 341*
verify                                                 builtin function         dcl 45 ref 354 405 451 499 499
version                                based           fixed bin(17,0)          level 2 in structure "mode_value" dcl 1-16
                                                                                  in procedure "mode_string_$parse" set ref 209
version                                parameter       fixed bin(17,0)          level 2 in structure "P_mode" dcl 285 in procedure
                                                                                  "parse_mode" set ref 296*
version                                based           fixed bin(17,0)          level 2 in structure "mode_string_info" dcl 1-9
                                                                                  in procedure "mode_string_$parse" set ref 106* 135
                                                                                  155 172 241 244

NAMES DECLARED BY EXPLICIT CONTEXT.
AT_END_OF_STRING                001573 constant        label                    dcl 389 ref 375 379
EGRESS                          001163 constant        label                    dcl 546 ref 509 531 541
FIRST_TOKEN                     000000 constant        label                    array(-1:9) dcl 304 ref 302
FOUND_MODE                      000736 constant        label                    dcl 228 ref 218 221
GET_MODE_NAME                   001327 constant        label                    dcl 300 ref 329 334
GET_VALUE                       001402 constant        label                    dcl 341 ref 323 393
HAVE_ATOMIC_MODE                001576 constant        label                    dcl 400 ref 310 316
HAVE_MODE                       001753 constant        label                    dcl 437 ref 380 391 411
HAVE_VALUE                      001652 constant        label                    dcl 418 ref 356
SECOND_TOKEN                    000013 constant        label                    array(-1:9) dcl 345 ref 343
cons                            002057 constant        entry                    internal dcl 476 ref 139 159 176 251 255 260
excludep                        001207 constant        entry                    internal dcl 185 ref 176
get_token                       001772 constant        entry                    internal dcl 443 ref 300 341 378
mode_string_$combine            000755 constant        entry                    external dcl 235
mode_string_$delete             000504 constant        entry                    external dcl 168
mode_string_$get                000315 constant        entry                    external dcl 130
mode_string_$get_error          000405 constant        entry                    external dcl 150
mode_string_$get_mode           000622 constant        entry                    external dcl 204
mode_string_$parse              000127 constant        entry                    external dcl 33
parse_cleanup                   001165 constant        entry                    internal dcl 120 ref 103 528
parse_mode                      001313 constant        entry                    internal dcl 282 ref 99 112 217
present_in_second               001256 constant        entry                    internal dcl 269 ref 251
syntax_error                    002370 constant        entry                    internal dcl 525 ref 304 307 311 314 318 325 331 345
                                                                                  348 358 362 369 371 381 384 406 418 421 433 437
                                                                                  466
unsupported_version             002403 constant        entry                    internal dcl 536 ref 135 155 172 209 241 244

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3320        3346    3044        3330
Length      3564    3044        26         201     254           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mode_string_$parse                  272 external procedure  is an external procedure.  
on unit on line 103                  64 on unit               
parse_cleanup                        64 internal procedure  is called by several nonquick procedures.  
excludep                                internal procedure  shares stack frame of external procedure mode_string_$parse.  
present_in_second                       internal procedure  shares stack frame of external procedure mode_string_$parse.  
parse_mode                              internal procedure  shares stack frame of external procedure mode_string_$parse.  
begin block on line 424                 begin block         shares stack frame of external procedure mode_string_$parse.  
get_token                               internal procedure  shares stack frame of external procedure mode_string_$parse.  
cons                                    internal procedure  shares stack frame of external procedure mode_string_$parse.  
syntax_error                            internal procedure  shares stack frame of external procedure mode_string_$parse.  
unsupported_version                     internal procedure  shares stack frame of external procedure mode_string_$parse.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mode_string_$parse       000106 counting_modes              mode_string_$parse
                         000107 dummy                       mode_string_$parse
                         000110 modes2                      mode_string_$parse
                         000112 modex                       mode_string_$parse
                         000113 must_cleanup                mode_string_$parse
                         000114 status                      mode_string_$parse
                         000115 string_len                  mode_string_$parse
                         000116 string_pos                  mode_string_$parse
                         000117 auto_mode                   mode_string_$parse
                         000146 areap                       mode_string_$parse
                         000150 mode_value_ptr              mode_string_$parse
                         000152 number_of_modes             mode_string_$parse
                         000154 mode_string_info_ptr        mode_string_$parse
                         000204 idx                         excludep
                         000214 mx                          present_in_second
                         000224 mode_name                   parse_mode
                         000226 value                       parse_mode
                         000230 break                       parse_mode
                         000231 bool_value                  parse_mode
                         000232 bool_valuep                 parse_mode
                         000233 more_left                   parse_mode
                         000234 two_tokens                  parse_mode
                         000244 token                       get_token
                         000254 modestr                     cons

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
shorten_stack       ext_entry_desc      int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_dec_check_                 get_system_free_area_         requote_string_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode_syntax  error_table_$mode_string_truncated                          error_table_$undefined_mode
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 000122        88 000146        89 000151        91 000163        92 000165        94 000167        95 000170
     96 000210        98 000211        99 000213       100 000221       101 000222       103 000223       105 000245
    106 000256       108 000260       109 000261       111 000262       112 000271       113 000303       115 000305
    116 000307       118 000310       130 000311       133 000334       135 000337       137 000343       138 000344
    139 000355       140 000365       142 000367       144 000401       146 000402       150 000403       153 000424
    155 000427       157 000433       158 000434       159 000445       160 000461       162 000463       164 000475
    166 000476       168 000477       171 000530       172 000533       174 000537       175 000540       176 000551
    177 000577       179 000601       181 000613       183 000614       204 000615       207 000644       209 000650
    212 000660       213 000662       214 000663       215 000703       217 000704       218 000711       219 000720
    221 000721       224 000732       226 000735       228 000736       231 000746       233 000747       235 000750
    238 000774       239 000777       241 001003       244 001013       247 001023       248 001024       251 001045
    253 001073       254 001076       255 001107       256 001117       258 001121       260 001135       261 001145
    263 001147       265 001161       267 001162       546 001163       120 001164       123 001172       124 001175
    126 001206       185 001207       191 001211       192 001223       193 001251       195 001253       269 001256
    274 001260       275 001271       276 001306       278 001310       282 001313       295 001315       296 001321
    297 001323       298 001326       300 001327       302 001331       304 001333       307 001334       309 001340
    310 001341       311 001343       312 001350       314 001353       316 001356       318 001357       320 001362
    321 001363       322 001365       323 001366       325 001367       327 001372       328 001374       329 001377
    331 001400       334 001401       341 001402       343 001404       345 001406       348 001407       350 001413
    352 001414       354 001422       356 001443       358 001444       362 001445       365 001450       368 001454
    369 001473       371 001475       372 001504       373 001522       375 001526       376 001530       378 001534
    379 001536       380 001543       381 001546       382 001551       384 001552       385 001560       386 001571
    387 001572       389 001573       391 001574       393 001575       400 001576       403 001577       405 001605
    406 001621       407 001624       409 001625       410 001631       411 001637       414 001640       415 001644
    416 001646       418 001652       421 001655       422 001661       424 001676       426 001703       427 001734
    430 001740       431 001744       432 001746       433 001747       424 001750       435 001751       437 001753
    439 001757       441 001767       443 001772       449 001774       451 001776       452 002013       454 002014
    455 002017       456 002021       457 002022       458 002023       460 002024       461 002036       462 002041
    465 002043       466 002046       468 002051       470 002056       476 002057       483 002061       485 002065
    487 002071       489 002107       491 002133       493 002136       494 002145       495 002213       496 002214
    498 002217       499 002226       501 002317       504 002332       506 002343       508 002352       509 002355
    512 002356       513 002365       515 002367       525 002370       528 002371       529 002377       531 002402
    536 002403       539 002404       541 002407


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
