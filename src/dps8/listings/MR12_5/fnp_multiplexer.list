	COMPILATION LISTING OF SEGMENT fnp_multiplexer
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1945.59_Mon_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,^ifthendo */
       13 fnp_multiplexer:
       14      proc;
       15 
       16 /* This is the called multiplexer module for FNP channels. It calls dn355
       17*   *  to pass mailboxes on to the FNP. Important data structures are:
       18*   *	fnp_info (in dn355_data) : info about the FNP as a whole
       19*   *	pcb (physical channel block) : allocated in tty_buf. Contains per-channel info
       20*   *
       21**/
       22 
       23 /* Written 08/15/78 by Robert Coren */
       24 /* Modified 04/11/79 by Robert Coren to handle all modes at once */
       25 /* Modified 06/29/79 by Bernard Greenberg for FNP echo negotiation */
       26 /* Modified 79 Aug 21 by Art Beattie to support 64K DN6670s. */
       27 /* Modified various times in 1980 by Robert Coren to add metering */
       28 /* Modified May 1981 by Robert Coren to keep get_meters order from using user-supplied
       29*   pointer while FNP channel is locked */
       30 /* Modified late summer 1981 by Robert Coren to handle tandd_attach order and COLTS channel */
       31 /* Modified fall 1981 by Robert Coren to assign smaller buffer sizes */
       32 /* Modified November 1981 by Robert Coren to fix bug whereby terminate_multiplexer
       33*   didn't initialize ttybp */
       34 /* Modified June 1982 by Robert Coren to correct precision of FNP addresses. */
       35 /* Modified November 1983 by Robert Coren to make priv_control check the pointer set by get_fnp_meters */
       36 /* Modified 83-12-16 BIM for io_manager calls */
       37 /* Modified 84-05-18 BIM for correction to ioa_ strings */
       38 /* Modified 1984-08-02 BIM for bug in shutdown_mpx handling of booting fnp */
       39 /* Modified 1984-09-25 BIM for paged mode fnp load. (page table filling) */
       40 /* Modified September 1984 by Robert Coren to free copied meters in
       41*   terminate_multiplexer and to exit loop in send_global if FNP is down */
       42 /* Modified November 1984 by Robert Coren to zero pad fields in copied meters
       43*   so random junk from the FNP doesn't get left in tty_area */
       44 /* Modified November 1984 by Robert Coren to use tty_area_manager to allocate and free saved meters */
       45 
       46 /****^  HISTORY COMMENTS:
       47*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
       48*     audit(86-06-19,Beattie), install(86-07-08,MR12.0-1089):
       49*     To process 256-bit echo negotiation break tables.
       50*  2) change(86-12-12,Beattie), approve(86-12-17,MECR0005),
       51*     audit(86-12-12,Brunelle), install(86-12-17,MR12.0-1250):
       52*     Declare an argument in call to fnp_util$free_page_table to accept the
       53*     error code being returned. (phx20712)
       54*  3) change(86-12-12,Beattie), approve(86-12-29,MCR7598),
       55*     audit(87-01-07,Brunelle), install(87-01-12,MR12.0-1268):
       56*     Declare an argument in call to fnp_util$free_page_table to accept the
       57*     error code being returned. (phx20712)
       58*                                                   END HISTORY COMMENTS */
       59 
       60 
       61 /* PARAMETERS */
       62 
       63 dcl  a_devx fixed bin;				/* devx of FNP channel */
       64 dcl  a_init_info_ptr ptr;
       65 dcl  a_fnpp ptr;
       66 dcl  a_subchan fixed bin;
       67 dcl  a_chainp ptr;
       68 dcl  a_mi_flag bit (1) aligned;
       69 dcl  a_code fixed bin (35);
       70 dcl  a_output_ptr ptr;
       71 dcl  a_order char (*);
       72 dcl  a_data_ptr ptr;
       73 dcl  a_mode_list_ptr ptr;
       74 dcl  a_modes char (*);
       75 
       76 
       77 /* AUTOMATIC */
       78 
       79 dcl  code fixed bin (35);				/* standard system error code */
       80 dcl  devx fixed bin;				/* of FNP channel */
       81 dcl  my_chan_name char (1);
       82 dcl  dno fixed bin;					/* FNP number */
       83 dcl  pcb_space fixed bin;
       84 dcl  space_needed fixed bin;
       85 dcl  output_ptr ptr;				/* pointer to caller's output data */
       86 dcl  chanx fixed bin;				/* index of PCB */
       87 dcl  output_length fixed bin;				/* number of output characters */
       88 dcl  sourcep ptr;
       89 dcl  (i, j) fixed bin;
       90 dcl  lastp ptr;					/* pointer to last buffer in already-exisitng chain */
       91 
       92 dcl  order char (32);
       93 dcl  data_ptr ptr;					/* pointer to order info structure */
       94 dcl  set_write_status bit (1);
       95 dcl  locked bit (1);
       96 dcl  old_mask fixed bin (71);
       97 dcl  mask_ptwp ptr;
       98 dcl  queue_locked bit (1);
       99 dcl  mylock bit (1);
      100 dcl  opcode fixed bin (8);				/* mailbox opcode */
      101 dcl  alter_type fixed bin (8);			/* alter parameters subop */
      102 dcl  check bit (1);
      103 dcl  mbx_data_len fixed bin;				/* in bits */
      104 dcl  mbx_data bit (4 * 36) based (addr (mbx_data_long));
      105 dcl  mbx_data_long bit (8 * 36);
      106 dcl  alter_data bit (4 * 36) varying;
      107 dcl  dumpin bit (1);
      108 dcl  dumpout bit (1);
      109 dcl  get_meters bit (1);
      110 dcl  temp_saved_meters_ptr ptr;
      111 dcl  meter_ptr ptr;
      112 dcl  lcmp ptr;
      113 dcl  fnp_meters_ptr ptr;
      114 dcl  ret_meters_ptr ptr;
      115 dcl  local_line_type fixed bin;
      116 dcl  phone_no_len fixed bin;				/* in bits */
      117 dcl  phone_digits (32) bit (6);
      118 dcl  next_digit fixed bin (6) unsigned;			/* value of next dialout digit */
      119 dcl  digit_pos fixed bin;				/* how far along we are in phone number */
      120 dcl  opend bit (1);					/* whether or not output is pending */
      121 
      122 dcl  modex fixed bin;
      123 dcl  mode_name char (8);
      124 dcl  mode_on bit (1);				/* mode to be turned on or off */
      125 dcl  mode_set (36) bit (1);
      126 dcl  hndlquit_set bit (1);
      127 dcl  base_len fixed bin;
      128 dcl  block_len fixed bin;
      129 dcl  chars_per_buf fixed bin;
      130 dcl  chars_per_sec fixed bin;
      131 
      132 dcl  wire_arg fixed bin (71);
      133 dcl  wire_ptr ptr;
      134 dcl  hsla_flag bit (1);
      135 dcl  old_flag bit (1);
      136 dcl  pcb_space_ptr ptr;
      137 dcl  prev_la_no fixed bin;
      138 dcl  la_no fixed bin;
      139 dcl  subchan fixed bin;
      140 dcl  his_fnp_no fixed bin;				/* FNP number in supplied channel name */
      141 dcl  pcbx fixed bin;
      142 dcl  found bit (1);
      143 dcl  past bit (1);
      144 dcl  n_fnp_words fixed bin;
      145 dcl  ignore bit (1);
      146 dcl  name char (32);
      147 dcl  temp_addr fixed bin;
      148 dcl  fnp_dump_ptr ptr;
      149 dcl  dump_patch_space fixed bin;			/* amount of space required by an fnp_(dump patch) order */
      150 dcl  dump_patch_time fixed bin (71);			/* clock time when a dump or patch order was initiated */
      151 
      152 
      153 dcl  1 dump_fnp_data aligned,				/* command data for dump_fnp & patch_fnp */
      154        2 abs_addr fixed bin (24),			/* absolute address of ring-zero buffer */
      155        2 fnp_addr fixed bin (18) unsigned unaligned,	/* address in FNP */
      156        2 fnp_len fixed bin (18) unsigned unaligned;	/* number of 18-bit words */
      157 
      158 dcl  1 fnp_break_data aligned,			/* command data for fnp_break order */
      159        2 lineno fixed bin (17) unal,			/* line number, derived from tty name */
      160        2 fnp_addr fixed bin (18) unsigned unal,
      161        2 action fixed bin (17) unal,
      162        2 flags bit (18) unal;
      163 
      164 dcl  1 echnego_break_table aligned,
      165        2 words (0:15) unaligned,
      166          3 bits bit (16) unaligned,
      167          3 pad bit (2) unaligned;
      168 
      169 /* BASED */
      170 
      171 dcl  based_fb_word fixed bin based;
      172 dcl  based_bit1 bit (1) based;
      173 dcl  based_bit2 bit (2) based;
      174 dcl  based_bit18 bit (18) based;
      175 dcl  based_bit72 bit (72) based;
      176 dcl  based_bit108 bit (108) based;
      177 dcl  based_echo_table_bits bit (WIRED_ECHO_BREAK_SIZE + 1) based;
      178 dcl  fnp_data (n_fnp_words) bit (18) based;
      179 
      180 dcl  phone_chars char (32) varying based;		/* phone number passed with dial_out order */
      181 
      182 dcl  1 wr_stat aligned based,				/* for write_status */
      183        2 ev_chan fixed bin (71),
      184        2 output_pending bit (1);
      185 
      186 dcl  1 rd_stat aligned based,				/* for read_status */
      187        2 ev_chan fixed bin (71),
      188        2 input_available bit (1);
      189 
      190 dcl  1 dump_fnp_info based (data_ptr) aligned,		/* structure passed for dump_fnp and patch_fnp */
      191        2 fnp_address fixed bin (24),
      192        2 fnp_len fixed bin,				/* number of 18=bit words */
      193        2 bufp ptr,					/* pointer to caller's buffer */
      194        2 old_value_ptr ptr;				/* pointer to previous values (patch only) */
      195 
      196 dcl  1 fnp_break_info aligned based (data_ptr),		/* structure passed on fnp_break order */
      197        2 chan_name char (6),				/* tty name, optional */
      198        2 fnp_addr fixed bin,				/* addr in fnp to set break */
      199        2 action fixed bin,				/* request type */
      200        2 flags bit (36);				/* special action flags */
      201 
      202 dcl  1 echo_start_data aligned based (data_ptr),		/* Echo starting data */
      203        2 ctr fixed bin (35),				/* Synchronization counter */
      204        2 screenleft fixed bin (35);			/* Length left on screen */
      205 
      206 /* BUILTINS & CONDITIONS */
      207 
      208 dcl  (addr, addrel, bin, bit, clock, divide, hbound, length, null, ptr, rel, rtrim, size, stac, stacq, string, substr,
      209      unspec) builtin;
      210 
      211 dcl  area condition;
      212 
      213 
      214 /* ENTRIES */
      215 
      216 dcl  pxss$notify entry (fixed bin);
      217 dcl  dn355$send_wcd entry (ptr, ptr, fixed bin (8), fixed bin, bit (*));
      218 dcl  dn355$send_global_wcd entry (ptr, fixed bin (8), fixed bin, bit (*));
      219 dcl  dn355$hangup_fnp_lines entry (fixed bin);
      220 dcl  dn355$process_interrupt_queue entry (fixed bin);
      221 dcl  dn355$interrupt entry;
      222 dcl  fnp_util$fill_page_table entry (fixed bin, fixed bin (35));
      223 dcl  fnp_util$free_page_table entry (fixed bin, fixed bin (35));
      224 dcl  fnp_util$unwire entry (fixed bin, fixed bin (35));
      225 dcl  tty_lock$lock_lcte entry (ptr, fixed bin (35));
      226 dcl  tty_area_manager$allocate entry (fixed bin, ptr);
      227 dcl  tty_area_manager$free entry (fixed bin, ptr);
      228 dcl  lock$lock_fast entry (pointer);
      229 dcl  lock$unlock_fast entry (pointer);
      230 dcl  syserr entry options (variable);
      231 dcl  syserr$error_code entry options (variable);
      232 dcl  parse_tty_name_ entry (char (*), fixed bin, bit (1), fixed bin, fixed bin);
      233 dcl  parse_fnp_name_ entry (char (*), fixed bin);
      234 dcl  pxss$addevent entry (fixed bin);
      235 dcl  pxss$delevent entry (fixed bin);
      236 dcl  pxss$wait entry;
      237 
      238 /* EXTERNAL STATIC */
      239 
      240 dcl  (
      241      error_table_$noalloc,
      242      error_table_$undefined_order_request,
      243      error_table_$bad_mode,
      244      error_table_$bad_channel,
      245      error_table_$buffer_big,
      246      error_table_$invalid_write,
      247      error_table_$dev_offset_out_of_bounds,
      248      error_table_$seglock,
      249      error_table_$mpx_down,
      250      error_table_$timeout,
      251      error_table_$unimplemented_version,
      252      error_table_$no_channel_meters,
      253      error_table_$resource_not_free,
      254      error_table_$io_assigned,
      255      error_table_$io_not_assigned,
      256      error_table_$io_not_configured,
      257      error_table_$io_not_available,
      258      error_table_$invalid_state
      259      ) ext static fixed bin (35);
      260 
      261 dcl  pds$processid ext static bit (36) aligned;
      262 dcl  pds$process_group_id ext static char (32) aligned;
      263 
      264 /* INTERNAL STATIC */
      265 
      266 /* The following are declared here because syserr_constants.incl.pl1 cannot
      267*   be used, owing to a naming conflict with mcs_interrupt_info.incl.pl1.
      268**/
      269 
      270 dcl  ANNOUNCE fixed bin internal static options (constant) init (0);
      271 dcl  CRASH_SYSTEM fixed bin internal static options (constant) init (1);
      272 
      273 dcl  DCW_LIST_SIZE fixed bin int static options (constant) init (16);
      274 dcl  DUMP_PATCH_LIMIT fixed bin (35) int static options (constant) init (10000000);
      275 						/* i.e., 10 seconds */
      276 
      277 /* The following facts about the the lists of modes below are IMPORTANT.
      278*   *  The modes which have corresponding alter_parameters subtypes are the same as the modes
      279*   *  that are valid for asynchronous lines only, and no data is associated with the
      280*   *  alter_parameters other than on/off, with the following exceptions:
      281*   *	blk_xfer and iflow require additional data (buffer sizes)
      282*   *	hndlquit is valid for any line, but is expressed by alter_parameters
      283*   *
      284*   *  Therefore, hndlquit is handled explicitly, and blk_xfer and iflow must come after those modes having alter_paramters
      285*   *  subop types. Anyone modifying these lists should be aware of this circumstance.
      286**/
      287 
      288 dcl  good_modes (1) char (8) int static options (constant)	/* modes recognized for all lines */
      289 	init ("hndlquit");
      290 
      291 dcl  async_only_modes (15) char (8) int static options (constant)
      292 						/* modes recognized for async lines only */
      293 	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "replay", "polite", "breakall", "prefixnl",
      294 	"no_outp", "8bit", "oddp", "oflow", "iflow", "blk_xfer");
      295 
      296 dcl  IFLOW_INDEX fixed bin internal static options (constant) init (14);
      297 dcl  BLK_XFER_INDEX fixed bin internal static options (constant) init (15);
      298 
      299 dcl  full_dpx_modes (7) char (8) int static options (constant)
      300 						/* modes requiring full duplex line type */
      301 	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "iflow", "oflow");
      302 
      303 dcl  mode_alter_types (13) fixed bin (8) int static options (constant)
      304 						/* alter_paramters subops corresponding to modes */
      305 	init (8,					/* crecho */
      306 	14,					/* tabecho */
      307 	9,					/* lfecho */
      308 	20,					/* echoplex */
      309 	3,					/* fulldpx */
      310 	23,					/* replay */
      311 	24,					/* polite */
      312 	27,					/* breakall */
      313 	28,					/* prefixnl */
      314 	33,					/* no_outp */
      315 	32,					/* 8bit */
      316 	31,					/* oddp */
      317 	30);					/* oflow */
      318 
      319 /* INCLUDE FILES */
      320 
      321 
  1     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  1     2 
  1     3 /* Date Last Modified and Reason
  1     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  1     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  1     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  1     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  1     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  1     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  1    10*   Modified November 1979 by C. Hornig for MCS tracing.
  1    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  1    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  1    13*   Modified March 1980 by Robert Coren to reorganize metering information
  1    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  1    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  1    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  1    17**/
  1    18 
  1    19 dcl  ttybp ptr,
  1    20      tty_buf$ ext static,				/* tty buffer segment */
  1    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  1    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  1    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  1    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  1    25 
  1    26 
  1    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  1    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  1    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  1    30 
  1    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  1    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  1    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  1    34 
  1    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  1    36     2 slock bit (36),				/* per system lock */
  1    37     2 absorig fixed bin (24),				/* abs address of this seg */
  1    38     2 borig bit (18),				/* index of start of buffer area */
  1    39     2 bleft fixed bin (18),				/* words left in pool */
  1    40     2 free bit (18),				/* pointer to start of free pool */
  1    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  1    42     2 padb1 bit (28) unaligned,
  1    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  1    44 
  1    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  1    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  1    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  1    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  1    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  1    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  1    51     2 minbuf fixed bin (18),				/* min output buffer size */
  1    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  1    53 
  1    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  1    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  1    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  1    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  1    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  1    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  1    60 
  1    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  1    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  1    63     2 bfx fixed bin,				/* used in calls to iobm */
  1    64     2 nquits fixed bin (35),				/* number of quits */
  1    65     2 space_needed_data,
  1    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  1    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  1    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  1    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  1    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  1    71 
  1    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  1    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  1    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  1    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  1    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  1    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  1    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  1    79 
  1    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  1    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  1    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  1    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  1    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  1    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  1    86 
  1    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  1    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  1    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  1    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  1    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  1    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  1    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  1    94 
  1    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  1    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  1    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  1    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  1    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  1   100     2 echo_neg_mux_nonecho fixed bin (35),
  1   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  1   102 
  1   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  1   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  1   105     2 trace unaligned,				/* tracing information */
  1   106       3 flags,
  1   107       4 enable bit,					/* global tracing control */
  1   108       4 default_mode bit,				/* whether to trace channels by default */
  1   109       4 read bit,					/* read */
  1   110       4 write bit,					/* write */
  1   111       4 data bit,					/* buffers on reads and writes */
  1   112       4 control bit,				/* control, priv_control, and hpriv_control */
  1   113       4 modes bit,					/* (get set check)_modes */
  1   114       4 interrupt bit,				/* interrupt, interrupt_later */
  1   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  1   116       4 start bit,					/* start, stop */
  1   117       4 shutdown bit,				/* shutdown */
  1   118       4 space_man bit,				/* tty_space_man$* */
  1   119       4 pad_flags bit (6),
  1   120       3 data_offset bit (18),				/* offset of tracing data */
  1   121 
  1   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  1   123 
  1   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  1   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  1   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  1   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  1   128 
  1   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  1   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  1   131 
  1   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  1   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  1   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  1   135 
  1   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  1   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  1   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  1   139 
  1   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  1   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  1   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  1   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  1   144 
  1   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  1   146 
  1   147     2 pad2 (13) fixed bin (35),
  1   148 
  1   149     2 free_space fixed bin;				/* start of free space region */
  1   150 
  1   151 
  2     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2     2 
  2     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  2     4 
  2     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     6 
  2     7 /* format: style3 */
  2     8 
  2     9 declare	lock_ptr		pointer;
  2    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  2    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    13 	  2 flags		aligned,
  2    14 	    3 notify_sw	bit (1) unaligned,
  2    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    16 
  2    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  1   152 
  1   153 
  1   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      322 
      323 
  3     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  3     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  3     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  3     9*     implementation.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /*
  3    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  3    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  3    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  3    17**/
  3    18 
  3    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  3    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  3    21 
  3    22 
  3    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  3    24     2 next bit (18),				/* foward pointer to next free block */
  3    25     2 size fixed bin;				/* number of words in this block */
  3    26 
  3    27 
  3    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  3    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  3    30     2 flags unaligned,
  3    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  3    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  3    33       3 break bit (1) unaligned,			/* buffer contains break character */
  3    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  3    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  3    36       3 pad bit (1) unaligned,
  3    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  3    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  3    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  3    40 
  3    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  3    42 
  3    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  3    44 
  3    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      324 
      325 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      326 
      327 
  5     1 /*  BEGIN dn355_data.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  5     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  5     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  5     9*     implementation.
  5    10*  2) change(89-03-20,Parisek), approve(89-06-06,MCR8110),
  5    11*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
  5    12*     Add support of protocol mpx.
  5    13*                                                   END HISTORY COMMENTS */
  5    14 
  5    15 
  5    16 /* Date Last Modified and Reason
  5    17*
  5    18*   Created 07/25/74 by R. B. Snyder for new ttydim.
  5    19*   Modified 06/23/77 by J. Stern to add channel_work_reqd and cwork_count
  5    20*   Modified 08/14/78 by Robert Coren to remove devx_tab and invent PCBs
  5    21*   Modified 79 May 14 by Art Beattie to add fnp_mem_size
  5    22*   Modified December 1979 by Robert Coren to add FNP queue lock
  5    23*   Modified January 1980 by Larry Johnson to increase max number of FNPs to 8
  5    24*   Modified 02/12/80 by Robert Coren to add dcw_list_array_ptr
  5    25*   Modified 03/06/80 by Robert Coren to add some metering info
  5    26*   Modified 12/10/80 by Robert Coren to add get_meters_waiting flag
  5    27*   Modified 83-12-16 BIM to use a chanid instead of iom/channel fb's.
  5    28*   Modified 1984-07-26 BIM for paged iom.
  5    29*   Modified in September 1985 for the DN7100 version interim.
  5    30**/
  5    31 
  5    32 /* LOCKING RULES: A fnp is locked by its LCTE unless its LCTE is uninitialized.
  5    33*   In that case, the configuration_lock must be held.
  5    34*   if tty_lock$lock_lcte returns io_no_permission, then the caller must
  5    35*   lock$lock_fast the configuration lock and retry the LCTE lock. If
  5    36*   the lcte is now initialized, too bad. Otherwise, the config lock protects.
  5    37*
  5    38*   Configuration locking is interesting to init_multiplexer and
  5    39*   all of fnp t&d and reconfiguration. The guts of the multiplexer
  5    40*   pay no attention to it. Thus, if the LCTE can be locked, it MUST be
  5    41*   locked before changing the io_manager_assigned flag. */
  5    42 
  5    43 /* format: style4,delnl,insnl,^ifthendo */
  5    44 
  5    45 dcl  max_no_355s fixed bin int static init (8) options (constant);
  5    46 						/* max no of 355s we can handle (arbitrary) */
  5    47 dcl  dn355_data$ external fixed bin;
  5    48 
  5    49 dcl  infop pointer;
  5    50 dcl  fnpp ptr;
  5    51 
  5    52 dcl  1 datanet_info aligned based (infop),
  5    53        2 configuration_lock aligned,
  5    54          3 pid bit (36) aligned,
  5    55          3 event bit (36) aligned,
  5    56          3 flags aligned,
  5    57 	 4 notify_sw bit (1) unaligned,
  5    58 	 4 pad bit (35) aligned,
  5    59        2 no_of_355s fixed bin,			/* no. of FNP's */
  5    60        2 trace bit (1) aligned,			/* watch events on console */
  5    61        2 debug_stop bit (1) aligned,			/* crash on errors */
  5    62        2 uncp_bufp ptr,                                     /* pointer to the circular buffer */
  5    63        2 protocol_datap ptr,				/* pointer to protocol_mpx data */
  5    64        2 pad1 (6) bit (36) aligned,
  5    65        2 per_datanet (max_no_355s) aligned like fnp_info;	/* data per datanet */
  5    66 
  5    67 dcl  1 fnp_info aligned based (fnpp),			/* structure for each FNP */
  5    68        2 mbx_pt pointer,				/* pointer to mailbox NULL if not in config */
  5    69        2 pcb_array_ptr pointer,			/* pointer to array of physical channel blocks */
  5    70        2 dcw_list_array_ptr pointer,			/* pointer to array of space reserved for output DCW lists */
  5    71        2 no_of_channels fixed bin,			/* number of channels on this FNP */
  5    72        2 fnp_id,
  5    73          3 fnp_tag char (1) unaligned,			/* letter identifying FNP */
  5    74          3 fnp_number fixed bin (9) unsigned unaligned,	/* sequence number of FNP */
  5    75          3 padc bit (18) unaligned,
  5    76        2 io_chanid char (8) aligned,
  5    77        2 io_manager_chx fixed bin (35),			/* devx for DIA on iom */
  5    78        2 lsla_idx (0:5) fixed bin aligned,		/* index into PCB array for lsla lines */
  5    79        2 hsla_idx (0:2) fixed bin aligned,		/* index into PCB array for hsla lines */
  5    80        2 count fixed bin,				/* number of items in delay queue */
  5    81        2 cur_ptr fixed bin,				/* offset in tty_buf of next delay queue element */
  5    82        2 last_ptr fixed bin,				/* offset in tty_buf of last delay queue element */
  5    83        2 bleft_355 fixed bin,				/* number of free buffers in this 355 */
  5    84        2 flags,
  5    85          3 work_reqd bit (1) unaligned,			/* mailbox messages queued up */
  5    86          3 bootloading bit (1) unaligned,		/* currently being bootloaded */
  5    87          3 running bit (1) unaligned,			/* this FNP is running */
  5    88          3 wired bit (1) unaligned,			/* bootload buffer is wired */
  5    89          3 dump_patch_in_progress bit (1) unaligned,	/* a dump or patch order is in progress */
  5    90          3 level_3_pending bit (1) unaligned,		/* level 3 interrupt pending */
  5    91          3 level_7_pending bit (1) unaligned,		/* level 7 interrupt pending */
  5    92          3 dump_patch_disabled bit (1) unaligned,		/* dump & patch orders disabled because of timeout */
  5    93          3 t_and_d_in_progress bit (1) unaligned,		/* T & D using FNP */
  5    94          3 t_and_d_lev_3_occurred bit (1) unaligned,	/* A level 3 occurred */
  5    95          3 t_and_d_lev_7_occurred bit (1) unaligned,
  5    96          3 t_and_d_notify_requested bit (1) unaligned,
  5    97          3 t_and_d_assigned bit (1) unaligned,		/* AS has given fnp to process */
  5    98          3 get_meters_waiting bit (1) unaligned,		/* waiting for meter copy to complete */
  5    99          3 padb bit (7) unaligned,
  5   100          3 active_dial unaligned,
  5   101             4 active_bit (15) bit (1) unaligned,		/* ON if the process is active */
  5   102        2 lcte_ptr ptr,				/* pointer to this FNP's LCT entry */
  5   103        2 astep ptr,					/* pointer to aste of wired bootload buffer */
  5   104        2 boot_ev_chan fixed bin (71),			/* event channel over which to signal bootload completion */
  5   105        2 boot_process_id bit (36),			/* process that initiated bootload */
  5   106        2 version char (4),				/* version id of core image */
  5   107        2 fnp_mem_size fixed bin (18) unsigned,		/* memory size of this FNP in 18-bit words */
  5   108        2 queue_lock bit (36) aligned,			/* lock for interrupt queue */
  5   109        2 dump_patch_lock bit (36),			/* lock for fnp_dump or _patch operation */
  5   110        2 q_entries_made fixed bin (35),			/* count of delay queue entries made */
  5   111        2 input_reject_count fixed bin,			/* number of times input rejected */
  5   112        2 processed_from_q fixed bin (35),		/* number of interrupts processed from queue */
  5   113        2 fnp_channel_locked fixed bin (35),		/* number of times dn355 found per-FNP lock locked */
  5   114        2 input_data_transactions fixed bin (35),		/* number of mailbox transactions for input */
  5   115        2 output_data_transactions fixed bin (35),		/* number of mailbox transactions for output */
  5   116        2 input_control_transactions fixed bin (35),	/* number of mailbox transactions for inbound control info */
  5   117        2 output_control_transactions fixed bin (35),	/* number of mailbox transactions for outbound control info */
  5   118        2 cumulative_mbx_in_use fixed bin (35),		/* cumulative count of number of outbound mailboxes in use */
  5   119        2 max_mbx_in_use fixed bin,			/* maximum number of mailboxes in use at any given time */
  5   120        2 mbx_in_use_updated fixed bin (35),		/* number of increments to cumulative_mbx_in_use */
  5   121        2 mbx_unavailable fixed bin (35),		/* number of times had to queue mailbox transaction because none available */
  5   122        2 free_size fixed bin (35),			/* cumulative amount of bleft_355 */
  5   123        2 free_count fixed bin,			/* number of adds to above */
  5   124        2 fnp_space_restricted_output fixed bin (35),	/* number of times available FNP space restricted amount of output sent */
  5   125        2 tandd_pcbx fixed bin,			/* index of PCB for COLTS channel */
  5   126        2 n_pages_wired fixed bin,			/* pages wired for loading */
  5   127        2 config_flags aligned,
  5   128          3 available bit (1) unaligned,			/* reconfig says "yes" */
  5   129          3 io_manager_assigned bit (1) unaligned,		/* We have channel assigned to us */
  5   130          3 pad bit (34) unaligned,
  5   131        2 uncp_pcbx1 fixed bin (17) unaligned,		/* For the DN7100 */
  5   132        2 uncp_pcbx2 fixed bin (17) unaligned,		/* For the DN7100 */  
  5   133        2 ptx fixed bin,				/* page table index, used only at bootload */
  5   134        2 ptp pointer unaligned;			/* page table for this FNP */
  5   135 
  5   136 /**** The following named constants are used to lay out the
  5   137*      iom page tables. Each FNP has to have its own page
  5   138*      table because there is not enough room to have eight different
  5   139*      bootload images of 32 K and > 64 K of tty_buf 
  5   140*
  5   141*      THE MAX TTY BUF LENGTH IS 192 K words. We could have another 16 K
  5   142*      easily, and then after that it would get hard. */ 
  5   143 
  5   144 /**** The layout
  5   145*
  5   146*      Page   I/O address   Memory address     Comments
  5   147*      ----      ------     --------------     --------
  5   148*      0              0       xxxxxx           invalid PTW
  5   149*      1           2000         2000           write-enabled (mailbox)
  5   150*      2           4000         4000           write-enabled (mailbox)
  5   151*      3	        6000         6000           write-enabled (mailbox)
  5   152*      4          10000       as needed        bootload image segment page 0
  5   153*      ....        ....         ....           ....
  5   154*      35        110000       as needed        bootload image segment page 31
  5   155*      36        112000       xxxxxx           invalid PTW
  5   156*      ...         ....         ....           ....
  5   157*      63        160000         ....           invalid PTW
  5   158*      64        200000       as needed        tty_buf page 0
  5   159*      ...         ....         ....           ....
  5   160*      127       260000       as needed        tty_buf page 63
  5   161*      255       ......        .....           tty_buf page 191
  5   162**/
  5   163 
  5   164 /**** We assume that the page table starts at all zeros. */
  5   165 
  5   166 declare  FIRST_BOOTLOAD_PAGEX fixed bin init (4) int static options (constant);
  5   167 declare  FIRST_TTY_BUF_PAGEX fixed bin init (64) int static options (constant);
  5   168 
  5   169 /* End include file dn355_data.incl.pl1 */
      328 
      329 
  6     1 /*	BEGIN INCLUDE FILE ... pcb.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  6     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  6     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  6     9*     implementation.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 
  6    13 /*  Created 08/14/78 by Robert S. Coren */
  6    14 /*  Modified 02/19/80 by Robert S. Coren to add read_first & read_last */
  6    15 /*  Modified 12/10/80 by Robert S. Coren to add metering stuff */
  6    16 /*  Modified May 1981 by Robert S.Coren to add tandd_attached flag */
  6    17 /*  Modified in February 1982 to add: dumpout, turn, enter_receive_pending,
  6    18*             connection_type, send_lf, extra_nl,lfecho flags for DN7100 */
  6    19 
  6    20 /* Describes physical channel blocks for FNP channels */
  6    21 
  6    22 dcl  n_pcbs fixed bin;
  6    23 dcl  pcbp ptr;
  6    24 
  6    25 dcl 1 pcb_array (n_pcbs) based aligned like pcb;
  6    26 
  6    27 dcl 1 pcb aligned based (pcbp),			/* physical channel block declaration */
  6    28     2 channel_desc unaligned,
  6    29       3 devx fixed bin (17),				/* index of LCT entry */
  6    30       3 subchan fixed bin (7) unaligned,		/* logical subchannel/lsla slot # correspondence */
  6    31       3 line_number unal,				/* regular line number */
  6    32         4 is_hsla bit (1) unaligned,			/* on if hsla, off if lsla */
  6    33         4 la_no bit (3) unaligned,			/* line adapter (high or low speed) number */
  6    34         4 slot_no bit (6) unaligned,			/* physical slot or subchannel number */
  6    35     2 write_first fixed bin (17) unaligned,		/* offset of first buffer in output chain */
  6    36     2 write_last fixed bin (17) unaligned,		/* offset of last buffer in output chain */
  6    37     2 baud_rate fixed bin (17) unaligned,		/* baud rate of channel */
  6    38     2 line_type fixed bin (17) unaligned,		/* line type */
  6    39     2 max_buf_size fixed bin (17) unaligned,		/* largest buffer to be allocated for output */
  6    40     2 write_cnt fixed bin (17) unaligned,		/* number of characters in write chain */
  6    41     2 flags unaligned,
  6    42       3 listen bit (1),				/* channel is ready for dialup */
  6    43       3 dialed bit (1),				/* channel is dialed up or connected */
  6    44       3 send_output bit (1),				/* channel is ready for output */
  6    45       3 high_speed bit (1),				/* needs large send_out threshold */
  6    46       3 sync_line bit (1),				/* synchronous channel */
  6    47       3 end_frame bit (1),				/* channel is waiting for formfeed */
  6    48       3 hndlquit bit (1),				/* channel in hndlquit mode */
  6    49       3 breakall_enabled bit (1),			/* breakall mode allowed for this channel */
  6    50       3 output_mbx_pending bit (1),			/* A wtx mbx has been sent, but not relinquished */
  6    51       3 copied_meters_ready bit (1),			/* copy_meters operation has completed */
  6    52       3 get_meters_waiting bit (1),			/* waiting for get_meters operation to complete */
  6    53       3 tandd_attached bit (1),			/* this channel is in use by T & D */
  6    54       3 enter_receive_pending bit (1),			/* enter_receive is waiting for send */
  6    55       3 turn bit (1),				/* Multics owns the turn */
  6    56       3 extra_nl bit (1),				/* add NL at end of buffer  (read) */
  6    57       3 send_lf bit (1),				/* send lf after read  */
  6    58       3 lfecho bit (1),				/* Validate lfecho mode */
  6    59       3 dumpout bit (1),				/* To purge first write after special dial */
  6    60       3 buffer_flag bit (1),                                /* Utilisation of a buffer in place of the circular buffer. */
  6    61       3 connection_type bit (2),			/* For full-duplex */
  6    62       3 padb bit (6),
  6    63       3 uncp_pcbx fixed bin (9) unal uns,		/* To manage the full duplex with the datanet 7100 */
  6    64     2 read_first fixed bin (18) unsigned unaligned,	/* head of read chain (while reading from FNP) */
  6    65     2 read_last fixed bin (18) unsigned unaligned,	/* tail of read chain (likewise) */
  6    66     2 saved_meters_ptr pointer unaligned,		/* pointer to (unwired) copy of meters at last dialup */
  6    67     2 copied_meters_offset fixed bin (18) unsigned;	/* offset in tty_buf of buffer meters copied to */
  6    68 
  6    69 /* END INCLUDE FILE ... pcb.incl.pl1 */
      330 
      331 
  7     1 /*		BEGIN mailbox_ops.incl.pl1
  7     2*
  7     3*   Created 8/15/74 by F. A. Canali
  7     4*   Modified 12/01/75 by J. Goldman for dial out
  7     5*   Modified 8/24/76 by Robert Coren to add dont_accept_calls and blast
  7     6*   Modified 7/28/77 by J. Stern to add set_delay_table
  7     7*   Modified 2/6/78 by Robert Coren to add sync_msg_size
  7     8*   Modified 6/29/79 by B. Greenberg for FNP echo negotiation
  7     9*   Modified Oct. 1979 by Robert Coren to add oflow & iflow modes
  7    10*   Modified 1/21/80 by Robert Coren to add parity controls 
  7    11*   Modified 12/10/80 by Robert Coren to add report_meters
  7    12*   */
  7    13 
  7    14 dcl (						/* declaration of submailbox io commands */
  7    15 
  7    16      rcd init (1),					/* read control data */
  7    17      rtx init (2),					/* read text */
  7    18      wcd init (3),					/* write control data */
  7    19      wtx init (4)					/* write text */
  7    20 
  7    21      ) fixed bin (8) int static options (constant);
  7    22 
  7    23 
  7    24 dcl (						/* declaration of submailbox op codes sent by 6180 to 355 */
  7    25 
  7    26      terminal_accepted init (0),			/* a dialed terminal has been accepted */
  7    27      disconnect_this_line init (1),			/* hang up a line */
  7    28      disconnect_all_lines init (2),			/* hang up all lines */
  7    29      dont_accept_calls init (3),			/* the 6180 is no longer accepting terminals */
  7    30      accept_calls init (4),				/* the 6180 is ready to accept terminals */
  7    31      input_accepted init (5),				/* the 6180 will accept input and has reserved
  7    32*						   space in its circular buffer */
  7    33      set_line_type init (6),				/* set the line type */
  7    34      enter_receive init (7),				/* give the line to the terminal */
  7    35      set_framing_chars init (8),			/* set characters for block transfer */
  7    36      blast init (9),				/* BOS blast message */
  7    37      accept_direct_output init (10),			/* the 6180 has an output request */
  7    38      accept_last_output init (11),			/* same as above but the 355 may
  7    39*						   unlock the keyboard and accept input
  7    40*						   when the output transmission is through */
  7    41      dial init (12),				/* use command data to dial a phone number */
  7    42      reject_request_temp init (14),			/* an input request can not be serviced */
  7    43      terminal_rejected init (16),			/* a dial up has been rejected */
  7    44      disconnect_accepted init (17),			/* the 6180 recognizes a disconnection */
  7    45      init_complete init (18),				/* 6180 system initialization is complete */
  7    46      dump_mem init (19),				/* dump 355 memory */
  7    47      patch_mem init (20),				/* patch 355 memory */
  7    48      fnp_break init (21),				/* to control fnp break points */
  7    49      line_control init (22),				/* line control order to fnp */
  7    50      sync_msg_size init (23),				/* set message size for sync line */
  7    51      set_echnego_break_table init (24),			/* send over echo negotiation break table */
  7    52      start_negotiated_echo init (25),			/* attempt to start FNP echoing for ech. nego. */
  7    53      stop_negotiated_echo init (26),			/* 6180 wants FNP to stop negotiated echo */
  7    54      init_echo_negotiation init (27),			/* synchronize echo negotiation ctrs. */
  7    55      break_acknowledged init (29),			/* the 6180 recognizes a break for a terminal */
  7    56      input_fc_chars init (30),			/* set input flow control chars */
  7    57      output_fc_chars init (31),			/* set output flow control chars */
  7    58      alter_parameters init (34),			/* request to alter 355 parms for a terminal */
  7    59      checksum_error init (35),			/* submailbox has a checksum error */
  7    60      report_meters init (36),				/* get meters from FNP */
  7    61      set_delay_table init (37)			/* tells 355 to set new delay table for channel */
  7    62      ) fixed bin (8) int static options (constant);
  7    63 
  7    64 
  7    65 dcl (						/* submailbox op codes sent from 355 to 6180 */
  7    66 
  7    67      accept_new_terminal init (64),			/* a terminal has dialed up */
  7    68      disconnected_line init (65),			/* a terminal has been hung up */
  7    69      input_in_mailbox init (66),			/* this mailbox contains input */
  7    70      line_masked init (67),				/* channel was masked for excessive interrupts */
  7    71      s6180_params init (68),				/* return bcount */
  7    72      send_output init (69),				/* I am ready to send to a terminal */
  7    73      ack_echnego_init init (70),			/* I have zeroed my ech. nego. ctr. */
  7    74      ack_echnego_stop init (71),			/* I have sent all that I have echoed. */
  7    75      connect_to_slave init (73),			/* a dialup sequence has been completed */
  7    76      accept_direct_input init (74),			/* HEY! here's some input for you */
  7    77      break_condition init (75),			/* a break has been hit for a terminl */
  7    78      wru_timeout init (76),				/* no answerback */
  7    79      error_message init (77),				/* error message from the 355 */
  7    80      first_acu_op_code init (80),
  7    81      acu_no_power init (80),				/* power indicator of auto-call unit is off */
  7    82      acu_line_occupied init (81),			/* auto-call unit's line is being used */
  7    83      acu_dial_failure init (82),			/* dial out failed */
  7    84      acu_no_good init (83),				/* invalid dial out attempt */
  7    85      last_acu_op_code init (83),
  7    86      line_status init (84)				/* line status reported by fnp */
  7    87      ) fixed bin (8) int static options (constant);
  7    88 
  7    89 dcl (						/* declaration of sub operations for alter parameters */
  7    90 
  7    91      Breakchar init (1),				/* specifies break character */
  7    92      Nocontrol init (2),				/* enter/leave nocontrol mode */
  7    93      Fullduplex init (3),				/* perform character echoing */
  7    94      Break init (4),			/* send line break to terminal */
  7    95      Errormsg init (5),				/* indicates error detected by 355 */
  7    96      Meter init (6),				/* read metering info */
  7    97      Sensepos init (7),				/* sense position of carrier */
  7    98      Crecho init (8),				/* enter/leave crecho mode */
  7    99      Lfecho init (9),				/* enter/leave line feed echo mode */
  7   100      Lock init (10),				/* lock keyboard */
  7   101      Msg init (11),					/* precanned msg for dialing terminals */
  7   102      Upstate init (12),				/* are you up? */
  7   103      Dumpoutput init (13),				/* throw away output */
  7   104      Tabecho init (14),				/* echo tabs */
  7   105      Setbusy init (15),				/* force dataset busy */
  7   106      Listen init (16),				/* answer the phone */
  7   107      Hndlquit init (17),				/* send newline on receipt of quit */
  7   108      Chngstring init (18),				/* printer addressing string definition */
  7   109      Wru init (19),					/* read answerback */
  7   110      Echoplex init (20),				/* enter/leave echoplex mode */
  7   111      Xmit_hold init (21),				/* start/stop transmit hold */
  7   112      Dumpinput init (22),				/* throw away input */
  7   113      Replay init (23),				/* replay interrupted input */
  7   114      Polite init (24),				/* write only if at left margin */
  7   115      Block_xfer init (25),				/* block transfer or "frame" mode */
  7   116      Set_buffer_size init (26),			/* set input buffer size */
  7   117      Breakall init (27),				/* break on all characters */
  7   118      Prefixnl init (28),				/* prefix output with newlines if input present */
  7   119      Input_flow_control init (29),			/* iflow mode */
  7   120      Output_flow_control init (30),			/* oflow mode */
  7   121      Odd_parity init (31),				/* generate odd parity */
  7   122      Eight_bit_in init (32),				/* 8bit mode */
  7   123      Eight_bit_out init (33)				/* no_outp mode */
  7   124      ) fixed bin (8) int static options (constant);
  7   125 
  7   126 dcl  global_opcodes (9) fixed bin (8) int static options (constant) init (
  7   127      2,						/* disconnect_all_lines */
  7   128      3,						/* dont_accept_calls */
  7   129      4,						/* accept_calls */
  7   130      9,						/* blast */
  7   131      19,						/* dump_mem */
  7   132      20,						/* patch_mem */
  7   133      21,						/* fnp_break */
  7   134      36,						/* report_meters */
  7   135      77);						/* error_message */
  7   136 
  7   137 /* END of mailbox_ops.incl.pl1 */
      332 
      333 
  8     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  8     2 
  8     3 /* This include file declares all the entries in tty_space_man and defines the constants
  8     4**  to be used for the flags argument
  8     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  8     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  8     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  8     8**/
  8     9 
  8    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  8    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  8    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  8    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  8    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  8    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  8    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  8    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  8    18 dcl  tty_space_man$needs_space entry (fixed bin);
  8    19 
  8    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  8    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  8    22 
  8    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      334 
      335 
  9     1 /* BEGIN INCLUDE FILE ... line_types.incl.pl1  */
  9     2 
  9     3 /* Written  November 10 1975 by Paul Green */
  9     4 /* Modified October 1978 by Larry Johnson to include line_type_names */
  9     5 /* Modified 12/19/78 by J. Stern to add POLLED_VIP line type */
  9     6 /* Modified 9/27/79 by J. Stern to add X25LAP line type */
  9     7 /* Modified Spring 1981 by Charles Hornig to add HDLC line type */
  9     8 /* Modified May 1981 by Robert Coren to add COLTS line type */
  9     9 /* Modified September 1984 by Robert Coren to correctly count VIP as a synchronous line type */
  9    10 
  9    11 
  9    12 /****^  HISTORY COMMENTS:
  9    13*  1) change(86-02-25,Negaret), approve(87-07-13,MCR7679),
  9    14*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    15*     Add a DSA line type.
  9    16*  2) change(87-03-17,Beattie), approve(87-07-13,MCR7656),
  9    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    18*     Add HASP_OPR to identify HASP workstation consoles with login service.
  9    19*                                                   END HISTORY COMMENTS */
  9    20 
  9    21 
  9    22 declare   (LINE_MC            initial (-2),
  9    23        	 LINE_TELNET	initial (-1),
  9    24            LINE_UNKNOWN       initial (0),
  9    25 	 LINE_ASCII	initial (1),
  9    26 	 LINE_1050	initial (2),
  9    27 	 LINE_2741	initial (3),
  9    28 	 LINE_ARDS	initial (4),
  9    29 	 LINE_SYNCH	initial (5),
  9    30 	 LINE_G115	initial (6),
  9    31 	 LINE_BSC		initial (7),
  9    32 	 LINE_ETX		initial (8),
  9    33 	 LINE_VIP		initial (9),
  9    34 	 LINE_ASYNC1	initial (10),
  9    35 	 LINE_ASYNC2	initial (11),
  9    36 	 LINE_ASYNC3	initial (12),
  9    37 	 LINE_SYNC1	initial (13),
  9    38 	 LINE_SYNC2	initial (14),
  9    39 	 LINE_SYNC3	initial (15),
  9    40 	 LINE_POLLED_VIP	initial (16),
  9    41 	 LINE_X25LAP	initial (17),
  9    42 	 LINE_HDLC	initial (18),
  9    43 	 LINE_COLTS	initial (19),
  9    44 	 LINE_DSA           initial (20),
  9    45 	 LINE_HASP_OPR	initial (21)
  9    46 	) fixed bin internal static options (constant);
  9    47 
  9    48 dcl  max_line_type fixed bin int static options (constant) init (21);
  9    49 
  9    50 declare  n_sync_line_types fixed bin int static options (constant) init (10);
  9    51 
  9    52 declare  sync_line_type (10) fixed bin int static options (constant) init (5, 6, 7, 9, 13, 14, 15, 16, 17, 18);
  9    53 
  9    54 dcl  line_types (-2:21) char (16) int static options (constant) init (
  9    55      "MC",                                                  /* -2 */
  9    56      "TELNET",					/* -1 */
  9    57      "none",					/* 0 */
  9    58      "ASCII",					/* 1 */
  9    59      "1050",					/* 2 */
  9    60      "2741",					/* 3 */
  9    61      "ARDS",					/* 4 */
  9    62      "Sync",					/* 5 */
  9    63      "G115",					/* 6 */
  9    64      "BSC",					/* 7 */
  9    65      "202ETX",					/* 8 */
  9    66      "VIP",					/* 9 */
  9    67      "ASYNC1",					/* 10 */
  9    68      "ASYNC2",					/* 11 */
  9    69      "ASYNC3",					/* 12 */
  9    70      "SYNC1",					/* 13 */
  9    71      "SYNC2",					/* 14 */
  9    72      "SYNC3",					/* 15 */
  9    73      "POLLED_VIP",					/* 16 */
  9    74      "X25LAP",					/* 17 */
  9    75      "HDLC",					/* 18 */
  9    76      "COLTS",					/* 19 */
  9    77      "DSA",					/* 20 */
  9    78      "HASP_OPR");					/* 21 */
  9    79 
  9    80 /* END INCLUDE FILE ... line_types.incl.pl1  */
      336 
      337 
 10     1 /* BEGIN INCLUDE FILE ... mux_init_info.incl.pl1 */
 10     2 
 10     3 /* Created 8/2/78 by J. Stern */
 10     4 
 10     5 
 10     6 dcl  miip ptr;					/* ptr to mux_init_info structure */
 10     7 dcl  mii_chan_count fixed bin;			/* channel count when allocating mux_init_info */
 10     8 
 10     9 
 10    10 dcl 1 mux_init_info aligned based (miip),		/* multiplexer initialization info */
 10    11       2 no_channels fixed bin,			/* number of multiplexed channels */
 10    12       2 channels (mii_chan_count refer (mux_init_info.no_channels)), /* one entry per channel */
 10    13         3 name char (32) unal,			/* channel name */
 10    14         3 devx fixed bin;				/* device index for channel */
 10    15 
 10    16 
 10    17 /* END INCLUDE FILE ... mux_init_info.incl.pl1 */
      338 
      339 
 11     1 /*  START OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3 /* Written by Charles Hornig, 1st quarter 1981 */
 11     4 /* Canonicalization entry added by Chris Jones, January 1984 */
 11     5 
 11     6 /* chanid = canonicalize_chanid (chanid); */
 11     7 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 11     8 dcl	io_chnl_util$canonicalize_chanid
 11     9 			   entry (char (8) aligned) returns (char (8) aligned);
 11    10 
 11    11 /* call iom_to_name (iomno, channo, name, code); */
 11    12 dcl	io_chnl_util$iom_to_name
 11    13 			   entry (fixed bin (3), fixed bin (7), char (8) aligned, fixed bin (35));
 11    14 
 11    15 /* call name_to_iom (name, iomno, channo, code); */
 11    16 dcl	io_chnl_util$name_to_iom
 11    17 			   entry (char (8) aligned, fixed bin (3), fixed bin (7), fixed bin (35));
 11    18 
 11    19 /*  END OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      340 
 12     1 /* BEGIN INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
 12     2 
 12     3 /* Created 4/9/79 by J. Stern */
 12     4 /* Modified: 10 November 1980 by G. Palter to add can_type */
 12     5 
 12     6 
 12     7 dcl  mclp ptr;
 12     8 dcl  mcl_version_2 fixed bin int static options (constant) init (2);
 12     9 
 12    10 dcl 1 mcl aligned based (mclp),			/* modes change list */
 12    11       2 version fixed bin,				/* version number of this structure (Input) */
 12    12       2 n_entries fixed bin,				/* number of mode change entries (Input) */
 12    13       2 line_len fixed bin,				/* new line length (-1 => no change) (Input) */
 12    14       2 page_len fixed bin,				/* new page length (-1 => no change) (Input) */
 12    15       2 can_type fixed binary,			/* new canonicalization type (-1 => no change) (Input) */
 12    16       2 flags,
 12    17         3 init bit (1) unal,				/* ON if all modes to be reinitialized (Input) */
 12    18         3 ll_error bit (1) unal,			/* ON if line length error detected (Output) */
 12    19         3 pl_error bit (1) unal,			/* ON if page length error detected (Output) */
 12    20         3 can_type_error bit (1) unaligned,		/* ON if can_type error detected (Output) */
 12    21         3 mbz bit (32) unal,
 12    22       2 entries (36) like mcle;			 /* one entry per mode change */
 12    23 
 12    24 dcl  mclep ptr;
 12    25 
 12    26 dcl 1 mcle aligned based (mclep),			/* mode change list entry */
 12    27       2 mode_name char (16) unal,			/* name of mode to change (Input) */
 12    28       2 flags,
 12    29         3 mode_switch bit (1) unal,			/* ON to turn mode on, else OFF (Input) */
 12    30         3 force bit (1) unal,				/* ON to ignore errors for this mode change (Input) */
 12    31         3 mpx_mode bit (1) unal,			/* ON if mode recognized by multiplexer (Output) */
 12    32         3 error bit (1) unal,				/* ON if mode change is in error (Output) */
 12    33         3 mbz bit (32) unal;
 12    34 
 12    35 
 12    36 /* END INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
      341 
 13     1 /* BEGIN INCLUDE FILE ... flow_conrol_info.incl.pl1 */
 13     2 
 13     3 /* This include file defines the structures used for the "input_flow_control_chars"
 13     4*   and "output_flow_control_chars" orders to MCS.
 13     5**/
 13     6 
 13     7 /* Created 08/13/79 by Robert S. Coren */
 13     8 
 13     9 dcl 1 input_flow_control_info aligned based,
 13    10     2 suspend_seq unaligned,
 13    11       3 count fixed bin (9) unsigned,
 13    12       3 chars char (3),
 13    13     2 resume_seq unaligned,
 13    14       3 count fixed bin (9) unsigned,
 13    15       3 chars char (3),
 13    16     2 timeout bit (1);
 13    17 
 13    18 
 13    19 dcl 1 output_flow_control_info aligned based,
 13    20     2 flags unaligned,
 13    21       3 suspend_resume bit (1),
 13    22       3 block_acknowledge bit (1),
 13    23       3 mbz bit (16),
 13    24     2 buffer_size fixed bin (18) unsigned unaligned,
 13    25     2 suspend_or_etb_seq unaligned,
 13    26       3 count fixed bin (9) unsigned,
 13    27       3 chars char (3),
 13    28     2 resume_or_ack_seq unaligned,
 13    29       3 count fixed bin (9) unsigned,
 13    30       3 chars char (3);
 13    31 
 13    32 
 13    33 /* END INCLUDE FILE ... flow_control_info.incl.pl1 */
 13    34 
      342 
 14     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
 14     2 
 14     3 /* Created 8/25/78 by J. Stern */
 14     4 
 14     5 
 14     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
 14     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
 14     8 
 14     9 /* call channel_manager$write (devx, output_ptr, code) */
 14    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
 14    11 
 14    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
 14    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
 14    14 
 14    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
 14    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
 14    17 
 14    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
 14    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
 14    20 
 14    21 /* call channel_manager$get_modes (devx, modes, code) */
 14    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
 14    23 
 14    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
 14    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    26 
 14    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
 14    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
 14    29 
 14    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
 14    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    32 
 14    33 
 14    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      343 
 15     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
 15     2 
 15     3 /* Defines constants and structures  used by MCS interrupt handlers */
 15     4 
 15     5 /* Created 08/21/78 by Robert Coren */
 15     6 /* Echo negotiation types added sometime by Bernie Greenberg */
 15     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
 15     8 /* MASKED type added June 23, 1982, by Robert Coren */
 15     9 
 15    10 dcl  DIALUP fixed bin int static options (constant) init (1);
 15    11 dcl  HANGUP fixed bin int static options (constant) init (2);
 15    12 dcl  CRASH fixed bin int static options (constant) init (3);
 15    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
 15    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
 15    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
 15    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
 15    17 dcl  QUIT fixed bin int static options (constant) init (8);
 15    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
 15    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
 15    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
 15    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
 15    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
 15    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
 15    24 dcl  TIMER fixed bin int static options (constant) init (15);
 15    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
 15    26 dcl  MASKED fixed bin int static options (constant) init (17);
 15    27 
 15    28 dcl  interrupt_info bit (72) aligned;
 15    29 
 15    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
 15    31     2 line_type fixed bin (9) unal uns,
 15    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
 15    33     2 baud_rate fixed bin (18) unal uns,
 15    34     2 max_buf_size fixed bin (9) unal uns,
 15    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
 15    36     2 pad bit (26) unal;
 15    37 
 15    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
 15    39     2 input_chain unaligned,
 15    40       3 chain_head bit (18) unaligned,
 15    41       3 chain_tail bit (18) unaligned,
 15    42     2 input_count fixed bin (18) unal uns,
 15    43     2 flags unaligned,
 15    44       3 break_char bit (1),				/* data contains a break character */
 15    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
 15    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
 15    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
 15    48       3 pad bit (14);
 15    49 
 15    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
 15    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
 15    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
 15    53 
 15    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
      344 
 16     1 
 16     2 /* BEGIN INCLUDE FILE...fnp_meters.incl.pl1 */
 16     3 
 16     4 /* This include file defines structures used to return meters when
 16     5**  a get_meters order is issued for a whole FNP.
 16     6**/
 16     7 
 16     8 /* Written December 1980 by Robert Coren */
 16     9 /* Modified February 1981 by Robert Coren to split off fnp_channel_meters */
 16    10 
 16    11 dcl  fnp_meterp pointer;
 16    12 
 16    13 dcl 1 fnp_global_meters based aligned,			/* FNP-wide meters */
 16    14     2 channels_dialed_cum fixed bin (35),
 16    15     2 channels_dialed_updates fixed bin (35),		/* updates to above */
 16    16     2 space_available_cum fixed bin (35),
 16    17     2 space_available_updates fixed bin (35),		/* updates to above */
 16    18     2 input_mbx_in_use_cum fixed bin (35),
 16    19     2 input_mbx_updates fixed bin (35),			/* updates to above */
 16    20     2 cur_channels_dialed fixed bin (18) unsigned unaligned,
 16    21     2 space_alloc_failures fixed bin (18) unsigned unaligned,
 16    22     2 abnormal_dia_status fixed bin (18) unsigned unaligned,
 16    23     2 buffer_pool fixed bin (18) unsigned unaligned,
 16    24     2 buffer_allocations fixed bin (35),
 16    25     2 buffers_preallocated fixed bin (35),
 16    26     2 used_preallocated_buffer fixed bin (35),
 16    27     2 no_preallocated_available fixed bin (35),
 16    28     2 time_booted fixed bin (71),
 16    29     2 total_idle_count fixed bin (35),
 16    30     2 idle_count_updates fixed bin (35),
 16    31     2 max_idle_count fixed bin (35),
 16    32     2 min_idle_count fixed bin (35),
 16    33     2 memory_parity_errors fixed bin (35);
 16    34 
 16    35 dcl 1 fnp_meters based (fnp_meterp) aligned,		/* structure for returning FNP-wide meters kept by FNP and ring 0 */
 16    36     2 version fixed bin,
 16    37     2 pad fixed bin,
 16    38     2 from_fnp like fnp_global_meters,
 16    39     2 n_channels fixed bin,
 16    40     2 output_mbx_in_use_cum fixed bin (35),
 16    41     2 output_mbx_updates fixed bin (35),
 16    42     2 output_mbx_unavailable fixed bin (35),
 16    43     2 max_output_mbx_in_use fixed bin,
 16    44     2 queue_entries_made fixed bin (35),
 16    45     2 input_rejects fixed bin,
 16    46     2 processed_from_q fixed bin (35),
 16    47     2 fnp_channel_locked fixed bin (35),
 16    48     2 input_data_transactions fixed bin (35),
 16    49     2 output_data_transactions fixed bin (35),
 16    50     2 input_control_transactions fixed bin (35),
 16    51     2 output_control_transactions fixed bin (35),
 16    52     2 fnp_space_restricted_output fixed bin,
 16    53     2 fnp_mem_size fixed bin,
 16    54     2 iom_number fixed bin,
 16    55     2 iom_chan_no fixed bin;
 16    56 
 16    57 dcl  FNP_METERS_VERSION_2 fixed bin int static options (constant) init (2);
 16    58 
 16    59 /* END INCLUDE FILE...fnp_meters.incl.pl1 */
      345 
 17     1 /* BEGIN INCLUDE FILE...fnp_channel_meters.incl.pl1 */
 17     2 
 17     3 /* This include file defines meters returned for subchannels of an FNP. */
 17     4 
 17     5 /* Created February 1981 by Robert Coren from fnp_meters.incl.pl1. */
 17     6 
 17     7 dcl  fnp_chan_meterp pointer;
 17     8 dcl  FNP_CHANNEL_METERS_VERSION_1 fixed bin int static options (constant) init (1);
 17     9 
 17    10 dcl 1 fnp_chan_meter_struc based (fnp_chan_meterp) aligned,
 17    11     2 version fixed bin,
 17    12     2 flags,
 17    13       3 synchronous bit (1) unaligned,
 17    14       3 reserved bit (35) unaligned,
 17    15     2 current_meters like fnp_channel_meters,
 17    16     2 saved_meters like fnp_channel_meters;
 17    17 
 17    18 dcl 1 fnp_channel_meters based aligned,
 17    19     2 header,
 17    20       3 dia_request_q_len fixed bin (35),			/* cumulative */
 17    21       3 dia_rql_updates fixed bin (35),			/* updates to above */
 17    22       3 pending_status fixed bin (35),			/* cumulative */
 17    23       3 pending_status_updates fixed bin (35),		/* updates to above */
 17    24       3 output_overlaps fixed bin (18) unsigned unaligned,	/* output chained to already-existing chain */
 17    25       3 parity_errors fixed bin (18) unsigned unaligned,	/* parity on the channel */
 17    26       3 software_status_overflows fixed bin (18) unsigned unaligned,
 17    27       3 hardware_status_overflows fixed bin (18) unsigned unaligned,
 17    28       3 input_alloc_failures fixed bin (18) unsigned unaligned,
 17    29       3 dia_current_q_len fixed bin (18) unsigned unaligned,	/* current length of dia request queue */
 17    30       3 exhaust fixed bin (35),
 17    31       3 software_xte fixed bin (18) unsigned unaligned,
 17    32       3 pad bit (18) unaligned,
 17    33     2 sync_or_async (17) fixed bin;			/* placeholder for meters for sync or async channels */
 17    34 
 17    35 dcl 1 fnp_sync_meters based aligned,
 17    36     2 header like fnp_channel_meters.header,
 17    37     2 input,
 17    38       3 message_count fixed bin (35),			/* total number of messages */
 17    39       3 cum_length fixed bin (35),			/* total cumulative length in characters */
 17    40       3 min_length fixed bin (18) unsigned unaligned,	/* length of shortest message */
 17    41       3 max_length fixed bin (18) unsigned unaligned,	/* length of longest message */
 17    42     2 output like fnp_sync_meters.input,
 17    43     2 counters (8) fixed bin (35),
 17    44     2 pad (3) fixed bin;
 17    45 
 17    46 dcl 1 fnp_async_meters based aligned,
 17    47     2 header like fnp_channel_meters.header,
 17    48     2 pre_exhaust fixed bin (35),
 17    49     2 echo_buf_overflow fixed bin (35),			/* number of times echo buffer has overflowed */
 17    50     2 bell_quits fixed bin (18) unsigned unaligned,
 17    51     2 padb bit (18) unaligned,
 17    52     2 pad (14) fixed bin;
 17    53 
 17    54 /* END INCLUDE FILE...fnp_channel_meters.incl.pl1 */
      346 
 18     1 /* BEGIN INCLUDE FILE...get_comm_meters_info.incl.pl1 */
 18     2 
 18     3 /* This include file defines the info structure(s) used with the get_meters order to MCM */
 18     4 /* A program that includes this include file must alos include lct.incl.pl1 */
 18     5 
 18     6 /* Written Decemeber 1980 by Robert Coren */
 18     7 
 18     8 dcl 1 get_comm_meters_info aligned based,		/* info_ptr points to this */
 18     9     2 version fixed bin,
 18    10     2 pad fixed bin,
 18    11     2 subchan_ptr pointer,				/* pointer to meters kept by the subchannel */
 18    12     2 logical_chan_ptr pointer,			/* pointer to meters kept by channel_manager */
 18    13     2 parent_ptr pointer,				/* pointer to meters kept by the parent multiplexer */
 18    14     2 subchan_type fixed bin,				/* multiplexer type of subchannel */
 18    15     2 parent_type fixed bin;				/* multiplexer type of parent */
 18    16 
 18    17 dcl 1 logical_chan_meters based aligned,		/* pointed to by get_comm_meters_info.logical_chan_ptr */
 18    18        2 current_meters like lcte.meters,		/* latest values */
 18    19        2 saved_meters like lcte.meters;			/* values as of last copy_meters */
 18    20 
 18    21 dcl  GET_COMM_METERS_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 18    22 
 18    23 /* END INCLUDE FILE...get_comm_meters_info.incl.pl1 */
      347 
 19     1 /* Begin include file io_manager_dcls.incl.pl1 */
 19     2 
 19     3 /* Written by Charles Hornig, late 1980 and early 1981 */
 19     4 /* Modified for MR10 interface, February 1982 */
 19     5 /* Channel reconfiguration entries added by Chris Jones, January 1984 */
 19     6 
 19     7 /* These entries are callable on unwired stacks. */
 19     8 
 19     9 /* call io_manager$assign (Chx, Channel, Handler, Index, Statusp, Code); */
 19    10 dcl  io_manager$assign
 19    11 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 19    12 	fixed bin (35), ptr, fixed bin (35));
 19    13 
 19    14 /* call io_manager$assign_add (Chx, Channel, Handler, Index, Statusp, Code); */
 19    15 dcl  io_manager$assign_add
 19    16 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 19    17 	fixed bin (35), ptr, fixed bin (35));
 19    18 
 19    19 /* call io_manager$unassign (Chx, Code); */
 19    20 dcl  io_manager$unassign entry (fixed bin (35), fixed bin (35));
 19    21 
 19    22 /* call io_manager$unassign_delete (Chx, Code); */
 19    23 dcl  io_manager$unassign_delete entry (fixed bin (35), fixed bin (35));
 19    24 
 19    25 /* call io_manager$connect (Io_manager_arg); */
 19    26 dcl  io_manager$connect entry (1 aligned like io_manager_arg);
 19    27 
 19    28 /* call io_manager$connect_abs (Io_manager_arg); */
 19    29 dcl  io_manager$connect_abs entry (1 aligned like io_manager_arg);
 19    30 
 19    31 /* call io_manager$connect_direct (Io_manager_arg); */
 19    32 dcl  io_manager$connect_direct entry (1 aligned like io_manager_arg);
 19    33 
 19    34 /* call io_manager$get_status (Chx, Io_status_entry_ptr); */
 19    35 dcl  io_manager$get_status entry (fixed bin (35), ptr);
 19    36 
 19    37 /* call io_manager$mask (Chx); */
 19    38 dcl  io_manager$mask entry (fixed bin (35));
 19    39 
 19    40 /* call io_manager$ignore_interrupt (); */
 19    41 dcl  io_manager$ignore_interrupt entry (fixed bin (35), fixed bin (3), bit (36) aligned);
 19    42 
 19    43 /* call io_manager$data_tdcw (Io_manager_arg);
 19    44*   dcl  io_manager$data_tdcw entry (1 aligned like io_manager_arg);
 19    45*
 19    46*   /* call io_manager$workspace_tdcw (Io_manager_arg); */
 19    47 dcl  io_manager$workspace_tdcw entry (1 aligned like io_manager_arg);
 19    48 
 19    49 dcl  io_manager_arg_ptr ptr;
 19    50 dcl  1 io_manager_arg aligned based (io_manager_arg_ptr),
 19    51        2 chx fixed bin (35),				/* channel index from io_manager$assign */
 19    52        2 bound fixed bin (19),			/* workspace size */
 19    53        2 pcw bit (36) aligned,			/* or IDCW */
 19    54        2 listx fixed bin (18),			/* DCW list offset */
 19    55        2 ptp ptr,					/* page table pointer */
 19    56        2 listp ptr,					/* DCW list pointer */
 19    57        2 dcw_pair_ptr ptr;				/* DCW pair pointer */
 19    58 
 19    59 /* End include file io_manager_dcls.incl.pl1 */
      348 
 20     1 /* BEGIN INCLUDE FILE mcs_echo_neg_sys.incl.pl1   Bernard Greenberg 1/20/79 */
 20     2 
 20     3 /* Modified 6/29/79 by BSG for FNP echo negotiation */
 20     4 
 20     5 
 20     6 /****^  HISTORY COMMENTS:
 20     7*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
 20     8*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
 20     9*     To increase size of break table and to add named constants for the size.
 20    10*                                                   END HISTORY COMMENTS */
 20    11 
 20    12 
 20    13 /* This include file defines the wired structure for MCS echo negotiation */
 20    14 
 20    15 dcl echo_datap ptr;					/* Wired echo data ptr */
 20    16 dcl WIRED_ECHO_BREAK_SIZE fixed bin internal static options (constant) init (255);
 20    17 dcl WORDS_IN_ECHO_BREAK_TABLE fixed bin internal static options (constant) init (8);
 20    18 
 20    19 dcl 1 echo_data based (echo_datap) aligned,		/* Wired echo data */
 20    20     2 break (0: 255) bit (1) unaligned,			/* 1 = break on this character */
 20    21     2 synchronized bit (1) unal,			/* Mux echo negotiation is synchronized */
 20    22     2 mux_will_echnego bit (1) unal,			/* Multiplexer accepted start_neg_echnego */
 20    23     2 echo_start_pending_sndopt bit (1) unal,		/* Send start_n_e when SEND_OUTPUT comes */
 20    24     2 awaiting_start_sync bit (1) unal,			/* Awaiting mux reply ACK for start */
 20    25     2 awaiting_stop_sync bit (1) unal,			/* Awaiting mux reply ACK for stop */
 20    26     2 pad bit (27) unaligned,
 20    27     2 sync_ctr fixed bin (35),			/* Protocol ctr for MUX echo neg */
 20    28     2 chars_echoed fixed bin (9) unsigned unaligned,	/* Count of chars echoed */
 20    29     2 horiz_room_left fixed bin (9) unsigned unaligned,	/* Room left on line */
 20    30     2 rubout_trigger_chars (2) unaligned,		/* Characters that cause rubout action */
 20    31       3 char char (1) unaligned,
 20    32     2 rubout_sequence_length fixed bin (4) unsigned unaligned, /* Length of rubout sequence, output */
 20    33     2 rubout_pad_count fixed bin (4) unsigned unaligned,	/* Count of pads needed */
 20    34     2 buffer_rubouts bit (1) unaligned,			/* 1 = put rubouts and rubbed out in buffer */
 20    35     2 rubout_sequence char (12) unaligned;		/* Actual rubout sequence */
 20    36 
 20    37 /* END INCLUDE FILE mcs_echo_neg_sys.incl.pl1 */
      349 
      350 
      351 init_multiplexer:
      352      entry (a_devx, a_init_info_ptr, a_fnpp, a_code);
      353 
      354 /* This entry is called to initialize data bases preparatory to loading an FNP
      355*   *  In particular, it initializes the appropriate entry in fnp_info, and allocates
      356*   *   and initializes PCBs
      357**/
      358 
      359 
      360 	devx = a_devx;
      361 	miip = a_init_info_ptr;
      362 	mii_chan_count = mux_init_info.no_channels;
      363 	pcb_space_ptr = null ();			/* make cleanup safe */
      364 	infop = addr (dn355_data$);
      365 	ttybp = addr (tty_buf$);
      366 	lctp = tty_buf.lct_ptr;
      367 
      368 	lcntp = lct.lcnt_ptr;			/* get channel name */
      369 	if length (rtrim (lcnt.names (devx))) ^= 1
      370 	then go to bad_channel;
      371 	my_chan_name = rtrim (lcnt.names (devx));
      372 	call parse_fnp_name_ (my_chan_name, dno);
      373 	if dno < 0				/* unreasonable name */
      374 	then do;
      375 bad_channel:
      376 	     a_code = error_table_$bad_channel;
      377 	     go to init_exit;
      378 	end;
      379 
      380 	fnpp = addr (datanet_info.per_datanet (dno));
      381 	call TRACE ("init_multiplexer");		/* only error trace if bad devx */
      382 
      383 	if my_chan_name ^= fnp_info.fnp_tag
      384 	then go to bad_channel;
      385 	if ^tty_buf.fnp_config_flags (dno)
      386 	then go to bad_channel;
      387 
      388 	call lock$lock_fast (addr (datanet_info.configuration_lock));
      389 						/* noone else can configure */
      390 	fnp_info.lcte_ptr = addr (lct.lcte_array (devx));
      391 
      392 	if fnp_info.t_and_d_in_progress		/* lcte will be invalid, but still */
      393 	then do;
      394 	     code = error_table_$io_not_available;
      395 	     go to init_abort;
      396 	end;
      397 
      398 	call assign_channel (code);			/* under config lock */
      399 	if code ^= 0
      400 	then go to init_abort;			/* it may have been deconfigured while we were farting around */
      401 
      402 	call fnp_util$fill_page_table ((fnp_info.fnp_number), code);
      403 	if code ^= 0
      404 	then go to init_abort;			/* IOI has problems? */
      405 
      406 	do i = 0 to 2;				/* initialize line-number indexes */
      407 	     fnp_info.hsla_idx (i) = -1;
      408 	     fnp_info.lsla_idx (i) = -1;
      409 	end;
      410 	do i = 3 to 5;				/* 3 more for LSLAs */
      411 	     fnp_info.lsla_idx (i) = -1;
      412 	end;
      413 
      414 	pcb_space = size (pcb) * mii_chan_count;	/* get enough space for an array of PCBs */
      415 	space_needed = pcb_space + 8 * DCW_LIST_SIZE;
      416 	call tty_space_man$get_space (space_needed, pcb_space_ptr);
      417 	if pcb_space_ptr = null			/* this would be unfortunate */
      418 	then do;
      419 	     a_code = error_table_$noalloc;
      420 	     go to init_abort;
      421 	end;
      422 	n_pcbs, fnp_info.no_of_channels = mii_chan_count;
      423 	pcb_space_ptr -> pcb_array (*).saved_meters_ptr = null ();
      424 						/* for cleanup */
      425 	fnp_info.pcb_array_ptr = pcb_space_ptr;
      426 	fnp_info.dcw_list_array_ptr = addrel (pcb_space_ptr, pcb_space);
      427 	string (fnp_info.flags) = "0"b;
      428 	prev_la_no = -1;				/* so test will work right the first time */
      429 	old_flag = "1"b;				/* HSLA channels (if any) are always first */
      430 
      431 /*
      432*   * The following code assigns line numbers and sets the adapter indexes
      433*   * It assumes that channels in mux_init_info are sorted in ascending order
      434**/
      435 
      436 	do pcbx = 1 to n_pcbs;
      437 	     pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
      438 	     unspec (pcb) = "0"b;
      439 	     pcb.saved_meters_ptr = null ();		/* for cleanup dept */
      440 	     pcb.devx = mux_init_info.channels (pcbx).devx;
      441 	     lctep = addr (lct.lcte_array (pcb.devx));
      442 	     lcte.subchannel = pcbx;
      443 	     name = mux_init_info.channels (pcbx).name;
      444 	     call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
      445 	     if his_fnp_no ^= dno
      446 	     then do;
      447 		code = error_table_$bad_channel;
      448 		go to init_abort;
      449 	     end;
      450 	     if la_no = 7
      451 	     then fnp_info.tandd_pcbx = pcbx;
      452 	     else if (la_no ^= prev_la_no | hsla_flag ^= old_flag)
      453 						/* first subchannel on this adapter */
      454 	     then do;
      455 		if hsla_flag
      456 		then fnp_info.hsla_idx (la_no) = pcbx;
      457 		else fnp_info.lsla_idx (la_no) = pcbx;
      458 		prev_la_no = la_no;
      459 		old_flag = hsla_flag;
      460 	     end;
      461 
      462 	     pcb.subchan = subchan;
      463 	     pcb.is_hsla = hsla_flag;
      464 	     pcb.la_no = bit (bin (la_no, 3), 3);
      465 	     if hsla_flag
      466 	     then pcb.slot_no = bit (bin (subchan, 6), 6);
      467 
      468 
      469 /*	     * lsla slot number has to wait for baud rate supplied at bootload time */
      470 
      471 	     on area
      472 		begin;
      473 		code = error_table_$noalloc;
      474 		go to init_abort;
      475 	     end;
      476 
      477 	     call tty_area_manager$allocate (size (fnp_channel_meters), temp_saved_meters_ptr);
      478 	     pcb.saved_meters_ptr = temp_saved_meters_ptr;
      479 	end;
      480 
      481 	call lock$unlock_fast (addr (datanet_info.configuration_lock));
      482 
      483 	a_fnpp = fnpp;				/* pass this back */
      484 	a_code = 0;
      485 init_exit:
      486 	return;
      487 
      488 init_abort:
      489 	call TRACE_ERROR ("init_multiplexer", code);
      490 	call lock$unlock_fast (addr (datanet_info.configuration_lock));
      491 	if pcb_space_ptr ^= null
      492 	then do;
      493 	     do pcbx = 1 to n_pcbs;
      494 		pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
      495 		if pcb.saved_meters_ptr ^= null ()
      496 		then call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
      497 	     end;
      498 	     call tty_space_man$free_space (space_needed, pcb_space_ptr);
      499 	end;
      500 	a_code = code;
      501 	return;
      502 
      503 terminate_multiplexer:
      504      entry (a_fnpp, a_code);
      505 
      506 /* This entry is called after FNP crash or shutdown in order to free PCBs */
      507 
      508 	fnpp = a_fnpp;
      509 	ttybp = addr (tty_buf$);
      510 	infop = addr (dn355_data$);
      511 	locked = "0"b;
      512 	call TRACE ("terminate_multiplexer");
      513 	call lock;
      514 	if code ^= 0
      515 	then go to terminate_return;
      516 
      517 	if fnp_info.bootloading | fnp_info.wired | fnp_info.running
      518 						/* bad time to terminate */
      519 	then code = error_table_$invalid_state;
      520 
      521 	else do;
      522 	     do i = 1 to fnp_info.no_of_channels;
      523 		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));
      524 		if pcb.write_first ^= 0
      525 		then call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
      526 		if pcb.read_first ^= 0
      527 		then call tty_space_man$free_chain ((pcb.devx), INPUT, ptr (ttybp, pcb.read_first));
      528 		call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
      529 		if pcb.copied_meters_offset ^= 0	/* free this if it's there */
      530 		then do;
      531 		     call tty_space_man$free_space (size (fnp_channel_meters), ptr (ttybp, pcb.copied_meters_offset));
      532 		     pcb.copied_meters_offset = 0;
      533 		end;
      534 	     end;
      535 
      536 	     string (fnp_info.flags) = "0"b;
      537 	     call tty_space_man$free_space (size (pcb) * fnp_info.no_of_channels + 8 * DCW_LIST_SIZE,
      538 		fnp_info.pcb_array_ptr);
      539 	     fnp_info.pcb_array_ptr = null;
      540 	     code = 0;
      541 	end;
      542 
      543 	if fnp_info.io_manager_assigned
      544 	then call unassign_channel (code);		/* not deconfigured on us */
      545 	call fnp_util$free_page_table ((fnp_info.fnp_number), (0));
      546 						/* even if we lost the assignment ... */
      547 	call unlock;
      548 
      549 terminate_return:
      550 	if code ^= 0
      551 	then call TRACE_ERROR ("terminate_multiplexer", code);
      552 	a_code = code;
      553 	return;
      554 
      555 start:
      556      entry (a_fnpp, a_code);
      557 
      558 /* entry to enable an FNP by sending "accept_calls" order */
      559 
      560 	fnpp = a_fnpp;
      561 	infop = addr (dn355_data$);
      562 	call TRACE ("start");
      563 	chanx = 1;				/* this is irrelevant, but will make setup happy */
      564 	call setup;
      565 	if code = 0
      566 	then do;
      567 	     call dn355$send_global_wcd (fnpp, accept_calls, 18,
      568 		bit (bin (bin (rel (addr (tty_buf.free_space)), 18) + tty_buf.absorig, 18), 18));
      569 	     call unlock;				/* setup locked */
      570 	end;
      571 	if code ^= 0
      572 	then call TRACE_ERROR ("start", code);
      573 	a_code = code;
      574 	return;
      575 
      576 
      577 stop:
      578      entry (a_fnpp, a_code);
      579 
      580 /* entry to disable an FNP from further dialups (by sending dont_accept_calls order) */
      581 
      582 	fnpp = a_fnpp;
      583 	infop = addr (dn355_data$);
      584 	call TRACE ("stop");
      585 	chanx = 1;				/* as for start entry */
      586 	call setup;
      587 	if code = 0
      588 	then do;
      589 	     call dn355$send_global_wcd (fnpp, dont_accept_calls, 0, ""b);
      590 	     call unlock;				/* setup locked */
      591 	end;
      592 	if code ^= 0
      593 	then call TRACE_ERROR ("stop", code);
      594 	a_code = code;
      595 	return;
      596 
      597 
      598 shutdown:
      599      entry (a_fnpp, a_code);
      600 
      601 /* This entry simulates an FNP crash; if the FNP is up, all lines will be hung up */
      602 
      603 	infop = addr (dn355_data$);
      604 	fnpp = a_fnpp;
      605 	if fnpp = null ()
      606 	then do;
      607 	     if datanet_info.trace
      608 	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with null fnp_ptr");
      609 	     go to shutdown_return;
      610 	end;
      611 	call TRACE ("shutdown");
      612 	infop = addr (dn355_data$);
      613 
      614 	if fnp_info.wired | fnp_info.bootloading	/* do the user ring a favor */
      615 	then do;
      616 	     if datanet_info.trace
      617 	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with FNP wired.");
      618 	     call fnp_util$unwire ((fnp_info.fnp_number), code);
      619 	     if code ^= 0
      620 	     then call syserr$error_code (ANNOUNCE, code, "fnp_multiplexer$shutdown: Failed to unwire fnp.");
      621 	end;
      622 
      623 	locked = "0"b;
      624 	if fnp_info.running				/* if it's up now */
      625 	then do;
      626 	     call lock;
      627 	     call dn355$hangup_fnp_lines ((fnp_info.fnp_number));
      628 	     fnp_info.running = "0"b;
      629 	     call unlock;
      630 	end;
      631 
      632 
      633 shutdown_return:
      634 	a_code = 0;
      635 	return;
      636 
      637 
      638 read:
      639      entry (a_fnpp, a_subchan, a_chainp, a_mi_flag, a_code);
      640 
      641 /* this is a dummy entry, dn355 never holds input at interrupt time */
      642 
      643 	a_chainp = null;
      644 	a_mi_flag = "0"b;
      645 	a_code = 0;
      646 	return;
      647 
      648 
      649 write:
      650      entry (a_fnpp, a_subchan, a_output_ptr, a_code);
      651 
      652 	fnpp = a_fnpp;
      653 	chanx = a_subchan;
      654 	output_ptr = a_output_ptr;
      655 
      656 	call setup;
      657 	if code ^= 0
      658 	then do;
      659 	     a_code = code;
      660 	     return;
      661 	end;
      662 
      663 /* figure out length of chain */
      664 
      665 	blockp = output_ptr;
      666 	output_length = buffer.tally;			/* to start with */
      667 
      668 	do while (buffer.next ^= 0);
      669 	     blockp = ptr (ttybp, buffer.next);
      670 	     output_length = output_length + buffer.tally;
      671 	end;
      672 
      673 	if pcb.write_last ^= 0			/* existing write chain */
      674 	then do;
      675 	     lastp = ptr (ttybp, pcb.write_last);
      676 	     lastp -> buffer.next = bin (rel (output_ptr));
      677 	end;
      678 
      679 	else pcb.write_first = bin (rel (output_ptr));
      680 
      681 	pcb.write_last = bin (rel (blockp));		/* in any case */
      682 	pcb.write_cnt = pcb.write_cnt + output_length;
      683 
      684 	if pcb.send_output				/* if the FNP is ready for it */
      685 	then call dn355$send_wcd (fnpp, pcbp, accept_direct_output, 0, ""b);
      686 
      687 	code = 0;
      688 write_exit:
      689 	call unlock;
      690 	if code = 0
      691 	then a_output_ptr = null ();			/* so caller will know we took it all */
      692 	a_code = code;
      693 	return;
      694 
      695 control:
      696      entry (a_fnpp, a_subchan, a_order, a_data_ptr, a_code);
      697 
      698 	fnpp = a_fnpp;
      699 	chanx = a_subchan;
      700 	order = a_order;
      701 	data_ptr = a_data_ptr;
      702 
      703 	dumpin, dumpout, set_write_status, get_meters = "0"b;
      704 						/* initialize local variables */
      705 	opcode, alter_type = -1;
      706 	check = "0"b;
      707 
      708 	if order = "read_status"			/* there's never any at this level */
      709 	then do;
      710 	     data_ptr -> rd_stat.input_available = "0"b;
      711 	     a_code = 0;
      712 	     return;
      713 	end;
      714 
      715 	else if order = "hangup"
      716 	then do;
      717 	     mbx_data_len = 0;
      718 	     mbx_data = ""b;
      719 	     opcode = disconnect_this_line;
      720 	end;
      721 
      722 	else if order = "wru"
      723 	then do;
      724 	     alter_type = Wru;
      725 	     alter_data = ""b;
      726 	end;
      727 
      728 	else if order = "interrupt"
      729 	then do;
      730 	     alter_type = Break;
      731 	     alter_data = ""b;
      732 	end;
      733 
      734 	else if order = "start_xmit_hd" | order = "stop_xmit_hd"
      735 	then do;
      736 	     alter_type = Xmit_hold;
      737 	     alter_data = "00000000"b || (order = "start_xmit_hd");
      738 	end;
      739 
      740 	else if order = "set_input_message_size"
      741 	then do;
      742 	     mbx_data = bit (bin (data_ptr -> based_fb_word, 18), 18);
      743 	     opcode = sync_msg_size;
      744 	end;
      745 
      746 	else if order = "line_control"
      747 	then do;
      748 	     mbx_data_len = 72;
      749 	     mbx_data = data_ptr -> based_bit72;
      750 	     opcode = line_control;
      751 	end;
      752 
      753 	else if order = "set_framing_chars"
      754 	then do;
      755 	     mbx_data_len = 18;
      756 	     mbx_data = data_ptr -> based_bit18;	/* two characters are packed in halfword */
      757 	     opcode = set_framing_chars;
      758 	end;
      759 
      760 	else if order = "set_delay"
      761 	then do;
      762 	     mbx_data_len = 108;
      763 	     mbx_data = data_ptr -> based_bit108;	/* 6 18-bit values */
      764 	     opcode = set_delay_table;
      765 	end;
      766 
      767 	else if order = "abort"			/* i.e., resetread or resetwrite */
      768 	then do;
      769 	     dumpin = substr (data_ptr -> based_bit2, 2, 1);
      770 						/* we'll simply save this info for later */
      771 	     dumpout = substr (data_ptr -> based_bit2, 1, 1);
      772 	end;
      773 
      774 	else if order = "set_line_type"
      775 	then do;
      776 	     mbx_data_len = 18;
      777 	     local_line_type = data_ptr -> based_fb_word;
      778 	     if local_line_type <= 0 | local_line_type > max_line_type
      779 	     then go to order_error;
      780 	     check = "1"b;				/* we'll have to look at PCB (after locking) */
      781 	     opcode = set_line_type;
      782 	end;
      783 
      784 	else if order = "dial_out"
      785 	then do;					/* we have to convert digits (in char. form) to 6-bit BCD */
      786 	     digit_pos = 0;
      787 	     do i = 1 to length (data_ptr -> phone_chars);/* should never see "X" in phone number */
      788 		next_digit = index ("0123456789XXX!", substr (data_ptr -> phone_chars, i, 1)) - 1;
      789 						/* a value of 13 tells autocall unit to wait for a */
      790 						/* dial tone before asking for another dialing digit */
      791 		if next_digit >= 0
      792 		then if next_digit < 10 | next_digit = 13
      793 		     then do;			/* it's actually a digit */
      794 			digit_pos = digit_pos + 1;
      795 			phone_digits (digit_pos) = bit (next_digit, 6);
      796 		     end;
      797 	     end;
      798 
      799 	     phone_no_len = 6 * digit_pos;
      800 	     opcode = dial;
      801 	     check = "1"b;				/* special stuff required here too */
      802 	end;
      803 
      804 	else if order = "listen"
      805 	then do;
      806 	     alter_type = Listen;
      807 	     alter_data = "000000001"b;
      808 	end;
      809 
      810 	else if order = "write_status"
      811 	then set_write_status = "1"b;
      812 
      813 	else if order = "enter_receive"
      814 	then do;
      815 	     mbx_data_len = 0;
      816 	     mbx_data = ""b;
      817 	     opcode = enter_receive;
      818 	end;
      819 	else if order = "start_negotiated_echo"
      820 	then do;
      821 	     mbx_data_len = 36;
      822 	     mbx_data =
      823 		bit (fixed (data_ptr -> echo_start_data.ctr, 18), 18)
      824 		|| bit (fixed (data_ptr -> echo_start_data.screenleft, 18), 18);
      825 	     opcode = start_negotiated_echo;
      826 	end;
      827 	else if order = "set_echnego_break_table"
      828 	then do;
      829 	     mbx_data_len = length (unspec (echnego_break_table));
      830 	     unspec (echnego_break_table) = ""b;	/* Get pads */
      831 	     do i = 0 to hbound (echnego_break_table.words, 1);
      832 		echnego_break_table.bits (i) = substr (data_ptr -> based_echo_table_bits, 1 + 16 * i, 16);
      833 	     end;
      834 	     mbx_data_long = unspec (echnego_break_table);
      835 	     opcode = set_echnego_break_table;
      836 	end;
      837 	else if order = "init_echo_negotiation"
      838 	then do;
      839 	     mbx_data_len = 0;
      840 	     mbx_data = ""b;
      841 	     opcode = init_echo_negotiation;
      842 	end;
      843 	else if order = "stop_negotiated_echo"
      844 	then do;
      845 	     mbx_data_len = 0;
      846 	     mbx_data = ""b;
      847 	     opcode = stop_negotiated_echo;
      848 	end;
      849 	else if order = "input_flow_control_chars"
      850 	then do;
      851 	     mbx_data_len = 36;
      852 	     if data_ptr -> input_flow_control_info.resume_seq.count = 0
      853 						/* turning it all off */
      854 	     then mbx_data = ""b;
      855 	     else do;
      856 		mbx_data =
      857 		     unspec (substr (data_ptr -> input_flow_control_info.suspend_seq.chars, 1, 1))
      858 		     || unspec (substr (data_ptr -> input_flow_control_info.resume_seq.chars, 1, 1))
      859 		     || data_ptr -> input_flow_control_info.timeout;
      860 		if data_ptr -> input_flow_control_info.suspend_seq.count = 0
      861 		then substr (mbx_data, 1, 9) = "0"b;	/* don't send suspend char if there isn't one */
      862 	     end;
      863 	     opcode = input_fc_chars;
      864 	end;
      865 	else if order = "output_flow_control_chars"
      866 	then do;
      867 	     mbx_data_len = 36;
      868 	     if data_ptr -> output_flow_control_info.suspend_or_etb_seq.count = 0
      869 						/* no chars */
      870 	     then mbx_data = "0"b;
      871 	     else mbx_data =
      872 		     unspec (substr (data_ptr -> output_flow_control_info.suspend_or_etb_seq.chars, 1, 1))
      873 		     || unspec (substr (data_ptr -> output_flow_control_info.resume_or_ack_seq.chars, 1, 1))
      874 		     || data_ptr -> output_flow_control_info.block_acknowledge;
      875 	     opcode = output_fc_chars;
      876 	end;
      877 
      878 	else if order = "copy_meters"
      879 	then do;
      880 	     opcode = report_meters;
      881 	     check = "1"b;
      882 	end;
      883 
      884 	else if order = "get_meters"
      885 	then do;
      886 	     ret_meters_ptr = data_ptr -> get_comm_meters_info.parent_ptr;
      887 	     if ret_meters_ptr = null ()
      888 	     then return;
      889 	     else if ret_meters_ptr -> fnp_chan_meter_struc.version ^= FNP_CHANNEL_METERS_VERSION_1
      890 	     then do;
      891 		a_code = error_table_$unimplemented_version;
      892 		return;
      893 	     end;
      894 
      895 	     else get_meters = "1"b;
      896 	end;
      897 
      898 	else if order = "tandd_attach"
      899 	then do;					/* simulate a dialup without bothering the FNP (channel is hung up already) */
      900 	     call setup;
      901 	     if code ^= 0
      902 	     then do;
      903 		a_code = code;
      904 		return;
      905 	     end;
      906 
      907 	     if pcb.listen | pcb.dialed		/* can't have this */
      908 	     then do;
      909 		call unlock;
      910 		a_code = error_table_$resource_not_free;
      911 		return;
      912 	     end;
      913 
      914 	     pcb.dialed = "1"b;
      915 	     pcb.tandd_attached = "1"b;
      916 	     unspec (dialup_info) = ""b;
      917 	     dialup_info.baud_rate = 1200;		/* just so it's something */
      918 	     dialup_info.line_type = LINE_ASCII;	/* make everyone's life easier */
      919 	     dialup_info.max_buf_size = 16;		/* COLTS wants small buffers */
      920 	     call channel_manager$interrupt ((pcb.devx), DIALUP, unspec (dialup_info));
      921 	     call unlock;
      922 	     a_code = 0;
      923 	     return;
      924 	end;
      925 
      926 	else do;
      927 order_error:
      928 	     a_code = error_table_$undefined_order_request;
      929 	     return;
      930 	end;
      931 
      932 	code = 0;
      933 	call setup;
      934 	if code ^= 0
      935 	then do;
      936 	     a_code = code;
      937 	     return;
      938 	end;
      939 
      940 	if opcode = disconnect_this_line		/* hangup */
      941 	then do;
      942 	     pcb.listen, pcb.tandd_attached = "0"b;
      943 	end;
      944 
      945 	if opcode = start_negotiated_echo & (pcb.write_first ^= 0
      946 						/* We have queued output */
      947 	     | pcb.output_mbx_pending)
      948 	then do;					/* The FNP has not take the mbx. */
      949 						/* handler re-do it when he sees this. */
      950 	     call unlock;
      951 	     a_code = error_table_$invalid_write;
      952 	     return;
      953 	end;
      954 
      955 
      956 	if alter_type ^= -1				/* alter_parameters required */
      957 	then do;
      958 	     if alter_type = Listen
      959 	     then do;				/* need to tell it buffer size */
      960 		alter_data = alter_data || fnp_buf_size ();
      961 		pcb.listen = "1"b;
      962 	     end;
      963 
      964 	     mbx_data_len = length (alter_data) + 9;	/* 9 bits for subop type */
      965 	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
      966 	     opcode = alter_parameters;
      967 	end;
      968 
      969 	if opcode ^= -1				/* we do have to send the FNP something */
      970 	then do;
      971 	     if check				/* anything special about it */
      972 	     then do;
      973 		if opcode = set_line_type		/* make sure this is OK */
      974 		then if pcb.listen
      975 		     then do;			/* it isn't */
      976 			call unlock;
      977 			go to order_error;
      978 		     end;
      979 
      980 		     else do;
      981 			mbx_data = bit (bin (local_line_type, 18), 18);
      982 			do i = 1 to n_sync_line_types while (local_line_type ^= sync_line_type (i));
      983 			end;
      984 
      985 			pcb.sync_line = (i <= n_sync_line_types);
      986 		     end;
      987 
      988 		else if opcode = dial		/* in this case we have to supply buffer size first */
      989 		then do;				/* because no listen was done */
      990 		     mbx_data_len = 36;
      991 		     alter_data = bit (bin (Set_buffer_size, 9), 9) || "000000001"b;
      992 		     mbx_data = alter_data || fnp_buf_size ();
      993 		     call dn355$send_wcd (fnpp, pcbp, alter_parameters, mbx_data_len, mbx_data);
      994 
      995 		     mbx_data_len = phone_no_len;
      996 		     mbx_data_long = string (phone_digits);
      997 		end;
      998 		else if opcode = report_meters
      999 		then do;
     1000 		     call tty_space_man$get_space (size (fnp_channel_meters), meter_ptr);
     1001 						/* get a buffer for the FNP meters */
     1002 		     if meter_ptr = null ()		/* couldn't get it */
     1003 		     then do;
     1004 			call unlock;
     1005 			a_code = error_table_$noalloc;
     1006 			return;
     1007 		     end;
     1008 
     1009 		     pcb.copied_meters_offset = bin (rel (meter_ptr), 18);
     1010 		     mbx_data = bit (bin (tty_buf.absorig + pcb.copied_meters_offset, 18), 18);
     1011 		     mbx_data_len = 18;
     1012 		end;
     1013 	     end;
     1014 
     1015 	     call dn355$send_wcd (fnpp, pcbp, opcode, mbx_data_len, mbx_data_long);
     1016 	end;
     1017 
     1018 	else do;
     1019 	     if dumpin
     1020 	     then call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpinput, 9), 9));
     1021 
     1022 	     if dumpout
     1023 	     then do;				/* first get rid of any ring 0 output */
     1024 		if pcb.write_first ^= 0
     1025 		then do;
     1026 		     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
     1027 		     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;
     1028 		end;
     1029 
     1030 
     1031 		call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpoutput, 9), 9));
     1032 
     1033 		if pcb.end_frame
     1034 		then do;
     1035 		     pcb.end_frame = "0"b;
     1036 		     if pcb.send_output
     1037 		     then call channel_manager$interrupt ((pcb.devx), SEND_OUTPUT, ""b);
     1038 		end;
     1039 	     end;
     1040 
     1041 	     if set_write_status
     1042 	     then opend = (pcb.write_first ^= 0);	/* this has to be in automatic, return structure isn't wired */
     1043 
     1044 	     if get_meters
     1045 	     then do;
     1046 		call get_fnp_meters ("0"b);
     1047 		call unlock;
     1048 
     1049 		if code = 0
     1050 		then ret_meters_ptr -> fnp_chan_meter_struc.synchronous = pcb.sync_line;
     1051 		if fnp_meters_ptr ^= null ()
     1052 		then do;
     1053 		     if unspec (fnp_meters_ptr -> fnp_channel_meters) = "0"b
     1054 		     then code = error_table_$no_channel_meters;
     1055 		     else do;
     1056 			ret_meters_ptr -> fnp_chan_meter_struc.current_meters =
     1057 			     fnp_meters_ptr -> fnp_channel_meters;
     1058 			ret_meters_ptr -> fnp_chan_meter_struc.saved_meters =
     1059 			     pcb.saved_meters_ptr -> fnp_channel_meters;
     1060 		     end;
     1061 
     1062 		     call tty_space_man$free_space (size (fnp_channel_meters), fnp_meters_ptr);
     1063 		end;
     1064 	     end;
     1065 	end;
     1066 
     1067 	call unlock;
     1068 	if set_write_status
     1069 	then data_ptr -> wr_stat.output_pending = opend;
     1070 	a_code = code;
     1071 
     1072 	return;
     1073 
     1074 check_modes:
     1075      entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);
     1076 
     1077 /* this entry is used to determine if this multiplexer understands or accepts a given set of modes */
     1078 
     1079 	fnpp = a_fnpp;
     1080 	chanx = a_subchan;
     1081 	mclp = a_mode_list_ptr;
     1082 	if mcl.version ^= mcl_version_2
     1083 	then do;
     1084 	     a_code = error_table_$unimplemented_version;
     1085 	     return;
     1086 	end;
     1087 
     1088 	call setup;				/* now we need PCB pointer */
     1089 	if code ^= 0
     1090 	then do;
     1091 	     a_code = code;
     1092 	     return;
     1093 	end;
     1094 
     1095 	do modex = 1 to mcl.n_entries;
     1096 	     mclep = addr (mcl.entries (modex));
     1097 	     mode_name = substr (mcle.mode_name, 1, 8);
     1098 	     mode_on = mcle.mode_switch;
     1099 
     1100 	     do i = 1 to hbound (good_modes, 1) while (mode_name ^= good_modes (i));
     1101 	     end;
     1102 
     1103 	     if i <= hbound (good_modes, 1)		/* tree */
     1104 						/* it's one of the ones we always recognize */
     1105 	     then mcle.mpx_mode = "1"b;
     1106 	     else do;
     1107 		do i = 1 to hbound (async_only_modes, 1) while (mode_name ^= async_only_modes (i));
     1108 		end;
     1109 
     1110 		if i > hbound (async_only_modes, 1)	/* we've never heard of this one at all */
     1111 		then mcle.mpx_mode = "0"b;
     1112 		else do;
     1113 		     mcle.mpx_mode = ^pcb.sync_line;	/* this mode is meaningful for asynchronous lines only */
     1114 
     1115 		     do i = 1 to hbound (full_dpx_modes, 1) while (mode_name ^= full_dpx_modes (i));
     1116 		     end;
     1117 
     1118 		     if (mode_name = "no_outp" | mode_name = "8bit" | mode_name = "oddp") & mode_on
     1119 		     then if ^pcb.is_hsla
     1120 			then go to bad_mode;
     1121 
     1122 		     if i <= hbound (full_dpx_modes, 1) /* if this was a mode requiring full duplex capability */
     1123 		     then if mode_on
     1124 			then if pcb.line_type ^= LINE_ASCII & pcb.line_type ^= LINE_ASYNC1
     1125 				& pcb.line_type ^= LINE_ASYNC2 & pcb.line_type ^= LINE_ASYNC3
     1126 			     then do;
     1127 bad_mode:
     1128 				if mcle.force
     1129 				then mcle.mpx_mode = "0"b;
     1130 				else do;
     1131 				     code = error_table_$bad_mode;
     1132 				     mcle.error = "1"b;
     1133 				end;
     1134 			     end;
     1135 
     1136 		end;
     1137 	     end;
     1138 	end;
     1139 
     1140 	call unlock;				/* setup locked */
     1141 	a_code = code;
     1142 	return;
     1143 
     1144 set_modes:
     1145      entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);
     1146 
     1147 /* this entry sets a specified set of mode (probably by calling dn355$send_wcd) */
     1148 
     1149 	fnpp = a_fnpp;
     1150 	chanx = a_subchan;
     1151 	mclp = a_mode_list_ptr;
     1152 	if mcl.version ^= mcl_version_2
     1153 	then do;
     1154 	     a_code = error_table_$unimplemented_version;
     1155 	     return;
     1156 	end;
     1157 
     1158 	call setup;
     1159 	if code ^= 0
     1160 	then do;
     1161 	     a_code = code;
     1162 	     return;
     1163 	end;
     1164 
     1165 	hndlquit_set = "0"b;
     1166 	string (mode_set) = "0"b;			/* nothing set yet */
     1167 
     1168 	do modex = 1 to mcl.n_entries;
     1169 	     mclep = addr (mcl.entries (modex));
     1170 	     if mcle.mpx_mode			/* if this is one we're interested in */
     1171 	     then call process_mode (mcle.mode_name, mcle.mode_switch);
     1172 	end;
     1173 
     1174 	if mcl.init
     1175 	then do;					/* if "init" we must turn off the ones that weren't mentioned */
     1176 	     if ^hndlquit_set
     1177 	     then call process_mode ("hndlquit", "0"b);
     1178 
     1179 	     do modex = 1 to hbound (async_only_modes, 1);
     1180 		if ^mode_set (modex)
     1181 		then call process_mode (async_only_modes (modex), "0"b);
     1182 	     end;
     1183 	end;
     1184 
     1185 	call unlock;
     1186 	a_code = code;
     1187 	return;
     1188 
     1189 
     1190 
     1191 get_modes:
     1192      entry (a_fnpp, a_subchan, a_modes, a_code);
     1193 
     1194 /* this is a dummy, we don't keep records of modes at this level */
     1195 
     1196 	a_modes = "";
     1197 	a_code = 0;
     1198 	return;
     1199 
     1200 priv_control:
     1201      entry (a_fnpp, a_order, a_data_ptr, a_code);
     1202 
     1203 /* entry for privileged global orders */
     1204 
     1205 	fnpp = a_fnpp;
     1206 	order = a_order;
     1207 	data_ptr = a_data_ptr;
     1208 
     1209 	if order = "dump_fnp"
     1210 	then do;
     1211 	     call setup_fnp;
     1212 	     if code ^= 0
     1213 	     then do;
     1214 		a_code = code;
     1215 		return;
     1216 	     end;
     1217 
     1218 	     locked = "0"b;
     1219 	     call send_global (dump_mem);
     1220 	     if code ^= 0
     1221 	     then go to end_dump_mem;
     1222 
     1223 /* send_global will wait; come back here after notify */
     1224 
     1225 	     n_fnp_words = dump_fnp_info.fnp_len;
     1226 	     dump_fnp_info.bufp -> fnp_data = fnp_dump_ptr -> fnp_data;
     1227 
     1228 end_dump_mem:
     1229 	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
     1230 	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
     1231 						/* this was allocated by setup_fnp */
     1232 	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1233 	end;
     1234 
     1235 	else if order = "get_meters"
     1236 	then do;
     1237 	     fnp_meterp = data_ptr -> get_comm_meters_info.subchan_ptr;
     1238 	     if fnp_meterp ^= null
     1239 	     then do;
     1240 		if fnp_meters.version ^= FNP_METERS_VERSION_2
     1241 		then code = error_table_$unimplemented_version;
     1242 		else do;
     1243 		     ttybp = addr (tty_buf$);		/* we'll need this */
     1244 		     call lock;
     1245 		     if code ^= 0
     1246 		     then do;
     1247 			a_code = code;
     1248 			return;
     1249 		     end;
     1250 
     1251 		     call get_fnp_meters ("1"b);
     1252 
     1253 		     if code = 0
     1254 		     then do;
     1255 			fnp_meters.n_channels = fnp_info.no_of_channels;
     1256 			fnp_meters.output_mbx_in_use_cum = fnp_info.cumulative_mbx_in_use;
     1257 			fnp_meters.output_mbx_updates = fnp_info.mbx_in_use_updated;
     1258 			fnp_meters.output_mbx_unavailable = fnp_info.mbx_unavailable;
     1259 			fnp_meters.max_output_mbx_in_use = fnp_info.max_mbx_in_use;
     1260 			fnp_meters.queue_entries_made = fnp_info.q_entries_made;
     1261 			fnp_meters.input_rejects = fnp_info.input_reject_count;
     1262 			fnp_meters.processed_from_q = fnp_info.processed_from_q;
     1263 			fnp_meters.fnp_channel_locked = fnp_info.fnp_channel_locked;
     1264 			fnp_meters.input_data_transactions = fnp_info.input_data_transactions;
     1265 			fnp_meters.output_data_transactions = fnp_info.output_data_transactions;
     1266 			fnp_meters.input_control_transactions = fnp_info.input_control_transactions;
     1267 			fnp_meters.output_control_transactions = fnp_info.output_control_transactions;
     1268 			fnp_meters.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output;
     1269 			fnp_meters.fnp_mem_size = fnp_info.fnp_mem_size;
     1270 			begin;
     1271 declare  iom fixed bin (3);
     1272 declare  chan fixed bin (7);
     1273 			     call io_chnl_util$name_to_iom (fnp_info.io_chanid, iom, chan, (0));
     1274 			     fnp_meters.iom_number = iom;
     1275 			     fnp_meters.iom_chan_no = chan;
     1276 			end;
     1277 
     1278 		     end;
     1279 
     1280 		     call unlock;
     1281 
     1282 		     if fnp_meters_ptr ^= null ()	/* let's make sure this is for real */
     1283 		     then do;
     1284 			data_ptr -> get_comm_meters_info.subchan_ptr -> fnp_meters.from_fnp =
     1285 			     fnp_meters_ptr -> fnp_global_meters;
     1286 
     1287 			call tty_space_man$free_space (size (fnp_global_meters), fnp_meters_ptr);
     1288 		     end;
     1289 
     1290 		     lctep = fnp_info.lcte_ptr;	/* since we don't call channel_manager, */
     1291 		     lcmp = data_ptr -> get_comm_meters_info.logical_chan_ptr;
     1292 						/* we have to copy logical channel data ourselves */
     1293 		     if lcmp ^= null ()
     1294 		     then do;
     1295 			lcmp -> logical_chan_meters.current_meters = lcte.meters;
     1296 			unspec (lcmp -> logical_chan_meters.saved_meters) = "0"b;
     1297 						/* no saved meters for an FNP */
     1298 		     end;
     1299 		end;
     1300 	     end;
     1301 	end;
     1302 
     1303 	else code = error_table_$undefined_order_request;
     1304 
     1305 	a_code = code;
     1306 	return;
     1307 
     1308 hpriv_control:
     1309      entry (a_fnpp, a_order, a_data_ptr, a_code);
     1310 
     1311 /* entry for highly-privileged global orders */
     1312 
     1313 	fnpp = a_fnpp;
     1314 	order = a_order;
     1315 	data_ptr = a_data_ptr;
     1316 	locked = "0"b;
     1317 	code = 0;
     1318 
     1319 	if order = "patch_fnp"
     1320 	then do;
     1321 	     call setup_fnp;
     1322 	     if code ^= 0
     1323 	     then do;
     1324 		a_code = code;
     1325 		return;
     1326 	     end;
     1327 	     n_fnp_words = dump_fnp_data.fnp_len;
     1328 	     sourcep = dump_fnp_info.bufp;
     1329 
     1330 	     fnp_dump_ptr -> fnp_data = sourcep -> fnp_data;
     1331 	     call syserr (ANNOUNCE, "fnp_multiplexer: patching FNP ^a for ^a:", fnp_info.fnp_tag, pds$process_group_id);
     1332 						/* tell operator about it */
     1333 
     1334 	     temp_addr = dump_fnp_data.fnp_addr;
     1335 	     do i = 1 to dump_fnp_data.fnp_len;
     1336 		call syserr (ANNOUNCE, "^6w from ^6.3b to ^6.3b", temp_addr,
     1337 		     dump_fnp_info.old_value_ptr -> fnp_data (i), dump_fnp_info.bufp -> fnp_data (i));
     1338 		temp_addr = temp_addr + 1;
     1339 	     end;
     1340 
     1341 	     call send_global (patch_mem);		/* send it off and wait */
     1342 	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
     1343 	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
     1344 						/* this was allocated by setup_fnp */
     1345 	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1346 	end;
     1347 
     1348 	else if order = "fnp_break"
     1349 	then do;
     1350 	     call setup_fnp;
     1351 	     if code ^= 0
     1352 	     then do;
     1353 		a_code = code;
     1354 		return;
     1355 	     end;
     1356 	     fnp_break_data.action = fnp_break_info.action;
     1357 						/* copy info */
     1358 	     fnp_break_data.fnp_addr = fnp_break_info.fnp_addr;
     1359 	     fnp_break_data.flags = substr (fnp_break_info.flags, 1, 18);
     1360 	     name = fnp_break_info.chan_name;
     1361 	     if name = ""
     1362 	     then fnp_break_data.lineno = -1;		/* no line, i.e. any line */
     1363 	     else do;
     1364 		call name_to_pcb (name);
     1365 		if code ^= 0
     1366 		then do;
     1367 		     a_code = code;
     1368 		     return;
     1369 		end;
     1370 		fnp_break_data.lineno = bin (string (pcb.line_number));
     1371 	     end;
     1372 
     1373 	     mbx_data = addr (fnp_break_data) -> based_bit72;
     1374 	     if ^locked
     1375 	     then call lock;
     1376 	     if code = 0
     1377 	     then do;
     1378 		call dn355$send_global_wcd (fnpp, fnp_break, 72, mbx_data);
     1379 		call unlock;
     1380 	     end;
     1381 	end;
     1382 
     1383 	else if order = "enable_breakall_mode"
     1384 	then ;
     1385 
     1386 	else if order = "disable_breakall_mode"
     1387 	then ;
     1388 
     1389 	else code = error_table_$undefined_order_request;
     1390 
     1391 hpriv_exit:
     1392 	a_code = code;
     1393 	return;
     1394 
     1395 fnp_lock:
     1396      entry (a_fnpp, a_code);				/* Non-wired lock entry */
     1397 
     1398 	fnpp = a_fnpp;
     1399 	call lock;
     1400 	a_code = code;
     1401 	return;
     1402 
     1403 fnp_unlock:
     1404      entry (a_fnpp);
     1405 
     1406 	fnpp = a_fnpp;
     1407 	mylock = "0"b;
     1408 	locked = "1"b;
     1409 	call unlock;
     1410 	return;
     1411 
     1412 setup:
     1413      proc;
     1414 
     1415 /* initial setup for per-channel stuff */
     1416 
     1417 
     1418 	code = 0;					/* innocent until proven guilty */
     1419 	ttybp = addr (tty_buf$);
     1420 	infop = addr (dn355_data$);
     1421 	locked, queue_locked = "0"b;
     1422 	call lock;
     1423 	if code ^= 0
     1424 	then return;
     1425 
     1426 	if fnp_info.running
     1427 	then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (chanx));
     1428 	else do;
     1429 	     call unlock;
     1430 	     code = error_table_$mpx_down;
     1431 	     return;
     1432 	end;
     1433 
     1434 	if pcb.copied_meters_ready			/* dn355 left them for us */
     1435 	then if ^lcte.locked_for_interrupt		/* make sure we're on call side */
     1436 	     then call save_copied_meters;
     1437 
     1438 	return;
     1439      end setup;
     1440 
     1441 
     1442 
     1443 setup_fnp:
     1444      proc;
     1445 
     1446 dcl  (fnp_address, fnp_len) fixed bin (18);
     1447 
     1448 /* this procedure is used instead of setup for privileged global orders */
     1449 
     1450 	if fnpp = null ()
     1451 	then go to setup_fnp_down;
     1452 	code = 0;
     1453 	if fnp_info.mbx_pt = null ()			/* this one isn't configured */
     1454 	     | ^fnp_info.running			/* or it isn't up */
     1455 	then do;
     1456 setup_fnp_down:
     1457 	     code = error_table_$mpx_down;
     1458 	     return;
     1459 	end;
     1460 
     1461 	ttybp = addr (tty_buf$);
     1462 	infop = addr (dn355_data$);
     1463 
     1464 	if order = "fnp_break"
     1465 	then return;				/* done if break order */
     1466 	if fnp_info.dump_patch_disabled
     1467 	then do;
     1468 	     code = error_table_$timeout;
     1469 	     return;
     1470 	end;
     1471 
     1472 	fnp_address = dump_fnp_info.fnp_address;
     1473 	fnp_len = dump_fnp_info.fnp_len;
     1474 	if order = "dump_fnp"
     1475 	then do;					/* check dump params */
     1476 	     if fnp_len <= 0 | fnp_len > 64
     1477 	     then do;
     1478 bad_fnp_len:
     1479 		code = error_table_$buffer_big;
     1480 		return;
     1481 	     end;
     1482 	end;
     1483 	else if order = "patch_fnp"
     1484 	then if fnp_len <= 0 | fnp_len > 32
     1485 	     then go to bad_fnp_len;
     1486 
     1487 	if (fnp_address < 0) | ((fnp_address + fnp_len) > fnp_info.fnp_mem_size)
     1488 	then do;
     1489 	     code = error_table_$dev_offset_out_of_bounds;
     1490 	     return;
     1491 	end;
     1492 
     1493 	if ^stac (addr (fnp_info.dump_patch_lock), pds$processid)
     1494 						/* lock the dump_patch function */
     1495 	then do;					/* if possible */
     1496 	     code = error_table_$seglock;
     1497 	     return;
     1498 	end;
     1499 
     1500 	dump_patch_space = divide (fnp_len + 1, 2, 17, 0);
     1501 	call tty_space_man$get_space (dump_patch_space, fnp_dump_ptr);
     1502 	if fnp_dump_ptr = null			/* couldn't get the space */
     1503 	then do;
     1504 	     code = error_table_$noalloc;
     1505 	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1506 	     return;
     1507 	end;
     1508 
     1509 	dump_patch_time = clock ();
     1510 	fnp_info.dump_patch_in_progress = "1"b;
     1511 	dump_fnp_data.abs_addr = bin (rel (fnp_dump_ptr)) + tty_buf.absorig;
     1512 						/* dump/patch is paged too ... */
     1513 	dump_fnp_data.fnp_addr = fnp_address;
     1514 	dump_fnp_data.fnp_len = fnp_len;
     1515 	return;
     1516 
     1517      end setup_fnp;
     1518 
     1519 save_copied_meters:
     1520      proc;
     1521 
     1522 /* internal procedure called  to pick up copied meters left in tty_buf by FNP */
     1523 
     1524 dcl  copied_meters_ptr ptr;
     1525 
     1526 	if pcb.copied_meters_offset ^= 0		/* make sure it's legit */
     1527 	then do;
     1528 	     copied_meters_ptr = ptr (ttybp, pcb.copied_meters_offset);
     1529 
     1530 /* zero out pad fields, which contain random junk (possibly input) from the FNP */
     1531 
     1532 	     if pcb.sync_line
     1533 	     then copied_meters_ptr -> fnp_sync_meters.pad (*) = 0;
     1534 	     else copied_meters_ptr -> fnp_async_meters.pad (*) = 0;
     1535 
     1536 	     pcb.saved_meters_ptr -> fnp_channel_meters = copied_meters_ptr -> fnp_channel_meters;
     1537 	     call tty_space_man$free_space (size (fnp_channel_meters), copied_meters_ptr);
     1538 						/* through with buffer now */
     1539 	     pcb.copied_meters_offset = 0;
     1540 	     pcb.copied_meters_ready = "0"b;
     1541 	end;
     1542 
     1543 	return;
     1544      end save_copied_meters;
     1545 
     1546 process_mode:
     1547      proc (mode_name, mode_on);
     1548 
     1549 dcl  mode_name char (*);
     1550 dcl  mode_on bit (1);
     1551 dcl  mode_name_index fixed bin;
     1552 
     1553 	alter_data = "00000000"b || mode_on;
     1554 
     1555 	if mode_name = "hndlquit"
     1556 	then do;
     1557 	     alter_type = Hndlquit;
     1558 	     pcb.hndlquit = mode_on;
     1559 	     hndlquit_set = "1"b;
     1560 	end;
     1561 
     1562 	else if ^pcb.sync_line			/* if we haven't already decided what to do */
     1563 	then do;
     1564 	     if mode_name = "blk_xfer" | mode_name = "iflow"
     1565 						/* special stuff here */
     1566 	     then do;
     1567 		if mode_name = "blk_xfer"
     1568 		then do;
     1569 		     mode_name_index = BLK_XFER_INDEX;
     1570 		     alter_type = Block_xfer;
     1571 		end;
     1572 		else do;
     1573 		     mode_name_index = IFLOW_INDEX;
     1574 		     alter_type = Input_flow_control;
     1575 		end;
     1576 
     1577 		if mode_on
     1578 		then do;				/* we have to tell it buffer sizes */
     1579 		     chars_per_sec = divide (pcb.baud_rate, 10, 17, 0);
     1580 		     base_len, block_len = divide (chars_per_sec, buf_per_second, 17, 0);
     1581 						/* and 1/2 second thereafter */
     1582 		end;
     1583 		else do;
     1584 		     base_len = 56;
     1585 		     block_len = 0;
     1586 		end;
     1587 
     1588 		alter_data = alter_data || bit (bin (base_len, 18), 18) || bit (bin (block_len, 18), 18);
     1589 		mode_set (mode_name_index) = "1"b;
     1590 	     end;
     1591 
     1592 	     else do;
     1593 		do i = 1 to hbound (mode_alter_types, 1) while (mode_name ^= async_only_modes (i));
     1594 		end;				/* note that blk_xfer is the last async_mode */
     1595 
     1596 		if i > hbound (mode_alter_types, 1)
     1597 		then code = error_table_$bad_mode;
     1598 
     1599 		else do;
     1600 		     alter_type = mode_alter_types (i);
     1601 		     mode_set (i) = "1"b;		/* this one is set now */
     1602 		end;
     1603 	     end;
     1604 	end;
     1605 
     1606 	if code = 0
     1607 	then do;
     1608 	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
     1609 	     call dn355$send_wcd (fnpp, pcbp, alter_parameters, length (alter_data) + 9, mbx_data);
     1610 	end;
     1611 	return;
     1612      end;
     1613 
     1614 send_global:
     1615      proc (opcode);
     1616 
     1617 /* this procedure calls dn355$send_global_wcd for the dump_fnp and patch_fnp orders */
     1618 
     1619 dcl  opcode fixed bin (8);
     1620 
     1621 	call pxss$addevent (FNP_DUMP_PATCH_EVENT);	/* so we'll be able to wait */
     1622 	mbx_data = addr (dump_fnp_data) -> based_bit72;
     1623 	call lock;
     1624 	if code ^= 0
     1625 	then return;
     1626 
     1627 	call dn355$send_global_wcd (fnpp, opcode, 72, mbx_data);
     1628 	call unlock;
     1629 
     1630 	call pxss$wait;				/* mustn't do anything till it's done */
     1631 
     1632 	do while (fnp_info.dump_patch_in_progress);	/* didn't complete yet */
     1633 	     if ^fnp_info.running			/* FNP crashed out from under us */
     1634 	     then do;
     1635 		code = error_table_$mpx_down;
     1636 		fnp_info.dump_patch_in_progress = "0"b; /* so we'll get out of loop */
     1637 	     end;
     1638 
     1639 	     else if clock () - dump_patch_time > DUMP_PATCH_LIMIT
     1640 						/* time's up! */
     1641 	     then do;
     1642 		code = error_table_$timeout;		/* can this operation */
     1643 		fnp_info.dump_patch_disabled = "1"b;
     1644 		fnp_info.dump_patch_in_progress = "0"b;
     1645 		call syserr (ANNOUNCE, "fnp_multiplexer: ^[dump^;patch^]_fnp order to FNP ^a timed out.",
     1646 		     opcode = dump_mem, fnp_info.fnp_tag);
     1647 	     end;
     1648 
     1649 	     else do;				/* must be someone else's notify */
     1650 		call pxss$addevent (FNP_DUMP_PATCH_EVENT);
     1651 		if fnp_info.dump_patch_in_progress	/* make sure it still hasn't happened */
     1652 		then call pxss$wait;
     1653 		else call pxss$delevent (FNP_DUMP_PATCH_EVENT);
     1654 						/* never mind, it's done */
     1655 	     end;
     1656 
     1657 	end;
     1658 
     1659 	return;					/* all right, we're done */
     1660 
     1661      end send_global;
     1662 
     1663 get_fnp_meters:
     1664      proc (global);
     1665 
     1666 /* subroutine to issue request for meters from FNP and wait for them to arrive */
     1667 
     1668 dcl  global bit (1) parameter;			/* indicates whether subchannel or whole FNP */
     1669 dcl  space_size fixed bin;
     1670 dcl  fnp_meter_wait_start fixed bin (71);
     1671 
     1672 	if fnp_info.dump_patch_disabled
     1673 	then do;
     1674 	     code = error_table_$timeout;		/* don't even try */
     1675 	     fnp_meters_ptr = null ();		/* so caller won't try to free space */
     1676 	     return;
     1677 	end;
     1678 
     1679 	if global
     1680 	then space_size = size (fnp_global_meters);
     1681 	else space_size = size (fnp_channel_meters);
     1682 
     1683 	call tty_space_man$get_space (space_size, fnp_meters_ptr);
     1684 	if fnp_meters_ptr = null ()
     1685 	then do;
     1686 	     code = error_table_$noalloc;
     1687 	     return;
     1688 	end;
     1689 
     1690 	mbx_data = bit (bin (tty_buf.absorig + bin (rel (fnp_meters_ptr)), 18), 18);
     1691 	call pxss$addevent (FNP_METER_EVENT);
     1692 	fnp_meter_wait_start = clock ();
     1693 
     1694 	if global					/* it's for whole FNP */
     1695 	then do;
     1696 	     if fnp_info.get_meters_waiting
     1697 	     then do;
     1698 		code = error_table_$seglock;		/* can't have two going at once */
     1699 		return;
     1700 	     end;
     1701 
     1702 	     fnp_info.get_meters_waiting = "1"b;
     1703 	     call dn355$send_global_wcd (fnpp, report_meters, 18, mbx_data);
     1704 	     pcbp = fnpp;				/* to avoid faults in loop test */
     1705 	end;
     1706 
     1707 	else do;
     1708 	     pcb.get_meters_waiting = "1"b;
     1709 	     call dn355$send_wcd (fnpp, pcbp, report_meters, 18, mbx_data);
     1710 	end;
     1711 
     1712 	call unlock;				/* while waiting */
     1713 	call pxss$wait;
     1714 	call lock;				/* while checking */
     1715 
     1716 	do while ((global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting));
     1717 	     if ^fnp_info.running
     1718 	     then do;
     1719 		code = error_table_$mpx_down;
     1720 		go to abort_get_meters;
     1721 	     end;
     1722 
     1723 	     else if clock () - fnp_meter_wait_start > DUMP_PATCH_LIMIT
     1724 	     then do;
     1725 		code = error_table_$timeout;
     1726 		fnp_info.dump_patch_disabled = "1"b;
     1727 		call syserr (ANNOUNCE,
     1728 		     "fnp_multiplexer: get_meters order for FNP ^a^[^s^;, line ^o,^] timed out.", fnp_info.fnp_tag,
     1729 		     global, string (pcb.line_number));
     1730 abort_get_meters:
     1731 		if global
     1732 		then fnp_info.get_meters_waiting = "0"b;
     1733 		else pcb.get_meters_waiting = "0"b;
     1734 	     end;
     1735 
     1736 	     else do;
     1737 		call unlock;			/* in case we wait some more */
     1738 		call pxss$addevent (FNP_METER_EVENT);
     1739 		if (global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting)
     1740 						/* check if it happened since we checked */
     1741 		then call pxss$wait;
     1742 		else call pxss$delevent (FNP_METER_EVENT);
     1743 		call lock;
     1744 	     end;
     1745 	end;
     1746 
     1747 	return;
     1748      end get_fnp_meters;
     1749 
     1750 name_to_pcb:
     1751      proc (name);
     1752 
     1753 dcl  name char (*);
     1754 
     1755 	code = 0;
     1756 	call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
     1757 	call lock;
     1758 	if code ^= 0
     1759 	then return;
     1760 
     1761 	if his_fnp_no ^= fnp_info.fnp_number
     1762 	then go to bad_device;
     1763 
     1764 	if hsla_flag
     1765 	then pcbx = fnp_info.hsla_idx (la_no);
     1766 	else pcbx = fnp_info.lsla_idx (la_no);
     1767 	if pcbx = -1
     1768 	then go to bad_device;
     1769 
     1770 	found, past = "0"b;
     1771 	do j = pcbx to fnp_info.no_of_channels while (^past & ^found);
     1772 	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
     1773 	     if pcb.la_no ^= bit (bin (la_no, 3), 3)
     1774 	     then past = "1"b;
     1775 	     else if pcb.slot_no = bit (bin (subchan, 6), 6)
     1776 	     then found = "1"b;
     1777 	end;
     1778 
     1779 	if ^found
     1780 	then do;
     1781 bad_device:
     1782 	     call unlock;
     1783 	     code = error_table_$bad_channel;
     1784 	     return;
     1785 	end;
     1786 
     1787 	return;
     1788      end name_to_pcb;
     1789 
     1790 lock:
     1791      proc;
     1792 
     1793 /* subroutine to lock the mailbox lock (which incidentally protects PCBs too) */
     1794 
     1795 	if fnpp = null ()
     1796 	then do;
     1797 	     code = error_table_$mpx_down;
     1798 	     return;
     1799 	end;
     1800 
     1801 	code = 0;
     1802 
     1803 	lctep = fnp_info.lcte_ptr;
     1804 	if lcte.lock = pds$processid			/* called as result of our own interrupt? */
     1805 	then if lcte.locked_for_interrupt
     1806 	     then mylock = "1"b;			/* remember not to unlock it */
     1807 	     else call syserr (CRASH_SYSTEM, "fnp_multiplexer: mylock error");
     1808 	else do;
     1809 	     mylock = "0"b;
     1810 	     call tty_lock$lock_lcte (lctep, code);
     1811 	     locked = (code = 0);
     1812 	end;
     1813 	return;
     1814      end lock;
     1815 
     1816 
     1817 
     1818 unlock:
     1819      proc;
     1820 
     1821 /* subroutine to release mailbox lock and process queued interrupts */
     1822 
     1823 	if locked
     1824 	then if ^mylock
     1825 	     then do;
     1826 
     1827 		call dn355$process_interrupt_queue ((fnp_info.fnp_number));
     1828 		locked = "0"b;			/* it unlocks the channel lock when it's done */
     1829 
     1830 	     end;
     1831 	return;
     1832 
     1833      end unlock;
     1834 
     1835 
     1836 fnp_buf_size:
     1837      proc returns (bit (18));
     1838 
     1839 /* internal procedure returns correct buffer size for FNP to use, based on baud rate
     1840*   *  and synchronous/asynchronous
     1841**/
     1842 
     1843 	do i = 1 to n_sync_line_types while (pcb.line_type ^= sync_line_type (i));
     1844 	end;
     1845 
     1846 	if i <= n_sync_line_types
     1847 	then do;
     1848 	     pcb.sync_line = "1"b;
     1849 	     chars_per_buf = divide (divide (pcb.baud_rate, 8, 17, 0), buf_per_second, 17, 0);
     1850 	end;
     1851 
     1852 	else do;
     1853 	     pcb.sync_line = "0"b;
     1854 	     chars_per_buf = 56;			/* always minimum for asynchronous */
     1855 	end;
     1856 
     1857 	return (bit (bin (chars_per_buf, 18), 18));
     1858      end fnp_buf_size;
     1859 
     1860 
     1861 /**** Wired entrypoints to talk to io_manager for both fnp_multiplexer
     1862*      and the fnp_util TandD code. These should be called under
     1863*      the FNP lcte lock. */
     1864 
     1865 declare  a_fnp_no fixed bin;
     1866 declare  fnp_no fixed bin;
     1867 
     1868 assign:
     1869      entry (a_fnp_no, a_code);
     1870 
     1871 	infop = addr (dn355_data$);
     1872 	call TRACE ("assign");
     1873 	fnp_no = a_fnp_no;
     1874 	fnpp = addr (datanet_info.per_datanet (fnp_no));
     1875 	call assign_channel (code);
     1876 	a_code = code;
     1877 	return;
     1878 
     1879 
     1880 unassign:
     1881      entry (a_fnp_no, a_code);
     1882 
     1883 	fnp_no = a_fnp_no;
     1884 	infop = addr (dn355_data$);
     1885 	call TRACE ("unassign");
     1886 	fnpp = addr (datanet_info.per_datanet (fnp_no));
     1887 
     1888 	call unassign_channel (code);
     1889 	a_code = code;
     1890 	return;
     1891 
     1892 
     1893 assign_channel:
     1894      procedure (code);
     1895 declare  code fixed bin (35);
     1896 
     1897 	code = 0;
     1898 	if ^fnp_info.available
     1899 	then do;
     1900 	     code = error_table_$io_not_configured;	/* "not available" */
     1901 	     go to assign_channel_return;
     1902 	end;
     1903 
     1904 	if fnp_info.io_manager_assigned
     1905 	then do;
     1906 	     code = error_table_$io_assigned;
     1907 	     go to assign_channel_return;
     1908 	end;
     1909 
     1910 	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, dn355$interrupt, (fnp_info.fnp_number),
     1911 	     (null ()), code);
     1912 	fnp_info.io_manager_assigned = (code = 0);
     1913 assign_channel_return:
     1914 	if datanet_info.trace | datanet_info.debug_stop
     1915 	then call syserr (ANNOUNCE, "fnp_multiplexer$assign_channel: Assignment of FNP ^a ^[succeeded^;failed^].",
     1916 		fnp_info.fnp_tag, (code = 0));
     1917 	if code ^= 0
     1918 	then call TRACE_ERROR ("assign_channel", code);
     1919 	return;
     1920      end assign_channel;
     1921 
     1922 unassign_channel:
     1923      procedure (code);
     1924 declare  code fixed bin (35);
     1925 
     1926 
     1927 	if ^fnp_info.io_manager_assigned
     1928 	then do;
     1929 	     code = error_table_$io_not_assigned;
     1930 	     go to unassign_return;
     1931 	end;
     1932 	call io_manager$unassign (fnp_info.io_manager_chx, code);
     1933 	if code = 0
     1934 	then fnp_info.io_manager_assigned = "0"b;
     1935 unassign_return:
     1936 	if datanet_info.trace | datanet_info.debug_stop
     1937 	then call syserr$error_code (ANNOUNCE, code,
     1938 		"fnp_multiplexer$unassign_channel: Unassignment of FNP ^a ^[failed^;succeeded^].", fnp_info.fnp_tag,
     1939 		(code ^= 0));
     1940 	if code ^= 0
     1941 	then call TRACE_ERROR ("unassign_channel", code);
     1942 	return;
     1943      end unassign_channel;
     1944 
     1945 TRACE:
     1946      procedure (Entry);
     1947 
     1948 declare  Entry char (32);
     1949 
     1950 	if datanet_info.trace
     1951 	then call syserr (ANNOUNCE, "fnp_multiplexer$^a: Tracing call.", Entry);
     1952 	return;
     1953 
     1954 
     1955 
     1956 TRACE_ERROR:
     1957      entry (Entry, Code);
     1958 
     1959 declare  Code fixed bin (35);
     1960 
     1961 	if datanet_info.trace | datanet_info.debug_stop
     1962 	then call syserr$error_code (ANNOUNCE, Code, "fnp_multiplexer$^a: Tracing error.", Entry);
     1963 	if datanet_info.debug_stop
     1964 	then call syserr (CRASH_SYSTEM, "fnp_multiplexer: debugging stop (type go to continue).");
     1965 	return;
     1966      end TRACE;
     1967 
     1968 /* BEGIN MESSAGE DOCUMENTATION
     1969*
     1970*   Message:
     1971*   fnp_multiplexer: patching FNP X for USER:
     1972*   ADDR from XXX to YYY
     1973*
     1974*   S:	$info
     1975*
     1976*   T:	$run
     1977*
     1978*   M:	The memory of FNP X is being patched by the privileged
     1979*   user whose user_id is USER. ADDR is the absolute location in FNP memory that is being
     1980*   patched (in octal); XXX and YYY are the old and new values of the location
     1981*   respectively (also in octal).
     1982*   The second line may be repeated (with different values) if more than one word
     1983*   is being patched.
     1984*
     1985*   A:	This information is for logging purposes.
     1986*
     1987*
     1988*   Message:
     1989*   fnp_multiplexer: mylock error
     1990*
     1991*   S:	$crash
     1992*
     1993*   T:	$run
     1994*
     1995*   M:	An attempt has been made to lock an FNP channel lock to a process
     1996*   that already has it locked.
     1997*
     1998*   A:	$inform
     1999*
     2000*
     2001*   Message:
     2002*   fnp_multiplexer: NAME order to FNP X timed out.
     2003*
     2004*   S:	$info
     2005*
     2006*   T:	$run
     2007*
     2008*   M:	NAME is "get_meters", "dump_fnp", or "patch_fnp". The named order to
     2009*   FNP X failed to complete within 10 seconds. The buffer space associated
     2010*   with the order has been abandoned, and get_meters, dump, and patch orders
     2011*   to that FNP are disabled until the FNP is reloaded.
     2012*
     2013*   A:	$inform
     2014*
     2015*
     2016*   Message:
     2017*   fnp_multiplexer: get_meters order for FNP X, line N, timed out.
     2018*
     2019*   S:     $info
     2020*
     2021*   T:     $run
     2022*
     2023*   M:     A get_meters order for line N of FNP X failed to complete within 10
     2024*   seconds. The buffer space associated with the order has been abandoned, and
     2025*   get_meters, dump, and patch orders to that FNP are disabled until the FNP
     2026*   is reloaded.
     2027*
     2028*
     2029*   Message:
     2030*   fnp_multiplexer$shutdown: Failed to unwire fnp. ERROR.
     2031*
     2032*   S:	$info
     2033*
     2034*   T:	$run
     2035*
     2036*   M:	An attempt to unwire the pages used for I/O to an FNP failed at FNP
     2037*   shutdown. ERROR contains the message derived from a standard system error
     2038*   code.
     2039*
     2040*   A:	$inform
     2041*
     2042*
     2043*   Message:
     2044*   fnp_multiplexer$shutdown: Called with null fnp_ptr
     2045*
     2046*   S:	$info
     2047*
     2048*   T:	$run
     2049*
     2050*   M:	A call was made to the shutdown entry with a null pointer to
     2051*   fnp_info. This message only appears if tracing is enabled for the specified
     2052*   FNP. 
     2053*
     2054*   A:	$inform
     2055*
     2056*
     2057*   Message:
     2058*   fnp_multiplexer$shutdown: Called with FNP wired.
     2059*
     2060*   S:	$info
     2061*
     2062*   T:	$run
     2063*
     2064*   M:	A call was made to the shutdown entry while the pages for I/O for an
     2065*   FNP were still wired.
     2066*   This message only appears if tracing is enabled for the specified FNP.
     2067*
     2068*   A:	none required.
     2069*
     2070*
     2071*   Message:
     2072*   fnp_multiplexer$assign_channel: Assignment of FNP X {succeeded | failed}.
     2073*
     2074*   S:	$info
     2075*
     2076*   T:	$run
     2077*
     2078*   M:	Indicates the result of a call to io_manager$assign for FNP X.
     2079*   This message only appears if tracing is enabled for the specified FNP.
     2080*
     2081*   A:	none required.
     2082*
     2083*
     2084*   Message:
     2085*   fnp_multiplexer$unassign_channel: Unassignment of FNP X {succeeded | failed}.
     2086*
     2087*   S:	$info
     2088*
     2089*   T:	$run
     2090*
     2091*   M:	Indicates the result of a call to io_manager$unassign for FNP X.
     2092*   This message only appears if tracing is enabled for the specified FNP.
     2093*
     2094*   A:	none required.
     2095*
     2096*
     2097*   Message:
     2098*   fnp_multiplexer$ENTRY: Tracing call.
     2099*
     2100*   S:	$info
     2101*
     2102*   T:	$run
     2103*
     2104*   M:	A call was made to the ENTRY entry.
     2105*   This message only appears if tracing is enabled for the specified FNP.
     2106*
     2107*   A:	none required.
     2108*
     2109*
     2110*   Message:
     2111*   fnp_multiplexer$ENTRY: Tracing error. ERROR.
     2112*
     2113*   S:	$info
     2114*
     2115*   T:	$run
     2116*
     2117*   M:	The error code represented by ERROR was encountered by ENTRY.
     2118*   This message only appears if tracing is enabled for the specified FNP.
     2119*
     2120*   A:	none required.
     2121*
     2122*
     2123*   Message:
     2124*   fnp_multiplexer: debugging stop (type go to continue).
     2125*
     2126*   S:	$crash
     2127*
     2128*   T:	$run
     2129*
     2130*   M:	An error has been encountered in setting up an FNP, and debugging
     2131*   mode is turned on.
     2132*
     2133*   A:	Use BCE commands to analyze the condition, if necessary; type "go"
     2134*   to resume system operation.
     2135*
     2136*   END MESSAGE DOCUMENTATION */
     2137 
     2138 
     2139 
     2140      end fnp_multiplexer;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1945.6  fnp_multiplexer.pl1               >udd>sm>ds>w>ml>fnp_multiplexer.pl1
322          1    01/06/85  1522.1  tty_buf.incl.pl1                  >ldd>incl>tty_buf.incl.pl1
1-152        2    01/06/85  1522.1  hc_fast_lock.incl.pl1             >ldd>incl>hc_fast_lock.incl.pl1
324          3    07/21/88  2136.0  tty_buffer_block.incl.pl1         >ldd>incl>tty_buffer_block.incl.pl1
326          4    11/08/82  1105.8  lct.incl.pl1                      >ldd>incl>lct.incl.pl1
328          5    10/26/89  2111.9  dn355_data.incl.pl1               >ldd>incl>dn355_data.incl.pl1
330          6    07/21/88  2136.0  pcb.incl.pl1                      >ldd>incl>pcb.incl.pl1
332          7    10/20/82  1038.6  mailbox_ops.incl.pl1              >ldd>incl>mailbox_ops.incl.pl1
334          8    06/18/81  1000.8  tty_space_man_dcls.incl.pl1       >ldd>incl>tty_space_man_dcls.incl.pl1
336          9    08/06/87  1013.4  line_types.incl.pl1               >ldd>incl>line_types.incl.pl1
338         10    02/23/79  1534.9  mux_init_info.incl.pl1            >ldd>incl>mux_init_info.incl.pl1
340         11    07/11/84  1037.3  io_chnl_util_dcls.incl.pl1        >ldd>incl>io_chnl_util_dcls.incl.pl1
341         12    03/19/81  1231.8  mcs_modes_change_list.incl.pl1    >ldd>incl>mcs_modes_change_list.incl.pl1
342         13    11/05/79  1528.9  flow_control_info.incl.pl1        >ldd>incl>flow_control_info.incl.pl1
343         14    05/06/80  1058.2  channel_manager_dcls.incl.pl1     >ldd>incl>channel_manager_dcls.incl.pl1
344         15    10/20/82  1038.6  mcs_interrupt_info.incl.pl1       >ldd>incl>mcs_interrupt_info.incl.pl1
345         16    03/29/82  1106.8  fnp_meters.incl.pl1               >ldd>incl>fnp_meters.incl.pl1
346         17    08/10/81  1943.6  fnp_channel_meters.incl.pl1       >ldd>incl>fnp_channel_meters.incl.pl1
347         18    06/18/81  1000.6  get_comm_meters_info.incl.pl1     >ldd>incl>get_comm_meters_info.incl.pl1
348         19    07/11/84  1037.3  io_manager_dcls.incl.pl1          >ldd>incl>io_manager_dcls.incl.pl1
349         20    07/10/86  2115.0  mcs_echo_neg_sys.incl.pl1         >ldd>incl>mcs_echo_neg_sys.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000152 constant        fixed bin(17,0)          initial dcl 270 set ref 607* 616* 619* 1331* 1336*
                                                                                  1645* 1727* 1913* 1935* 1950* 1961*
BLK_XFER_INDEX                         constant        fixed bin(17,0)          initial dcl 297 ref 1569
Block_xfer                             constant        fixed bin(8,0)           initial dcl 7-89 ref 1570
Break                                  constant        fixed bin(8,0)           initial dcl 7-89 ref 730
CRASH_SYSTEM                    000167 constant        fixed bin(17,0)          initial dcl 271 set ref 1807* 1963*
Code                                   parameter       fixed bin(35,0)          dcl 1959 set ref 1956 1961*
DCW_LIST_SIZE                          constant        fixed bin(17,0)          initial dcl 273 ref 415 537
DIALUP                          000167 constant        fixed bin(17,0)          initial dcl 15-10 set ref 920*
DUMP_PATCH_LIMIT                000110 constant        fixed bin(35,0)          initial dcl 274 ref 1639 1723
Dumpinput                              constant        fixed bin(8,0)           initial dcl 7-89 ref 1019 1019
Dumpoutput                             constant        fixed bin(8,0)           initial dcl 7-89 ref 1031 1031
Entry                                  parameter       char(32)                 packed unaligned dcl 1948 set ref 1945 1950* 1956
                                                                                  1961*
FNP_CHANNEL_METERS_VERSION_1           constant        fixed bin(17,0)          initial dcl 17-8 ref 889
FNP_DUMP_PATCH_EVENT            000156 constant        fixed bin(17,0)          initial dcl 1-31 set ref 1621* 1650* 1653*
FNP_METERS_VERSION_2                   constant        fixed bin(17,0)          initial dcl 16-57 ref 1240
FNP_METER_EVENT                 000014 constant        fixed bin(17,0)          initial dcl 1-32 set ref 1691* 1738* 1742*
Hndlquit                               constant        fixed bin(8,0)           initial dcl 7-89 ref 1557
IFLOW_INDEX                            constant        fixed bin(17,0)          initial dcl 296 ref 1573
INPUT                           000152 constant        bit(1)                   initial packed unaligned dcl 8-20 set ref 526*
Input_flow_control                     constant        fixed bin(8,0)           initial dcl 7-89 ref 1574
LINE_ASCII                             constant        fixed bin(17,0)          initial dcl 9-22 ref 918 1122
LINE_ASYNC1                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1122
LINE_ASYNC2                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1122
LINE_ASYNC3                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1122
Listen                                 constant        fixed bin(8,0)           initial dcl 7-89 ref 806 958
OUTPUT                          000151 constant        bit(1)                   initial packed unaligned dcl 8-21 set ref 524* 1026*
SEND_OUTPUT                     000163 constant        fixed bin(17,0)          initial dcl 15-13 set ref 1036*
Set_buffer_size                        constant        fixed bin(8,0)           initial dcl 7-89 ref 991
WIRED_ECHO_BREAK_SIZE                  constant        fixed bin(17,0)          initial dcl 20-16 ref 832
Wru                                    constant        fixed bin(8,0)           initial dcl 7-89 ref 724
Xmit_hold                              constant        fixed bin(8,0)           initial dcl 7-89 ref 736
a_chainp                               parameter       pointer                  dcl 67 set ref 638 643*
a_code                                 parameter       fixed bin(35,0)          dcl 69 set ref 351 375* 419* 484* 500* 503 552* 555
                                                                                  573* 577 594* 598 633* 638 645* 649 659* 692* 695
                                                                                  711* 891* 903* 910* 922* 927* 936* 951* 1005*
                                                                                  1070* 1074 1084* 1091* 1141* 1144 1154* 1161*
                                                                                  1186* 1191 1197* 1200 1214* 1247* 1305* 1308 1324*
                                                                                  1353* 1367* 1391* 1395 1400* 1868 1876* 1880 1889*
a_data_ptr                             parameter       pointer                  dcl 72 ref 695 701 1200 1207 1308 1315
a_devx                                 parameter       fixed bin(17,0)          dcl 63 ref 351 360
a_fnp_no                               parameter       fixed bin(17,0)          dcl 1865 ref 1868 1873 1880 1883
a_fnpp                                 parameter       pointer                  dcl 65 set ref 351 483* 503 508 555 560 577 582 598
                                                                                  604 638 649 652 695 698 1074 1079 1144 1149 1191
                                                                                  1200 1205 1308 1313 1395 1398 1403 1406
a_init_info_ptr                        parameter       pointer                  dcl 64 ref 351 361
a_mi_flag                              parameter       bit(1)                   dcl 68 set ref 638 644*
a_mode_list_ptr                        parameter       pointer                  dcl 73 ref 1074 1081 1144 1151
a_modes                                parameter       char                     packed unaligned dcl 74 set ref 1191 1196*
a_order                                parameter       char                     packed unaligned dcl 71 ref 695 700 1200 1206 1308
                                                                                  1314
a_output_ptr                           parameter       pointer                  dcl 70 set ref 649 654 690*
a_subchan                              parameter       fixed bin(17,0)          dcl 66 ref 638 649 653 695 699 1074 1080 1144 1150
                                                                                  1191
abs_addr                        000256 automatic       fixed bin(24,0)          level 2 dcl 153 set ref 1511*
absorig                   1            based           fixed bin(24,0)          level 2 dcl 1-35 ref 567 567 1010 1511 1690
accept_calls                    000163 constant        fixed bin(8,0)           initial dcl 7-24 set ref 567*
accept_direct_output            000136 constant        fixed bin(8,0)           initial dcl 7-24 set ref 684*
action                    3            based           fixed bin(17,0)          level 2 in structure "fnp_break_info" dcl 196
                                                                                  in procedure "fnp_multiplexer" ref 1356
action                    1     000260 automatic       fixed bin(17,0)          level 2 in structure "fnp_break_data" packed packed
                                                                                  unaligned dcl 158 in procedure "fnp_multiplexer"
                                                                                  set ref 1356*
addr                                                   builtin function         dcl 208 ref 364 365 380 388 388 390 437 441 481 481
                                                                                  490 490 494 509 510 523 561 567 567 583 603 612
                                                                                  718 742 749 756 763 816 822 840 846 852 856 860
                                                                                  868 871 965 981 992 993 1010 1096 1169 1243 1373
                                                                                  1373 1378 1419 1420 1426 1461 1462 1493 1608 1609
                                                                                  1622 1622 1627 1690 1703 1709 1772 1871 1874 1884
                                                                                  1886
addrel                                                 builtin function         dcl 208 ref 426
alter_data                      000152 automatic       varying bit(144)         dcl 106 set ref 725* 731* 737* 807* 960* 960 964 965
                                                                                  991* 992 1553* 1588* 1588 1608 1609
alter_parameters                000012 constant        fixed bin(8,0)           initial dcl 7-24 set ref 966 993* 1019* 1031* 1609*
alter_type                      000137 automatic       fixed bin(8,0)           dcl 101 set ref 705* 724* 730* 736* 806* 956 958 965
                                                                                  1557* 1570* 1574* 1600* 1608
area                            000272 stack reference condition                dcl 211 ref 471
async_only_modes                000050 constant        char(8)                  initial array packed unaligned dcl 291 set ref 1107
                                                                                  1107 1110 1179 1180* 1593
available                66            based           bit(1)                   level 3 packed packed unaligned dcl 5-67 ref 1898
base_len                        000215 automatic       fixed bin(17,0)          dcl 127 set ref 1580* 1584* 1588
based_bit108                           based           bit(108)                 packed unaligned dcl 176 ref 763
based_bit18                            based           bit(18)                  packed unaligned dcl 174 ref 756
based_bit2                             based           bit(2)                   packed unaligned dcl 173 ref 769 771
based_bit72                            based           bit(72)                  packed unaligned dcl 175 ref 749 1373 1622
based_echo_table_bits                  based           bit                      packed unaligned dcl 177 ref 832
based_fb_word                          based           fixed bin(17,0)          dcl 171 ref 742 777
baud_rate                 2            based           fixed bin(17,0)          level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  1579 1849
baud_rate                 0(18) 000332 automatic       fixed bin(18,0)          level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 15-30 in procedure
                                                                                  "fnp_multiplexer" set ref 917*
bin                                                    builtin function         dcl 208 ref 464 465 567 567 567 567 676 679 681 742
                                                                                  965 981 991 1009 1010 1019 1019 1031 1031 1370
                                                                                  1511 1588 1588 1608 1690 1690 1773 1775 1857
bit                                                    builtin function         dcl 208 ref 464 465 567 567 742 795 822 822 965 981
                                                                                  991 1010 1019 1019 1031 1031 1588 1588 1608 1690
                                                                                  1773 1775 1857
bits                            000262 automatic       bit(16)                  array level 3 packed packed unaligned dcl 164 set
                                                                                  ref 832*
block_acknowledge         0(01)        based           bit(1)                   level 3 packed packed unaligned dcl 13-19 ref 871
block_len                       000216 automatic       fixed bin(17,0)          dcl 128 set ref 1580* 1585* 1588
blockp                          000302 automatic       pointer                  dcl 3-19 set ref 665* 666 668 669* 669 670 681
bootloading              30(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 517
                                                                                  614
buf_per_second                         constant        fixed bin(17,0)          initial dcl 1-29 ref 1580 1849
buffer                                 based           structure                level 1 dcl 3-28
bufp                      2            based           pointer                  level 2 dcl 190 ref 1226 1328 1336
chan                            000405 automatic       fixed bin(7,0)           dcl 1272 set ref 1273* 1275
chan_name                              based           char(6)                  level 2 dcl 196 ref 1360
channel_desc                           based           structure                level 2 packed packed unaligned dcl 6-27
channel_manager$interrupt       000144 constant        entry                    external dcl 14-25 ref 920 1036
channels                  1            based           structure                array level 2 dcl 10-10
chanx                           000110 automatic       fixed bin(17,0)          dcl 86 set ref 563* 585* 653* 699* 1080* 1150* 1426
chars                     2(09)        based           char(3)                  level 3 in structure "output_flow_control_info"
                                                                                  packed packed unaligned dcl 13-19 in procedure
                                                                                  "fnp_multiplexer" ref 871
chars                     1(09)        based           char(3)                  level 3 in structure "input_flow_control_info"
                                                                                  packed packed unaligned dcl 13-9 in procedure
                                                                                  "fnp_multiplexer" ref 856
chars                     0(09)        based           char(3)                  level 3 in structure "input_flow_control_info"
                                                                                  packed packed unaligned dcl 13-9 in procedure
                                                                                  "fnp_multiplexer" ref 856
chars                     1(09)        based           char(3)                  level 3 in structure "output_flow_control_info"
                                                                                  packed packed unaligned dcl 13-19 in procedure
                                                                                  "fnp_multiplexer" ref 871
chars_per_buf                   000217 automatic       fixed bin(17,0)          dcl 129 set ref 1849* 1854* 1857
chars_per_sec                   000220 automatic       fixed bin(17,0)          dcl 130 set ref 1579* 1580
check                           000140 automatic       bit(1)                   packed unaligned dcl 102 set ref 706* 780* 801* 881*
                                                                                  971
clock                                                  builtin function         dcl 208 ref 1509 1639 1692 1723
code                                   parameter       fixed bin(35,0)          dcl 1924 in procedure "unassign_channel" set ref
                                                                                  1922 1929* 1932* 1933 1935* 1935 1940 1940*
code                                   parameter       fixed bin(35,0)          dcl 1895 in procedure "assign_channel" set ref 1893
                                                                                  1897* 1900* 1906* 1910* 1912 1913 1917 1917*
code                            000100 automatic       fixed bin(35,0)          dcl 79 in procedure "fnp_multiplexer" set ref 394*
                                                                                  398* 399 402* 403 447* 473* 488* 500 514 517* 540*
                                                                                  543* 549 549* 552 565 571 571* 573 587 592 592*
                                                                                  594 618* 619 619* 657 659 687* 690 692 901 903
                                                                                  932* 934 936 1049 1053* 1070 1089 1091 1131* 1141
                                                                                  1159 1161 1186 1212 1214 1220 1228 1240* 1245 1247
                                                                                  1253 1303* 1305 1317* 1322 1324 1342 1351 1353
                                                                                  1365 1367 1376 1389* 1391 1400 1418* 1423 1430*
                                                                                  1452* 1456* 1468* 1478* 1489* 1496* 1504* 1596*
                                                                                  1606 1624 1635* 1642* 1674* 1686* 1698* 1719*
                                                                                  1725* 1755* 1758 1783* 1797* 1801* 1810* 1811
                                                                                  1875* 1876 1888* 1889
config_flags             66            based           structure                level 2 dcl 5-67
configuration_lock                     based           structure                level 2 dcl 5-52 set ref 388 388 481 481 490 490
copied_meters_offset      7            based           fixed bin(18,0)          level 2 unsigned dcl 6-27 set ref 529 531 531 532*
                                                                                  1009* 1010 1526 1528 1539*
copied_meters_ptr               000432 automatic       pointer                  dcl 1524 set ref 1528* 1532 1534 1536 1537*
copied_meters_ready       4(09)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1434 1540*
count                     1            based           fixed bin(9,0)           level 3 in structure "output_flow_control_info"
                                                                                  packed packed unsigned unaligned dcl 13-19
                                                                                  in procedure "fnp_multiplexer" ref 868
count                                  based           fixed bin(9,0)           level 3 in structure "input_flow_control_info"
                                                                                  packed packed unsigned unaligned dcl 13-9
                                                                                  in procedure "fnp_multiplexer" ref 860
count                     1            based           fixed bin(9,0)           level 3 in structure "input_flow_control_info"
                                                                                  packed packed unsigned unaligned dcl 13-9
                                                                                  in procedure "fnp_multiplexer" ref 852
ctr                                    based           fixed bin(35,0)          level 2 dcl 202 ref 822
cumulative_mbx_in_use
                         55            based           fixed bin(35,0)          level 2 dcl 5-67 ref 1256
current_meters                         based           structure                level 2 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "fnp_multiplexer" set ref 1295*
current_meters            2            based           structure                level 2 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer" set ref
                                                                                  1056*
data_ptr                        000130 automatic       pointer                  dcl 93 set ref 701* 710 742 749 756 763 769 771 777
                                                                                  787 788 822 822 832 852 856 856 856 860 868 871
                                                                                  871 871 886 1068 1207* 1225 1226 1237 1284 1291
                                                                                  1315* 1328 1336 1336 1356 1358 1359 1360 1472 1473
datanet_info                           based           structure                level 1 dcl 5-52
dcw_list_array_ptr        4            based           pointer                  level 2 dcl 5-67 set ref 426*
debug_stop                6            based           bit(1)                   level 2 dcl 5-52 ref 1913 1935 1961 1963
devx                            000101 automatic       fixed bin(17,0)          dcl 80 in procedure "fnp_multiplexer" set ref 360*
                                                                                  369 371 390
devx                                   based           fixed bin(17,0)          level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  440* 441 524 526 920 1026 1036
devx                     11            based           fixed bin(17,0)          array level 3 in structure "mux_init_info" dcl 10-10
                                                                                  in procedure "fnp_multiplexer" ref 440
dial                                   constant        fixed bin(8,0)           initial dcl 7-24 ref 800 988
dialed                    4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref 907
                                                                                  914*
dialup_info                     000332 automatic       structure                level 1 dcl 15-30 set ref 916* 920 920
digit_pos                       000205 automatic       fixed bin(17,0)          dcl 119 set ref 786* 794* 794 795 799
disconnect_this_line                   constant        fixed bin(8,0)           initial dcl 7-24 ref 719 940
divide                                                 builtin function         dcl 208 ref 1500 1579 1580 1849 1849
dn355$hangup_fnp_lines          000014 constant        entry                    external dcl 219 ref 627
dn355$interrupt                 000020 constant        entry                    external dcl 221 ref 1910 1910
dn355$process_interrupt_queue   000016 constant        entry                    external dcl 220 ref 1827
dn355$send_global_wcd           000012 constant        entry                    external dcl 218 ref 567 589 1378 1627 1703
dn355$send_wcd                  000010 constant        entry                    external dcl 217 ref 684 993 1015 1019 1031 1609
                                                                                  1709
dn355_data$                     000132 external static fixed bin(17,0)          dcl 5-47 set ref 364 510 561 583 603 612 1420 1462
                                                                                  1871 1884
dno                             000103 automatic       fixed bin(17,0)          dcl 82 set ref 372* 373 380 385 445
dont_accept_calls               000165 constant        fixed bin(8,0)           initial dcl 7-24 set ref 589*
dump_fnp_data                   000256 automatic       structure                level 1 dcl 153 set ref 1622
dump_fnp_info                          based           structure                level 1 dcl 190
dump_mem                               constant        fixed bin(8,0)           initial dcl 7-24 set ref 1219* 1645
dump_patch_disabled      30(07)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref
                                                                                  1466 1643* 1672 1726*
dump_patch_in_progress
                         30(04)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref
                                                                                  1510* 1632 1636* 1644* 1651
dump_patch_lock          44            based           bit(36)                  level 2 dcl 5-67 set ref 1232 1345 1493 1505
dump_patch_space                000252 automatic       fixed bin(17,0)          dcl 149 set ref 1228* 1342* 1500* 1501*
dump_patch_time                 000254 automatic       fixed bin(71,0)          dcl 150 set ref 1509* 1639
dumpin                          000157 automatic       bit(1)                   packed unaligned dcl 107 set ref 703* 769* 1019
dumpout                         000160 automatic       bit(1)                   packed unaligned dcl 108 set ref 703* 771* 1022
echnego_break_table             000262 automatic       structure                level 1 dcl 164 set ref 829 830* 834
echo_start_data                        based           structure                level 1 dcl 202
end_frame                 4(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1033 1035*
enter_receive                          constant        fixed bin(8,0)           initial dcl 7-24 ref 817
entries                   6            based           structure                array level 2 dcl 12-10 set ref 1096 1169
error                     4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1132*
error_table_$bad_channel        000066 external static fixed bin(35,0)          dcl 240 ref 375 447 1783
error_table_$bad_mode           000064 external static fixed bin(35,0)          dcl 240 ref 1131 1596
error_table_$buffer_big         000070 external static fixed bin(35,0)          dcl 240 ref 1478
error_table_$dev_offset_out_of_bounds
                                000074 external static fixed bin(35,0)          dcl 240 ref 1489
error_table_$invalid_state      000122 external static fixed bin(35,0)          dcl 240 ref 517
error_table_$invalid_write      000072 external static fixed bin(35,0)          dcl 240 ref 951
error_table_$io_assigned        000112 external static fixed bin(35,0)          dcl 240 ref 1906
error_table_$io_not_assigned    000114 external static fixed bin(35,0)          dcl 240 ref 1929
error_table_$io_not_available   000120 external static fixed bin(35,0)          dcl 240 ref 394
error_table_$io_not_configured  000116 external static fixed bin(35,0)          dcl 240 ref 1900
error_table_$mpx_down           000100 external static fixed bin(35,0)          dcl 240 ref 1430 1456 1635 1719 1797
error_table_$no_channel_meters  000106 external static fixed bin(35,0)          dcl 240 ref 1053
error_table_$noalloc            000060 external static fixed bin(35,0)          dcl 240 ref 419 473 1005 1504 1686
error_table_$resource_not_free  000110 external static fixed bin(35,0)          dcl 240 ref 910
error_table_$seglock            000076 external static fixed bin(35,0)          dcl 240 ref 1496 1698
error_table_$timeout            000102 external static fixed bin(35,0)          dcl 240 ref 1228 1342 1468 1642 1674 1725
error_table_$undefined_order_request
                                000062 external static fixed bin(35,0)          dcl 240 ref 927 1303 1389
error_table_$unimplemented_version
                                000104 external static fixed bin(35,0)          dcl 240 ref 891 1084 1154 1240
flags                     5            based           structure                level 2 in structure "mcl" dcl 12-10 in procedure
                                                                                  "fnp_multiplexer"
flags                     4            based           structure                level 2 in structure "mcle" dcl 12-26 in procedure
                                                                                  "fnp_multiplexer"
flags                     4            based           bit(36)                  level 2 in structure "fnp_break_info" dcl 196
                                                                                  in procedure "fnp_multiplexer" ref 1359
flags                     1(18) 000260 automatic       bit(18)                  level 2 in structure "fnp_break_data" packed packed
                                                                                  unaligned dcl 158 in procedure "fnp_multiplexer"
                                                                                  set ref 1359*
flags                    30            based           structure                level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" set ref 427* 536*
flags                     2(09)        based           structure                level 2 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "fnp_multiplexer"
flags                     4            based           structure                level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer"
flags                                  based           structure                level 2 in structure "output_flow_control_info"
                                                                                  packed packed unaligned dcl 13-19 in procedure
                                                                                  "fnp_multiplexer"
flags                     1            based           structure                level 2 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer"
fnp_addr                  2            based           fixed bin(17,0)          level 2 in structure "fnp_break_info" dcl 196
                                                                                  in procedure "fnp_multiplexer" ref 1358
fnp_addr                  0(18) 000260 automatic       fixed bin(18,0)          level 2 in structure "fnp_break_data" packed packed
                                                                                  unsigned unaligned dcl 158 in procedure
                                                                                  "fnp_multiplexer" set ref 1358*
fnp_addr                  1     000256 automatic       fixed bin(18,0)          level 2 in structure "dump_fnp_data" packed packed
                                                                                  unsigned unaligned dcl 153 in procedure
                                                                                  "fnp_multiplexer" set ref 1334 1513*
fnp_address                     000422 automatic       fixed bin(18,0)          dcl 1446 in procedure "setup_fnp" set ref 1472* 1487
                                                                                  1487 1513
fnp_address                            based           fixed bin(24,0)          level 2 in structure "dump_fnp_info" dcl 190
                                                                                  in procedure "fnp_multiplexer" ref 1472
fnp_async_meters                       based           structure                level 1 dcl 17-46
fnp_break                       000013 constant        fixed bin(8,0)           initial dcl 7-24 set ref 1378*
fnp_break_data                  000260 automatic       structure                level 1 dcl 158 set ref 1373
fnp_break_info                         based           structure                level 1 dcl 196
fnp_chan_meter_struc                   based           structure                level 1 dcl 17-10
fnp_channel_locked       50            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1263
fnp_channel_locked       35            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1263*
fnp_channel_meters                     based           structure                level 1 dcl 17-18 set ref 477 477 495 495 528 528
                                                                                  531 531 1000 1000 1053 1056 1058 1062 1062 1536*
                                                                                  1536 1537 1537 1681
fnp_config_flags          5            based           bit(1)                   array level 2 packed packed unaligned dcl 1-35 ref
                                                                                  385
fnp_data                               based           bit(18)                  array packed unaligned dcl 178 set ref 1226* 1226
                                                                                  1330* 1330 1336* 1336*
fnp_dump_ptr                    000250 automatic       pointer                  dcl 148 set ref 1226 1228* 1330 1342* 1501* 1502
                                                                                  1511
fnp_global_meters                      based           structure                level 1 dcl 16-13 ref 1284 1287 1287 1679
fnp_id                    7            based           structure                level 2 dcl 5-67
fnp_info                               based           structure                level 1 dcl 5-67
fnp_len                   1(18) 000256 automatic       fixed bin(18,0)          level 2 in structure "dump_fnp_data" packed packed
                                                                                  unsigned unaligned dcl 153 in procedure
                                                                                  "fnp_multiplexer" set ref 1327 1335 1514*
fnp_len                         000423 automatic       fixed bin(18,0)          dcl 1446 in procedure "setup_fnp" set ref 1473* 1476
                                                                                  1476 1483 1483 1487 1500 1514
fnp_len                   1            based           fixed bin(17,0)          level 2 in structure "dump_fnp_info" dcl 190
                                                                                  in procedure "fnp_multiplexer" ref 1225 1473
fnp_mem_size             43            based           fixed bin(17,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1269*
fnp_mem_size             42            based           fixed bin(18,0)          level 2 in structure "fnp_info" unsigned dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1269 1487
fnp_meter_wait_start            000464 automatic       fixed bin(71,0)          dcl 1670 set ref 1692* 1723
fnp_meterp                      000334 automatic       pointer                  dcl 16-11 set ref 1237* 1238 1240 1255 1256 1257
                                                                                  1258 1259 1260 1261 1262 1263 1264 1265 1266 1267
                                                                                  1268 1269 1274 1275
fnp_meters                             based           structure                level 1 dcl 16-35
fnp_meters_ptr                  000170 automatic       pointer                  dcl 113 set ref 1051 1053 1056 1062* 1282 1284 1287*
                                                                                  1675* 1683* 1684 1690
fnp_no                          000336 automatic       fixed bin(17,0)          dcl 1866 set ref 1873* 1874 1883* 1886
fnp_number                7(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 5-67
                                                                                  ref 402 545 618 627 1761 1827 1910
fnp_space_restricted_output
                         63            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1268
fnp_space_restricted_output
                         42            based           fixed bin(17,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1268*
fnp_sync_meters                        based           structure                level 1 dcl 17-35
fnp_tag                   7            based           char(1)                  level 3 packed packed unaligned dcl 5-67 set ref 383
                                                                                  1331* 1645* 1727* 1913* 1935*
fnp_util$fill_page_table        000022 constant        entry                    external dcl 222 ref 402
fnp_util$free_page_table        000024 constant        entry                    external dcl 223 ref 545
fnp_util$unwire                 000026 constant        entry                    external dcl 224 ref 618
fnpp                            000314 automatic       pointer                  dcl 5-50 set ref 380* 383 390 392 402 407 408 411
                                                                                  422 425 426 427 450 455 457 483 508* 517 517 517
                                                                                  522 523 536 537 537 539 543 545 560* 567* 582*
                                                                                  589* 604* 605 614 614 618 624 627 628 652* 684*
                                                                                  698* 993* 1015* 1019* 1031* 1079* 1149* 1205* 1232
                                                                                  1255 1256 1257 1258 1259 1260 1261 1262 1263 1264
                                                                                  1265 1266 1267 1268 1269 1273 1290 1313* 1331 1345
                                                                                  1378* 1398* 1406* 1426 1426 1450 1453 1453 1466
                                                                                  1487 1493 1505 1510 1609* 1627* 1632 1633 1636
                                                                                  1643 1644 1645 1651 1672 1696 1702 1703* 1704
                                                                                  1709* 1716 1717 1726 1727 1730 1739 1761 1764 1766
                                                                                  1771 1772 1795 1803 1827 1874* 1886* 1898 1904
                                                                                  1910 1910 1910 1912 1913 1927 1932 1933 1935
force                     4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 ref 1127
found                           000233 automatic       bit(1)                   packed unaligned dcl 142 set ref 1770* 1771 1775*
                                                                                  1779
free_space              150            based           fixed bin(17,0)          level 2 dcl 1-35 set ref 567 567
from_fnp                  2            based           structure                level 2 dcl 16-35 set ref 1284*
full_dpx_modes                  000032 constant        char(8)                  initial array packed unaligned dcl 299 ref 1115 1115
                                                                                  1122
get_comm_meters_info                   based           structure                level 1 dcl 18-8
get_meters                      000161 automatic       bit(1)                   packed unaligned dcl 109 set ref 703* 895* 1044
get_meters_waiting        4(10)        based           bit(1)                   level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  1708* 1716 1733* 1739
get_meters_waiting       30(13)        based           bit(1)                   level 3 in structure "fnp_info" packed packed
                                                                                  unaligned dcl 5-67 in procedure "fnp_multiplexer"
                                                                                  set ref 1696 1702* 1716 1730* 1739
global                                 parameter       bit(1)                   packed unaligned dcl 1668 set ref 1663 1679 1694
                                                                                  1716 1716 1727* 1730 1739 1739
good_modes                      000106 constant        char(8)                  initial array packed unaligned dcl 288 ref 1100 1100
                                                                                  1103
hbound                                                 builtin function         dcl 208 ref 831 1100 1103 1107 1110 1115 1122 1179
                                                                                  1593 1596
hc_fast_lock                           based           structure                level 1 dcl 2-10
header                   34            based           structure                level 3 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer"
header                    2            based           structure                level 3 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer"
header                                 based           structure                level 2 in structure "fnp_channel_meters" dcl 17-18
                                                                                  in procedure "fnp_multiplexer"
his_fnp_no                      000231 automatic       fixed bin(17,0)          dcl 140 set ref 444* 445 1756* 1761
hndlquit                  4(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1558*
hndlquit_set                    000214 automatic       bit(1)                   packed unaligned dcl 126 set ref 1165* 1176 1559*
hsla_flag                       000221 automatic       bit(1)                   packed unaligned dcl 134 set ref 444* 452 455 459
                                                                                  463 465 1756* 1764
hsla_idx                 21            based           fixed bin(17,0)          array level 2 dcl 5-67 set ref 407* 455* 1764
i                               000114 automatic       fixed bin(17,0)          dcl 89 set ref 406* 407 408* 410* 411* 522* 523*
                                                                                  787* 788* 831* 832 832* 982* 982* 985 1100* 1100*
                                                                                  1103 1107* 1107* 1110 1115* 1115* 1122 1335* 1336
                                                                                  1336* 1593* 1593* 1596 1600 1601 1843* 1843* 1846
ignore                          000236 automatic       bit(1)                   packed unaligned dcl 145 set ref 1232* 1345* 1505*
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "fnp_multiplexer"
in                       26            based           structure                level 3 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "fnp_multiplexer"
in                        2            based           structure                level 3 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "fnp_multiplexer"
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "fnp_multiplexer"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "fnp_multiplexer"
infop                           000312 automatic       pointer                  dcl 5-49 set ref 364* 380 388 388 481 481 490 490
                                                                                  510* 561* 583* 603* 607 612* 616 1420* 1462* 1871*
                                                                                  1874 1884* 1886 1913 1913 1935 1935 1950 1961 1961
                                                                                  1963
init                      5            based           bit(1)                   level 3 packed packed unaligned dcl 12-10 ref 1174
init_echo_negotiation                  constant        fixed bin(8,0)           initial dcl 7-24 ref 841
input                    11            based           structure                level 2 dcl 17-35
input_available           2            based           bit(1)                   level 2 dcl 186 set ref 710*
input_control_transactions
                         40            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1266*
input_control_transactions
                         53            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1266
input_data_transactions
                         36            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1264*
input_data_transactions
                         51            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1264
input_fc_chars                         constant        fixed bin(8,0)           initial dcl 7-24 ref 863
input_flow_control_info                based           structure                level 1 dcl 13-9
input_reject_count       46            based           fixed bin(17,0)          level 2 dcl 5-67 ref 1261
input_rejects            33            based           fixed bin(17,0)          level 2 dcl 16-35 set ref 1261*
io_chanid                10            based           char(8)                  level 2 dcl 5-67 set ref 1273* 1910*
io_chnl_util$name_to_iom        000142 constant        entry                    external dcl 11-16 ref 1273
io_manager$assign               000146 constant        entry                    external dcl 19-10 ref 1910
io_manager$unassign             000150 constant        entry                    external dcl 19-20 ref 1932
io_manager_arg                         based           structure                level 1 dcl 19-50
io_manager_assigned      66(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 543
                                                                                  1904 1912* 1927 1933*
io_manager_chx           12            based           fixed bin(35,0)          level 2 dcl 5-67 set ref 1910* 1932*
iom                             000404 automatic       fixed bin(3,0)           dcl 1271 set ref 1273* 1274
iom_chan_no              45            based           fixed bin(17,0)          level 2 dcl 16-35 set ref 1275*
iom_number               44            based           fixed bin(17,0)          level 2 dcl 16-35 set ref 1274*
is_hsla                   0(26)        based           bit(1)                   level 4 packed packed unaligned dcl 6-27 set ref
                                                                                  463* 1118
j                               000115 automatic       fixed bin(17,0)          dcl 89 set ref 1771* 1772*
la_no                           000227 automatic       fixed bin(17,0)          dcl 138 in procedure "fnp_multiplexer" set ref 444*
                                                                                  450 452 455 457 458 464 1756* 1764 1766 1773
la_no                     0(27)        based           bit(3)                   level 4 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  464* 1773
lastp                           000116 automatic       pointer                  dcl 90 set ref 675* 676
lcmp                            000166 automatic       pointer                  dcl 112 set ref 1291* 1293 1295 1296
lcnt                                   based           structure                level 1 dcl 4-65
lcnt_ptr                  2            based           pointer                  level 2 dcl 4-11 ref 368
lcntp                           000310 automatic       pointer                  dcl 4-63 set ref 368* 369 371
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 1-35 ref 366
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 390 441
lcte_ptr                 32            based           pointer                  level 2 dcl 5-67 set ref 390* 1290 1803
lctep                           000306 automatic       pointer                  dcl 4-8 set ref 441* 442 1290* 1295 1434 1803* 1804
                                                                                  1804 1810*
lctp                            000304 automatic       pointer                  dcl 4-7 set ref 366* 368 390 441
length                                                 builtin function         dcl 208 ref 369 787 829 964 1609
line_control                           constant        fixed bin(8,0)           initial dcl 7-24 ref 750
line_number               0(26)        based           structure                level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1370 1727 1727
line_type                 2(18)        based           fixed bin(17,0)          level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  1122 1122 1122 1122 1843
line_type                       000332 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 15-30 in procedure
                                                                                  "fnp_multiplexer" set ref 918*
lineno                          000260 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 158 set ref
                                                                                  1361* 1370*
listen                    4            based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref 907
                                                                                  942* 961* 973
local_line_type                 000174 automatic       fixed bin(17,0)          dcl 115 set ref 777* 778 778 981 982
lock                                   based           bit(36)                  level 2 dcl 4-20 ref 1804
lock$lock_fast                  000036 constant        entry                    external dcl 228 ref 388
lock$unlock_fast                000040 constant        entry                    external dcl 229 ref 481 490
locked                          000133 automatic       bit(1)                   packed unaligned dcl 95 set ref 511* 623* 1218*
                                                                                  1316* 1374 1408* 1421* 1811* 1823 1828*
locked_for_interrupt      2(12)        based           bit(1)                   level 3 packed packed unaligned dcl 4-20 ref 1434
                                                                                  1804
logical_chan_meters                    based           structure                level 1 dcl 18-17
logical_chan_ptr          4            based           pointer                  level 2 dcl 18-8 ref 1291
lsla_idx                 13            based           fixed bin(17,0)          array level 2 dcl 5-67 set ref 408* 411* 457* 1766
major_channel_info        3            based           structure                level 2 dcl 4-20
max_buf_size              1     000332 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 15-30
                                                                                  set ref 919*
max_line_type                          constant        fixed bin(17,0)          initial dcl 9-48 ref 778
max_mbx_in_use           56            based           fixed bin(17,0)          level 2 dcl 5-67 ref 1259
max_no_355s                            internal static fixed bin(17,0)          initial dcl 5-45 ref 5-52
max_output_mbx_in_use
                         31            based           fixed bin(17,0)          level 2 dcl 16-35 set ref 1259*
mbx_data                               based           bit(144)                 packed unaligned dcl 104 set ref 718* 742* 749* 756*
                                                                                  763* 816* 822* 840* 846* 852* 856* 860* 868* 871*
                                                                                  965* 981* 992* 993* 1010* 1373* 1378* 1608* 1609*
                                                                                  1622* 1627* 1690* 1703* 1709*
mbx_data_len                    000141 automatic       fixed bin(17,0)          dcl 103 set ref 717* 748* 755* 762* 776* 815* 821*
                                                                                  829* 839* 845* 851* 867* 964* 990* 993* 995* 1011*
                                                                                  1015*
mbx_data_long                   000142 automatic       bit(288)                 packed unaligned dcl 105 set ref 718 742 749 756 763
                                                                                  816 822 834* 840 846 852 856 860 868 871 965 981
                                                                                  992 993 996* 1010 1015* 1373 1378 1608 1609 1622
                                                                                  1627 1690 1703 1709
mbx_in_use_updated       57            based           fixed bin(35,0)          level 2 dcl 5-67 ref 1257
mbx_pt                                 based           pointer                  level 2 dcl 5-67 ref 1453
mbx_unavailable          60            based           fixed bin(35,0)          level 2 dcl 5-67 ref 1258
mcl                                    based           structure                level 1 dcl 12-10
mcl_version_2                          constant        fixed bin(17,0)          initial dcl 12-8 ref 1082 1152
mcle                                   based           structure                level 1 dcl 12-26
mclep                           000330 automatic       pointer                  dcl 12-24 set ref 1096* 1097 1098 1103 1110 1113
                                                                                  1127 1127 1132 1169* 1170 1170 1170
mclp                            000326 automatic       pointer                  dcl 12-7 set ref 1081* 1082 1095 1096 1151* 1152
                                                                                  1168 1169 1174
meter_ptr                       000164 automatic       pointer                  dcl 111 set ref 1000* 1002 1009
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "fnp_multiplexer"
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "fnp_multiplexer" ref 1295
mii_chan_count                  000324 automatic       fixed bin(17,0)          dcl 10-7 set ref 362* 414 422
miip                            000322 automatic       pointer                  dcl 10-6 set ref 361* 362 440 443
mode_alter_types                000015 constant        fixed bin(8,0)           initial array dcl 303 ref 1593 1596 1600
mode_name                              parameter       char                     packed unaligned dcl 1549 in procedure
                                                                                  "process_mode" ref 1546 1555 1564 1564 1567 1593
mode_name                              based           char(16)                 level 2 in structure "mcle" packed packed unaligned
                                                                                  dcl 12-26 in procedure "fnp_multiplexer" set ref
                                                                                  1097 1170*
mode_name                       000210 automatic       char(8)                  packed unaligned dcl 123 in procedure
                                                                                  "fnp_multiplexer" set ref 1097* 1100 1107 1115
                                                                                  1118 1118 1118
mode_name_index                 000444 automatic       fixed bin(17,0)          dcl 1551 set ref 1569* 1573* 1589
mode_on                         000212 automatic       bit(1)                   packed unaligned dcl 124 in procedure
                                                                                  "fnp_multiplexer" set ref 1098* 1118 1122
mode_on                                parameter       bit(1)                   packed unaligned dcl 1550 in procedure
                                                                                  "process_mode" ref 1546 1553 1558 1577
mode_set                        000213 automatic       bit(1)                   array packed unaligned dcl 125 set ref 1166* 1180
                                                                                  1589* 1601*
mode_switch               4            based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1098 1170*
modex                           000207 automatic       fixed bin(17,0)          dcl 122 set ref 1095* 1096* 1168* 1169* 1179* 1180
                                                                                  1180*
mpx_mode                  4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1103* 1110* 1113* 1127* 1170
mux_init_info                          based           structure                level 1 dcl 10-10
my_chan_name                    000102 automatic       char(1)                  packed unaligned dcl 81 set ref 371* 372* 383
mylock                          000135 automatic       bit(1)                   packed unaligned dcl 99 set ref 1407* 1804* 1809*
                                                                                  1823
n_channels               25            based           fixed bin(17,0)          level 2 dcl 16-35 set ref 1255*
n_entries                 1            based           fixed bin(17,0)          level 2 dcl 12-10 ref 1095 1168
n_fnp_words                     000235 automatic       fixed bin(17,0)          dcl 144 set ref 1225* 1226 1226 1226 1327* 1330 1330
                                                                                  1330
n_pcbs                          000316 automatic       fixed bin(17,0)          dcl 6-22 set ref 422* 423 436 493
n_sync_line_types                      constant        fixed bin(17,0)          initial dcl 9-50 ref 982 985 1843 1846
name                            000237 automatic       char(32)                 packed unaligned dcl 146 in procedure
                                                                                  "fnp_multiplexer" set ref 443* 444* 1360* 1361
                                                                                  1364*
name                                   parameter       char                     packed unaligned dcl 1753 in procedure "name_to_pcb"
                                                                                  set ref 1750 1756*
name                      1            based           char(32)                 array level 3 in structure "mux_init_info" packed
                                                                                  packed unaligned dcl 10-10 in procedure
                                                                                  "fnp_multiplexer" ref 443
names                                  based           char(32)                 array level 2 packed packed unaligned dcl 4-65 ref
                                                                                  369 371
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 3-28
                                                                                  set ref 668 669 676*
next_digit                      000204 automatic       fixed bin(6,0)           unsigned dcl 118 set ref 788* 791 791 791 795
no_channels                            based           fixed bin(17,0)          level 2 dcl 10-10 ref 362
no_of_channels            6            based           fixed bin(17,0)          level 2 dcl 5-67 set ref 422* 522 537 1255 1771
null                                                   builtin function         dcl 208 ref 363 417 423 439 491 495 539 605 643 690
                                                                                  887 1002 1051 1238 1282 1293 1450 1453 1502 1675
                                                                                  1684 1795 1910
old_flag                        000222 automatic       bit(1)                   packed unaligned dcl 135 set ref 429* 452 459*
old_value_ptr             4            based           pointer                  level 2 dcl 190 ref 1336
opcode                                 parameter       fixed bin(8,0)           dcl 1619 in procedure "send_global" set ref 1614
                                                                                  1627* 1645
opcode                          000136 automatic       fixed bin(8,0)           dcl 100 in procedure "fnp_multiplexer" set ref 705*
                                                                                  719* 743* 750* 757* 764* 781* 800* 817* 825* 835*
                                                                                  841* 847* 863* 875* 880* 940 945 966* 969 973 988
                                                                                  998 1015*
opend                           000206 automatic       bit(1)                   packed unaligned dcl 120 set ref 1041* 1068
order                           000120 automatic       char(32)                 packed unaligned dcl 92 set ref 700* 708 715 722 728
                                                                                  734 734 737 740 746 753 760 767 774 784 804 810
                                                                                  813 819 827 837 843 849 865 878 884 898 1206* 1209
                                                                                  1235 1314* 1319 1348 1383 1386 1464 1474 1483
output_control_transactions
                         41            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1267*
output_control_transactions
                         54            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1267
output_data_transactions
                         37            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1265*
output_data_transactions
                         52            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1265
output_fc_chars                        constant        fixed bin(8,0)           initial dcl 7-24 ref 875
output_flow_control_info               based           structure                level 1 dcl 13-19
output_length                   000111 automatic       fixed bin(17,0)          dcl 87 set ref 666* 670* 670 682
output_mbx_in_use_cum
                         26            based           fixed bin(35,0)          level 2 dcl 16-35 set ref 1256*
output_mbx_pending        4(08)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref 945
output_mbx_unavailable
                         30            based           fixed bin(35,0)          level 2 dcl 16-35 set ref 1258*
output_mbx_updates       27            based           fixed bin(35,0)          level 2 dcl 16-35 set ref 1257*
output_pending            2            based           bit(1)                   level 2 dcl 182 set ref 1068*
output_ptr                      000106 automatic       pointer                  dcl 85 set ref 654* 665 676 679
pad                      14            based           fixed bin(17,0)          array level 2 in structure "fnp_async_meters"
                                                                                  dcl 17-46 in procedure "fnp_multiplexer" set ref
                                                                                  1534*
pad                      27            based           fixed bin(17,0)          array level 2 in structure "fnp_sync_meters"
                                                                                  dcl 17-35 in procedure "fnp_multiplexer" set ref
                                                                                  1532*
parent_ptr                6            based           pointer                  level 2 dcl 18-8 ref 886
parse_fnp_name_                 000050 constant        entry                    external dcl 233 ref 372
parse_tty_name_                 000046 constant        entry                    external dcl 232 ref 444 1756
past                            000234 automatic       bit(1)                   packed unaligned dcl 143 set ref 1770* 1771 1773*
patch_mem                              constant        fixed bin(8,0)           initial dcl 7-24 set ref 1341*
pcb                                    based           structure                level 1 dcl 6-27 set ref 414 438* 537
pcb_array                              based           structure                array level 1 dcl 6-25 set ref 437 494 523 1426 1772
pcb_array_ptr             2            based           pointer                  level 2 dcl 5-67 set ref 425* 523 537* 539* 1426
                                                                                  1772
pcb_space                       000104 automatic       fixed bin(17,0)          dcl 83 set ref 414* 415 426
pcb_space_ptr                   000224 automatic       pointer                  dcl 136 set ref 363* 416* 417 423 425 426 437 491
                                                                                  494 498*
pcbp                            000320 automatic       pointer                  dcl 6-23 set ref 414 437* 438 439 440 441 462 463
                                                                                  464 465 478 494* 495 495 523* 524 524 524 524 526
                                                                                  526 526 526 528 529 531 531 532 537 673 675 679
                                                                                  681 682 682 684 684* 907 907 914 915 920 942 942
                                                                                  945 945 961 973 985 993* 1009 1010 1015* 1019*
                                                                                  1024 1026 1026 1026 1027 1027 1027 1031* 1033 1035
                                                                                  1036 1036 1041 1049 1058 1113 1118 1122 1122 1122
                                                                                  1122 1370 1426* 1434 1526 1528 1532 1536 1539 1540
                                                                                  1558 1562 1579 1609* 1704* 1708 1709* 1716 1727
                                                                                  1727 1733 1739 1772* 1773 1775 1843 1848 1849 1853
pcbx                            000232 automatic       fixed bin(17,0)          dcl 141 set ref 436* 437 440 442 443 450 455 457*
                                                                                  493* 494* 1764* 1766* 1767 1771
pds$process_group_id            000126 external static char(32)                 dcl 262 set ref 1331*
pds$processid                   000124 external static bit(36)                  dcl 261 ref 1232 1345 1493 1505 1804
per_datanet              22            based           structure                array level 2 dcl 5-52 set ref 380 1874 1886
phone_chars                            based           varying char(32)         dcl 180 ref 787 788
phone_digits                    000176 automatic       bit(6)                   array packed unaligned dcl 117 set ref 795* 996
phone_no_len                    000175 automatic       fixed bin(17,0)          dcl 116 set ref 799* 995
prev_la_no                      000226 automatic       fixed bin(17,0)          dcl 137 set ref 428* 452 458*
processed_from_q         34            based           fixed bin(35,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" set ref 1262*
processed_from_q         47            based           fixed bin(35,0)          level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "fnp_multiplexer" ref 1262
ptr                                                    builtin function         dcl 208 ref 524 524 526 526 531 531 669 675 1026
                                                                                  1026 1528
pxss$addevent                   000052 constant        entry                    external dcl 234 ref 1621 1650 1691 1738
pxss$delevent                   000054 constant        entry                    external dcl 235 ref 1653 1742
pxss$wait                       000056 constant        entry                    external dcl 236 ref 1630 1651 1713 1739
q_entries_made           45            based           fixed bin(35,0)          level 2 dcl 5-67 ref 1260
queue_entries_made       32            based           fixed bin(35,0)          level 2 dcl 16-35 set ref 1260*
queue_locked                    000134 automatic       bit(1)                   packed unaligned dcl 98 set ref 1421*
rd_stat                                based           structure                level 1 dcl 186
read_first                5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-27
                                                                                  set ref 526 526 526
rel                                                    builtin function         dcl 208 ref 567 567 676 679 681 1009 1511 1690
report_meters                   000157 constant        fixed bin(8,0)           initial dcl 7-24 set ref 880 998 1703* 1709*
resume_or_ack_seq         2            based           structure                level 2 packed packed unaligned dcl 13-19
resume_seq                1            based           structure                level 2 packed packed unaligned dcl 13-9
ret_meters_ptr                  000172 automatic       pointer                  dcl 114 set ref 886* 887 889 1049 1056 1058
rtrim                                                  builtin function         dcl 208 ref 369 371
running                  30(02)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 517
                                                                                  624 628* 1426 1453 1633 1717
saved_meters             34            based           structure                level 2 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer" set ref
                                                                                  1058*
saved_meters             24            based           structure                level 2 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "fnp_multiplexer" set ref 1296*
saved_meters_ptr          6            based           pointer                  level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  439* 478* 495 495 528 1058 1536
saved_meters_ptr          6            based           pointer                  array level 2 in structure "pcb_array" packed packed
                                                                                  unaligned dcl 6-25 in procedure "fnp_multiplexer"
                                                                                  set ref 423*
screenleft                1            based           fixed bin(35,0)          level 2 dcl 202 ref 822
send_output               4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref 684
                                                                                  1036
set_delay_table                        constant        fixed bin(8,0)           initial dcl 7-24 ref 764
set_echnego_break_table                constant        fixed bin(8,0)           initial dcl 7-24 ref 835
set_framing_chars                      constant        fixed bin(8,0)           initial dcl 7-24 ref 757
set_line_type                          constant        fixed bin(8,0)           initial dcl 7-24 ref 781 973
set_write_status                000132 automatic       bit(1)                   packed unaligned dcl 94 set ref 703* 810* 1041 1068
size                                                   builtin function         dcl 208 ref 414 477 477 495 495 528 528 531 531 537
                                                                                  1000 1000 1062 1062 1287 1287 1537 1537 1679 1681
slot_no                   0(30)        based           bit(6)                   level 4 packed packed unaligned dcl 6-27 set ref
                                                                                  465* 1775
sourcep                         000112 automatic       pointer                  dcl 88 set ref 1328* 1330
space_needed                    000105 automatic       fixed bin(17,0)          dcl 84 set ref 415* 416* 498*
space_size                      000462 automatic       fixed bin(17,0)          dcl 1669 set ref 1679* 1681* 1683*
stac                                                   builtin function         dcl 208 ref 1493
stacq                                                  builtin function         dcl 208 ref 1232 1345 1505
start_negotiated_echo                  constant        fixed bin(8,0)           initial dcl 7-24 ref 825 945
stop_negotiated_echo                   constant        fixed bin(8,0)           initial dcl 7-24 ref 847
string                                                 builtin function         dcl 208 set ref 427* 536* 996 1166* 1370 1727 1727
subchan                         000230 automatic       fixed bin(17,0)          dcl 139 in procedure "fnp_multiplexer" set ref 444*
                                                                                  462 465 1756* 1775
subchan                   0(18)        based           fixed bin(7,0)           level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "fnp_multiplexer" set ref
                                                                                  462*
subchan_ptr               2            based           pointer                  level 2 dcl 18-8 ref 1237 1284
subchannel                3(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-20 set ref
                                                                                  442*
substr                                                 builtin function         dcl 208 set ref 769 771 788 832 856 856 860* 871 871
                                                                                  1097 1359
suspend_or_etb_seq        1            based           structure                level 2 packed packed unaligned dcl 13-19
suspend_seq                            based           structure                level 2 packed packed unaligned dcl 13-9
sync_line                 4(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  985* 1049 1113 1532 1562 1848* 1853*
sync_line_type                  000000 constant        fixed bin(17,0)          initial array dcl 9-52 ref 982 1843
sync_msg_size                          constant        fixed bin(8,0)           initial dcl 7-24 ref 743
synchronous               1            based           bit(1)                   level 3 packed packed unaligned dcl 17-10 set ref
                                                                                  1049*
syserr                          000042 constant        entry                    external dcl 230 ref 607 616 1331 1336 1645 1727
                                                                                  1807 1913 1950 1963
syserr$error_code               000044 constant        entry                    external dcl 231 ref 619 1935 1961
t_and_d_in_progress      30(08)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 392
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 3-28
                                                                                  ref 666 670
tandd_attached            4(11)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  915* 942*
tandd_pcbx               64            based           fixed bin(17,0)          level 2 dcl 5-67 set ref 450*
temp_addr                       000247 automatic       fixed bin(17,0)          dcl 147 set ref 1334* 1336* 1338* 1338
temp_saved_meters_ptr           000162 automatic       pointer                  dcl 110 set ref 477* 478
timeout                   2            based           bit(1)                   level 2 dcl 13-9 ref 856
trace                     5            based           bit(1)                   level 2 dcl 5-52 ref 607 616 1913 1935 1950 1961
tty_area_manager$allocate       000032 constant        entry                    external dcl 226 ref 477
tty_area_manager$free           000034 constant        entry                    external dcl 227 ref 495 528
tty_buf                                based           structure                level 1 dcl 1-35
tty_buf$                        000130 external static fixed bin(17,0)          dcl 1-19 set ref 365 509 1243 1419 1461
tty_lock$lock_lcte              000030 constant        entry                    external dcl 225 ref 1810
tty_space_man$free_chain        000140 constant        entry                    external dcl 8-16 ref 524 526 1026
tty_space_man$free_space        000136 constant        entry                    external dcl 8-12 ref 498 531 537 1062 1228 1287
                                                                                  1342 1537
tty_space_man$get_space         000134 constant        entry                    external dcl 8-10 ref 416 1000 1501 1683
ttybp                           000300 automatic       pointer                  dcl 1-19 set ref 365* 366 385 509* 524 524 526 526
                                                                                  531 531 567 567 567 567 669 675 1010 1026 1026
                                                                                  1243* 1419* 1461* 1511 1528 1690
unspec                                                 builtin function         dcl 208 set ref 438* 829 830* 834 856 856 871 871
                                                                                  916* 920 920 1053 1296*
version                                based           fixed bin(17,0)          level 2 in structure "mcl" dcl 12-10 in procedure
                                                                                  "fnp_multiplexer" ref 1082 1152
version                                based           fixed bin(17,0)          level 2 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "fnp_multiplexer" ref 889
version                                based           fixed bin(17,0)          level 2 in structure "fnp_meters" dcl 16-35
                                                                                  in procedure "fnp_multiplexer" ref 1240
wired                    30(03)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 517
                                                                                  614
words                           000262 automatic       structure                array level 2 packed packed unaligned dcl 164 set
                                                                                  ref 831
wr_stat                                based           structure                level 1 dcl 182
write_cnt                 3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref
                                                                                  682* 682 1027*
write_first               1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref 524
                                                                                  524 524 679* 945 1024 1026 1026 1027* 1041
write_last                1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref 673
                                                                                  675 681* 1027*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_INPUT                           internal static fixed bin(17,0)          initial dcl 15-15
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 15-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 15-23
Breakall                               internal static fixed bin(8,0)           initial dcl 7-89
Breakchar                              internal static fixed bin(8,0)           initial dcl 7-89
CRASH                                  internal static fixed bin(17,0)          initial dcl 15-12
Chngstring                             internal static fixed bin(8,0)           initial dcl 7-89
Crecho                                 internal static fixed bin(8,0)           initial dcl 7-89
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 15-19
Echoplex                               internal static fixed bin(8,0)           initial dcl 7-89
Eight_bit_in                           internal static fixed bin(8,0)           initial dcl 7-89
Eight_bit_out                          internal static fixed bin(8,0)           initial dcl 7-89
Errormsg                               internal static fixed bin(8,0)           initial dcl 7-89
FIRST_BOOTLOAD_PAGEX                   internal static fixed bin(17,0)          initial dcl 5-166
FIRST_TTY_BUF_PAGEX                    internal static fixed bin(17,0)          initial dcl 5-167
Fullduplex                             internal static fixed bin(8,0)           initial dcl 7-89
GET_COMM_METERS_INFO_VERSION_1         internal static fixed bin(17,0)          initial dcl 18-21
HANGUP                                 internal static fixed bin(17,0)          initial dcl 15-11
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 15-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 15-16
LINE_1050                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_2741                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_ARDS                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_BSC                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_COLTS                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_DSA                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_ETX                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_G115                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_HASP_OPR                          internal static fixed bin(17,0)          initial dcl 9-22
LINE_HDLC                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_MC                                internal static fixed bin(17,0)          initial dcl 9-22
LINE_POLLED_VIP                        internal static fixed bin(17,0)          initial dcl 9-22
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 15-18
LINE_SYNC1                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNC2                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNC3                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNCH                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_TELNET                            internal static fixed bin(17,0)          initial dcl 9-22
LINE_UNKNOWN                           internal static fixed bin(17,0)          initial dcl 9-22
LINE_VIP                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_X25LAP                            internal static fixed bin(17,0)          initial dcl 9-22
Lfecho                                 internal static fixed bin(8,0)           initial dcl 7-89
Lock                                   internal static fixed bin(8,0)           initial dcl 7-89
MASKED                                 internal static fixed bin(17,0)          initial dcl 15-26
Meter                                  internal static fixed bin(8,0)           initial dcl 7-89
Msg                                    internal static fixed bin(8,0)           initial dcl 7-89
Nocontrol                              internal static fixed bin(8,0)           initial dcl 7-89
Odd_parity                             internal static fixed bin(8,0)           initial dcl 7-89
Output_flow_control                    internal static fixed bin(8,0)           initial dcl 7-89
Polite                                 internal static fixed bin(8,0)           initial dcl 7-89
Prefixnl                               internal static fixed bin(8,0)           initial dcl 7-89
QUIT                                   internal static fixed bin(17,0)          initial dcl 15-17
Replay                                 internal static fixed bin(8,0)           initial dcl 7-89
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 15-21
Sensepos                               internal static fixed bin(8,0)           initial dcl 7-89
Setbusy                                internal static fixed bin(8,0)           initial dcl 7-89
TIMER                                  internal static fixed bin(17,0)          initial dcl 15-24
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 1-33
Tabecho                                internal static fixed bin(8,0)           initial dcl 7-89
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 15-25
Upstate                                internal static fixed bin(8,0)           initial dcl 7-89
WORDS_IN_ECHO_BREAK_TABLE              internal static fixed bin(17,0)          initial dcl 20-17
WRU_TIMEOUT                            internal static fixed bin(17,0)          initial dcl 15-20
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 1-19
accept_direct_input                    internal static fixed bin(8,0)           initial dcl 7-65
accept_last_output                     internal static fixed bin(8,0)           initial dcl 7-24
accept_new_terminal                    internal static fixed bin(8,0)           initial dcl 7-65
ack_echnego_init                       internal static fixed bin(8,0)           initial dcl 7-65
ack_echnego_stop                       internal static fixed bin(8,0)           initial dcl 7-65
acu_dial_failure                       internal static fixed bin(8,0)           initial dcl 7-65
acu_line_occupied                      internal static fixed bin(8,0)           initial dcl 7-65
acu_no_good                            internal static fixed bin(8,0)           initial dcl 7-65
acu_no_power                           internal static fixed bin(8,0)           initial dcl 7-65
based_bit1                             based           bit(1)                   packed unaligned dcl 172
blast                                  internal static fixed bin(8,0)           initial dcl 7-24
break_acknowledged                     internal static fixed bin(8,0)           initial dcl 7-24
break_condition                        internal static fixed bin(8,0)           initial dcl 7-65
bsizec                                 internal static fixed bin(17,0)          initial dcl 1-28
channel_manager$check_modes     000000 constant        entry                    external dcl 14-19
channel_manager$control         000000 constant        entry                    external dcl 14-13
channel_manager$get_modes       000000 constant        entry                    external dcl 14-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 14-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 14-31
channel_manager$read            000000 constant        entry                    external dcl 14-7
channel_manager$set_modes       000000 constant        entry                    external dcl 14-16
channel_manager$write           000000 constant        entry                    external dcl 14-10
checksum_error                         internal static fixed bin(8,0)           initial dcl 7-24
connect_to_slave                       internal static fixed bin(8,0)           initial dcl 7-65
disconnect_accepted                    internal static fixed bin(8,0)           initial dcl 7-24
disconnect_all_lines                   internal static fixed bin(8,0)           initial dcl 7-24
disconnected_line                      internal static fixed bin(8,0)           initial dcl 7-65
echo_data                              based           structure                level 1 dcl 20-19
echo_datap                             automatic       pointer                  dcl 20-15
error_message                          internal static fixed bin(8,0)           initial dcl 7-65
first_acu_op_code                      internal static fixed bin(8,0)           initial dcl 7-65
fnp_chan_meterp                        automatic       pointer                  dcl 17-7
free_block                             based           structure                level 1 dcl 3-23
free_blockp                            automatic       pointer                  dcl 3-20
global_opcodes                         internal static fixed bin(8,0)           initial array dcl 7-126
init_complete                          internal static fixed bin(8,0)           initial dcl 7-24
input_accepted                         internal static fixed bin(8,0)           initial dcl 7-24
input_bpart                            internal static fixed bin(18,0)          initial dcl 1-19
input_in_mailbox                       internal static fixed bin(8,0)           initial dcl 7-65
interrupt_info                         automatic       bit(72)                  dcl 15-28
io_chnl_util$canonicalize_chanid
                                000000 constant        entry                    external dcl 11-8
io_chnl_util$iom_to_name        000000 constant        entry                    external dcl 11-12
io_manager$assign_add           000000 constant        entry                    external dcl 19-15
io_manager$connect              000000 constant        entry                    external dcl 19-26
io_manager$connect_abs          000000 constant        entry                    external dcl 19-29
io_manager$connect_direct       000000 constant        entry                    external dcl 19-32
io_manager$get_status           000000 constant        entry                    external dcl 19-35
io_manager$ignore_interrupt     000000 constant        entry                    external dcl 19-41
io_manager$mask                 000000 constant        entry                    external dcl 19-38
io_manager$unassign_delete      000000 constant        entry                    external dcl 19-23
io_manager$workspace_tdcw       000000 constant        entry                    external dcl 19-47
io_manager_arg_ptr                     automatic       pointer                  dcl 19-49
last_acu_op_code                       internal static fixed bin(8,0)           initial dcl 7-65
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
line_masked                            internal static fixed bin(8,0)           initial dcl 7-65
line_status                            internal static fixed bin(8,0)           initial dcl 7-65
line_types                             internal static char(16)                 initial array packed unaligned dcl 9-54
lock_ptr                               automatic       pointer                  dcl 2-9
mask_ptwp                              automatic       pointer                  dcl 97
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 3-43
old_mask                               automatic       fixed bin(71,0)          dcl 96
output_bpart                           internal static fixed bin(18,0)          initial dcl 1-19
pxss$notify                     000000 constant        entry                    external dcl 216
qblock_size                            internal static fixed bin(17,0)          initial dcl 1-27
rcd                                    internal static fixed bin(8,0)           initial dcl 7-14
reject_request_temp                    internal static fixed bin(8,0)           initial dcl 7-24
rtx                                    internal static fixed bin(8,0)           initial dcl 7-14
rtx_info                               automatic       structure                level 1 dcl 15-38
s6180_params                           internal static fixed bin(8,0)           initial dcl 7-65
saved_meters                           based           structure                level 1 dcl 4-68
send_output                            internal static fixed bin(8,0)           initial dcl 7-65
terminal_accepted                      internal static fixed bin(8,0)           initial dcl 7-24
terminal_rejected                      internal static fixed bin(8,0)           initial dcl 7-24
timer_info                             automatic       structure                level 1 dcl 15-50
tty_ev                                 internal static fixed bin(17,0)          initial dcl 1-19
tty_space_man$free_buffer       000000 constant        entry                    external dcl 8-14
tty_space_man$get_buffer        000000 constant        entry                    external dcl 8-13
tty_space_man$get_chain         000000 constant        entry                    external dcl 8-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 8-11
tty_space_man$needs_space       000000 constant        entry                    external dcl 8-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 8-17
wcd                                    internal static fixed bin(8,0)           initial dcl 7-14
wire_arg                               automatic       fixed bin(71,0)          dcl 132
wire_ptr                               automatic       pointer                  dcl 133
wru_timeout                            internal static fixed bin(8,0)           initial dcl 7-65
wtx                                    internal static fixed bin(8,0)           initial dcl 7-14

NAMES DECLARED BY EXPLICIT CONTEXT.
TRACE                           010566 constant        entry                    internal dcl 1945 ref 381 512 562 584 611 1872 1885
TRACE_ERROR                     010621 constant        entry                    internal dcl 1956 ref 488 549 571 592 1917 1940
abort_get_meters                007646 constant        label                    dcl 1730 ref 1720
assign                          006206 constant        entry                    external dcl 1868
assign_channel                  010300 constant        entry                    internal dcl 1893 ref 398 1875
assign_channel_return           010366 constant        label                    dcl 1913 ref 1901 1907
bad_channel                     001011 constant        label                    dcl 375 ref 369 383 385
bad_device                      010104 constant        label                    dcl 1781 ref 1761 1767
bad_fnp_len                     006425 constant        label                    dcl 1478 ref 1483
bad_mode                        004744 constant        label                    dcl 1127 ref 1118
check_modes                     004512 constant        entry                    external dcl 1074
control                         002702 constant        entry                    external dcl 695
end_dump_mem                    005304 constant        label                    dcl 1228 ref 1220
fnp_buf_size                    010221 constant        entry                    internal dcl 1836 ref 960 992
fnp_lock                        006136 constant        entry                    external dcl 1395
fnp_multiplexer                 000675 constant        entry                    external dcl 13
fnp_unlock                      006162 constant        entry                    external dcl 1403
get_fnp_meters                  007327 constant        entry                    internal dcl 1663 ref 1046 1251
get_modes                       005147 constant        entry                    external dcl 1191
hpriv_control                   005534 constant        entry                    external dcl 1308
hpriv_exit                      006131 constant        label                    dcl 1391
init_abort                      001500 constant        label                    dcl 488 ref 395 399 403 420 448 474
init_exit                       001477 constant        label                    dcl 485 ref 377
init_multiplexer                000710 constant        entry                    external dcl 351
lock                            010112 constant        entry                    internal dcl 1790 ref 513 626 1244 1374 1399 1422
                                                                                  1623 1714 1743 1757
name_to_pcb                     007735 constant        entry                    internal dcl 1750 ref 1364
order_error                     003632 constant        label                    dcl 927 ref 778 977
priv_control                    005204 constant        entry                    external dcl 1200
process_mode                    006622 constant        entry                    internal dcl 1546 ref 1170 1176 1180
read                            002500 constant        entry                    external dcl 638
save_copied_meters              006540 constant        entry                    internal dcl 1519 ref 1434
send_global                     007126 constant        entry                    internal dcl 1614 ref 1219 1341
set_modes                       004770 constant        entry                    external dcl 1144
setup                           006301 constant        entry                    internal dcl 1412 ref 564 586 656 900 933 1088 1158
setup_fnp                       006346 constant        entry                    internal dcl 1443 ref 1211 1321 1350
setup_fnp_down                  006364 constant        label                    dcl 1456 ref 1450
shutdown                        002274 constant        entry                    external dcl 598
shutdown_return                 002471 constant        label                    dcl 633 ref 609
start                           002065 constant        entry                    external dcl 555
stop                            002177 constant        entry                    external dcl 577
terminate_multiplexer           001577 constant        entry                    external dcl 503
terminate_return                002051 constant        label                    dcl 549 ref 514
unassign                        006244 constant        entry                    external dcl 1880
unassign_channel                010447 constant        entry                    internal dcl 1922 ref 543 1888
unassign_return                 010501 constant        label                    dcl 1935 ref 1930
unlock                          010176 constant        entry                    internal dcl 1818 ref 547 569 590 629 688 909 921
                                                                                  950 976 1004 1047 1067 1140 1185 1280 1379 1409
                                                                                  1429 1628 1712 1737 1781
write                           002525 constant        entry                    external dcl 649
write_exit                      002664 constant        label                    dcl 688

NAMES DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 822 822
index                                                  builtin function         ref 788

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11740       12112   11003       11750
Length     13112   11003       152         763     734           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fnp_multiplexer                     782 external procedure  is an external procedure.  
on unit on line 471                  64 on unit               
begin block on line 1270                begin block         shares stack frame of external procedure fnp_multiplexer.  
setup                                   internal procedure  shares stack frame of external procedure fnp_multiplexer.  
setup_fnp                               internal procedure  shares stack frame of external procedure fnp_multiplexer.  
save_copied_meters                      internal procedure  shares stack frame of external procedure fnp_multiplexer.  
process_mode                            internal procedure  shares stack frame of external procedure fnp_multiplexer.  
send_global                             internal procedure  shares stack frame of external procedure fnp_multiplexer.  
get_fnp_meters                          internal procedure  shares stack frame of external procedure fnp_multiplexer.  
name_to_pcb                             internal procedure  shares stack frame of external procedure fnp_multiplexer.  
lock                                    internal procedure  shares stack frame of external procedure fnp_multiplexer.  
unlock                                  internal procedure  shares stack frame of external procedure fnp_multiplexer.  
fnp_buf_size                            internal procedure  shares stack frame of external procedure fnp_multiplexer.  
assign_channel                          internal procedure  shares stack frame of external procedure fnp_multiplexer.  
unassign_channel                        internal procedure  shares stack frame of external procedure fnp_multiplexer.  
TRACE                                   internal procedure  shares stack frame of external procedure fnp_multiplexer.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fnp_multiplexer          000100 code                        fnp_multiplexer
                         000101 devx                        fnp_multiplexer
                         000102 my_chan_name                fnp_multiplexer
                         000103 dno                         fnp_multiplexer
                         000104 pcb_space                   fnp_multiplexer
                         000105 space_needed                fnp_multiplexer
                         000106 output_ptr                  fnp_multiplexer
                         000110 chanx                       fnp_multiplexer
                         000111 output_length               fnp_multiplexer
                         000112 sourcep                     fnp_multiplexer
                         000114 i                           fnp_multiplexer
                         000115 j                           fnp_multiplexer
                         000116 lastp                       fnp_multiplexer
                         000120 order                       fnp_multiplexer
                         000130 data_ptr                    fnp_multiplexer
                         000132 set_write_status            fnp_multiplexer
                         000133 locked                      fnp_multiplexer
                         000134 queue_locked                fnp_multiplexer
                         000135 mylock                      fnp_multiplexer
                         000136 opcode                      fnp_multiplexer
                         000137 alter_type                  fnp_multiplexer
                         000140 check                       fnp_multiplexer
                         000141 mbx_data_len                fnp_multiplexer
                         000142 mbx_data_long               fnp_multiplexer
                         000152 alter_data                  fnp_multiplexer
                         000157 dumpin                      fnp_multiplexer
                         000160 dumpout                     fnp_multiplexer
                         000161 get_meters                  fnp_multiplexer
                         000162 temp_saved_meters_ptr       fnp_multiplexer
                         000164 meter_ptr                   fnp_multiplexer
                         000166 lcmp                        fnp_multiplexer
                         000170 fnp_meters_ptr              fnp_multiplexer
                         000172 ret_meters_ptr              fnp_multiplexer
                         000174 local_line_type             fnp_multiplexer
                         000175 phone_no_len                fnp_multiplexer
                         000176 phone_digits                fnp_multiplexer
                         000204 next_digit                  fnp_multiplexer
                         000205 digit_pos                   fnp_multiplexer
                         000206 opend                       fnp_multiplexer
                         000207 modex                       fnp_multiplexer
                         000210 mode_name                   fnp_multiplexer
                         000212 mode_on                     fnp_multiplexer
                         000213 mode_set                    fnp_multiplexer
                         000214 hndlquit_set                fnp_multiplexer
                         000215 base_len                    fnp_multiplexer
                         000216 block_len                   fnp_multiplexer
                         000217 chars_per_buf               fnp_multiplexer
                         000220 chars_per_sec               fnp_multiplexer
                         000221 hsla_flag                   fnp_multiplexer
                         000222 old_flag                    fnp_multiplexer
                         000224 pcb_space_ptr               fnp_multiplexer
                         000226 prev_la_no                  fnp_multiplexer
                         000227 la_no                       fnp_multiplexer
                         000230 subchan                     fnp_multiplexer
                         000231 his_fnp_no                  fnp_multiplexer
                         000232 pcbx                        fnp_multiplexer
                         000233 found                       fnp_multiplexer
                         000234 past                        fnp_multiplexer
                         000235 n_fnp_words                 fnp_multiplexer
                         000236 ignore                      fnp_multiplexer
                         000237 name                        fnp_multiplexer
                         000247 temp_addr                   fnp_multiplexer
                         000250 fnp_dump_ptr                fnp_multiplexer
                         000252 dump_patch_space            fnp_multiplexer
                         000254 dump_patch_time             fnp_multiplexer
                         000256 dump_fnp_data               fnp_multiplexer
                         000260 fnp_break_data              fnp_multiplexer
                         000262 echnego_break_table         fnp_multiplexer
                         000300 ttybp                       fnp_multiplexer
                         000302 blockp                      fnp_multiplexer
                         000304 lctp                        fnp_multiplexer
                         000306 lctep                       fnp_multiplexer
                         000310 lcntp                       fnp_multiplexer
                         000312 infop                       fnp_multiplexer
                         000314 fnpp                        fnp_multiplexer
                         000316 n_pcbs                      fnp_multiplexer
                         000320 pcbp                        fnp_multiplexer
                         000322 miip                        fnp_multiplexer
                         000324 mii_chan_count              fnp_multiplexer
                         000326 mclp                        fnp_multiplexer
                         000330 mclep                       fnp_multiplexer
                         000332 dialup_info                 fnp_multiplexer
                         000334 fnp_meterp                  fnp_multiplexer
                         000336 fnp_no                      fnp_multiplexer
                         000404 iom                         begin block on line 1270
                         000405 chan                        begin block on line 1270
                         000422 fnp_address                 setup_fnp
                         000423 fnp_len                     setup_fnp
                         000432 copied_meters_ptr           save_copied_meters
                         000444 mode_name_index             process_mode
                         000462 space_size                  get_fnp_meters
                         000464 fnp_meter_wait_start        get_fnp_meters

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_le_a              alloc_bit_temp      alloc_temp          cat_realloc_bits
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           stac_mac            enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$interrupt     dn355$hangup_fnp_lines        dn355$interrupt               dn355$process_interrupt_queue
dn355$send_global_wcd         dn355$send_wcd                fnp_util$fill_page_table      fnp_util$free_page_table
fnp_util$unwire               io_chnl_util$name_to_iom      io_manager$assign             io_manager$unassign
lock$lock_fast                lock$unlock_fast              parse_fnp_name_               parse_tty_name_
pxss$addevent                 pxss$delevent                 pxss$wait                     syserr
syserr$error_code             tty_area_manager$allocate     tty_area_manager$free         tty_lock$lock_lcte
tty_space_man$free_chain      tty_space_man$free_space      tty_space_man$get_space

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dn355_data$                   error_table_$bad_channel      error_table_$bad_mode         error_table_$buffer_big
error_table_$dev_offset_out_of_bounds                       error_table_$invalid_state    error_table_$invalid_write
error_table_$io_assigned      error_table_$io_not_assigned  error_table_$io_not_available
error_table_$io_not_configured                              error_table_$mpx_down
error_table_$no_channel_meters                              error_table_$noalloc
error_table_$resource_not_free                              error_table_$seglock          error_table_$timeout
error_table_$undefined_order_request                        error_table_$unimplemented_version
pds$process_group_id          pds$processid                 tty_buf$


CONSTANTS
010705  aa     577777777777

010706  aa     077777000043
010707  aa     000001000000

010710  aa     777577777777

010711  aa     777757777777

010712  aa     757777777777

010713  aa     777377777777

010714  aa     000002000000
010715  aa     000002000000
010716  aa     600000000041
010717  aa     000237000000
010720  ta     000150000000
010721  aa     000000000000

010722  aa     000002000000
010723  aa     000000000000
010724  ta     000125000000
010725  aa     000000000000

010726  aa     000002000000
010727  aa     000000000000
010730  aa     600000000041
010731  aa     000611000000

010732  aa     000002000000
010733  aa     000000000000
010734  ta     000126000000
010735  aa     000000000000

010736  aa     000004000000
010737  aa     000004000000
010740  aa     600000000041
010741  aa     000630000000
010742  aa     600000000041
010743  aa     000610000000
010744  ta     000155000000
010745  aa     000000000000
010746  ta     000164000000
010747  aa     000000000000

010750  aa     767777777777

010752  aa     000002000000
010753  aa     000000000000
010754  aa     600000000041
010755  aa     000610000000

010756  aa     777677777777

010757  aa     377777777777

010760  aa     000777777777

010761  aa     677777777777

010762  aa     000004000000
010763  aa     000000000000
010764  aa     600000000041
010765  aa     000546000000
010766  aa     600000000041
010767  aa     000100000000

010770  aa     007777000001

010772  aa     000002000000
010773  aa     000000000000
010774  aa     600000000041
010775  aa     000100000000

010776  aa     000002000000
010777  aa     000000000000
011000  aa     600000000041
011001  aa     000546000000

000000  aa     000000000005
000001  aa     000000000006
000002  aa     000000000007
000003  aa     000000000011
000004  aa     000000000015
000005  aa     000000000016
000006  aa     000000000017
000007  aa     000000000020
000010  aa     000000000021
000011  aa     000000000022

000012  aa     000000000042

000013  aa     000000000025

000014  aa     000000000073

000015  aa     000000000010
000016  aa     000000000016
000017  aa     000000000011
000020  aa     000000000024
000021  aa     000000000003
000022  aa     000000000027
000023  aa     000000000030
000024  aa     000000000033
000025  aa     000000000034
000026  aa     000000000041
000027  aa     000000000040
000030  aa     000000000037
000031  aa     000000000036

000032  aa  143 162 145 143	crec
000033  aa  150 157 040 040	ho  
000034  aa  164 141 142 145	tabe
000035  aa  143 150 157 040	cho 
000036  aa  154 146 145 143	lfec
000037  aa  150 157 040 040	ho  
000040  aa  145 143 150 157	echo
000041  aa  160 154 145 170	plex
000042  aa  146 165 154 154	full
000043  aa  144 160 170 040	dpx 
000044  aa  151 146 154 157	iflo
000045  aa  167 040 040 040	w   
000046  aa  157 146 154 157	oflo
000047  aa  167 040 040 040	w   

000050  aa  143 162 145 143	crec
000051  aa  150 157 040 040	ho  
000052  aa  164 141 142 145	tabe
000053  aa  143 150 157 040	cho 
000054  aa  154 146 145 143	lfec
000055  aa  150 157 040 040	ho  
000056  aa  145 143 150 157	echo
000057  aa  160 154 145 170	plex
000060  aa  146 165 154 154	full
000061  aa  144 160 170 040	dpx 
000062  aa  162 145 160 154	repl
000063  aa  141 171 040 040	ay  
000064  aa  160 157 154 151	poli
000065  aa  164 145 040 040	te  
000066  aa  142 162 145 141	brea
000067  aa  153 141 154 154	kall
000070  aa  160 162 145 146	pref
000071  aa  151 170 156 154	ixnl
000072  aa  156 157 137 157	no_o
000073  aa  165 164 160 040	utp 
000074  aa  070 142 151 164	8bit
000075  aa  040 040 040 040	    
000076  aa  157 144 144 160	oddp
000077  aa  040 040 040 040	    
000100  aa  157 146 154 157	oflo
000101  aa  167 040 040 040	w   
000102  aa  151 146 154 157	iflo
000103  aa  167 040 040 040	w   
000104  aa  142 154 153 137	blk_
000105  aa  170 146 145 162	xfer

000106  aa  150 156 144 154	hndl
000107  aa  161 165 151 164	quit

000110  aa     000046113200


000111  aa     524000000066

000112  aa     524000000042

000113  aa     524000000041

000114  aa     524000000117

000115  aa     524000000113

000116  aa     524000000035

000117  aa     514000000012

000120  aa     524000000111

000121  aa     524000000077

000122  aa     524000000027

000123  aa     524000000040

000124  aa     524000000050

000125  aa     000000000024

000126  aa     000000000023

000127  aa     526000000010

000130  aa     526000000020

000131  aa  157 144 144 160	oddp

000132  aa  070 142 151 164	8bit

000133  aa     514000000011

000134  aa     516000000440

000135  aa     516000000220

000136  aa     000000000012

000137  aa  167 162 165 000	wru

000140  aa     524000000057

000141  aa     524000000060

000142  aa     524000000062

000143  aa     514000000000

000144  aa  163 164 157 160	stop

000145  aa     514000000022

000146  aa     404000000010

000147  aa     516000000001

000150  aa     526000000040

000151  aa     400000000000

011002  aa     777777777777

000152  aa     000000000000

000153  aa     526000000001

000154  aa     516000000022

000155  aa     524000000010

000156  aa     000000000072

000157  aa     000000000044

000160  aa  141 162 145 141	area

000161  aa     526077777777

000162  aa     404000000043

000163  aa     000000000004

000164  aa     514000000001

000165  aa     000000000003

000166  aa     464000000000

000167  aa     000000000001

000170  aa     404000000021

000172  aa  151 146 154 157	iflo
000173  aa  167 000 000 000	w

000174  aa  142 154 153 137	blk_
000175  aa  170 146 145 162	xfer

000176  aa  165 156 141 163	unas
000177  aa  163 151 147 156	sign

000200  aa  141 163 163 151	assi
000201  aa  147 156 000 000	gn

000202  aa  144 165 155 160	dump
000203  aa  137 146 156 160	_fnp

000204  aa  150 156 144 154	hndl
000205  aa  161 165 151 164	quit

000206  aa  156 157 137 157	no_o
000207  aa  165 164 160 000	utp

000210  aa     000000000000
000211  aa     000000000000

000212  aa  154 151 163 164	list
000213  aa  145 156 000 000	en

000214  aa  144 151 141 154	dial
000215  aa  137 157 165 164	_out

000216  aa  141 142 157 162	abor
000217  aa  164 000 000 000	t

000220  aa  150 141 156 147	hang
000221  aa  165 160 000 000	up

000222  aa  163 150 165 164	shut
000223  aa  144 157 167 156	down

000224  aa  163 164 141 162	star
000225  aa  164 000 000 000	t

000226  aa     077777000043
000227  aa     000001000000

000230  aa  146 156 160 137	fnp_
000231  aa  142 162 145 141	brea
000232  aa  153 000 000 000	k

000233  aa  160 141 164 143	patc
000234  aa  150 137 146 156	h_fn
000235  aa  160 000 000 000	p

000236  aa  164 141 156 144	tand
000237  aa  144 137 141 164	d_at
000240  aa  164 141 143 150	tach

000241  aa  147 145 164 137	get_
000242  aa  155 145 164 145	mete
000243  aa  162 163 000 000	rs

000244  aa  143 157 160 171	copy
000245  aa  137 155 145 164	_met
000246  aa  145 162 163 000	ers

000247  aa  167 162 151 164	writ
000250  aa  145 137 163 164	e_st
000251  aa  141 164 165 163	atus

000252  aa  163 145 164 137	set_
000253  aa  144 145 154 141	dela
000254  aa  171 000 000 000	y

000255  aa  154 151 156 145	line
000256  aa  137 143 157 156	_con
000257  aa  164 162 157 154	trol

000260  aa  163 164 157 160	stop
000261  aa  137 170 155 151	_xmi
000262  aa  164 137 150 144	t_hd

000263  aa  151 156 164 145	inte
000264  aa  162 162 165 160	rrup
000265  aa  164 000 000 000	t

000266  aa  162 145 141 144	read
000267  aa  137 163 164 141	_sta
000270  aa  164 165 163 000	tus

000271  aa  165 156 141 163	unas
000272  aa  163 151 147 156	sign
000273  aa  137 143 150 141	_cha
000274  aa  156 156 145 154	nnel

000275  aa  141 163 163 151	assi
000276  aa  147 156 137 143	gn_c
000277  aa  150 141 156 156	hann
000300  aa  145 154 000 000	el

000301  aa  145 156 164 145	ente
000302  aa  162 137 162 145	r_re
000303  aa  143 145 151 166	ceiv
000304  aa  145 000 000 000	e

000305  aa  060 061 062 063	0123
000306  aa  064 065 066 067	4567
000307  aa  070 071 130 130	89XX
000310  aa  130 041 000 000	X!

000311  aa  163 145 164 137	set_
000312  aa  154 151 156 145	line
000313  aa  137 164 171 160	_typ
000314  aa  145 000 000 000	e

000315  aa  163 164 141 162	star
000316  aa  164 137 170 155	t_xm
000317  aa  151 164 137 150	it_h
000320  aa  144 000 000 000	d

000321  aa  151 156 151 164	init
000322  aa  137 155 165 154	_mul
000323  aa  164 151 160 154	tipl
000324  aa  145 170 145 162	exer

000325  aa  145 156 141 142	enab
000326  aa  154 145 137 142	le_b
000327  aa  162 145 141 153	reak
000330  aa  141 154 154 137	all_
000331  aa  155 157 144 145	mode

000332  aa  163 164 157 160	stop
000333  aa  137 156 145 147	_neg
000334  aa  157 164 151 141	otia
000335  aa  164 145 144 137	ted_
000336  aa  145 143 150 157	echo

000337  aa  163 145 164 137	set_
000340  aa  146 162 141 155	fram
000341  aa  151 156 147 137	ing_
000342  aa  143 150 141 162	char
000343  aa  163 000 000 000	s

000344  aa  144 151 163 141	disa
000345  aa  142 154 145 137	ble_
000346  aa  142 162 145 141	brea
000347  aa  153 141 154 154	kall
000350  aa  137 155 157 144	_mod
000351  aa  145 000 000 000	e

000352  aa  136 066 167 040	^6w 
000353  aa  146 162 157 155	from
000354  aa  040 136 066 056	 ^6.
000355  aa  063 142 040 164	3b t
000356  aa  157 040 136 066	o ^6
000357  aa  056 063 142 000	.3b

000360  aa  151 156 160 165	inpu
000361  aa  164 137 146 154	t_fl
000362  aa  157 167 137 143	ow_c
000363  aa  157 156 164 162	ontr
000364  aa  157 154 137 143	ol_c
000365  aa  150 141 162 163	hars

000366  aa  151 156 151 164	init
000367  aa  137 145 143 150	_ech
000370  aa  157 137 156 145	o_ne
000371  aa  147 157 164 151	goti
000372  aa  141 164 151 157	atio
000373  aa  156 000 000 000	n

000374  aa  163 145 164 137	set_
000375  aa  145 143 150 156	echn
000376  aa  145 147 157 137	ego_
000377  aa  142 162 145 141	brea
000400  aa  153 137 164 141	k_ta
000401  aa  142 154 145 000	ble

000402  aa  163 164 141 162	star
000403  aa  164 137 156 145	t_ne
000404  aa  147 157 164 151	goti
000405  aa  141 164 145 144	ated
000406  aa  137 145 143 150	_ech
000407  aa  157 000 000 000	o

000410  aa  163 145 164 137	set_
000411  aa  151 156 160 165	inpu
000412  aa  164 137 155 145	t_me
000413  aa  163 163 141 147	ssag
000414  aa  145 137 163 151	e_si
000415  aa  172 145 000 000	ze

000416  aa  164 145 162 155	term
000417  aa  151 156 141 164	inat
000420  aa  145 137 155 165	e_mu
000421  aa  154 164 151 160	ltip
000422  aa  154 145 170 145	lexe
000423  aa  162 000 000 000	r

000424  aa  157 165 164 160	outp
000425  aa  165 164 137 146	ut_f
000426  aa  154 157 167 137	low_
000427  aa  143 157 156 164	cont
000430  aa  162 157 154 137	rol_
000431  aa  143 150 141 162	char
000432  aa  163 000 000 000	s

000433  aa  146 156 160 137	fnp_
000434  aa  155 165 154 164	mult
000435  aa  151 160 154 145	iple
000436  aa  170 145 162 072	xer:
000437  aa  040 155 171 154	 myl
000440  aa  157 143 153 040	ock 
000441  aa  145 162 162 157	erro
000442  aa  162 000 000 000	r

000443  aa  146 156 160 137	fnp_
000444  aa  155 165 154 164	mult
000445  aa  151 160 154 145	iple
000446  aa  170 145 162 044	xer$
000447  aa  136 141 072 040	^a: 
000450  aa  124 162 141 143	Trac
000451  aa  151 156 147 040	ing 
000452  aa  145 162 162 157	erro
000453  aa  162 056 000 000	r.

000454  aa  146 156 160 137	fnp_
000455  aa  155 165 154 164	mult
000456  aa  151 160 154 145	iple
000457  aa  170 145 162 044	xer$
000460  aa  136 141 072 040	^a: 
000461  aa  124 162 141 143	Trac
000462  aa  151 156 147 040	ing 
000463  aa  143 141 154 154	call
000464  aa  056 000 000 000	.

000465  aa  146 156 160 137	fnp_
000466  aa  155 165 154 164	mult
000467  aa  151 160 154 145	iple
000470  aa  170 145 162 072	xer:
000471  aa  040 160 141 164	 pat
000472  aa  143 150 151 156	chin
000473  aa  147 040 106 116	g FN
000474  aa  120 040 136 141	P ^a
000475  aa  040 146 157 162	 for
000476  aa  040 136 141 072	 ^a:

000477  aa  146 156 160 137	fnp_
000500  aa  155 165 154 164	mult
000501  aa  151 160 154 145	iple
000502  aa  170 145 162 044	xer$
000503  aa  163 150 165 164	shut
000504  aa  144 157 167 156	down
000505  aa  072 040 106 141	: Fa
000506  aa  151 154 145 144	iled
000507  aa  040 164 157 040	 to 
000510  aa  165 156 167 151	unwi
000511  aa  162 145 040 146	re f
000512  aa  156 160 056 000	np.

000513  aa  146 156 160 137	fnp_
000514  aa  155 165 154 164	mult
000515  aa  151 160 154 145	iple
000516  aa  170 145 162 044	xer$
000517  aa  163 150 165 164	shut
000520  aa  144 157 167 156	down
000521  aa  072 040 103 141	: Ca
000522  aa  154 154 145 144	lled
000523  aa  040 167 151 164	 wit
000524  aa  150 040 106 116	h FN
000525  aa  120 040 167 151	P wi
000526  aa  162 145 144 056	red.

000527  aa  146 156 160 137	fnp_
000530  aa  155 165 154 164	mult
000531  aa  151 160 154 145	iple
000532  aa  170 145 162 044	xer$
000533  aa  163 150 165 164	shut
000534  aa  144 157 167 156	down
000535  aa  072 040 103 141	: Ca
000536  aa  154 154 145 144	lled
000537  aa  040 167 151 164	 wit
000540  aa  150 040 156 165	h nu
000541  aa  154 154 040 146	ll f
000542  aa  156 160 137 160	np_p
000543  aa  164 162 000 000	tr

000544  aa  146 156 160 137	fnp_
000545  aa  155 165 154 164	mult
000546  aa  151 160 154 145	iple
000547  aa  170 145 162 072	xer:
000550  aa  040 144 145 142	 deb
000551  aa  165 147 147 151	uggi
000552  aa  156 147 040 163	ng s
000553  aa  164 157 160 040	top 
000554  aa  050 164 171 160	(typ
000555  aa  145 040 147 157	e go
000556  aa  040 164 157 040	 to 
000557  aa  143 157 156 164	cont
000560  aa  151 156 165 145	inue
000561  aa  051 056 000 000	).

000562  aa  146 156 160 137	fnp_
000563  aa  155 165 154 164	mult
000564  aa  151 160 154 145	iple
000565  aa  170 145 162 072	xer:
000566  aa  040 136 133 144	 ^[d
000567  aa  165 155 160 136	ump^
000570  aa  073 160 141 164	;pat
000571  aa  143 150 136 135	ch^]
000572  aa  137 146 156 160	_fnp
000573  aa  040 157 162 144	 ord
000574  aa  145 162 040 164	er t
000575  aa  157 040 106 116	o FN
000576  aa  120 040 136 141	P ^a
000577  aa  040 164 151 155	 tim
000600  aa  145 144 040 157	ed o
000601  aa  165 164 056 000	ut.

000602  aa  146 156 160 137	fnp_
000603  aa  155 165 154 164	mult
000604  aa  151 160 154 145	iple
000605  aa  170 145 162 044	xer$
000606  aa  141 163 163 151	assi
000607  aa  147 156 137 143	gn_c
000610  aa  150 141 156 156	hann
000611  aa  145 154 072 040	el: 
000612  aa  101 163 163 151	Assi
000613  aa  147 156 155 145	gnme
000614  aa  156 164 040 157	nt o
000615  aa  146 040 106 116	f FN
000616  aa  120 040 136 141	P ^a
000617  aa  040 136 133 163	 ^[s
000620  aa  165 143 143 145	ucce
000621  aa  145 144 145 144	eded
000622  aa  136 073 146 141	^;fa
000623  aa  151 154 145 144	iled
000624  aa  136 135 056 000	^].

000625  aa  146 156 160 137	fnp_
000626  aa  155 165 154 164	mult
000627  aa  151 160 154 145	iple
000630  aa  170 145 162 072	xer:
000631  aa  040 147 145 164	 get
000632  aa  137 155 145 164	_met
000633  aa  145 162 163 040	ers 
000634  aa  157 162 144 145	orde
000635  aa  162 040 146 157	r fo
000636  aa  162 040 106 116	r FN
000637  aa  120 040 136 141	P ^a
000640  aa  136 133 136 163	^[^s
000641  aa  136 073 054 040	^;, 
000642  aa  154 151 156 145	line
000643  aa  040 136 157 054	 ^o,
000644  aa  136 135 040 164	^] t
000645  aa  151 155 145 144	imed
000646  aa  040 157 165 164	 out
000647  aa  056 000 000 000	.

000650  aa  146 156 160 137	fnp_
000651  aa  155 165 154 164	mult
000652  aa  151 160 154 145	iple
000653  aa  170 145 162 044	xer$
000654  aa  165 156 141 163	unas
000655  aa  163 151 147 156	sign
000656  aa  137 143 150 141	_cha
000657  aa  156 156 145 154	nnel
000660  aa  072 040 125 156	: Un
000661  aa  141 163 163 151	assi
000662  aa  147 156 155 145	gnme
000663  aa  156 164 040 157	nt o
000664  aa  146 040 106 116	f FN
000665  aa  120 040 136 141	P ^a
000666  aa  040 136 133 146	 ^[f
000667  aa  141 151 154 145	aile
000670  aa  144 136 073 163	d^;s
000671  aa  165 143 143 145	ucce
000672  aa  145 144 145 144	eded
000673  aa  136 135 056 000	^].

BEGIN PROCEDURE fnp_multiplexer
ENTRY TO fnp_multiplexer                                    STATEMENT 1 ON LINE 13
fnp_multiplexer:
     proc;

000674  da     000561200000
000675  aa   001420 6270 00	eax7 	784
000676  aa  7 00034 3521 20	epp2 	pr7|28,*
000677  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000700  aa     000000000000
000701  aa     000000000000
						STATEMENT 1 ON LINE 351
init_multiplexer:
     entry (a_devx, a_init_info_ptr, a_fnpp, a_code);

000702  aa   000020 7100 04	tra  	16,ic		000722
ENTRY TO init_multiplexer                                   STATEMENT 1 ON LINE 351
init_multiplexer:
     entry (a_devx, a_init_info_ptr, a_fnpp, a_code);

000703  at     000004000170
000704  tt     000166000166
000705  ta     000162000000
000706  ta     000703000000
000707  da     000571300000
000710  aa   001420 6270 00	eax7 	784
000711  aa  7 00034 3521 20	epp2 	pr7|28,*
000712  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000713  aa     000010000000
000714  aa     000000000000
000715  aa  6 00032 3735 20	epp7 	pr6|26,*
000716  aa  7 00006 3715 20	epp5 	pr7|6,*
000717  aa  6 00340 6515 00	spri5	pr6|224
000720  aa  7 00010 3535 20	epp3 	pr7|8,*
000721  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 360
	devx = a_devx;

000722  aa  6 00032 3735 20	epp7 	pr6|26,*
000723  aa  7 00002 2361 20	ldq  	pr7|2,*		a_devx
000724  aa  6 00101 7561 00	stq  	pr6|65		devx
						STATEMENT 1 ON LINE 361
	miip = a_init_info_ptr;

000725  aa  7 00004 3715 20	epp5 	pr7|4,*		a_init_info_ptr
000726  aa  5 00000 3715 20	epp5 	pr5|0,*		a_init_info_ptr
000727  aa  6 00322 6515 00	spri5	pr6|210		miip
						STATEMENT 1 ON LINE 362
	mii_chan_count = mux_init_info.no_channels;

000730  aa  5 00000 2361 00	ldq  	pr5|0		mux_init_info.no_channels
000731  aa  6 00324 7561 00	stq  	pr6|212		mii_chan_count
						STATEMENT 1 ON LINE 363
	pcb_space_ptr = null ();

000732  aa   777274 2370 04	ldaq 	-324,ic		000226 = 077777000043 000001000000
000733  aa  6 00224 7571 00	staq 	pr6|148		pcb_space_ptr
						STATEMENT 1 ON LINE 364
	infop = addr (dn355_data$);

000734  la  4 00132 3535 20	epp3 	pr4|90,*		dn355_data$
000735  aa  6 00312 2535 00	spri3	pr6|202		infop
						STATEMENT 1 ON LINE 365
	ttybp = addr (tty_buf$);

000736  la  4 00130 3515 20	epp1 	pr4|88,*		tty_buf$
000737  aa  6 00300 2515 00	spri1	pr6|192		ttybp
						STATEMENT 1 ON LINE 366
	lctp = tty_buf.lct_ptr;

000740  aa  1 00006 3715 20	epp5 	pr1|6,*		tty_buf.lct_ptr
000741  aa  6 00304 6515 00	spri5	pr6|196		lctp
						STATEMENT 1 ON LINE 368
	lcntp = lct.lcnt_ptr;

000742  aa  5 00002 3535 20	epp3 	pr5|2,*		lct.lcnt_ptr
000743  aa  6 00310 2535 00	spri3	pr6|200		lcntp
						STATEMENT 1 ON LINE 369
	if length (rtrim (lcnt.names (devx))) ^= 1
	then go to bad_channel;

000744  aa  6 00101 2361 00	ldq  	pr6|65		devx
000745  aa   000003 7360 00	qls  	3
000746  aa  3 77770 3515 06	epp1 	pr3|-8,ql		lcnt.names
000747  aa  6 00544 7561 00	stq  	pr6|356
000750  aa  000 000 165 500	tctr 	(pr)
000751  aa  1 00000 00 0040	desc9a	pr1|0,32		lcnt.names
000752  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000753  aa  6 00056 0001 00	arg  	pr6|46
000754  aa  6 00056 2361 00	ldq  	pr6|46
000755  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000756  aa  6 00545 7561 00	stq  	pr6|357
000757  aa   000040 2360 07	ldq  	32,dl
000760  aa  6 00545 1761 00	sbq  	pr6|357
000761  aa   000001 1160 07	cmpq 	1,dl
000762  aa   000027 6010 04	tnz  	23,ic		001011
						STATEMENT 1 ON LINE 371
	my_chan_name = rtrim (lcnt.names (devx));

000763  aa  6 00545 7561 00	stq  	pr6|357
000764  aa  6 00544 2361 00	ldq  	pr6|356
000765  aa   000002 7360 00	qls  	2
000766  aa  6 00102 4501 00	stz  	pr6|66		my_chan_name
000767  aa  6 00545 2351 00	lda  	pr6|357
000770  aa  040 100 100 546	mlr  	(pr,rl,ql),(pr),fill(040)
000771  aa  3 77770 00 0005	desc9a	pr3|-8,al		lcnt.names
000772  aa  6 00102 00 0001	desc9a	pr6|66,1		my_chan_name
						STATEMENT 1 ON LINE 372
	call parse_fnp_name_ (my_chan_name, dno);

000773  aa  6 00102 3521 00	epp2 	pr6|66		my_chan_name
000774  aa  6 00550 2521 00	spri2	pr6|360
000775  aa  6 00103 3521 00	epp2 	pr6|67		dno
000776  aa  6 00552 2521 00	spri2	pr6|362
000777  aa   777154 3520 04	epp2 	-404,ic		000153 = 526000000001
001000  aa  6 00554 2521 00	spri2	pr6|364
001001  aa   777167 3520 04	epp2 	-393,ic		000170 = 404000000021
001002  aa  6 00556 2521 00	spri2	pr6|366
001003  aa  6 00546 6211 00	eax1 	pr6|358
001004  aa   010000 4310 07	fld  	4096,dl
001005  la  4 00050 3521 20	epp2 	pr4|40,*		parse_fnp_name_
001006  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 373
	if dno < 0				/* unreasonable name */
	then do;

001007  aa  6 00103 2361 00	ldq  	pr6|67		dno
001010  aa   000005 6050 04	tpl  	5,ic		001015
						STATEMENT 1 ON LINE 375
bad_channel:
	     a_code = error_table_$bad_channel;

001011  aa  6 00044 3701 20	epp4 	pr6|36,*
001012  la  4 00066 2361 20	ldq  	pr4|54,*		error_table_$bad_channel
001013  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 377
	     go to init_exit;

001014  aa   000463 7100 04	tra  	307,ic		001477
						STATEMENT 1 ON LINE 378
	end;

						STATEMENT 1 ON LINE 380
	fnpp = addr (datanet_info.per_datanet (dno));

001015  aa   000072 4020 07	mpy  	58,dl
001016  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
001017  aa  7 77730 3735 06	epp7 	pr7|-40,ql	datanet_info.per_datanet
001020  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 381
	call TRACE ("init_multiplexer");

001021  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001022  aa   777300 00 0020	desc9a	-320,16		000321 = 151156151164
001023  aa  6 00546 00 0040	desc9a	pr6|358,32
001024  aa   007752 3520 04	epp2 	4074,ic		010776 = 000002000000
001025  aa   007541 6700 04	tsp4 	3937,ic		010566
						STATEMENT 1 ON LINE 383
	if my_chan_name ^= fnp_info.fnp_tag
	then go to bad_channel;

001026  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001027  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_tag
001030  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001031  aa  6 00545 7551 00	sta  	pr6|357		fnp_info.fnp_tag
001032  aa  6 00102 2351 00	lda  	pr6|66		my_chan_name
001033  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001034  aa  6 00545 1151 00	cmpa 	pr6|357		fnp_info.fnp_tag
001035  aa   777754 6010 04	tnz  	-20,ic		001011
						STATEMENT 1 ON LINE 385
	if ^tty_buf.fnp_config_flags (dno)
	then go to bad_channel;

001036  aa  6 00103 7271 00	lxl7 	pr6|67		dno
001037  aa  6 00300 3715 20	epp5 	pr6|192,*		ttybp
001040  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
001041  aa  5 00004 70 0001	descb	pr5|4(35),1	tty_buf.fnp_config_flags
001042  aa   000000 00 0000	descb	0,0
001043  aa   777746 6000 04	tze  	-26,ic		001011
						STATEMENT 1 ON LINE 388
	call lock$lock_fast (addr (datanet_info.configuration_lock));

001044  aa  6 00312 3535 20	epp3 	pr6|202,*		datanet_info.configuration_lock
001045  aa  6 00560 2535 00	spri3	pr6|368
001046  aa  6 00560 3521 00	epp2 	pr6|368
001047  aa  6 00550 2521 00	spri2	pr6|360
001050  aa  6 00546 6211 00	eax1 	pr6|358
001051  aa   004000 4310 07	fld  	2048,dl
001052  aa  6 00044 3701 20	epp4 	pr6|36,*
001053  la  4 00036 3521 20	epp2 	pr4|30,*		lock$lock_fast
001054  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 390
	fnp_info.lcte_ptr = addr (lct.lcte_array (devx));

001055  aa  6 00101 2361 00	ldq  	pr6|65		devx
001056  aa   000005 7360 00	qls  	5
001057  aa  6 00304 3735 20	epp7 	pr6|196,*		lctp
001060  aa  7 77760 3735 06	epp7 	pr7|-16,ql	lct.lcte_array
001061  aa  6 00314 3715 20	epp5 	pr6|204,*		fnpp
001062  aa  5 00032 6535 00	spri7	pr5|26		fnp_info.lcte_ptr
						STATEMENT 1 ON LINE 392
	if fnp_info.t_and_d_in_progress		/* lcte will be invalid, but still */
	then do;

001063  aa  5 00030 2351 00	lda  	pr5|24		fnp_info.t_and_d_in_progress
001064  aa   001000 3150 03	cana 	512,du
001065  aa   000005 6000 04	tze  	5,ic		001072
						STATEMENT 1 ON LINE 394
	     code = error_table_$io_not_available;

001066  aa  6 00044 3701 20	epp4 	pr6|36,*
001067  la  4 00120 2361 20	ldq  	pr4|80,*		error_table_$io_not_available
001070  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 395
	     go to init_abort;

001071  aa   000407 7100 04	tra  	263,ic		001500
						STATEMENT 1 ON LINE 396
	end;

						STATEMENT 1 ON LINE 398
	call assign_channel (code);

001072  aa   007700 3520 04	epp2 	4032,ic		010772 = 000002000000
001073  aa   007205 6700 04	tsp4 	3717,ic		010300
						STATEMENT 1 ON LINE 399
	if code ^= 0
	then go to init_abort;

001074  aa  6 00100 2361 00	ldq  	pr6|64		code
001075  aa   000403 6010 04	tnz  	259,ic		001500
						STATEMENT 1 ON LINE 402
	call fnp_util$fill_page_table ((fnp_info.fnp_number), code);

001076  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001077  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
001100  aa   000011 7350 00	als  	9
001101  aa   000077 7730 00	lrl  	63
001102  aa  6 00545 7561 00	stq  	pr6|357
001103  aa  6 00545 3521 00	epp2 	pr6|357
001104  aa  6 00550 2521 00	spri2	pr6|360
001105  aa  6 00100 3521 00	epp2 	pr6|64		code
001106  aa  6 00552 2521 00	spri2	pr6|362
001107  aa  6 00546 6211 00	eax1 	pr6|358
001110  aa   010000 4310 07	fld  	4096,dl
001111  aa  6 00044 3701 20	epp4 	pr6|36,*
001112  la  4 00022 3521 20	epp2 	pr4|18,*		fnp_util$fill_page_table
001113  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 403
	if code ^= 0
	then go to init_abort;

001114  aa  6 00100 2361 00	ldq  	pr6|64		code
001115  aa   000363 6010 04	tnz  	243,ic		001500
						STATEMENT 1 ON LINE 406
	do i = 0 to 2;

001116  aa  6 00114 4501 00	stz  	pr6|76		i
001117  aa   000000 0110 03	nop  	0,du
001120  aa  6 00114 2361 00	ldq  	pr6|76		i
001121  aa   000002 1160 07	cmpq 	2,dl
001122  aa   000010 6054 04	tpnz 	8,ic		001132
						STATEMENT 1 ON LINE 407
	     fnp_info.hsla_idx (i) = -1;

001123  aa   000001 3360 07	lcq  	1,dl
001124  aa  6 00114 7271 00	lxl7 	pr6|76		i
001125  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001126  aa  7 00021 7561 17	stq  	pr7|17,7		fnp_info.hsla_idx
						STATEMENT 1 ON LINE 408
	     fnp_info.lsla_idx (i) = -1;

001127  aa  7 00013 7561 17	stq  	pr7|11,7		fnp_info.lsla_idx
						STATEMENT 1 ON LINE 409
	end;

001130  aa  6 00114 0541 00	aos  	pr6|76		i
001131  aa   777767 7100 04	tra  	-9,ic		001120
						STATEMENT 1 ON LINE 410
	do i = 3 to 5;

001132  aa   000003 2360 07	ldq  	3,dl
001133  aa  6 00114 7561 00	stq  	pr6|76		i
001134  aa  6 00114 2361 00	ldq  	pr6|76		i
001135  aa   000005 1160 07	cmpq 	5,dl
001136  aa   000007 6054 04	tpnz 	7,ic		001145
						STATEMENT 1 ON LINE 411
	     fnp_info.lsla_idx (i) = -1;

001137  aa   000001 3360 07	lcq  	1,dl
001140  aa  6 00114 7271 00	lxl7 	pr6|76		i
001141  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001142  aa  7 00013 7561 17	stq  	pr7|11,7		fnp_info.lsla_idx
						STATEMENT 1 ON LINE 412
	end;

001143  aa  6 00114 0541 00	aos  	pr6|76		i
001144  aa   777770 7100 04	tra  	-8,ic		001134
						STATEMENT 1 ON LINE 414
	pcb_space = size (pcb) * mii_chan_count;

001145  aa   000010 2360 07	ldq  	8,dl
001146  aa  6 00324 4021 00	mpy  	pr6|212		mii_chan_count
001147  aa  6 00104 7561 00	stq  	pr6|68		pcb_space
						STATEMENT 1 ON LINE 415
	space_needed = pcb_space + 8 * DCW_LIST_SIZE;

001150  aa   000200 2360 07	ldq  	128,dl
001151  aa  6 00104 0761 00	adq  	pr6|68		pcb_space
001152  aa  6 00105 7561 00	stq  	pr6|69		space_needed
						STATEMENT 1 ON LINE 416
	call tty_space_man$get_space (space_needed, pcb_space_ptr);

001153  aa  6 00105 3521 00	epp2 	pr6|69		space_needed
001154  aa  6 00550 2521 00	spri2	pr6|360
001155  aa  6 00224 3521 00	epp2 	pr6|148		pcb_space_ptr
001156  aa  6 00552 2521 00	spri2	pr6|362
001157  aa  6 00546 6211 00	eax1 	pr6|358
001160  aa   010000 4310 07	fld  	4096,dl
001161  aa  6 00044 3701 20	epp4 	pr6|36,*
001162  la  4 00134 3521 20	epp2 	pr4|92,*		tty_space_man$get_space
001163  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 417
	if pcb_space_ptr = null			/* this would be unfortunate */
	then do;

001164  aa  6 00224 2371 00	ldaq 	pr6|148		pcb_space_ptr
001165  aa   777041 6770 04	eraq 	-479,ic		000226 = 077777000043 000001000000
001166  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001167  aa   000005 6010 04	tnz  	5,ic		001174
						STATEMENT 1 ON LINE 419
	     a_code = error_table_$noalloc;

001170  aa  6 00044 3701 20	epp4 	pr6|36,*
001171  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$noalloc
001172  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 420
	     go to init_abort;

001173  aa   000305 7100 04	tra  	197,ic		001500
						STATEMENT 1 ON LINE 421
	end;

						STATEMENT 1 ON LINE 422
	n_pcbs, fnp_info.no_of_channels = mii_chan_count;

001174  aa  6 00324 2361 00	ldq  	pr6|212		mii_chan_count
001175  aa  6 00316 7561 00	stq  	pr6|206		n_pcbs
001176  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001177  aa  7 00006 7561 00	stq  	pr7|6		fnp_info.no_of_channels
						STATEMENT 1 ON LINE 423
	pcb_space_ptr -> pcb_array (*).saved_meters_ptr = null ();

001200  aa   000001 2360 07	ldq  	1,dl
001201  aa  6 00352 7561 00	stq  	pr6|234
001202  aa  6 00352 2361 00	ldq  	pr6|234
001203  aa   000003 7360 00	qls  	3
001204  aa   000000 6270 06	eax7 	0,ql
001205  aa   007563 2360 04	ldq  	3955,ic		010770 = 007777000001
001206  aa  6 00224 3735 20	epp7 	pr6|148,*		pcb_space_ptr
001207  aa  7 77776 7561 17	stq  	pr7|-2,7		pcb_array.saved_meters_ptr
001210  aa  6 00352 2361 00	ldq  	pr6|234
001211  aa  6 00352 0541 00	aos  	pr6|234
001212  aa  6 00316 1161 00	cmpq 	pr6|206		n_pcbs
001213  aa   777767 6040 04	tmi  	-9,ic		001202
						STATEMENT 1 ON LINE 425
	fnp_info.pcb_array_ptr = pcb_space_ptr;

001214  aa  6 00314 3715 20	epp5 	pr6|204,*		fnpp
001215  aa  5 00002 6535 00	spri7	pr5|2		fnp_info.pcb_array_ptr
						STATEMENT 1 ON LINE 426
	fnp_info.dcw_list_array_ptr = addrel (pcb_space_ptr, pcb_space);

001216  aa  6 00104 2361 00	ldq  	pr6|68		pcb_space
001217  aa  7 00000 3521 06	epp2 	pr7|0,ql
001220  aa   000000 0520 03	adwp2	0,du
001221  aa  5 00004 2521 00	spri2	pr5|4		fnp_info.dcw_list_array_ptr
						STATEMENT 1 ON LINE 427
	string (fnp_info.flags) = "0"b;

001222  aa  5 00030 4501 00	stz  	pr5|24
						STATEMENT 1 ON LINE 428
	prev_la_no = -1;

001223  aa   000001 3360 07	lcq  	1,dl
001224  aa  6 00226 7561 00	stq  	pr6|150		prev_la_no
						STATEMENT 1 ON LINE 429
	old_flag = "1"b;

001225  aa   400000 2350 03	lda  	131072,du
001226  aa  6 00222 7551 00	sta  	pr6|146		old_flag
						STATEMENT 1 ON LINE 436
	do pcbx = 1 to n_pcbs;

001227  aa  6 00316 2361 00	ldq  	pr6|206		n_pcbs
001230  aa  6 00353 7561 00	stq  	pr6|235
001231  aa   000001 2360 07	ldq  	1,dl
001232  aa  6 00232 7561 00	stq  	pr6|154		pcbx
001233  aa   000000 0110 03	nop  	0,du
001234  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001235  aa  6 00353 1161 00	cmpq 	pr6|235
001236  aa   000225 6054 04	tpnz 	149,ic		001463
						STATEMENT 1 ON LINE 437
	     pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));

001237  aa   000003 7360 00	qls  	3
001240  aa  6 00224 3735 20	epp7 	pr6|148,*		pcb_space_ptr
001241  aa  7 77770 3735 06	epp7 	pr7|-8,ql		pcb_array
001242  aa  6 00320 6535 00	spri7	pr6|208		pcbp
						STATEMENT 1 ON LINE 438
	     unspec (pcb) = "0"b;

001243  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001244  aa   000000 00 0000	desc9a	0,0
001245  aa  7 00000 00 0040	desc9a	pr7|0,32
						STATEMENT 1 ON LINE 439
	     pcb.saved_meters_ptr = null ();

001246  aa   007522 2360 04	ldq  	3922,ic		010770 = 007777000001
001247  aa  7 00006 7561 00	stq  	pr7|6		pcb.saved_meters_ptr
						STATEMENT 1 ON LINE 440
	     pcb.devx = mux_init_info.channels (pcbx).devx;

001250  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001251  aa   000011 4020 07	mpy  	9,dl
001252  aa   000000 6270 06	eax7 	0,ql
001253  aa  6 00322 2361 66	ldq  	pr6|210,*ql	mux_init_info.devx
001254  aa   000066 7370 00	lls  	54
001255  aa  7 00000 5511 60	stba 	pr7|0,60		pcb.devx
						STATEMENT 1 ON LINE 441
	     lctep = addr (lct.lcte_array (pcb.devx));

001256  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001257  aa   000066 7330 00	lrs  	54
001260  aa   000005 7360 00	qls  	5
001261  aa  6 00304 3715 20	epp5 	pr6|196,*		lctp
001262  aa  5 77760 3715 06	epp5 	pr5|-16,ql	lct.lcte_array
001263  aa  6 00306 6515 00	spri5	pr6|198		lctep
						STATEMENT 1 ON LINE 442
	     lcte.subchannel = pcbx;

001264  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001265  aa  5 00003 5521 14	stbq 	pr5|3,14		lcte.subchannel
						STATEMENT 1 ON LINE 443
	     name = mux_init_info.channels (pcbx).name;

001266  aa  6 00322 3535 20	epp3 	pr6|210,*		miip
001267  aa  3 77770 3535 17	epp3 	pr3|-8,7		mux_init_info.name
001270  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001271  aa  3 00000 00 0040	desc9a	pr3|0,32		mux_init_info.name
001272  aa  6 00237 00 0040	desc9a	pr6|159,32	name
						STATEMENT 1 ON LINE 444
	     call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);

001273  aa  6 00237 3521 00	epp2 	pr6|159		name
001274  aa  6 00564 2521 00	spri2	pr6|372
001275  aa  6 00231 3521 00	epp2 	pr6|153		his_fnp_no
001276  aa  6 00566 2521 00	spri2	pr6|374
001277  aa  6 00221 3521 00	epp2 	pr6|145		hsla_flag
001300  aa  6 00570 2521 00	spri2	pr6|376
001301  aa  6 00227 3521 00	epp2 	pr6|151		la_no
001302  aa  6 00572 2521 00	spri2	pr6|378
001303  aa  6 00230 3521 00	epp2 	pr6|152		subchan
001304  aa  6 00574 2521 00	spri2	pr6|380
001305  aa   776643 3520 04	epp2 	-605,ic		000150 = 526000000040
001306  aa  6 00576 2521 00	spri2	pr6|382
001307  aa   776661 3520 04	epp2 	-591,ic		000170 = 404000000021
001310  aa  6 00600 2521 00	spri2	pr6|384
001311  aa  6 00604 2521 00	spri2	pr6|388
001312  aa  6 00606 2521 00	spri2	pr6|390
001313  aa   776634 3520 04	epp2 	-612,ic		000147 = 516000000001
001314  aa  6 00602 2521 00	spri2	pr6|386
001315  aa  6 00562 6211 00	eax1 	pr6|370
001316  aa   024000 4310 07	fld  	10240,dl
001317  aa  6 00044 3701 20	epp4 	pr6|36,*
001320  la  4 00046 3521 20	epp2 	pr4|38,*		parse_tty_name_
001321  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 445
	     if his_fnp_no ^= dno
	     then do;

001322  aa  6 00231 2361 00	ldq  	pr6|153		his_fnp_no
001323  aa  6 00103 1161 00	cmpq 	pr6|67		dno
001324  aa   000005 6000 04	tze  	5,ic		001331
						STATEMENT 1 ON LINE 447
		code = error_table_$bad_channel;

001325  aa  6 00044 3701 20	epp4 	pr6|36,*
001326  la  4 00066 2361 20	ldq  	pr4|54,*		error_table_$bad_channel
001327  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 448
		go to init_abort;

001330  aa   000150 7100 04	tra  	104,ic		001500
						STATEMENT 1 ON LINE 449
	     end;

						STATEMENT 1 ON LINE 450
	     if la_no = 7
	     then fnp_info.tandd_pcbx = pcbx;

001331  aa  6 00227 2361 00	ldq  	pr6|151		la_no
001332  aa   000007 1160 07	cmpq 	7,dl
001333  aa   000005 6010 04	tnz  	5,ic		001340
001334  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001335  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001336  aa  7 00064 7561 00	stq  	pr7|52		fnp_info.tandd_pcbx
001337  aa   000027 7100 04	tra  	23,ic		001366
						STATEMENT 1 ON LINE 452
	     else if (la_no ^= prev_la_no | hsla_flag ^= old_flag)
						/* first subchannel on this adapter */
	     then do;

001340  aa  6 00226 1161 00	cmpq 	pr6|150		prev_la_no
001341  aa   000005 6010 04	tnz  	5,ic		001346
001342  aa  6 00221 2351 00	lda  	pr6|145		hsla_flag
001343  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001344  aa  6 00222 1151 00	cmpa 	pr6|146		old_flag
001345  aa   000021 6000 04	tze  	17,ic		001366
						STATEMENT 1 ON LINE 455
		if hsla_flag
		then fnp_info.hsla_idx (la_no) = pcbx;

001346  aa  6 00221 2351 00	lda  	pr6|145		hsla_flag
001347  aa   400000 3150 03	cana 	131072,du
001350  aa   000006 6000 04	tze  	6,ic		001356
001351  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001352  aa  6 00227 7271 00	lxl7 	pr6|151		la_no
001353  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001354  aa  7 00021 7561 17	stq  	pr7|17,7		fnp_info.hsla_idx
001355  aa   000005 7100 04	tra  	5,ic		001362
						STATEMENT 1 ON LINE 457
		else fnp_info.lsla_idx (la_no) = pcbx;

001356  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001357  aa  6 00227 7271 00	lxl7 	pr6|151		la_no
001360  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001361  aa  7 00013 7561 17	stq  	pr7|11,7		fnp_info.lsla_idx
						STATEMENT 1 ON LINE 458
		prev_la_no = la_no;

001362  aa  6 00227 2361 00	ldq  	pr6|151		la_no
001363  aa  6 00226 7561 00	stq  	pr6|150		prev_la_no
						STATEMENT 1 ON LINE 459
		old_flag = hsla_flag;

001364  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001365  aa  6 00222 7551 00	sta  	pr6|146		old_flag
						STATEMENT 1 ON LINE 460
	     end;

						STATEMENT 1 ON LINE 462
	     pcb.subchan = subchan;

001366  aa  6 00230 2361 00	ldq  	pr6|152		subchan
001367  aa   000056 7370 00	lls  	46
001370  aa  6 00320 6751 20	era  	pr6|208,*		pcb.subchan
001371  aa   776000 3750 07	ana  	261120,dl
001372  aa  6 00320 6551 20	ersa 	pr6|208,*		pcb.subchan
						STATEMENT 1 ON LINE 463
	     pcb.is_hsla = hsla_flag;

001373  aa  6 00221 2351 00	lda  	pr6|145		hsla_flag
001374  aa   000032 7710 00	arl  	26
001375  aa  6 00320 6751 20	era  	pr6|208,*		pcb.is_hsla
001376  aa   001000 3750 07	ana  	512,dl
001377  aa  6 00320 6551 20	ersa 	pr6|208,*		pcb.is_hsla
						STATEMENT 1 ON LINE 464
	     pcb.la_no = bit (bin (la_no, 3), 3);

001400  aa  6 00227 2351 00	lda  	pr6|151		la_no
001401  aa   000002 6050 04	tpl  	2,ic		001403
001402  aa   000000 5310 00	neg  	0
001403  aa   000041 7350 00	als  	33
001404  aa   000033 7710 00	arl  	27
001405  aa  6 00320 6751 20	era  	pr6|208,*		pcb.la_no
001406  aa   000700 3750 07	ana  	448,dl
001407  aa  6 00320 6551 20	ersa 	pr6|208,*		pcb.la_no
						STATEMENT 1 ON LINE 465
	     if hsla_flag
	     then pcb.slot_no = bit (bin (subchan, 6), 6);

001410  aa  6 00221 2351 00	lda  	pr6|145		hsla_flag
001411  aa   400000 3150 03	cana 	131072,du
001412  aa   000007 6000 04	tze  	7,ic		001421
001413  aa  6 00230 2351 00	lda  	pr6|152		subchan
001414  aa   000002 6050 04	tpl  	2,ic		001416
001415  aa   000000 5310 00	neg  	0
001416  aa  0 00314 3771 00	anaq 	pr0|204		= 000000000077 777777777777
001417  aa  6 00320 3735 20	epp7 	pr6|208,*		pcb.slot_no
001420  aa  7 00000 7511 01	stca 	pr7|0,01		pcb.slot_no
						STATEMENT 1 ON LINE 471
	     on area
		begin;

001421  aa   000004 7260 07	lxl6 	4,dl
001422  aa   776536 3520 04	epp2 	-674,ic		000160 = 141162145141
001423  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001424  aa   000004 7100 04	tra  	4,ic		001430
001425  aa     000272000000
001426  aa   000015 7100 04	tra  	13,ic		001443
BEGIN CONDITION area.1
ENTRY TO area.1                                             STATEMENT 1 ON LINE 471
	     on area
		begin;

001427  da     000576200000
001430  aa   000100 6270 00	eax7 	64
001431  aa  7 00034 3521 20	epp2 	pr7|28,*
001432  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001433  aa     000000000000
001434  aa     000000000000
						STATEMENT 1 ON LINE 473
		code = error_table_$noalloc;

001435  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$noalloc
001436  aa  6 00040 3735 20	epp7 	pr6|32,*
001437  aa  7 00100 7561 00	stq  	pr7|64		code
						STATEMENT 1 ON LINE 474
		go to init_abort;

001440  aa   000040 3520 04	epp2 	32,ic		001500 = 040100100404
001441  aa   000001 7270 07	lxl7 	1,dl
001442  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 475
	     end;

  END CONDITION area.1
						STATEMENT 1 ON LINE 477
	     call tty_area_manager$allocate (size (fnp_channel_meters), temp_saved_meters_ptr);

001443  aa   000032 2360 07	ldq  	26,dl
001444  aa  6 00545 7561 00	stq  	pr6|357
001445  aa  6 00545 3521 00	epp2 	pr6|357
001446  aa  6 00550 2521 00	spri2	pr6|360
001447  aa  6 00162 3521 00	epp2 	pr6|114		temp_saved_meters_ptr
001450  aa  6 00552 2521 00	spri2	pr6|362
001451  aa  6 00546 6211 00	eax1 	pr6|358
001452  aa   010000 4310 07	fld  	4096,dl
001453  aa  6 00044 3701 20	epp4 	pr6|36,*
001454  la  4 00032 3521 20	epp2 	pr4|26,*		tty_area_manager$allocate
001455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 478
	     pcb.saved_meters_ptr = temp_saved_meters_ptr;

001456  aa  6 00162 3735 20	epp7 	pr6|114,*		temp_saved_meters_ptr
001457  aa  6 00320 3715 20	epp5 	pr6|208,*		pcbp
001460  aa  5 00006 5471 00	sprp7	pr5|6		pcb.saved_meters_ptr
						STATEMENT 1 ON LINE 479
	end;

001461  aa  6 00232 0541 00	aos  	pr6|154		pcbx
001462  aa   777552 7100 04	tra  	-150,ic		001234
						STATEMENT 1 ON LINE 481
	call lock$unlock_fast (addr (datanet_info.configuration_lock));

001463  aa  6 00312 3735 20	epp7 	pr6|202,*		datanet_info.configuration_lock
001464  aa  6 00560 6535 00	spri7	pr6|368
001465  aa  6 00560 3521 00	epp2 	pr6|368
001466  aa  6 00550 2521 00	spri2	pr6|360
001467  aa  6 00546 6211 00	eax1 	pr6|358
001470  aa   004000 4310 07	fld  	2048,dl
001471  aa  6 00044 3701 20	epp4 	pr6|36,*
001472  la  4 00040 3521 20	epp2 	pr4|32,*		lock$unlock_fast
001473  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 483
	a_fnpp = fnpp;

001474  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001475  aa  6 00340 6535 20	spri7	pr6|224,*		a_fnpp
						STATEMENT 1 ON LINE 484
	a_code = 0;

001476  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 485
init_exit:
	return;

001477  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 488
init_abort:
	call TRACE_ERROR ("init_multiplexer", code);

001500  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001501  aa   776621 00 0020	desc9a	-623,16		000321 = 151156151164
001502  aa  6 00546 00 0040	desc9a	pr6|358,32
001503  aa   007257 3520 04	epp2 	3759,ic		010762 = 000004000000
001504  aa   007115 6700 04	tsp4 	3661,ic		010621
						STATEMENT 1 ON LINE 490
	call lock$unlock_fast (addr (datanet_info.configuration_lock));

001505  aa  6 00312 3735 20	epp7 	pr6|202,*		datanet_info.configuration_lock
001506  aa  6 00560 6535 00	spri7	pr6|368
001507  aa  6 00560 3521 00	epp2 	pr6|368
001510  aa  6 00550 2521 00	spri2	pr6|360
001511  aa  6 00546 6211 00	eax1 	pr6|358
001512  aa   004000 4310 07	fld  	2048,dl
001513  aa  6 00044 3701 20	epp4 	pr6|36,*
001514  la  4 00040 3521 20	epp2 	pr4|32,*		lock$unlock_fast
001515  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 491
	if pcb_space_ptr ^= null
	then do;

001516  aa  6 00224 2371 00	ldaq 	pr6|148		pcb_space_ptr
001517  aa   776507 6770 04	eraq 	-697,ic		000226 = 077777000043 000001000000
001520  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001521  aa   000047 6000 04	tze  	39,ic		001570
						STATEMENT 1 ON LINE 493
	     do pcbx = 1 to n_pcbs;

001522  aa  6 00316 2361 00	ldq  	pr6|206		n_pcbs
001523  aa  6 00354 7561 00	stq  	pr6|236
001524  aa   000001 2360 07	ldq  	1,dl
001525  aa  6 00232 7561 00	stq  	pr6|154		pcbx
001526  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
001527  aa  6 00354 1161 00	cmpq 	pr6|236
001530  aa   000027 6054 04	tpnz 	23,ic		001557
						STATEMENT 1 ON LINE 494
		pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));

001531  aa   000003 7360 00	qls  	3
001532  aa  6 00224 3735 20	epp7 	pr6|148,*		pcb_space_ptr
001533  aa  7 77770 3735 06	epp7 	pr7|-8,ql		pcb_array
001534  aa  6 00320 6535 00	spri7	pr6|208		pcbp
						STATEMENT 1 ON LINE 495
		if pcb.saved_meters_ptr ^= null ()
		then call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));

001535  aa  7 00006 2361 00	ldq  	pr7|6		pcb.saved_meters_ptr
001536  aa   007232 1160 04	cmpq 	3738,ic		010770 = 007777000001
001537  aa   000016 6000 04	tze  	14,ic		001555
001540  aa   000032 2360 07	ldq  	26,dl
001541  aa  6 00545 7561 00	stq  	pr6|357
001542  aa  7 00006 7651 00	lprp5	pr7|6		pcb.saved_meters_ptr
001543  aa  6 00560 6515 00	spri5	pr6|368
001544  aa  6 00545 3521 00	epp2 	pr6|357
001545  aa  6 00550 2521 00	spri2	pr6|360
001546  aa  6 00560 3521 00	epp2 	pr6|368
001547  aa  6 00552 2521 00	spri2	pr6|362
001550  aa  6 00546 6211 00	eax1 	pr6|358
001551  aa   010000 4310 07	fld  	4096,dl
001552  aa  6 00044 3701 20	epp4 	pr6|36,*
001553  la  4 00034 3521 20	epp2 	pr4|28,*		tty_area_manager$free
001554  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 497
	     end;

001555  aa  6 00232 0541 00	aos  	pr6|154		pcbx
001556  aa   777750 7100 04	tra  	-24,ic		001526
						STATEMENT 1 ON LINE 498
	     call tty_space_man$free_space (space_needed, pcb_space_ptr);

001557  aa  6 00105 3521 00	epp2 	pr6|69		space_needed
001560  aa  6 00550 2521 00	spri2	pr6|360
001561  aa  6 00224 3521 00	epp2 	pr6|148		pcb_space_ptr
001562  aa  6 00552 2521 00	spri2	pr6|362
001563  aa  6 00546 6211 00	eax1 	pr6|358
001564  aa   010000 4310 07	fld  	4096,dl
001565  aa  6 00044 3701 20	epp4 	pr6|36,*
001566  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
001567  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 499
	end;

						STATEMENT 1 ON LINE 500
	a_code = code;

001570  aa  6 00100 2361 00	ldq  	pr6|64		code
001571  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 501
	return;

001572  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO terminate_multiplexer                              STATEMENT 1 ON LINE 503
terminate_multiplexer:
     entry (a_fnpp, a_code);

001573  at     000002000166
001574  ta     000162000000
001575  ta     001573000000
001576  da     000607300000
001577  aa   001420 6270 00	eax7 	784
001600  aa  7 00034 3521 20	epp2 	pr7|28,*
001601  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001602  aa     000004000000
001603  aa     000000000000
001604  aa  6 00032 3735 20	epp7 	pr6|26,*
001605  aa  7 00002 3715 20	epp5 	pr7|2,*
001606  aa  6 00340 6515 00	spri5	pr6|224
001607  aa  7 00004 3535 20	epp3 	pr7|4,*
001610  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 508
	fnpp = a_fnpp;

001611  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
001612  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
001613  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 509
	ttybp = addr (tty_buf$);

001614  aa  6 00044 3701 20	epp4 	pr6|36,*
001615  la  4 00130 3715 20	epp5 	pr4|88,*		tty_buf$
001616  aa  6 00300 6515 00	spri5	pr6|192		ttybp
						STATEMENT 1 ON LINE 510
	infop = addr (dn355_data$);

001617  la  4 00132 3535 20	epp3 	pr4|90,*		dn355_data$
001620  aa  6 00312 2535 00	spri3	pr6|202		infop
						STATEMENT 1 ON LINE 511
	locked = "0"b;

001621  aa  6 00133 4501 00	stz  	pr6|91		locked
						STATEMENT 1 ON LINE 512
	call TRACE ("terminate_multiplexer");

001622  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001623  aa   776574 00 0025	desc9a	-644,21		000416 = 164145162155
001624  aa  6 00546 00 0040	desc9a	pr6|358,32
001625  aa   007151 3520 04	epp2 	3689,ic		010776 = 000002000000
001626  aa   006740 6700 04	tsp4 	3552,ic		010566
						STATEMENT 1 ON LINE 513
	call lock;

001627  aa   006263 6700 04	tsp4 	3251,ic		010112
						STATEMENT 1 ON LINE 514
	if code ^= 0
	then go to terminate_return;

001630  aa  6 00100 2361 00	ldq  	pr6|64		code
001631  aa   000220 6010 04	tnz  	144,ic		002051
						STATEMENT 1 ON LINE 517
	if fnp_info.bootloading | fnp_info.wired | fnp_info.running
						/* bad time to terminate */
	then code = error_table_$invalid_state;

001632  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001633  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
001634  aa   340000 3150 03	cana 	114688,du
001635  aa   000005 6000 04	tze  	5,ic		001642
001636  aa  6 00044 3701 20	epp4 	pr6|36,*
001637  la  4 00122 2361 20	ldq  	pr4|82,*		error_table_$invalid_state
001640  aa  6 00100 7561 00	stq  	pr6|64		code
001641  aa   000163 7100 04	tra  	115,ic		002024
						STATEMENT 1 ON LINE 521
	else do;

						STATEMENT 1 ON LINE 522
	     do i = 1 to fnp_info.no_of_channels;

001642  aa  7 00006 2361 00	ldq  	pr7|6		fnp_info.no_of_channels
001643  aa  6 00355 7561 00	stq  	pr6|237
001644  aa   000001 2360 07	ldq  	1,dl
001645  aa  6 00114 7561 00	stq  	pr6|76		i
001646  aa  6 00114 2361 00	ldq  	pr6|76		i
001647  aa  6 00355 1161 00	cmpq 	pr6|237
001650  aa   000127 6054 04	tpnz 	87,ic		001777
						STATEMENT 1 ON LINE 523
		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));

001651  aa   000003 7360 00	qls  	3
001652  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
001653  aa  7 00002 3715 20	epp5 	pr7|2,*		fnp_info.pcb_array_ptr
001654  aa  5 77770 3735 06	epp7 	pr5|-8,ql		pcb_array
001655  aa  6 00320 6535 00	spri7	pr6|208		pcbp
						STATEMENT 1 ON LINE 524
		if pcb.write_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));

001656  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
001657  aa   000066 7330 00	lrs  	54
001660  aa   000024 6000 04	tze  	20,ic		001704
001661  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001662  aa  6 00610 7561 00	stq  	pr6|392		pcb.write_first
001663  aa   000066 7330 00	lrs  	54
001664  aa  6 00545 7561 00	stq  	pr6|357
001665  aa  6 00610 2361 00	ldq  	pr6|392		pcb.write_first
001666  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
001667  aa   000000 3120 06	eawp2	0,ql
001670  aa  6 00560 2521 00	spri2	pr6|368
001671  aa  6 00545 3521 00	epp2 	pr6|357
001672  aa  6 00550 2521 00	spri2	pr6|360
001673  aa   776256 3520 04	epp2 	-850,ic		000151 = 400000000000
001674  aa  6 00552 2521 00	spri2	pr6|362
001675  aa  6 00560 3521 00	epp2 	pr6|368
001676  aa  6 00554 2521 00	spri2	pr6|364
001677  aa  6 00546 6211 00	eax1 	pr6|358
001700  aa   014000 4310 07	fld  	6144,dl
001701  aa  6 00044 3701 20	epp4 	pr6|36,*
001702  la  4 00140 3521 20	epp2 	pr4|96,*		tty_space_man$free_chain
001703  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 526
		if pcb.read_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), INPUT, ptr (ttybp, pcb.read_first));

001704  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
001705  aa  7 00005 2351 00	lda  	pr7|5		pcb.read_first
001706  aa   000066 7730 00	lrl  	54
001707  aa   000024 6000 04	tze  	20,ic		001733
001710  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001711  aa  6 00610 7561 00	stq  	pr6|392		pcb.read_first
001712  aa   000066 7330 00	lrs  	54
001713  aa  6 00545 7561 00	stq  	pr6|357
001714  aa  6 00610 2361 00	ldq  	pr6|392		pcb.read_first
001715  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
001716  aa   000000 3120 06	eawp2	0,ql
001717  aa  6 00560 2521 00	spri2	pr6|368
001720  aa  6 00545 3521 00	epp2 	pr6|357
001721  aa  6 00550 2521 00	spri2	pr6|360
001722  aa   776230 3520 04	epp2 	-872,ic		000152 = 000000000000
001723  aa  6 00552 2521 00	spri2	pr6|362
001724  aa  6 00560 3521 00	epp2 	pr6|368
001725  aa  6 00554 2521 00	spri2	pr6|364
001726  aa  6 00546 6211 00	eax1 	pr6|358
001727  aa   014000 4310 07	fld  	6144,dl
001730  aa  6 00044 3701 20	epp4 	pr6|36,*
001731  la  4 00140 3521 20	epp2 	pr4|96,*		tty_space_man$free_chain
001732  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 528
		call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));

001733  aa   000032 2360 07	ldq  	26,dl
001734  aa  6 00545 7561 00	stq  	pr6|357
001735  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
001736  aa  7 00006 7671 00	lprp7	pr7|6		pcb.saved_meters_ptr
001737  aa  6 00560 6535 00	spri7	pr6|368
001740  aa  6 00545 3521 00	epp2 	pr6|357
001741  aa  6 00550 2521 00	spri2	pr6|360
001742  aa  6 00560 3521 00	epp2 	pr6|368
001743  aa  6 00552 2521 00	spri2	pr6|362
001744  aa  6 00546 6211 00	eax1 	pr6|358
001745  aa   010000 4310 07	fld  	4096,dl
001746  aa  6 00044 3701 20	epp4 	pr6|36,*
001747  la  4 00034 3521 20	epp2 	pr4|28,*		tty_area_manager$free
001750  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 529
		if pcb.copied_meters_offset ^= 0	/* free this if it's there */
		then do;

001751  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
001752  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
001753  aa   000022 6000 04	tze  	18,ic		001775
						STATEMENT 1 ON LINE 531
		     call tty_space_man$free_space (size (fnp_channel_meters), ptr (ttybp, pcb.copied_meters_offset));

001754  aa   000032 2360 07	ldq  	26,dl
001755  aa  6 00545 7561 00	stq  	pr6|357
001756  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
001757  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
001760  aa   000000 3120 06	eawp2	0,ql
001761  aa  6 00560 2521 00	spri2	pr6|368
001762  aa  6 00545 3521 00	epp2 	pr6|357
001763  aa  6 00550 2521 00	spri2	pr6|360
001764  aa  6 00560 3521 00	epp2 	pr6|368
001765  aa  6 00552 2521 00	spri2	pr6|362
001766  aa  6 00546 6211 00	eax1 	pr6|358
001767  aa   010000 4310 07	fld  	4096,dl
001770  aa  6 00044 3701 20	epp4 	pr6|36,*
001771  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
001772  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 532
		     pcb.copied_meters_offset = 0;

001773  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
001774  aa  7 00007 4501 00	stz  	pr7|7		pcb.copied_meters_offset
						STATEMENT 1 ON LINE 533
		end;

						STATEMENT 1 ON LINE 534
	     end;

001775  aa  6 00114 0541 00	aos  	pr6|76		i
001776  aa   777650 7100 04	tra  	-88,ic		001646
						STATEMENT 1 ON LINE 536
	     string (fnp_info.flags) = "0"b;

001777  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002000  aa  7 00030 4501 00	stz  	pr7|24
						STATEMENT 1 ON LINE 537
	     call tty_space_man$free_space (size (pcb) * fnp_info.no_of_channels + 8 * DCW_LIST_SIZE,
		fnp_info.pcb_array_ptr);

002001  aa   000200 2360 07	ldq  	128,dl
002002  aa  6 00610 7561 00	stq  	pr6|392
002003  aa   000010 2360 07	ldq  	8,dl
002004  aa  7 00006 4021 00	mpy  	pr7|6		fnp_info.no_of_channels
002005  aa  6 00610 0331 00	adl  	pr6|392
002006  aa  6 00545 7561 00	stq  	pr6|357
002007  aa  6 00545 3521 00	epp2 	pr6|357
002010  aa  6 00550 2521 00	spri2	pr6|360
002011  aa  7 00002 3521 00	epp2 	pr7|2		fnp_info.pcb_array_ptr
002012  aa  6 00552 2521 00	spri2	pr6|362
002013  aa  6 00546 6211 00	eax1 	pr6|358
002014  aa   010000 4310 07	fld  	4096,dl
002015  aa  6 00044 3701 20	epp4 	pr6|36,*
002016  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
002017  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 539
	     fnp_info.pcb_array_ptr = null;

002020  aa   776206 2370 04	ldaq 	-890,ic		000226 = 077777000043 000001000000
002021  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002022  aa  7 00002 7571 00	staq 	pr7|2		fnp_info.pcb_array_ptr
						STATEMENT 1 ON LINE 540
	     code = 0;

002023  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 541
	end;

						STATEMENT 1 ON LINE 543
	if fnp_info.io_manager_assigned
	then call unassign_channel (code);

002024  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
002025  aa   200000 3150 03	cana 	65536,du
002026  aa   000003 6000 04	tze  	3,ic		002031
002027  aa   006743 3520 04	epp2 	3555,ic		010772 = 000002000000
002030  aa   006417 6700 04	tsp4 	3343,ic		010447
						STATEMENT 1 ON LINE 545
	call fnp_util$free_page_table ((fnp_info.fnp_number), (0));

002031  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002032  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
002033  aa   000011 7350 00	als  	9
002034  aa   000077 7730 00	lrl  	63
002035  aa  6 00545 7561 00	stq  	pr6|357
002036  aa  6 00610 4501 00	stz  	pr6|392
002037  aa  6 00545 3521 00	epp2 	pr6|357
002040  aa  6 00550 2521 00	spri2	pr6|360
002041  aa  6 00610 3521 00	epp2 	pr6|392
002042  aa  6 00552 2521 00	spri2	pr6|362
002043  aa  6 00546 6211 00	eax1 	pr6|358
002044  aa   010000 4310 07	fld  	4096,dl
002045  aa  6 00044 3701 20	epp4 	pr6|36,*
002046  la  4 00024 3521 20	epp2 	pr4|20,*		fnp_util$free_page_table
002047  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 547
	call unlock;

002050  aa   006126 6700 04	tsp4 	3158,ic		010176
						STATEMENT 1 ON LINE 549
terminate_return:
	if code ^= 0
	then call TRACE_ERROR ("terminate_multiplexer", code);

002051  aa  6 00100 2361 00	ldq  	pr6|64		code
002052  aa   000006 6000 04	tze  	6,ic		002060
002053  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002054  aa   776343 00 0025	desc9a	-797,21		000416 = 164145162155
002055  aa  6 00546 00 0040	desc9a	pr6|358,32
002056  aa   006704 3520 04	epp2 	3524,ic		010762 = 000004000000
002057  aa   006542 6700 04	tsp4 	3426,ic		010621
						STATEMENT 1 ON LINE 552
	a_code = code;

002060  aa  6 00100 2361 00	ldq  	pr6|64		code
002061  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 553
	return;

002062  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO start                                              STATEMENT 1 ON LINE 555
start:
     entry (a_fnpp, a_code);

002063  ta     001573000000
002064  da     000614300000
002065  aa   001420 6270 00	eax7 	784
002066  aa  7 00034 3521 20	epp2 	pr7|28,*
002067  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002070  aa     000004000000
002071  aa     000000000000
002072  aa  6 00032 3735 20	epp7 	pr6|26,*
002073  aa  7 00002 3715 20	epp5 	pr7|2,*
002074  aa  6 00340 6515 00	spri5	pr6|224
002075  aa  7 00004 3535 20	epp3 	pr7|4,*
002076  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 560
	fnpp = a_fnpp;

002077  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
002100  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002101  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 561
	infop = addr (dn355_data$);

002102  aa  6 00044 3701 20	epp4 	pr6|36,*
002103  la  4 00132 3715 20	epp5 	pr4|90,*		dn355_data$
002104  aa  6 00312 6515 00	spri5	pr6|202		infop
						STATEMENT 1 ON LINE 562
	call TRACE ("start");

002105  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002106  aa   776117 00 0005	desc9a	-945,5		000224 = 163164141162
002107  aa  6 00546 00 0040	desc9a	pr6|358,32
002110  aa   006666 3520 04	epp2 	3510,ic		010776 = 000002000000
002111  aa   006455 6700 04	tsp4 	3373,ic		010566
						STATEMENT 1 ON LINE 563
	chanx = 1;

002112  aa   000001 2360 07	ldq  	1,dl
002113  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 564
	call setup;

002114  aa   004165 6700 04	tsp4 	2165,ic		006301
						STATEMENT 1 ON LINE 565
	if code = 0
	then do;

002115  aa  6 00100 2361 00	ldq  	pr6|64		code
002116  aa   000045 6010 04	tnz  	37,ic		002163
						STATEMENT 1 ON LINE 567
	     call dn355$send_global_wcd (fnpp, accept_calls, 18,
		bit (bin (bin (rel (addr (tty_buf.free_space)), 18) + tty_buf.absorig, 18), 18));

002117  aa   000022 2360 07	ldq  	18,dl
002120  aa  6 00610 7561 00	stq  	pr6|392
002121  aa  6 00300 3735 20	epp7 	pr6|192,*		ttybp
002122  aa  7 00150 3735 00	epp7 	pr7|104		tty_buf.free_space
002123  aa  7 00000 6351 00	eaa  	pr7|0
002124  aa   000066 7730 00	lrl  	54
002125  aa  6 00300 3715 20	epp5 	pr6|192,*		ttybp
002126  aa  5 00001 0761 00	adq  	pr5|1		tty_buf.absorig
002127  aa   000003 6050 04	tpl  	3,ic		002132
002130  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
002131  aa   000001 0760 07	adq  	1,dl
002132  aa   000066 7370 00	lls  	54
002133  aa  6 00545 7551 00	sta  	pr6|357
002134  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
002135  aa  6 00564 2521 00	spri2	pr6|372
002136  aa   776025 3520 04	epp2 	-1003,ic		000163 = 000000000004
002137  aa  6 00566 2521 00	spri2	pr6|374
002140  aa  6 00610 3521 00	epp2 	pr6|392
002141  aa  6 00570 2521 00	spri2	pr6|376
002142  aa  6 00545 3521 00	epp2 	pr6|357
002143  aa  6 00572 2521 00	spri2	pr6|378
002144  aa   776022 3520 04	epp2 	-1006,ic		000166 = 464000000000
002145  aa  6 00574 2521 00	spri2	pr6|380
002146  aa   776000 3520 04	epp2 	-1024,ic		000146 = 404000000010
002147  aa  6 00576 2521 00	spri2	pr6|382
002150  aa   776020 3520 04	epp2 	-1008,ic		000170 = 404000000021
002151  aa  6 00600 2521 00	spri2	pr6|384
002152  aa   775773 3520 04	epp2 	-1029,ic		000145 = 514000000022
002153  aa  6 00602 2521 00	spri2	pr6|386
002154  aa  6 00562 6211 00	eax1 	pr6|370
002155  aa   020000 4310 07	fld  	8192,dl
002156  aa  6 00044 3701 20	epp4 	pr6|36,*
002157  la  4 00012 3521 20	epp2 	pr4|10,*		dn355$send_global_wcd
002160  aa  6 00560 6535 00	spri7	pr6|368
002161  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 569
	     call unlock;

002162  aa   006014 6700 04	tsp4 	3084,ic		010176
						STATEMENT 1 ON LINE 570
	end;

						STATEMENT 1 ON LINE 571
	if code ^= 0
	then call TRACE_ERROR ("start", code);

002163  aa  6 00100 2361 00	ldq  	pr6|64		code
002164  aa   000006 6000 04	tze  	6,ic		002172
002165  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002166  aa   776037 00 0005	desc9a	-993,5		000224 = 163164141162
002167  aa  6 00546 00 0040	desc9a	pr6|358,32
002170  aa   006572 3520 04	epp2 	3450,ic		010762 = 000004000000
002171  aa   006430 6700 04	tsp4 	3352,ic		010621
						STATEMENT 1 ON LINE 573
	a_code = code;

002172  aa  6 00100 2361 00	ldq  	pr6|64		code
002173  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 574
	return;

002174  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO stop                                               STATEMENT 1 ON LINE 577
stop:
     entry (a_fnpp, a_code);

002175  ta     001573000000
002176  da     000621300000
002177  aa   001420 6270 00	eax7 	784
002200  aa  7 00034 3521 20	epp2 	pr7|28,*
002201  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002202  aa     000004000000
002203  aa     000000000000
002204  aa  6 00032 3735 20	epp7 	pr6|26,*
002205  aa  7 00002 3715 20	epp5 	pr7|2,*
002206  aa  6 00340 6515 00	spri5	pr6|224
002207  aa  7 00004 3535 20	epp3 	pr7|4,*
002210  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 582
	fnpp = a_fnpp;

002211  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
002212  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002213  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 583
	infop = addr (dn355_data$);

002214  aa  6 00044 3701 20	epp4 	pr6|36,*
002215  la  4 00132 3715 20	epp5 	pr4|90,*		dn355_data$
002216  aa  6 00312 6515 00	spri5	pr6|202		infop
						STATEMENT 1 ON LINE 584
	call TRACE ("stop");

002217  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002220  aa   775725 00 0004	desc9a	-1067,4		000144 = 163164157160
002221  aa  6 00546 00 0040	desc9a	pr6|358,32
002222  aa   006554 3520 04	epp2 	3436,ic		010776 = 000002000000
002223  aa   006343 6700 04	tsp4 	3299,ic		010566
						STATEMENT 1 ON LINE 585
	chanx = 1;

002224  aa   000001 2360 07	ldq  	1,dl
002225  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 586
	call setup;

002226  aa   004053 6700 04	tsp4 	2091,ic		006301
						STATEMENT 1 ON LINE 587
	if code = 0
	then do;

002227  aa  6 00100 2361 00	ldq  	pr6|64		code
002230  aa   000030 6010 04	tnz  	24,ic		002260
						STATEMENT 1 ON LINE 589
	     call dn355$send_global_wcd (fnpp, dont_accept_calls, 0, ""b);

002231  aa  6 00545 4501 00	stz  	pr6|357
002232  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
002233  aa  6 00564 2521 00	spri2	pr6|372
002234  aa   775731 3520 04	epp2 	-1063,ic		000165 = 000000000003
002235  aa  6 00566 2521 00	spri2	pr6|374
002236  aa  6 00545 3521 00	epp2 	pr6|357
002237  aa  6 00570 2521 00	spri2	pr6|376
002240  aa  6 00610 3521 00	epp2 	pr6|392
002241  aa  6 00572 2521 00	spri2	pr6|378
002242  aa   775724 3520 04	epp2 	-1068,ic		000166 = 464000000000
002243  aa  6 00574 2521 00	spri2	pr6|380
002244  aa   775702 3520 04	epp2 	-1086,ic		000146 = 404000000010
002245  aa  6 00576 2521 00	spri2	pr6|382
002246  aa   775722 3520 04	epp2 	-1070,ic		000170 = 404000000021
002247  aa  6 00600 2521 00	spri2	pr6|384
002250  aa   775673 3520 04	epp2 	-1093,ic		000143 = 514000000000
002251  aa  6 00602 2521 00	spri2	pr6|386
002252  aa  6 00562 6211 00	eax1 	pr6|370
002253  aa   020000 4310 07	fld  	8192,dl
002254  aa  6 00044 3701 20	epp4 	pr6|36,*
002255  la  4 00012 3521 20	epp2 	pr4|10,*		dn355$send_global_wcd
002256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 590
	     call unlock;

002257  aa   005717 6700 04	tsp4 	3023,ic		010176
						STATEMENT 1 ON LINE 591
	end;

						STATEMENT 1 ON LINE 592
	if code ^= 0
	then call TRACE_ERROR ("stop", code);

002260  aa  6 00100 2361 00	ldq  	pr6|64		code
002261  aa   000006 6000 04	tze  	6,ic		002267
002262  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002263  aa   775662 00 0004	desc9a	-1102,4		000144 = 163164157160
002264  aa  6 00546 00 0040	desc9a	pr6|358,32
002265  aa   006475 3520 04	epp2 	3389,ic		010762 = 000004000000
002266  aa   006333 6700 04	tsp4 	3291,ic		010621
						STATEMENT 1 ON LINE 594
	a_code = code;

002267  aa  6 00100 2361 00	ldq  	pr6|64		code
002270  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 595
	return;

002271  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO shutdown                                           STATEMENT 1 ON LINE 598
shutdown:
     entry (a_fnpp, a_code);

002272  ta     001573000000
002273  da     000627300000
002274  aa   001420 6270 00	eax7 	784
002275  aa  7 00034 3521 20	epp2 	pr7|28,*
002276  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002277  aa     000004000000
002300  aa     000000000000
002301  aa  6 00032 3735 20	epp7 	pr6|26,*
002302  aa  7 00002 3715 20	epp5 	pr7|2,*
002303  aa  6 00340 6515 00	spri5	pr6|224
002304  aa  7 00004 3535 20	epp3 	pr7|4,*
002305  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 603
	infop = addr (dn355_data$);

002306  aa  6 00044 3701 20	epp4 	pr6|36,*
002307  la  4 00132 3735 20	epp7 	pr4|90,*		dn355_data$
002310  aa  6 00312 6535 00	spri7	pr6|202		infop
						STATEMENT 1 ON LINE 604
	fnpp = a_fnpp;

002311  aa  6 00340 3715 20	epp5 	pr6|224,*		a_fnpp
002312  aa  5 00000 3715 20	epp5 	pr5|0,*		a_fnpp
002313  aa  6 00314 6515 00	spri5	pr6|204		fnpp
						STATEMENT 1 ON LINE 605
	if fnpp = null ()
	then do;

002314  aa  6 00314 2371 00	ldaq 	pr6|204		fnpp
002315  aa   775711 6770 04	eraq 	-1079,ic		000226 = 077777000043 000001000000
002316  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002317  aa   000023 6010 04	tnz  	19,ic		002342
						STATEMENT 1 ON LINE 607
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with null fnp_ptr");

002320  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
002321  aa   000150 6000 04	tze  	104,ic		002471
002322  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002323  aa   776205 00 0064	desc9a	-891,52		000527 = 146156160137
002324  aa  6 00562 00 0064	desc9a	pr6|370,52
002325  aa   775625 3520 04	epp2 	-1131,ic		000152 = 000000000000
002326  aa  6 00550 2521 00	spri2	pr6|360
002327  aa  6 00562 3521 00	epp2 	pr6|370
002330  aa  6 00552 2521 00	spri2	pr6|362
002331  aa   775637 3520 04	epp2 	-1121,ic		000170 = 404000000021
002332  aa  6 00554 2521 00	spri2	pr6|364
002333  aa   775607 3520 04	epp2 	-1145,ic		000142 = 524000000062
002334  aa  6 00556 2521 00	spri2	pr6|366
002335  aa  6 00546 6211 00	eax1 	pr6|358
002336  aa   010000 4310 07	fld  	4096,dl
002337  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
002340  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 609
	     go to shutdown_return;

002341  aa   000130 7100 04	tra  	88,ic		002471
						STATEMENT 1 ON LINE 610
	end;

						STATEMENT 1 ON LINE 611
	call TRACE ("shutdown");

002342  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002343  aa   775660 00 0010	desc9a	-1104,8		000222 = 163150165164
002344  aa  6 00546 00 0040	desc9a	pr6|358,32
002345  aa   006431 3520 04	epp2 	3353,ic		010776 = 000002000000
002346  aa   006220 6700 04	tsp4 	3216,ic		010566
						STATEMENT 1 ON LINE 612
	infop = addr (dn355_data$);

002347  aa  6 00044 3701 20	epp4 	pr6|36,*
002350  la  4 00132 3735 20	epp7 	pr4|90,*		dn355_data$
002351  aa  6 00312 6535 00	spri7	pr6|202		infop
						STATEMENT 1 ON LINE 614
	if fnp_info.wired | fnp_info.bootloading	/* do the user ring a favor */
	then do;

002352  aa  6 00314 3715 20	epp5 	pr6|204,*		fnpp
002353  aa  5 00030 2351 00	lda  	pr5|24		fnp_info.bootloading
002354  aa   240000 3150 03	cana 	81920,du
002355  aa   000066 6000 04	tze  	54,ic		002443
						STATEMENT 1 ON LINE 616
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with FNP wired.");

002356  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
002357  aa   000020 6000 04	tze  	16,ic		002377
002360  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002361  aa   776133 00 0060	desc9a	-933,48		000513 = 146156160137
002362  aa  6 00562 00 0060	desc9a	pr6|370,48
002363  aa   775567 3520 04	epp2 	-1161,ic		000152 = 000000000000
002364  aa  6 00550 2521 00	spri2	pr6|360
002365  aa  6 00562 3521 00	epp2 	pr6|370
002366  aa  6 00552 2521 00	spri2	pr6|362
002367  aa   775601 3520 04	epp2 	-1151,ic		000170 = 404000000021
002370  aa  6 00554 2521 00	spri2	pr6|364
002371  aa   775550 3520 04	epp2 	-1176,ic		000141 = 524000000060
002372  aa  6 00556 2521 00	spri2	pr6|366
002373  aa  6 00546 6211 00	eax1 	pr6|358
002374  aa   010000 4310 07	fld  	4096,dl
002375  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
002376  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 618
	     call fnp_util$unwire ((fnp_info.fnp_number), code);

002377  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002400  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
002401  aa   000011 7350 00	als  	9
002402  aa   000077 7730 00	lrl  	63
002403  aa  6 00610 7561 00	stq  	pr6|392
002404  aa  6 00610 3521 00	epp2 	pr6|392
002405  aa  6 00550 2521 00	spri2	pr6|360
002406  aa  6 00100 3521 00	epp2 	pr6|64		code
002407  aa  6 00552 2521 00	spri2	pr6|362
002410  aa  6 00546 6211 00	eax1 	pr6|358
002411  aa   010000 4310 07	fld  	4096,dl
002412  aa  6 00044 3701 20	epp4 	pr6|36,*
002413  la  4 00026 3521 20	epp2 	pr4|22,*		fnp_util$unwire
002414  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 619
	     if code ^= 0
	     then call syserr$error_code (ANNOUNCE, code, "fnp_multiplexer$shutdown: Failed to unwire fnp.");

002415  aa  6 00100 2361 00	ldq  	pr6|64		code
002416  aa   000025 6000 04	tze  	21,ic		002443
002417  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002420  aa   776060 00 0060	desc9a	-976,48		000477 = 146156160137
002421  aa  6 00562 00 0060	desc9a	pr6|370,48
002422  aa   775530 3520 04	epp2 	-1192,ic		000152 = 000000000000
002423  aa  6 00614 2521 00	spri2	pr6|396
002424  aa  6 00100 3521 00	epp2 	pr6|64		code
002425  aa  6 00616 2521 00	spri2	pr6|398
002426  aa  6 00562 3521 00	epp2 	pr6|370
002427  aa  6 00620 2521 00	spri2	pr6|400
002430  aa   775540 3520 04	epp2 	-1184,ic		000170 = 404000000021
002431  aa  6 00622 2521 00	spri2	pr6|402
002432  aa   775530 3520 04	epp2 	-1192,ic		000162 = 404000000043
002433  aa  6 00624 2521 00	spri2	pr6|404
002434  aa   775504 3520 04	epp2 	-1212,ic		000140 = 524000000057
002435  aa  6 00626 2521 00	spri2	pr6|406
002436  aa  6 00612 6211 00	eax1 	pr6|394
002437  aa   014000 4310 07	fld  	6144,dl
002440  aa  6 00044 3701 20	epp4 	pr6|36,*
002441  la  4 00044 3521 20	epp2 	pr4|36,*		syserr$error_code
002442  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 621
	end;

						STATEMENT 1 ON LINE 623
	locked = "0"b;

002443  aa  6 00133 4501 00	stz  	pr6|91		locked
						STATEMENT 1 ON LINE 624
	if fnp_info.running				/* if it's up now */
	then do;

002444  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002445  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
002446  aa   100000 3150 03	cana 	32768,du
002447  aa   000022 6000 04	tze  	18,ic		002471
						STATEMENT 1 ON LINE 626
	     call lock;

002450  aa   005442 6700 04	tsp4 	2850,ic		010112
						STATEMENT 1 ON LINE 627
	     call dn355$hangup_fnp_lines ((fnp_info.fnp_number));

002451  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002452  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
002453  aa   000011 7350 00	als  	9
002454  aa   000077 7730 00	lrl  	63
002455  aa  6 00611 7561 00	stq  	pr6|393
002456  aa  6 00611 3521 00	epp2 	pr6|393
002457  aa  6 00550 2521 00	spri2	pr6|360
002460  aa  6 00546 6211 00	eax1 	pr6|358
002461  aa   004000 4310 07	fld  	2048,dl
002462  aa  6 00044 3701 20	epp4 	pr6|36,*
002463  la  4 00014 3521 20	epp2 	pr4|12,*		dn355$hangup_fnp_lines
002464  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 628
	     fnp_info.running = "0"b;

002465  aa   006274 2350 04	lda  	3260,ic		010761 = 677777777777
002466  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
002467  aa  7 00030 3551 00	ansa 	pr7|24		fnp_info.running
						STATEMENT 1 ON LINE 629
	     call unlock;

002470  aa   005506 6700 04	tsp4 	2886,ic		010176
						STATEMENT 1 ON LINE 630
	end;

						STATEMENT 1 ON LINE 633
shutdown_return:
	a_code = 0;

002471  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 635
	return;

002472  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read                                               STATEMENT 1 ON LINE 638
read:
     entry (a_fnpp, a_subchan, a_chainp, a_mi_flag, a_code);

002473  at     000005000166
002474  tt     000170000166
002475  tt     000164000162
002476  ta     002473000000
002477  da     000634300000
002500  aa   001420 6270 00	eax7 	784
002501  aa  7 00034 3521 20	epp2 	pr7|28,*
002502  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002503  aa     000012000000
002504  aa     000000000000
002505  aa  6 00032 3735 20	epp7 	pr6|26,*
002506  aa  7 00002 3715 20	epp5 	pr7|2,*
002507  aa  6 00340 6515 00	spri5	pr6|224
002510  aa  7 00012 3535 20	epp3 	pr7|10,*
002511  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 643
	a_chainp = null;

002512  aa   775514 2370 04	ldaq 	-1204,ic		000226 = 077777000043 000001000000
002513  aa  6 00032 3735 20	epp7 	pr6|26,*
002514  aa  7 00006 7571 20	staq 	pr7|6,*		a_chainp
						STATEMENT 1 ON LINE 644
	a_mi_flag = "0"b;

002515  aa  7 00010 4501 20	stz  	pr7|8,*		a_mi_flag
						STATEMENT 1 ON LINE 645
	a_code = 0;

002516  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 646
	return;

002517  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO write                                              STATEMENT 1 ON LINE 649
write:
     entry (a_fnpp, a_subchan, a_output_ptr, a_code);

002520  at     000004000166
002521  tt     000170000166
002522  ta     000162000000
002523  ta     002520000000
002524  da     000641300000
002525  aa   001420 6270 00	eax7 	784
002526  aa  7 00034 3521 20	epp2 	pr7|28,*
002527  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002530  aa     000010000000
002531  aa     000000000000
002532  aa  6 00032 3735 20	epp7 	pr6|26,*
002533  aa  7 00002 3715 20	epp5 	pr7|2,*
002534  aa  6 00340 6515 00	spri5	pr6|224
002535  aa  7 00010 3535 20	epp3 	pr7|8,*
002536  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 652
	fnpp = a_fnpp;

002537  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
002540  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002541  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 653
	chanx = a_subchan;

002542  aa  6 00032 3715 20	epp5 	pr6|26,*
002543  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
002544  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 654
	output_ptr = a_output_ptr;

002545  aa  5 00006 3535 20	epp3 	pr5|6,*		a_output_ptr
002546  aa  3 00000 3535 20	epp3 	pr3|0,*		a_output_ptr
002547  aa  6 00106 2535 00	spri3	pr6|70		output_ptr
						STATEMENT 1 ON LINE 656
	call setup;

002550  aa   003531 6700 04	tsp4 	1881,ic		006301
						STATEMENT 1 ON LINE 657
	if code ^= 0
	then do;

002551  aa  6 00100 2361 00	ldq  	pr6|64		code
002552  aa   000003 6000 04	tze  	3,ic		002555
						STATEMENT 1 ON LINE 659
	     a_code = code;

002553  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 660
	     return;

002554  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 661
	end;

						STATEMENT 1 ON LINE 665
	blockp = output_ptr;

002555  aa  6 00106 3735 20	epp7 	pr6|70,*		output_ptr
002556  aa  6 00302 6535 00	spri7	pr6|194		blockp
						STATEMENT 1 ON LINE 666
	output_length = buffer.tally;

002557  aa  6 00302 2361 20	ldq  	pr6|194,*		buffer.tally
002560  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002561  aa  6 00111 7561 00	stq  	pr6|73		output_length
						STATEMENT 1 ON LINE 668
	do while (buffer.next ^= 0);

002562  aa  6 00302 2351 20	lda  	pr6|194,*		buffer.next
002563  aa   000066 7730 00	lrl  	54
002564  aa  6 00611 7561 00	stq  	pr6|393		buffer.next
002565  aa   000010 6000 04	tze  	8,ic		002575
						STATEMENT 1 ON LINE 669
	     blockp = ptr (ttybp, buffer.next);

002566  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
002567  aa   000000 3120 06	eawp2	0,ql
002570  aa  6 00302 2521 00	spri2	pr6|194		blockp
						STATEMENT 1 ON LINE 670
	     output_length = output_length + buffer.tally;

002571  aa  2 00000 2361 00	ldq  	pr2|0		buffer.tally
002572  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002573  aa  6 00111 0561 00	asq  	pr6|73		output_length
						STATEMENT 1 ON LINE 671
	end;

002574  aa   777766 7100 04	tra  	-10,ic		002562
						STATEMENT 1 ON LINE 673
	if pcb.write_last ^= 0			/* existing write chain */
	then do;

002575  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
002576  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_last
002577  aa   000022 7350 00	als  	18
002600  aa   000066 7330 00	lrs  	54
002601  aa  6 00611 7561 00	stq  	pr6|393		pcb.write_last
002602  aa   000011 6000 04	tze  	9,ic		002613
						STATEMENT 1 ON LINE 675
	     lastp = ptr (ttybp, pcb.write_last);

002603  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
002604  aa   000000 3120 06	eawp2	0,ql
002605  aa  6 00116 2521 00	spri2	pr6|78		lastp
						STATEMENT 1 ON LINE 676
	     lastp -> buffer.next = bin (rel (output_ptr));

002606  aa  6 00106 6351 20	eaa  	pr6|70,*		output_ptr
002607  aa   000066 7730 00	lrl  	54
002610  aa   000066 7370 00	lls  	54
002611  aa  2 00000 5511 60	stba 	pr2|0,60		buffer.next
						STATEMENT 1 ON LINE 677
	end;

002612  aa   000005 7100 04	tra  	5,ic		002617
						STATEMENT 1 ON LINE 679
	else pcb.write_first = bin (rel (output_ptr));

002613  aa  6 00106 6351 20	eaa  	pr6|70,*		output_ptr
002614  aa   000066 7730 00	lrl  	54
002615  aa   000066 7370 00	lls  	54
002616  aa  7 00001 5511 60	stba 	pr7|1,60		pcb.write_first
						STATEMENT 1 ON LINE 681
	pcb.write_last = bin (rel (blockp));

002617  aa  6 00302 6351 20	eaa  	pr6|194,*		blockp
002620  aa   000066 7730 00	lrl  	54
002621  aa  7 00001 5521 14	stbq 	pr7|1,14		pcb.write_last
						STATEMENT 1 ON LINE 682
	pcb.write_cnt = pcb.write_cnt + output_length;

002622  aa  7 00003 2351 00	lda  	pr7|3		pcb.write_cnt
002623  aa   000022 7350 00	als  	18
002624  aa   000066 7330 00	lrs  	54
002625  aa  6 00111 0761 00	adq  	pr6|73		output_length
002626  aa  7 00003 5521 14	stbq 	pr7|3,14		pcb.write_cnt
						STATEMENT 1 ON LINE 684
	if pcb.send_output				/* if the FNP is ready for it */
	then call dn355$send_wcd (fnpp, pcbp, accept_direct_output, 0, ""b);

002627  aa  7 00004 2351 00	lda  	pr7|4		pcb.send_output
002630  aa   100000 3150 03	cana 	32768,du
002631  aa   000032 6000 04	tze  	26,ic		002663
002632  aa  6 00611 4501 00	stz  	pr6|393
002633  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
002634  aa  6 00564 2521 00	spri2	pr6|372
002635  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
002636  aa  6 00566 2521 00	spri2	pr6|374
002637  aa   775277 3520 04	epp2 	-1345,ic		000136 = 000000000012
002640  aa  6 00570 2521 00	spri2	pr6|376
002641  aa  6 00611 3521 00	epp2 	pr6|393
002642  aa  6 00572 2521 00	spri2	pr6|378
002643  aa  6 00610 3521 00	epp2 	pr6|392
002644  aa  6 00574 2521 00	spri2	pr6|380
002645  aa   775321 3520 04	epp2 	-1327,ic		000166 = 464000000000
002646  aa  6 00576 2521 00	spri2	pr6|382
002647  aa  6 00600 2521 00	spri2	pr6|384
002650  aa   775276 3520 04	epp2 	-1346,ic		000146 = 404000000010
002651  aa  6 00602 2521 00	spri2	pr6|386
002652  aa   775316 3520 04	epp2 	-1330,ic		000170 = 404000000021
002653  aa  6 00604 2521 00	spri2	pr6|388
002654  aa   775267 3520 04	epp2 	-1353,ic		000143 = 514000000000
002655  aa  6 00606 2521 00	spri2	pr6|390
002656  aa  6 00562 6211 00	eax1 	pr6|370
002657  aa   024000 4310 07	fld  	10240,dl
002660  aa  6 00044 3701 20	epp4 	pr6|36,*
002661  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
002662  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 687
	code = 0;

002663  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 688
write_exit:
	call unlock;

002664  aa   005312 6700 04	tsp4 	2762,ic		010176
						STATEMENT 1 ON LINE 690
	if code = 0
	then a_output_ptr = null ();

002665  aa  6 00100 2361 00	ldq  	pr6|64		code
002666  aa   000004 6010 04	tnz  	4,ic		002672
002667  aa   775337 2370 04	ldaq 	-1313,ic		000226 = 077777000043 000001000000
002670  aa  6 00032 3735 20	epp7 	pr6|26,*
002671  aa  7 00006 7571 20	staq 	pr7|6,*		a_output_ptr
						STATEMENT 1 ON LINE 692
	a_code = code;

002672  aa  6 00100 2361 00	ldq  	pr6|64		code
002673  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 693
	return;

002674  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO control                                            STATEMENT 1 ON LINE 695
control:
     entry (a_fnpp, a_subchan, a_order, a_data_ptr, a_code);

002675  at     000005000166
002676  tt     000170000161
002677  tt     000166000162
002700  ta     002675000000
002701  da     000646300000
002702  aa   001420 6270 00	eax7 	784
002703  aa  7 00034 3521 20	epp2 	pr7|28,*
002704  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002705  aa     000012000000
002706  aa     000000000000
002707  aa  6 00032 3735 20	epp7 	pr6|26,*
002710  aa  7 00002 3715 20	epp5 	pr7|2,*
002711  aa  6 00340 6515 00	spri5	pr6|224
002712  aa  7 00006 3535 20	epp3 	pr7|6,*
002713  aa  6 00346 2535 00	spri3	pr6|230
002714  aa  6 00042 3515 20	epp1 	pr6|34,*
002715  aa  1 00004 3715 20	epp5 	pr1|4,*
002716  aa  6 00344 6515 00	spri5	pr6|228
002717  aa  7 00010 3535 20	epp3 	pr7|8,*
002720  aa  6 00350 2535 00	spri3	pr6|232
002721  aa  7 00012 3515 20	epp1 	pr7|10,*
002722  aa  6 00342 2515 00	spri1	pr6|226
						STATEMENT 1 ON LINE 698
	fnpp = a_fnpp;

002723  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
002724  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002725  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 699
	chanx = a_subchan;

002726  aa  6 00032 3715 20	epp5 	pr6|26,*
002727  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
002730  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 700
	order = a_order;

002731  aa  6 00344 2361 20	ldq  	pr6|228,*
002732  aa   000002 6040 04	tmi  	2,ic		002734
002733  aa   777777 3760 07	anq  	262143,dl
002734  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002735  aa  6 00346 3535 20	epp3 	pr6|230,*
002736  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002737  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_order
002740  aa  6 00120 00 0040	desc9a	pr6|80,32		order
						STATEMENT 1 ON LINE 701
	data_ptr = a_data_ptr;

002741  aa  6 00350 3515 20	epp1 	pr6|232,*		a_data_ptr
002742  aa  1 00000 3515 20	epp1 	pr1|0,*		a_data_ptr
002743  aa  6 00130 2515 00	spri1	pr6|88		data_ptr
						STATEMENT 1 ON LINE 703
	dumpin, dumpout, set_write_status, get_meters = "0"b;

002744  aa  6 00157 4501 00	stz  	pr6|111		dumpin
002745  aa  6 00160 4501 00	stz  	pr6|112		dumpout
002746  aa  6 00132 4501 00	stz  	pr6|90		set_write_status
002747  aa  6 00161 4501 00	stz  	pr6|113		get_meters
						STATEMENT 1 ON LINE 705
	opcode, alter_type = -1;

002750  aa   000001 3360 07	lcq  	1,dl
002751  aa  6 00136 7561 00	stq  	pr6|94		opcode
002752  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 706
	check = "0"b;

002753  aa  6 00140 4501 00	stz  	pr6|96		check
						STATEMENT 1 ON LINE 708
	if order = "read_status"			/* there's never any at this level */
	then do;

002754  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002755  aa  6 00120 00 0040	desc9a	pr6|80,32		order
002756  aa   775312 00 0013	desc9a	-1334,11		000266 = 162145141144
002757  aa   000004 6010 04	tnz  	4,ic		002763
						STATEMENT 1 ON LINE 710
	     data_ptr -> rd_stat.input_available = "0"b;

002760  aa  1 00002 4501 00	stz  	pr1|2		rd_stat.input_available
						STATEMENT 1 ON LINE 711
	     a_code = 0;

002761  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 712
	     return;

002762  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 713
	end;

						STATEMENT 1 ON LINE 715
	else if order = "hangup"
	then do;

002763  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002764  aa  6 00120 00 0040	desc9a	pr6|80,32		order
002765  aa   775235 00 0006	desc9a	-1379,6		000220 = 150141156147
002766  aa   000010 6010 04	tnz  	8,ic		002776
						STATEMENT 1 ON LINE 717
	     mbx_data_len = 0;

002767  aa  6 00141 4501 00	stz  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 718
	     mbx_data = ""b;

002770  aa  000 100 100 400	mlr  	(),(pr),fill(000)
002771  aa   000000 00 0000	desc9a	0,0
002772  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
						STATEMENT 1 ON LINE 719
	     opcode = disconnect_this_line;

002773  aa   000001 2360 07	ldq  	1,dl
002774  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 720
	end;

002775  aa   000641 7100 04	tra  	417,ic		003636
						STATEMENT 1 ON LINE 722
	else if order = "wru"
	then do;

002776  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002777  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003000  aa   775141 00 0003	desc9a	-1439,3		000137 = 167162165000
003001  aa   000005 6010 04	tnz  	5,ic		003006
						STATEMENT 1 ON LINE 724
	     alter_type = Wru;

003002  aa   000023 2360 07	ldq  	19,dl
003003  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 725
	     alter_data = ""b;

003004  aa  6 00152 4501 00	stz  	pr6|106		alter_data
						STATEMENT 1 ON LINE 726
	end;

003005  aa   000631 7100 04	tra  	409,ic		003636
						STATEMENT 1 ON LINE 728
	else if order = "interrupt"
	then do;

003006  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003007  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003010  aa   775255 00 0011	desc9a	-1363,9		000263 = 151156164145
003011  aa   000005 6010 04	tnz  	5,ic		003016
						STATEMENT 1 ON LINE 730
	     alter_type = Break;

003012  aa   000004 2360 07	ldq  	4,dl
003013  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 731
	     alter_data = ""b;

003014  aa  6 00152 4501 00	stz  	pr6|106		alter_data
						STATEMENT 1 ON LINE 732
	end;

003015  aa   000621 7100 04	tra  	401,ic		003636
						STATEMENT 1 ON LINE 734
	else if order = "start_xmit_hd" | order = "stop_xmit_hd"
	then do;

003016  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003017  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003020  aa   775277 00 0015	desc9a	-1345,13		000315 = 163164141162
003021  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
003022  aa  6 00610 7551 00	sta  	pr6|392
003023  aa   000005 6010 04	tnz  	5,ic		003030
003024  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003025  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003026  aa   775234 00 0014	desc9a	-1380,12		000260 = 163164157160
003027  aa   000010 6010 04	tnz  	8,ic		003037
						STATEMENT 1 ON LINE 736
	     alter_type = Xmit_hold;

003030  aa   000025 2360 07	ldq  	21,dl
003031  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 737
	     alter_data = "00000000"b || (order = "start_xmit_hd");

003032  aa   000010 7710 00	arl  	8
003033  aa  6 00153 7551 00	sta  	pr6|107		alter_data
003034  aa   000011 2360 07	ldq  	9,dl
003035  aa  6 00152 7561 00	stq  	pr6|106		alter_data
						STATEMENT 1 ON LINE 738
	end;

003036  aa   000600 7100 04	tra  	384,ic		003636
						STATEMENT 1 ON LINE 740
	else if order = "set_input_message_size"
	then do;

003037  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003040  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003041  aa   775351 00 0026	desc9a	-1303,22		000410 = 163145164137
003042  aa   000014 6010 04	tnz  	12,ic		003056
						STATEMENT 1 ON LINE 742
	     mbx_data = bit (bin (data_ptr -> based_fb_word, 18), 18);

003043  aa  1 00000 2351 00	lda  	pr1|0		based_fb_word
003044  aa   000002 6050 04	tpl  	2,ic		003046
003045  aa   000000 5310 00	neg  	0
003046  aa   000022 7350 00	als  	18
003047  aa  6 00610 7551 00	sta  	pr6|392
003050  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003051  aa  6 00610 00 0022	descb	pr6|392,18
003052  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 743
	     opcode = sync_msg_size;

003053  aa   000027 2360 07	ldq  	23,dl
003054  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 744
	end;

003055  aa   000561 7100 04	tra  	369,ic		003636
						STATEMENT 1 ON LINE 746
	else if order = "line_control"
	then do;

003056  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003057  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003060  aa   775177 00 0014	desc9a	-1409,12		000255 = 154151156145
003061  aa   000011 6010 04	tnz  	9,ic		003072
						STATEMENT 1 ON LINE 748
	     mbx_data_len = 72;

003062  aa   000110 2360 07	ldq  	72,dl
003063  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 749
	     mbx_data = data_ptr -> based_bit72;

003064  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003065  aa  1 00000 00 0110	descb	pr1|0,72		based_bit72
003066  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 750
	     opcode = line_control;

003067  aa   000026 2360 07	ldq  	22,dl
003070  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 751
	end;

003071  aa   000545 7100 04	tra  	357,ic		003636
						STATEMENT 1 ON LINE 753
	else if order = "set_framing_chars"
	then do;

003072  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003073  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003074  aa   775245 00 0021	desc9a	-1371,17		000337 = 163145164137
003075  aa   000011 6010 04	tnz  	9,ic		003106
						STATEMENT 1 ON LINE 755
	     mbx_data_len = 18;

003076  aa   000022 2360 07	ldq  	18,dl
003077  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 756
	     mbx_data = data_ptr -> based_bit18;

003100  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003101  aa  1 00000 00 0022	descb	pr1|0,18		based_bit18
003102  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 757
	     opcode = set_framing_chars;

003103  aa   000010 2360 07	ldq  	8,dl
003104  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 758
	end;

003105  aa   000531 7100 04	tra  	345,ic		003636
						STATEMENT 1 ON LINE 760
	else if order = "set_delay"
	then do;

003106  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003107  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003110  aa   775144 00 0011	desc9a	-1436,9		000252 = 163145164137
003111  aa   000011 6010 04	tnz  	9,ic		003122
						STATEMENT 1 ON LINE 762
	     mbx_data_len = 108;

003112  aa   000154 2360 07	ldq  	108,dl
003113  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 763
	     mbx_data = data_ptr -> based_bit108;

003114  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003115  aa  1 00000 00 0154	descb	pr1|0,108		based_bit108
003116  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 764
	     opcode = set_delay_table;

003117  aa   000045 2360 07	ldq  	37,dl
003120  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 765
	end;

003121  aa   000515 7100 04	tra  	333,ic		003636
						STATEMENT 1 ON LINE 767
	else if order = "abort"			/* i.e., resetread or resetwrite */
	then do;

003122  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003123  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003124  aa   775074 00 0005	desc9a	-1476,5		000216 = 141142157162
003125  aa   000012 6010 04	tnz  	10,ic		003137
						STATEMENT 1 ON LINE 769
	     dumpin = substr (data_ptr -> based_bit2, 2, 1);

003126  aa  6 00157 4501 00	stz  	pr6|111		dumpin
003127  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003130  aa  1 00000 01 0001	descb	pr1|0(1),1	based_bit2
003131  aa  6 00157 00 0001	descb	pr6|111,1		dumpin
						STATEMENT 1 ON LINE 771
	     dumpout = substr (data_ptr -> based_bit2, 1, 1);

003132  aa  6 00160 4501 00	stz  	pr6|112		dumpout
003133  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003134  aa  1 00000 00 0001	descb	pr1|0,1		based_bit2
003135  aa  6 00160 00 0001	descb	pr6|112,1		dumpout
						STATEMENT 1 ON LINE 772
	end;

003136  aa   000500 7100 04	tra  	320,ic		003636
						STATEMENT 1 ON LINE 774
	else if order = "set_line_type"
	then do;

003137  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003140  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003141  aa   775152 00 0015	desc9a	-1430,13		000311 = 163145164137
003142  aa   000015 6010 04	tnz  	13,ic		003157
						STATEMENT 1 ON LINE 776
	     mbx_data_len = 18;

003143  aa   000022 2360 07	ldq  	18,dl
003144  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 777
	     local_line_type = data_ptr -> based_fb_word;

003145  aa  1 00000 2361 00	ldq  	pr1|0		based_fb_word
003146  aa  6 00174 7561 00	stq  	pr6|124		local_line_type
						STATEMENT 1 ON LINE 778
	     if local_line_type <= 0 | local_line_type > max_line_type
	     then go to order_error;

003147  aa   000463 6044 04	tmoz 	307,ic		003632
003150  aa   000025 1160 07	cmpq 	21,dl
003151  aa   000461 6054 04	tpnz 	305,ic		003632
						STATEMENT 1 ON LINE 780
	     check = "1"b;

003152  aa   400000 2350 03	lda  	131072,du
003153  aa  6 00140 7551 00	sta  	pr6|96		check
						STATEMENT 1 ON LINE 781
	     opcode = set_line_type;

003154  aa   000006 2360 07	ldq  	6,dl
003155  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 782
	end;

003156  aa   000460 7100 04	tra  	304,ic		003636
						STATEMENT 1 ON LINE 784
	else if order = "dial_out"
	then do;

003157  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003160  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003161  aa   775035 00 0010	desc9a	-1507,8		000214 = 144151141154
003162  aa   000052 6010 04	tnz  	42,ic		003234
						STATEMENT 1 ON LINE 786
	     digit_pos = 0;

003163  aa  6 00205 4501 00	stz  	pr6|133		digit_pos
						STATEMENT 1 ON LINE 787
	     do i = 1 to length (data_ptr -> phone_chars);

003164  aa  1 00000 2361 00	ldq  	pr1|0		phone_chars
003165  aa  6 00356 7561 00	stq  	pr6|238
003166  aa   000001 2360 07	ldq  	1,dl
003167  aa  6 00114 7561 00	stq  	pr6|76		i
003170  aa  6 00114 2361 00	ldq  	pr6|76		i
003171  aa  6 00356 1161 00	cmpq 	pr6|238
003172  aa   000032 6054 04	tpnz 	26,ic		003224
						STATEMENT 1 ON LINE 788
		next_digit = index ("0123456789XXX!", substr (data_ptr -> phone_chars, i, 1)) - 1;

003173  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
003174  aa  000 106 124 404	scm  	(ic),(pr,ql),mask(000)
003175  aa   775111 00 0016	desc9a	-1463,14		000305 = 060061062063
003176  aa  7 00000 60 0001	desc9a	pr7|0(3),1	phone_chars
003177  aa  6 00056 0001 00	arg  	pr6|46
003200  aa  6 00056 2361 00	ldq  	pr6|46
003201  aa   000002 6070 04	ttf  	2,ic		003203
003202  aa   000001 3360 07	lcq  	1,dl
003203  aa  6 00204 7561 00	stq  	pr6|132		next_digit
						STATEMENT 1 ON LINE 791
		if next_digit >= 0
		then if next_digit < 10 | next_digit = 13
		     then do;

003204  aa   000016 6040 04	tmi  	14,ic		003222
003205  aa   000012 1160 07	cmpq 	10,dl
003206  aa   000003 6040 04	tmi  	3,ic		003211
003207  aa   000015 1160 07	cmpq 	13,dl
003210  aa   000012 6010 04	tnz  	10,ic		003222
						STATEMENT 1 ON LINE 794
			digit_pos = digit_pos + 1;

003211  aa  6 00205 0541 00	aos  	pr6|133		digit_pos
						STATEMENT 1 ON LINE 795
			phone_digits (digit_pos) = bit (next_digit, 6);

003212  aa  6 00205 2361 00	ldq  	pr6|133		digit_pos
003213  aa   000006 4020 07	mpy  	6,dl
003214  aa  6 00204 2351 00	lda  	pr6|132		next_digit
003215  aa   000036 7350 00	als  	30
003216  aa  6 00056 7551 00	sta  	pr6|46
003217  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
003220  aa  6 00056 00 0006	descb	pr6|46,6
003221  aa  6 00175 63 0006	descb	pr6|125(30),6	phone_digits
						STATEMENT 1 ON LINE 796
		     end;

						STATEMENT 1 ON LINE 797
	     end;

003222  aa  6 00114 0541 00	aos  	pr6|76		i
003223  aa   777745 7100 04	tra  	-27,ic		003170
						STATEMENT 1 ON LINE 799
	     phone_no_len = 6 * digit_pos;

003224  aa  6 00205 2361 00	ldq  	pr6|133		digit_pos
003225  aa   000006 4020 07	mpy  	6,dl
003226  aa  6 00175 7561 00	stq  	pr6|125		phone_no_len
						STATEMENT 1 ON LINE 800
	     opcode = dial;

003227  aa   000014 2360 07	ldq  	12,dl
003230  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 801
	     check = "1"b;

003231  aa   400000 2350 03	lda  	131072,du
003232  aa  6 00140 7551 00	sta  	pr6|96		check
						STATEMENT 1 ON LINE 802
	end;

003233  aa   000403 7100 04	tra  	259,ic		003636
						STATEMENT 1 ON LINE 804
	else if order = "listen"
	then do;

003234  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003235  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003236  aa   774756 00 0006	desc9a	-1554,6		000212 = 154151163164
003237  aa   000010 6010 04	tnz  	8,ic		003247
						STATEMENT 1 ON LINE 806
	     alter_type = Listen;

003240  aa   000020 2360 07	ldq  	16,dl
003241  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 807
	     alter_data = "000000001"b;

003242  aa   001000 2350 03	lda  	512,du
003243  aa  6 00153 7551 00	sta  	pr6|107		alter_data
003244  aa   000011 2360 07	ldq  	9,dl
003245  aa  6 00152 7561 00	stq  	pr6|106		alter_data
						STATEMENT 1 ON LINE 808
	end;

003246  aa   000370 7100 04	tra  	248,ic		003636
						STATEMENT 1 ON LINE 810
	else if order = "write_status"
	then set_write_status = "1"b;

003247  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003250  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003251  aa   775000 00 0014	desc9a	-1536,12		000247 = 167162151164
003252  aa   000004 6010 04	tnz  	4,ic		003256
003253  aa   400000 2350 03	lda  	131072,du
003254  aa  6 00132 7551 00	sta  	pr6|90		set_write_status
003255  aa   000361 7100 04	tra  	241,ic		003636
						STATEMENT 1 ON LINE 813
	else if order = "enter_receive"
	then do;

003256  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003257  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003260  aa   775023 00 0015	desc9a	-1517,13		000301 = 145156164145
003261  aa   000010 6010 04	tnz  	8,ic		003271
						STATEMENT 1 ON LINE 815
	     mbx_data_len = 0;

003262  aa  6 00141 4501 00	stz  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 816
	     mbx_data = ""b;

003263  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003264  aa   000000 00 0000	desc9a	0,0
003265  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
						STATEMENT 1 ON LINE 817
	     opcode = enter_receive;

003266  aa   000007 2360 07	ldq  	7,dl
003267  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 818
	end;

003270  aa   000346 7100 04	tra  	230,ic		003636
						STATEMENT 1 ON LINE 819
	else if order = "start_negotiated_echo"
	then do;

003271  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003272  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003273  aa   775111 00 0025	desc9a	-1463,21		000402 = 163164141162
003274  aa   000024 6010 04	tnz  	20,ic		003320
						STATEMENT 1 ON LINE 821
	     mbx_data_len = 36;

003275  aa   000044 2360 07	ldq  	36,dl
003276  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 822
	     mbx_data =
		bit (fixed (data_ptr -> echo_start_data.ctr, 18), 18)
		|| bit (fixed (data_ptr -> echo_start_data.screenleft, 18), 18);

003277  aa  1 00000 2351 00	lda  	pr1|0		echo_start_data.ctr
003300  aa   000002 6050 04	tpl  	2,ic		003302
003301  aa   000000 5310 00	neg  	0
003302  aa   000022 7350 00	als  	18
003303  aa  6 00610 7551 00	sta  	pr6|392
003304  aa  1 00001 2351 00	lda  	pr1|1		echo_start_data.screenleft
003305  aa   000002 6050 04	tpl  	2,ic		003307
003306  aa   000000 5310 00	neg  	0
003307  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
003310  aa  6 00610 2751 00	ora  	pr6|392
003311  aa  6 00610 7551 00	sta  	pr6|392
003312  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003313  aa  6 00610 00 0044	descb	pr6|392,36
003314  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 825
	     opcode = start_negotiated_echo;

003315  aa   000031 2360 07	ldq  	25,dl
003316  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 826
	end;

003317  aa   000317 7100 04	tra  	207,ic		003636
						STATEMENT 1 ON LINE 827
	else if order = "set_echnego_break_table"
	then do;

003320  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003321  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003322  aa   775054 00 0027	desc9a	-1492,23		000374 = 163145164137
003323  aa   000032 6010 04	tnz  	26,ic		003355
						STATEMENT 1 ON LINE 829
	     mbx_data_len = length (unspec (echnego_break_table));

003324  aa   000440 2360 07	ldq  	288,dl
003325  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 830
	     unspec (echnego_break_table) = ""b;

003326  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003327  aa   000000 00 0000	desc9a	0,0
003330  aa  6 00262 00 0040	desc9a	pr6|178,32
						STATEMENT 1 ON LINE 831
	     do i = 0 to hbound (echnego_break_table.words, 1);

003331  aa  6 00114 4501 00	stz  	pr6|76		i
003332  aa  6 00114 2361 00	ldq  	pr6|76		i
003333  aa   000017 1160 07	cmpq 	15,dl
003334  aa   000013 6054 04	tpnz 	11,ic		003347
						STATEMENT 1 ON LINE 832
		echnego_break_table.bits (i) = substr (data_ptr -> based_echo_table_bits, 1 + 16 * i, 16);

003335  aa   000022 4020 07	mpy  	18,dl
003336  aa   000000 6270 06	eax7 	0,ql
003337  aa  6 00114 2361 00	ldq  	pr6|76		i
003340  aa   000004 7360 00	qls  	4
003341  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
003342  aa  003 117 060 506	csl  	(pr,ql),(pr,x7),fill(0),bool(move)
003343  aa  7 00000 00 0020	descb	pr7|0,16		based_echo_table_bits
003344  aa  6 00262 00 0020	descb	pr6|178,16	echnego_break_table.bits
						STATEMENT 1 ON LINE 833
	     end;

003345  aa  6 00114 0541 00	aos  	pr6|76		i
003346  aa   777764 7100 04	tra  	-12,ic		003332
						STATEMENT 1 ON LINE 834
	     mbx_data_long = unspec (echnego_break_table);

003347  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003350  aa  6 00262 00 0040	desc9a	pr6|178,32
003351  aa  6 00142 00 0040	desc9a	pr6|98,32		mbx_data_long
						STATEMENT 1 ON LINE 835
	     opcode = set_echnego_break_table;

003352  aa   000030 2360 07	ldq  	24,dl
003353  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 836
	end;

003354  aa   000262 7100 04	tra  	178,ic		003636
						STATEMENT 1 ON LINE 837
	else if order = "init_echo_negotiation"
	then do;

003355  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003356  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003357  aa   775011 00 0025	desc9a	-1527,21		000366 = 151156151164
003360  aa   000010 6010 04	tnz  	8,ic		003370
						STATEMENT 1 ON LINE 839
	     mbx_data_len = 0;

003361  aa  6 00141 4501 00	stz  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 840
	     mbx_data = ""b;

003362  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003363  aa   000000 00 0000	desc9a	0,0
003364  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
						STATEMENT 1 ON LINE 841
	     opcode = init_echo_negotiation;

003365  aa   000033 2360 07	ldq  	27,dl
003366  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 842
	end;

003367  aa   000247 7100 04	tra  	167,ic		003636
						STATEMENT 1 ON LINE 843
	else if order = "stop_negotiated_echo"
	then do;

003370  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003371  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003372  aa   774742 00 0024	desc9a	-1566,20		000332 = 163164157160
003373  aa   000010 6010 04	tnz  	8,ic		003403
						STATEMENT 1 ON LINE 845
	     mbx_data_len = 0;

003374  aa  6 00141 4501 00	stz  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 846
	     mbx_data = ""b;

003375  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003376  aa   000000 00 0000	desc9a	0,0
003377  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
						STATEMENT 1 ON LINE 847
	     opcode = stop_negotiated_echo;

003400  aa   000032 2360 07	ldq  	26,dl
003401  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 848
	end;

003402  aa   000234 7100 04	tra  	156,ic		003636
						STATEMENT 1 ON LINE 849
	else if order = "input_flow_control_chars"
	then do;

003403  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003404  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003405  aa   774755 00 0030	desc9a	-1555,24		000360 = 151156160165
003406  aa   000043 6010 04	tnz  	35,ic		003451
						STATEMENT 1 ON LINE 851
	     mbx_data_len = 36;

003407  aa   000044 2360 07	ldq  	36,dl
003410  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 852
	     if data_ptr -> input_flow_control_info.resume_seq.count = 0
						/* turning it all off */
	     then mbx_data = ""b;

003411  aa  1 00001 2351 00	lda  	pr1|1		input_flow_control_info.count
003412  aa   000077 7730 00	lrl  	63
003413  aa   000005 6010 04	tnz  	5,ic		003420
003414  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003415  aa   000000 00 0000	desc9a	0,0
003416  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
003417  aa   000027 7100 04	tra  	23,ic		003446
						STATEMENT 1 ON LINE 855
	     else do;

						STATEMENT 1 ON LINE 856
		mbx_data =
		     unspec (substr (data_ptr -> input_flow_control_info.suspend_seq.chars, 1, 1))
		     || unspec (substr (data_ptr -> input_flow_control_info.resume_seq.chars, 1, 1))
		     || data_ptr -> input_flow_control_info.timeout;

003420  aa  1 00000 2351 00	lda  	pr1|0
003421  aa   000011 7350 00	als  	9
003422  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003423  aa  6 00610 7551 00	sta  	pr6|392
003424  aa  1 00001 2351 00	lda  	pr1|1
003425  aa   000011 7350 00	als  	9
003426  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003427  aa   000011 7710 00	arl  	9
003430  aa  6 00610 2751 00	ora  	pr6|392
003431  aa  6 00610 7551 00	sta  	pr6|392
003432  aa  1 00002 2351 00	lda  	pr1|2		input_flow_control_info.timeout
003433  aa   000022 7710 00	arl  	18
003434  aa  6 00610 2751 00	ora  	pr6|392
003435  aa  6 00610 7551 00	sta  	pr6|392
003436  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003437  aa  6 00610 00 0023	descb	pr6|392,19
003440  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 860
		if data_ptr -> input_flow_control_info.suspend_seq.count = 0
		then substr (mbx_data, 1, 9) = "0"b;

003441  aa  1 00000 2351 00	lda  	pr1|0		input_flow_control_info.count
003442  aa   000077 7730 00	lrl  	63
003443  aa   000003 6010 04	tnz  	3,ic		003446
003444  aa   005314 2350 04	lda  	2764,ic		010760 = 000777777777
003445  aa  6 00142 3551 00	ansa 	pr6|98		mbx_data
						STATEMENT 1 ON LINE 862
	     end;

						STATEMENT 1 ON LINE 863
	     opcode = input_fc_chars;

003446  aa   000036 2360 07	ldq  	30,dl
003447  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 864
	end;

003450  aa   000166 7100 04	tra  	118,ic		003636
						STATEMENT 1 ON LINE 865
	else if order = "output_flow_control_chars"
	then do;

003451  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003452  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003453  aa   774753 00 0031	desc9a	-1557,25		000424 = 157165164160
003454  aa   000040 6010 04	tnz  	32,ic		003514
						STATEMENT 1 ON LINE 867
	     mbx_data_len = 36;

003455  aa   000044 2360 07	ldq  	36,dl
003456  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 868
	     if data_ptr -> output_flow_control_info.suspend_or_etb_seq.count = 0
						/* no chars */
	     then mbx_data = "0"b;

003457  aa  1 00001 2351 00	lda  	pr1|1		output_flow_control_info.count
003460  aa   000077 7730 00	lrl  	63
003461  aa   000005 6010 04	tnz  	5,ic		003466
003462  aa  000 100 100 400	mlr  	(),(pr),fill(000)
003463  aa   000000 00 0000	desc9a	0,0
003464  aa  6 00142 00 0020	desc9a	pr6|98,16		mbx_data
003465  aa   000024 7100 04	tra  	20,ic		003511
						STATEMENT 1 ON LINE 871
	     else mbx_data =
		     unspec (substr (data_ptr -> output_flow_control_info.suspend_or_etb_seq.chars, 1, 1))
		     || unspec (substr (data_ptr -> output_flow_control_info.resume_or_ack_seq.chars, 1, 1))
		     || data_ptr -> output_flow_control_info.block_acknowledge;

003466  aa  1 00001 2351 00	lda  	pr1|1
003467  aa   000011 7350 00	als  	9
003470  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003471  aa  6 00610 7551 00	sta  	pr6|392
003472  aa  1 00002 2351 00	lda  	pr1|2
003473  aa   000011 7350 00	als  	9
003474  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003475  aa   000011 7710 00	arl  	9
003476  aa  6 00610 2751 00	ora  	pr6|392
003477  aa  6 00610 7551 00	sta  	pr6|392
003500  aa  1 00000 2351 00	lda  	pr1|0		output_flow_control_info.block_acknowledge
003501  aa   000001 7350 00	als  	1
003502  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003503  aa   000022 7710 00	arl  	18
003504  aa  6 00610 2751 00	ora  	pr6|392
003505  aa  6 00610 7551 00	sta  	pr6|392
003506  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003507  aa  6 00610 00 0023	descb	pr6|392,19
003510  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 875
	     opcode = output_fc_chars;

003511  aa   000037 2360 07	ldq  	31,dl
003512  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 876
	end;

003513  aa   000123 7100 04	tra  	83,ic		003636
						STATEMENT 1 ON LINE 878
	else if order = "copy_meters"
	then do;

003514  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003515  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003516  aa   774530 00 0013	desc9a	-1704,11		000244 = 143157160171
003517  aa   000006 6010 04	tnz  	6,ic		003525
						STATEMENT 1 ON LINE 880
	     opcode = report_meters;

003520  aa   000044 2360 07	ldq  	36,dl
003521  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 881
	     check = "1"b;

003522  aa   400000 2350 03	lda  	131072,du
003523  aa  6 00140 7551 00	sta  	pr6|96		check
						STATEMENT 1 ON LINE 882
	end;

003524  aa   000112 7100 04	tra  	74,ic		003636
						STATEMENT 1 ON LINE 884
	else if order = "get_meters"
	then do;

003525  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003526  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003527  aa   774514 00 0012	desc9a	-1716,10		000241 = 147145164137
003530  aa   000021 6010 04	tnz  	17,ic		003551
						STATEMENT 1 ON LINE 886
	     ret_meters_ptr = data_ptr -> get_comm_meters_info.parent_ptr;

003531  aa  1 00006 3735 20	epp7 	pr1|6,*		get_comm_meters_info.parent_ptr
003532  aa  6 00172 6535 00	spri7	pr6|122		ret_meters_ptr
						STATEMENT 1 ON LINE 887
	     if ret_meters_ptr = null ()
	     then return;

003533  aa  6 00172 2371 00	ldaq 	pr6|122		ret_meters_ptr
003534  aa   774472 6770 04	eraq 	-1734,ic		000226 = 077777000043 000001000000
003535  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003536  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 889
	     else if ret_meters_ptr -> fnp_chan_meter_struc.version ^= FNP_CHANNEL_METERS_VERSION_1
	     then do;

003537  aa  7 00000 2361 00	ldq  	pr7|0		fnp_chan_meter_struc.version
003540  aa   000001 1160 07	cmpq 	1,dl
003541  aa   000005 6000 04	tze  	5,ic		003546
						STATEMENT 1 ON LINE 891
		a_code = error_table_$unimplemented_version;

003542  aa  6 00044 3701 20	epp4 	pr6|36,*
003543  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$unimplemented_version
003544  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 892
		return;

003545  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 893
	     end;

						STATEMENT 1 ON LINE 895
	     else get_meters = "1"b;

003546  aa   400000 2350 03	lda  	131072,du
003547  aa  6 00161 7551 00	sta  	pr6|113		get_meters
						STATEMENT 1 ON LINE 896
	end;

003550  aa   000066 7100 04	tra  	54,ic		003636
						STATEMENT 1 ON LINE 898
	else if order = "tandd_attach"
	then do;

003551  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003552  aa  6 00120 00 0040	desc9a	pr6|80,32		order
003553  aa   774465 00 0014	desc9a	-1739,12		000236 = 164141156144
003554  aa   000056 6010 04	tnz  	46,ic		003632
						STATEMENT 1 ON LINE 900
	     call setup;

003555  aa   002524 6700 04	tsp4 	1364,ic		006301
						STATEMENT 1 ON LINE 901
	     if code ^= 0
	     then do;

003556  aa  6 00100 2361 00	ldq  	pr6|64		code
003557  aa   000003 6000 04	tze  	3,ic		003562
						STATEMENT 1 ON LINE 903
		a_code = code;

003560  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 904
		return;

003561  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 905
	     end;

						STATEMENT 1 ON LINE 907
	     if pcb.listen | pcb.dialed		/* can't have this */
	     then do;

003562  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
003563  aa  7 00004 2351 00	lda  	pr7|4		pcb.dialed
003564  aa   600000 3150 03	cana 	196608,du
003565  aa   000006 6000 04	tze  	6,ic		003573
						STATEMENT 1 ON LINE 909
		call unlock;

003566  aa   004410 6700 04	tsp4 	2312,ic		010176
						STATEMENT 1 ON LINE 910
		a_code = error_table_$resource_not_free;

003567  aa  6 00044 3701 20	epp4 	pr6|36,*
003570  la  4 00110 2361 20	ldq  	pr4|72,*		error_table_$resource_not_free
003571  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 911
		return;

003572  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 912
	     end;

						STATEMENT 1 ON LINE 914
	     pcb.dialed = "1"b;

003573  aa   200000 2350 03	lda  	65536,du
003574  aa  7 00004 2551 00	orsa 	pr7|4		pcb.dialed
						STATEMENT 1 ON LINE 915
	     pcb.tandd_attached = "1"b;

003575  aa   000100 2350 03	lda  	64,du
003576  aa  7 00004 2551 00	orsa 	pr7|4		pcb.tandd_attached
						STATEMENT 1 ON LINE 916
	     unspec (dialup_info) = ""b;

003577  aa   774411 2370 04	ldaq 	-1783,ic		000210 = 000000000000 000000000000
003600  aa  6 00332 7571 00	staq 	pr6|218
						STATEMENT 1 ON LINE 917
	     dialup_info.baud_rate = 1200;

003601  aa   002260 2350 07	lda  	1200,dl
003602  aa  6 00332 5511 14	stba 	pr6|218,14	dialup_info.baud_rate
						STATEMENT 1 ON LINE 918
	     dialup_info.line_type = LINE_ASCII;

003603  aa   001000 2350 03	lda  	512,du
003604  aa  6 00332 5511 40	stba 	pr6|218,40	dialup_info.line_type
						STATEMENT 1 ON LINE 919
	     dialup_info.max_buf_size = 16;

003605  aa   020000 2350 03	lda  	8192,du
003606  aa  6 00333 5511 40	stba 	pr6|219,40	dialup_info.max_buf_size
						STATEMENT 1 ON LINE 920
	     call channel_manager$interrupt ((pcb.devx), DIALUP, unspec (dialup_info));

003607  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
003610  aa   000066 7330 00	lrs  	54
003611  aa  6 00610 7561 00	stq  	pr6|392
003612  aa  6 00332 2371 00	ldaq 	pr6|218
003613  aa  6 00630 7571 00	staq 	pr6|408
003614  aa  6 00610 3521 00	epp2 	pr6|392
003615  aa  6 00550 2521 00	spri2	pr6|360
003616  aa   774351 3520 04	epp2 	-1815,ic		000167 = 000000000001
003617  aa  6 00552 2521 00	spri2	pr6|362
003620  aa  6 00630 3521 00	epp2 	pr6|408
003621  aa  6 00554 2521 00	spri2	pr6|364
003622  aa  6 00546 6211 00	eax1 	pr6|358
003623  aa   014000 4310 07	fld  	6144,dl
003624  aa  6 00044 3701 20	epp4 	pr6|36,*
003625  la  4 00144 3521 20	epp2 	pr4|100,*		channel_manager$interrupt
003626  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 921
	     call unlock;

003627  aa   004347 6700 04	tsp4 	2279,ic		010176
						STATEMENT 1 ON LINE 922
	     a_code = 0;

003630  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 923
	     return;

003631  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 924
	end;

						STATEMENT 1 ON LINE 926
	else do;

						STATEMENT 1 ON LINE 927
order_error:
	     a_code = error_table_$undefined_order_request;

003632  aa  6 00044 3701 20	epp4 	pr6|36,*
003633  la  4 00062 2361 20	ldq  	pr4|50,*		error_table_$undefined_order_request
003634  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 929
	     return;

003635  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 930
	end;

						STATEMENT 1 ON LINE 932
	code = 0;

003636  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 933
	call setup;

003637  aa   002442 6700 04	tsp4 	1314,ic		006301
						STATEMENT 1 ON LINE 934
	if code ^= 0
	then do;

003640  aa  6 00100 2361 00	ldq  	pr6|64		code
003641  aa   000003 6000 04	tze  	3,ic		003644
						STATEMENT 1 ON LINE 936
	     a_code = code;

003642  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 937
	     return;

003643  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 938
	end;

						STATEMENT 1 ON LINE 940
	if opcode = disconnect_this_line		/* hangup */
	then do;

003644  aa  6 00136 2361 00	ldq  	pr6|94		opcode
003645  aa   000001 1160 07	cmpq 	1,dl
003646  aa   000006 6010 04	tnz  	6,ic		003654
						STATEMENT 1 ON LINE 942
	     pcb.listen, pcb.tandd_attached = "0"b;

003647  aa   005110 2350 04	lda  	2632,ic		010757 = 377777777777
003650  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
003651  aa  7 00004 3551 00	ansa 	pr7|4		pcb.listen
003652  aa   005104 2350 04	lda  	2628,ic		010756 = 777677777777
003653  aa  7 00004 3551 00	ansa 	pr7|4		pcb.tandd_attached
						STATEMENT 1 ON LINE 943
	end;

						STATEMENT 1 ON LINE 945
	if opcode = start_negotiated_echo & (pcb.write_first ^= 0
						/* We have queued output */
	     | pcb.output_mbx_pending)
	then do;

003654  aa   000031 1160 07	cmpq 	25,dl
003655  aa   000015 6010 04	tnz  	13,ic		003672
003656  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
003657  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
003660  aa   000066 7330 00	lrs  	54
003661  aa   000004 6010 04	tnz  	4,ic		003665
003662  aa  7 00004 2351 00	lda  	pr7|4		pcb.output_mbx_pending
003663  aa   001000 3150 03	cana 	512,du
003664  aa   000006 6000 04	tze  	6,ic		003672
						STATEMENT 1 ON LINE 950
	     call unlock;

003665  aa   004311 6700 04	tsp4 	2249,ic		010176
						STATEMENT 1 ON LINE 951
	     a_code = error_table_$invalid_write;

003666  aa  6 00044 3701 20	epp4 	pr6|36,*
003667  la  4 00072 2361 20	ldq  	pr4|58,*		error_table_$invalid_write
003670  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 952
	     return;

003671  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 953
	end;

						STATEMENT 1 ON LINE 956
	if alter_type ^= -1				/* alter_parameters required */
	then do;

003672  aa  6 00137 2361 00	ldq  	pr6|95		alter_type
003673  aa   005107 1160 04	cmpq 	2631,ic		011002 = 777777777777
003674  aa   000052 6000 04	tze  	42,ic		003746
						STATEMENT 1 ON LINE 958
	     if alter_type = Listen
	     then do;

003675  aa   000020 1160 07	cmpq 	16,dl
003676  aa   000020 6010 04	tnz  	16,ic		003716
						STATEMENT 1 ON LINE 960
		alter_data = alter_data || fnp_buf_size ();

003677  aa   005053 3520 04	epp2 	2603,ic		010752 = 000002000000
003700  aa   004321 6700 04	tsp4 	2257,ic		010221
003701  aa   000220 2360 07	ldq  	144,dl
003702  aa  6 00152 1761 00	sbq  	pr6|106		alter_data
003703  aa   000022 1160 07	cmpq 	18,dl
003704  aa   000002 6040 04	tmi  	2,ic		003706
003705  aa   000022 2360 07	ldq  	18,dl
003706  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
003707  aa  6 00152 0561 00	asq  	pr6|106		alter_data
003710  aa  003 157 060 540	csl  	(pr,rl),(pr,rl,x7),fill(0),bool(move)
003711  aa  6 00610 00 0006	descb	pr6|392,ql
003712  aa  6 00153 00 0006	descb	pr6|107,ql	alter_data
						STATEMENT 1 ON LINE 961
		pcb.listen = "1"b;

003713  aa   400000 2350 03	lda  	131072,du
003714  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
003715  aa  7 00004 2551 00	orsa 	pr7|4		pcb.listen
						STATEMENT 1 ON LINE 962
	     end;

						STATEMENT 1 ON LINE 964
	     mbx_data_len = length (alter_data) + 9;

003716  aa  6 00152 2361 00	ldq  	pr6|106		alter_data
003717  aa   000011 0760 07	adq  	9,dl
003720  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 965
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;

003721  aa  6 00137 2351 00	lda  	pr6|95		alter_type
003722  aa   000002 6050 04	tpl  	2,ic		003724
003723  aa   000000 5310 00	neg  	0
003724  aa   000033 7350 00	als  	27
003725  aa  6 00610 7551 00	sta  	pr6|392
003726  aa   000011 2360 07	ldq  	9,dl
003727  aa  6 00152 0761 00	adq  	pr6|106		alter_data
003730  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
003731  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003732  aa  6 00610 00 0011	descb	pr6|392,9
003733  aa  2 00000 00 0011	descb	pr2|0,9
003734  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
003735  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
003736  aa  6 00153 00 0017	descb	pr6|107,x7	alter_data
003737  aa  2 00000 20 0017	descb	pr2|0(9),x7
003740  aa  003 100 060 540	csl  	(pr,rl),(pr),fill(0),bool(move)
003741  aa  2 00000 00 0006	descb	pr2|0,ql
003742  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 966
	     opcode = alter_parameters;

003743  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
003744  aa   000042 2360 07	ldq  	34,dl
003745  aa  6 00136 7561 00	stq  	pr6|94		opcode
						STATEMENT 1 ON LINE 967
	end;

						STATEMENT 1 ON LINE 969
	if opcode ^= -1				/* we do have to send the FNP something */
	then do;

003746  aa  6 00136 2361 00	ldq  	pr6|94		opcode
003747  aa   005033 1160 04	cmpq 	2587,ic		011002 = 777777777777
003750  aa   000246 6000 04	tze  	166,ic		004216
						STATEMENT 1 ON LINE 971
	     if check				/* anything special about it */
	     then do;

003751  aa  6 00140 2351 00	lda  	pr6|96		check
003752  aa   000213 6000 04	tze  	139,ic		004165
						STATEMENT 1 ON LINE 973
		if opcode = set_line_type		/* make sure this is OK */
		then if pcb.listen
		     then do;

003753  aa   000006 1160 07	cmpq 	6,dl
003754  aa   000046 6010 04	tnz  	38,ic		004022
003755  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
003756  aa  7 00004 2351 00	lda  	pr7|4		pcb.listen
003757  aa   400000 3150 03	cana 	131072,du
003760  aa   000003 6000 04	tze  	3,ic		003763
						STATEMENT 1 ON LINE 976
			call unlock;

003761  aa   004215 6700 04	tsp4 	2189,ic		010176
						STATEMENT 1 ON LINE 977
			go to order_error;

003762  aa   777650 7100 04	tra  	-88,ic		003632
						STATEMENT 1 ON LINE 978
		     end;

						STATEMENT 1 ON LINE 980
		     else do;

						STATEMENT 1 ON LINE 981
			mbx_data = bit (bin (local_line_type, 18), 18);

003763  aa  6 00174 2351 00	lda  	pr6|124		local_line_type
003764  aa   000002 6050 04	tpl  	2,ic		003766
003765  aa   000000 5310 00	neg  	0
003766  aa   000022 7350 00	als  	18
003767  aa  6 00610 7551 00	sta  	pr6|392
003770  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003771  aa  6 00610 00 0022	descb	pr6|392,18
003772  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 982
			do i = 1 to n_sync_line_types while (local_line_type ^= sync_line_type (i));

003773  aa   000012 2360 07	ldq  	10,dl
003774  aa  6 00357 7561 00	stq  	pr6|239
003775  aa   000001 2360 07	ldq  	1,dl
003776  aa  6 00114 7561 00	stq  	pr6|76		i
003777  aa   000000 0110 03	nop  	0,du
004000  aa  6 00114 2361 00	ldq  	pr6|76		i
004001  aa  6 00357 1161 00	cmpq 	pr6|239
004002  aa   000007 6054 04	tpnz 	7,ic		004011
004003  aa  6 00174 2361 00	ldq  	pr6|124		local_line_type
004004  aa  6 00114 7271 00	lxl7 	pr6|76		i
004005  ta   777777 1160 17	cmpq 	-1,7
004006  aa   000003 6000 04	tze  	3,ic		004011
						STATEMENT 1 ON LINE 983
			end;

004007  aa  6 00114 0541 00	aos  	pr6|76		i
004010  aa   777770 7100 04	tra  	-8,ic		004000
						STATEMENT 1 ON LINE 985
			pcb.sync_line = (i <= n_sync_line_types);

004011  aa  6 00114 2361 00	ldq  	pr6|76		i
004012  aa   000012 1160 07	cmpq 	10,dl
004013  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
004014  aa   000004 7710 00	arl  	4
004015  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004016  aa  7 00004 6751 00	era  	pr7|4		pcb.sync_line
004017  aa   020000 3750 03	ana  	8192,du
004020  aa  7 00004 6551 00	ersa 	pr7|4		pcb.sync_line
						STATEMENT 1 ON LINE 986
		     end;

004021  aa   000144 7100 04	tra  	100,ic		004165
						STATEMENT 1 ON LINE 988
		else if opcode = dial		/* in this case we have to supply buffer size first */
		then do;

004022  aa   000014 1160 07	cmpq 	12,dl
004023  aa   000074 6010 04	tnz  	60,ic		004117
						STATEMENT 1 ON LINE 990
		     mbx_data_len = 36;

004024  aa   000044 2360 07	ldq  	36,dl
004025  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 991
		     alter_data = bit (bin (Set_buffer_size, 9), 9) || "000000001"b;

004026  aa   000032 2350 07	lda  	26,dl
004027  aa   000002 6050 04	tpl  	2,ic		004031
004030  aa   000000 5310 00	neg  	0
004031  aa   000033 7350 00	als  	27
004032  aa  6 00610 7551 00	sta  	pr6|392
004033  aa   000001 2350 03	lda  	1,du
004034  aa  6 00610 2751 00	ora  	pr6|392
004035  aa  6 00153 7551 00	sta  	pr6|107		alter_data
004036  aa   000022 2360 07	ldq  	18,dl
004037  aa  6 00152 7561 00	stq  	pr6|106		alter_data
						STATEMENT 1 ON LINE 992
		     mbx_data = alter_data || fnp_buf_size ();

004040  aa   004712 3520 04	epp2 	2506,ic		010752 = 000002000000
004041  aa   004160 6700 04	tsp4 	2160,ic		010221
004042  aa  6 00152 2361 00	ldq  	pr6|106		alter_data
004043  aa   000022 0760 07	adq  	18,dl
004044  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
004045  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
004046  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
004047  aa  6 00153 00 0017	descb	pr6|107,x7	alter_data
004050  aa  2 00000 00 0017	descb	pr2|0,x7
004051  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
004052  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
004053  aa  6 00610 00 0022	descb	pr6|392,18
004054  aa  2 00000 00 0022	descb	pr2|0,18
004055  aa  003 100 060 540	csl  	(pr,rl),(pr),fill(0),bool(move)
004056  aa  2 00000 00 0006	descb	pr2|0,ql
004057  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 993
		     call dn355$send_wcd (fnpp, pcbp, alter_parameters, mbx_data_len, mbx_data);

004060  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004061  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
004062  aa  6 00564 2521 00	spri2	pr6|372
004063  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
004064  aa  6 00566 2521 00	spri2	pr6|374
004065  aa   773725 3520 04	epp2 	-2091,ic		000012 = 000000000042
004066  aa  6 00570 2521 00	spri2	pr6|376
004067  aa  6 00141 3521 00	epp2 	pr6|97		mbx_data_len
004070  aa  6 00572 2521 00	spri2	pr6|378
004071  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
004072  aa  6 00574 2521 00	spri2	pr6|380
004073  aa   774073 3520 04	epp2 	-1989,ic		000166 = 464000000000
004074  aa  6 00576 2521 00	spri2	pr6|382
004075  aa  6 00600 2521 00	spri2	pr6|384
004076  aa   774050 3520 04	epp2 	-2008,ic		000146 = 404000000010
004077  aa  6 00602 2521 00	spri2	pr6|386
004100  aa   774070 3520 04	epp2 	-1992,ic		000170 = 404000000021
004101  aa  6 00604 2521 00	spri2	pr6|388
004102  aa   774033 3520 04	epp2 	-2021,ic		000135 = 516000000220
004103  aa  6 00606 2521 00	spri2	pr6|390
004104  aa  6 00562 6211 00	eax1 	pr6|370
004105  aa   024000 4310 07	fld  	10240,dl
004106  aa  6 00044 3701 20	epp4 	pr6|36,*
004107  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
004110  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 995
		     mbx_data_len = phone_no_len;

004111  aa  6 00175 2361 00	ldq  	pr6|125		phone_no_len
004112  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 996
		     mbx_data_long = string (phone_digits);

004113  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004114  aa  6 00176 00 0300	descb	pr6|126,192
004115  aa  6 00142 00 0440	descb	pr6|98,288	mbx_data_long
						STATEMENT 1 ON LINE 997
		end;

004116  aa   000047 7100 04	tra  	39,ic		004165
						STATEMENT 1 ON LINE 998
		else if opcode = report_meters
		then do;

004117  aa   000044 1160 07	cmpq 	36,dl
004120  aa   000045 6010 04	tnz  	37,ic		004165
						STATEMENT 1 ON LINE 1000
		     call tty_space_man$get_space (size (fnp_channel_meters), meter_ptr);

004121  aa   000032 2360 07	ldq  	26,dl
004122  aa  6 00610 7561 00	stq  	pr6|392
004123  aa  6 00610 3521 00	epp2 	pr6|392
004124  aa  6 00550 2521 00	spri2	pr6|360
004125  aa  6 00164 3521 00	epp2 	pr6|116		meter_ptr
004126  aa  6 00552 2521 00	spri2	pr6|362
004127  aa  6 00546 6211 00	eax1 	pr6|358
004130  aa   010000 4310 07	fld  	4096,dl
004131  aa  6 00044 3701 20	epp4 	pr6|36,*
004132  la  4 00134 3521 20	epp2 	pr4|92,*		tty_space_man$get_space
004133  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1002
		     if meter_ptr = null ()		/* couldn't get it */
		     then do;

004134  aa  6 00164 2371 00	ldaq 	pr6|116		meter_ptr
004135  aa   774071 6770 04	eraq 	-1991,ic		000226 = 077777000043 000001000000
004136  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004137  aa   000006 6010 04	tnz  	6,ic		004145
						STATEMENT 1 ON LINE 1004
			call unlock;

004140  aa   004036 6700 04	tsp4 	2078,ic		010176
						STATEMENT 1 ON LINE 1005
			a_code = error_table_$noalloc;

004141  aa  6 00044 3701 20	epp4 	pr6|36,*
004142  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$noalloc
004143  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1006
			return;

004144  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1007
		     end;

						STATEMENT 1 ON LINE 1009
		     pcb.copied_meters_offset = bin (rel (meter_ptr), 18);

004145  aa  6 00164 6351 20	eaa  	pr6|116,*		meter_ptr
004146  aa   000066 7730 00	lrl  	54
004147  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004150  aa  7 00007 7561 00	stq  	pr7|7		pcb.copied_meters_offset
						STATEMENT 1 ON LINE 1010
		     mbx_data = bit (bin (tty_buf.absorig + pcb.copied_meters_offset, 18), 18);

004151  aa  6 00300 3715 20	epp5 	pr6|192,*		ttybp
004152  aa  5 00001 0761 00	adq  	pr5|1		tty_buf.absorig
004153  aa   000003 6050 04	tpl  	3,ic		004156
004154  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
004155  aa   000001 0760 07	adq  	1,dl
004156  aa   000066 7370 00	lls  	54
004157  aa  6 00610 7551 00	sta  	pr6|392
004160  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004161  aa  6 00610 00 0022	descb	pr6|392,18
004162  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 1011
		     mbx_data_len = 18;

004163  aa   000022 2360 07	ldq  	18,dl
004164  aa  6 00141 7561 00	stq  	pr6|97		mbx_data_len
						STATEMENT 1 ON LINE 1012
		end;

						STATEMENT 1 ON LINE 1013
	     end;

						STATEMENT 1 ON LINE 1015
	     call dn355$send_wcd (fnpp, pcbp, opcode, mbx_data_len, mbx_data_long);

004165  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
004166  aa  6 00564 2521 00	spri2	pr6|372
004167  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
004170  aa  6 00566 2521 00	spri2	pr6|374
004171  aa  6 00136 3521 00	epp2 	pr6|94		opcode
004172  aa  6 00570 2521 00	spri2	pr6|376
004173  aa  6 00141 3521 00	epp2 	pr6|97		mbx_data_len
004174  aa  6 00572 2521 00	spri2	pr6|378
004175  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data_long
004176  aa  6 00574 2521 00	spri2	pr6|380
004177  aa   773767 3520 04	epp2 	-2057,ic		000166 = 464000000000
004200  aa  6 00576 2521 00	spri2	pr6|382
004201  aa  6 00600 2521 00	spri2	pr6|384
004202  aa   773744 3520 04	epp2 	-2076,ic		000146 = 404000000010
004203  aa  6 00602 2521 00	spri2	pr6|386
004204  aa   773764 3520 04	epp2 	-2060,ic		000170 = 404000000021
004205  aa  6 00604 2521 00	spri2	pr6|388
004206  aa   773726 3520 04	epp2 	-2090,ic		000134 = 516000000440
004207  aa  6 00606 2521 00	spri2	pr6|390
004210  aa  6 00562 6211 00	eax1 	pr6|370
004211  aa   024000 4310 07	fld  	10240,dl
004212  aa  6 00044 3701 20	epp4 	pr6|36,*
004213  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
004214  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1016
	end;

004215  aa   000262 7100 04	tra  	178,ic		004477
						STATEMENT 1 ON LINE 1018
	else do;

						STATEMENT 1 ON LINE 1019
	     if dumpin
	     then call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpinput, 9), 9));

004216  aa  6 00157 2351 00	lda  	pr6|111		dumpin
004217  aa   000040 6000 04	tze  	32,ic		004257
004220  aa   000011 2360 07	ldq  	9,dl
004221  aa  6 00610 7561 00	stq  	pr6|392
004222  aa   000026 2350 07	lda  	22,dl
004223  aa   000002 6050 04	tpl  	2,ic		004225
004224  aa   000000 5310 00	neg  	0
004225  aa   000033 7350 00	als  	27
004226  aa  6 00611 7551 00	sta  	pr6|393
004227  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
004230  aa  6 00564 2521 00	spri2	pr6|372
004231  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
004232  aa  6 00566 2521 00	spri2	pr6|374
004233  aa   773557 3520 04	epp2 	-2193,ic		000012 = 000000000042
004234  aa  6 00570 2521 00	spri2	pr6|376
004235  aa  6 00610 3521 00	epp2 	pr6|392
004236  aa  6 00572 2521 00	spri2	pr6|378
004237  aa  6 00611 3521 00	epp2 	pr6|393
004240  aa  6 00574 2521 00	spri2	pr6|380
004241  aa   773725 3520 04	epp2 	-2091,ic		000166 = 464000000000
004242  aa  6 00576 2521 00	spri2	pr6|382
004243  aa  6 00600 2521 00	spri2	pr6|384
004244  aa   773702 3520 04	epp2 	-2110,ic		000146 = 404000000010
004245  aa  6 00602 2521 00	spri2	pr6|386
004246  aa   773722 3520 04	epp2 	-2094,ic		000170 = 404000000021
004247  aa  6 00604 2521 00	spri2	pr6|388
004250  aa   773663 3520 04	epp2 	-2125,ic		000133 = 514000000011
004251  aa  6 00606 2521 00	spri2	pr6|390
004252  aa  6 00562 6211 00	eax1 	pr6|370
004253  aa   024000 4310 07	fld  	10240,dl
004254  aa  6 00044 3701 20	epp4 	pr6|36,*
004255  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
004256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1022
	     if dumpout
	     then do;

004257  aa  6 00160 2351 00	lda  	pr6|112		dumpout
004260  aa   000127 6000 04	tze  	87,ic		004407
						STATEMENT 1 ON LINE 1024
		if pcb.write_first ^= 0
		then do;

004261  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004262  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
004263  aa   000066 7330 00	lrs  	54
004264  aa   000033 6000 04	tze  	27,ic		004317
						STATEMENT 1 ON LINE 1026
		     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));

004265  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
004266  aa  6 00610 7561 00	stq  	pr6|392		pcb.write_first
004267  aa   000066 7330 00	lrs  	54
004270  aa  6 00611 7561 00	stq  	pr6|393
004271  aa  6 00610 2361 00	ldq  	pr6|392		pcb.write_first
004272  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
004273  aa   000000 3120 06	eawp2	0,ql
004274  aa  6 00630 2521 00	spri2	pr6|408
004275  aa  6 00611 3521 00	epp2 	pr6|393
004276  aa  6 00550 2521 00	spri2	pr6|360
004277  aa   773652 3520 04	epp2 	-2134,ic		000151 = 400000000000
004300  aa  6 00552 2521 00	spri2	pr6|362
004301  aa  6 00630 3521 00	epp2 	pr6|408
004302  aa  6 00554 2521 00	spri2	pr6|364
004303  aa  6 00546 6211 00	eax1 	pr6|358
004304  aa   014000 4310 07	fld  	6144,dl
004305  aa  6 00044 3701 20	epp4 	pr6|36,*
004306  la  4 00140 3521 20	epp2 	pr4|96,*		tty_space_man$free_chain
004307  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1027
		     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;

004310  aa   000000 2350 07	lda  	0,dl
004311  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004312  aa  7 00001 5511 60	stba 	pr7|1,60		pcb.write_first
004313  aa   000022 7710 00	arl  	18
004314  aa  7 00001 5511 14	stba 	pr7|1,14		pcb.write_last
004315  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
004316  aa  7 00003 5511 14	stba 	pr7|3,14		pcb.write_cnt
						STATEMENT 1 ON LINE 1028
		end;

						STATEMENT 1 ON LINE 1031
		call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpoutput, 9), 9));

004317  aa   000011 2360 07	ldq  	9,dl
004320  aa  6 00611 7561 00	stq  	pr6|393
004321  aa   000015 2350 07	lda  	13,dl
004322  aa   000002 6050 04	tpl  	2,ic		004324
004323  aa   000000 5310 00	neg  	0
004324  aa   000033 7350 00	als  	27
004325  aa  6 00610 7551 00	sta  	pr6|392
004326  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
004327  aa  6 00564 2521 00	spri2	pr6|372
004330  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
004331  aa  6 00566 2521 00	spri2	pr6|374
004332  aa   773460 3520 04	epp2 	-2256,ic		000012 = 000000000042
004333  aa  6 00570 2521 00	spri2	pr6|376
004334  aa  6 00611 3521 00	epp2 	pr6|393
004335  aa  6 00572 2521 00	spri2	pr6|378
004336  aa  6 00610 3521 00	epp2 	pr6|392
004337  aa  6 00574 2521 00	spri2	pr6|380
004340  aa   773626 3520 04	epp2 	-2154,ic		000166 = 464000000000
004341  aa  6 00576 2521 00	spri2	pr6|382
004342  aa  6 00600 2521 00	spri2	pr6|384
004343  aa   773603 3520 04	epp2 	-2173,ic		000146 = 404000000010
004344  aa  6 00602 2521 00	spri2	pr6|386
004345  aa   773623 3520 04	epp2 	-2157,ic		000170 = 404000000021
004346  aa  6 00604 2521 00	spri2	pr6|388
004347  aa   773564 3520 04	epp2 	-2188,ic		000133 = 514000000011
004350  aa  6 00606 2521 00	spri2	pr6|390
004351  aa  6 00562 6211 00	eax1 	pr6|370
004352  aa   024000 4310 07	fld  	10240,dl
004353  aa  6 00044 3701 20	epp4 	pr6|36,*
004354  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
004355  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1033
		if pcb.end_frame
		then do;

004356  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004357  aa  7 00004 2351 00	lda  	pr7|4		pcb.end_frame
004360  aa   010000 3150 03	cana 	4096,du
004361  aa   000026 6000 04	tze  	22,ic		004407
						STATEMENT 1 ON LINE 1035
		     pcb.end_frame = "0"b;

004362  aa   004366 2350 04	lda  	2294,ic		010750 = 767777777777
004363  aa  7 00004 3551 00	ansa 	pr7|4		pcb.end_frame
						STATEMENT 1 ON LINE 1036
		     if pcb.send_output
		     then call channel_manager$interrupt ((pcb.devx), SEND_OUTPUT, ""b);

004364  aa  7 00004 2351 00	lda  	pr7|4		pcb.send_output
004365  aa   100000 3150 03	cana 	32768,du
004366  aa   000021 6000 04	tze  	17,ic		004407
004367  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
004370  aa   000066 7330 00	lrs  	54
004371  aa  6 00610 7561 00	stq  	pr6|392
004372  aa   773616 2370 04	ldaq 	-2162,ic		000210 = 000000000000 000000000000
004373  aa  6 00630 7571 00	staq 	pr6|408
004374  aa  6 00610 3521 00	epp2 	pr6|392
004375  aa  6 00550 2521 00	spri2	pr6|360
004376  aa   773565 3520 04	epp2 	-2187,ic		000163 = 000000000004
004377  aa  6 00552 2521 00	spri2	pr6|362
004400  aa  6 00630 3521 00	epp2 	pr6|408
004401  aa  6 00554 2521 00	spri2	pr6|364
004402  aa  6 00546 6211 00	eax1 	pr6|358
004403  aa   014000 4310 07	fld  	6144,dl
004404  aa  6 00044 3701 20	epp4 	pr6|36,*
004405  la  4 00144 3521 20	epp2 	pr4|100,*		channel_manager$interrupt
004406  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1038
		end;

						STATEMENT 1 ON LINE 1039
	     end;

						STATEMENT 1 ON LINE 1041
	     if set_write_status
	     then opend = (pcb.write_first ^= 0);

004407  aa  6 00132 2351 00	lda  	pr6|90		set_write_status
004410  aa   000006 6000 04	tze  	6,ic		004416
004411  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004412  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
004413  aa   000066 7330 00	lrs  	54
004414  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
004415  aa  6 00206 7551 00	sta  	pr6|134		opend
						STATEMENT 1 ON LINE 1044
	     if get_meters
	     then do;

004416  aa  6 00161 2351 00	lda  	pr6|113		get_meters
004417  aa   000060 6000 04	tze  	48,ic		004477
						STATEMENT 1 ON LINE 1046
		call get_fnp_meters ("0"b);

004420  aa   000000 2350 07	lda  	0,dl
004421  aa  6 00610 7551 00	sta  	pr6|392
004422  aa   004330 3520 04	epp2 	2264,ic		010752 = 000002000000
004423  aa   002704 6700 04	tsp4 	1476,ic		007327
						STATEMENT 1 ON LINE 1047
		call unlock;

004424  aa   003552 6700 04	tsp4 	1898,ic		010176
						STATEMENT 1 ON LINE 1049
		if code = 0
		then ret_meters_ptr -> fnp_chan_meter_struc.synchronous = pcb.sync_line;

004425  aa  6 00100 2361 00	ldq  	pr6|64		code
004426  aa   000010 6010 04	tnz  	8,ic		004436
004427  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004430  aa  7 00004 2351 00	lda  	pr7|4		pcb.sync_line
004431  aa   000004 7350 00	als  	4
004432  aa  6 00172 3715 20	epp5 	pr6|122,*		ret_meters_ptr
004433  aa  5 00001 6751 00	era  	pr5|1		fnp_chan_meter_struc.synchronous
004434  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
004435  aa  5 00001 6551 00	ersa 	pr5|1		fnp_chan_meter_struc.synchronous
						STATEMENT 1 ON LINE 1051
		if fnp_meters_ptr ^= null ()
		then do;

004436  aa  6 00170 2371 00	ldaq 	pr6|120		fnp_meters_ptr
004437  aa   773567 6770 04	eraq 	-2185,ic		000226 = 077777000043 000001000000
004440  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004441  aa   000036 6000 04	tze  	30,ic		004477
						STATEMENT 1 ON LINE 1053
		     if unspec (fnp_meters_ptr -> fnp_channel_meters) = "0"b
		     then code = error_table_$no_channel_meters;

004442  aa  6 00170 3735 20	epp7 	pr6|120,*		fnp_meters_ptr
004443  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
004444  aa  7 00000 00 1650	descb	pr7|0,936
004445  aa   000000 00 0000	descb	0,0
004446  aa   000005 6010 04	tnz  	5,ic		004453
004447  aa  6 00044 3701 20	epp4 	pr6|36,*
004450  la  4 00106 2361 20	ldq  	pr4|70,*		error_table_$no_channel_meters
004451  aa  6 00100 7561 00	stq  	pr6|64		code
004452  aa   000012 7100 04	tra  	10,ic		004464
						STATEMENT 1 ON LINE 1055
		     else do;

						STATEMENT 1 ON LINE 1056
			ret_meters_ptr -> fnp_chan_meter_struc.current_meters =
			     fnp_meters_ptr -> fnp_channel_meters;

004453  aa  6 00172 3715 20	epp5 	pr6|122,*		ret_meters_ptr
004454  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004455  aa  7 00000 00 0150	desc9a	pr7|0,104		fnp_channel_meters
004456  aa  5 00002 00 0150	desc9a	pr5|2,104		fnp_chan_meter_struc.current_meters
						STATEMENT 1 ON LINE 1058
			ret_meters_ptr -> fnp_chan_meter_struc.saved_meters =
			     pcb.saved_meters_ptr -> fnp_channel_meters;

004457  aa  6 00320 3535 20	epp3 	pr6|208,*		pcbp
004460  aa  3 00006 7631 00	lprp3	pr3|6		pcb.saved_meters_ptr
004461  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004462  aa  3 00000 00 0150	desc9a	pr3|0,104		fnp_channel_meters
004463  aa  5 00034 00 0150	desc9a	pr5|28,104	fnp_chan_meter_struc.saved_meters
						STATEMENT 1 ON LINE 1060
		     end;

						STATEMENT 1 ON LINE 1062
		     call tty_space_man$free_space (size (fnp_channel_meters), fnp_meters_ptr);

004464  aa   000032 2360 07	ldq  	26,dl
004465  aa  6 00610 7561 00	stq  	pr6|392
004466  aa  6 00610 3521 00	epp2 	pr6|392
004467  aa  6 00550 2521 00	spri2	pr6|360
004470  aa  6 00170 3521 00	epp2 	pr6|120		fnp_meters_ptr
004471  aa  6 00552 2521 00	spri2	pr6|362
004472  aa  6 00546 6211 00	eax1 	pr6|358
004473  aa   010000 4310 07	fld  	4096,dl
004474  aa  6 00044 3701 20	epp4 	pr6|36,*
004475  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
004476  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1063
		end;

						STATEMENT 1 ON LINE 1064
	     end;

						STATEMENT 1 ON LINE 1065
	end;

						STATEMENT 1 ON LINE 1067
	call unlock;

004477  aa   003477 6700 04	tsp4 	1855,ic		010176
						STATEMENT 1 ON LINE 1068
	if set_write_status
	then data_ptr -> wr_stat.output_pending = opend;

004500  aa  6 00132 2351 00	lda  	pr6|90		set_write_status
004501  aa   000004 6000 04	tze  	4,ic		004505
004502  aa  6 00206 2351 00	lda  	pr6|134		opend
004503  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
004504  aa  7 00002 7551 00	sta  	pr7|2		wr_stat.output_pending
						STATEMENT 1 ON LINE 1070
	a_code = code;

004505  aa  6 00100 2361 00	ldq  	pr6|64		code
004506  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1072
	return;

004507  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO check_modes                                        STATEMENT 1 ON LINE 1074
check_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

004510  ta     002520000000
004511  da     000654300000
004512  aa   001420 6270 00	eax7 	784
004513  aa  7 00034 3521 20	epp2 	pr7|28,*
004514  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004515  aa     000010000000
004516  aa     000000000000
004517  aa  6 00032 3735 20	epp7 	pr6|26,*
004520  aa  7 00002 3715 20	epp5 	pr7|2,*
004521  aa  6 00340 6515 00	spri5	pr6|224
004522  aa  7 00010 3535 20	epp3 	pr7|8,*
004523  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 1079
	fnpp = a_fnpp;

004524  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
004525  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
004526  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1080
	chanx = a_subchan;

004527  aa  6 00032 3715 20	epp5 	pr6|26,*
004530  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
004531  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 1081
	mclp = a_mode_list_ptr;

004532  aa  5 00006 3535 20	epp3 	pr5|6,*		a_mode_list_ptr
004533  aa  3 00000 3535 20	epp3 	pr3|0,*		a_mode_list_ptr
004534  aa  6 00326 2535 00	spri3	pr6|214		mclp
						STATEMENT 1 ON LINE 1082
	if mcl.version ^= mcl_version_2
	then do;

004535  aa  3 00000 2361 00	ldq  	pr3|0		mcl.version
004536  aa   000002 1160 07	cmpq 	2,dl
004537  aa   000005 6000 04	tze  	5,ic		004544
						STATEMENT 1 ON LINE 1084
	     a_code = error_table_$unimplemented_version;

004540  aa  6 00044 3701 20	epp4 	pr6|36,*
004541  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$unimplemented_version
004542  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1085
	     return;

004543  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1086
	end;

						STATEMENT 1 ON LINE 1088
	call setup;

004544  aa   001535 6700 04	tsp4 	861,ic		006301
						STATEMENT 1 ON LINE 1089
	if code ^= 0
	then do;

004545  aa  6 00100 2361 00	ldq  	pr6|64		code
004546  aa   000003 6000 04	tze  	3,ic		004551
						STATEMENT 1 ON LINE 1091
	     a_code = code;

004547  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1092
	     return;

004550  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1093
	end;

						STATEMENT 1 ON LINE 1095
	do modex = 1 to mcl.n_entries;

004551  aa  6 00326 3735 20	epp7 	pr6|214,*		mclp
004552  aa  7 00001 2361 00	ldq  	pr7|1		mcl.n_entries
004553  aa  6 00360 7561 00	stq  	pr6|240
004554  aa   000001 2360 07	ldq  	1,dl
004555  aa  6 00207 7561 00	stq  	pr6|135		modex
004556  aa  6 00207 2361 00	ldq  	pr6|135		modex
004557  aa  6 00360 1161 00	cmpq 	pr6|240
004560  aa   000202 6054 04	tpnz 	130,ic		004762
						STATEMENT 1 ON LINE 1096
	     mclep = addr (mcl.entries (modex));

004561  aa   000005 4020 07	mpy  	5,dl
004562  aa  6 00326 3735 20	epp7 	pr6|214,*		mclp
004563  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
004564  aa  6 00330 6535 00	spri7	pr6|216		mclep
						STATEMENT 1 ON LINE 1097
	     mode_name = substr (mcle.mode_name, 1, 8);

004565  aa  7 00000 2351 00	lda  	pr7|0		mcle.mode_name
004566  aa  7 00001 2361 00	ldq  	pr7|1		mcle.mode_name
004567  aa  6 00210 7571 00	staq 	pr6|136		mode_name
						STATEMENT 1 ON LINE 1098
	     mode_on = mcle.mode_switch;

004570  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
004571  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
004572  aa  6 00212 7551 00	sta  	pr6|138		mode_on
						STATEMENT 1 ON LINE 1100
	     do i = 1 to hbound (good_modes, 1) while (mode_name ^= good_modes (i));

004573  aa   000001 2360 07	ldq  	1,dl
004574  aa  6 00114 7561 00	stq  	pr6|76		i
004575  aa   000000 0110 03	nop  	0,du
004576  aa  6 00114 2361 00	ldq  	pr6|76		i
004577  aa   000001 1160 07	cmpq 	1,dl
004600  aa   000012 6054 04	tpnz 	10,ic		004612
004601  aa   000001 7360 00	qls  	1
004602  aa   000000 6270 06	eax7 	0,ql
004603  aa  6 00210 2371 00	ldaq 	pr6|136		mode_name
004604  ta   000104 1150 17	cmpa 	68,7
004605  aa   000002 6010 04	tnz  	2,ic		004607
004606  ta   000105 1160 17	cmpq 	69,7
004607  aa   000003 6000 04	tze  	3,ic		004612
						STATEMENT 1 ON LINE 1101
	     end;

004610  aa  6 00114 0541 00	aos  	pr6|76		i
004611  aa   777765 7100 04	tra  	-11,ic		004576
						STATEMENT 1 ON LINE 1103
	     if i <= hbound (good_modes, 1)		/* tree */
						/* it's one of the ones we always recognize */
	     then mcle.mpx_mode = "1"b;

004612  aa  6 00114 2361 00	ldq  	pr6|76		i
004613  aa   000001 1160 07	cmpq 	1,dl
004614  aa   000005 6054 04	tpnz 	5,ic		004621
004615  aa   100000 2350 03	lda  	32768,du
004616  aa  6 00330 3735 20	epp7 	pr6|216,*		mclep
004617  aa  7 00004 2551 00	orsa 	pr7|4		mcle.mpx_mode
004620  aa   000140 7100 04	tra  	96,ic		004760
						STATEMENT 1 ON LINE 1106
	     else do;

						STATEMENT 1 ON LINE 1107
		do i = 1 to hbound (async_only_modes, 1) while (mode_name ^= async_only_modes (i));

004621  aa   000001 2360 07	ldq  	1,dl
004622  aa  6 00114 7561 00	stq  	pr6|76		i
004623  aa   000000 0110 03	nop  	0,du
004624  aa  6 00114 2361 00	ldq  	pr6|76		i
004625  aa   000017 1160 07	cmpq 	15,dl
004626  aa   000012 6054 04	tpnz 	10,ic		004640
004627  aa   000001 7360 00	qls  	1
004630  aa   000000 6270 06	eax7 	0,ql
004631  aa  6 00210 2371 00	ldaq 	pr6|136		mode_name
004632  ta   000046 1150 17	cmpa 	38,7
004633  aa   000002 6010 04	tnz  	2,ic		004635
004634  ta   000047 1160 17	cmpq 	39,7
004635  aa   000003 6000 04	tze  	3,ic		004640
						STATEMENT 1 ON LINE 1108
		end;

004636  aa  6 00114 0541 00	aos  	pr6|76		i
004637  aa   777765 7100 04	tra  	-11,ic		004624
						STATEMENT 1 ON LINE 1110
		if i > hbound (async_only_modes, 1)	/* we've never heard of this one at all */
		then mcle.mpx_mode = "0"b;

004640  aa  6 00114 2361 00	ldq  	pr6|76		i
004641  aa   000017 1160 07	cmpq 	15,dl
004642  aa   000005 6044 04	tmoz 	5,ic		004647
004643  aa   004116 2350 04	lda  	2126,ic		010761 = 677777777777
004644  aa  6 00330 3735 20	epp7 	pr6|216,*		mclep
004645  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
004646  aa   000112 7100 04	tra  	74,ic		004760
						STATEMENT 1 ON LINE 1112
		else do;

						STATEMENT 1 ON LINE 1113
		     mcle.mpx_mode = ^pcb.sync_line;

004647  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004650  aa  7 00004 2351 00	lda  	pr7|4		pcb.sync_line
004651  aa   000004 7350 00	als  	4
004652  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
004653  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
004654  aa   000002 7710 00	arl  	2
004655  aa  6 00330 3715 20	epp5 	pr6|216,*		mclep
004656  aa  5 00004 6751 00	era  	pr5|4		mcle.mpx_mode
004657  aa   100000 3750 03	ana  	32768,du
004660  aa  5 00004 6551 00	ersa 	pr5|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 1115
		     do i = 1 to hbound (full_dpx_modes, 1) while (mode_name ^= full_dpx_modes (i));

004661  aa   000001 2360 07	ldq  	1,dl
004662  aa  6 00114 7561 00	stq  	pr6|76		i
004663  aa   000000 0110 03	nop  	0,du
004664  aa  6 00114 2361 00	ldq  	pr6|76		i
004665  aa   000007 1160 07	cmpq 	7,dl
004666  aa   000012 6054 04	tpnz 	10,ic		004700
004667  aa   000001 7360 00	qls  	1
004670  aa   000000 6270 06	eax7 	0,ql
004671  aa  6 00210 2371 00	ldaq 	pr6|136		mode_name
004672  ta   000030 1150 17	cmpa 	24,7
004673  aa   000002 6010 04	tnz  	2,ic		004675
004674  ta   000031 1160 17	cmpq 	25,7
004675  aa   000003 6000 04	tze  	3,ic		004700
						STATEMENT 1 ON LINE 1116
		     end;

004676  aa  6 00114 0541 00	aos  	pr6|76		i
004677  aa   777765 7100 04	tra  	-11,ic		004664
						STATEMENT 1 ON LINE 1118
		     if (mode_name = "no_outp" | mode_name = "8bit" | mode_name = "oddp") & mode_on
		     then if ^pcb.is_hsla
			then go to bad_mode;

004700  aa   773306 2370 04	ldaq 	-2362,ic		000206 = 156157137157 165164160000
004701  aa  0 00456 2771 00	oraq 	pr0|302		= 000000000000 000000000040
004702  aa  6 00210 1171 00	cmpaq	pr6|136		mode_name
004703  aa   000013 6000 04	tze  	11,ic		004716
004704  aa   773226 2350 04	lda  	-2410,ic		000132 = 070142151164
004705  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
004706  aa  0 00450 2771 00	oraq 	pr0|296		= 000000000000 040040040040
004707  aa  6 00210 1171 00	cmpaq	pr6|136		mode_name
004710  aa   000006 6000 04	tze  	6,ic		004716
004711  aa   773220 2350 04	lda  	-2416,ic		000131 = 157144144160
004712  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
004713  aa  0 00450 2771 00	oraq 	pr0|296		= 000000000000 040040040040
004714  aa  6 00210 1171 00	cmpaq	pr6|136		mode_name
004715  aa   000006 6010 04	tnz  	6,ic		004723
004716  aa  6 00212 2351 00	lda  	pr6|138		mode_on
004717  aa   000004 6000 04	tze  	4,ic		004723
004720  aa  6 00320 2351 20	lda  	pr6|208,*		pcb.is_hsla
004721  aa   001000 3150 07	cana 	512,dl
004722  aa   000022 6000 04	tze  	18,ic		004744
						STATEMENT 1 ON LINE 1122
		     if i <= hbound (full_dpx_modes, 1) /* if this was a mode requiring full duplex capability */
		     then if mode_on
			then if pcb.line_type ^= LINE_ASCII & pcb.line_type ^= LINE_ASYNC1
				& pcb.line_type ^= LINE_ASYNC2 & pcb.line_type ^= LINE_ASYNC3
			     then do;

004723  aa  6 00114 2361 00	ldq  	pr6|76		i
004724  aa   000007 1160 07	cmpq 	7,dl
004725  aa   000033 6054 04	tpnz 	27,ic		004760
004726  aa  6 00212 2351 00	lda  	pr6|138		mode_on
004727  aa   000031 6000 04	tze  	25,ic		004760
004730  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
004731  aa  7 00002 2351 00	lda  	pr7|2		pcb.line_type
004732  aa   000022 7350 00	als  	18
004733  aa   000066 7330 00	lrs  	54
004734  aa   000001 1160 07	cmpq 	1,dl
004735  aa   000023 6000 04	tze  	19,ic		004760
004736  aa   000012 1160 07	cmpq 	10,dl
004737  aa   000021 6000 04	tze  	17,ic		004760
004740  aa   000013 1160 07	cmpq 	11,dl
004741  aa   000017 6000 04	tze  	15,ic		004760
004742  aa   000014 1160 07	cmpq 	12,dl
004743  aa   000015 6000 04	tze  	13,ic		004760
						STATEMENT 1 ON LINE 1127
bad_mode:
				if mcle.force
				then mcle.mpx_mode = "0"b;

004744  aa  6 00330 3735 20	epp7 	pr6|216,*		mclep
004745  aa  7 00004 2351 00	lda  	pr7|4		mcle.force
004746  aa   200000 3150 03	cana 	65536,du
004747  aa   000004 6000 04	tze  	4,ic		004753
004750  aa   004011 2350 04	lda  	2057,ic		010761 = 677777777777
004751  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
004752  aa   000006 7100 04	tra  	6,ic		004760
						STATEMENT 1 ON LINE 1130
				else do;

						STATEMENT 1 ON LINE 1131
				     code = error_table_$bad_mode;

004753  aa  6 00044 3701 20	epp4 	pr6|36,*
004754  la  4 00064 2361 20	ldq  	pr4|52,*		error_table_$bad_mode
004755  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1132
				     mcle.error = "1"b;

004756  aa   040000 2350 03	lda  	16384,du
004757  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 1133
				end;

						STATEMENT 1 ON LINE 1134
			     end;

						STATEMENT 1 ON LINE 1136
		end;

						STATEMENT 1 ON LINE 1137
	     end;

						STATEMENT 1 ON LINE 1138
	end;

004760  aa  6 00207 0541 00	aos  	pr6|135		modex
004761  aa   777575 7100 04	tra  	-131,ic		004556
						STATEMENT 1 ON LINE 1140
	call unlock;

004762  aa   003214 6700 04	tsp4 	1676,ic		010176
						STATEMENT 1 ON LINE 1141
	a_code = code;

004763  aa  6 00100 2361 00	ldq  	pr6|64		code
004764  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1142
	return;

004765  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_modes                                          STATEMENT 1 ON LINE 1144
set_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

004766  ta     002520000000
004767  da     000662300000
004770  aa   001420 6270 00	eax7 	784
004771  aa  7 00034 3521 20	epp2 	pr7|28,*
004772  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004773  aa     000010000000
004774  aa     000000000000
004775  aa  6 00032 3735 20	epp7 	pr6|26,*
004776  aa  7 00002 3715 20	epp5 	pr7|2,*
004777  aa  6 00340 6515 00	spri5	pr6|224
005000  aa  7 00010 3535 20	epp3 	pr7|8,*
005001  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 1149
	fnpp = a_fnpp;

005002  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
005003  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
005004  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1150
	chanx = a_subchan;

005005  aa  6 00032 3715 20	epp5 	pr6|26,*
005006  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
005007  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 1151
	mclp = a_mode_list_ptr;

005010  aa  5 00006 3535 20	epp3 	pr5|6,*		a_mode_list_ptr
005011  aa  3 00000 3535 20	epp3 	pr3|0,*		a_mode_list_ptr
005012  aa  6 00326 2535 00	spri3	pr6|214		mclp
						STATEMENT 1 ON LINE 1152
	if mcl.version ^= mcl_version_2
	then do;

005013  aa  3 00000 2361 00	ldq  	pr3|0		mcl.version
005014  aa   000002 1160 07	cmpq 	2,dl
005015  aa   000005 6000 04	tze  	5,ic		005022
						STATEMENT 1 ON LINE 1154
	     a_code = error_table_$unimplemented_version;

005016  aa  6 00044 3701 20	epp4 	pr6|36,*
005017  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$unimplemented_version
005020  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1155
	     return;

005021  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1156
	end;

						STATEMENT 1 ON LINE 1158
	call setup;

005022  aa   001257 6700 04	tsp4 	687,ic		006301
						STATEMENT 1 ON LINE 1159
	if code ^= 0
	then do;

005023  aa  6 00100 2361 00	ldq  	pr6|64		code
005024  aa   000003 6000 04	tze  	3,ic		005027
						STATEMENT 1 ON LINE 1161
	     a_code = code;

005025  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1162
	     return;

005026  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1163
	end;

						STATEMENT 1 ON LINE 1165
	hndlquit_set = "0"b;

005027  aa  6 00214 4501 00	stz  	pr6|140		hndlquit_set
						STATEMENT 1 ON LINE 1166
	string (mode_set) = "0"b;

005030  aa  6 00213 4501 00	stz  	pr6|139
						STATEMENT 1 ON LINE 1168
	do modex = 1 to mcl.n_entries;

005031  aa  6 00326 3735 20	epp7 	pr6|214,*		mclp
005032  aa  7 00001 2361 00	ldq  	pr7|1		mcl.n_entries
005033  aa  6 00361 7561 00	stq  	pr6|241
005034  aa   000001 2360 07	ldq  	1,dl
005035  aa  6 00207 7561 00	stq  	pr6|135		modex
005036  aa  6 00207 2361 00	ldq  	pr6|135		modex
005037  aa  6 00361 1161 00	cmpq 	pr6|241
005040  aa   000026 6054 04	tpnz 	22,ic		005066
						STATEMENT 1 ON LINE 1169
	     mclep = addr (mcl.entries (modex));

005041  aa   000005 4020 07	mpy  	5,dl
005042  aa  6 00326 3735 20	epp7 	pr6|214,*		mclp
005043  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
005044  aa  6 00330 6535 00	spri7	pr6|216		mclep
						STATEMENT 1 ON LINE 1170
	     if mcle.mpx_mode			/* if this is one we're interested in */
	     then call process_mode (mcle.mode_name, mcle.mode_switch);

005045  aa  7 00004 2351 00	lda  	pr7|4		mcle.mpx_mode
005046  aa   100000 3150 03	cana 	32768,du
005047  aa   000015 6000 04	tze  	13,ic		005064
005050  aa  7 00000 3521 00	epp2 	pr7|0		mcle.mode_name
005051  aa  6 00614 2521 00	spri2	pr6|396
005052  aa  7 00004 3521 00	epp2 	pr7|4		mcle.mode_switch
005053  aa  6 00616 2521 00	spri2	pr6|398
005054  aa   773054 3520 04	epp2 	-2516,ic		000130 = 526000000020
005055  aa  6 00620 2521 00	spri2	pr6|400
005056  aa   773071 3520 04	epp2 	-2503,ic		000147 = 516000000001
005057  aa  6 00622 2521 00	spri2	pr6|402
005060  aa  6 00612 3521 00	epp2 	pr6|394
005061  aa   010000 4310 07	fld  	4096,dl
005062  aa  2 00000 7571 00	staq 	pr2|0
005063  aa   001537 6700 04	tsp4 	863,ic		006622
						STATEMENT 1 ON LINE 1172
	end;

005064  aa  6 00207 0541 00	aos  	pr6|135		modex
005065  aa   777751 7100 04	tra  	-23,ic		005036
						STATEMENT 1 ON LINE 1174
	if mcl.init
	then do;

005066  aa  6 00326 3735 20	epp7 	pr6|214,*		mclp
005067  aa  7 00005 2351 00	lda  	pr7|5		mcl.init
005070  aa   400000 3150 03	cana 	131072,du
005071  aa   000045 6000 04	tze  	37,ic		005136
						STATEMENT 1 ON LINE 1176
	     if ^hndlquit_set
	     then call process_mode ("hndlquit", "0"b);

005072  aa  6 00214 2351 00	lda  	pr6|140		hndlquit_set
005073  aa   000010 6010 04	tnz  	8,ic		005103
005074  aa   773110 2370 04	ldaq 	-2488,ic		000204 = 150156144154 161165151164
005075  aa  6 00630 7571 00	staq 	pr6|408
005076  aa   000000 2350 07	lda  	0,dl
005077  aa  6 00610 7551 00	sta  	pr6|392
005100  aa   003636 3520 04	epp2 	1950,ic		010736 = 000004000000
005101  aa  2 00000 2351 00	lda  	pr2|0
005102  aa   001520 6700 04	tsp4 	848,ic		006622
						STATEMENT 1 ON LINE 1179
	     do modex = 1 to hbound (async_only_modes, 1);

005103  aa   000001 2360 07	ldq  	1,dl
005104  aa  6 00207 7561 00	stq  	pr6|135		modex
005105  aa   000000 0110 03	nop  	0,du
005106  aa  6 00207 2361 00	ldq  	pr6|135		modex
005107  aa   000017 1160 07	cmpq 	15,dl
005110  aa   000026 6054 04	tpnz 	22,ic		005136
						STATEMENT 1 ON LINE 1180
		if ^mode_set (modex)
		then call process_mode (async_only_modes (modex), "0"b);

005111  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
005112  aa  6 00212 70 0001	descb	pr6|138(35),1	mode_set
005113  aa   000000 00 0000	descb	0,0
005114  aa   000020 6010 04	tnz  	16,ic		005134
005115  aa   000001 7360 00	qls  	1
005116  aa   000000 2350 07	lda  	0,dl
005117  aa  6 00610 7551 00	sta  	pr6|392
005120  ta   000046 3520 06	epp2 	38,ql
005121  aa  6 00614 2521 00	spri2	pr6|396
005122  aa  6 00610 3521 00	epp2 	pr6|392
005123  aa  6 00616 2521 00	spri2	pr6|398
005124  aa   773003 3520 04	epp2 	-2557,ic		000127 = 526000000010
005125  aa  6 00620 2521 00	spri2	pr6|400
005126  aa   773036 3520 04	epp2 	-2530,ic		000164 = 514000000001
005127  aa  6 00622 2521 00	spri2	pr6|402
005130  aa  6 00612 3521 00	epp2 	pr6|394
005131  aa   010000 4310 07	fld  	4096,dl
005132  aa  2 00000 7571 00	staq 	pr2|0
005133  aa   001467 6700 04	tsp4 	823,ic		006622
						STATEMENT 1 ON LINE 1182
	     end;

005134  aa  6 00207 0541 00	aos  	pr6|135		modex
005135  aa   777751 7100 04	tra  	-23,ic		005106
						STATEMENT 1 ON LINE 1183
	end;

						STATEMENT 1 ON LINE 1185
	call unlock;

005136  aa   003040 6700 04	tsp4 	1568,ic		010176
						STATEMENT 1 ON LINE 1186
	a_code = code;

005137  aa  6 00100 2361 00	ldq  	pr6|64		code
005140  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1187
	return;

005141  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_modes                                          STATEMENT 1 ON LINE 1191
get_modes:
     entry (a_fnpp, a_subchan, a_modes, a_code);

005142  at     000004000166
005143  tt     000170000161
005144  ta     000162000000
005145  ta     005142000000
005146  da     000670300000
005147  aa   001420 6270 00	eax7 	784
005150  aa  7 00034 3521 20	epp2 	pr7|28,*
005151  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
005152  aa     000010000000
005153  aa     000000000000
005154  aa  6 00042 3735 20	epp7 	pr6|34,*
005155  aa  7 00004 2361 20	ldq  	pr7|4,*
005156  aa   000002 6040 04	tmi  	2,ic		005160
005157  aa   777777 3760 07	anq  	262143,dl
005160  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
005161  aa  6 00632 7561 00	stq  	pr6|410
005162  aa  6 00032 3715 20	epp5 	pr6|26,*
005163  aa  5 00002 3535 20	epp3 	pr5|2,*
005164  aa  6 00340 2535 00	spri3	pr6|224
005165  aa  5 00010 3515 20	epp1 	pr5|8,*
005166  aa  6 00342 2515 00	spri1	pr6|226
						STATEMENT 1 ON LINE 1196
	a_modes = "";

005167  aa  6 00032 3735 20	epp7 	pr6|26,*
005170  aa  7 00006 3715 20	epp5 	pr7|6,*
005171  aa  6 00632 2351 00	lda  	pr6|410
005172  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
005173  aa   000000 00 0000	desc9a	0,0
005174  aa  5 00000 00 0005	desc9a	pr5|0,al		a_modes
						STATEMENT 1 ON LINE 1197
	a_code = 0;

005175  aa  6 00342 4501 20	stz  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1198
	return;

005176  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO priv_control                                       STATEMENT 1 ON LINE 1200
priv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

005177  at     000004000166
005200  tt     000161000166
005201  ta     000162000000
005202  ta     005177000000
005203  da     000677300000
005204  aa   001420 6270 00	eax7 	784
005205  aa  7 00034 3521 20	epp2 	pr7|28,*
005206  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
005207  aa     000010000000
005210  aa     000000000000
005211  aa  6 00032 3735 20	epp7 	pr6|26,*
005212  aa  7 00002 3715 20	epp5 	pr7|2,*
005213  aa  6 00340 6515 00	spri5	pr6|224
005214  aa  7 00004 3535 20	epp3 	pr7|4,*
005215  aa  6 00346 2535 00	spri3	pr6|230
005216  aa  6 00042 3515 20	epp1 	pr6|34,*
005217  aa  1 00002 3715 20	epp5 	pr1|2,*
005220  aa  6 00344 6515 00	spri5	pr6|228
005221  aa  7 00006 3535 20	epp3 	pr7|6,*
005222  aa  6 00350 2535 00	spri3	pr6|232
005223  aa  7 00010 3515 20	epp1 	pr7|8,*
005224  aa  6 00342 2515 00	spri1	pr6|226
						STATEMENT 1 ON LINE 1205
	fnpp = a_fnpp;

005225  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
005226  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
005227  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1206
	order = a_order;

005230  aa  6 00344 2361 20	ldq  	pr6|228,*
005231  aa   000002 6040 04	tmi  	2,ic		005233
005232  aa   777777 3760 07	anq  	262143,dl
005233  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
005234  aa  6 00346 3715 20	epp5 	pr6|230,*
005235  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
005236  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_order
005237  aa  6 00120 00 0040	desc9a	pr6|80,32		order
						STATEMENT 1 ON LINE 1207
	data_ptr = a_data_ptr;

005240  aa  6 00350 3535 20	epp3 	pr6|232,*		a_data_ptr
005241  aa  3 00000 3535 20	epp3 	pr3|0,*		a_data_ptr
005242  aa  6 00130 2535 00	spri3	pr6|88		data_ptr
						STATEMENT 1 ON LINE 1209
	if order = "dump_fnp"
	then do;

005243  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
005244  aa  6 00120 00 0040	desc9a	pr6|80,32		order
005245  aa   772737 00 0010	desc9a	-2593,8		000202 = 144165155160
005246  aa   000064 6010 04	tnz  	52,ic		005332
						STATEMENT 1 ON LINE 1211
	     call setup_fnp;

005247  aa   001077 6700 04	tsp4 	575,ic		006346
						STATEMENT 1 ON LINE 1212
	     if code ^= 0
	     then do;

005250  aa  6 00100 2361 00	ldq  	pr6|64		code
005251  aa   000003 6000 04	tze  	3,ic		005254
						STATEMENT 1 ON LINE 1214
		a_code = code;

005252  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1215
		return;

005253  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1216
	     end;

						STATEMENT 1 ON LINE 1218
	     locked = "0"b;

005254  aa  6 00133 4501 00	stz  	pr6|91		locked
						STATEMENT 1 ON LINE 1219
	     call send_global (dump_mem);

005255  aa   003455 3520 04	epp2 	1837,ic		010732 = 000002000000
005256  aa   001650 6700 04	tsp4 	936,ic		007126
						STATEMENT 1 ON LINE 1220
	     if code ^= 0
	     then go to end_dump_mem;

005257  aa  6 00100 2361 00	ldq  	pr6|64		code
005260  aa   000024 6010 04	tnz  	20,ic		005304
						STATEMENT 1 ON LINE 1225
	     n_fnp_words = dump_fnp_info.fnp_len;

005261  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
005262  aa  7 00001 2361 00	ldq  	pr7|1		dump_fnp_info.fnp_len
005263  aa  6 00235 7561 00	stq  	pr6|157		n_fnp_words
						STATEMENT 1 ON LINE 1226
	     dump_fnp_info.bufp -> fnp_data = fnp_dump_ptr -> fnp_data;

005264  aa   000022 4020 07	mpy  	18,dl
005265  aa   000043 0760 07	adq  	35,dl
005266  aa   000044 5060 07	div  	36,dl
005267  aa  0 00553 7001 00	tsx0 	pr0|363		alloc_temp
005270  aa  6 00630 2521 00	spri2	pr6|408
005271  aa  6 00235 2361 00	ldq  	pr6|157		n_fnp_words
005272  aa   000022 4020 07	mpy  	18,dl
005273  aa  6 00630 3715 20	epp5 	pr6|408,*
005274  aa  6 00250 3535 20	epp3 	pr6|168,*		fnp_dump_ptr
005275  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
005276  aa  3 00000 00 0006	descb	pr3|0,ql		fnp_data
005277  aa  5 00000 00 0006	descb	pr5|0,ql
005300  aa  7 00002 3515 20	epp1 	pr7|2,*		dump_fnp_info.bufp
005301  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
005302  aa  5 00000 00 0006	descb	pr5|0,ql
005303  aa  1 00000 00 0006	descb	pr1|0,ql		fnp_data
						STATEMENT 1 ON LINE 1228
end_dump_mem:
	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);

005304  aa  6 00610 7561 00	stq  	pr6|392
005305  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
005306  aa  6 00100 2361 00	ldq  	pr6|64		code
005307  aa  6 00044 3701 20	epp4 	pr6|36,*
005310  la  4 00102 1161 20	cmpq 	pr4|66,*		error_table_$timeout
005311  aa   000011 6000 04	tze  	9,ic		005322
005312  aa  6 00252 3521 00	epp2 	pr6|170		dump_patch_space
005313  aa  6 00550 2521 00	spri2	pr6|360
005314  aa  6 00250 3521 00	epp2 	pr6|168		fnp_dump_ptr
005315  aa  6 00552 2521 00	spri2	pr6|362
005316  aa  6 00546 6211 00	eax1 	pr6|358
005317  aa   010000 4310 07	fld  	4096,dl
005320  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
005321  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1232
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);

005322  aa   000000 2350 07	lda  	0,dl
005323  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
005324  aa  7 00044 3521 00	epp2 	pr7|36		fnp_info.dump_patch_lock
005325  aa  6 00044 3701 20	epp4 	pr6|36,*
005326  la  4 00124 2361 20	ldq  	pr4|84,*		pds$processid
005327  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
005330  aa  6 00236 7551 00	sta  	pr6|158		ignore
						STATEMENT 1 ON LINE 1233
	end;

005331  aa   000176 7100 04	tra  	126,ic		005527
						STATEMENT 1 ON LINE 1235
	else if order = "get_meters"
	then do;

005332  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
005333  aa  6 00120 00 0040	desc9a	pr6|80,32		order
005334  aa   772707 00 0012	desc9a	-2617,10		000241 = 147145164137
005335  aa   000167 6010 04	tnz  	119,ic		005524
						STATEMENT 1 ON LINE 1237
	     fnp_meterp = data_ptr -> get_comm_meters_info.subchan_ptr;

005336  aa  3 00002 3515 20	epp1 	pr3|2,*		get_comm_meters_info.subchan_ptr
005337  aa  6 00334 2515 00	spri1	pr6|220		fnp_meterp
						STATEMENT 1 ON LINE 1238
	     if fnp_meterp ^= null
	     then do;

005340  aa  6 00334 2371 00	ldaq 	pr6|220		fnp_meterp
005341  aa   772665 6770 04	eraq 	-2635,ic		000226 = 077777000043 000001000000
005342  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005343  aa   000164 6000 04	tze  	116,ic		005527
						STATEMENT 1 ON LINE 1240
		if fnp_meters.version ^= FNP_METERS_VERSION_2
		then code = error_table_$unimplemented_version;

005344  aa  1 00000 2361 00	ldq  	pr1|0		fnp_meters.version
005345  aa   000002 1160 07	cmpq 	2,dl
005346  aa   000005 6000 04	tze  	5,ic		005353
005347  aa  6 00044 3701 20	epp4 	pr6|36,*
005350  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$unimplemented_version
005351  aa  6 00100 7561 00	stq  	pr6|64		code
005352  aa   000155 7100 04	tra  	109,ic		005527
						STATEMENT 1 ON LINE 1242
		else do;

						STATEMENT 1 ON LINE 1243
		     ttybp = addr (tty_buf$);

005353  aa  6 00044 3701 20	epp4 	pr6|36,*
005354  la  4 00130 3735 20	epp7 	pr4|88,*		tty_buf$
005355  aa  6 00300 6535 00	spri7	pr6|192		ttybp
						STATEMENT 1 ON LINE 1244
		     call lock;

005356  aa   002534 6700 04	tsp4 	1372,ic		010112
						STATEMENT 1 ON LINE 1245
		     if code ^= 0
		     then do;

005357  aa  6 00100 2361 00	ldq  	pr6|64		code
005360  aa   000003 6000 04	tze  	3,ic		005363
						STATEMENT 1 ON LINE 1247
			a_code = code;

005361  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1248
			return;

005362  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1249
		     end;

						STATEMENT 1 ON LINE 1251
		     call get_fnp_meters ("1"b);

005363  aa   400000 2350 03	lda  	131072,du
005364  aa  6 00611 7551 00	sta  	pr6|393
005365  aa   003341 3520 04	epp2 	1761,ic		010726 = 000002000000
005366  aa   001741 6700 04	tsp4 	993,ic		007327
						STATEMENT 1 ON LINE 1253
		     if code = 0
		     then do;

005367  aa  6 00100 2361 00	ldq  	pr6|64		code
005370  aa   000065 6010 04	tnz  	53,ic		005455
						STATEMENT 1 ON LINE 1255
			fnp_meters.n_channels = fnp_info.no_of_channels;

005371  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
005372  aa  7 00006 2361 00	ldq  	pr7|6		fnp_info.no_of_channels
005373  aa  6 00334 3715 20	epp5 	pr6|220,*		fnp_meterp
005374  aa  5 00025 7561 00	stq  	pr5|21		fnp_meters.n_channels
						STATEMENT 1 ON LINE 1256
			fnp_meters.output_mbx_in_use_cum = fnp_info.cumulative_mbx_in_use;

005375  aa  7 00055 2361 00	ldq  	pr7|45		fnp_info.cumulative_mbx_in_use
005376  aa  5 00026 7561 00	stq  	pr5|22		fnp_meters.output_mbx_in_use_cum
						STATEMENT 1 ON LINE 1257
			fnp_meters.output_mbx_updates = fnp_info.mbx_in_use_updated;

005377  aa  7 00057 2361 00	ldq  	pr7|47		fnp_info.mbx_in_use_updated
005400  aa  5 00027 7561 00	stq  	pr5|23		fnp_meters.output_mbx_updates
						STATEMENT 1 ON LINE 1258
			fnp_meters.output_mbx_unavailable = fnp_info.mbx_unavailable;

005401  aa  7 00060 2361 00	ldq  	pr7|48		fnp_info.mbx_unavailable
005402  aa  5 00030 7561 00	stq  	pr5|24		fnp_meters.output_mbx_unavailable
						STATEMENT 1 ON LINE 1259
			fnp_meters.max_output_mbx_in_use = fnp_info.max_mbx_in_use;

005403  aa  7 00056 2361 00	ldq  	pr7|46		fnp_info.max_mbx_in_use
005404  aa  5 00031 7561 00	stq  	pr5|25		fnp_meters.max_output_mbx_in_use
						STATEMENT 1 ON LINE 1260
			fnp_meters.queue_entries_made = fnp_info.q_entries_made;

005405  aa  7 00045 2361 00	ldq  	pr7|37		fnp_info.q_entries_made
005406  aa  5 00032 7561 00	stq  	pr5|26		fnp_meters.queue_entries_made
						STATEMENT 1 ON LINE 1261
			fnp_meters.input_rejects = fnp_info.input_reject_count;

005407  aa  7 00046 2361 00	ldq  	pr7|38		fnp_info.input_reject_count
005410  aa  5 00033 7561 00	stq  	pr5|27		fnp_meters.input_rejects
						STATEMENT 1 ON LINE 1262
			fnp_meters.processed_from_q = fnp_info.processed_from_q;

005411  aa  7 00047 2361 00	ldq  	pr7|39		fnp_info.processed_from_q
005412  aa  5 00034 7561 00	stq  	pr5|28		fnp_meters.processed_from_q
						STATEMENT 1 ON LINE 1263
			fnp_meters.fnp_channel_locked = fnp_info.fnp_channel_locked;

005413  aa  7 00050 2361 00	ldq  	pr7|40		fnp_info.fnp_channel_locked
005414  aa  5 00035 7561 00	stq  	pr5|29		fnp_meters.fnp_channel_locked
						STATEMENT 1 ON LINE 1264
			fnp_meters.input_data_transactions = fnp_info.input_data_transactions;

005415  aa  7 00051 2361 00	ldq  	pr7|41		fnp_info.input_data_transactions
005416  aa  5 00036 7561 00	stq  	pr5|30		fnp_meters.input_data_transactions
						STATEMENT 1 ON LINE 1265
			fnp_meters.output_data_transactions = fnp_info.output_data_transactions;

005417  aa  7 00052 2361 00	ldq  	pr7|42		fnp_info.output_data_transactions
005420  aa  5 00037 7561 00	stq  	pr5|31		fnp_meters.output_data_transactions
						STATEMENT 1 ON LINE 1266
			fnp_meters.input_control_transactions = fnp_info.input_control_transactions;

005421  aa  7 00053 2361 00	ldq  	pr7|43		fnp_info.input_control_transactions
005422  aa  5 00040 7561 00	stq  	pr5|32		fnp_meters.input_control_transactions
						STATEMENT 1 ON LINE 1267
			fnp_meters.output_control_transactions = fnp_info.output_control_transactions;

005423  aa  7 00054 2361 00	ldq  	pr7|44		fnp_info.output_control_transactions
005424  aa  5 00041 7561 00	stq  	pr5|33		fnp_meters.output_control_transactions
						STATEMENT 1 ON LINE 1268
			fnp_meters.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output;

005425  aa  7 00063 2361 00	ldq  	pr7|51		fnp_info.fnp_space_restricted_output
005426  aa  5 00042 7561 00	stq  	pr5|34		fnp_meters.fnp_space_restricted_output
						STATEMENT 1 ON LINE 1269
			fnp_meters.fnp_mem_size = fnp_info.fnp_mem_size;

005427  aa  7 00042 2361 00	ldq  	pr7|34		fnp_info.fnp_mem_size
005430  aa  5 00043 7561 00	stq  	pr5|35		fnp_meters.fnp_mem_size
						STATEMENT 1 ON LINE 1270
			begin;

BEGIN BLOCK  1                                              STATEMENT 1 ON LINE 1273
			     call io_chnl_util$name_to_iom (fnp_info.io_chanid, iom, chan, (0));

005431  aa  6 00633 4501 00	stz  	pr6|411
005432  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
005433  aa  7 00010 3521 00	epp2 	pr7|8		fnp_info.io_chanid
005434  aa  6 00636 2521 00	spri2	pr6|414
005435  aa  6 00404 3521 00	epp2 	pr6|260		iom
005436  aa  6 00640 2521 00	spri2	pr6|416
005437  aa  6 00405 3521 00	epp2 	pr6|261		chan
005440  aa  6 00642 2521 00	spri2	pr6|418
005441  aa  6 00633 3521 00	epp2 	pr6|411
005442  aa  6 00644 2521 00	spri2	pr6|420
005443  aa  6 00634 6211 00	eax1 	pr6|412
005444  aa   020000 4310 07	fld  	8192,dl
005445  aa  6 00044 3701 20	epp4 	pr6|36,*
005446  la  4 00142 3521 20	epp2 	pr4|98,*		io_chnl_util$name_to_iom
005447  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1274
			     fnp_meters.iom_number = iom;

005450  aa  6 00404 2361 00	ldq  	pr6|260		iom
005451  aa  6 00334 3735 20	epp7 	pr6|220,*		fnp_meterp
005452  aa  7 00044 7561 00	stq  	pr7|36		fnp_meters.iom_number
						STATEMENT 1 ON LINE 1275
			     fnp_meters.iom_chan_no = chan;

005453  aa  6 00405 2361 00	ldq  	pr6|261		chan
005454  aa  7 00045 7561 00	stq  	pr7|37		fnp_meters.iom_chan_no
						STATEMENT 1 ON LINE 1276
			end;

  END BLOCK  1
						STATEMENT 1 ON LINE 1278
		     end;

						STATEMENT 1 ON LINE 1280
		     call unlock;

005455  aa   002521 6700 04	tsp4 	1361,ic		010176
						STATEMENT 1 ON LINE 1282
		     if fnp_meters_ptr ^= null ()	/* let's make sure this is for real */
		     then do;

005456  aa  6 00170 2371 00	ldaq 	pr6|120		fnp_meters_ptr
005457  aa   772547 6770 04	eraq 	-2713,ic		000226 = 077777000043 000001000000
005460  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005461  aa   000022 6000 04	tze  	18,ic		005503
						STATEMENT 1 ON LINE 1284
			data_ptr -> get_comm_meters_info.subchan_ptr -> fnp_meters.from_fnp =
			     fnp_meters_ptr -> fnp_global_meters;

005462  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
005463  aa  7 00002 3715 20	epp5 	pr7|2,*		get_comm_meters_info.subchan_ptr
005464  aa  6 00170 3535 20	epp3 	pr6|120,*		fnp_meters_ptr
005465  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
005466  aa  3 00000 00 0114	desc9a	pr3|0,76		fnp_global_meters
005467  aa  5 00002 00 0114	desc9a	pr5|2,76		fnp_meters.from_fnp
						STATEMENT 1 ON LINE 1287
			call tty_space_man$free_space (size (fnp_global_meters), fnp_meters_ptr);

005470  aa   000023 2360 07	ldq  	19,dl
005471  aa  6 00611 7561 00	stq  	pr6|393
005472  aa  6 00611 3521 00	epp2 	pr6|393
005473  aa  6 00550 2521 00	spri2	pr6|360
005474  aa  6 00170 3521 00	epp2 	pr6|120		fnp_meters_ptr
005475  aa  6 00552 2521 00	spri2	pr6|362
005476  aa  6 00546 6211 00	eax1 	pr6|358
005477  aa   010000 4310 07	fld  	4096,dl
005500  aa  6 00044 3701 20	epp4 	pr6|36,*
005501  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
005502  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1288
		     end;

						STATEMENT 1 ON LINE 1290
		     lctep = fnp_info.lcte_ptr;

005503  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
005504  aa  7 00032 3735 20	epp7 	pr7|26,*		fnp_info.lcte_ptr
005505  aa  6 00306 6535 00	spri7	pr6|198		lctep
						STATEMENT 1 ON LINE 1291
		     lcmp = data_ptr -> get_comm_meters_info.logical_chan_ptr;

005506  aa  6 00130 3715 20	epp5 	pr6|88,*		data_ptr
005507  aa  5 00004 3715 20	epp5 	pr5|4,*		get_comm_meters_info.logical_chan_ptr
005510  aa  6 00166 6515 00	spri5	pr6|118		lcmp
						STATEMENT 1 ON LINE 1293
		     if lcmp ^= null ()
		     then do;

005511  aa  6 00166 2371 00	ldaq 	pr6|118		lcmp
005512  aa   772514 6770 04	eraq 	-2740,ic		000226 = 077777000043 000001000000
005513  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005514  aa   000013 6000 04	tze  	11,ic		005527
						STATEMENT 1 ON LINE 1295
			lcmp -> logical_chan_meters.current_meters = lcte.meters;

005515  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
005516  aa  7 00006 00 0120	desc9a	pr7|6,80		lcte.meters
005517  aa  5 00000 00 0120	desc9a	pr5|0,80		logical_chan_meters.current_meters
						STATEMENT 1 ON LINE 1296
			unspec (lcmp -> logical_chan_meters.saved_meters) = "0"b;

005520  aa  000 100 100 400	mlr  	(),(pr),fill(000)
005521  aa   000000 00 0000	desc9a	0,0
005522  aa  5 00024 00 0120	desc9a	pr5|20,80
						STATEMENT 1 ON LINE 1298
		     end;

						STATEMENT 1 ON LINE 1299
		end;

						STATEMENT 1 ON LINE 1300
	     end;

						STATEMENT 1 ON LINE 1301
	end;

005523  aa   000004 7100 04	tra  	4,ic		005527
						STATEMENT 1 ON LINE 1303
	else code = error_table_$undefined_order_request;

005524  aa  6 00044 3701 20	epp4 	pr6|36,*
005525  la  4 00062 2361 20	ldq  	pr4|50,*		error_table_$undefined_order_request
005526  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1305
	a_code = code;

005527  aa  6 00100 2361 00	ldq  	pr6|64		code
005530  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1306
	return;

005531  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO hpriv_control                                      STATEMENT 1 ON LINE 1308
hpriv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

005532  ta     005177000000
005533  da     000706300000
005534  aa   001420 6270 00	eax7 	784
005535  aa  7 00034 3521 20	epp2 	pr7|28,*
005536  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
005537  aa     000010000000
005540  aa     000000000000
005541  aa  6 00032 3735 20	epp7 	pr6|26,*
005542  aa  7 00002 3715 20	epp5 	pr7|2,*
005543  aa  6 00340 6515 00	spri5	pr6|224
005544  aa  7 00004 3535 20	epp3 	pr7|4,*
005545  aa  6 00346 2535 00	spri3	pr6|230
005546  aa  6 00042 3515 20	epp1 	pr6|34,*
005547  aa  1 00002 3715 20	epp5 	pr1|2,*
005550  aa  6 00344 6515 00	spri5	pr6|228
005551  aa  7 00006 3535 20	epp3 	pr7|6,*
005552  aa  6 00350 2535 00	spri3	pr6|232
005553  aa  7 00010 3515 20	epp1 	pr7|8,*
005554  aa  6 00342 2515 00	spri1	pr6|226
						STATEMENT 1 ON LINE 1313
	fnpp = a_fnpp;

005555  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
005556  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
005557  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1314
	order = a_order;

005560  aa  6 00344 2361 20	ldq  	pr6|228,*
005561  aa   000002 6040 04	tmi  	2,ic		005563
005562  aa   777777 3760 07	anq  	262143,dl
005563  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
005564  aa  6 00346 3715 20	epp5 	pr6|230,*
005565  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
005566  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_order
005567  aa  6 00120 00 0040	desc9a	pr6|80,32		order
						STATEMENT 1 ON LINE 1315
	data_ptr = a_data_ptr;

005570  aa  6 00350 3535 20	epp3 	pr6|232,*		a_data_ptr
005571  aa  3 00000 3535 20	epp3 	pr3|0,*		a_data_ptr
005572  aa  6 00130 2535 00	spri3	pr6|88		data_ptr
						STATEMENT 1 ON LINE 1316
	locked = "0"b;

005573  aa  6 00133 4501 00	stz  	pr6|91		locked
						STATEMENT 1 ON LINE 1317
	code = 0;

005574  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1319
	if order = "patch_fnp"
	then do;

005575  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
005576  aa  6 00120 00 0040	desc9a	pr6|80,32		order
005577  aa   772436 00 0011	desc9a	-2786,9		000233 = 160141164143
005600  aa   000204 6010 04	tnz  	132,ic		006004
						STATEMENT 1 ON LINE 1321
	     call setup_fnp;

005601  aa   000545 6700 04	tsp4 	357,ic		006346
						STATEMENT 1 ON LINE 1322
	     if code ^= 0
	     then do;

005602  aa  6 00100 2361 00	ldq  	pr6|64		code
005603  aa   000003 6000 04	tze  	3,ic		005606
						STATEMENT 1 ON LINE 1324
		a_code = code;

005604  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1325
		return;

005605  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1326
	     end;

						STATEMENT 1 ON LINE 1327
	     n_fnp_words = dump_fnp_data.fnp_len;

005606  aa  6 00257 2361 00	ldq  	pr6|175		dump_fnp_data.fnp_len
005607  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
005610  aa  6 00235 7561 00	stq  	pr6|157		n_fnp_words
						STATEMENT 1 ON LINE 1328
	     sourcep = dump_fnp_info.bufp;

005611  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
005612  aa  7 00002 3735 20	epp7 	pr7|2,*		dump_fnp_info.bufp
005613  aa  6 00112 6535 00	spri7	pr6|74		sourcep
						STATEMENT 1 ON LINE 1330
	     fnp_dump_ptr -> fnp_data = sourcep -> fnp_data;

005614  aa   000022 4020 07	mpy  	18,dl
005615  aa   000043 0760 07	adq  	35,dl
005616  aa   000044 5060 07	div  	36,dl
005617  aa  0 00553 7001 00	tsx0 	pr0|363		alloc_temp
005620  aa  6 00630 2521 00	spri2	pr6|408
005621  aa  6 00235 2361 00	ldq  	pr6|157		n_fnp_words
005622  aa   000022 4020 07	mpy  	18,dl
005623  aa  6 00630 3715 20	epp5 	pr6|408,*
005624  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
005625  aa  7 00000 00 0006	descb	pr7|0,ql		fnp_data
005626  aa  5 00000 00 0006	descb	pr5|0,ql
005627  aa  6 00250 3535 20	epp3 	pr6|168,*		fnp_dump_ptr
005630  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
005631  aa  5 00000 00 0006	descb	pr5|0,ql
005632  aa  3 00000 00 0006	descb	pr3|0,ql		fnp_data
						STATEMENT 1 ON LINE 1331
	     call syserr (ANNOUNCE, "fnp_multiplexer: patching FNP ^a for ^a:", fnp_info.fnp_tag, pds$process_group_id);

005633  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
005634  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005635  aa   772631 00 0050	desc9a	-2663,40		000465 = 146156160137
005636  aa  6 00546 00 0050	desc9a	pr6|358,40
005637  aa   772313 3520 04	epp2 	-2869,ic		000152 = 000000000000
005640  aa  6 00564 2521 00	spri2	pr6|372
005641  aa  6 00546 3521 00	epp2 	pr6|358
005642  aa  6 00566 2521 00	spri2	pr6|374
005643  aa  6 00314 3515 20	epp1 	pr6|204,*		fnpp
005644  aa  1 00007 3521 00	epp2 	pr1|7		fnp_info.fnp_tag
005645  aa  6 00570 2521 00	spri2	pr6|376
005646  aa  6 00044 3701 20	epp4 	pr6|36,*
005647  la  4 00126 3521 20	epp2 	pr4|86,*		pds$process_group_id
005650  aa  6 00572 2521 00	spri2	pr6|378
005651  aa   772317 3520 04	epp2 	-2865,ic		000170 = 404000000021
005652  aa  6 00574 2521 00	spri2	pr6|380
005653  aa   772251 3520 04	epp2 	-2903,ic		000124 = 524000000050
005654  aa  6 00576 2521 00	spri2	pr6|382
005655  aa   772276 3520 04	epp2 	-2882,ic		000153 = 526000000001
005656  aa  6 00600 2521 00	spri2	pr6|384
005657  aa   772244 3520 04	epp2 	-2908,ic		000123 = 524000000040
005660  aa  6 00602 2521 00	spri2	pr6|386
005661  aa  6 00611 7561 00	stq  	pr6|393
005662  aa  6 00562 6211 00	eax1 	pr6|370
005663  aa   020000 4310 07	fld  	8192,dl
005664  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
005665  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1334
	     temp_addr = dump_fnp_data.fnp_addr;

005666  aa  6 00257 2351 00	lda  	pr6|175		dump_fnp_data.fnp_addr
005667  aa   000066 7730 00	lrl  	54
005670  aa  6 00247 7561 00	stq  	pr6|167		temp_addr
						STATEMENT 1 ON LINE 1335
	     do i = 1 to dump_fnp_data.fnp_len;

005671  aa  6 00257 2361 00	ldq  	pr6|175		dump_fnp_data.fnp_len
005672  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
005673  aa  6 00362 7561 00	stq  	pr6|242
005674  aa   000001 2360 07	ldq  	1,dl
005675  aa  6 00114 7561 00	stq  	pr6|76		i
005676  aa  6 00114 2361 00	ldq  	pr6|76		i
005677  aa  6 00362 1161 00	cmpq 	pr6|242
005700  aa   000056 6054 04	tpnz 	46,ic		005756
						STATEMENT 1 ON LINE 1336
		call syserr (ANNOUNCE, "^6w from ^6.3b to ^6.3b", temp_addr,
		     dump_fnp_info.old_value_ptr -> fnp_data (i), dump_fnp_info.bufp -> fnp_data (i));

005701  aa   772253 2360 04	ldq  	-2901,ic		000154 = 516000000022
005702  aa  6 00545 7561 00	stq  	pr6|357
005703  aa  6 00646 7561 00	stq  	pr6|422
005704  aa   772446 2370 04	ldaq 	-2778,ic		000352 = 136066167040 146162157155
005705  aa  6 00546 7571 00	staq 	pr6|358
005706  aa   772446 2370 04	ldaq 	-2778,ic		000354 = 040136066056 063142040164
005707  aa  6 00550 7571 00	staq 	pr6|360
005710  aa   772446 2370 04	ldaq 	-2778,ic		000356 = 157040136066 056063142000
005711  aa  6 00552 7571 00	staq 	pr6|362
005712  aa  6 00114 2361 00	ldq  	pr6|76		i
005713  aa   000022 4020 07	mpy  	18,dl
005714  aa   772236 3520 04	epp2 	-2914,ic		000152 = 000000000000
005715  aa  6 00564 2521 00	spri2	pr6|372
005716  aa  6 00546 3521 00	epp2 	pr6|358
005717  aa  6 00566 2521 00	spri2	pr6|374
005720  aa  6 00247 3521 00	epp2 	pr6|167		temp_addr
005721  aa  6 00570 2521 00	spri2	pr6|376
005722  aa  6 00647 7561 00	stq  	pr6|423
005723  aa   000022 0760 07	adq  	18,dl
005724  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
005725  aa  7 00004 3715 20	epp5 	pr7|4,*		dump_fnp_info.old_value_ptr
005726  aa  5 77777 3521 00	epp2 	pr5|-1		fnp_data
005727  aa  2 00000 5035 06	abd  	pr2|0,ql
005730  aa  6 00572 2521 00	spri2	pr6|378
005731  aa  7 00002 3535 20	epp3 	pr7|2,*		dump_fnp_info.bufp
005732  aa  3 77777 3521 00	epp2 	pr3|-1		fnp_data
005733  aa  2 00000 5035 06	abd  	pr2|0,ql
005734  aa  6 00574 2521 00	spri2	pr6|380
005735  aa   772233 3520 04	epp2 	-2917,ic		000170 = 404000000021
005736  aa  6 00576 2521 00	spri2	pr6|382
005737  aa  6 00602 2521 00	spri2	pr6|386
005740  aa   772162 3520 04	epp2 	-2958,ic		000122 = 524000000027
005741  aa  6 00600 2521 00	spri2	pr6|384
005742  aa  6 00545 3521 00	epp2 	pr6|357
005743  aa  6 00604 2521 00	spri2	pr6|388
005744  aa  6 00646 3521 00	epp2 	pr6|422
005745  aa  6 00606 2521 00	spri2	pr6|390
005746  aa  6 00562 6211 00	eax1 	pr6|370
005747  aa   024000 4310 07	fld  	10240,dl
005750  aa  6 00044 3701 20	epp4 	pr6|36,*
005751  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
005752  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1338
		temp_addr = temp_addr + 1;

005753  aa  6 00247 0541 00	aos  	pr6|167		temp_addr
						STATEMENT 1 ON LINE 1339
	     end;

005754  aa  6 00114 0541 00	aos  	pr6|76		i
005755  aa   777721 7100 04	tra  	-47,ic		005676
						STATEMENT 1 ON LINE 1341
	     call send_global (patch_mem);

005756  aa   002744 3520 04	epp2 	1508,ic		010722 = 000002000000
005757  aa   001147 6700 04	tsp4 	615,ic		007126
						STATEMENT 1 ON LINE 1342
	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);

005760  aa  6 00100 2361 00	ldq  	pr6|64		code
005761  aa  6 00044 3701 20	epp4 	pr6|36,*
005762  la  4 00102 1161 20	cmpq 	pr4|66,*		error_table_$timeout
005763  aa   000011 6000 04	tze  	9,ic		005774
005764  aa  6 00252 3521 00	epp2 	pr6|170		dump_patch_space
005765  aa  6 00550 2521 00	spri2	pr6|360
005766  aa  6 00250 3521 00	epp2 	pr6|168		fnp_dump_ptr
005767  aa  6 00552 2521 00	spri2	pr6|362
005770  aa  6 00546 6211 00	eax1 	pr6|358
005771  aa   010000 4310 07	fld  	4096,dl
005772  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
005773  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1345
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);

005774  aa   000000 2350 07	lda  	0,dl
005775  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
005776  aa  7 00044 3521 00	epp2 	pr7|36		fnp_info.dump_patch_lock
005777  aa  6 00044 3701 20	epp4 	pr6|36,*
006000  la  4 00124 2361 20	ldq  	pr4|84,*		pds$processid
006001  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
006002  aa  6 00236 7551 00	sta  	pr6|158		ignore
						STATEMENT 1 ON LINE 1346
	end;

006003  aa   000126 7100 04	tra  	86,ic		006131
						STATEMENT 1 ON LINE 1348
	else if order = "fnp_break"
	then do;

006004  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006005  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006006  aa   772224 00 0011	desc9a	-2924,9		000230 = 146156160137
006007  aa   000105 6010 04	tnz  	69,ic		006114
						STATEMENT 1 ON LINE 1350
	     call setup_fnp;

006010  aa   000336 6700 04	tsp4 	222,ic		006346
						STATEMENT 1 ON LINE 1351
	     if code ^= 0
	     then do;

006011  aa  6 00100 2361 00	ldq  	pr6|64		code
006012  aa   000003 6000 04	tze  	3,ic		006015
						STATEMENT 1 ON LINE 1353
		a_code = code;

006013  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1354
		return;

006014  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1355
	     end;

						STATEMENT 1 ON LINE 1356
	     fnp_break_data.action = fnp_break_info.action;

006015  aa  6 00130 3735 20	epp7 	pr6|88,*		data_ptr
006016  aa  7 00003 2361 00	ldq  	pr7|3		fnp_break_info.action
006017  aa   000066 7370 00	lls  	54
006020  aa  6 00261 5511 60	stba 	pr6|177,60	fnp_break_data.action
						STATEMENT 1 ON LINE 1358
	     fnp_break_data.fnp_addr = fnp_break_info.fnp_addr;

006021  aa  7 00002 2361 00	ldq  	pr7|2		fnp_break_info.fnp_addr
006022  aa  6 00260 5521 14	stbq 	pr6|176,14	fnp_break_data.fnp_addr
						STATEMENT 1 ON LINE 1359
	     fnp_break_data.flags = substr (fnp_break_info.flags, 1, 18);

006023  aa  7 00004 2351 00	lda  	pr7|4		fnp_break_info.flags
006024  aa   000022 7710 00	arl  	18
006025  aa  6 00261 5511 14	stba 	pr6|177,14	fnp_break_data.flags
						STATEMENT 1 ON LINE 1360
	     name = fnp_break_info.chan_name;

006026  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006027  aa  7 00000 00 0006	desc9a	pr7|0,6		fnp_break_info.chan_name
006030  aa  6 00237 00 0040	desc9a	pr6|159,32	name
						STATEMENT 1 ON LINE 1361
	     if name = ""
	     then fnp_break_data.lineno = -1;

006031  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006032  aa  6 00237 00 0040	desc9a	pr6|159,32	name
006033  aa   002751 00 0000	desc9a	1513,0		011002 = 777777777777
006034  aa   000004 6010 04	tnz  	4,ic		006040
006035  aa   777777 2350 03	lda  	262143,du
006036  aa  6 00260 5511 60	stba 	pr6|176,60	fnp_break_data.lineno
006037  aa   000014 7100 04	tra  	12,ic		006053
						STATEMENT 1 ON LINE 1363
	     else do;

						STATEMENT 1 ON LINE 1364
		call name_to_pcb (name);

006040  aa   002654 3520 04	epp2 	1452,ic		010714 = 000002000000
006041  aa  2 00000 2351 00	lda  	pr2|0
006042  aa   001673 6700 04	tsp4 	955,ic		007735
						STATEMENT 1 ON LINE 1365
		if code ^= 0
		then do;

006043  aa  6 00100 2361 00	ldq  	pr6|64		code
006044  aa   000003 6000 04	tze  	3,ic		006047
						STATEMENT 1 ON LINE 1367
		     a_code = code;

006045  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1368
		     return;

006046  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1369
		end;

						STATEMENT 1 ON LINE 1370
		fnp_break_data.lineno = bin (string (pcb.line_number));

006047  aa  6 00320 2361 20	ldq  	pr6|208,*
006050  aa  0 00414 3771 00	anaq 	pr0|268		= 000000000000 000000001777
006051  aa   000066 7370 00	lls  	54
006052  aa  6 00260 5511 60	stba 	pr6|176,60	fnp_break_data.lineno
						STATEMENT 1 ON LINE 1371
	     end;

						STATEMENT 1 ON LINE 1373
	     mbx_data = addr (fnp_break_data) -> based_bit72;

006053  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
006054  aa  6 00260 00 0110	descb	pr6|176,72	based_bit72
006055  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 1374
	     if ^locked
	     then call lock;

006056  aa  6 00133 2351 00	lda  	pr6|91		locked
006057  aa   000002 6010 04	tnz  	2,ic		006061
006060  aa   002032 6700 04	tsp4 	1050,ic		010112
						STATEMENT 1 ON LINE 1376
	     if code = 0
	     then do;

006061  aa  6 00100 2361 00	ldq  	pr6|64		code
006062  aa   000047 6010 04	tnz  	39,ic		006131
						STATEMENT 1 ON LINE 1378
		call dn355$send_global_wcd (fnpp, fnp_break, 72, mbx_data);

006063  aa   000110 2360 07	ldq  	72,dl
006064  aa  6 00545 7561 00	stq  	pr6|357
006065  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
006066  aa  6 00564 2521 00	spri2	pr6|372
006067  aa   771724 3520 04	epp2 	-3116,ic		000013 = 000000000025
006070  aa  6 00566 2521 00	spri2	pr6|374
006071  aa  6 00545 3521 00	epp2 	pr6|357
006072  aa  6 00570 2521 00	spri2	pr6|376
006073  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
006074  aa  6 00572 2521 00	spri2	pr6|378
006075  aa   772071 3520 04	epp2 	-3015,ic		000166 = 464000000000
006076  aa  6 00574 2521 00	spri2	pr6|380
006077  aa   772047 3520 04	epp2 	-3033,ic		000146 = 404000000010
006100  aa  6 00576 2521 00	spri2	pr6|382
006101  aa   772067 3520 04	epp2 	-3017,ic		000170 = 404000000021
006102  aa  6 00600 2521 00	spri2	pr6|384
006103  aa   772032 3520 04	epp2 	-3046,ic		000135 = 516000000220
006104  aa  6 00602 2521 00	spri2	pr6|386
006105  aa  6 00562 6211 00	eax1 	pr6|370
006106  aa   020000 4310 07	fld  	8192,dl
006107  aa  6 00044 3701 20	epp4 	pr6|36,*
006110  la  4 00012 3521 20	epp2 	pr4|10,*		dn355$send_global_wcd
006111  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1379
		call unlock;

006112  aa   002064 6700 04	tsp4 	1076,ic		010176
						STATEMENT 1 ON LINE 1380
	     end;

						STATEMENT 1 ON LINE 1381
	end;

006113  aa   000016 7100 04	tra  	14,ic		006131
						STATEMENT 1 ON LINE 1383
	else if order = "enable_breakall_mode"
	then ;

006114  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006115  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006116  aa   772211 00 0024	desc9a	-2935,20		000325 = 145156141142
006117  aa   000002 6010 04	tnz  	2,ic		006121
006120  aa   000011 7100 04	tra  	9,ic		006131
						STATEMENT 1 ON LINE 1386
	else if order = "disable_breakall_mode"
	then ;

006121  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006122  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006123  aa   772223 00 0025	desc9a	-2925,21		000344 = 144151163141
006124  aa   000002 6010 04	tnz  	2,ic		006126
006125  aa   000004 7100 04	tra  	4,ic		006131
						STATEMENT 1 ON LINE 1389
	else code = error_table_$undefined_order_request;

006126  aa  6 00044 3701 20	epp4 	pr6|36,*
006127  la  4 00062 2361 20	ldq  	pr4|50,*		error_table_$undefined_order_request
006130  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1391
hpriv_exit:
	a_code = code;

006131  aa  6 00100 2361 00	ldq  	pr6|64		code
006132  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1393
	return;

006133  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO fnp_lock                                           STATEMENT 1 ON LINE 1395
fnp_lock:
     entry (a_fnpp, a_code);

006134  ta     001573000000
006135  da     000714300000
006136  aa   001420 6270 00	eax7 	784
006137  aa  7 00034 3521 20	epp2 	pr7|28,*
006140  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
006141  aa     000004000000
006142  aa     000000000000
006143  aa  6 00032 3735 20	epp7 	pr6|26,*
006144  aa  7 00002 3715 20	epp5 	pr7|2,*
006145  aa  6 00340 6515 00	spri5	pr6|224
006146  aa  7 00004 3535 20	epp3 	pr7|4,*
006147  aa  6 00342 2535 00	spri3	pr6|226
						STATEMENT 1 ON LINE 1398
	fnpp = a_fnpp;

006150  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
006151  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
006152  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1399
	call lock;

006153  aa   001737 6700 04	tsp4 	991,ic		010112
						STATEMENT 1 ON LINE 1400
	a_code = code;

006154  aa  6 00100 2361 00	ldq  	pr6|64		code
006155  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1401
	return;

006156  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO fnp_unlock                                         STATEMENT 1 ON LINE 1403
fnp_unlock:
     entry (a_fnpp);

006157  at     000001000166
006160  ta     006157000000
006161  da     000722300000
006162  aa   001420 6270 00	eax7 	784
006163  aa  7 00034 3521 20	epp2 	pr7|28,*
006164  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
006165  aa     000002000000
006166  aa     000000000000
006167  aa  6 00032 3735 20	epp7 	pr6|26,*
006170  aa  7 00002 3715 20	epp5 	pr7|2,*
006171  aa  6 00340 6515 00	spri5	pr6|224
						STATEMENT 1 ON LINE 1406
	fnpp = a_fnpp;

006172  aa  6 00340 3735 20	epp7 	pr6|224,*		a_fnpp
006173  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
006174  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1407
	mylock = "0"b;

006175  aa  6 00135 4501 00	stz  	pr6|93		mylock
						STATEMENT 1 ON LINE 1408
	locked = "1"b;

006176  aa   400000 2350 03	lda  	131072,du
006177  aa  6 00133 7551 00	sta  	pr6|91		locked
						STATEMENT 1 ON LINE 1409
	call unlock;

006200  aa   001776 6700 04	tsp4 	1022,ic		010176
						STATEMENT 1 ON LINE 1410
	return;

006201  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO assign                                             STATEMENT 1 ON LINE 1868
assign:
     entry (a_fnp_no, a_code);

006202  at     000002000170
006203  ta     000162000000
006204  ta     006202000000
006205  da     000725300000
006206  aa   001420 6270 00	eax7 	784
006207  aa  7 00034 3521 20	epp2 	pr7|28,*
006210  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
006211  aa     000004000000
006212  aa     000000000000
006213  aa  6 00032 3735 20	epp7 	pr6|26,*
006214  aa  7 00004 3715 20	epp5 	pr7|4,*
006215  aa  6 00342 6515 00	spri5	pr6|226
						STATEMENT 1 ON LINE 1871
	infop = addr (dn355_data$);

006216  aa  6 00044 3701 20	epp4 	pr6|36,*
006217  la  4 00132 3735 20	epp7 	pr4|90,*		dn355_data$
006220  aa  6 00312 6535 00	spri7	pr6|202		infop
						STATEMENT 1 ON LINE 1872
	call TRACE ("assign");

006221  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
006222  aa   771757 00 0006	desc9a	-3089,6		000200 = 141163163151
006223  aa  6 00546 00 0040	desc9a	pr6|358,32
006224  aa   002552 3520 04	epp2 	1386,ic		010776 = 000002000000
006225  aa   002341 6700 04	tsp4 	1249,ic		010566
						STATEMENT 1 ON LINE 1873
	fnp_no = a_fnp_no;

006226  aa  6 00032 3735 20	epp7 	pr6|26,*
006227  aa  7 00002 2361 20	ldq  	pr7|2,*		a_fnp_no
006230  aa  6 00336 7561 00	stq  	pr6|222		fnp_no
						STATEMENT 1 ON LINE 1874
	fnpp = addr (datanet_info.per_datanet (fnp_no));

006231  aa   000072 4020 07	mpy  	58,dl
006232  aa  6 00312 3715 20	epp5 	pr6|202,*		infop
006233  aa  5 77730 3715 06	epp5 	pr5|-40,ql	datanet_info.per_datanet
006234  aa  6 00314 6515 00	spri5	pr6|204		fnpp
						STATEMENT 1 ON LINE 1875
	call assign_channel (code);

006235  aa   002535 3520 04	epp2 	1373,ic		010772 = 000002000000
006236  aa   002042 6700 04	tsp4 	1058,ic		010300
						STATEMENT 1 ON LINE 1876
	a_code = code;

006237  aa  6 00100 2361 00	ldq  	pr6|64		code
006240  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1877
	return;

006241  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO unassign                                           STATEMENT 1 ON LINE 1880
unassign:
     entry (a_fnp_no, a_code);

006242  ta     006202000000
006243  da     000730300000
006244  aa   001420 6270 00	eax7 	784
006245  aa  7 00034 3521 20	epp2 	pr7|28,*
006246  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
006247  aa     000004000000
006250  aa     000000000000
006251  aa  6 00032 3735 20	epp7 	pr6|26,*
006252  aa  7 00004 3715 20	epp5 	pr7|4,*
006253  aa  6 00342 6515 00	spri5	pr6|226
						STATEMENT 1 ON LINE 1883
	fnp_no = a_fnp_no;

006254  aa  6 00032 3735 20	epp7 	pr6|26,*
006255  aa  7 00002 2361 20	ldq  	pr7|2,*		a_fnp_no
006256  aa  6 00336 7561 00	stq  	pr6|222		fnp_no
						STATEMENT 1 ON LINE 1884
	infop = addr (dn355_data$);

006257  aa  6 00044 3701 20	epp4 	pr6|36,*
006260  la  4 00132 3715 20	epp5 	pr4|90,*		dn355_data$
006261  aa  6 00312 6515 00	spri5	pr6|202		infop
						STATEMENT 1 ON LINE 1885
	call TRACE ("unassign");

006262  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
006263  aa   771714 00 0010	desc9a	-3124,8		000176 = 165156141163
006264  aa  6 00546 00 0040	desc9a	pr6|358,32
006265  aa   002511 3520 04	epp2 	1353,ic		010776 = 000002000000
006266  aa   002300 6700 04	tsp4 	1216,ic		010566
						STATEMENT 1 ON LINE 1886
	fnpp = addr (datanet_info.per_datanet (fnp_no));

006267  aa  6 00336 2361 00	ldq  	pr6|222		fnp_no
006270  aa   000072 4020 07	mpy  	58,dl
006271  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
006272  aa  7 77730 3735 06	epp7 	pr7|-40,ql	datanet_info.per_datanet
006273  aa  6 00314 6535 00	spri7	pr6|204		fnpp
						STATEMENT 1 ON LINE 1888
	call unassign_channel (code);

006274  aa   002476 3520 04	epp2 	1342,ic		010772 = 000002000000
006275  aa   002152 6700 04	tsp4 	1130,ic		010447
						STATEMENT 1 ON LINE 1889
	a_code = code;

006276  aa  6 00100 2361 00	ldq  	pr6|64		code
006277  aa  6 00342 7561 20	stq  	pr6|226,*		a_code
						STATEMENT 1 ON LINE 1890
	return;

006300  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2140
     end fnp_multiplexer;

BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 1412
setup:
     proc;

006301  aa  6 00406 6501 00	spri4	pr6|262
						STATEMENT 1 ON LINE 1418
	code = 0;

006302  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1419
	ttybp = addr (tty_buf$);

006303  aa  6 00044 3701 20	epp4 	pr6|36,*
006304  la  4 00130 3735 20	epp7 	pr4|88,*		tty_buf$
006305  aa  6 00300 6535 00	spri7	pr6|192		ttybp
						STATEMENT 1 ON LINE 1420
	infop = addr (dn355_data$);

006306  la  4 00132 3715 20	epp5 	pr4|90,*		dn355_data$
006307  aa  6 00312 6515 00	spri5	pr6|202		infop
						STATEMENT 1 ON LINE 1421
	locked, queue_locked = "0"b;

006310  aa  6 00133 4501 00	stz  	pr6|91		locked
006311  aa  6 00134 4501 00	stz  	pr6|92		queue_locked
						STATEMENT 1 ON LINE 1422
	call lock;

006312  aa   001600 6700 04	tsp4 	896,ic		010112
						STATEMENT 1 ON LINE 1423
	if code ^= 0
	then return;

006313  aa  6 00100 2361 00	ldq  	pr6|64		code
006314  aa   000002 6000 04	tze  	2,ic		006316
006315  aa  6 00406 6101 00	rtcd 	pr6|262
						STATEMENT 1 ON LINE 1426
	if fnp_info.running
	then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (chanx));

006316  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
006317  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
006320  aa   100000 3150 03	cana 	32768,du
006321  aa   000007 6000 04	tze  	7,ic		006330
006322  aa  6 00110 2361 00	ldq  	pr6|72		chanx
006323  aa   000003 7360 00	qls  	3
006324  aa  7 00002 3715 20	epp5 	pr7|2,*		fnp_info.pcb_array_ptr
006325  aa  5 77770 3535 06	epp3 	pr5|-8,ql		pcb_array
006326  aa  6 00320 2535 00	spri3	pr6|208		pcbp
006327  aa   000006 7100 04	tra  	6,ic		006335
						STATEMENT 1 ON LINE 1428
	else do;

						STATEMENT 1 ON LINE 1429
	     call unlock;

006330  aa   001646 6700 04	tsp4 	934,ic		010176
						STATEMENT 1 ON LINE 1430
	     code = error_table_$mpx_down;

006331  aa  6 00044 3701 20	epp4 	pr6|36,*
006332  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$mpx_down
006333  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1431
	     return;

006334  aa  6 00406 6101 00	rtcd 	pr6|262
						STATEMENT 1 ON LINE 1432
	end;

						STATEMENT 1 ON LINE 1434
	if pcb.copied_meters_ready			/* dn355 left them for us */
	then if ^lcte.locked_for_interrupt		/* make sure we're on call side */
	     then call save_copied_meters;

006335  aa  3 00004 2351 00	lda  	pr3|4		pcb.copied_meters_ready
006336  aa   000400 3150 03	cana 	256,du
006337  aa   000006 6000 04	tze  	6,ic		006345
006340  aa  6 00306 3735 20	epp7 	pr6|198,*		lctep
006341  aa  7 00002 2351 00	lda  	pr7|2		lcte.locked_for_interrupt
006342  aa   000040 3150 03	cana 	32,du
006343  aa   000002 6010 04	tnz  	2,ic		006345
006344  aa   000174 6700 04	tsp4 	124,ic		006540
						STATEMENT 1 ON LINE 1438
	return;

006345  aa  6 00406 6101 00	rtcd 	pr6|262
						STATEMENT 1 ON LINE 1439
     end setup;

  END PROCEDURE setup
BEGIN PROCEDURE setup_fnp
ENTRY TO setup_fnp                                          STATEMENT 1 ON LINE 1443
setup_fnp:
     proc;

006346  aa  6 00414 6501 00	spri4	pr6|268
						STATEMENT 1 ON LINE 1450
	if fnpp = null ()
	then go to setup_fnp_down;

006347  aa  6 00314 2371 00	ldaq 	pr6|204		fnpp
006350  aa   771656 6770 04	eraq 	-3154,ic		000226 = 077777000043 000001000000
006351  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006352  aa   000012 6000 04	tze  	10,ic		006364
						STATEMENT 1 ON LINE 1452
	code = 0;

006353  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1453
	if fnp_info.mbx_pt = null ()			/* this one isn't configured */
	     | ^fnp_info.running			/* or it isn't up */
	then do;

006354  aa  6 00314 2371 20	ldaq 	pr6|204,*		fnp_info.mbx_pt
006355  aa   771651 6770 04	eraq 	-3159,ic		000226 = 077777000043 000001000000
006356  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006357  aa   000005 6000 04	tze  	5,ic		006364
006360  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
006361  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
006362  aa   100000 3150 03	cana 	32768,du
006363  aa   000005 6010 04	tnz  	5,ic		006370
						STATEMENT 1 ON LINE 1456
setup_fnp_down:
	     code = error_table_$mpx_down;

006364  aa  6 00044 3701 20	epp4 	pr6|36,*
006365  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$mpx_down
006366  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1458
	     return;

006367  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1459
	end;

						STATEMENT 1 ON LINE 1461
	ttybp = addr (tty_buf$);

006370  aa  6 00044 3701 20	epp4 	pr6|36,*
006371  la  4 00130 3715 20	epp5 	pr4|88,*		tty_buf$
006372  aa  6 00300 6515 00	spri5	pr6|192		ttybp
						STATEMENT 1 ON LINE 1462
	infop = addr (dn355_data$);

006373  la  4 00132 3535 20	epp3 	pr4|90,*		dn355_data$
006374  aa  6 00312 2535 00	spri3	pr6|202		infop
						STATEMENT 1 ON LINE 1464
	if order = "fnp_break"
	then return;

006375  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006376  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006377  aa   771633 00 0011	desc9a	-3173,9		000230 = 146156160137
006400  aa   000002 6010 04	tnz  	2,ic		006402
006401  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1466
	if fnp_info.dump_patch_disabled
	then do;

006402  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.dump_patch_disabled
006403  aa   002000 3150 03	cana 	1024,du
006404  aa   000004 6000 04	tze  	4,ic		006410
						STATEMENT 1 ON LINE 1468
	     code = error_table_$timeout;

006405  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$timeout
006406  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1469
	     return;

006407  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1470
	end;

						STATEMENT 1 ON LINE 1472
	fnp_address = dump_fnp_info.fnp_address;

006410  aa  6 00130 2361 20	ldq  	pr6|88,*		dump_fnp_info.fnp_address
006411  aa  6 00422 7561 00	stq  	pr6|274		fnp_address
						STATEMENT 1 ON LINE 1473
	fnp_len = dump_fnp_info.fnp_len;

006412  aa  6 00130 3515 20	epp1 	pr6|88,*		data_ptr
006413  aa  1 00001 2361 00	ldq  	pr1|1		dump_fnp_info.fnp_len
006414  aa  6 00423 7561 00	stq  	pr6|275		fnp_len
						STATEMENT 1 ON LINE 1474
	if order = "dump_fnp"
	then do;

006415  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006416  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006417  aa   771565 00 0010	desc9a	-3211,8		000202 = 144165155160
006420  aa   000012 6010 04	tnz  	10,ic		006432
						STATEMENT 1 ON LINE 1476
	     if fnp_len <= 0 | fnp_len > 64
	     then do;

006421  aa  6 00423 2361 00	ldq  	pr6|275		fnp_len
006422  aa   000003 6044 04	tmoz 	3,ic		006425
006423  aa   000100 1160 07	cmpq 	64,dl
006424  aa   000016 6044 04	tmoz 	14,ic		006442
						STATEMENT 1 ON LINE 1478
bad_fnp_len:
		code = error_table_$buffer_big;

006425  aa  6 00044 3701 20	epp4 	pr6|36,*
006426  la  4 00070 2361 20	ldq  	pr4|56,*		error_table_$buffer_big
006427  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1480
		return;

006430  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1481
	     end;

						STATEMENT 1 ON LINE 1482
	end;

006431  aa   000011 7100 04	tra  	9,ic		006442
						STATEMENT 1 ON LINE 1483
	else if order = "patch_fnp"
	then if fnp_len <= 0 | fnp_len > 32
	     then go to bad_fnp_len;

006432  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
006433  aa  6 00120 00 0040	desc9a	pr6|80,32		order
006434  aa   771601 00 0011	desc9a	-3199,9		000233 = 160141164143
006435  aa   000005 6010 04	tnz  	5,ic		006442
006436  aa  6 00423 2361 00	ldq  	pr6|275		fnp_len
006437  aa   777766 6044 04	tmoz 	-10,ic		006425
006440  aa   000040 1160 07	cmpq 	32,dl
006441  aa   777764 6054 04	tpnz 	-12,ic		006425
						STATEMENT 1 ON LINE 1487
	if (fnp_address < 0) | ((fnp_address + fnp_len) > fnp_info.fnp_mem_size)
	then do;

006442  aa  6 00422 2361 00	ldq  	pr6|274		fnp_address
006443  aa   000005 6040 04	tmi  	5,ic		006450
006444  aa  6 00423 0761 00	adq  	pr6|275		fnp_len
006445  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
006446  aa  7 00042 1161 00	cmpq 	pr7|34		fnp_info.fnp_mem_size
006447  aa   000005 6044 04	tmoz 	5,ic		006454
						STATEMENT 1 ON LINE 1489
	     code = error_table_$dev_offset_out_of_bounds;

006450  aa  6 00044 3701 20	epp4 	pr6|36,*
006451  la  4 00074 2361 20	ldq  	pr4|60,*		error_table_$dev_offset_out_of_bounds
006452  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1490
	     return;

006453  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1491
	end;

						STATEMENT 1 ON LINE 1493
	if ^stac (addr (fnp_info.dump_patch_lock), pds$processid)
						/* lock the dump_patch function */
	then do;

006454  aa  7 00044 3715 00	epp5 	pr7|36		fnp_info.dump_patch_lock
006455  aa  6 00650 6515 00	spri5	pr6|424
006456  aa  6 00044 3701 20	epp4 	pr6|36,*
006457  la  4 00124 2351 20	lda  	pr4|84,*		pds$processid
006460  aa  5 00000 3521 00	epp2 	pr5|0
006461  aa  0 00663 7001 00	tsx0 	pr0|435		stac_mac
006462  aa   000004 6010 04	tnz  	4,ic		006466
						STATEMENT 1 ON LINE 1496
	     code = error_table_$seglock;

006463  la  4 00076 2361 20	ldq  	pr4|62,*		error_table_$seglock
006464  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1497
	     return;

006465  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1498
	end;

						STATEMENT 1 ON LINE 1500
	dump_patch_space = divide (fnp_len + 1, 2, 17, 0);

006466  aa  6 00423 2361 00	ldq  	pr6|275		fnp_len
006467  aa   000001 0760 07	adq  	1,dl
006470  aa   000002 5060 07	div  	2,dl
006471  aa  6 00252 7561 00	stq  	pr6|170		dump_patch_space
						STATEMENT 1 ON LINE 1501
	call tty_space_man$get_space (dump_patch_space, fnp_dump_ptr);

006472  aa  6 00252 3521 00	epp2 	pr6|170		dump_patch_space
006473  aa  6 00654 2521 00	spri2	pr6|428
006474  aa  6 00250 3521 00	epp2 	pr6|168		fnp_dump_ptr
006475  aa  6 00656 2521 00	spri2	pr6|430
006476  aa  6 00652 6211 00	eax1 	pr6|426
006477  aa   010000 4310 07	fld  	4096,dl
006500  la  4 00134 3521 20	epp2 	pr4|92,*		tty_space_man$get_space
006501  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1502
	if fnp_dump_ptr = null			/* couldn't get the space */
	then do;

006502  aa  6 00250 2371 00	ldaq 	pr6|168		fnp_dump_ptr
006503  aa   771523 6770 04	eraq 	-3245,ic		000226 = 077777000043 000001000000
006504  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006505  aa   000013 6010 04	tnz  	11,ic		006520
						STATEMENT 1 ON LINE 1504
	     code = error_table_$noalloc;

006506  aa  6 00044 3701 20	epp4 	pr6|36,*
006507  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$noalloc
006510  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1505
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);

006511  aa   000000 2350 07	lda  	0,dl
006512  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
006513  aa  7 00044 3521 00	epp2 	pr7|36		fnp_info.dump_patch_lock
006514  la  4 00124 2361 20	ldq  	pr4|84,*		pds$processid
006515  aa  0 01434 7001 00	tsx0 	pr0|796		stacq_mac
006516  aa  6 00236 7551 00	sta  	pr6|158		ignore
						STATEMENT 1 ON LINE 1506
	     return;

006517  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1507
	end;

						STATEMENT 1 ON LINE 1509
	dump_patch_time = clock ();

006520  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
006521  aa  6 00254 7571 00	staq 	pr6|172		dump_patch_time
						STATEMENT 1 ON LINE 1510
	fnp_info.dump_patch_in_progress = "1"b;

006522  aa   020000 2350 03	lda  	8192,du
006523  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
006524  aa  7 00030 2551 00	orsa 	pr7|24		fnp_info.dump_patch_in_progress
						STATEMENT 1 ON LINE 1511
	dump_fnp_data.abs_addr = bin (rel (fnp_dump_ptr)) + tty_buf.absorig;

006525  aa  6 00250 6351 20	eaa  	pr6|168,*		fnp_dump_ptr
006526  aa   000066 7730 00	lrl  	54
006527  aa  6 00300 3715 20	epp5 	pr6|192,*		ttybp
006530  aa  5 00001 0331 00	adl  	pr5|1		tty_buf.absorig
006531  aa  6 00256 7561 00	stq  	pr6|174		dump_fnp_data.abs_addr
						STATEMENT 1 ON LINE 1513
	dump_fnp_data.fnp_addr = fnp_address;

006532  aa  6 00422 2361 00	ldq  	pr6|274		fnp_address
006533  aa   000066 7370 00	lls  	54
006534  aa  6 00257 5511 60	stba 	pr6|175,60	dump_fnp_data.fnp_addr
						STATEMENT 1 ON LINE 1514
	dump_fnp_data.fnp_len = fnp_len;

006535  aa  6 00423 2361 00	ldq  	pr6|275		fnp_len
006536  aa  6 00257 5521 14	stbq 	pr6|175,14	dump_fnp_data.fnp_len
						STATEMENT 1 ON LINE 1515
	return;

006537  aa  6 00414 6101 00	rtcd 	pr6|268
						STATEMENT 1 ON LINE 1517
     end setup_fnp;

  END PROCEDURE setup_fnp
BEGIN PROCEDURE save_copied_meters
ENTRY TO save_copied_meters                                 STATEMENT 1 ON LINE 1519
save_copied_meters:
     proc;

006540  aa  6 00424 6501 00	spri4	pr6|276
						STATEMENT 1 ON LINE 1526
	if pcb.copied_meters_offset ^= 0		/* make sure it's legit */
	then do;

006541  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
006542  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
006543  aa   000056 6000 04	tze  	46,ic		006621
						STATEMENT 1 ON LINE 1528
	     copied_meters_ptr = ptr (ttybp, pcb.copied_meters_offset);

006544  aa  6 00300 3521 20	epp2 	pr6|192,*		ttybp
006545  aa   000000 3120 06	eawp2	0,ql
006546  aa  6 00432 2521 00	spri2	pr6|282		copied_meters_ptr
						STATEMENT 1 ON LINE 1532
	     if pcb.sync_line
	     then copied_meters_ptr -> fnp_sync_meters.pad (*) = 0;

006547  aa  7 00004 2351 00	lda  	pr7|4		pcb.sync_line
006550  aa   020000 3150 03	cana 	8192,du
006551  aa   000013 6000 04	tze  	11,ic		006564
006552  aa   000001 2360 07	ldq  	1,dl
006553  aa  6 00434 7561 00	stq  	pr6|284
006554  aa  6 00434 7271 00	lxl7 	pr6|284
006555  aa  6 00432 3735 20	epp7 	pr6|282,*		copied_meters_ptr
006556  aa  7 00026 4501 17	stz  	pr7|22,7		fnp_sync_meters.pad
006557  aa  6 00434 2361 00	ldq  	pr6|284
006560  aa  6 00434 0541 00	aos  	pr6|284
006561  aa   000003 1160 07	cmpq 	3,dl
006562  aa   777772 6040 04	tmi  	-6,ic		006554
006563  aa   000012 7100 04	tra  	10,ic		006575
						STATEMENT 1 ON LINE 1534
	     else copied_meters_ptr -> fnp_async_meters.pad (*) = 0;

006564  aa   000001 2360 07	ldq  	1,dl
006565  aa  6 00434 7561 00	stq  	pr6|284
006566  aa  6 00434 7271 00	lxl7 	pr6|284
006567  aa  6 00432 3735 20	epp7 	pr6|282,*		copied_meters_ptr
006570  aa  7 00013 4501 17	stz  	pr7|11,7		fnp_async_meters.pad
006571  aa  6 00434 2361 00	ldq  	pr6|284
006572  aa  6 00434 0541 00	aos  	pr6|284
006573  aa   000016 1160 07	cmpq 	14,dl
006574  aa   777772 6040 04	tmi  	-6,ic		006566
						STATEMENT 1 ON LINE 1536
	     pcb.saved_meters_ptr -> fnp_channel_meters = copied_meters_ptr -> fnp_channel_meters;

006575  aa  6 00320 3715 20	epp5 	pr6|208,*		pcbp
006576  aa  5 00006 7651 00	lprp5	pr5|6		pcb.saved_meters_ptr
006577  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
006600  aa  7 00000 00 0150	desc9a	pr7|0,104		fnp_channel_meters
006601  aa  5 00000 00 0150	desc9a	pr5|0,104		fnp_channel_meters
						STATEMENT 1 ON LINE 1537
	     call tty_space_man$free_space (size (fnp_channel_meters), copied_meters_ptr);

006602  aa   000032 2360 07	ldq  	26,dl
006603  aa  6 00660 7561 00	stq  	pr6|432
006604  aa  6 00660 3521 00	epp2 	pr6|432
006605  aa  6 00664 2521 00	spri2	pr6|436
006606  aa  6 00432 3521 00	epp2 	pr6|282		copied_meters_ptr
006607  aa  6 00666 2521 00	spri2	pr6|438
006610  aa  6 00662 6211 00	eax1 	pr6|434
006611  aa   010000 4310 07	fld  	4096,dl
006612  aa  6 00044 3701 20	epp4 	pr6|36,*
006613  la  4 00136 3521 20	epp2 	pr4|94,*		tty_space_man$free_space
006614  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1539
	     pcb.copied_meters_offset = 0;

006615  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
006616  aa  7 00007 4501 00	stz  	pr7|7		pcb.copied_meters_offset
						STATEMENT 1 ON LINE 1540
	     pcb.copied_meters_ready = "0"b;

006617  aa   002074 2350 04	lda  	1084,ic		010713 = 777377777777
006620  aa  7 00004 3551 00	ansa 	pr7|4		pcb.copied_meters_ready
						STATEMENT 1 ON LINE 1541
	end;

						STATEMENT 1 ON LINE 1543
	return;

006621  aa  6 00424 6101 00	rtcd 	pr6|276
						STATEMENT 1 ON LINE 1544
     end save_copied_meters;

  END PROCEDURE save_copied_meters
BEGIN PROCEDURE process_mode
ENTRY TO process_mode                                       STATEMENT 1 ON LINE 1546
process_mode:
     proc (mode_name, mode_on);

006622  aa  6 00436 6501 00	spri4	pr6|286
006623  aa  6 00440 2521 00	spri2	pr6|288
006624  aa  2 00002 3521 01	epp2 	pr2|2,au
006625  aa  6 00442 2521 00	spri2	pr6|290
006626  aa  2 00000 2361 20	ldq  	pr2|0,*
006627  aa   000002 6040 04	tmi  	2,ic		006631
006630  aa   777777 3760 07	anq  	262143,dl
006631  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
006632  aa  6 00670 7561 00	stq  	pr6|440
						STATEMENT 1 ON LINE 1553
	alter_data = "00000000"b || mode_on;

006633  aa  6 00440 3735 20	epp7 	pr6|288,*
006634  aa  7 00004 3715 20	epp5 	pr7|4,*
006635  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
006636  aa  5 00000 00 0001	descb	pr5|0,1		mode_on
006637  aa  6 00671 00 0044	descb	pr6|441,36	mode_on
006640  aa  6 00671 2351 00	lda  	pr6|441		mode_on
006641  aa   000010 7710 00	arl  	8
006642  aa  6 00153 7551 00	sta  	pr6|107		alter_data
006643  aa   000011 2360 07	ldq  	9,dl
006644  aa  6 00152 7561 00	stq  	pr6|106		alter_data
						STATEMENT 1 ON LINE 1555
	if mode_name = "hndlquit"
	then do;

006645  aa  7 00002 3535 20	epp3 	pr7|2,*
006646  aa  6 00670 2351 00	lda  	pr6|440
006647  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006650  aa  3 00000 00 0005	desc9a	pr3|0,al		mode_name
006651  aa   771335 00 0010	desc9a	-3363,8		000204 = 150156144154
006652  aa   000014 6010 04	tnz  	12,ic		006666
						STATEMENT 1 ON LINE 1557
	     alter_type = Hndlquit;

006653  aa   000021 2360 07	ldq  	17,dl
006654  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 1558
	     pcb.hndlquit = mode_on;

006655  aa  6 00671 2351 00	lda  	pr6|441		mode_on
006656  aa   000006 7710 00	arl  	6
006657  aa  6 00320 3515 20	epp1 	pr6|208,*		pcbp
006660  aa  1 00004 6751 00	era  	pr1|4		pcb.hndlquit
006661  aa   004000 3750 03	ana  	2048,du
006662  aa  1 00004 6551 00	ersa 	pr1|4		pcb.hndlquit
						STATEMENT 1 ON LINE 1559
	     hndlquit_set = "1"b;

006663  aa   400000 2350 03	lda  	131072,du
006664  aa  6 00214 7551 00	sta  	pr6|140		hndlquit_set
						STATEMENT 1 ON LINE 1560
	end;

006665  aa   000160 7100 04	tra  	112,ic		007045
						STATEMENT 1 ON LINE 1562
	else if ^pcb.sync_line			/* if we haven't already decided what to do */
	then do;

006666  aa  6 00320 3515 20	epp1 	pr6|208,*		pcbp
006667  aa  1 00004 2351 00	lda  	pr1|4		pcb.sync_line
006670  aa   020000 3150 03	cana 	8192,du
006671  aa   000154 6010 04	tnz  	108,ic		007045
						STATEMENT 1 ON LINE 1564
	     if mode_name = "blk_xfer" | mode_name = "iflow"
						/* special stuff here */
	     then do;

006672  aa  6 00670 2361 00	ldq  	pr6|440
006673  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006674  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
006675  aa   771301 00 0010	desc9a	-3391,8		000174 = 142154153137
006676  aa   000005 6000 04	tze  	5,ic		006703
006677  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006700  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
006701  aa   771273 00 0005	desc9a	-3397,5		000172 = 151146154157
006702  aa   000106 6010 04	tnz  	70,ic		007010
						STATEMENT 1 ON LINE 1567
		if mode_name = "blk_xfer"
		then do;

006703  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
006704  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
006705  aa   771271 00 0010	desc9a	-3399,8		000174 = 142154153137
006706  aa   000006 6010 04	tnz  	6,ic		006714
						STATEMENT 1 ON LINE 1569
		     mode_name_index = BLK_XFER_INDEX;

006707  aa   000017 2360 07	ldq  	15,dl
006710  aa  6 00444 7561 00	stq  	pr6|292		mode_name_index
						STATEMENT 1 ON LINE 1570
		     alter_type = Block_xfer;

006711  aa   000031 2360 07	ldq  	25,dl
006712  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 1571
		end;

006713  aa   000005 7100 04	tra  	5,ic		006720
						STATEMENT 1 ON LINE 1572
		else do;

						STATEMENT 1 ON LINE 1573
		     mode_name_index = IFLOW_INDEX;

006714  aa   000016 2360 07	ldq  	14,dl
006715  aa  6 00444 7561 00	stq  	pr6|292		mode_name_index
						STATEMENT 1 ON LINE 1574
		     alter_type = Input_flow_control;

006716  aa   000035 2360 07	ldq  	29,dl
006717  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 1575
		end;

						STATEMENT 1 ON LINE 1577
		if mode_on
		then do;

006720  aa  6 00671 2351 00	lda  	pr6|441		mode_on
006721  aa   000011 6000 04	tze  	9,ic		006732
						STATEMENT 1 ON LINE 1579
		     chars_per_sec = divide (pcb.baud_rate, 10, 17, 0);

006722  aa  1 00002 2351 00	lda  	pr1|2		pcb.baud_rate
006723  aa   000066 7330 00	lrs  	54
006724  aa   000012 5060 07	div  	10,dl
006725  aa  6 00220 7561 00	stq  	pr6|144		chars_per_sec
						STATEMENT 1 ON LINE 1580
		     base_len, block_len = divide (chars_per_sec, buf_per_second, 17, 0);

006726  aa   000012 5060 07	div  	10,dl
006727  aa  6 00215 7561 00	stq  	pr6|141		base_len
006730  aa  6 00216 7561 00	stq  	pr6|142		block_len
						STATEMENT 1 ON LINE 1582
		end;

006731  aa   000004 7100 04	tra  	4,ic		006735
						STATEMENT 1 ON LINE 1583
		else do;

						STATEMENT 1 ON LINE 1584
		     base_len = 56;

006732  aa   000070 2360 07	ldq  	56,dl
006733  aa  6 00215 7561 00	stq  	pr6|141		base_len
						STATEMENT 1 ON LINE 1585
		     block_len = 0;

006734  aa  6 00216 4501 00	stz  	pr6|142		block_len
						STATEMENT 1 ON LINE 1586
		end;

						STATEMENT 1 ON LINE 1588
		alter_data = alter_data || bit (bin (base_len, 18), 18) || bit (bin (block_len, 18), 18);

006735  aa  6 00216 2351 00	lda  	pr6|142		block_len
006736  aa   000002 6050 04	tpl  	2,ic		006740
006737  aa   000000 5310 00	neg  	0
006740  aa   000022 7350 00	als  	18
006741  aa  6 00671 7551 00	sta  	pr6|441
006742  aa  6 00215 2351 00	lda  	pr6|141		base_len
006743  aa   000002 6050 04	tpl  	2,ic		006745
006744  aa   000000 5310 00	neg  	0
006745  aa   000022 7350 00	als  	18
006746  aa  6 00672 7551 00	sta  	pr6|442
006747  aa  6 00152 2361 00	ldq  	pr6|106		alter_data
006750  aa   000022 0760 07	adq  	18,dl
006751  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
006752  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
006753  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
006754  aa  6 00153 00 0017	descb	pr6|107,x7	alter_data
006755  aa  2 00000 00 0017	descb	pr2|0,x7
006756  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
006757  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
006760  aa  6 00672 00 0022	descb	pr6|442,18
006761  aa  2 00000 00 0022	descb	pr2|0,18
006762  aa  6 00672 7561 00	stq  	pr6|442
006763  aa   000022 0760 07	adq  	18,dl
006764  aa  6 00673 7561 00	stq  	pr6|443
006765  aa  0 00607 7001 00	tsx0 	pr0|391		cat_realloc_bits
006766  aa  6 00672 2351 00	lda  	pr6|442
006767  aa  003 105 060 500	csl  	(pr),(pr,al),fill(0),bool(move)
006770  aa  6 00671 00 0022	descb	pr6|441,18
006771  aa  2 00000 00 0022	descb	pr2|0,18
006772  aa  6 00673 2361 00	ldq  	pr6|443
006773  aa   000220 1160 07	cmpq 	144,dl
006774  aa   000002 6040 04	tmi  	2,ic		006776
006775  aa   000220 2360 07	ldq  	144,dl
006776  aa  6 00152 7561 00	stq  	pr6|106		alter_data
006777  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
007000  aa  2 00000 00 0006	descb	pr2|0,ql
007001  aa  6 00153 00 0006	descb	pr6|107,ql	alter_data
						STATEMENT 1 ON LINE 1589
		mode_set (mode_name_index) = "1"b;

007002  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007003  aa  6 00444 7271 00	lxl7 	pr6|292		mode_name_index
007004  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
007005  aa   000000 00 0000	descb	0,0
007006  aa  6 00212 70 0001	descb	pr6|138(35),1	mode_set
						STATEMENT 1 ON LINE 1590
	     end;

007007  aa   000036 7100 04	tra  	30,ic		007045
						STATEMENT 1 ON LINE 1592
	     else do;

						STATEMENT 1 ON LINE 1593
		do i = 1 to hbound (mode_alter_types, 1) while (mode_name ^= async_only_modes (i));

007010  aa   000001 2360 07	ldq  	1,dl
007011  aa  6 00114 7561 00	stq  	pr6|76		i
007012  aa  6 00114 2361 00	ldq  	pr6|76		i
007013  aa   000015 1160 07	cmpq 	13,dl
007014  aa   000014 6054 04	tpnz 	12,ic		007030
007015  aa   000001 7360 00	qls  	1
007016  aa  6 00440 3735 20	epp7 	pr6|288,*
007017  aa  7 00002 3715 20	epp5 	pr7|2,*
007020  ta   000046 3534 06	epp3 	38,ql
007021  aa  6 00670 2351 00	lda  	pr6|440
007022  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
007023  aa  5 00000 00 0005	desc9a	pr5|0,al		mode_name
007024  aa  3 00000 00 0010	desc9a	pr3|0,8		async_only_modes
007025  aa   000003 6000 04	tze  	3,ic		007030
						STATEMENT 1 ON LINE 1594
		end;

007026  aa  6 00114 0541 00	aos  	pr6|76		i
007027  aa   777763 7100 04	tra  	-13,ic		007012
						STATEMENT 1 ON LINE 1596
		if i > hbound (mode_alter_types, 1)
		then code = error_table_$bad_mode;

007030  aa  6 00114 2361 00	ldq  	pr6|76		i
007031  aa   000015 1160 07	cmpq 	13,dl
007032  aa   000005 6044 04	tmoz 	5,ic		007037
007033  aa  6 00044 3701 20	epp4 	pr6|36,*
007034  la  4 00064 2361 20	ldq  	pr4|52,*		error_table_$bad_mode
007035  aa  6 00100 7561 00	stq  	pr6|64		code
007036  aa   000007 7100 04	tra  	7,ic		007045
						STATEMENT 1 ON LINE 1599
		else do;

						STATEMENT 1 ON LINE 1600
		     alter_type = mode_alter_types (i);

007037  ta   000014 2360 06	ldq  	12,ql
007040  aa  6 00137 7561 00	stq  	pr6|95		alter_type
						STATEMENT 1 ON LINE 1601
		     mode_set (i) = "1"b;

007041  aa  6 00114 7271 00	lxl7 	pr6|76		i
007042  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
007043  aa   000000 00 0000	descb	0,0
007044  aa  6 00212 70 0001	descb	pr6|138(35),1	mode_set
						STATEMENT 1 ON LINE 1602
		end;

						STATEMENT 1 ON LINE 1603
	     end;

						STATEMENT 1 ON LINE 1604
	end;

						STATEMENT 1 ON LINE 1606
	if code = 0
	then do;

007045  aa  6 00100 2361 00	ldq  	pr6|64		code
007046  aa   000057 6010 04	tnz  	47,ic		007125
						STATEMENT 1 ON LINE 1608
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;

007047  aa  6 00137 2351 00	lda  	pr6|95		alter_type
007050  aa   000002 6050 04	tpl  	2,ic		007052
007051  aa   000000 5310 00	neg  	0
007052  aa   000033 7350 00	als  	27
007053  aa  6 00673 7551 00	sta  	pr6|443
007054  aa   000011 2360 07	ldq  	9,dl
007055  aa  6 00152 0761 00	adq  	pr6|106		alter_data
007056  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
007057  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007060  aa  6 00673 00 0011	descb	pr6|443,9
007061  aa  2 00000 00 0011	descb	pr2|0,9
007062  aa  6 00152 7271 00	lxl7 	pr6|106		alter_data
007063  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
007064  aa  6 00153 00 0017	descb	pr6|107,x7	alter_data
007065  aa  2 00000 20 0017	descb	pr2|0(9),x7
007066  aa  003 100 060 540	csl  	(pr,rl),(pr),fill(0),bool(move)
007067  aa  2 00000 00 0006	descb	pr2|0,ql
007070  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 1609
	     call dn355$send_wcd (fnpp, pcbp, alter_parameters, length (alter_data) + 9, mbx_data);

007071  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
007072  aa  6 00152 2361 00	ldq  	pr6|106		alter_data
007073  aa   000011 0760 07	adq  	9,dl
007074  aa  6 00673 7561 00	stq  	pr6|443
007075  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
007076  aa  6 00676 2521 00	spri2	pr6|446
007077  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
007100  aa  6 00700 2521 00	spri2	pr6|448
007101  aa   770711 3520 04	epp2 	-3639,ic		000012 = 000000000042
007102  aa  6 00702 2521 00	spri2	pr6|450
007103  aa  6 00673 3521 00	epp2 	pr6|443
007104  aa  6 00704 2521 00	spri2	pr6|452
007105  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
007106  aa  6 00706 2521 00	spri2	pr6|454
007107  aa   771057 3520 04	epp2 	-3537,ic		000166 = 464000000000
007110  aa  6 00710 2521 00	spri2	pr6|456
007111  aa  6 00712 2521 00	spri2	pr6|458
007112  aa   771034 3520 04	epp2 	-3556,ic		000146 = 404000000010
007113  aa  6 00714 2521 00	spri2	pr6|460
007114  aa   771054 3520 04	epp2 	-3540,ic		000170 = 404000000021
007115  aa  6 00716 2521 00	spri2	pr6|462
007116  aa   771017 3520 04	epp2 	-3569,ic		000135 = 516000000220
007117  aa  6 00720 2521 00	spri2	pr6|464
007120  aa  6 00674 6211 00	eax1 	pr6|444
007121  aa   024000 4310 07	fld  	10240,dl
007122  aa  6 00044 3701 20	epp4 	pr6|36,*
007123  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
007124  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1610
	end;

						STATEMENT 1 ON LINE 1611
	return;

007125  aa  6 00436 6101 00	rtcd 	pr6|286
						STATEMENT 1 ON LINE 1612
     end;

  END PROCEDURE process_mode
BEGIN PROCEDURE send_global
ENTRY TO send_global                                        STATEMENT 1 ON LINE 1614
send_global:
     proc (opcode);

007126  aa  6 00446 6501 00	spri4	pr6|294
007127  aa  6 00450 2521 00	spri2	pr6|296
						STATEMENT 1 ON LINE 1621
	call pxss$addevent (FNP_DUMP_PATCH_EVENT);

007130  aa   771026 3520 04	epp2 	-3562,ic		000156 = 000000000072
007131  aa  6 00724 2521 00	spri2	pr6|468
007132  aa  6 00722 6211 00	eax1 	pr6|466
007133  aa   004000 4310 07	fld  	2048,dl
007134  aa  6 00044 3701 20	epp4 	pr6|36,*
007135  la  4 00052 3521 20	epp2 	pr4|42,*		pxss$addevent
007136  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1622
	mbx_data = addr (dump_fnp_data) -> based_bit72;

007137  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007140  aa  6 00256 00 0110	descb	pr6|174,72	based_bit72
007141  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 1623
	call lock;

007142  aa   000750 6700 04	tsp4 	488,ic		010112
						STATEMENT 1 ON LINE 1624
	if code ^= 0
	then return;

007143  aa  6 00100 2361 00	ldq  	pr6|64		code
007144  aa   000002 6000 04	tze  	2,ic		007146
007145  aa  6 00446 6101 00	rtcd 	pr6|294
						STATEMENT 1 ON LINE 1627
	call dn355$send_global_wcd (fnpp, opcode, 72, mbx_data);

007146  aa   000110 2360 07	ldq  	72,dl
007147  aa  6 00726 7561 00	stq  	pr6|470
007150  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
007151  aa  6 00732 2521 00	spri2	pr6|474
007152  aa  6 00450 3735 20	epp7 	pr6|296,*
007153  aa  7 00002 3521 20	epp2 	pr7|2,*		opcode
007154  aa  6 00734 2521 00	spri2	pr6|476
007155  aa  6 00726 3521 00	epp2 	pr6|470
007156  aa  6 00736 2521 00	spri2	pr6|478
007157  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
007160  aa  6 00740 2521 00	spri2	pr6|480
007161  aa   771005 3520 04	epp2 	-3579,ic		000166 = 464000000000
007162  aa  6 00742 2521 00	spri2	pr6|482
007163  aa   770763 3520 04	epp2 	-3597,ic		000146 = 404000000010
007164  aa  6 00744 2521 00	spri2	pr6|484
007165  aa   771003 3520 04	epp2 	-3581,ic		000170 = 404000000021
007166  aa  6 00746 2521 00	spri2	pr6|486
007167  aa   770746 3520 04	epp2 	-3610,ic		000135 = 516000000220
007170  aa  6 00750 2521 00	spri2	pr6|488
007171  aa  6 00730 6211 00	eax1 	pr6|472
007172  aa   020000 4310 07	fld  	8192,dl
007173  aa  6 00044 3701 20	epp4 	pr6|36,*
007174  la  4 00012 3521 20	epp2 	pr4|10,*		dn355$send_global_wcd
007175  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1628
	call unlock;

007176  aa   001000 6700 04	tsp4 	512,ic		010176
						STATEMENT 1 ON LINE 1630
	call pxss$wait;

007177  aa  6 00056 6211 00	eax1 	pr6|46
007200  aa   000000 4310 07	fld  	0,dl
007201  aa  6 00044 3701 20	epp4 	pr6|36,*
007202  la  4 00056 3521 20	epp2 	pr4|46,*		pxss$wait
007203  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1632
	do while (fnp_info.dump_patch_in_progress);

007204  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
007205  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.dump_patch_in_progress
007206  aa   020000 3150 03	cana 	8192,du
007207  aa   000117 6000 04	tze  	79,ic		007326
						STATEMENT 1 ON LINE 1633
	     if ^fnp_info.running			/* FNP crashed out from under us */
	     then do;

007210  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
007211  aa   100000 3150 03	cana 	32768,du
007212  aa   000007 6010 04	tnz  	7,ic		007221
						STATEMENT 1 ON LINE 1635
		code = error_table_$mpx_down;

007213  aa  6 00044 3701 20	epp4 	pr6|36,*
007214  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$mpx_down
007215  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1636
		fnp_info.dump_patch_in_progress = "0"b;

007216  aa   001474 2350 04	lda  	828,ic		010712 = 757777777777
007217  aa  7 00030 3551 00	ansa 	pr7|24		fnp_info.dump_patch_in_progress
						STATEMENT 1 ON LINE 1637
	     end;

007220  aa   777764 7100 04	tra  	-12,ic		007204
						STATEMENT 1 ON LINE 1639
	     else if clock () - dump_patch_time > DUMP_PATCH_LIMIT
						/* time's up! */
	     then do;

007221  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007222  aa  6 00254 1771 00	sbaq 	pr6|172		dump_patch_time
007223  aa  6 00752 7571 00	staq 	pr6|490
007224  aa   770664 2350 04	lda  	-3660,ic		000110 = 000046113200
007225  aa   000044 7330 00	lrs  	36
007226  aa  6 00752 1171 00	cmpaq	pr6|490
007227  aa   000046 6050 04	tpl  	38,ic		007275
						STATEMENT 1 ON LINE 1642
		code = error_table_$timeout;

007230  aa  6 00044 3701 20	epp4 	pr6|36,*
007231  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$timeout
007232  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1643
		fnp_info.dump_patch_disabled = "1"b;

007233  aa   002000 2350 03	lda  	1024,du
007234  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
007235  aa  7 00030 2551 00	orsa 	pr7|24		fnp_info.dump_patch_disabled
						STATEMENT 1 ON LINE 1644
		fnp_info.dump_patch_in_progress = "0"b;

007236  aa   001454 2350 04	lda  	812,ic		010712 = 757777777777
007237  aa  7 00030 3551 00	ansa 	pr7|24		fnp_info.dump_patch_in_progress
						STATEMENT 1 ON LINE 1645
		call syserr (ANNOUNCE, "fnp_multiplexer: ^[dump^;patch^]_fnp order to FNP ^a timed out.",
		     opcode = dump_mem, fnp_info.fnp_tag);

007240  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
007241  aa   771322 00 0100	desc9a	-3374,64		000562 = 146156160137
007242  aa  6 00730 00 0100	desc9a	pr6|472,64
007243  aa  6 00450 3715 20	epp5 	pr6|296,*
007244  aa  5 00002 2361 20	ldq  	pr5|2,*		opcode
007245  aa   000023 1160 07	cmpq 	19,dl
007246  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
007247  aa  6 00726 7551 00	sta  	pr6|470
007250  aa   770702 3520 04	epp2 	-3646,ic		000152 = 000000000000
007251  aa  6 00756 2521 00	spri2	pr6|494
007252  aa  6 00730 3521 00	epp2 	pr6|472
007253  aa  6 00760 2521 00	spri2	pr6|496
007254  aa  6 00726 3521 00	epp2 	pr6|470
007255  aa  6 00762 2521 00	spri2	pr6|498
007256  aa  7 00007 3521 00	epp2 	pr7|7		fnp_info.fnp_tag
007257  aa  6 00764 2521 00	spri2	pr6|500
007260  aa   770710 3520 04	epp2 	-3640,ic		000170 = 404000000021
007261  aa  6 00766 2521 00	spri2	pr6|502
007262  aa   770637 3520 04	epp2 	-3681,ic		000121 = 524000000077
007263  aa  6 00770 2521 00	spri2	pr6|504
007264  aa   770700 3520 04	epp2 	-3648,ic		000164 = 514000000001
007265  aa  6 00772 2521 00	spri2	pr6|506
007266  aa   770665 3520 04	epp2 	-3659,ic		000153 = 526000000001
007267  aa  6 00774 2521 00	spri2	pr6|508
007270  aa  6 00754 6211 00	eax1 	pr6|492
007271  aa   020000 4310 07	fld  	8192,dl
007272  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
007273  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1647
	     end;

007274  aa   777710 7100 04	tra  	-56,ic		007204
						STATEMENT 1 ON LINE 1649
	     else do;

						STATEMENT 1 ON LINE 1650
		call pxss$addevent (FNP_DUMP_PATCH_EVENT);

007275  aa   770661 3520 04	epp2 	-3663,ic		000156 = 000000000072
007276  aa  6 00724 2521 00	spri2	pr6|468
007277  aa  6 00722 6211 00	eax1 	pr6|466
007300  aa   004000 4310 07	fld  	2048,dl
007301  aa  6 00044 3701 20	epp4 	pr6|36,*
007302  la  4 00052 3521 20	epp2 	pr4|42,*		pxss$addevent
007303  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1651
		if fnp_info.dump_patch_in_progress	/* make sure it still hasn't happened */
		then call pxss$wait;

007304  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
007305  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.dump_patch_in_progress
007306  aa   020000 3150 03	cana 	8192,du
007307  aa   000007 6000 04	tze  	7,ic		007316
007310  aa  6 00056 6211 00	eax1 	pr6|46
007311  aa   000000 4310 07	fld  	0,dl
007312  aa  6 00044 3701 20	epp4 	pr6|36,*
007313  la  4 00056 3521 20	epp2 	pr4|46,*		pxss$wait
007314  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
007315  aa   777667 7100 04	tra  	-73,ic		007204
						STATEMENT 1 ON LINE 1653
		else call pxss$delevent (FNP_DUMP_PATCH_EVENT);

007316  aa   770640 3520 04	epp2 	-3680,ic		000156 = 000000000072
007317  aa  6 00724 2521 00	spri2	pr6|468
007320  aa  6 00722 6211 00	eax1 	pr6|466
007321  aa   004000 4310 07	fld  	2048,dl
007322  aa  6 00044 3701 20	epp4 	pr6|36,*
007323  la  4 00054 3521 20	epp2 	pr4|44,*		pxss$delevent
007324  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1655
	     end;

						STATEMENT 1 ON LINE 1657
	end;

007325  aa   777657 7100 04	tra  	-81,ic		007204
						STATEMENT 1 ON LINE 1659
	return;

007326  aa  6 00446 6101 00	rtcd 	pr6|294
						STATEMENT 1 ON LINE 1661
     end send_global;

  END PROCEDURE send_global
BEGIN PROCEDURE get_fnp_meters
ENTRY TO get_fnp_meters                                     STATEMENT 1 ON LINE 1663
get_fnp_meters:
     proc (global);

007327  aa  6 00454 6501 00	spri4	pr6|300
007330  aa  6 00456 2521 00	spri2	pr6|302
						STATEMENT 1 ON LINE 1672
	if fnp_info.dump_patch_disabled
	then do;

007331  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
007332  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.dump_patch_disabled
007333  aa   002000 3150 03	cana 	1024,du
007334  aa   000007 6000 04	tze  	7,ic		007343
						STATEMENT 1 ON LINE 1674
	     code = error_table_$timeout;

007335  aa  6 00044 3701 20	epp4 	pr6|36,*
007336  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$timeout
007337  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1675
	     fnp_meters_ptr = null ();

007340  aa   770666 2370 04	ldaq 	-3658,ic		000226 = 077777000043 000001000000
007341  aa  6 00170 7571 00	staq 	pr6|120		fnp_meters_ptr
						STATEMENT 1 ON LINE 1676
	     return;

007342  aa  6 00454 6101 00	rtcd 	pr6|300
						STATEMENT 1 ON LINE 1677
	end;

						STATEMENT 1 ON LINE 1679
	if global
	then space_size = size (fnp_global_meters);

007343  aa  2 00002 3715 20	epp5 	pr2|2,*
007344  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
007345  aa  5 00000 00 0001	descb	pr5|0,1		global
007346  aa   000000 00 0000	descb	0,0
007347  aa   000004 6000 04	tze  	4,ic		007353
007350  aa   000023 2360 07	ldq  	19,dl
007351  aa  6 00462 7561 00	stq  	pr6|306		space_size
007352  aa   000003 7100 04	tra  	3,ic		007355
						STATEMENT 1 ON LINE 1681
	else space_size = size (fnp_channel_meters);

007353  aa   000032 2360 07	ldq  	26,dl
007354  aa  6 00462 7561 00	stq  	pr6|306		space_size
						STATEMENT 1 ON LINE 1683
	call tty_space_man$get_space (space_size, fnp_meters_ptr);

007355  aa  6 00462 3521 00	epp2 	pr6|306		space_size
007356  aa  6 01000 2521 00	spri2	pr6|512
007357  aa  6 00170 3521 00	epp2 	pr6|120		fnp_meters_ptr
007360  aa  6 01002 2521 00	spri2	pr6|514
007361  aa  6 00776 6211 00	eax1 	pr6|510
007362  aa   010000 4310 07	fld  	4096,dl
007363  aa  6 00044 3701 20	epp4 	pr6|36,*
007364  la  4 00134 3521 20	epp2 	pr4|92,*		tty_space_man$get_space
007365  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1684
	if fnp_meters_ptr = null ()
	then do;

007366  aa  6 00170 2371 00	ldaq 	pr6|120		fnp_meters_ptr
007367  aa   770637 6770 04	eraq 	-3681,ic		000226 = 077777000043 000001000000
007370  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007371  aa   000005 6010 04	tnz  	5,ic		007376
						STATEMENT 1 ON LINE 1686
	     code = error_table_$noalloc;

007372  aa  6 00044 3701 20	epp4 	pr6|36,*
007373  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$noalloc
007374  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1687
	     return;

007375  aa  6 00454 6101 00	rtcd 	pr6|300
						STATEMENT 1 ON LINE 1688
	end;

						STATEMENT 1 ON LINE 1690
	mbx_data = bit (bin (tty_buf.absorig + bin (rel (fnp_meters_ptr)), 18), 18);

007376  aa  6 00170 6351 20	eaa  	pr6|120,*		fnp_meters_ptr
007377  aa   000066 7730 00	lrl  	54
007400  aa  6 00300 3735 20	epp7 	pr6|192,*		ttybp
007401  aa  7 00001 0331 00	adl  	pr7|1		tty_buf.absorig
007402  aa   000003 6050 04	tpl  	3,ic		007405
007403  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
007404  aa   000001 0760 07	adq  	1,dl
007405  aa   000066 7370 00	lls  	54
007406  aa  6 01004 7551 00	sta  	pr6|516
007407  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007410  aa  6 01004 00 0022	descb	pr6|516,18
007411  aa  6 00142 00 0220	descb	pr6|98,144	mbx_data
						STATEMENT 1 ON LINE 1691
	call pxss$addevent (FNP_METER_EVENT);

007412  aa   770402 3520 04	epp2 	-3838,ic		000014 = 000000000073
007413  aa  6 01000 2521 00	spri2	pr6|512
007414  aa  6 00776 6211 00	eax1 	pr6|510
007415  aa   004000 4310 07	fld  	2048,dl
007416  aa  6 00044 3701 20	epp4 	pr6|36,*
007417  la  4 00052 3521 20	epp2 	pr4|42,*		pxss$addevent
007420  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1692
	fnp_meter_wait_start = clock ();

007421  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007422  aa  6 00464 7571 00	staq 	pr6|308		fnp_meter_wait_start
						STATEMENT 1 ON LINE 1694
	if global					/* it's for whole FNP */
	then do;

007423  aa  6 00456 3735 20	epp7 	pr6|302,*
007424  aa  7 00002 3715 20	epp5 	pr7|2,*
007425  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
007426  aa  5 00000 00 0001	descb	pr5|0,1		global
007427  aa   000000 00 0000	descb	0,0
007430  aa   000045 6000 04	tze  	37,ic		007475
						STATEMENT 1 ON LINE 1696
	     if fnp_info.get_meters_waiting
	     then do;

007431  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
007432  aa  3 00030 2351 00	lda  	pr3|24		fnp_info.get_meters_waiting
007433  aa   000020 3150 03	cana 	16,du
007434  aa   000005 6000 04	tze  	5,ic		007441
						STATEMENT 1 ON LINE 1698
		code = error_table_$seglock;

007435  aa  6 00044 3701 20	epp4 	pr6|36,*
007436  la  4 00076 2361 20	ldq  	pr4|62,*		error_table_$seglock
007437  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1699
		return;

007440  aa  6 00454 6101 00	rtcd 	pr6|300
						STATEMENT 1 ON LINE 1700
	     end;

						STATEMENT 1 ON LINE 1702
	     fnp_info.get_meters_waiting = "1"b;

007441  aa   000020 2350 03	lda  	16,du
007442  aa  3 00030 2551 00	orsa 	pr3|24		fnp_info.get_meters_waiting
						STATEMENT 1 ON LINE 1703
	     call dn355$send_global_wcd (fnpp, report_meters, 18, mbx_data);

007443  aa   000022 2360 07	ldq  	18,dl
007444  aa  6 01004 7561 00	stq  	pr6|516
007445  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
007446  aa  6 01010 2521 00	spri2	pr6|520
007447  aa   770510 3520 04	epp2 	-3768,ic		000157 = 000000000044
007450  aa  6 01012 2521 00	spri2	pr6|522
007451  aa  6 01004 3521 00	epp2 	pr6|516
007452  aa  6 01014 2521 00	spri2	pr6|524
007453  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
007454  aa  6 01016 2521 00	spri2	pr6|526
007455  aa   770511 3520 04	epp2 	-3767,ic		000166 = 464000000000
007456  aa  6 01020 2521 00	spri2	pr6|528
007457  aa   770467 3520 04	epp2 	-3785,ic		000146 = 404000000010
007460  aa  6 01022 2521 00	spri2	pr6|530
007461  aa   770507 3520 04	epp2 	-3769,ic		000170 = 404000000021
007462  aa  6 01024 2521 00	spri2	pr6|532
007463  aa   770452 3520 04	epp2 	-3798,ic		000135 = 516000000220
007464  aa  6 01026 2521 00	spri2	pr6|534
007465  aa  6 01006 6211 00	eax1 	pr6|518
007466  aa   020000 4310 07	fld  	8192,dl
007467  aa  6 00044 3701 20	epp4 	pr6|36,*
007470  la  4 00012 3521 20	epp2 	pr4|10,*		dn355$send_global_wcd
007471  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1704
	     pcbp = fnpp;

007472  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
007473  aa  6 00320 6535 00	spri7	pr6|208		pcbp
						STATEMENT 1 ON LINE 1705
	end;

007474  aa   000036 7100 04	tra  	30,ic		007532
						STATEMENT 1 ON LINE 1707
	else do;

						STATEMENT 1 ON LINE 1708
	     pcb.get_meters_waiting = "1"b;

007475  aa   000200 2350 03	lda  	128,du
007476  aa  6 00320 3535 20	epp3 	pr6|208,*		pcbp
007477  aa  3 00004 2551 00	orsa 	pr3|4		pcb.get_meters_waiting
						STATEMENT 1 ON LINE 1709
	     call dn355$send_wcd (fnpp, pcbp, report_meters, 18, mbx_data);

007500  aa   000022 2360 07	ldq  	18,dl
007501  aa  6 01004 7561 00	stq  	pr6|516
007502  aa  6 00314 3521 00	epp2 	pr6|204		fnpp
007503  aa  6 01032 2521 00	spri2	pr6|538
007504  aa  6 00320 3521 00	epp2 	pr6|208		pcbp
007505  aa  6 01034 2521 00	spri2	pr6|540
007506  aa   770451 3520 04	epp2 	-3799,ic		000157 = 000000000044
007507  aa  6 01036 2521 00	spri2	pr6|542
007510  aa  6 01004 3521 00	epp2 	pr6|516
007511  aa  6 01040 2521 00	spri2	pr6|544
007512  aa  6 00142 3521 00	epp2 	pr6|98		mbx_data
007513  aa  6 01042 2521 00	spri2	pr6|546
007514  aa   770452 3520 04	epp2 	-3798,ic		000166 = 464000000000
007515  aa  6 01044 2521 00	spri2	pr6|548
007516  aa  6 01046 2521 00	spri2	pr6|550
007517  aa   770427 3520 04	epp2 	-3817,ic		000146 = 404000000010
007520  aa  6 01050 2521 00	spri2	pr6|552
007521  aa   770447 3520 04	epp2 	-3801,ic		000170 = 404000000021
007522  aa  6 01052 2521 00	spri2	pr6|554
007523  aa   770412 3520 04	epp2 	-3830,ic		000135 = 516000000220
007524  aa  6 01054 2521 00	spri2	pr6|556
007525  aa  6 01030 6211 00	eax1 	pr6|536
007526  aa   024000 4310 07	fld  	10240,dl
007527  aa  6 00044 3701 20	epp4 	pr6|36,*
007530  la  4 00010 3521 20	epp2 	pr4|8,*		dn355$send_wcd
007531  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1710
	end;

						STATEMENT 1 ON LINE 1712
	call unlock;

007532  aa   000444 6700 04	tsp4 	292,ic		010176
						STATEMENT 1 ON LINE 1713
	call pxss$wait;

007533  aa  6 00056 6211 00	eax1 	pr6|46
007534  aa   000000 4310 07	fld  	0,dl
007535  aa  6 00044 3701 20	epp4 	pr6|36,*
007536  la  4 00056 3521 20	epp2 	pr4|46,*		pxss$wait
007537  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1714
	call lock;

007540  aa   000352 6700 04	tsp4 	234,ic		010112
						STATEMENT 1 ON LINE 1716
	do while ((global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting));

007541  aa   000000 0110 03	nop  	0,du
007542  aa  6 00456 3735 20	epp7 	pr6|302,*
007543  aa  7 00002 3715 20	epp5 	pr7|2,*
007544  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007545  aa  5 00000 00 0001	descb	pr5|0,1		global
007546  aa  6 01004 00 0044	descb	pr6|516,36	global
007547  aa  6 01004 2351 00	lda  	pr6|516		global
007550  aa   000005 6000 04	tze  	5,ic		007555
007551  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
007552  aa  3 00030 2351 00	lda  	pr3|24		fnp_info.get_meters_waiting
007553  aa   000020 3150 03	cana 	16,du
007554  aa   000007 6010 04	tnz  	7,ic		007563
007555  aa  6 01004 2351 00	lda  	pr6|516		global
007556  aa   000156 6010 04	tnz  	110,ic		007734
007557  aa  6 00320 3535 20	epp3 	pr6|208,*		pcbp
007560  aa  3 00004 2351 00	lda  	pr3|4		pcb.get_meters_waiting
007561  aa   000200 3150 03	cana 	128,du
007562  aa   000152 6000 04	tze  	106,ic		007734
						STATEMENT 1 ON LINE 1717
	     if ^fnp_info.running
	     then do;

007563  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
007564  aa  3 00030 2351 00	lda  	pr3|24		fnp_info.running
007565  aa   100000 3150 03	cana 	32768,du
007566  aa   000005 6010 04	tnz  	5,ic		007573
						STATEMENT 1 ON LINE 1719
		code = error_table_$mpx_down;

007567  aa  6 00044 3701 20	epp4 	pr6|36,*
007570  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$mpx_down
007571  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1720
		go to abort_get_meters;

007572  aa   000054 7100 04	tra  	44,ic		007646
						STATEMENT 1 ON LINE 1721
	     end;

						STATEMENT 1 ON LINE 1723
	     else if clock () - fnp_meter_wait_start > DUMP_PATCH_LIMIT
	     then do;

007573  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
007574  aa  6 00464 1771 00	sbaq 	pr6|308		fnp_meter_wait_start
007575  aa  6 01056 7571 00	staq 	pr6|558
007576  aa   770312 2350 04	lda  	-3894,ic		000110 = 000046113200
007577  aa   000044 7330 00	lrs  	36
007600  aa  6 01056 1171 00	cmpaq	pr6|558
007601  aa   000063 6050 04	tpl  	51,ic		007664
						STATEMENT 1 ON LINE 1725
		code = error_table_$timeout;

007602  aa  6 00044 3701 20	epp4 	pr6|36,*
007603  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$timeout
007604  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1726
		fnp_info.dump_patch_disabled = "1"b;

007605  aa   002000 2350 03	lda  	1024,du
007606  aa  3 00030 2551 00	orsa 	pr3|24		fnp_info.dump_patch_disabled
						STATEMENT 1 ON LINE 1727
		call syserr (ANNOUNCE,
		     "fnp_multiplexer: get_meters order for FNP ^a^[^s^;, line ^o,^] timed out.", fnp_info.fnp_tag,
		     global, string (pcb.line_number));

007607  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
007610  aa   771016 00 0114	desc9a	-3570,76		000625 = 146156160137
007611  aa  6 01030 00 0114	desc9a	pr6|536,76
007612  aa  6 00320 2351 20	lda  	pr6|208,*
007613  aa   000032 7350 00	als  	26
007614  aa  6 01004 7551 00	sta  	pr6|516
007615  aa   770335 3520 04	epp2 	-3875,ic		000152 = 000000000000
007616  aa  6 01062 2521 00	spri2	pr6|562
007617  aa  6 01030 3521 00	epp2 	pr6|536
007620  aa  6 01064 2521 00	spri2	pr6|564
007621  aa  3 00007 3521 00	epp2 	pr3|7		fnp_info.fnp_tag
007622  aa  6 01066 2521 00	spri2	pr6|566
007623  aa  6 00456 3735 20	epp7 	pr6|302,*
007624  aa  7 00002 3521 20	epp2 	pr7|2,*		global
007625  aa  6 01070 2521 00	spri2	pr6|568
007626  aa  6 01004 3521 00	epp2 	pr6|516
007627  aa  6 01072 2521 00	spri2	pr6|570
007630  aa   770340 3520 04	epp2 	-3872,ic		000170 = 404000000021
007631  aa  6 01074 2521 00	spri2	pr6|572
007632  aa   770266 3520 04	epp2 	-3914,ic		000120 = 524000000111
007633  aa  6 01076 2521 00	spri2	pr6|574
007634  aa   770317 3520 04	epp2 	-3889,ic		000153 = 526000000001
007635  aa  6 01100 2521 00	spri2	pr6|576
007636  aa   770311 3520 04	epp2 	-3895,ic		000147 = 516000000001
007637  aa  6 01102 2521 00	spri2	pr6|578
007640  aa   770257 3520 04	epp2 	-3921,ic		000117 = 514000000012
007641  aa  6 01104 2521 00	spri2	pr6|580
007642  aa  6 01060 6211 00	eax1 	pr6|560
007643  aa   024000 4310 07	fld  	10240,dl
007644  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
007645  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1730
abort_get_meters:
		if global
		then fnp_info.get_meters_waiting = "0"b;

007646  aa  6 00456 3735 20	epp7 	pr6|302,*
007647  aa  7 00002 3715 20	epp5 	pr7|2,*
007650  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
007651  aa  5 00000 00 0001	descb	pr5|0,1		global
007652  aa   000000 00 0000	descb	0,0
007653  aa   000005 6000 04	tze  	5,ic		007660
007654  aa   001035 2350 04	lda  	541,ic		010711 = 777757777777
007655  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
007656  aa  3 00030 3551 00	ansa 	pr3|24		fnp_info.get_meters_waiting
007657  aa   777663 7100 04	tra  	-77,ic		007542
						STATEMENT 1 ON LINE 1733
		else pcb.get_meters_waiting = "0"b;

007660  aa   001030 2350 04	lda  	536,ic		010710 = 777577777777
007661  aa  6 00320 3535 20	epp3 	pr6|208,*		pcbp
007662  aa  3 00004 3551 00	ansa 	pr3|4		pcb.get_meters_waiting
						STATEMENT 1 ON LINE 1734
	     end;

007663  aa   777657 7100 04	tra  	-81,ic		007542
						STATEMENT 1 ON LINE 1736
	     else do;

						STATEMENT 1 ON LINE 1737
		call unlock;

007664  aa   000312 6700 04	tsp4 	202,ic		010176
						STATEMENT 1 ON LINE 1738
		call pxss$addevent (FNP_METER_EVENT);

007665  aa   770127 3520 04	epp2 	-4009,ic		000014 = 000000000073
007666  aa  6 01000 2521 00	spri2	pr6|512
007667  aa  6 00776 6211 00	eax1 	pr6|510
007670  aa   004000 4310 07	fld  	2048,dl
007671  aa  6 00044 3701 20	epp4 	pr6|36,*
007672  la  4 00052 3521 20	epp2 	pr4|42,*		pxss$addevent
007673  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1739
		if (global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting)
						/* check if it happened since we checked */
		then call pxss$wait;

007674  aa  6 00456 3735 20	epp7 	pr6|302,*
007675  aa  7 00002 3715 20	epp5 	pr7|2,*
007676  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
007677  aa  5 00000 00 0001	descb	pr5|0,1		global
007700  aa  6 01004 00 0044	descb	pr6|516,36	global
007701  aa  6 01004 2351 00	lda  	pr6|516		global
007702  aa   000005 6000 04	tze  	5,ic		007707
007703  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
007704  aa  3 00030 2351 00	lda  	pr3|24		fnp_info.get_meters_waiting
007705  aa   000020 3150 03	cana 	16,du
007706  aa   000007 6010 04	tnz  	7,ic		007715
007707  aa  6 01004 2351 00	lda  	pr6|516		global
007710  aa   000013 6010 04	tnz  	11,ic		007723
007711  aa  6 00320 3535 20	epp3 	pr6|208,*		pcbp
007712  aa  3 00004 2351 00	lda  	pr3|4		pcb.get_meters_waiting
007713  aa   000200 3150 03	cana 	128,du
007714  aa   000007 6000 04	tze  	7,ic		007723
007715  aa  6 00056 6211 00	eax1 	pr6|46
007716  aa   000000 4310 07	fld  	0,dl
007717  aa  6 00044 3701 20	epp4 	pr6|36,*
007720  la  4 00056 3521 20	epp2 	pr4|46,*		pxss$wait
007721  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
007722  aa   000010 7100 04	tra  	8,ic		007732
						STATEMENT 1 ON LINE 1742
		else call pxss$delevent (FNP_METER_EVENT);

007723  aa   770071 3520 04	epp2 	-4039,ic		000014 = 000000000073
007724  aa  6 01000 2521 00	spri2	pr6|512
007725  aa  6 00776 6211 00	eax1 	pr6|510
007726  aa   004000 4310 07	fld  	2048,dl
007727  aa  6 00044 3701 20	epp4 	pr6|36,*
007730  la  4 00054 3521 20	epp2 	pr4|44,*		pxss$delevent
007731  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1743
		call lock;

007732  aa   000160 6700 04	tsp4 	112,ic		010112
						STATEMENT 1 ON LINE 1744
	     end;

						STATEMENT 1 ON LINE 1745
	end;

007733  aa   777607 7100 04	tra  	-121,ic		007542
						STATEMENT 1 ON LINE 1747
	return;

007734  aa  6 00454 6101 00	rtcd 	pr6|300
						STATEMENT 1 ON LINE 1748
     end get_fnp_meters;

  END PROCEDURE get_fnp_meters
BEGIN PROCEDURE name_to_pcb
ENTRY TO name_to_pcb                                        STATEMENT 1 ON LINE 1750
name_to_pcb:
     proc (name);

007735  aa  6 00466 6501 00	spri4	pr6|310
007736  aa  6 00470 2521 00	spri2	pr6|312
007737  aa  2 00002 3521 01	epp2 	pr2|2,au
007740  aa  6 00472 2521 00	spri2	pr6|314
007741  aa  2 00000 2361 20	ldq  	pr2|0,*
007742  aa   000002 6040 04	tmi  	2,ic		007744
007743  aa   777777 3760 07	anq  	262143,dl
007744  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
007745  aa  6 01106 7561 00	stq  	pr6|582
						STATEMENT 1 ON LINE 1755
	code = 0;

007746  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1756
	call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);

007747  aa  6 00470 3735 20	epp7 	pr6|312,*
007750  aa  7 00002 3521 20	epp2 	pr7|2,*		name
007751  aa  6 01112 2521 00	spri2	pr6|586
007752  aa  6 00231 3521 00	epp2 	pr6|153		his_fnp_no
007753  aa  6 01114 2521 00	spri2	pr6|588
007754  aa  6 00221 3521 00	epp2 	pr6|145		hsla_flag
007755  aa  6 01116 2521 00	spri2	pr6|590
007756  aa  6 00227 3521 00	epp2 	pr6|151		la_no
007757  aa  6 01120 2521 00	spri2	pr6|592
007760  aa  6 00230 3521 00	epp2 	pr6|152		subchan
007761  aa  6 01122 2521 00	spri2	pr6|594
007762  aa  6 00472 3715 20	epp5 	pr6|314,*
007763  aa  5 00000 3521 20	epp2 	pr5|0,*
007764  aa  6 01124 2521 00	spri2	pr6|596
007765  aa   770203 3520 04	epp2 	-3965,ic		000170 = 404000000021
007766  aa  6 01126 2521 00	spri2	pr6|598
007767  aa  6 01132 2521 00	spri2	pr6|602
007770  aa  6 01134 2521 00	spri2	pr6|604
007771  aa   770156 3520 04	epp2 	-3986,ic		000147 = 516000000001
007772  aa  6 01130 2521 00	spri2	pr6|600
007773  aa  6 01110 6211 00	eax1 	pr6|584
007774  aa   024000 4310 07	fld  	10240,dl
007775  aa  6 00044 3701 20	epp4 	pr6|36,*
007776  la  4 00046 3521 20	epp2 	pr4|38,*		parse_tty_name_
007777  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1757
	call lock;

010000  aa   000112 6700 04	tsp4 	74,ic		010112
						STATEMENT 1 ON LINE 1758
	if code ^= 0
	then return;

010001  aa  6 00100 2361 00	ldq  	pr6|64		code
010002  aa   000002 6000 04	tze  	2,ic		010004
010003  aa  6 00466 6101 00	rtcd 	pr6|310
						STATEMENT 1 ON LINE 1761
	if his_fnp_no ^= fnp_info.fnp_number
	then go to bad_device;

010004  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010005  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
010006  aa   000011 7350 00	als  	9
010007  aa   000077 7730 00	lrl  	63
010010  aa  6 00231 1161 00	cmpq 	pr6|153		his_fnp_no
010011  aa   000073 6010 04	tnz  	59,ic		010104
						STATEMENT 1 ON LINE 1764
	if hsla_flag
	then pcbx = fnp_info.hsla_idx (la_no);

010012  aa  6 00221 2351 00	lda  	pr6|145		hsla_flag
010013  aa   400000 3150 03	cana 	131072,du
010014  aa   000005 6000 04	tze  	5,ic		010021
010015  aa  6 00227 7271 00	lxl7 	pr6|151		la_no
010016  aa  7 00021 2361 17	ldq  	pr7|17,7		fnp_info.hsla_idx
010017  aa  6 00232 7561 00	stq  	pr6|154		pcbx
010020  aa   000004 7100 04	tra  	4,ic		010024
						STATEMENT 1 ON LINE 1766
	else pcbx = fnp_info.lsla_idx (la_no);

010021  aa  6 00227 7271 00	lxl7 	pr6|151		la_no
010022  aa  7 00013 2361 17	ldq  	pr7|11,7		fnp_info.lsla_idx
010023  aa  6 00232 7561 00	stq  	pr6|154		pcbx
						STATEMENT 1 ON LINE 1767
	if pcbx = -1
	then go to bad_device;

010024  aa   000756 1160 04	cmpq 	494,ic		011002 = 777777777777
010025  aa   000057 6000 04	tze  	47,ic		010104
						STATEMENT 1 ON LINE 1770
	found, past = "0"b;

010026  aa  6 00233 4501 00	stz  	pr6|155		found
010027  aa  6 00234 4501 00	stz  	pr6|156		past
						STATEMENT 1 ON LINE 1771
	do j = pcbx to fnp_info.no_of_channels while (^past & ^found);

010030  aa  7 00006 2361 00	ldq  	pr7|6		fnp_info.no_of_channels
010031  aa  6 00474 7561 00	stq  	pr6|316
010032  aa  6 00232 2361 00	ldq  	pr6|154		pcbx
010033  aa  6 00115 7561 00	stq  	pr6|77		j
010034  aa  6 00115 2361 00	ldq  	pr6|77		j
010035  aa  6 00474 1161 00	cmpq 	pr6|316
010036  aa   000044 6054 04	tpnz 	36,ic		010102
010037  aa  6 00234 2351 00	lda  	pr6|156		past
010040  aa   000042 6010 04	tnz  	34,ic		010102
010041  aa  6 00233 2351 00	lda  	pr6|155		found
010042  aa   000040 6010 04	tnz  	32,ic		010102
						STATEMENT 1 ON LINE 1772
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));

010043  aa   000003 7360 00	qls  	3
010044  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010045  aa  7 00002 3715 20	epp5 	pr7|2,*		fnp_info.pcb_array_ptr
010046  aa  5 77770 3735 06	epp7 	pr5|-8,ql		pcb_array
010047  aa  6 00320 6535 00	spri7	pr6|208		pcbp
						STATEMENT 1 ON LINE 1773
	     if pcb.la_no ^= bit (bin (la_no, 3), 3)
	     then past = "1"b;

010050  aa  6 00227 2351 00	lda  	pr6|151		la_no
010051  aa   000002 6050 04	tpl  	2,ic		010053
010052  aa   000000 5310 00	neg  	0
010053  aa   000041 7350 00	als  	33
010054  aa  6 01107 7551 00	sta  	pr6|583
010055  aa  7 00000 2351 00	lda  	pr7|0		pcb.la_no
010056  aa   000033 7350 00	als  	27
010057  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
010060  aa  6 01107 1151 00	cmpa 	pr6|583
010061  aa   000004 6000 04	tze  	4,ic		010065
010062  aa   400000 2350 03	lda  	131072,du
010063  aa  6 00234 7551 00	sta  	pr6|156		past
010064  aa   000014 7100 04	tra  	12,ic		010100
						STATEMENT 1 ON LINE 1775
	     else if pcb.slot_no = bit (bin (subchan, 6), 6)
	     then found = "1"b;

010065  aa  6 00230 2351 00	lda  	pr6|152		subchan
010066  aa   000002 6050 04	tpl  	2,ic		010070
010067  aa   000000 5310 00	neg  	0
010070  aa   000036 7350 00	als  	30
010071  aa  6 01107 7551 00	sta  	pr6|583
010072  aa  7 00000 2351 00	lda  	pr7|0		pcb.slot_no
010073  aa   000036 7350 00	als  	30
010074  aa  6 01107 1151 00	cmpa 	pr6|583
010075  aa   000003 6010 04	tnz  	3,ic		010100
010076  aa   400000 2350 03	lda  	131072,du
010077  aa  6 00233 7551 00	sta  	pr6|155		found
						STATEMENT 1 ON LINE 1777
	end;

010100  aa  6 00115 0541 00	aos  	pr6|77		j
010101  aa   777733 7100 04	tra  	-37,ic		010034
						STATEMENT 1 ON LINE 1779
	if ^found
	then do;

010102  aa  6 00233 2351 00	lda  	pr6|155		found
010103  aa   000006 6010 04	tnz  	6,ic		010111
						STATEMENT 1 ON LINE 1781
bad_device:
	     call unlock;

010104  aa   000072 6700 04	tsp4 	58,ic		010176
						STATEMENT 1 ON LINE 1783
	     code = error_table_$bad_channel;

010105  aa  6 00044 3701 20	epp4 	pr6|36,*
010106  la  4 00066 2361 20	ldq  	pr4|54,*		error_table_$bad_channel
010107  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1784
	     return;

010110  aa  6 00466 6101 00	rtcd 	pr6|310
						STATEMENT 1 ON LINE 1785
	end;

						STATEMENT 1 ON LINE 1787
	return;

010111  aa  6 00466 6101 00	rtcd 	pr6|310
						STATEMENT 1 ON LINE 1788
     end name_to_pcb;

  END PROCEDURE name_to_pcb
BEGIN PROCEDURE lock
ENTRY TO lock                                               STATEMENT 1 ON LINE 1790
lock:
     proc;

010112  aa  6 00476 6501 00	spri4	pr6|318
						STATEMENT 1 ON LINE 1795
	if fnpp = null ()
	then do;

010113  aa  6 00314 2371 00	ldaq 	pr6|204		fnpp
010114  aa   770112 6770 04	eraq 	-4022,ic		000226 = 077777000043 000001000000
010115  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010116  aa   000005 6010 04	tnz  	5,ic		010123
						STATEMENT 1 ON LINE 1797
	     code = error_table_$mpx_down;

010117  aa  6 00044 3701 20	epp4 	pr6|36,*
010120  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$mpx_down
010121  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1798
	     return;

010122  aa  6 00476 6101 00	rtcd 	pr6|318
						STATEMENT 1 ON LINE 1799
	end;

						STATEMENT 1 ON LINE 1801
	code = 0;

010123  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1803
	lctep = fnp_info.lcte_ptr;

010124  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010125  aa  7 00032 3735 20	epp7 	pr7|26,*		fnp_info.lcte_ptr
010126  aa  6 00306 6535 00	spri7	pr6|198		lctep
						STATEMENT 1 ON LINE 1804
	if lcte.lock = pds$processid			/* called as result of our own interrupt? */
	then if lcte.locked_for_interrupt
	     then mylock = "1"b;

010127  aa  7 00000 2351 00	lda  	pr7|0		lcte.lock
010130  aa  6 00044 3701 20	epp4 	pr6|36,*
010131  la  4 00124 1151 20	cmpa 	pr4|84,*		pds$processid
010132  aa   000027 6010 04	tnz  	23,ic		010161
010133  aa  7 00002 2351 00	lda  	pr7|2		lcte.locked_for_interrupt
010134  aa   000040 3150 03	cana 	32,du
010135  aa   000004 6000 04	tze  	4,ic		010141
010136  aa   400000 2350 03	lda  	131072,du
010137  aa  6 00135 7551 00	sta  	pr6|93		mylock
010140  aa   000035 7100 04	tra  	29,ic		010175
						STATEMENT 1 ON LINE 1807
	     else call syserr (CRASH_SYSTEM, "fnp_multiplexer: mylock error");

010141  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010142  aa   770272 00 0040	desc9a	-3910,32		000433 = 146156160137
010143  aa  6 01136 00 0040	desc9a	pr6|606,32
010144  aa   770023 3520 04	epp2 	-4077,ic		000167 = 000000000001
010145  aa  6 01150 2521 00	spri2	pr6|616
010146  aa  6 01136 3521 00	epp2 	pr6|606
010147  aa  6 01152 2521 00	spri2	pr6|618
010150  aa   770020 3520 04	epp2 	-4080,ic		000170 = 404000000021
010151  aa  6 01154 2521 00	spri2	pr6|620
010152  aa   767744 3520 04	epp2 	-4124,ic		000116 = 524000000035
010153  aa  6 01156 2521 00	spri2	pr6|622
010154  aa  6 01146 6211 00	eax1 	pr6|614
010155  aa   010000 4310 07	fld  	4096,dl
010156  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
010157  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
010160  aa   000015 7100 04	tra  	13,ic		010175
						STATEMENT 1 ON LINE 1808
	else do;

						STATEMENT 1 ON LINE 1809
	     mylock = "0"b;

010161  aa  6 00135 4501 00	stz  	pr6|93		mylock
						STATEMENT 1 ON LINE 1810
	     call tty_lock$lock_lcte (lctep, code);

010162  aa  6 00306 3521 00	epp2 	pr6|198		lctep
010163  aa  6 01140 2521 00	spri2	pr6|608
010164  aa  6 00100 3521 00	epp2 	pr6|64		code
010165  aa  6 01142 2521 00	spri2	pr6|610
010166  aa  6 01136 6211 00	eax1 	pr6|606
010167  aa   010000 4310 07	fld  	4096,dl
010170  la  4 00030 3521 20	epp2 	pr4|24,*		tty_lock$lock_lcte
010171  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1811
	     locked = (code = 0);

010172  aa  6 00100 2361 00	ldq  	pr6|64		code
010173  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
010174  aa  6 00133 7551 00	sta  	pr6|91		locked
						STATEMENT 1 ON LINE 1812
	end;

						STATEMENT 1 ON LINE 1813
	return;

010175  aa  6 00476 6101 00	rtcd 	pr6|318
						STATEMENT 1 ON LINE 1814
     end lock;

  END PROCEDURE lock
BEGIN PROCEDURE unlock
ENTRY TO unlock                                             STATEMENT 1 ON LINE 1818
unlock:
     proc;

010176  aa  6 00504 6501 00	spri4	pr6|324
						STATEMENT 1 ON LINE 1823
	if locked
	then if ^mylock
	     then do;

010177  aa  6 00133 2351 00	lda  	pr6|91		locked
010200  aa   000020 6000 04	tze  	16,ic		010220
010201  aa  6 00135 2351 00	lda  	pr6|93		mylock
010202  aa   000016 6010 04	tnz  	14,ic		010220
						STATEMENT 1 ON LINE 1827
		call dn355$process_interrupt_queue ((fnp_info.fnp_number));

010203  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010204  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
010205  aa   000011 7350 00	als  	9
010206  aa   000077 7730 00	lrl  	63
010207  aa  6 01160 7561 00	stq  	pr6|624
010210  aa  6 01160 3521 00	epp2 	pr6|624
010211  aa  6 01164 2521 00	spri2	pr6|628
010212  aa  6 01162 6211 00	eax1 	pr6|626
010213  aa   004000 4310 07	fld  	2048,dl
010214  aa  6 00044 3701 20	epp4 	pr6|36,*
010215  la  4 00016 3521 20	epp2 	pr4|14,*		dn355$process_interrupt_queue
010216  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1828
		locked = "0"b;

010217  aa  6 00133 4501 00	stz  	pr6|91		locked
						STATEMENT 1 ON LINE 1830
	     end;

						STATEMENT 1 ON LINE 1831
	return;

010220  aa  6 00504 6101 00	rtcd 	pr6|324
						STATEMENT 1 ON LINE 1833
     end unlock;

  END PROCEDURE unlock
BEGIN PROCEDURE fnp_buf_size
ENTRY TO fnp_buf_size                                       STATEMENT 1 ON LINE 1836
fnp_buf_size:
     proc returns (bit (18));

010221  aa  6 00512 6501 00	spri4	pr6|330
010222  aa  6 00514 2521 00	spri2	pr6|332
						STATEMENT 1 ON LINE 1843
	do i = 1 to n_sync_line_types while (pcb.line_type ^= sync_line_type (i));

010223  aa   000012 2360 07	ldq  	10,dl
010224  aa  6 00520 7561 00	stq  	pr6|336
010225  aa   000001 2360 07	ldq  	1,dl
010226  aa  6 00114 7561 00	stq  	pr6|76		i
010227  aa   000000 0110 03	nop  	0,du
010230  aa  6 00114 2361 00	ldq  	pr6|76		i
010231  aa  6 00520 1161 00	cmpq 	pr6|336
010232  aa   000012 6054 04	tpnz 	10,ic		010244
010233  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
010234  aa  7 00002 2351 00	lda  	pr7|2		pcb.line_type
010235  aa   000022 7350 00	als  	18
010236  aa   000066 7330 00	lrs  	54
010237  aa  6 00114 7271 00	lxl7 	pr6|76		i
010240  ta   777777 1160 17	cmpq 	-1,7
010241  aa   000003 6000 04	tze  	3,ic		010244
						STATEMENT 1 ON LINE 1844
	end;

010242  aa  6 00114 0541 00	aos  	pr6|76		i
010243  aa   777765 7100 04	tra  	-11,ic		010230
						STATEMENT 1 ON LINE 1846
	if i <= n_sync_line_types
	then do;

010244  aa  6 00114 2361 00	ldq  	pr6|76		i
010245  aa   000012 1160 07	cmpq 	10,dl
010246  aa   000012 6054 04	tpnz 	10,ic		010260
						STATEMENT 1 ON LINE 1848
	     pcb.sync_line = "1"b;

010247  aa   020000 2350 03	lda  	8192,du
010250  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
010251  aa  7 00004 2551 00	orsa 	pr7|4		pcb.sync_line
						STATEMENT 1 ON LINE 1849
	     chars_per_buf = divide (divide (pcb.baud_rate, 8, 17, 0), buf_per_second, 17, 0);

010252  aa  7 00002 2351 00	lda  	pr7|2		pcb.baud_rate
010253  aa   000066 7330 00	lrs  	54
010254  aa   000010 5060 07	div  	8,dl
010255  aa   000012 5060 07	div  	10,dl
010256  aa  6 00217 7561 00	stq  	pr6|143		chars_per_buf
						STATEMENT 1 ON LINE 1850
	end;

010257  aa   000006 7100 04	tra  	6,ic		010265
						STATEMENT 1 ON LINE 1852
	else do;

						STATEMENT 1 ON LINE 1853
	     pcb.sync_line = "0"b;

010260  aa   000432 2350 04	lda  	282,ic		010712 = 757777777777
010261  aa  6 00320 3735 20	epp7 	pr6|208,*		pcbp
010262  aa  7 00004 3551 00	ansa 	pr7|4		pcb.sync_line
						STATEMENT 1 ON LINE 1854
	     chars_per_buf = 56;

010263  aa   000070 2360 07	ldq  	56,dl
010264  aa  6 00217 7561 00	stq  	pr6|143		chars_per_buf
						STATEMENT 1 ON LINE 1855
	end;

						STATEMENT 1 ON LINE 1857
	return (bit (bin (chars_per_buf, 18), 18));

010265  aa  6 00217 2351 00	lda  	pr6|143		chars_per_buf
010266  aa   000002 6050 04	tpl  	2,ic		010270
010267  aa   000000 5310 00	neg  	0
010270  aa   000022 7350 00	als  	18
010271  aa  6 00056 7551 00	sta  	pr6|46
010272  aa  6 00514 3715 20	epp5 	pr6|332,*
010273  aa  5 00002 3535 20	epp3 	pr5|2,*
010274  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
010275  aa  6 00056 00 0022	descb	pr6|46,18
010276  aa  3 00000 00 0022	descb	pr3|0,18
010277  aa  6 00512 6101 00	rtcd 	pr6|330
						STATEMENT 1 ON LINE 1858
     end fnp_buf_size;

  END PROCEDURE fnp_buf_size
BEGIN PROCEDURE assign_channel
ENTRY TO assign_channel                                     STATEMENT 1 ON LINE 1893
assign_channel:
     procedure (code);

010300  aa  6 00522 6501 00	spri4	pr6|338
010301  aa  6 00524 2521 00	spri2	pr6|340
						STATEMENT 1 ON LINE 1897
	code = 0;

010302  aa  2 00002 4501 20	stz  	pr2|2,*		code
						STATEMENT 1 ON LINE 1898
	if ^fnp_info.available
	then do;

010303  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010304  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.available
010305  aa   400000 3150 03	cana 	131072,du
010306  aa   000005 6010 04	tnz  	5,ic		010313
						STATEMENT 1 ON LINE 1900
	     code = error_table_$io_not_configured;

010307  aa  6 00044 3701 20	epp4 	pr6|36,*
010310  la  4 00116 2361 20	ldq  	pr4|78,*		error_table_$io_not_configured
010311  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 1901
	     go to assign_channel_return;

010312  aa   000054 7100 04	tra  	44,ic		010366
						STATEMENT 1 ON LINE 1902
	end;

						STATEMENT 1 ON LINE 1904
	if fnp_info.io_manager_assigned
	then do;

010313  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
010314  aa   200000 3150 03	cana 	65536,du
010315  aa   000005 6000 04	tze  	5,ic		010322
						STATEMENT 1 ON LINE 1906
	     code = error_table_$io_assigned;

010316  aa  6 00044 3701 20	epp4 	pr6|36,*
010317  la  4 00112 2361 20	ldq  	pr4|74,*		error_table_$io_assigned
010320  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 1907
	     go to assign_channel_return;

010321  aa   000045 7100 04	tra  	37,ic		010366
						STATEMENT 1 ON LINE 1908
	end;

						STATEMENT 1 ON LINE 1910
	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, dn355$interrupt, (fnp_info.fnp_number),
	     (null ()), code);

010322  aa  6 00044 3701 20	epp4 	pr6|36,*
010323  la  4 00020 3521 20	epp2 	pr4|16,*		dn355$interrupt
010324  aa  6 01166 2521 00	spri2	pr6|630		cp.1207
010325  aa   000361 2370 04	ldaq 	241,ic		010706 = 077777000043 000001000000
010326  aa  6 01170 7571 00	staq 	pr6|632		cp.1207
010327  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
010330  aa   000011 7350 00	als  	9
010331  aa   000077 7730 00	lrl  	63
010332  aa  6 01172 7561 00	stq  	pr6|634
010333  aa   767673 3714 24	epp5 	-4165,ic*
010334  aa  6 01174 6515 00	spri5	pr6|636
010335  aa  7 00012 3521 00	epp2 	pr7|10		fnp_info.io_manager_chx
010336  aa  6 01200 2521 00	spri2	pr6|640
010337  aa  7 00010 3521 00	epp2 	pr7|8		fnp_info.io_chanid
010340  aa  6 01202 2521 00	spri2	pr6|642
010341  aa  6 01166 3521 00	epp2 	pr6|630		cp.1207
010342  aa  6 01204 2521 00	spri2	pr6|644
010343  aa  6 01172 3521 00	epp2 	pr6|634
010344  aa  6 01206 2521 00	spri2	pr6|646
010345  aa  6 01174 3521 00	epp2 	pr6|636
010346  aa  6 01210 2521 00	spri2	pr6|648
010347  aa  6 00524 3535 20	epp3 	pr6|340,*
010350  aa  3 00002 3521 20	epp2 	pr3|2,*		code
010351  aa  6 01212 2521 00	spri2	pr6|650
010352  aa  6 01176 6211 00	eax1 	pr6|638
010353  aa   030000 4310 07	fld  	12288,dl
010354  la  4 00146 3521 20	epp2 	pr4|102,*		io_manager$assign
010355  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1912
	fnp_info.io_manager_assigned = (code = 0);

010356  aa  6 00524 3735 20	epp7 	pr6|340,*
010357  aa  7 00002 2361 20	ldq  	pr7|2,*		code
010360  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
010361  aa   000001 7710 00	arl  	1
010362  aa  6 00314 3715 20	epp5 	pr6|204,*		fnpp
010363  aa  5 00066 6751 00	era  	pr5|54		fnp_info.io_manager_assigned
010364  aa   200000 3750 03	ana  	65536,du
010365  aa  5 00066 6551 00	ersa 	pr5|54		fnp_info.io_manager_assigned
						STATEMENT 1 ON LINE 1913
assign_channel_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr (ANNOUNCE, "fnp_multiplexer$assign_channel: Assignment of FNP ^a ^[succeeded^;failed^].",
		fnp_info.fnp_tag, (code = 0));

010366  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
010367  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
010370  aa   000003 6010 04	tnz  	3,ic		010373
010371  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
010372  aa   000036 6000 04	tze  	30,ic		010430
010373  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010374  aa   770207 00 0114	desc9a	-3961,76		000602 = 146156160137
010375  aa  6 01214 00 0114	desc9a	pr6|652,76
010376  aa  6 00524 3715 20	epp5 	pr6|340,*
010377  aa  5 00002 2361 20	ldq  	pr5|2,*		code
010400  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
010401  aa  6 01172 7551 00	sta  	pr6|634
010402  aa   767550 3520 04	epp2 	-4248,ic		000152 = 000000000000
010403  aa  6 01242 2521 00	spri2	pr6|674
010404  aa  6 01214 3521 00	epp2 	pr6|652
010405  aa  6 01244 2521 00	spri2	pr6|676
010406  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
010407  aa  3 00007 3521 00	epp2 	pr3|7		fnp_info.fnp_tag
010410  aa  6 01246 2521 00	spri2	pr6|678
010411  aa  6 01172 3521 00	epp2 	pr6|634
010412  aa  6 01250 2521 00	spri2	pr6|680
010413  aa   767555 3520 04	epp2 	-4243,ic		000170 = 404000000021
010414  aa  6 01252 2521 00	spri2	pr6|682
010415  aa   767500 3520 04	epp2 	-4288,ic		000115 = 524000000113
010416  aa  6 01254 2521 00	spri2	pr6|684
010417  aa   767534 3520 04	epp2 	-4260,ic		000153 = 526000000001
010420  aa  6 01256 2521 00	spri2	pr6|686
010421  aa   767543 3520 04	epp2 	-4253,ic		000164 = 514000000001
010422  aa  6 01260 2521 00	spri2	pr6|688
010423  aa  6 01240 6211 00	eax1 	pr6|672
010424  aa   020000 4310 07	fld  	8192,dl
010425  aa  6 00044 3701 20	epp4 	pr6|36,*
010426  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
010427  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1917
	if code ^= 0
	then call TRACE_ERROR ("assign_channel", code);

010430  aa  6 00524 3735 20	epp7 	pr6|340,*
010431  aa  7 00002 2361 20	ldq  	pr7|2,*		code
010432  aa   000014 6000 04	tze  	12,ic		010446
010433  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
010434  aa   767642 00 0016	desc9a	-4190,14		000275 = 141163163151
010435  aa  6 01176 00 0040	desc9a	pr6|638,32
010436  aa  6 01176 3521 00	epp2 	pr6|638
010437  aa  6 01242 2521 00	spri2	pr6|674
010440  aa  7 00002 3521 20	epp2 	pr7|2,*		code
010441  aa  6 01244 2521 00	spri2	pr6|676
010442  aa  6 01240 3521 00	epp2 	pr6|672
010443  aa   010000 4310 07	fld  	4096,dl
010444  aa  2 00000 7571 00	staq 	pr2|0
010445  aa   000154 6700 04	tsp4 	108,ic		010621
						STATEMENT 1 ON LINE 1919
	return;

010446  aa  6 00522 6101 00	rtcd 	pr6|338
						STATEMENT 1 ON LINE 1920
     end assign_channel;

  END PROCEDURE assign_channel
BEGIN PROCEDURE unassign_channel
ENTRY TO unassign_channel                                   STATEMENT 1 ON LINE 1922
unassign_channel:
     procedure (code);

010447  aa  6 00530 6501 00	spri4	pr6|344
010450  aa  6 00532 2521 00	spri2	pr6|346
						STATEMENT 1 ON LINE 1927
	if ^fnp_info.io_manager_assigned
	then do;

010451  aa  6 00314 3735 20	epp7 	pr6|204,*		fnpp
010452  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
010453  aa   200000 3150 03	cana 	65536,du
010454  aa   000005 6010 04	tnz  	5,ic		010461
						STATEMENT 1 ON LINE 1929
	     code = error_table_$io_not_assigned;

010455  aa  6 00044 3701 20	epp4 	pr6|36,*
010456  la  4 00114 2361 20	ldq  	pr4|76,*		error_table_$io_not_assigned
010457  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 1930
	     go to unassign_return;

010460  aa   000021 7100 04	tra  	17,ic		010501
						STATEMENT 1 ON LINE 1931
	end;

						STATEMENT 1 ON LINE 1932
	call io_manager$unassign (fnp_info.io_manager_chx, code);

010461  aa  7 00012 3521 00	epp2 	pr7|10		fnp_info.io_manager_chx
010462  aa  6 01264 2521 00	spri2	pr6|692
010463  aa  6 00532 3715 20	epp5 	pr6|346,*
010464  aa  5 00002 3521 20	epp2 	pr5|2,*		code
010465  aa  6 01266 2521 00	spri2	pr6|694
010466  aa  6 01262 6211 00	eax1 	pr6|690
010467  aa   010000 4310 07	fld  	4096,dl
010470  aa  6 00044 3701 20	epp4 	pr6|36,*
010471  la  4 00150 3521 20	epp2 	pr4|104,*		io_manager$unassign
010472  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1933
	if code = 0
	then fnp_info.io_manager_assigned = "0"b;

010473  aa  6 00532 3735 20	epp7 	pr6|346,*
010474  aa  7 00002 2361 20	ldq  	pr7|2,*		code
010475  aa   000004 6010 04	tnz  	4,ic		010501
010476  aa   000207 2350 04	lda  	135,ic		010705 = 577777777777
010477  aa  6 00314 3715 20	epp5 	pr6|204,*		fnpp
010500  aa  5 00066 3551 00	ansa 	pr5|54		fnp_info.io_manager_assigned
						STATEMENT 1 ON LINE 1935
unassign_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, code,
		"fnp_multiplexer$unassign_channel: Unassignment of FNP ^a ^[failed^;succeeded^].", fnp_info.fnp_tag,
		(code ^= 0));

010501  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
010502  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
010503  aa   000003 6010 04	tnz  	3,ic		010506
010504  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
010505  aa   000042 6000 04	tze  	34,ic		010547
010506  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010507  aa   770142 00 0120	desc9a	-3998,80		000650 = 146156160137
010510  aa  6 01270 00 0120	desc9a	pr6|696,80
010511  aa  6 00532 3715 20	epp5 	pr6|346,*
010512  aa  5 00002 2361 20	ldq  	pr5|2,*		code
010513  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
010514  aa  6 01314 7551 00	sta  	pr6|716
010515  aa   767435 3520 04	epp2 	-4323,ic		000152 = 000000000000
010516  aa  6 01320 2521 00	spri2	pr6|720
010517  aa  5 00002 3521 20	epp2 	pr5|2,*		code
010520  aa  6 01322 2521 00	spri2	pr6|722
010521  aa  6 01270 3521 00	epp2 	pr6|696
010522  aa  6 01324 2521 00	spri2	pr6|724
010523  aa  6 00314 3535 20	epp3 	pr6|204,*		fnpp
010524  aa  3 00007 3521 00	epp2 	pr3|7		fnp_info.fnp_tag
010525  aa  6 01326 2521 00	spri2	pr6|726
010526  aa  6 01314 3521 00	epp2 	pr6|716
010527  aa  6 01330 2521 00	spri2	pr6|728
010530  aa   767440 3520 04	epp2 	-4320,ic		000170 = 404000000021
010531  aa  6 01332 2521 00	spri2	pr6|730
010532  aa   767430 3520 04	epp2 	-4328,ic		000162 = 404000000043
010533  aa  6 01334 2521 00	spri2	pr6|732
010534  aa   767360 3520 04	epp2 	-4368,ic		000114 = 524000000117
010535  aa  6 01336 2521 00	spri2	pr6|734
010536  aa   767415 3520 04	epp2 	-4339,ic		000153 = 526000000001
010537  aa  6 01340 2521 00	spri2	pr6|736
010540  aa   767424 3520 04	epp2 	-4332,ic		000164 = 514000000001
010541  aa  6 01342 2521 00	spri2	pr6|738
010542  aa  6 01316 6211 00	eax1 	pr6|718
010543  aa   024000 4310 07	fld  	10240,dl
010544  aa  6 00044 3701 20	epp4 	pr6|36,*
010545  la  4 00044 3521 20	epp2 	pr4|36,*		syserr$error_code
010546  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1940
	if code ^= 0
	then call TRACE_ERROR ("unassign_channel", code);

010547  aa  6 00532 3735 20	epp7 	pr6|346,*
010550  aa  7 00002 2361 20	ldq  	pr7|2,*		code
010551  aa   000014 6000 04	tze  	12,ic		010565
010552  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
010553  aa   767517 00 0020	desc9a	-4273,16		000271 = 165156141163
010554  aa  6 01270 00 0040	desc9a	pr6|696,32
010555  aa  6 01270 3521 00	epp2 	pr6|696
010556  aa  6 01320 2521 00	spri2	pr6|720
010557  aa  7 00002 3521 20	epp2 	pr7|2,*		code
010560  aa  6 01322 2521 00	spri2	pr6|722
010561  aa  6 01316 3521 00	epp2 	pr6|718
010562  aa   010000 4310 07	fld  	4096,dl
010563  aa  2 00000 7571 00	staq 	pr2|0
010564  aa   000035 6700 04	tsp4 	29,ic		010621
						STATEMENT 1 ON LINE 1942
	return;

010565  aa  6 00530 6101 00	rtcd 	pr6|344
						STATEMENT 1 ON LINE 1943
     end unassign_channel;

  END PROCEDURE unassign_channel
BEGIN PROCEDURE TRACE
ENTRY TO TRACE                                              STATEMENT 1 ON LINE 1945
TRACE:
     procedure (Entry);

010566  aa  6 00536 6501 00	spri4	pr6|350
010567  aa  6 00540 2521 00	spri2	pr6|352
						STATEMENT 1 ON LINE 1950
	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_multiplexer$^a: Tracing call.", Entry);

010570  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
010571  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
010572  aa   000026 6000 04	tze  	22,ic		010620
010573  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010574  aa   767661 00 0044	desc9a	-4175,36		000454 = 146156160137
010575  aa  6 01344 00 0044	desc9a	pr6|740,36
010576  aa   767354 3520 04	epp2 	-4372,ic		000152 = 000000000000
010577  aa  6 01360 2521 00	spri2	pr6|752
010600  aa  6 01344 3521 00	epp2 	pr6|740
010601  aa  6 01362 2521 00	spri2	pr6|754
010602  aa  6 00540 3715 20	epp5 	pr6|352,*
010603  aa  5 00002 3521 20	epp2 	pr5|2,*		Entry
010604  aa  6 01364 2521 00	spri2	pr6|756
010605  aa   767363 3520 04	epp2 	-4365,ic		000170 = 404000000021
010606  aa  6 01366 2521 00	spri2	pr6|758
010607  aa   767304 3520 04	epp2 	-4412,ic		000113 = 524000000041
010610  aa  6 01370 2521 00	spri2	pr6|760
010611  aa   767337 3520 04	epp2 	-4385,ic		000150 = 526000000040
010612  aa  6 01372 2521 00	spri2	pr6|762
010613  aa  6 01356 6211 00	eax1 	pr6|750
010614  aa   014000 4310 07	fld  	6144,dl
010615  aa  6 00044 3701 20	epp4 	pr6|36,*
010616  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
010617  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1952
	return;

010620  aa  6 00536 6101 00	rtcd 	pr6|350
ENTRY TO TRACE_ERROR                                        STATEMENT 1 ON LINE 1956
TRACE_ERROR:
     entry (Entry, Code);

010621  aa  6 00536 6501 00	spri4	pr6|350
010622  aa  6 00540 2521 00	spri2	pr6|352
						STATEMENT 1 ON LINE 1961
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, Code, "fnp_multiplexer$^a: Tracing error.", Entry);

010623  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
010624  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
010625  aa   000003 6010 04	tnz  	3,ic		010630
010626  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
010627  aa   000032 6000 04	tze  	26,ic		010661
010630  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010631  aa   767613 00 0044	desc9a	-4213,36		000443 = 146156160137
010632  aa  6 01344 00 0044	desc9a	pr6|740,36
010633  aa   767317 3520 04	epp2 	-4401,ic		000152 = 000000000000
010634  aa  6 01376 2521 00	spri2	pr6|766
010635  aa  6 00540 3715 20	epp5 	pr6|352,*
010636  aa  5 00004 3521 20	epp2 	pr5|4,*		Code
010637  aa  6 01400 2521 00	spri2	pr6|768
010640  aa  6 01344 3521 00	epp2 	pr6|740
010641  aa  6 01402 2521 00	spri2	pr6|770
010642  aa  5 00002 3521 20	epp2 	pr5|2,*		Entry
010643  aa  6 01404 2521 00	spri2	pr6|772
010644  aa   767324 3520 04	epp2 	-4396,ic		000170 = 404000000021
010645  aa  6 01406 2521 00	spri2	pr6|774
010646  aa   767314 3520 04	epp2 	-4404,ic		000162 = 404000000043
010647  aa  6 01410 2521 00	spri2	pr6|776
010650  aa   767242 3520 04	epp2 	-4446,ic		000112 = 524000000042
010651  aa  6 01412 2521 00	spri2	pr6|778
010652  aa   767276 3520 04	epp2 	-4418,ic		000150 = 526000000040
010653  aa  6 01414 2521 00	spri2	pr6|780
010654  aa  6 01374 6211 00	eax1 	pr6|764
010655  aa   020000 4310 07	fld  	8192,dl
010656  aa  6 00044 3701 20	epp4 	pr6|36,*
010657  la  4 00044 3521 20	epp2 	pr4|36,*		syserr$error_code
010660  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1963
	if datanet_info.debug_stop
	then call syserr (CRASH_SYSTEM, "fnp_multiplexer: debugging stop (type go to continue).");

010661  aa  6 00312 3735 20	epp7 	pr6|202,*		infop
010662  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
010663  aa   000021 6000 04	tze  	17,ic		010704
010664  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
010665  aa   767660 00 0070	desc9a	-4176,56		000544 = 146156160137
010666  aa  6 01356 00 0070	desc9a	pr6|750,56
010667  aa   767300 3520 04	epp2 	-4416,ic		000167 = 000000000001
010670  aa  6 01376 2521 00	spri2	pr6|766
010671  aa  6 01356 3521 00	epp2 	pr6|750
010672  aa  6 01400 2521 00	spri2	pr6|768
010673  aa   767275 3520 04	epp2 	-4419,ic		000170 = 404000000021
010674  aa  6 01402 2521 00	spri2	pr6|770
010675  aa   767214 3520 04	epp2 	-4468,ic		000111 = 524000000066
010676  aa  6 01404 2521 00	spri2	pr6|772
010677  aa  6 01374 6211 00	eax1 	pr6|764
010700  aa   010000 4310 07	fld  	4096,dl
010701  aa  6 00044 3701 20	epp4 	pr6|36,*
010702  la  4 00042 3521 20	epp2 	pr4|34,*		syserr
010703  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1965
	return;

010704  aa  6 00536 6101 00	rtcd 	pr6|350
						STATEMENT 1 ON LINE 1966
     end TRACE;

  END PROCEDURE TRACE
  END PROCEDURE fnp_multiplexer


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
