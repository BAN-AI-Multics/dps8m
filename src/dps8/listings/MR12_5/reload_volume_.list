	COMPILATION LISTING OF SEGMENT reload_volume_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1000.9 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
       16*     install(88-10-17,MR12.2-1173):
       17*     Rewrote the paged read mechanism to read an entire object from a dump
       18*     tape, then write it a page at a time.  When a short segment is read from
       19*     tape, the routine will now deposit any unused pages.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       24 
       25 reload_volume_: proc (rldr_datap, code);
       26 
       27 /* This routine is the main driving program for the reload of a physical volume. We read a object from the dump
       28*   volume, check to see if it's already there, and if so we free the pages already allocated. We then withdraw the
       29*   necessary pages and write the new vtoce and the non-null pages of the object. If a page can not be written
       30*   we mark the page as unusable, allocate a new one and rewrite the page. If this operation bears
       31*   any resemlance to the way the hardcore behaves to a physical volume, the resemlance is intentional. */
       32 /* Modified 5/79 by D. Vinograd to correct calling sequence to rldr_input_$read_page
       33*   so that variable already_there is passed as arg and that a clumulative count
       34*   of elements read is maintained such that non-null pages of all zeros are
       35*   treated correctly. */
       36 /* Modified:     3/1/83 by GA Texada to allow multiple physical volume reloading.	         */
       37 
       38 dcl code		     fixed bin (35);
       39 dcl (csl, bad_pages, object_pgx, pgx, pvindex, vtocx) fixed bin;
       40 dcl (new_vtocep, old_vtocep) ptr;
       41 dcl (Swritten, already_there, new_volume, skip_next_header_check) bit (1);
       42 dcl pages_returned	     fixed bin;
       43 
       44 dcl 1 new_local_vtoce    like vtoce aligned;
       45 dcl 1 old_local_vtoce    like vtoce aligned;
       46 
       47 dcl myname	     char (32) int static init ("reload_volume_") options (constant);
       48 
       49 dcl error_table_$end_of_info ext fixed bin (35);
       50 
       51 dcl rldr_input_$collect_stats entry (ptr, fixed bin);
       52 dcl rldr_input_$get_object entry (ptr, bit (1), ptr, fixed bin, bit (1), fixed bin, fixed bin (35));
       53 dcl rldr_input_$read_object entry (ptr, fixed bin, bit (1), bit (1), fixed bin, fixed bin (35));
       54 dcl rldr_report_$error_output entry options (variable);
       55 dcl rldr_vtoc_buffer_$get entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
       56 dcl rldr_vtoc_buffer_$put entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
       57 dcl rldr_output_$write_page entry (ptr, fixed bin, ptr, bit (18), fixed bin (35));
       58 dcl rldr_volume_map_$deposit entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
       59 dcl rldr_volume_map_$withdraw entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
       60 
       61 dcl (addr, bit, divide, fixed, pointer, substr, unspec) builtin;
       62 
       63 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       64 
       65 
       66 /* Initialize local variables and structures */
       67     code = 0;
       68     skip_next_header_check = "0"b;
       69     new_vtocep = addr (new_local_vtoce);
       70     old_vtocep = addr (old_local_vtoce);
       71     unspec (new_local_vtoce) = "0"b;
       72     unspec (old_local_vtoce) = "0"b;
       73 						/* Read through all the dump volumes on the list  */
       74     do while ("1"b);				/* pvindex will be returned if code = 0, to show  */
       75 restart: call rldr_input_$get_object (rldr_datap, skip_next_header_check, new_vtocep, vtocx, already_there, pvindex, code);
       76 						/* which physical volume the object belongs to	*/
       77       if code ^= 0 then do;
       78 	if code = error_table_$end_of_info then do;
       79 	    code = 0;
       80 	    return;
       81 	  end;
       82 	call rldr_report_$error_output (rldr_datap, code, myname, "Error reading input");
       83 	return;
       84         end;
       85       vtoc_headerp = rldr_data_.vtoc_headerp (pvindex);
       86 						/* If already there free allocated pages */
       87       if already_there then do;
       88 	call rldr_vtoc_buffer_$get (rldr_datap, pvindex, old_vtocep, vtocx, code);
       89 	if code ^= 0 then do;
       90 	    call rldr_report_$error_output (rldr_datap, code, myname, "Error reading old vtoce ^o for pv ^a", vtocx,
       91 	         rldr_data_.pvname (pvindex));
       92 	    goto skip_this_pv;
       93 	  end;
       94 	if old_vtocep -> vtoce.uid ^= "0"b then do;
       95 	    call rldr_volume_map_$deposit (rldr_datap, pvindex, old_vtocep, -1, code);
       96 	    if code ^= 0 then do;
       97 	        call rldr_report_$error_output (rldr_datap, code, myname, "Error depositing old vtoce ^o for pv ^a", vtocx,
       98 		   rldr_data_.pvname (pvindex));
       99 	        goto skip_this_pv;
      100 	      end;
      101 	  end;
      102         end;
      103 						/* Allocate new pages */
      104       if new_vtocep -> vtoce.uid ^= "0"b then
      105         call rldr_volume_map_$withdraw (rldr_datap, pvindex, new_vtocep, -1, code);
      106       if code ^= 0 then do;
      107 	call rldr_report_$error_output (rldr_datap, code, myname, "Unable to withdraw for new vtoce ^o for pv ^a", vtocx,
      108 	     rldr_data_.pvname (pvindex));
      109 	goto skip_this_pv;
      110         end;
      111 						/* Write out vtoce  */
      112       call rldr_vtoc_buffer_$put (rldr_datap, pvindex, new_vtocep, vtocx, code);
      113       if code ^= 0 then do;
      114 	call rldr_report_$error_output (rldr_datap, code, myname, "Error writing new vtoce ^o for pv ^a", vtocx,
      115 	     rldr_data_.pvname (pvindex));
      116 	goto skip_this_pv;
      117         end;
      118 
      119 
      120       if new_vtocep -> vtoce.uid ^= "0"b & ^rldr_data_.no_object then do;
      121 	csl = fixed (new_vtocep -> vtoce.csl);
      122 	call rldr_input_$read_object (rldr_datap, pvindex, new_volume,
      123 	     skip_next_header_check, pages_returned, code);
      124 	if new_volume then goto restart;
      125 	if code ^= 0 then
      126 	  new_vtocep -> vtoce.damaged = "1"b;
      127 
      128 /* Write out each non null page. If the write fails log the bad address, withdraw an other page and try again */
      129 
      130 
      131 	object_pgx = 0;
      132 	do pgx = 0 to csl - 1 while (divide (object_pgx, WORDS_PER_PAGE, 17) < pages_returned);
      133 	  if ^substr (new_vtocep -> vtoce.fm (pgx), 1, 1) then do;
      134 	      Swritten = "0"b;
      135 	      do while (^Swritten);
      136 	        call rldr_output_$write_page (rldr_datap, pvindex,
      137 		   pointer (rldr_data_.data_object_bp, object_pgx),
      138 		   new_vtocep -> vtoce.fm (pgx), code);
      139 	        if code ^= 0 then do;
      140 		  call log_bad_addr (new_vtocep -> vtoce.fm (pgx));
      141 		  call rldr_volume_map_$withdraw (rldr_datap,
      142 		       pvindex, new_vtocep, pgx, code);
      143 		  if code ^= 0 then do;
      144 		      call rldr_report_$error_output (rldr_datap, code, myname,
      145 			 "Unable to withdraw for bad page on pv ^a", rldr_data_.pvname (pvindex));
      146 		      goto skip_this_pv;
      147 		    end;
      148 		end;
      149 	        else do;
      150 		  Swritten = "1"b;
      151 		  object_pgx = object_pgx + WORDS_PER_PAGE;
      152 		end;
      153 	      end;
      154 	    end;
      155 	end;
      156 
      157 	bad_pages = 0;
      158 	do pgx = pgx to csl - 1;			/* incomplete object */
      159 	  call rldr_volume_map_$deposit (rldr_datap, pvindex,
      160 	       new_vtocep, pgx, code);
      161 	  if code ^= 0 then
      162 	    call rldr_report_$error_output (rldr_datap, code, myname, "Error depositing page ^d of vtoce ^o for pv ^a",
      163 	         pgx, vtocx, rldr_data_.pvname (pvindex));
      164 	  bad_pages = bad_pages + 1;
      165 	end;
      166 
      167 	if new_vtocep -> vtoce.damaged then do;
      168 	    new_vtocep -> vtoce.csl = bit (fixed (csl - bad_pages, 9), 9);
      169 	    new_vtocep -> vtoce.records = bit (fixed (fixed (new_vtocep -> vtoce.records) - bad_pages, 9), 9);
      170 	    call rldr_vtoc_buffer_$put (rldr_datap, pvindex, new_vtocep,
      171 	         vtocx, code);
      172 	    if code ^= 0 then
      173 	      call rldr_report_$error_output (rldr_datap, code, myname,
      174 		 "Unable to set damaged switch for vtoce ^o on pv ^a", vtocx, rldr_data_.pvname (pvindex));
      175 	  end;
      176         end;
      177 
      178 
      179       if ^already_there then call rldr_input_$collect_stats (rldr_datap, pvindex);
      180     end;
      181 
      182     return;
      183 skip_this_pv:
      184     call rldr_report_$error_output (rldr_datap, 0, myname,	/* well, let the user know			*/
      185          "Abandoning the reload of pv ^a", rldr_data_.pvname (pvindex));
      186     rldr_data_.abandoned (pvindex) = "1"b;		/* mark as abandoned			*/
      187     rldr_data_.num_abandoned = rldr_data_.num_abandoned + 1;
      188     if rldr_data_.num_abandoned = rldr_data_.npvs then do;
      189         call rldr_report_$error_output (rldr_datap, 0, myname,
      190 	   "All physical volumes to be reloaded have been abandoned.");
      191         return;
      192       end;
      193 
      194     goto restart;					/* and press-on				*/
      195 
      196 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      197 
      198 
      199 log_bad_addr: proc (add);
      200 
      201 /* This proc logs the bad address of a failed write request */
      202 
      203 
      204 dcl add		     bit (18);
      205 
      206     call rldr_report_$error_output (rldr_datap, 0, myname, "Bad disk page ^o for pv ^a", add, rldr_data_.pvname (pvindex));
      207     return;
      208   end log_bad_addr;
      209 
  1     1 /* BEGIN INCLUDE FILE ... rldr_data_.incl.pl1 ... March 1976 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  1     6*     audit(86-05-22,GWMay), install(86-07-18,MR12.0-1098):
  1     7*     Add device_name to support the -pvname_device argument to reload.
  1     8*  2) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  1     9*     install(88-10-17,MR12.2-1173):
  1    10*     Added pointer and length values for use as an input_buffer for
  1    11*     intermediate reads.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 /* Severely modified 3/1/83 by GA Texada to support multiple physical */
  1    16 /*          volume reloading.				          */
  1    17 /*          Modified: 3/5/84 by GA Texada to make restart a per pv attribute */
  1    18 /*		  and add stranger flag.			*/
  1    19 
  1    20 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
  1    21 
  1    22 
  1    23 dcl rldr_datap	     ptr,
  1    24   rldr_data_max_pvs	     fixed bin,
  1    25 
  1    26   1 rldr_data_	     aligned based (rldr_datap),
  1    27     2 common	     like rldr_data_common,		/* only one of each needed			*/
  1    28     2 per_pv	     (rldr_data_max_pvs refer (rldr_data_.npvs)) like rldr_data_perpv,
  1    29 
  1    30   1 rldr_data_common     aligned,
  1    31     2 bits,
  1    32     ( 3 save	     bit (1),			/* if on can use disk pack restored by BOS */
  1    33       3 first_volume     bit (1),			/* if on indicates we are on first volume */
  1    34       3 rpv	     bit (1),			/* if on indicates we are reloading rpv */
  1    35       3 data_init	     bit (1),			/* if on data structure initialized to null state */
  1    36       3 arg_init	     bit (1),			/* on if arguments have been processed */
  1    37       3 disable_error_report bit (1),			/* if on will disable error messages */
  1    38       3 no_object	     bit (1),			/* if on only vtoces will be reloaded */
  1    39       3 err_online	     bit (1),			/* if on error messages written to error output */
  1    40       3 detach	     bit (1),			/* if on attached media will  be detached */
  1    41       3 brief	     bit (1),			/* if on brief mode enabled */
  1    42       3 manual	     bit (1),			/* if on operator will select input volumes */
  1    43       3 restart	     bit (1),			/* -restart was supplied			*/
  1    44       3 stranger	     bit (1),			/* ON if the pv's do not belong to the mounted RPV*/
  1    45       3 pad0	     bit (23)) unal,
  1    46       3 old_256K_switch  bit (2) aligned,		/* state of 256KW connection switch before we came along*/
  1    47       (3 last_pvid,					/* pvid of last good object read		*/
  1    48       3 rpv_pvid,					/* rpv pvid */
  1    49       3 rpv_lvid)	     bit (36),			/* rpv lvid */
  1    50       3 last_valid_puid  (0:15) bit (36),		/* last non-zero path uid read from input medium */
  1    51     2 chars,
  1    52     ( 3 sys_dir,					/* directory where vologs are */
  1    53       3 default_sys_dir) char (168),			/* default directory where vologs are */
  1    54       (3 last_valid_vtoce_ename,			/* last valid entry name from VTOCE */
  1    55       3 operator,					/* operator's name or initials */
  1    56       3 io_module)	     char (32),			/* name of io outer module used to read input */
  1    57       (3 input_volume_desc,				/* optional input medium attach description */
  1    58       3 output_volume_desc) char (256),			/* optional output medium attach description */
  1    59     2 fixed,
  1    60     ( 3 num_abandoned,				/* count these as we go along			*/
  1    61       3 last_vtocx,					/* vtocx of last valid object read		*/
  1    62       3 npvs,					/* the number of pv names given to the reload_volume command*/
  1    63       3 rpv_disk_type)   fixed bin,			/* model index of rpv disk drive */
  1    64       (3 start_time,				/* time reload started */
  1    65       3 from_time)	     fixed bin (71),		/*  time from which dump tapes should be skipped */
  1    66       3 input_buffer_len fixed bin (21),		/* length of the data in the read buffer */
  1    67       3 input_buffer_start fixed bin (21),		/* position in read buffer where new data begins */
  1    68     2 ptrs,
  1    69     ( 3 inputvol_iocbp,				/* iocb ptr for input */
  1    70       3 error_iocbp,				/* iocb ptr for error output */
  1    71       3 skip,					/* ptr to skip list */
  1    72       3 volume_record_bp,				/* ptr to temp seg containing most recent volume record */
  1    73       3 infop,					/* ptr to temp seg containig tdump info */
  1    74       3 data_object_bp,				/* ptr to temp seg containing most recent object from input medium */
  1    75       3 input_vol_lstp  ptr,				/* ptr to temp seg containing list of input media */
  1    76       3 input_buffer_ptr)  ptr,			/* ptr to read buffer */
  1    77  
  1    78 
  1    79   1 rldr_data_perpv	     aligned,			/* one entry per physical volume to be reloaded	*/
  1    80     2 flags,
  1    81       3 abandoned	     bit (1) unal,			/* we quit due to some error			*/
  1    82       3 restart	     bit (1),			/* if on unitialized volume ok and reload will restart */
  1    83       3 mbz0	     bit (34) unal,			/* beware, RFU				*/
  1    84     (2 pvname,					/* physical volume name */
  1    85     2 lvname,					/* logical volume name of physical volume being reloaded */
  1    86     2 disk_model)	     char (32),			/* model name of disk drive */
  1    87     2 device_name	     char (8),
  1    88     (2 lvid,					/* logical volume id of volume being reloaded */
  1    89     2 pvid)	     bit (36),			/* physical volume id of volume being reloaded */
  1    90     (2 prev_wordx,					/* index to fsmap */
  1    91     2 prev_bitx,					/* index to fsmap */
  1    92     2 disk_type,					/* model index of disk drive */
  1    93     2 usable_sectors,				/* usable sectors per cylinder of disk pack */
  1    94     2 unusable_sectors,				/* unusable sectors per cylinder of disk pack */
  1    95     2 n_vtoce)	     fixed bin,			/* number of vtoce on disk pack */
  1    96     (2 vtocbp,					/* ptr to vtoc buffer seg */
  1    97     2 vtoc_headerp,					/* ptr to temp seg containing the vtoc header */
  1    98     2 labelp,					/* ptr to temp seg containing pack label */
  1    99     2 bvlp,					/* ptr to volume log */
  1   100     2 outputvol_iocbp,				/* iocb ptr for output */
  1   101     2 controlp,					/* ptr to seg containing reload control info about vtoc */
  1   102     2 vol_mapp)	     ptr,				/* ptr to temp seg containing volume map */
  1   103 
  1   104   1 rldr_data_nulled_pv  aligned int static options (constant),
  1   105     2 flags,
  1   106       3 abandoned	     bit (1) init ("0"b) unal,
  1   107       3 restart	     bit (1) init ("0"b) unal,
  1   108       3 mbz0	     bit (34) init ((34)"0"b) unal,
  1   109       (2 pvname,
  1   110     2 lvname,
  1   111     2 disk_model)	     char (32) init (""),
  1   112     2 device_name	     char (8) init (""),
  1   113     (2 lvid,
  1   114     2 pvid)	     bit (36) init ("0"b),
  1   115     (2 prev_wordx,
  1   116     2 prev_bitx,
  1   117     2 disk_type,
  1   118     2 usable_sectors,
  1   119     2 unusable_sectors,
  1   120     2 n_vtoce)	     fixed bin init (0),
  1   121     (2 vtocbp,
  1   122     2 vtoc_headerp,
  1   123     2 labelp,
  1   124     2 bvlp,
  1   125     2 outputvol_iocbp,
  1   126     2 controlp,
  1   127     2 vol_mapp)	     ptr init (null ());
  1   128 
  1   129 
  1   130 /* END INCLUDE FILE rldr_data_.incl.pl1 */
      210 
      211 
  2     1 /* BEGIN INCLUDE FILE ... vtoc_header.incl.pl1 */
  2     2 
  2     3 dcl  vtoc_headerp ptr;
  2     4 
  2     5 dcl 1 vtoc_header based (vtoc_headerp) aligned,
  2     6 
  2     7     2 version fixed bin (17),				/* version number. The current version number is 1. * */
  2     8     2 n_vtoce fixed bin (17),				/* number of vtoc entries */
  2     9     2 vtoc_last_recno fixed bin (17),			/* record number of the last record of the vtoc */
  2    10     2 n_free_vtoce fixed bin (17),			/* number of free vtoc entries */
  2    11     2 first_free_vtocx fixed bin (17),			/* index of the first vtoce in the free list */
  2    12     2 pad (3) bit (36),
  2    13     2 dmpr_bit_map (2048 - 8) bit (36);			/* space for dmpr bit map */
  2    14 
  2    15 /* END INCLUDE ... vtoc_header */
  2    16 
      212 
      213 
  3     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  3     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  3     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  3     4 
  3     5 dcl  vtocep ptr;
  3     6 
  3     7 dcl 1 vtoce based (vtocep) aligned,
  3     8 
  3     9 
  3    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  3    11 
  3    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  3    13 
  3    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  3    16     2 records bit (9),				/* number of records used by the seg in second storage */
  3    17     2 pad2 bit (9),
  3    18 
  3    19     2 dtu bit (36),					/* date and time segment was last used */
  3    20 
  3    21     2 dtm bit (36),					/* date and time segment was last modified */
  3    22 
  3    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    24     2 deciduous bit (1),				/* true if hc_sdw */
  3    25     2 nid bit (1),					/* no incremental dump switch */
  3    26     2 dnzp bit (1),					/* Dont null zero pages */
  3    27     2 gtpd bit (1),					/* Global transparent paging device */
  3    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  3    29     2 damaged bit (1),				/* TRUE if contents damaged */
  3    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  3    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  3    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  3    33     2 pad3 bit (8),
  3    34     2 dirsw bit (1),				/* directory switch */
  3    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  3    36     2 pad4 bit (16)) unaligned,			/* not used */
  3    37 
  3    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  3    39 
  3    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    41 
  3    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    43 
  3    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  3    45 
  3    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  3    47 
  3    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  3    49 
  3    50 
  3    51 
  3    52 
  3    53 
  3    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  3    55 
  3    56     2 pad6 (10) bit (36),				/* not used */
  3    57 
  3    58     2 ncd bit (1),					/* no complete dump switch */
  3    59     2 pad7 bit (17),
  3    60     2 pad8 bit (18),
  3    61 
  3    62     2 dtd bit (36),					/* date-time-dumped */
  3    63 
  3    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  3    65 
  3    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  3    67 
  3    68 
  3    69 
  3    70 
  3    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  3    72 
  3    73     2 primary_name char (32),				/* primary name of the segment */
  3    74 
  3    75     2 time_created bit (36),				/* time the segment was created */
  3    76 
  3    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  3    78 
  3    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  3    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  3    81 
  3    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  3    83 
  3    84     2 access_class bit (72),				/* access class in branch */
  3    85     2 perm_flags aligned,
  3    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  3    87       3 pad9 bit (35) unal,
  3    88     2 owner bit (36);				/* pvid of this volume */
  3    89 
  3    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  3    91 
  3    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  3    93     2 pad1 bit (7*36),
  3    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    95     2 pad2 bit (184*36);
  3    96 
  3    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      214 
      215 
  4     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  4     5*     install(86-11-21,MR12.0-1223):
  4     6*     created.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 /* format: off */
  4    10 
  4    11 /* ************************************************************************ */
  4    12 /*							      */
  4    13 /* Function: Provides constants for commonly used Multics system values.    */
  4    14 /*							      */
  4    15 /* Usage: These values are available for use in place of "magic" numbers    */
  4    16 /*        (unexplained numbers) in programming applications.	      */
  4    17 /*							      */
  4    18 /* Definitions:						      */
  4    19 /*							      */
  4    20 /*   PER             bit     character/byte     word     page     segment   */
  4    21 /*		 					      */
  4    22 /*   bits              1            9             36     36864    9400320   */
  4    23 /*   characters/bytes	      1	           4      4096    1044480   */
  4    24 /*   words				 1      1024     261120   */
  4    25 /*   pages				           1        255   */
  4    26 /*   segments						  1   */
  4    27 /*							      */
  4    28 /*  The base values for a bit, char, word and page are determined by the    */
  4    29 /*  Multics hardware implementation.  The other values are calculated from  */
  4    30 /*  their relation to one another as shown in the matrix above.	      */
  4    31 /*							      */
  4    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  4    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  4    34 /*		  = 9 * 4					      */
  4    35 /*		  = 36					      */
  4    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  4    37 /*		  = 9 * 4 * 1024				      */
  4    38 /*		  = 36864					      */
  4    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  4    40 /*		    PAGES_PER_SEGMENT			      */
  4    41 /*		  = 9 * 4 * 1024 * 255			      */
  4    42 /*		  = 9400320				      */
  4    43 /*							      */
  4    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  4    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  4    46 /*		  = 4 * 1024				      */
  4    47 /*		  = 4096					      */
  4    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  4    49 /*		  = 4 * 1024 * 255				      */
  4    50 /*		  = 1044480				      */
  4    51 /*							      */
  4    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  4    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  4    54 /*		  = 1024 * 255				      */
  4    55 /*		  = 261120				      */
  4    56 /*							      */
  4    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  4    58 /*							      */
  4    59 /* ************************************************************************ */
  4    60 
  4    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  4    62 				options (constant) initial (9);
  4    63 
  4    64        declare BITS_PER_WORD		fixed bin (6) internal static
  4    65 				options (constant) initial (36);
  4    66 
  4    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  4    68 				options (constant) initial (36864);
  4    69 
  4    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  4    71 				options (constant) initial (9400320);
  4    72 
  4    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  4    74 				options (constant) initial (4);
  4    75 
  4    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  4    77 				options (constant) initial (4096);
  4    78 
  4    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  4    80 				options (constant) initial (1044480);
  4    81 
  4    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  4    83 
  4    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  4    85 				options (constant) initial (1024);
  4    86 
  4    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  4    88 
  4    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  4    90 				options (constant) initial (261120);
  4    91 
  4    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  4    93 				options (constant) initial (255);
  4    94 
  4    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  4    96 
      216 
      217 /* BEGIN MESSAGE DOCUMENTATION
      218*
      219*   Message:
      220*   reload_volume_: Abandoning the reload of pv PVNAME
      221*
      222*   S:	$rld_out
      223*
      224*   T:	$reload
      225*
      226*   M:	Some fatal error has occurred during the reload of the specified
      227*   physical volume.
      228*
      229*   A:	Take the action required by the error just previous to this one and 
      230*   retry the reload of the physical volume.
      231*
      232*
      233*   Message:
      234*   reload_volume_: All physical volumes to be reloaded have been abandoned.
      235*
      236*   S:	$rld_out
      237*
      238*   T:	$reload
      239*
      240*   M:	Some fatal error has occurred during the reload of ALL the
      241*   specified physical volumes.
      242*
      243*   A:	$ignore
      244*
      245*
      246*   Message:
      247*   reload_volume_: Bad disk page PAGE_ADDRESS for pv PVNAME
      248*
      249*   S:	$rld_out
      250*
      251*   T:	$reload
      252*
      253*   M:	An I/O error occurred during a reload.
      254*   This message indicates the bad disk address on the volume being reloaded.
      255*
      256*   A:	$ignore
      257*
      258*
      259*   Message:
      260*   reload_volume_: Error reading input: ERROR_MESS
      261*
      262*   S:	$rld_out
      263*
      264*   T:	$reload
      265*
      266*   M:	An error occurred while reading input.
      267*   The input medium is abandoned.
      268*
      269*   A:	$ignore
      270*
      271*
      272*   Message:
      273*   reload_volume_: Error reading old vtoce VTOCX for pv PVNAME: ERROR_MESS
      274*
      275*   S:	$rld_out
      276*
      277*   T:	$reload
      278*
      279*   M:	An I/O error occurred during a reload. The input medium is abandoned.
      280*
      281*   A:	$ignore
      282*
      283*
      284*   Message:
      285*   reload_volume_: Error depositing old vtoce VTOCX for pv PVNAME: ERROR_MESS
      286*
      287*   S:	$rld_out
      288*
      289*   T:	$reload
      290*
      291*   M:	The reloader was unable to release pages of an old object.
      292*   $err
      293*   The input medium is abandoned.
      294*
      295*   A:	$ignore
      296*
      297*
      298*   Message:
      299*   reload_volume_: Error depositing page PAGENO of vtoce VTOCX for pv PVNAME: ERROR_MESS
      300*
      301*   S:	$rld_out
      302*
      303*   T:	$reload
      304*
      305*   M:	The reloader was unable to release page PAGENO (decimal) of the
      306*   new object. This is only done when an incomplete object is detected.
      307*
      308*   A:	$ignore
      309*
      310*
      311*   Message:
      312*   reload_volume_: Error writing new vtoce VTOCX for pv PVNAME: ERROR_MESS
      313*
      314*   S:	$rld_out
      315*
      316*   T:	$reload
      317*
      318*   M:	An I/O error occurred during a reload. The input medium is abandoned.
      319*
      320*   A:	$ignore
      321*
      322*
      323*   Message:
      324*   reload_volume_: Unable to set damaged switch for vtoce VTOCX on pv PVNAME: ERROR_MESS
      325*
      326*   S:	$rld_out
      327*
      328*   T:	$reload
      329*
      330*   M:	An I/O error has occured while attempting to write out the
      331*   new vtoce, which has the damaged switch turned on.
      332*
      333*   A:	$ignore
      334*
      335*
      336*   Message:
      337*   reload_volume_: Unable to withdraw for bad page on pv PVNAME: ERROR_MESS
      338*
      339*   S:	$rld_out
      340*
      341*   T:	$reload
      342*
      343*   M:	After an I/O error, the reloader attempted to allocate a new page,
      344*   and failed. The volume may be full.
      345*
      346*   A:	If the volume is full, it may be necessary to
      347*   clean it up with sweep_pv -gc before restarting the reload.
      348*
      349*
      350*   Message:
      351*   reload_volume_: Unable to withdraw for new vtoce VTOCX for pv PVNAME: ERROR_MESS
      352*
      353*   S:	$rld_out
      354*
      355*   T:	$reload
      356*
      357*   M:	The reloader is unable to allocate a new VTOCE.
      358*   The volume may be full. The input medium is abandoned.
      359*
      360*   A:	$ignore
      361*   If the volume is full, it may be necessary to clean it up with
      362*   sweep_pv with the -gc option and then to continue reloading.
      363*
      364*
      365*   END MESSAGE DOCUMENTATION */
      366 
      367   end reload_volume_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0851.2  reload_volume_.pl1                >spec>install>1115>reload_volume_.pl1
210          1    10/18/88  1215.0  rldr_data_.incl.pl1               >ldd>include>rldr_data_.incl.pl1
212          2    05/23/77  0919.3  vtoc_header.incl.pl1              >ldd>include>vtoc_header.incl.pl1
214          3    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
216          4    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Swritten                        000112 automatic       bit(1)                   packed unaligned dcl 41 set ref 134* 135 150*
WORDS_PER_PAGE                         constant        fixed bin(11,0)          initial dcl 4-84 ref 132 151
abandoned               434            based           bit(1)                   array level 4 packed packed unaligned dcl 1-23 set
                                                                                  ref 186*
add                                    parameter       bit(18)                  packed unaligned dcl 204 set ref 199 206*
addr                                                   builtin function         dcl 61 ref 69 70
already_there                   000113 automatic       bit(1)                   packed unaligned dcl 41 set ref 75* 87 179
bad_pages                       000101 automatic       fixed bin(17,0)          dcl 39 set ref 157* 164* 164 168 169
bit                                                    builtin function         dcl 61 ref 168 169
bits                                   based           structure                level 3 dcl 1-23
code                                   parameter       fixed bin(35,0)          dcl 38 set ref 25 67* 75* 77 78 79* 82* 88* 89 90*
                                                                                  95* 96 97* 104* 106 107* 112* 113 114* 122* 125
                                                                                  136* 139 141* 143 144* 159* 161 161* 170* 172 172*
common                                 based           structure                level 2 dcl 1-23
csl                             000100 automatic       fixed bin(17,0)          dcl 39 in procedure "reload_volume_" set ref 121*
                                                                                  132 158 168
csl                       2(09)        based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 3-7 in procedure "reload_volume_" set ref 121
                                                                                  168*
damaged                   5(06)        based           bit(1)                   level 2 packed packed unaligned dcl 3-7 set ref 125*
                                                                                  167
data_object_bp          426            based           pointer                  level 4 dcl 1-23 ref 136 136
divide                                                 builtin function         dcl 61 ref 132
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 49 ref 78
fixed                   402            based           structure                level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "reload_volume_"
fixed                                                  builtin function         dcl 61 in procedure "reload_volume_" ref 121 168 169
                                                                                  169
flags                   434            based           structure                array level 3 dcl 1-23
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 3-7 set
                                                                                  ref 133 136* 140*
myname                          000000 constant        char(32)                 initial packed unaligned dcl 47 set ref 82* 90* 97*
                                                                                  107* 114* 144* 161* 172* 183* 189* 206*
new_local_vtoce                 000117 automatic       structure                level 1 dcl 44 set ref 69 71*
new_volume                      000114 automatic       bit(1)                   packed unaligned dcl 41 set ref 122* 124
new_vtocep                      000106 automatic       pointer                  dcl 40 set ref 69* 75* 104 104* 112* 120 121 125 133
                                                                                  136 140 141* 159* 167 168 169 169 170*
no_object                 0(06)        based           bit(1)                   level 4 packed packed unaligned dcl 1-23 ref 120
npvs                    404            based           fixed bin(17,0)          level 4 dcl 1-23 ref 188
num_abandoned           402            based           fixed bin(17,0)          level 4 dcl 1-23 set ref 187* 187 188
object_pgx                      000102 automatic       fixed bin(17,0)          dcl 39 set ref 131* 132 136 136 151* 151
old_local_vtoce                 000417 automatic       structure                level 1 dcl 45 set ref 70 72*
old_vtocep                      000110 automatic       pointer                  dcl 40 set ref 70* 88* 94 95*
pages_returned                  000116 automatic       fixed bin(17,0)          dcl 42 set ref 122* 132
per_pv                  434            based           structure                array level 2 dcl 1-23
pgx                             000103 automatic       fixed bin(17,0)          dcl 39 set ref 132* 133 136 140 141* 158* 158* 159*
                                                                                  161*
pointer                                                builtin function         dcl 61 ref 136 136
ptrs                    414            based           structure                level 3 dcl 1-23
pvindex                         000104 automatic       fixed bin(17,0)          dcl 39 set ref 75* 85 88* 90 95* 97 104* 107 112*
                                                                                  114 122* 136* 141* 144 159* 161 170* 172 179* 183
                                                                                  186 206
pvname                  437            based           char(32)                 array level 3 dcl 1-23 set ref 90* 97* 107* 114*
                                                                                  144* 161* 172* 183* 206*
records                   2(18)        based           bit(9)                   level 2 packed packed unaligned dcl 3-7 set ref 169*
                                                                                  169
rldr_data_                             based           structure                level 1 dcl 1-23
rldr_data_common                000720 automatic       structure                level 1 dcl 1-23
rldr_data_perpv                 001354 automatic       structure                level 1 dcl 1-23
rldr_datap                             parameter       pointer                  dcl 1-23 set ref 25 75* 82* 85 88* 90* 90 95* 97* 97
                                                                                  104* 107* 107 112* 114* 114 120 122* 136* 136 136
                                                                                  141* 144* 144 159* 161* 161 170* 172* 172 179*
                                                                                  183* 183 186 187 187 188 188 189* 206* 206
rldr_input_$collect_stats       000012 constant        entry                    external dcl 51 ref 179
rldr_input_$get_object          000014 constant        entry                    external dcl 52 ref 75
rldr_input_$read_object         000016 constant        entry                    external dcl 53 ref 122
rldr_output_$write_page         000026 constant        entry                    external dcl 57 ref 136
rldr_report_$error_output       000020 constant        entry                    external dcl 54 ref 82 90 97 107 114 144 161 172 183
                                                                                  189 206
rldr_volume_map_$deposit        000030 constant        entry                    external dcl 58 ref 95 159
rldr_volume_map_$withdraw       000032 constant        entry                    external dcl 59 ref 104 141
rldr_vtoc_buffer_$get           000022 constant        entry                    external dcl 55 ref 88
rldr_vtoc_buffer_$put           000024 constant        entry                    external dcl 56 ref 112 170
skip_next_header_check          000115 automatic       bit(1)                   packed unaligned dcl 41 set ref 68* 75* 122*
substr                                                 builtin function         dcl 61 ref 133
uid                       1            based           bit(36)                  level 2 packed packed unaligned dcl 3-7 ref 94 104
                                                                                  120
unspec                                                 builtin function         dcl 61 set ref 71* 72*
vtoc_headerp            504            based           pointer                  array level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "reload_volume_" ref 85
vtoc_headerp                    001440 automatic       pointer                  dcl 2-3 in procedure "reload_volume_" set ref 85*
vtoce                                  based           structure                level 1 dcl 3-7
vtocx                           000105 automatic       fixed bin(17,0)          dcl 39 set ref 75* 88* 90* 97* 107* 112* 114* 161*
                                                                                  170* 172*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 4-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 4-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 4-70
BITS_PER_WORD                          internal static fixed bin(6,0)           initial dcl 4-64
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 4-76
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 4-79
CHARS_PER_WORD                         internal static fixed bin(3,0)           initial dcl 4-73
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 4-92
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 4-89
rldr_data_max_pvs                      automatic       fixed bin(17,0)          dcl 1-23
rldr_data_nulled_pv                    internal static structure                level 1 dcl 1-23
seg_vtoce                              based           structure                level 1 dcl 3-92
vtoc_header                            based           structure                level 1 dcl 2-5
vtoce_parts                            based           bit(2304)                array dcl 3-90
vtocep                                 automatic       pointer                  dcl 3-5

NAMES DECLARED BY EXPLICIT CONTEXT.
log_bad_addr                    001534 constant        entry                    internal dcl 199 ref 140
reload_volume_                  000212 constant        entry                    external dcl 25
restart                         000234 constant        label                    dcl 75 ref 124 194
skip_this_pv                    001422 constant        label                    dcl 183 ref 92 99 109 116 146

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1760        2014    1610        1770
Length      2270    1610        34         240     147           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
reload_volume_                      942 external procedure  is an external procedure.  
log_bad_addr                            internal procedure  shares stack frame of external procedure reload_volume_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
reload_volume_           000100 csl                         reload_volume_
                         000101 bad_pages                   reload_volume_
                         000102 object_pgx                  reload_volume_
                         000103 pgx                         reload_volume_
                         000104 pvindex                     reload_volume_
                         000105 vtocx                       reload_volume_
                         000106 new_vtocep                  reload_volume_
                         000110 old_vtocep                  reload_volume_
                         000112 Swritten                    reload_volume_
                         000113 already_there               reload_volume_
                         000114 new_volume                  reload_volume_
                         000115 skip_next_header_check      reload_volume_
                         000116 pages_returned              reload_volume_
                         000117 new_local_vtoce             reload_volume_
                         000417 old_local_vtoce             reload_volume_
                         000720 rldr_data_common            reload_volume_
                         001354 rldr_data_perpv             reload_volume_
                         001440 vtoc_headerp                reload_volume_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
rldr_input_$collect_stats     rldr_input_$get_object        rldr_input_$read_object       rldr_output_$write_page
rldr_report_$error_output     rldr_volume_map_$deposit      rldr_volume_map_$withdraw     rldr_vtoc_buffer_$get
rldr_vtoc_buffer_$put

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info


CONSTANTS
000000  aa  162 145 154 157	relo
000001  aa  141 144 137 166	ad_v
000002  aa  157 154 165 155	olum
000003  aa  145 137 040 040	e_  
000004  aa  040 040 040 040	    
000005  aa  040 040 040 040	    
000006  aa  040 040 040 040	    
000007  aa  040 040 040 040	    

000010  aa     524000000032

000011  aa     516000000022

000012  aa     524000000070

000013  aa     524000000036

000014  aa     404000000005

000015  aa     524000000062

000016  aa     524000000056

000017  aa     524000000050

000020  aa     524000000055

000021  aa     524000000047

000022  aa     524000000040

000023  aa     404000000021

000024  aa     524000000044

000025  aa     524000000023

000026  aa     526000000040

000027  aa     464000000000

000030  aa     404000000043

000031  aa  105 162 162 157	Erro
000032  aa  162 040 162 145	r re
000033  aa  141 144 151 156	adin
000034  aa  147 040 151 156	g in
000035  aa  160 165 164 000	put

000036  aa  102 141 144 040	Bad 
000037  aa  144 151 163 153	disk
000040  aa  040 160 141 147	 pag
000041  aa  145 040 136 157	e ^o
000042  aa  040 146 157 162	 for
000043  aa  040 160 166 040	 pv 
000044  aa  136 141 000 000	^a

000045  aa  101 142 141 156	Aban
000046  aa  144 157 156 151	doni
000047  aa  156 147 040 164	ng t
000050  aa  150 145 040 162	he r
000051  aa  145 154 157 141	eloa
000052  aa  144 040 157 146	d of
000053  aa  040 160 166 040	 pv 
000054  aa  136 141 000 000	^a

000055  aa  105 162 162 157	Erro
000056  aa  162 040 167 162	r wr
000057  aa  151 164 151 156	itin
000060  aa  147 040 156 145	g ne
000061  aa  167 040 166 164	w vt
000062  aa  157 143 145 040	oce 
000063  aa  136 157 040 146	^o f
000064  aa  157 162 040 160	or p
000065  aa  166 040 136 141	v ^a

000066  aa  105 162 162 157	Erro
000067  aa  162 040 162 145	r re
000070  aa  141 144 151 156	adin
000071  aa  147 040 157 154	g ol
000072  aa  144 040 166 164	d vt
000073  aa  157 143 145 040	oce 
000074  aa  136 157 040 146	^o f
000075  aa  157 162 040 160	or p
000076  aa  166 040 136 141	v ^a

000077  aa  125 156 141 142	Unab
000100  aa  154 145 040 164	le t
000101  aa  157 040 167 151	o wi
000102  aa  164 150 144 162	thdr
000103  aa  141 167 040 146	aw f
000104  aa  157 162 040 142	or b
000105  aa  141 144 040 160	ad p
000106  aa  141 147 145 040	age 
000107  aa  157 156 040 160	on p
000110  aa  166 040 136 141	v ^a

000111  aa  105 162 162 157	Erro
000112  aa  162 040 144 145	r de
000113  aa  160 157 163 151	posi
000114  aa  164 151 156 147	ting
000115  aa  040 157 154 144	 old
000116  aa  040 166 164 157	 vto
000117  aa  143 145 040 136	ce ^
000120  aa  157 040 146 157	o fo
000121  aa  162 040 160 166	r pv
000122  aa  040 136 141 000	 ^a

000123  aa  105 162 162 157	Erro
000124  aa  162 040 144 145	r de
000125  aa  160 157 163 151	posi
000126  aa  164 151 156 147	ting
000127  aa  040 160 141 147	 pag
000130  aa  145 040 136 144	e ^d
000131  aa  040 157 146 040	 of 
000132  aa  166 164 157 143	vtoc
000133  aa  145 040 136 157	e ^o
000134  aa  040 146 157 162	 for
000135  aa  040 160 166 040	 pv 
000136  aa  136 141 000 000	^a

000137  aa  125 156 141 142	Unab
000140  aa  154 145 040 164	le t
000141  aa  157 040 167 151	o wi
000142  aa  164 150 144 162	thdr
000143  aa  141 167 040 146	aw f
000144  aa  157 162 040 156	or n
000145  aa  145 167 040 166	ew v
000146  aa  164 157 143 145	toce
000147  aa  040 136 157 040	 ^o 
000150  aa  146 157 162 040	for 
000151  aa  160 166 040 136	pv ^
000152  aa  141 000 000 000	a

000153  aa  125 156 141 142	Unab
000154  aa  154 145 040 164	le t
000155  aa  157 040 163 145	o se
000156  aa  164 040 144 141	t da
000157  aa  155 141 147 145	mage
000160  aa  144 040 163 167	d sw
000161  aa  151 164 143 150	itch
000162  aa  040 146 157 162	 for
000163  aa  040 166 164 157	 vto
000164  aa  143 145 040 136	ce ^
000165  aa  157 040 157 156	o on
000166  aa  040 160 166 040	 pv 
000167  aa  136 141 000 000	^a

000170  aa  101 154 154 040	All 
000171  aa  160 150 171 163	phys
000172  aa  151 143 141 154	ical
000173  aa  040 166 157 154	 vol
000174  aa  165 155 145 163	umes
000175  aa  040 164 157 040	 to 
000176  aa  142 145 040 162	be r
000177  aa  145 154 157 141	eloa
000200  aa  144 145 144 040	ded 
000201  aa  150 141 166 145	have
000202  aa  040 142 145 145	 bee
000203  aa  156 040 141 142	n ab
000204  aa  141 156 144 157	ando
000205  aa  156 145 144 056	ned.

BEGIN PROCEDURE reload_volume_
ENTRY TO reload_volume_                                     STATEMENT 1 ON LINE 25
reload_volume_: proc (rldr_datap, code);

000206  at     000002000027
000207  ta     000030000000
000210  ta     000206000000
000211  da     000143300000
000212  aa   001660 6270 00	eax7 	944
000213  aa  7 00034 3521 20	epp2 	pr7|28,*
000214  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000215  aa     000004000000
000216  aa     000000000000
						STATEMENT 1 ON LINE 67
    code = 0;

000217  aa  6 00032 3735 20	epp7 	pr6|26,*
000220  aa  7 00004 4501 20	stz  	pr7|4,*		code
						STATEMENT 1 ON LINE 68
    skip_next_header_check = "0"b;

000221  aa  6 00115 4501 00	stz  	pr6|77		skip_next_header_check
						STATEMENT 1 ON LINE 69
    new_vtocep = addr (new_local_vtoce);

000222  aa  6 00117 3715 00	epp5 	pr6|79		new_local_vtoce
000223  aa  6 00106 6515 00	spri5	pr6|70		new_vtocep
						STATEMENT 1 ON LINE 70
    old_vtocep = addr (old_local_vtoce);

000224  aa  6 00417 3535 00	epp3 	pr6|271		old_local_vtoce
000225  aa  6 00110 2535 00	spri3	pr6|72		old_vtocep
						STATEMENT 1 ON LINE 71
    unspec (new_local_vtoce) = "0"b;

000226  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000227  aa   000000 00 0000	desc9a	0,0
000230  aa  6 00117 00 1400	desc9a	pr6|79,768
						STATEMENT 1 ON LINE 72
    unspec (old_local_vtoce) = "0"b;

000231  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000232  aa   000000 00 0000	desc9a	0,0
000233  aa  6 00417 00 1400	desc9a	pr6|271,768
						STATEMENT 1 ON LINE 74
    do while ("1"b);

						STATEMENT 1 ON LINE 75
restart: call rldr_input_$get_object (rldr_datap, skip_next_header_check, new_vtocep, vtocx, already_there, pvindex, code);

000234  aa  6 00032 3735 20	epp7 	pr6|26,*
000235  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000236  aa  6 01454 2521 00	spri2	pr6|812
000237  aa  6 00115 3521 00	epp2 	pr6|77		skip_next_header_check
000240  aa  6 01456 2521 00	spri2	pr6|814
000241  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
000242  aa  6 01460 2521 00	spri2	pr6|816
000243  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000244  aa  6 01462 2521 00	spri2	pr6|818
000245  aa  6 00113 3521 00	epp2 	pr6|75		already_there
000246  aa  6 01464 2521 00	spri2	pr6|820
000247  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000250  aa  6 01466 2521 00	spri2	pr6|822
000251  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000252  aa  6 01470 2521 00	spri2	pr6|824
000253  aa  6 01452 6211 00	eax1 	pr6|810
000254  aa   034000 4310 07	fld  	14336,dl
000255  aa  6 00044 3701 20	epp4 	pr6|36,*
000256  la  4 00014 3521 20	epp2 	pr4|12,*		rldr_input_$get_object
000257  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 77
      if code ^= 0 then do;

000260  aa  6 00032 3735 20	epp7 	pr6|26,*
000261  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000262  aa   000036 6000 04	tze  	30,ic		000320
						STATEMENT 1 ON LINE 78
	if code = error_table_$end_of_info then do;

000263  aa  6 00044 3701 20	epp4 	pr6|36,*
000264  la  4 00010 1161 20	cmpq 	pr4|8,*		error_table_$end_of_info
000265  aa   000003 6010 04	tnz  	3,ic		000270
						STATEMENT 1 ON LINE 79
	    code = 0;

000266  aa  7 00004 4501 20	stz  	pr7|4,*		code
						STATEMENT 1 ON LINE 80
	    return;

000267  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 81
	  end;

						STATEMENT 1 ON LINE 82
	call rldr_report_$error_output (rldr_datap, code, myname, "Error reading input");

000270  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000271  aa   777541 00 0024	desc9a	-159,20		000031 = 105162162157
000272  aa  6 01452 00 0024	desc9a	pr6|810,20
000273  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000274  aa  6 01474 2521 00	spri2	pr6|828
000275  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000276  aa  6 01476 2521 00	spri2	pr6|830
000277  aa   777501 3520 04	epp2 	-191,ic		000000 = 162145154157
000300  aa  6 01500 2521 00	spri2	pr6|832
000301  aa  6 01452 3521 00	epp2 	pr6|810
000302  aa  6 01502 2521 00	spri2	pr6|834
000303  aa   777524 3520 04	epp2 	-172,ic		000027 = 464000000000
000304  aa  6 01504 2521 00	spri2	pr6|836
000305  aa   777523 3520 04	epp2 	-173,ic		000030 = 404000000043
000306  aa  6 01506 2521 00	spri2	pr6|838
000307  aa   777517 3520 04	epp2 	-177,ic		000026 = 526000000040
000310  aa  6 01510 2521 00	spri2	pr6|840
000311  aa   777514 3520 04	epp2 	-180,ic		000025 = 524000000023
000312  aa  6 01512 2521 00	spri2	pr6|842
000313  aa  6 01472 6211 00	eax1 	pr6|826
000314  aa   020000 4310 07	fld  	8192,dl
000315  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
000316  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 83
	return;

000317  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 84
        end;

						STATEMENT 1 ON LINE 85
      vtoc_headerp = rldr_data_.vtoc_headerp (pvindex);

000320  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
000321  aa   000064 4020 07	mpy  	52,dl
000322  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000323  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000324  aa  5 00420 3535 26	epp3 	pr5|272,ql*	rldr_data_.vtoc_headerp
000325  aa  6 01440 2535 00	spri3	pr6|800		vtoc_headerp
						STATEMENT 1 ON LINE 87
      if already_there then do;

000326  aa  6 00113 2351 00	lda  	pr6|75		already_there
000327  aa   400000 3150 03	cana 	131072,du
000330  aa   000170 6000 04	tze  	120,ic		000520
						STATEMENT 1 ON LINE 88
	call rldr_vtoc_buffer_$get (rldr_datap, pvindex, old_vtocep, vtocx, code);

000331  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000332  aa  6 01454 2521 00	spri2	pr6|812
000333  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000334  aa  6 01456 2521 00	spri2	pr6|814
000335  aa  6 00110 3521 00	epp2 	pr6|72		old_vtocep
000336  aa  6 01460 2521 00	spri2	pr6|816
000337  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000340  aa  6 01462 2521 00	spri2	pr6|818
000341  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000342  aa  6 01464 2521 00	spri2	pr6|820
000343  aa  6 01452 6211 00	eax1 	pr6|810
000344  aa   024000 4310 07	fld  	10240,dl
000345  aa  6 00044 3701 20	epp4 	pr6|36,*
000346  la  4 00022 3521 20	epp2 	pr4|18,*		rldr_vtoc_buffer_$get
000347  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 89
	if code ^= 0 then do;

000350  aa  6 00032 3735 20	epp7 	pr6|26,*
000351  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000352  aa   000050 6000 04	tze  	40,ic		000422
						STATEMENT 1 ON LINE 90
	    call rldr_report_$error_output (rldr_datap, code, myname, "Error reading old vtoce ^o for pv ^a", vtocx,
	         rldr_data_.pvname (pvindex));

000353  aa   777447 2360 04	ldq  	-217,ic		000022 = 524000000040
000354  aa  6 01514 7561 00	stq  	pr6|844
000355  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000356  aa   777511 00 0044	desc9a	-183,36		000066 = 105162162157
000357  aa  6 01452 00 0044	desc9a	pr6|810,36
000360  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
000361  aa   000064 4020 07	mpy  	52,dl
000362  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000363  aa  6 01520 2521 00	spri2	pr6|848
000364  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000365  aa  6 01522 2521 00	spri2	pr6|850
000366  aa   777412 3520 04	epp2 	-246,ic		000000 = 162145154157
000367  aa  6 01524 2521 00	spri2	pr6|852
000370  aa  6 01452 3521 00	epp2 	pr6|810
000371  aa  6 01526 2521 00	spri2	pr6|854
000372  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000373  aa  6 01530 2521 00	spri2	pr6|856
000374  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000375  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000376  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000377  aa  6 01532 2521 00	spri2	pr6|858
000400  aa   777427 3520 04	epp2 	-233,ic		000027 = 464000000000
000401  aa  6 01534 2521 00	spri2	pr6|860
000402  aa   777426 3520 04	epp2 	-234,ic		000030 = 404000000043
000403  aa  6 01536 2521 00	spri2	pr6|862
000404  aa   777422 3520 04	epp2 	-238,ic		000026 = 526000000040
000405  aa  6 01540 2521 00	spri2	pr6|864
000406  aa   777416 3520 04	epp2 	-242,ic		000024 = 524000000044
000407  aa  6 01542 2521 00	spri2	pr6|866
000410  aa   777413 3520 04	epp2 	-245,ic		000023 = 404000000021
000411  aa  6 01544 2521 00	spri2	pr6|868
000412  aa  6 01514 3521 00	epp2 	pr6|844
000413  aa  6 01546 2521 00	spri2	pr6|870
000414  aa  6 01516 6211 00	eax1 	pr6|846
000415  aa   030000 4310 07	fld  	12288,dl
000416  aa  6 00044 3701 20	epp4 	pr6|36,*
000417  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
000420  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 92
	    goto skip_this_pv;

000421  aa   001001 7100 04	tra  	513,ic		001422
						STATEMENT 1 ON LINE 93
	  end;

						STATEMENT 1 ON LINE 94
	if old_vtocep -> vtoce.uid ^= "0"b then do;

000422  aa  6 00110 3715 20	epp5 	pr6|72,*		old_vtocep
000423  aa  5 00001 2351 00	lda  	pr5|1		vtoce.uid
000424  aa   000074 6000 04	tze  	60,ic		000520
						STATEMENT 1 ON LINE 95
	    call rldr_volume_map_$deposit (rldr_datap, pvindex, old_vtocep, -1, code);

000425  aa   000001 3360 07	lcq  	1,dl
000426  aa  6 01514 7561 00	stq  	pr6|844
000427  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000430  aa  6 01454 2521 00	spri2	pr6|812
000431  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000432  aa  6 01456 2521 00	spri2	pr6|814
000433  aa  6 00110 3521 00	epp2 	pr6|72		old_vtocep
000434  aa  6 01460 2521 00	spri2	pr6|816
000435  aa  6 01514 3521 00	epp2 	pr6|844
000436  aa  6 01462 2521 00	spri2	pr6|818
000437  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000440  aa  6 01464 2521 00	spri2	pr6|820
000441  aa  6 01452 6211 00	eax1 	pr6|810
000442  aa   024000 4310 07	fld  	10240,dl
000443  aa  6 00044 3701 20	epp4 	pr6|36,*
000444  la  4 00030 3521 20	epp2 	pr4|24,*		rldr_volume_map_$deposit
000445  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 96
	    if code ^= 0 then do;

000446  aa  6 00032 3735 20	epp7 	pr6|26,*
000447  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000450  aa   000050 6000 04	tze  	40,ic		000520
						STATEMENT 1 ON LINE 97
	        call rldr_report_$error_output (rldr_datap, code, myname, "Error depositing old vtoce ^o for pv ^a", vtocx,
		   rldr_data_.pvname (pvindex));

000451  aa   777351 2360 04	ldq  	-279,ic		000022 = 524000000040
000452  aa  6 01514 7561 00	stq  	pr6|844
000453  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000454  aa   777436 00 0050	desc9a	-226,40		000111 = 105162162157
000455  aa  6 01452 00 0050	desc9a	pr6|810,40
000456  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
000457  aa   000064 4020 07	mpy  	52,dl
000460  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000461  aa  6 01520 2521 00	spri2	pr6|848
000462  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000463  aa  6 01522 2521 00	spri2	pr6|850
000464  aa   777314 3520 04	epp2 	-308,ic		000000 = 162145154157
000465  aa  6 01524 2521 00	spri2	pr6|852
000466  aa  6 01452 3521 00	epp2 	pr6|810
000467  aa  6 01526 2521 00	spri2	pr6|854
000470  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000471  aa  6 01530 2521 00	spri2	pr6|856
000472  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000473  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000474  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000475  aa  6 01532 2521 00	spri2	pr6|858
000476  aa   777331 3520 04	epp2 	-295,ic		000027 = 464000000000
000477  aa  6 01534 2521 00	spri2	pr6|860
000500  aa   777330 3520 04	epp2 	-296,ic		000030 = 404000000043
000501  aa  6 01536 2521 00	spri2	pr6|862
000502  aa   777324 3520 04	epp2 	-300,ic		000026 = 526000000040
000503  aa  6 01540 2521 00	spri2	pr6|864
000504  aa   777315 3520 04	epp2 	-307,ic		000021 = 524000000047
000505  aa  6 01542 2521 00	spri2	pr6|866
000506  aa   777315 3520 04	epp2 	-307,ic		000023 = 404000000021
000507  aa  6 01544 2521 00	spri2	pr6|868
000510  aa  6 01514 3521 00	epp2 	pr6|844
000511  aa  6 01546 2521 00	spri2	pr6|870
000512  aa  6 01516 6211 00	eax1 	pr6|846
000513  aa   030000 4310 07	fld  	12288,dl
000514  aa  6 00044 3701 20	epp4 	pr6|36,*
000515  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
000516  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 99
	        goto skip_this_pv;

000517  aa   000703 7100 04	tra  	451,ic		001422
						STATEMENT 1 ON LINE 100
	      end;

						STATEMENT 1 ON LINE 101
	  end;

						STATEMENT 1 ON LINE 102
        end;

						STATEMENT 1 ON LINE 104
      if new_vtocep -> vtoce.uid ^= "0"b then
        call rldr_volume_map_$withdraw (rldr_datap, pvindex, new_vtocep, -1, code);

000520  aa  6 00106 3715 20	epp5 	pr6|70,*		new_vtocep
000521  aa  5 00001 2351 00	lda  	pr5|1		vtoce.uid
000522  aa   000022 6000 04	tze  	18,ic		000544
000523  aa   000001 3360 07	lcq  	1,dl
000524  aa  6 01514 7561 00	stq  	pr6|844
000525  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000526  aa  6 01454 2521 00	spri2	pr6|812
000527  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000530  aa  6 01456 2521 00	spri2	pr6|814
000531  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
000532  aa  6 01460 2521 00	spri2	pr6|816
000533  aa  6 01514 3521 00	epp2 	pr6|844
000534  aa  6 01462 2521 00	spri2	pr6|818
000535  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000536  aa  6 01464 2521 00	spri2	pr6|820
000537  aa  6 01452 6211 00	eax1 	pr6|810
000540  aa   024000 4310 07	fld  	10240,dl
000541  aa  6 00044 3701 20	epp4 	pr6|36,*
000542  la  4 00032 3521 20	epp2 	pr4|26,*		rldr_volume_map_$withdraw
000543  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 106
      if code ^= 0 then do;

000544  aa  6 00032 3735 20	epp7 	pr6|26,*
000545  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000546  aa   000050 6000 04	tze  	40,ic		000616
						STATEMENT 1 ON LINE 107
	call rldr_report_$error_output (rldr_datap, code, myname, "Unable to withdraw for new vtoce ^o for pv ^a", vtocx,
	     rldr_data_.pvname (pvindex));

000547  aa   777253 2360 04	ldq  	-341,ic		000022 = 524000000040
000550  aa  6 01514 7561 00	stq  	pr6|844
000551  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000552  aa   777366 00 0060	desc9a	-266,48		000137 = 125156141142
000553  aa  6 01452 00 0060	desc9a	pr6|810,48
000554  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
000555  aa   000064 4020 07	mpy  	52,dl
000556  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000557  aa  6 01520 2521 00	spri2	pr6|848
000560  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000561  aa  6 01522 2521 00	spri2	pr6|850
000562  aa   777216 3520 04	epp2 	-370,ic		000000 = 162145154157
000563  aa  6 01524 2521 00	spri2	pr6|852
000564  aa  6 01452 3521 00	epp2 	pr6|810
000565  aa  6 01526 2521 00	spri2	pr6|854
000566  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000567  aa  6 01530 2521 00	spri2	pr6|856
000570  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000571  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000572  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000573  aa  6 01532 2521 00	spri2	pr6|858
000574  aa   777233 3520 04	epp2 	-357,ic		000027 = 464000000000
000575  aa  6 01534 2521 00	spri2	pr6|860
000576  aa   777232 3520 04	epp2 	-358,ic		000030 = 404000000043
000577  aa  6 01536 2521 00	spri2	pr6|862
000600  aa   777226 3520 04	epp2 	-362,ic		000026 = 526000000040
000601  aa  6 01540 2521 00	spri2	pr6|864
000602  aa   777216 3520 04	epp2 	-370,ic		000020 = 524000000055
000603  aa  6 01542 2521 00	spri2	pr6|866
000604  aa   777217 3520 04	epp2 	-369,ic		000023 = 404000000021
000605  aa  6 01544 2521 00	spri2	pr6|868
000606  aa  6 01514 3521 00	epp2 	pr6|844
000607  aa  6 01546 2521 00	spri2	pr6|870
000610  aa  6 01516 6211 00	eax1 	pr6|846
000611  aa   030000 4310 07	fld  	12288,dl
000612  aa  6 00044 3701 20	epp4 	pr6|36,*
000613  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
000614  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 109
	goto skip_this_pv;

000615  aa   000605 7100 04	tra  	389,ic		001422
						STATEMENT 1 ON LINE 110
        end;

						STATEMENT 1 ON LINE 112
      call rldr_vtoc_buffer_$put (rldr_datap, pvindex, new_vtocep, vtocx, code);

000616  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000617  aa  6 01454 2521 00	spri2	pr6|812
000620  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000621  aa  6 01456 2521 00	spri2	pr6|814
000622  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
000623  aa  6 01460 2521 00	spri2	pr6|816
000624  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000625  aa  6 01462 2521 00	spri2	pr6|818
000626  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000627  aa  6 01464 2521 00	spri2	pr6|820
000630  aa  6 01452 6211 00	eax1 	pr6|810
000631  aa   024000 4310 07	fld  	10240,dl
000632  aa  6 00044 3701 20	epp4 	pr6|36,*
000633  la  4 00024 3521 20	epp2 	pr4|20,*		rldr_vtoc_buffer_$put
000634  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 113
      if code ^= 0 then do;

000635  aa  6 00032 3735 20	epp7 	pr6|26,*
000636  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000637  aa   000050 6000 04	tze  	40,ic		000707
						STATEMENT 1 ON LINE 114
	call rldr_report_$error_output (rldr_datap, code, myname, "Error writing new vtoce ^o for pv ^a", vtocx,
	     rldr_data_.pvname (pvindex));

000640  aa   777162 2360 04	ldq  	-398,ic		000022 = 524000000040
000641  aa  6 01514 7561 00	stq  	pr6|844
000642  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000643  aa   777213 00 0044	desc9a	-373,36		000055 = 105162162157
000644  aa  6 01452 00 0044	desc9a	pr6|810,36
000645  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
000646  aa   000064 4020 07	mpy  	52,dl
000647  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000650  aa  6 01520 2521 00	spri2	pr6|848
000651  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000652  aa  6 01522 2521 00	spri2	pr6|850
000653  aa   777125 3520 04	epp2 	-427,ic		000000 = 162145154157
000654  aa  6 01524 2521 00	spri2	pr6|852
000655  aa  6 01452 3521 00	epp2 	pr6|810
000656  aa  6 01526 2521 00	spri2	pr6|854
000657  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
000660  aa  6 01530 2521 00	spri2	pr6|856
000661  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000662  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000663  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000664  aa  6 01532 2521 00	spri2	pr6|858
000665  aa   777142 3520 04	epp2 	-414,ic		000027 = 464000000000
000666  aa  6 01534 2521 00	spri2	pr6|860
000667  aa   777141 3520 04	epp2 	-415,ic		000030 = 404000000043
000670  aa  6 01536 2521 00	spri2	pr6|862
000671  aa   777135 3520 04	epp2 	-419,ic		000026 = 526000000040
000672  aa  6 01540 2521 00	spri2	pr6|864
000673  aa   777131 3520 04	epp2 	-423,ic		000024 = 524000000044
000674  aa  6 01542 2521 00	spri2	pr6|866
000675  aa   777126 3520 04	epp2 	-426,ic		000023 = 404000000021
000676  aa  6 01544 2521 00	spri2	pr6|868
000677  aa  6 01514 3521 00	epp2 	pr6|844
000700  aa  6 01546 2521 00	spri2	pr6|870
000701  aa  6 01516 6211 00	eax1 	pr6|846
000702  aa   030000 4310 07	fld  	12288,dl
000703  aa  6 00044 3701 20	epp4 	pr6|36,*
000704  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
000705  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 116
	goto skip_this_pv;

000706  aa   000514 7100 04	tra  	332,ic		001422
						STATEMENT 1 ON LINE 117
        end;

						STATEMENT 1 ON LINE 120
      if new_vtocep -> vtoce.uid ^= "0"b & ^rldr_data_.no_object then do;

000707  aa  6 00106 3715 20	epp5 	pr6|70,*		new_vtocep
000710  aa  5 00001 2351 00	lda  	pr5|1		vtoce.uid
000711  aa   000472 6000 04	tze  	314,ic		001403
000712  aa  7 00002 3535 20	epp3 	pr7|2,*		rldr_datap
000713  aa  3 00000 2351 20	lda  	pr3|0,*		rldr_data_.no_object
000714  aa   004000 3150 03	cana 	2048,du
000715  aa   000466 6010 04	tnz  	310,ic		001403
						STATEMENT 1 ON LINE 121
	csl = fixed (new_vtocep -> vtoce.csl);

000716  aa  5 00002 2351 00	lda  	pr5|2		vtoce.csl
000717  aa   000011 7350 00	als  	9
000720  aa   000077 7730 00	lrl  	63
000721  aa  6 00100 7561 00	stq  	pr6|64		csl
						STATEMENT 1 ON LINE 122
	call rldr_input_$read_object (rldr_datap, pvindex, new_volume,
	     skip_next_header_check, pages_returned, code);

000722  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000723  aa  6 01454 2521 00	spri2	pr6|812
000724  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
000725  aa  6 01456 2521 00	spri2	pr6|814
000726  aa  6 00114 3521 00	epp2 	pr6|76		new_volume
000727  aa  6 01460 2521 00	spri2	pr6|816
000730  aa  6 00115 3521 00	epp2 	pr6|77		skip_next_header_check
000731  aa  6 01462 2521 00	spri2	pr6|818
000732  aa  6 00116 3521 00	epp2 	pr6|78		pages_returned
000733  aa  6 01464 2521 00	spri2	pr6|820
000734  aa  7 00004 3521 20	epp2 	pr7|4,*		code
000735  aa  6 01466 2521 00	spri2	pr6|822
000736  aa  6 01452 6211 00	eax1 	pr6|810
000737  aa   030000 4310 07	fld  	12288,dl
000740  aa  6 00044 3701 20	epp4 	pr6|36,*
000741  la  4 00016 3521 20	epp2 	pr4|14,*		rldr_input_$read_object
000742  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 124
	if new_volume then goto restart;

000743  aa  6 00114 2351 00	lda  	pr6|76		new_volume
000744  aa   400000 3150 03	cana 	131072,du
000745  aa   777267 6010 04	tnz  	-329,ic		000234
						STATEMENT 1 ON LINE 125
	if code ^= 0 then
	  new_vtocep -> vtoce.damaged = "1"b;

000746  aa  6 00032 3735 20	epp7 	pr6|26,*
000747  aa  7 00004 2361 20	ldq  	pr7|4,*		code
000750  aa   000004 6000 04	tze  	4,ic		000754
000751  aa   004000 2350 03	lda  	2048,du
000752  aa  6 00106 3715 20	epp5 	pr6|70,*		new_vtocep
000753  aa  5 00005 2551 00	orsa 	pr5|5		vtoce.damaged
						STATEMENT 1 ON LINE 131
	object_pgx = 0;

000754  aa  6 00102 4501 00	stz  	pr6|66		object_pgx
						STATEMENT 1 ON LINE 132
	do pgx = 0 to csl - 1 while (divide (object_pgx, WORDS_PER_PAGE, 17) < pages_returned);

000755  aa  6 00100 2361 00	ldq  	pr6|64		csl
000756  aa   000001 1760 07	sbq  	1,dl
000757  aa  6 01442 7561 00	stq  	pr6|802
000760  aa  6 00103 4501 00	stz  	pr6|67		pgx
000761  aa   000000 0110 03	nop  	0,du
000762  aa  6 00103 2361 00	ldq  	pr6|67		pgx
000763  aa  6 01442 1161 00	cmpq 	pr6|802
000764  aa   000165 6054 04	tpnz 	117,ic		001151
000765  aa  6 00102 2361 00	ldq  	pr6|66		object_pgx
000766  aa   002000 5060 07	div  	1024,dl
000767  aa  6 00116 1161 00	cmpq 	pr6|78		pages_returned
000770  aa   000161 6050 04	tpl  	113,ic		001151
						STATEMENT 1 ON LINE 133
	  if ^substr (new_vtocep -> vtoce.fm (pgx), 1, 1) then do;

000771  aa  6 00103 2361 00	ldq  	pr6|67		pgx
000772  aa   000022 4020 07	mpy  	18,dl
000773  aa  6 00106 3735 20	epp7 	pr6|70,*		new_vtocep
000774  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
000775  aa  7 00020 00 0001	descb	pr7|16,1		vtoce.fm
000776  aa   000000 00 0000	descb	0,0
000777  aa   000150 6010 04	tnz  	104,ic		001147
						STATEMENT 1 ON LINE 134
	      Swritten = "0"b;

001000  aa  6 00112 4501 00	stz  	pr6|74		Swritten
						STATEMENT 1 ON LINE 135
	      do while (^Swritten);

001001  aa   000000 0110 03	nop  	0,du
001002  aa  6 00112 2351 00	lda  	pr6|74		Swritten
001003  aa   000144 6010 04	tnz  	100,ic		001147
						STATEMENT 1 ON LINE 136
	        call rldr_output_$write_page (rldr_datap, pvindex,
		   pointer (rldr_data_.data_object_bp, object_pgx),
		   new_vtocep -> vtoce.fm (pgx), code);

001004  aa  6 00102 2361 00	ldq  	pr6|66		object_pgx
001005  aa  6 00032 3735 20	epp7 	pr6|26,*
001006  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001007  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001010  aa  5 00426 3521 20	epp2 	pr5|278,*		rldr_data_.data_object_bp
001011  aa   000000 3120 06	eawp2	0,ql
001012  aa  6 01550 2521 00	spri2	pr6|872
001013  aa  6 00103 2361 00	ldq  	pr6|67		pgx
001014  aa   000022 4020 07	mpy  	18,dl
001015  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001016  aa  6 01454 2521 00	spri2	pr6|812
001017  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
001020  aa  6 01456 2521 00	spri2	pr6|814
001021  aa  6 01550 3521 00	epp2 	pr6|872
001022  aa  6 01460 2521 00	spri2	pr6|816
001023  aa  6 00106 3535 20	epp3 	pr6|70,*		new_vtocep
001024  aa  3 00020 3521 00	epp2 	pr3|16		vtoce.fm
001025  aa  2 00000 5035 06	abd  	pr2|0,ql
001026  aa  6 01462 2521 00	spri2	pr6|818
001027  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001030  aa  6 01464 2521 00	spri2	pr6|820
001031  aa  6 01514 7561 00	stq  	pr6|844
001032  aa  6 01452 6211 00	eax1 	pr6|810
001033  aa   024000 4310 07	fld  	10240,dl
001034  aa  6 00044 3701 20	epp4 	pr6|36,*
001035  la  4 00026 3521 20	epp2 	pr4|22,*		rldr_output_$write_page
001036  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 139
	        if code ^= 0 then do;

001037  aa  6 00032 3735 20	epp7 	pr6|26,*
001040  aa  7 00004 2361 20	ldq  	pr7|4,*		code
001041  aa   000101 6000 04	tze  	65,ic		001142
						STATEMENT 1 ON LINE 140
		  call log_bad_addr (new_vtocep -> vtoce.fm (pgx));

001042  aa  6 01514 7271 00	lxl7 	pr6|844
001043  aa  6 00106 3715 20	epp5 	pr6|70,*		new_vtocep
001044  aa  5 00020 3521 00	epp2 	pr5|16		vtoce.fm
001045  aa  2 00000 5035 17	abd  	pr2|0,7
001046  aa  6 01454 2521 00	spri2	pr6|812
001047  aa  6 01452 3521 00	epp2 	pr6|810
001050  aa   004000 4310 07	fld  	2048,dl
001051  aa  2 00000 7571 00	staq 	pr2|0
001052  aa   000462 6700 04	tsp4 	306,ic		001534
						STATEMENT 1 ON LINE 141
		  call rldr_volume_map_$withdraw (rldr_datap,
		       pvindex, new_vtocep, pgx, code);

001053  aa  6 00032 3735 20	epp7 	pr6|26,*
001054  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001055  aa  6 01454 2521 00	spri2	pr6|812
001056  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
001057  aa  6 01456 2521 00	spri2	pr6|814
001060  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
001061  aa  6 01460 2521 00	spri2	pr6|816
001062  aa  6 00103 3521 00	epp2 	pr6|67		pgx
001063  aa  6 01462 2521 00	spri2	pr6|818
001064  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001065  aa  6 01464 2521 00	spri2	pr6|820
001066  aa  6 01452 6211 00	eax1 	pr6|810
001067  aa   024000 4310 07	fld  	10240,dl
001070  aa  6 00044 3701 20	epp4 	pr6|36,*
001071  la  4 00032 3521 20	epp2 	pr4|26,*		rldr_volume_map_$withdraw
001072  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 143
		  if code ^= 0 then do;

001073  aa  6 00032 3735 20	epp7 	pr6|26,*
001074  aa  7 00004 2361 20	ldq  	pr7|4,*		code
001075  aa   777705 6000 04	tze  	-59,ic		001002
						STATEMENT 1 ON LINE 144
		      call rldr_report_$error_output (rldr_datap, code, myname,
			 "Unable to withdraw for bad page on pv ^a", rldr_data_.pvname (pvindex));

001076  aa   776724 2360 04	ldq  	-556,ic		000022 = 524000000040
001077  aa  6 01514 7561 00	stq  	pr6|844
001100  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001101  aa   776777 00 0050	desc9a	-513,40		000077 = 125156141142
001102  aa  6 01452 00 0050	desc9a	pr6|810,40
001103  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
001104  aa   000064 4020 07	mpy  	52,dl
001105  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001106  aa  6 01520 2521 00	spri2	pr6|848
001107  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001110  aa  6 01522 2521 00	spri2	pr6|850
001111  aa   776667 3520 04	epp2 	-585,ic		000000 = 162145154157
001112  aa  6 01524 2521 00	spri2	pr6|852
001113  aa  6 01452 3521 00	epp2 	pr6|810
001114  aa  6 01526 2521 00	spri2	pr6|854
001115  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001116  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001117  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001120  aa  6 01530 2521 00	spri2	pr6|856
001121  aa   776706 3520 04	epp2 	-570,ic		000027 = 464000000000
001122  aa  6 01532 2521 00	spri2	pr6|858
001123  aa   776705 3520 04	epp2 	-571,ic		000030 = 404000000043
001124  aa  6 01534 2521 00	spri2	pr6|860
001125  aa   776701 3520 04	epp2 	-575,ic		000026 = 526000000040
001126  aa  6 01536 2521 00	spri2	pr6|862
001127  aa   776670 3520 04	epp2 	-584,ic		000017 = 524000000050
001130  aa  6 01540 2521 00	spri2	pr6|864
001131  aa  6 01514 3521 00	epp2 	pr6|844
001132  aa  6 01542 2521 00	spri2	pr6|866
001133  aa  6 01516 6211 00	eax1 	pr6|846
001134  aa   024000 4310 07	fld  	10240,dl
001135  aa  6 00044 3701 20	epp4 	pr6|36,*
001136  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001137  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 146
		      goto skip_this_pv;

001140  aa   000262 7100 04	tra  	178,ic		001422
						STATEMENT 1 ON LINE 147
		    end;

						STATEMENT 1 ON LINE 148
		end;

001141  aa   777641 7100 04	tra  	-95,ic		001002
						STATEMENT 1 ON LINE 149
	        else do;

						STATEMENT 1 ON LINE 150
		  Swritten = "1"b;

001142  aa   400000 2350 03	lda  	131072,du
001143  aa  6 00112 7551 00	sta  	pr6|74		Swritten
						STATEMENT 1 ON LINE 151
		  object_pgx = object_pgx + WORDS_PER_PAGE;

001144  aa   002000 2360 07	ldq  	1024,dl
001145  aa  6 00102 0561 00	asq  	pr6|66		object_pgx
						STATEMENT 1 ON LINE 152
		end;

						STATEMENT 1 ON LINE 153
	      end;

001146  aa   777634 7100 04	tra  	-100,ic		001002
						STATEMENT 1 ON LINE 154
	    end;

						STATEMENT 1 ON LINE 155
	end;

001147  aa  6 00103 0541 00	aos  	pr6|67		pgx
001150  aa   777612 7100 04	tra  	-118,ic		000762
						STATEMENT 1 ON LINE 157
	bad_pages = 0;

001151  aa  6 00101 4501 00	stz  	pr6|65		bad_pages
						STATEMENT 1 ON LINE 158
	do pgx = pgx to csl - 1;

001152  aa  6 00100 2361 00	ldq  	pr6|64		csl
001153  aa   000001 1760 07	sbq  	1,dl
001154  aa  6 01443 7561 00	stq  	pr6|803
001155  aa  6 00103 2361 00	ldq  	pr6|67		pgx
001156  aa  6 00103 7561 00	stq  	pr6|67		pgx
001157  aa   000000 0110 03	nop  	0,du
001160  aa  6 00103 2361 00	ldq  	pr6|67		pgx
001161  aa  6 01443 1161 00	cmpq 	pr6|803
001162  aa   000100 6054 04	tpnz 	64,ic		001262
						STATEMENT 1 ON LINE 159
	  call rldr_volume_map_$deposit (rldr_datap, pvindex,
	       new_vtocep, pgx, code);

001163  aa  6 00032 3735 20	epp7 	pr6|26,*
001164  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001165  aa  6 01454 2521 00	spri2	pr6|812
001166  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
001167  aa  6 01456 2521 00	spri2	pr6|814
001170  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
001171  aa  6 01460 2521 00	spri2	pr6|816
001172  aa  6 00103 3521 00	epp2 	pr6|67		pgx
001173  aa  6 01462 2521 00	spri2	pr6|818
001174  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001175  aa  6 01464 2521 00	spri2	pr6|820
001176  aa  6 01452 6211 00	eax1 	pr6|810
001177  aa   024000 4310 07	fld  	10240,dl
001200  aa  6 00044 3701 20	epp4 	pr6|36,*
001201  la  4 00030 3521 20	epp2 	pr4|24,*		rldr_volume_map_$deposit
001202  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 161
	  if code ^= 0 then
	    call rldr_report_$error_output (rldr_datap, code, myname, "Error depositing page ^d of vtoce ^o for pv ^a",
	         pgx, vtocx, rldr_data_.pvname (pvindex));

001203  aa  6 00032 3735 20	epp7 	pr6|26,*
001204  aa  7 00004 2361 20	ldq  	pr7|4,*		code
001205  aa   000052 6000 04	tze  	42,ic		001257
001206  aa   776614 2360 04	ldq  	-628,ic		000022 = 524000000040
001207  aa  6 01514 7561 00	stq  	pr6|844
001210  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001211  aa   776713 00 0060	desc9a	-565,48		000123 = 105162162157
001212  aa  6 01452 00 0060	desc9a	pr6|810,48
001213  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
001214  aa   000064 4020 07	mpy  	52,dl
001215  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001216  aa  6 01554 2521 00	spri2	pr6|876
001217  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001220  aa  6 01556 2521 00	spri2	pr6|878
001221  aa   776557 3520 04	epp2 	-657,ic		000000 = 162145154157
001222  aa  6 01560 2521 00	spri2	pr6|880
001223  aa  6 01452 3521 00	epp2 	pr6|810
001224  aa  6 01562 2521 00	spri2	pr6|882
001225  aa  6 00103 3521 00	epp2 	pr6|67		pgx
001226  aa  6 01564 2521 00	spri2	pr6|884
001227  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
001230  aa  6 01566 2521 00	spri2	pr6|886
001231  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001232  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001233  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001234  aa  6 01570 2521 00	spri2	pr6|888
001235  aa   776572 3520 04	epp2 	-646,ic		000027 = 464000000000
001236  aa  6 01572 2521 00	spri2	pr6|890
001237  aa   776571 3520 04	epp2 	-647,ic		000030 = 404000000043
001240  aa  6 01574 2521 00	spri2	pr6|892
001241  aa   776565 3520 04	epp2 	-651,ic		000026 = 526000000040
001242  aa  6 01576 2521 00	spri2	pr6|894
001243  aa   776553 3520 04	epp2 	-661,ic		000016 = 524000000056
001244  aa  6 01600 2521 00	spri2	pr6|896
001245  aa   776556 3520 04	epp2 	-658,ic		000023 = 404000000021
001246  aa  6 01602 2521 00	spri2	pr6|898
001247  aa  6 01604 2521 00	spri2	pr6|900
001250  aa  6 01514 3521 00	epp2 	pr6|844
001251  aa  6 01606 2521 00	spri2	pr6|902
001252  aa  6 01552 6211 00	eax1 	pr6|874
001253  aa   034000 4310 07	fld  	14336,dl
001254  aa  6 00044 3701 20	epp4 	pr6|36,*
001255  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 164
	  bad_pages = bad_pages + 1;

001257  aa  6 00101 0541 00	aos  	pr6|65		bad_pages
						STATEMENT 1 ON LINE 165
	end;

001260  aa  6 00103 0541 00	aos  	pr6|67		pgx
001261  aa   777677 7100 04	tra  	-65,ic		001160
						STATEMENT 1 ON LINE 167
	if new_vtocep -> vtoce.damaged then do;

001262  aa  6 00106 3735 20	epp7 	pr6|70,*		new_vtocep
001263  aa  7 00005 2351 00	lda  	pr7|5		vtoce.damaged
001264  aa   004000 3150 03	cana 	2048,du
001265  aa   000116 6000 04	tze  	78,ic		001403
						STATEMENT 1 ON LINE 168
	    new_vtocep -> vtoce.csl = bit (fixed (csl - bad_pages, 9), 9);

001266  aa  6 00100 2361 00	ldq  	pr6|64		csl
001267  aa  6 00101 1761 00	sbq  	pr6|65		bad_pages
001270  aa   000003 6050 04	tpl  	3,ic		001273
001271  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
001272  aa   000001 0760 07	adq  	1,dl
001273  aa   000077 7370 00	lls  	63
001274  aa   000011 7730 00	lrl  	9
001275  aa  7 00002 5511 20	stba 	pr7|2,20		vtoce.csl
						STATEMENT 1 ON LINE 169
	    new_vtocep -> vtoce.records = bit (fixed (fixed (new_vtocep -> vtoce.records) - bad_pages, 9), 9);

001276  aa  7 00002 2351 00	lda  	pr7|2		vtoce.records
001277  aa   000022 7350 00	als  	18
001300  aa   000077 7730 00	lrl  	63
001301  aa   000000 5330 00	negl 	0
001302  aa  6 00101 0331 00	adl  	pr6|65		bad_pages
001303  aa   000000 5330 00	negl 	0
001304  aa   000003 6050 04	tpl  	3,ic		001307
001305  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
001306  aa   000001 0760 07	adq  	1,dl
001307  aa   000077 7370 00	lls  	63
001310  aa   000022 7730 00	lrl  	18
001311  aa  7 00002 5511 10	stba 	pr7|2,10		vtoce.records
						STATEMENT 1 ON LINE 170
	    call rldr_vtoc_buffer_$put (rldr_datap, pvindex, new_vtocep,
	         vtocx, code);

001312  aa  6 00032 3715 20	epp5 	pr6|26,*
001313  aa  5 00002 3521 20	epp2 	pr5|2,*		rldr_datap
001314  aa  6 01454 2521 00	spri2	pr6|812
001315  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
001316  aa  6 01456 2521 00	spri2	pr6|814
001317  aa  6 00106 3521 00	epp2 	pr6|70		new_vtocep
001320  aa  6 01460 2521 00	spri2	pr6|816
001321  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
001322  aa  6 01462 2521 00	spri2	pr6|818
001323  aa  5 00004 3521 20	epp2 	pr5|4,*		code
001324  aa  6 01464 2521 00	spri2	pr6|820
001325  aa  6 01452 6211 00	eax1 	pr6|810
001326  aa   024000 4310 07	fld  	10240,dl
001327  aa  6 00044 3701 20	epp4 	pr6|36,*
001330  la  4 00024 3521 20	epp2 	pr4|20,*		rldr_vtoc_buffer_$put
001331  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 172
	    if code ^= 0 then
	      call rldr_report_$error_output (rldr_datap, code, myname,
		 "Unable to set damaged switch for vtoce ^o on pv ^a", vtocx, rldr_data_.pvname (pvindex));

001332  aa  6 00032 3735 20	epp7 	pr6|26,*
001333  aa  7 00004 2361 20	ldq  	pr7|4,*		code
001334  aa   000047 6000 04	tze  	39,ic		001403
001335  aa   776465 2360 04	ldq  	-715,ic		000022 = 524000000040
001336  aa  6 01514 7561 00	stq  	pr6|844
001337  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001340  aa   776614 00 0064	desc9a	-628,52		000153 = 125156141142
001341  aa  6 01452 00 0064	desc9a	pr6|810,52
001342  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
001343  aa   000064 4020 07	mpy  	52,dl
001344  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001345  aa  6 01520 2521 00	spri2	pr6|848
001346  aa  7 00004 3521 20	epp2 	pr7|4,*		code
001347  aa  6 01522 2521 00	spri2	pr6|850
001350  aa   776430 3520 04	epp2 	-744,ic		000000 = 162145154157
001351  aa  6 01524 2521 00	spri2	pr6|852
001352  aa  6 01452 3521 00	epp2 	pr6|810
001353  aa  6 01526 2521 00	spri2	pr6|854
001354  aa  6 00105 3521 00	epp2 	pr6|69		vtocx
001355  aa  6 01530 2521 00	spri2	pr6|856
001356  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001357  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001360  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001361  aa  6 01532 2521 00	spri2	pr6|858
001362  aa   776445 3520 04	epp2 	-731,ic		000027 = 464000000000
001363  aa  6 01534 2521 00	spri2	pr6|860
001364  aa   776444 3520 04	epp2 	-732,ic		000030 = 404000000043
001365  aa  6 01536 2521 00	spri2	pr6|862
001366  aa   776440 3520 04	epp2 	-736,ic		000026 = 526000000040
001367  aa  6 01540 2521 00	spri2	pr6|864
001370  aa   776425 3520 04	epp2 	-747,ic		000015 = 524000000062
001371  aa  6 01542 2521 00	spri2	pr6|866
001372  aa   776431 3520 04	epp2 	-743,ic		000023 = 404000000021
001373  aa  6 01544 2521 00	spri2	pr6|868
001374  aa  6 01514 3521 00	epp2 	pr6|844
001375  aa  6 01546 2521 00	spri2	pr6|870
001376  aa  6 01516 6211 00	eax1 	pr6|846
001377  aa   030000 4310 07	fld  	12288,dl
001400  aa  6 00044 3701 20	epp4 	pr6|36,*
001401  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001402  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 175
	  end;

						STATEMENT 1 ON LINE 176
        end;

						STATEMENT 1 ON LINE 179
      if ^already_there then call rldr_input_$collect_stats (rldr_datap, pvindex);

001403  aa  6 00113 2351 00	lda  	pr6|75		already_there
001404  aa   400000 3150 03	cana 	131072,du
001405  aa   776627 6010 04	tnz  	-617,ic		000234
001406  aa  6 00032 3735 20	epp7 	pr6|26,*
001407  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001410  aa  6 01454 2521 00	spri2	pr6|812
001411  aa  6 00104 3521 00	epp2 	pr6|68		pvindex
001412  aa  6 01456 2521 00	spri2	pr6|814
001413  aa  6 01452 6211 00	eax1 	pr6|810
001414  aa   010000 4310 07	fld  	4096,dl
001415  aa  6 00044 3701 20	epp4 	pr6|36,*
001416  la  4 00012 3521 20	epp2 	pr4|10,*		rldr_input_$collect_stats
001417  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 180
    end;

001420  aa   776614 7100 04	tra  	-628,ic		000234
						STATEMENT 1 ON LINE 182
    return;

001421  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 183
skip_this_pv:
    call rldr_report_$error_output (rldr_datap, 0, myname,	/* well, let the user know			*/
         "Abandoning the reload of pv ^a", rldr_data_.pvname (pvindex));

001422  aa   776400 2360 04	ldq  	-768,ic		000022 = 524000000040
001423  aa  6 01514 7561 00	stq  	pr6|844
001424  aa  6 01515 4501 00	stz  	pr6|845
001425  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001426  aa   776420 00 0040	desc9a	-752,32		000045 = 101142141156
001427  aa  6 01452 00 0040	desc9a	pr6|810,32
001430  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
001431  aa   000064 4020 07	mpy  	52,dl
001432  aa  6 00032 3735 20	epp7 	pr6|26,*
001433  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001434  aa  6 01520 2521 00	spri2	pr6|848
001435  aa  6 01515 3521 00	epp2 	pr6|845
001436  aa  6 01522 2521 00	spri2	pr6|850
001437  aa   776341 3520 04	epp2 	-799,ic		000000 = 162145154157
001440  aa  6 01524 2521 00	spri2	pr6|852
001441  aa  6 01452 3521 00	epp2 	pr6|810
001442  aa  6 01526 2521 00	spri2	pr6|854
001443  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001444  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001445  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001446  aa  6 01530 2521 00	spri2	pr6|856
001447  aa   776360 3520 04	epp2 	-784,ic		000027 = 464000000000
001450  aa  6 01532 2521 00	spri2	pr6|858
001451  aa   776343 3520 04	epp2 	-797,ic		000014 = 404000000005
001452  aa  6 01534 2521 00	spri2	pr6|860
001453  aa   776353 3520 04	epp2 	-789,ic		000026 = 526000000040
001454  aa  6 01536 2521 00	spri2	pr6|862
001455  aa   776336 3520 04	epp2 	-802,ic		000013 = 524000000036
001456  aa  6 01540 2521 00	spri2	pr6|864
001457  aa  6 01514 3521 00	epp2 	pr6|844
001460  aa  6 01542 2521 00	spri2	pr6|866
001461  aa  6 01610 7561 00	stq  	pr6|904
001462  aa  6 01516 6211 00	eax1 	pr6|846
001463  aa   024000 4310 07	fld  	10240,dl
001464  aa  6 00044 3701 20	epp4 	pr6|36,*
001465  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001466  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 186
    rldr_data_.abandoned (pvindex) = "1"b;

001467  aa   400000 2350 03	lda  	131072,du
001470  aa  6 00032 3735 20	epp7 	pr6|26,*
001471  aa  6 01610 7271 00	lxl7 	pr6|904
001472  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001473  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001474  aa  5 00350 2551 17	orsa 	pr5|232,7		rldr_data_.abandoned
						STATEMENT 1 ON LINE 187
    rldr_data_.num_abandoned = rldr_data_.num_abandoned + 1;

001475  aa  5 00402 0541 00	aos  	pr5|258		rldr_data_.num_abandoned
						STATEMENT 1 ON LINE 188
    if rldr_data_.num_abandoned = rldr_data_.npvs then do;

001476  aa  5 00402 2361 00	ldq  	pr5|258		rldr_data_.num_abandoned
001477  aa  5 00404 1161 00	cmpq 	pr5|260		rldr_data_.npvs
001500  aa   776534 6010 04	tnz  	-676,ic		000234
						STATEMENT 1 ON LINE 189
        call rldr_report_$error_output (rldr_datap, 0, myname,
	   "All physical volumes to be reloaded have been abandoned.");

001501  aa  6 01610 4501 00	stz  	pr6|904
001502  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001503  aa   776466 00 0070	desc9a	-714,56		000170 = 101154154040
001504  aa  6 01452 00 0070	desc9a	pr6|810,56
001505  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001506  aa  6 01474 2521 00	spri2	pr6|828
001507  aa  6 01610 3521 00	epp2 	pr6|904
001510  aa  6 01476 2521 00	spri2	pr6|830
001511  aa   776267 3520 04	epp2 	-841,ic		000000 = 162145154157
001512  aa  6 01500 2521 00	spri2	pr6|832
001513  aa  6 01452 3521 00	epp2 	pr6|810
001514  aa  6 01502 2521 00	spri2	pr6|834
001515  aa   776312 3520 04	epp2 	-822,ic		000027 = 464000000000
001516  aa  6 01504 2521 00	spri2	pr6|836
001517  aa   776275 3520 04	epp2 	-835,ic		000014 = 404000000005
001520  aa  6 01506 2521 00	spri2	pr6|838
001521  aa   776305 3520 04	epp2 	-827,ic		000026 = 526000000040
001522  aa  6 01510 2521 00	spri2	pr6|840
001523  aa   776267 3520 04	epp2 	-841,ic		000012 = 524000000070
001524  aa  6 01512 2521 00	spri2	pr6|842
001525  aa  6 01472 6211 00	eax1 	pr6|826
001526  aa   020000 4310 07	fld  	8192,dl
001527  aa  6 00044 3701 20	epp4 	pr6|36,*
001530  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001531  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 191
        return;

001532  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 192
      end;

						STATEMENT 1 ON LINE 194
    goto restart;

001533  aa   776501 7100 04	tra  	-703,ic		000234
						STATEMENT 1 ON LINE 367
  end reload_volume_;

BEGIN PROCEDURE log_bad_addr
ENTRY TO log_bad_addr                                       STATEMENT 1 ON LINE 199
log_bad_addr: proc (add);

001534  aa  6 01444 6501 00	spri4	pr6|804
001535  aa  6 01446 2521 00	spri2	pr6|806
						STATEMENT 1 ON LINE 206
    call rldr_report_$error_output (rldr_datap, 0, myname, "Bad disk page ^o for pv ^a", add, rldr_data_.pvname (pvindex));

001536  aa   776264 2360 04	ldq  	-844,ic		000022 = 524000000040
001537  aa  6 01611 7561 00	stq  	pr6|905
001540  aa  6 01612 4501 00	stz  	pr6|906
001541  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001542  aa   776275 00 0034	desc9a	-835,28		000036 = 102141144040
001543  aa  6 01614 00 0034	desc9a	pr6|908,28
001544  aa  6 00104 2361 00	ldq  	pr6|68		pvindex
001545  aa   000064 4020 07	mpy  	52,dl
001546  aa  6 00032 3735 20	epp7 	pr6|26,*
001547  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001550  aa  6 01626 2521 00	spri2	pr6|918
001551  aa  6 01612 3521 00	epp2 	pr6|906
001552  aa  6 01630 2521 00	spri2	pr6|920
001553  aa   776225 3520 04	epp2 	-875,ic		000000 = 162145154157
001554  aa  6 01632 2521 00	spri2	pr6|922
001555  aa  6 01614 3521 00	epp2 	pr6|908
001556  aa  6 01634 2521 00	spri2	pr6|924
001557  aa  6 01446 3715 20	epp5 	pr6|806,*
001560  aa  5 00002 3521 20	epp2 	pr5|2,*		add
001561  aa  6 01636 2521 00	spri2	pr6|926
001562  aa  7 00002 3535 20	epp3 	pr7|2,*		rldr_datap
001563  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
001564  aa  3 00353 3521 06	epp2 	pr3|235,ql	rldr_data_.pvname
001565  aa  6 01640 2521 00	spri2	pr6|928
001566  aa   776241 3520 04	epp2 	-863,ic		000027 = 464000000000
001567  aa  6 01642 2521 00	spri2	pr6|930
001570  aa   776224 3520 04	epp2 	-876,ic		000014 = 404000000005
001571  aa  6 01644 2521 00	spri2	pr6|932
001572  aa   776234 3520 04	epp2 	-868,ic		000026 = 526000000040
001573  aa  6 01646 2521 00	spri2	pr6|934
001574  aa   776214 3520 04	epp2 	-884,ic		000010 = 524000000032
001575  aa  6 01650 2521 00	spri2	pr6|936
001576  aa   776213 3520 04	epp2 	-885,ic		000011 = 516000000022
001577  aa  6 01652 2521 00	spri2	pr6|938
001600  aa  6 01611 3521 00	epp2 	pr6|905
001601  aa  6 01654 2521 00	spri2	pr6|940
001602  aa  6 01624 6211 00	eax1 	pr6|916
001603  aa   030000 4310 07	fld  	12288,dl
001604  aa  6 00044 3701 20	epp4 	pr6|36,*
001605  la  4 00020 3521 20	epp2 	pr4|16,*		rldr_report_$error_output
001606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 207
    return;

001607  aa  6 01444 6101 00	rtcd 	pr6|804
						STATEMENT 1 ON LINE 208
  end log_bad_addr;

  END PROCEDURE log_bad_addr
  END PROCEDURE reload_volume_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
