	COMPILATION LISTING OF SEGMENT make_segs_paged
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0950.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style2 */
       14 
       15 make_segs_paged:
       16      proc;
       17 
       18 
       19 /* 	last modified (date, by whom and reason):
       20*
       21*    1/85 by Keith Loepere to recognize segments already paged.
       22*   12/83 by Keith Loepere for breakpoint page support 
       23*   9/83 by Keith Loepere to tolerate paged, wired segments
       24*   7/82 BIM -- use stack_frame patch to remove need for special
       25*   pmut swap/copy entry; rationalize names, slte_uns, flush gtpd.
       26*   6/21/82 by E. N. Kittlitz to move core map.
       27*   12/21/80 by W. Olin Sibert, to move setting of sst.write_limit into
       28*      init_pvt, move high water mark announcement into (new) announce_chwm,
       29*      and move call to collect_free_core into init_collection_1.
       30*    8/24/79 by J. A. Bush to set the max length of the sstnt in the slte
       31*      based on the number of aste entries
       32*    2/19/79 by D. Spector to set sst. write_limit when done
       33*
       34*    8/02/77 by Greenberg for pc_wired-calling.
       35*    4/22/77 by B. Greenberg to stop special-casing prds, when it became
       36*      deciduous.
       37*    2/06/76 by S. Webber for new reconfiguration
       38*
       39*   12/08/75 by Bernard Greenberg for pre-withdraw system wherein nothing
       40*      gets truncated at shutdown time, for all is withdrawn against the
       41*      hardcore partition.
       42*    9/04/75 by Greenberg to gtpd sst_names_.
       43*    4/16/75 by BSG for AST name table, in New Storage System.
       44*    2/10/75 by Andre Bensoussan for New Storage System.
       45*
       46*   10/08/74 by B. Greenberg for SST name table.
       47*    7/18/74 by Mike Grady to rename this make_segs_paged from update_sst_pl1
       48*      and move wiring code to make_sdw to remove aste.iw bit and allow
       49*      certain collection 2 wired segs to be unthreaded.
       50*    4/09/74 by S.Webber to wire down only first part of bound_sss_wired_
       51*    3/19/74 by Bernard Greenberg for collect_free_core mechanism
       52*
       53*   11/01/73 by RE Mullen: to v2pl1
       54*    6/27/72 by Craig Jensen: to convert this code for the follow-on 645.
       55*    4/06/72 by clj: to free up pages immediately after they are no longer
       56*      needed; rather than waiting until the end of update_sst_pl1; this
       57*      avoided some memory overflows which were occurring during the
       58*      execution of the aste_create loop.
       59*   */
       60 
       61 	dcl     tsdw		 fixed bin (71);
       62 	dcl     page_size		 fixed bin (18);
       63 
       64 	dcl     sstnt_no		 fixed bin;
       65 	dcl     dseg_no		 fixed bin;
       66 
       67 	dcl     new_dbr		 fixed bin (71);
       68 	dcl     new_seg_sdw		 fixed bin (71);
       69 
       70 	dcl     abs_seg_ptr		 ptr;
       71 	dcl     seg_ptr		 ptr;
       72 
       73 	dcl     1 sorted_segs	 (0:300) aligned automatic,
       74 						/* Array of seg. nos. sorted by their abs. mem. addr. */
       75 		2 segnum		 fixed bin,
       76 		2 add		 fixed bin (26);
       77 
       78 	dcl     k			 fixed bin;
       79 	dcl     idx		 fixed bin;
       80 	dcl     segnum		 fixed bin;
       81 
       82 	dcl     current_address	 fixed bin (26) aligned;
       83 						/* Addr. of first word of current seg. */
       84 	dcl     current_page	 fixed bin;	/* Page no. in which first word of current seg. resides. */
       85 	dcl     high_page_to_free	 fixed bin;	/* Page no. of highest page in mem. yet to be freed. */
       86 	dcl     seg_size		 fixed bin (19);	/* Size in words of current seg. */
       87 	dcl     nsegs		 fixed bin;	/* No. of entries in the array; sorted_seg_nos. */
       88 	dcl     new_address		 fixed bin (26) aligned;
       89 						/* New value to be assigned to curloc. */
       90 
       91 	dcl     dseg$		 (0:1023) fixed bin (71) external static;
       92 						/* initializer's dseg */
       93 	dcl     ds_seg$		 (0:1023) fixed bin (71) external static;
       94 						/* new dseg being created for initializer */
       95 	dcl     abs_seg$		 ext;		/* window seg through which copies are made */
       96 	dcl     slt$		 ext;
       97 
       98 	dcl     1 sst$level		 (0:3) aligned external,
       99 		2 ausedp		 bit (18) unaligned,
      100 		2 no_aste		 fixed bin (18) uns unal;
      101 
      102 	dcl     sys_info$page_size	 fixed bin ext;
      103 	dcl     pds$dstep		 bit (18) aligned ext;
      104 	dcl     unpaged_page_tables$	 aligned ext;
      105 
      106 	dcl     absadr		 entry (ptr, fixed bin (35)) returns (fixed bin (26));
      107 	dcl     freecore		 entry (fixed bin);
      108 	dcl     get_ptrs_$given_astep	 entry (ptr) returns (fixed bin (71));
      109 	dcl     make_sdw		 entry (fixed bin, fixed bin (71), ptr, ptr);
      110 	dcl     make_sdw$unthreaded	 entry (fixed bin, fixed bin (71), ptr, ptr);
      111 	dcl     pc_wired$write	 entry (ptr, fixed bin, fixed bin);
      112 	dcl     pmut$swap_sdw	 entry (ptr, ptr);
      113 	dcl     pmut$ldbr		 entry (fixed bin (71));
      114 	dcl     sdw_util_$get_size	 entry (pointer, fixed bin (19));
      115 	dcl     sdw_util_$get_address	 entry (pointer, fixed bin (26));
      116 	dcl     sdw_util_$set_access	 entry (pointer, bit (4) unaligned);
      117 	dcl     syserr		 entry options (variable);
      118 	dcl     thread$out		 entry (ptr, bit (18));
      119 
      120 	dcl     (addr, baseno, baseptr, bin, bit, currentsize, divide, max, null, ptr, rel, segno, string, sum, unspec)
      121 				 builtin;
      122 
      123 	upt_ptr = addr (unpaged_page_tables$);
      124 	abs_seg_ptr = addr (abs_seg$);
      125 	sltp = addr (slt$);				/* Get a pointer to the SLT */
      126 	sstnp = addr (sst_names_$);
      127 	sstnt_no = bin (baseno (sstnp), 18);
      128 	dseg_no = bin (baseno (addr (dseg$)), 18);
      129 	page_size = sys_info$page_size;		/* Copy Page Size to Stack. */
      130 
      131 /* Get an ASTE for the initializer's dseg, fill in values */
      132 
      133 	call make_sdw$unthreaded (dseg_no, tsdw, astep, (null ()));
      134 	pds$dstep = rel (astep);			/* Set rel pointer to chain of dseg's */
      135 
      136 	call pmut$swap_sdw (addr (ds_seg$), addr (tsdw));
      137 
      138 	ds_seg$ (dseg_no) = tsdw;			/* fill in SDW for dseg in new dseg being built */
      139 	new_dbr = tsdw;				/* save descriptor segment base register */
      140 
      141 	sltep = addr (slt.seg (sstnt_no));		/* get ptr to slte for sstnt */
      142 	sstnt.nentries = sum (sst$level.no_aste);	/* get total number of astes */
      143 	slte_uns.max_length = divide (currentsize (sstnt) + (page_size - 1), page_size, 9, 0);
      144 						/* set the max length (in pages) */
      145 
      146 
      147 /* Create an array which lists the segment nos. of the pageable segments; these segment nos. are
      148*   sorted by the addresses of these segments. */
      149 
      150 	nsegs = 0;				/* Init. no. segs. in this array. */
      151 	do segnum = slt.first_sup_seg to slt.last_sup_seg, slt.first_init_seg to slt.last_init_seg;
      152 	     sltep = addr (slt.seg (segnum));		/* get pointer to this seg's SLTE */
      153 	     if (^slte.paged) | slte.abs_seg | slte.layout_seg
      154 	     then do;				/* copy SDW directly if funny segment */
      155 		     ds_seg$ (segnum) = dseg$ (segnum);
      156 		     goto CHECK_NEXT_SEGMENT;
      157 		end;
      158 
      159 	     if dseg$ (segnum) = 0
      160 	     then new_address = 0;			/* null seg */
      161 	     else do;
      162 		     call sdw_util_$get_address (addr (dseg$ (segnum)), new_address);
      163 		     if new_address >= upt.sst_absloc & new_address <= upt.sst_last_loc
      164 		     then do;			/* already paged */
      165 			     ds_seg$ (segnum) = dseg$ (segnum);
      166 			     goto CHECK_NEXT_SEGMENT;
      167 			end;
      168 		     new_address = absadr (baseptr (segnum), (0));
      169 						/* real mem address */
      170 		end;
      171 
      172 	     nsegs = nsegs + 1;			/* Increm. no. segs. in array being built. */
      173 	     if nsegs > hbound (sorted_segs, 1)
      174 	     then /* Did array overflow? */
      175 		call syserr (CRASH, "make_segs_paged: sorted_segs array overflowed.");
      176 
      177 	     sorted_segs (nsegs).segnum = segnum;	/* Remember segnum and address in the array */
      178 	     sorted_segs (nsegs).add = new_address;
      179 
      180 	     do idx = nsegs to 1 by -1;		/* Scan the sorted array for the proper slot for "segnum". */
      181 		if new_address > sorted_segs (idx).add
      182 		then /* is the idx'th slot the right one? */
      183 		     goto SLOT_FOUND;		/* Yes, exit from this loop. */
      184 		sorted_segs (idx) = sorted_segs (idx - 1);
      185 						/* Otherwise, bubble up */
      186 	     end;
      187 
      188 	     idx = 0;				/* If the loop falls out, first slot is the one sought. */
      189 
      190 SLOT_FOUND:
      191 	     sorted_segs (idx + 1).segnum = segnum;	/* Add the new segment in the right place. */
      192 	     sorted_segs (idx + 1).add = new_address;
      193 
      194 CHECK_NEXT_SEGMENT:
      195 	end;					/* End of loop sorting segment addresses */
      196 
      197 
      198 /* Make each of the pageable segments pageable by moving them to the pageable region in memory. */
      199 
      200 	high_page_to_free = -1;			/* Indicate that this variable has to be initialized. */
      201 LOOP_DOWN_SEGS:
      202 	do idx = nsegs to 1 by -1;			/* Process the segment with the highest addr. next */
      203 						/* so that region of memory can be freed without having */
      204 						/* to be concerned if following portions of the last page */
      205 						/* of the segment are still in use. */
      206 	     segnum = sorted_segs (idx).segnum;		/* Get the seg. no. of highest seg. not yet freed. */
      207 	     sltep = addr (slt.seg (segnum));		/* get pointer to this seg's SLTE */
      208 	     seg_ptr = baseptr (segnum);		/* Get ptr. to seg. to be copied. */
      209 
      210 	     if segnum = dseg_no
      211 	     then goto SKIP;
      212 
      213 	     call make_sdw (segnum, tsdw, astep, (null ()));
      214 						/* Get the AST entry and the SDW */
      215 	     if astep = null ()
      216 	     then goto SKIP;			/* Don't attempt to allocate abs segs. */
      217 
      218 /* Now move the i'th segment */
      219 
      220 	     ds_seg$ (segnum) = tsdw;			/* fill in new SDW into new dseg */
      221 	     if dseg$ (segnum) = 0
      222 	     then do;				/* no prev segment (so don't free) */
      223 		     call pmut$swap_sdw (seg_ptr, addr (tsdw));
      224 						/* but new sdw (from make_sdw) good - clean up new seg */
      225 		     call pc_wired$write (astep, 0, -1);
      226 		     go to SKIP;
      227 		end;
      228 
      229 
      230 /* Having put the right thing into the new dseg, one might think that */
      231 /* a copy of the contents is all that is needed. However, it is also */
      232 /* neccessary to swap the old dseg (that is still in use) over to the */
      233 /* paged copy, so that the storage can be freed. */
      234 
      235 	     new_address = absadr (baseptr (segnum), (0));/* Get addr. of first word in original seg */
      236 	     call sdw_util_$get_size (addr (dseg$ (segnum)), seg_size);
      237 						/* Get size of seg. (in words). */
      238 
      239 	     new_seg_sdw = tsdw;			/* save it with correct access */
      240 	     call sdw_util_$set_access (addr (tsdw), "1010"b);
      241 						/* Make the abs-seg RW */
      242 	     call pmut$swap_sdw (addr (abs_seg$), addr (tsdw));
      243 
      244 	     if slte_uns.breakpointable
      245 	     then begin;
      246 		     declare (from_bkpt_page_ptr, to_bkpt_page_ptr)
      247 					      ptr;
      248 		     declare (from_breakpoint_ptr, to_breakpoint_ptr)
      249 					      ptr;
      250 		     declare bkpt_num	      fixed bin;
      251 
      252 		     seg_size = seg_size - 1024;	/* handle bkpt page separately */
      253 
      254 /* We must copy over breakpoints set in this seg.
      255*For wired segs this will overwrite the breakpoints with themselves in
      256*breakpoint_page$, but this won't hurt. */
      257 
      258 		     from_bkpt_page_ptr = addrel (seg_ptr, seg_size);
      259 		     to_bkpt_page_ptr = addrel (abs_seg_ptr, seg_size);
      260 		     do bkpt_num = 1 to dimension (from_bkpt_page_ptr -> bkpt_page.bkpts, 1);
      261 			from_breakpoint_ptr = addr (from_bkpt_page_ptr -> bkpt_page.bkpts (bkpt_num));
      262 			to_breakpoint_ptr = addr (to_bkpt_page_ptr -> bkpt_page.bkpts (bkpt_num));
      263 			if segno (from_breakpoint_ptr -> breakpoint.original_instr_ptr) = segnum
      264 			then to_breakpoint_ptr -> breakpoint = from_breakpoint_ptr -> breakpoint;
      265 		     end;
      266 		end;
      267 
      268 /* When we process our own stack, the return address for pmut$swap_sdw */
      269 /* would land in the old copy only. So it is filled in by hand here, */
      270 /* which is just overwritten for all other segs. */
      271 
      272 	     stackframeptr () -> stack_frame.return_ptr = codeptr (PMUT_RETURN_HERE);
      273 	     begin;
      274 		declare from		 (seg_size) bit (36) aligned based (seg_ptr);
      275 		declare to		 (seg_size) bit (36) aligned based (abs_seg_ptr);
      276 		to = from;
      277 	     end;
      278 	     call pmut$swap_sdw (seg_ptr, addr (new_seg_sdw));
      279 PMUT_RETURN_HERE:
      280 	     call pc_wired$write (astep, 0, -1);	/* Get it out to disk */
      281 
      282 /* Free the pages of the old ith seg. */
      283 
      284 	     current_address = new_address;		/* Get addr. of first word in seg. i. */
      285 	     current_page = divide (current_address + page_size - 1, page_size, 12, 0);
      286 						/* Get page no. of page into which
      287*						   current_address points. */
      288 	     high_page_to_free = divide (current_address + seg_size - 1, page_size, 12, 0);
      289 						/* No, get the highest page no. */
      290 	     do k = current_page to high_page_to_free;	/* Loop to free all pages now available. */
      291 		call freecore (k);			/* Free a page. */
      292 	     end;
      293 SKIP:
      294 	end LOOP_DOWN_SEGS;
      295 
      296 /* Now switch over to the new descriptor segment */
      297 
      298 	call pmut$ldbr (new_dbr);			/* switch to the new paged dseg */
      299 	addr (flagbox$) -> fgbx.hc_dbr = unspec (new_dbr);
      300 
      301 	tsdw = 0;
      302 	call pmut$swap_sdw (addr (abs_seg$), addr (tsdw));/* cleanup */
      303 
      304 	sstnt.names = "";				/* touch all the names, initialize them, and withdraw the pages */
      305 
      306 	return;
      307 
      308 
      309 /* format: off */
      310  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      310 
      311  /* BEGIN include file bce_breakpoint_page.incl.pl1 */
  2     2 
  2     3 /* Description of hardcore breakpoint information saved in breakpoint_page.
  2     4*Keith Loepere, December 1983. */
  2     5 /* Sentinel added, July 1984 by Keith Loepere. */
  2     6 
  2     7 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  2     8 
  2     9 dcl  1 bkpt_page		        aligned based (bkpt_page_ptr),
  2    10        2 header		        aligned,
  2    11          3 mc_		        aligned like mc,
  2    12          3 mode_reg		        bit (36) aligned,
  2    13          3 cache_mode_reg	        bit (36) aligned,
  2    14          3 dbr		        bit (72) aligned,
  2    15          3 bar		        bit (36) aligned,
  2    16          3 sentinel		        char (4) unal,
  2    17          3 pad		        (10) bit (36),
  2    18        2 bkpts		        (120) aligned like breakpoint;
  2    19 dcl  bkpt_page_ptr		        ptr;
  2    20 
  2    21 dcl  1 breakpoint		        aligned based (breakpoint_ptr),
  2    22        2 breakpoint_drl	        bit (36),		/* drl -1 => breakpoint */
  2    23        2 instructions	        (4) bit (36),
  2    24        2 tra_back_offset	        fixed bin (18) unal uns,
  2    25        2 tra_back		        bit (18) unal,	/* tra back to original code */
  2    26        2 original_instr_ptr	        ptr unal,		/* ptr to where original instruction was */
  2    27        2 original_instr	        bit (36);		/* real instruction moved */
  2    28 dcl  breakpoint_ptr		        ptr;
  2    29 
  2    30 dcl  BKPT_page_sentinel	        char (4) static options (constant) init ("bkpt");
  2    31 
  2    32 /* END include file bce_breakpoint_page.incl.pl1 */
      311 
      312  /* BEGIN INCLUDE FILE ... flagbox.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(87-02-26,Farley), approve(87-04-15,MCR7661),
  3     6*     audit(87-04-21,Fawcett), install(87-04-28,MR12.1-1028):
  3     7*     Added io_reconfig flag to inhibit BCE from attempting an emergency
  3     8*     shutdown when the data in memory could be corrupted.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /* last modified 5/3/77 by Noel I. Morris	*/
  3    13 /* Modified 8/79 by R.J.C. Kissel to add FNP blast message. */
  3    14 /* Modified 7/82 BIM for recognizable sentinel field */
  3    15 /* Modified for bootload Multics flagbox starting in 8/83 by Keith Loepere. */
  3    16 
  3    17 /* The contents of this segment are data shared by Multics and bce.
  3    18*   This entity occupies the locations within the toehold starting at 40o
  3    19*   (not counting the toehold_used spacer at the beginning). */
  3    20 
  3    21 dcl  flagbox$ ext;
  3    22 dcl  fgbxp ptr;
  3    23 
  3    24 dcl 1 fgbx based (fgbxp) aligned,
  3    25     2 toehold_used (32) bit (36) aligned,		/* flagbox seg now mapped onto all of first page of toehold -
  3    26*						This is what was unused before. */
  3    27     2 flags (36) bit (1) unal,			/* communications switches */
  3    28     2 slt_segno bit (18),				/* segment # of the SLT */
  3    29     2 pad1 fixed bin,
  3    30     2 rtb,					/* return to bce info */
  3    31      (3 ssenb bit (1),				/* "1"b if storage system enabled */
  3    32       3 call_bce bit (1),				/* "1"b if bce called by operator */
  3    33       3 shut bit (1),				/* "1"b if bce called after shutdown */
  3    34       3 mess bit (1),				/* "1"b if message has been provided */
  3    35       3 alert bit (1),				/* "1"b if audible alarm to be sounded */
  3    36       3 breakpoint bit (1),				/* "1"b is breakpoint caused call to bce */
  3    37       3 manual_crash bit (1),				/* either manual entry or execute fault */
  3    38       3 io_reconfig bit (1),				/* "1"b if I/O reconfiguration */
  3    39 						/* could cause memory corruption */
  3    40       3 pad bit (21),
  3    41       3 bce_entry fixed bin (6) uns) unal,		/* type of entry into bce
  3    42*						   00o => Multics entry
  3    43*						   20o => manual entry
  3    44*						   40o => esd entry */
  3    45     2 sentinel char (32) aligned,			/* set by bce (for now) */
  3    46     2 sst_sdw bit (72),				/* set by init_sst */
  3    47     2 hc_dbr bit (72),				/* set by start_cpu, idle DBR */
  3    48     2 message char (64),				/* message for return to bce */
  3    49     2 return_to_bce_command char (128) unal;		/* command to run upon crash/shutdown */
  3    50 
  3    51 declare FLAGBOX_SENTINEL char (32) init ("Flagbox & Toehold Valid") int static options (constant);
  3    52 
  3    53 /* END INCLUDE FILE ... flagbox.incl.pl1 */
      312 
      313  /*  */
  4     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  4     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  4     4 /* Modified 07/07/76 by Morris for fault register data */
  4     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  4     6 /* Modified '82 to make values constant */
  4     7 
  4     8 /* words 0-15 pointer registers */
  4     9 
  4    10 dcl  mcp ptr;
  4    11 
  4    12 dcl 1 mc based (mcp) aligned,
  4    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  4    14    (2 regs,					/* registers */
  4    15       3 x (0:7) bit (18),				/* index registers */
  4    16       3 a bit (36),					/* accumulator */
  4    17       3 q bit (36),					/* q-register */
  4    18       3 e bit (8),					/* exponent */
  4    19       3 pad1 bit (28),
  4    20       3 t bit (27),					/* timer register */
  4    21       3 pad2 bit (6),
  4    22       3 ralr bit (3),				/* ring alarm register */
  4    23 
  4    24     2 scu (0:7) bit (36),
  4    25 
  4    26     2 mask bit (72),				/* mem controller mask at time of fault */
  4    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  4    28     2 errcode fixed bin (35),				/* fault handler's error code */
  4    29     2 fim_temp,
  4    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  4    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  4    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  4    33     2 fault_reg bit (36),				/* fault register */
  4    34     2 pad2 bit (1),
  4    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  4    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  4    37     2 fault_time bit (54),				/* time of fault */
  4    38 
  4    39     2 eis_info (0:7) bit (36)) unaligned;
  4    40 
  4    41 
  4    42 dcl (apx fixed bin init (0),
  4    43      abx fixed bin init (1),
  4    44      bpx fixed bin init (2),
  4    45      bbx fixed bin init (3),
  4    46      lpx fixed bin init (4),
  4    47      lbx fixed bin init (5),
  4    48      spx fixed bin init (6),
  4    49      sbx fixed bin init (7)) internal static options (constant);
  4    50 
  4    51 
  4    52 
  4    53 
  4    54 dcl  scup ptr;
  4    55 
  4    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  4    57 
  4    58 
  4    59 /*	WORD (0)		*/
  4    60 
  4    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  4    62       3 prr bit (3),				/* procedure ring register */
  4    63       3 psr bit (15),				/* procedure segment register */
  4    64       3 p bit (1),					/* procedure privileged bit */
  4    65 
  4    66     2 apu,					/* APPENDING UNIT STATUS */
  4    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  4    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  4    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  4    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  4    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  4    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  4    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  4    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  4    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  4    76       3 ptw bit (1),				/* Fetch of PTW */
  4    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  4    78       3 fap bit (1),				/* Fetch of final address paged */
  4    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  4    80       3 fabs bit (1),				/* Fetch of final address absolute */
  4    81 
  4    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  4    83 
  4    84 
  4    85 /*	WORD (1)		*/
  4    86 
  4    87     2 fd,						/* FAULT  DATA */
  4    88       3 iro bit (1),				/* illegal ring order */
  4    89       3 oeb bit (1),				/* out of execute bracket */
  4    90       3 e_off bit (1),				/* no execute */
  4    91       3 orb bit (1),				/* out of read bracket */
  4    92       3 r_off bit (1),				/* no read */
  4    93       3 owb bit (1),				/* out of write bracket */
  4    94       3 w_off bit (1),				/* no write */
  4    95       3 no_ga bit (1),				/* not a gate */
  4    96       3 ocb bit (1),				/* out of call bracket */
  4    97       3 ocall bit (1),				/* outward call */
  4    98       3 boc bit (1),				/* bad outward call */
  4    99       3 inret bit (1),				/* inward return */
  4   100       3 crt bit (1),				/* cross ring transfer */
  4   101       3 ralr bit (1),				/* ring alarm register */
  4   102       3 am_er bit (1),				/* associative memory fault */
  4   103       3 oosb bit (1),				/* out of segment bounds */
  4   104       3 paru bit (1),				/* processor parity upper */
  4   105       3 parl bit (1),				/* processor parity lower */
  4   106       3 onc_1 bit (1),				/* op not complete type 1 */
  4   107       3 onc_2 bit (1),				/* op not complete type 2 */
  4   108 
  4   109     2 port_stat,					/* PORT  STATUS */
  4   110       3 ial bit (4),				/* illegal action lines */
  4   111       3 iac bit (3),				/* illegal action channel */
  4   112       3 con_chan bit (3),				/* connect channel */
  4   113 
  4   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  4   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  4   116 
  4   117 
  4   118 /*	WORD (2)		*/
  4   119 
  4   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  4   121       3 trr bit (3),				/* temporary ring register */
  4   122       3 tsr bit (15),				/* temporary segment register */
  4   123 
  4   124     2 pad2 bit (9),
  4   125 
  4   126     2 cpu_no bit (3),				/* CPU number */
  4   127 
  4   128     2 delta bit (6),				/* tally modification DELTA */
  4   129 
  4   130 
  4   131 /*	WORD (3)		*/
  4   132 
  4   133     2 word3 bit (18),
  4   134 
  4   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  4   136       3 tsna,					/* Word 1 status */
  4   137         4 prn bit (3),				/* Word 1  PR  number */
  4   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  4   139       3 tsnb,					/* Word 2  status */
  4   140         4 prn bit (3),				/* Word 2  PR  number */
  4   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  4   142       3 tsnc,					/* Word 3  status */
  4   143         4 prn bit (3),				/* Word 3  PR  number */
  4   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  4   145 
  4   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  4   147 
  4   148 
  4   149 /* 	WORD (4)		*/
  4   150 
  4   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  4   152 
  4   153     2 ir,						/* INDICATOR  REGISTERS */
  4   154       3 zero bit (1),				/* zero indicator */
  4   155       3 neg bit (1),				/* negative indicator */
  4   156       3 carry bit (1),				/* carryry indicator */
  4   157       3 ovfl bit (1),				/* overflow indicator */
  4   158       3 eovf bit (1),				/* eponent overflow */
  4   159       3 eufl bit (1),				/* exponent underflow */
  4   160       3 oflm bit (1),				/* overflow mask */
  4   161       3 tro bit (1),				/* tally runout */
  4   162       3 par bit (1),				/* parity error */
  4   163       3 parm bit (1),				/* parity mask */
  4   164       3 bm bit (1),					/* ^bar mode */
  4   165       3 tru bit (1),				/* truncation mode */
  4   166       3 mif bit (1),				/* multi-word instruction mode */
  4   167       3 abs bit (1),				/* absolute mode */
  4   168       3 hex bit (1),				/* hexadecimal exponent mode */
  4   169       3 pad bit (3),
  4   170 
  4   171 
  4   172 /*	WORD (5)		*/
  4   173 
  4   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  4   175 
  4   176     2 cu,						/* CONTROL UNIT STATUS */
  4   177       3 rf bit (1),					/* on first cycle of repeat instr */
  4   178       3 rpt bit (1),				/* repeat instruction */
  4   179       3 rd bit (1),					/* repeat double instruction */
  4   180       3 rl bit (1),					/* repeat link instruciton */
  4   181       3 pot bit (1),				/* IT  modification */
  4   182       3 pon bit (1),				/* return type instruction */
  4   183       3 xde bit (1),				/* XDE from Even location */
  4   184       3 xdo bit (1),				/* XDE from Odd  location */
  4   185       3 poa bit (1),				/* operation preparation */
  4   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  4   187       3 its bit (1),				/* ITS modification */
  4   188       3 if bit (1),					/* fault occured during instruction fetch */
  4   189 
  4   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  4   191 
  4   192 
  4   193 /*	WORDS (6,7)	*/
  4   194 
  4   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  4   196 
  4   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  4   198 
  4   199 
  4   200 
  4   201 
  4   202 
  4   203 
  4   204 /*	ALTERNATE   SCU  DECLARATION		*/
  4   205 
  4   206 
  4   207 dcl 1 scux based (scup) aligned,
  4   208 
  4   209    (2 pad0 bit (36),
  4   210 
  4   211     2 fd,						/* GROUP II  FAULT DATA */
  4   212       3 isn bit (1),				/* illegal segment number */
  4   213       3 ioc bit (1),				/* illegal op  code  */
  4   214       3 ia_am bit (1),				/* illegal address - modifier */
  4   215       3 isp bit (1),				/* illegal slave  procedure */
  4   216       3 ipr bit (1),				/* illegal procedure */
  4   217       3 nea bit (1),				/* non existent address */
  4   218       3 oobb bit (1),				/* out of bounds */
  4   219       3 pad bit (29),
  4   220 
  4   221     2 pad2 bit (36),
  4   222 
  4   223     2 pad3a bit (18),
  4   224 
  4   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  4   226       3 prn bit (3),				/* PR  number */
  4   227       3 prv bit (1),				/* PR  valid bit */
  4   228 
  4   229     2 pad3b bit (6)) unaligned,
  4   230 
  4   231     2 pad45 (0:1) bit (36),
  4   232 
  4   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  4   234 
  4   235 
  4   236 
  4   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      313 
      314  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  5     2 
  5     3 /* Declarations for Segment Loading Table header and array.
  5     4*
  5     5*   Used by Initialization and MST Checker subroutines */
  5     6 
  5     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  5     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  5     9     namep ptr,					/* pointer to segment name list block */
  5    10     pathp ptr,					/* pointer to segment's directory path name */
  5    11     aclp ptr;					/* pointer to acl structure */
  5    12 
  5    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  5    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  5    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  5    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  5    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  5    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  5    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  5    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  5    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  5    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  5    23 
  5    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  5    25 
  5    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  5    27 	2 pad bit (18) unal,
  5    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  5    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  5    30 
  5    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  5    32 	2 count fixed bin (17),			/* number of segment names in this block */
  5    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  5    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  5    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  5    36 	  3 pad bit (5) unal,
  5    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  5    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  5    39 
  5    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  5    41 	2 size fixed bin (17),			/* length of pathname */
  5    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  5    43 	2 acls fixed bin;				/* ACL list starts here */
  5    44 
  5    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  5    46 	2 count fixed bin,				/* number of entries in acl list */
  5    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  5    48 	  3 userid char (32),			/* user specification */
  5    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  5    50 	  3 pad bit (36) aligned,
  5    51 	  3 code fixed bin;
  5    52 
  5    53 
  5    54 /* END INCLUDE FILE slt.incl.pl1 */
      314 
      315  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  6     2 /* Declaration for Segment Loading Table Entry structure.
  6     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  6     4 /* modified 5/4/76 by Noel I. Morris	*/
  6     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  6     6 /* format: style3 */
  6     7 
  6     8 dcl	sltep		ptr;
  6     9 
  6    10 dcl	1 slte_uns	based (sltep) aligned,
  6    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  6    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  6    13 /**** End of word 1 */
  6    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  6    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  6    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  6    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  6    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  6    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  6    20 	  2 pad1		bit (3),			/* unused */
  6    21 	  2 wired		bit (1),			/* segment is wired if ON */
  6    22 	  2 paged		bit (1),			/* segment is paged if ON */
  6    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  6    24 	  2 pad3		bit (2),
  6    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  6    26 /**** End of 1st half of word 2 */
  6    27 	  2 pad4		bit (3),
  6    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  6    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  6    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  6    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  6    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  6    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  6    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  6    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  6    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  6    37 /***** End of word 2 */
  6    38 	  2 pad5		bit (6),
  6    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  6    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  6    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  6    42 /***** End of word 3 */
  6    43 	  2 pad7		bit (3),
  6    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  6    45 	  2 bit_count	fixed bin (24) uns
  6    46 	  )		unaligned;		/* bitcount of segment */
  6    47 
  6    48 dcl	1 slte		based (sltep) aligned,
  6    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  6    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  6    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  6    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  6    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  6    54 	  2 firmware_seg    bit (1),
  6    55 	  2 layout_seg      bit (1),
  6    56 	  2 breakpointable  bit (1),
  6    57 	  2 pad2		bit (3),
  6    58 	  2 wired		bit (1),			/* segment is wired if ON */
  6    59 	  2 paged		bit (1),			/* segment is paged if ON */
  6    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  6    61 	  2 pad3		bit (2),
  6    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  6    63 	  2 pad4		bit (3),
  6    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  6    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  6    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  6    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  6    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  6    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  6    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  6    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  6    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  6    73 	  2 pad5		bit (6),
  6    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  6    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  6    76 	  2 segno		bit (18),			/* text/link segment number */
  6    77 	  2 pad6		bit (3),
  6    78 	  2 max_length	bit (9),			/* maximum length for segment */
  6    79 	  2 bit_count	bit (24)
  6    80 	  )		unaligned;		/* bitcount of segment */
  6    81 
  6    82 /* END INCLUDE FILE slte.incl.pl1 */
      315 
      316  /* Begin include file sstnt.incl.pl1   */
  7     2 
  7     3 /* Created 10/03/74 by Bernard Greenberg */
  7     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  7     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  7     6 
  7     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  7     8 
  7     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  7    10 
  7    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  7    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  7    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  7    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  7    15     2 pad1 (5) fixed bin,
  7    16 
  7    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  7    18      ast_name_offsets,				/* Starting index for names at each level */
  7    19      ast_offsets,					/* Starting rel addr of each AST region */
  7    20      pad2) (0 : 3) fixed bin,
  7    21 
  7    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  7    23 
  7    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  7    25 
  7    26 dcl  nm_astep ptr;					/* astep to be used */
  7    27 
  7    28 /* End include file sstnt.incl.pl1 */
      316 
      317  /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  8     2 
  8     3 /* format: off */
  8     4 
  8     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  8     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  8     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  8     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  8     9 
  8    10 
  8    11 /****^  HISTORY COMMENTS:
  8    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  8    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  8    14*     Modified to add constants for the translator_id field in the stack_frame
  8    15*     structure.
  8    16*                                                   END HISTORY COMMENTS */
  8    17 
  8    18 
  8    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  8    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  8    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  8    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  8    23 
  8    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  8    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  8    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  8    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  8    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  8    29 
  8    30 
  8    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  8    32 
  8    33 dcl  stack_frame_min_length fixed bin static init(48);
  8    34 
  8    35 
  8    36 dcl 1 stack_frame based(sp) aligned,
  8    37     2 pointer_registers(0 : 7) ptr,
  8    38     2 prev_sp pointer,
  8    39     2 next_sp pointer,
  8    40     2 return_ptr pointer,
  8    41     2 entry_ptr pointer,
  8    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  8    43     2 arg_ptr pointer,
  8    44     2 static_ptr ptr unaligned,
  8    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  8    46     2 on_unit_relp1 bit(18) unaligned,
  8    47     2 on_unit_relp2 bit(18) unaligned,
  8    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  8    49*						   0 => PL/I version II
  8    50*						   1 => ALM
  8    51*						   2 => PL/I version I   
  8    52*						   3 => signal caller frame
  8    53*						   4 => signaller frame */
  8    54     2 operator_return_offset bit(18) unaligned,
  8    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  8    56     2 a bit(36),					/* accumulator */
  8    57     2 q bit(36),					/* q-register */
  8    58     2 e bit(36),					/* exponent */
  8    59     2 timer bit(27) unaligned,				/* timer */
  8    60     2 pad bit(6) unaligned,
  8    61     2 ring_alarm_reg bit(3) unaligned;
  8    62 
  8    63 
  8    64 dcl 1 stack_frame_flags based(sp) aligned,
  8    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  8    66     2 xx0 bit(22) unal,
  8    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  8    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  8    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  8    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  8    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  8    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  8    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  8    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  8    75     2 xx0a bit(6) unal,
  8    76     2 xx1 fixed bin,
  8    77     2 xx2 fixed bin,
  8    78     2 xx3 bit(25) unal,
  8    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  8    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  8    81     2 xx3a bit(9) unaligned,
  8    82     2 xx4(9) bit(72) aligned,
  8    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  8    84*						*  operator puts a pointer to the base of
  8    85*						*  the calling procedure here. (text base ptr)  */
  8    86     2 xx5 bit(72) aligned,
  8    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  8    88 
  8    89 /* format: on */
  8    90 
  8    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      317 
      318  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  9     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  9     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  9     4 
  9     5 /* This include file has an ALM version.  Keep 'em in sync! */
  9     6 
  9     7 dcl (
  9     8 
  9     9 /* The following constants define the message action codes.  This indicates
  9    10*how a message is to be handled.  */
  9    11 
  9    12      SYSERR_CRASH_SYSTEM	init (1),			
  9    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  9    14 
  9    15      SYSERR_TERMINATE_PROCESS	init (2),
  9    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  9    17 
  9    18      SYSERR_PRINT_WITH_ALARM	init (3),
  9    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  9    20 
  9    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  9    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  9    23 
  9    24      SYSERR_LOG_OR_PRINT	init (4),
  9    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  9    26 
  9    27      SYSERR_LOG_OR_DISCARD	init (5),
  9    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  9    29 
  9    30 
  9    31 /* The following constants are added to the normal severities to indicate
  9    32*different sorting classes of messages.  */
  9    33 
  9    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  9    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  9    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  9    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  9    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  9    39 	) fixed bin internal static options (constant);
  9    40 
  9    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      318 
      319  /* BEGIN include file unpaged_page_tables.incl.pl1 */
 10     2 
 10     3 /* This include file describes the segments unpaged_page_tables and
 10     4*int_unpaged_page_tables.  These segments contain the page tables for
 10     5*segments that are paged and wired, those segments previously called
 10     6*unpaged.
 10     7*
 10     8*Written September 15, 1983 by Keith Loepere. */
 10     9 
 10    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 10    11 
 10    12 dcl  upt_ptr		        ptr;
 10    13 dcl  1 upt		        aligned based (upt_ptr),
 10    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
 10    15        2 sst_last_loc	        fixed bin (26),
 10    16        2 upt_absloc		        fixed bin (26),
 10    17        2 upt_last_loc	        fixed bin (26),
 10    18        2 iupt_absloc	        fixed bin (26),
 10    19        2 iupt_last_loc	        fixed bin (26),
 10    20 
 10    21        2 current_length	        fixed bin,		/* number of words currently used */
 10    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
 10    23        2 first_entry	        like upt_entry;
 10    24 
 10    25 dcl  upt_entry_ptr		        ptr;
 10    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
 10    27        2 size		        fixed bin,		/* number of page table words allocated */
 10    28        2 segno		        fixed bin,		/* of hardcore segment */
 10    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
 10    30 
 10    31 /* END include file unpaged_page_tables.incl.pl1 */
      319 
      320 
      321 /*  */
      322 
      323 /* BEGIN MESSAGE DOCUMENTATION
      324*
      325*   Message:
      326*   make_segs_paged: sorted_segs array overflowed.
      327*
      328*   S: $crash
      329*
      330*   T: $init
      331*
      332*   M: The number of paged segments in collection 1 is larger than
      333*   the internal buffer in the program make_segs_paged required to
      334*   sort them by main memory address. This indicates an error in
      335*   construction of the system (i.e., too many header entries), or
      336*   may be symptomatic of main memory or CPU hardware problems.
      337*
      338*   A: If this recurs, revert to a previous system tape. No emergency
      339*   shutdown is needed. 
      340*
      341*   END MESSAGE DOCUMENTATION */
      342 
      343 	end make_segs_paged;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0816.1  make_segs_paged.pl1               >spec>install>1112>make_segs_paged.pl1
310          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
311          2    11/18/84  1346.2  bce_breakpoint_page.incl.pl1      >ldd>include>bce_breakpoint_page.incl.pl1
312          3    04/30/87  1513.7  flagbox.incl.pl1                  >ldd>include>flagbox.incl.pl1
313          4    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
314          5    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
315          6    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
316          7    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
317          8    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
318          9    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
319         10    07/11/84  0937.3  unpaged_page_tables.incl.pl1      >ldd>include>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000004 constant        fixed bin(17,0)          initial dcl 9-7 set ref 173*
abs_seg                   1(05)        based           bit(1)                   level 2 packed packed unaligned dcl 6-48 ref 153
abs_seg$                        000014 external static fixed bin(17,0)          dcl 95 set ref 124 242 242 302 302
abs_seg_ptr                     000112 automatic       pointer                  dcl 70 set ref 124* 259 276
absadr                          000030 constant        entry                    external dcl 106 ref 168 235
add                       1     000116 automatic       fixed bin(26,0)          array level 2 dcl 73 set ref 178* 181 192*
addr                                                   builtin function         dcl 120 ref 123 124 125 126 128 136 136 136 136 141
                                                                                  152 162 162 207 223 223 236 236 240 240 242 242
                                                                                  242 242 261 262 278 278 299 302 302 302 302
astep                           001262 automatic       pointer                  dcl 1-9 set ref 133* 134 213* 215 225* 279*
baseno                                                 builtin function         dcl 120 ref 127 128
baseptr                                                builtin function         dcl 120 ref 168 168 208 235 235
bin                                                    builtin function         dcl 120 ref 127 128
bkpt_num                        001316 automatic       fixed bin(17,0)          dcl 250 set ref 260* 261 262*
bkpt_page                              based           structure                level 1 dcl 2-9
bkpts                   100            based           structure                array level 2 dcl 2-9 set ref 260 261 262
breakpoint                             based           structure                level 1 dcl 2-21 set ref 263* 263
breakpointable            1(08)        based           bit(1)                   level 2 packed packed unaligned dcl 6-10 ref 244
current_address                 001253 automatic       fixed bin(26,0)          dcl 82 set ref 284* 285 288
current_page                    001254 automatic       fixed bin(17,0)          dcl 84 set ref 285* 290
currentsize                                            builtin function         dcl 120 ref 143
divide                                                 builtin function         dcl 120 ref 143 285 288
ds_seg$                         000012 external static fixed bin(71,0)          array dcl 93 set ref 136 136 138* 155* 165* 220*
dseg$                           000010 external static fixed bin(71,0)          array dcl 91 set ref 128 155 159 162 162 165 221 236
                                                                                  236
dseg_no                         000104 automatic       fixed bin(17,0)          dcl 65 set ref 128* 133* 138 210
fgbx                                   based           structure                level 1 dcl 3-24
first_init_seg            5            based           fixed bin(18,0)          level 2 dcl 5-13 ref 151
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 5-13 ref 151
flagbox$                        000056 external static fixed bin(17,0)          dcl 3-21 set ref 299
freecore                        000032 constant        entry                    external dcl 107 ref 291
from                                   based           bit(36)                  array dcl 274 ref 276
from_bkpt_page_ptr              001306 automatic       pointer                  dcl 246 set ref 258* 260 261
from_breakpoint_ptr             001312 automatic       pointer                  dcl 248 set ref 261* 263 263
hc_dbr                   56            based           bit(72)                  level 2 dcl 3-24 set ref 299*
high_page_to_free               001255 automatic       fixed bin(17,0)          dcl 85 set ref 200* 288* 290
idx                             001251 automatic       fixed bin(17,0)          dcl 79 set ref 180* 181 184 184* 188* 190 192 201*
                                                                                  206*
k                               001250 automatic       fixed bin(17,0)          dcl 78 set ref 290* 291*
last_init_seg             6            based           fixed bin(18,0)          level 2 dcl 5-13 ref 151
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 5-13 ref 151
layout_seg                1(07)        based           bit(1)                   level 2 packed packed unaligned dcl 6-48 ref 153
make_sdw                        000034 constant        entry                    external dcl 109 ref 213
make_sdw$unthreaded             000036 constant        entry                    external dcl 110 ref 133
max_length                3(03)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 6-10
                                                                                  set ref 143*
mc                                     based           structure                level 1 dcl 4-12
names                    30            based           varying char(32)         array level 2 dcl 7-11 set ref 304*
nentries                  2            based           fixed bin(17,0)          level 2 dcl 7-11 set ref 142* 143 304
new_address                     001260 automatic       fixed bin(26,0)          dcl 88 set ref 159* 162* 163 163 168* 178 181 192
                                                                                  235* 284
new_dbr                         000106 automatic       fixed bin(71,0)          dcl 67 set ref 139* 298* 299
new_seg_sdw                     000110 automatic       fixed bin(71,0)          dcl 68 set ref 239* 278 278
no_aste                   0(18) 000020 external static fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 98 ref 142
nsegs                           001257 automatic       fixed bin(17,0)          dcl 87 set ref 150* 172* 172 173 177 178 180 201
null                                                   builtin function         dcl 120 ref 133 213 215
original_instr_ptr        6            based           pointer                  level 2 packed packed unaligned dcl 2-21 set ref 263
page_size                       000102 automatic       fixed bin(18,0)          dcl 62 set ref 129* 143 143 285 285 288
paged                     1(13)        based           bit(1)                   level 2 packed packed unaligned dcl 6-48 ref 153
pc_wired$write                  000040 constant        entry                    external dcl 111 ref 225 279
pds$dstep                       000024 external static bit(18)                  dcl 103 set ref 134*
pmut$ldbr                       000044 constant        entry                    external dcl 113 ref 298
pmut$swap_sdw                   000042 constant        entry                    external dcl 112 ref 136 223 242 278 302
rel                                                    builtin function         dcl 120 ref 134
return_ptr               24            based           pointer                  level 2 dcl 8-36 set ref 272*
sdw_util_$get_address           000050 constant        entry                    external dcl 115 ref 162
sdw_util_$get_size              000046 constant        entry                    external dcl 114 ref 236
sdw_util_$set_access            000052 constant        entry                    external dcl 116 ref 240
seg                      10            based           structure                array level 2 dcl 5-13 set ref 141 152 207
seg_ptr                         000114 automatic       pointer                  dcl 71 set ref 208* 223* 258 276 278*
seg_size                        001256 automatic       fixed bin(19,0)          dcl 86 set ref 236* 252* 252 258 259 276 288
segno                                                  builtin function         dcl 120 ref 263
segnum                          000116 automatic       fixed bin(17,0)          array level 2 in structure "sorted_segs" dcl 73
                                                                                  in procedure "make_segs_paged" set ref 177* 190*
                                                                                  206
segnum                          001252 automatic       fixed bin(17,0)          dcl 80 in procedure "make_segs_paged" set ref 151*
                                                                                  152 155 155 159 162 162 165 165 168 168 177 190*
                                                                                  206* 207 208 210 213* 220 221 235 235 236 236 263
slt                                    based           structure                level 1 dcl 5-13
slt$                            000016 external static fixed bin(17,0)          dcl 96 set ref 125
slte                                   based           structure                level 1 dcl 6-48
slte_uns                               based           structure                level 1 dcl 6-10
sltep                           001266 automatic       pointer                  dcl 6-8 set ref 141* 143 152* 153 153 153 207* 244
sltp                            001264 automatic       pointer                  dcl 5-7 set ref 125* 141 151 151 151 151 152 207
sorted_segs                     000116 automatic       structure                array level 1 dcl 73 set ref 173 184* 184
sst$level                       000020 external static structure                array level 1 dcl 98
sst_absloc                             based           fixed bin(26,0)          level 2 dcl 10-13 ref 163
sst_last_loc              1            based           fixed bin(26,0)          level 2 dcl 10-13 ref 163
sst_names_$                     000060 external static fixed bin(17,0)          dcl 7-7 set ref 126
sstnp                           001270 automatic       pointer                  dcl 7-9 set ref 126* 127 142 143 304
sstnt                                  based           structure                level 1 dcl 7-11 set ref 143
sstnt_no                        000103 automatic       fixed bin(17,0)          dcl 64 set ref 127* 141
stack_frame                            based           structure                level 1 dcl 8-36
sum                                                    builtin function         dcl 120 ref 142
sys_info$page_size              000022 external static fixed bin(17,0)          dcl 102 ref 129
syserr                          000054 constant        entry                    external dcl 117 ref 173
to                                     based           bit(36)                  array dcl 275 set ref 276*
to_bkpt_page_ptr                001310 automatic       pointer                  dcl 246 set ref 259* 262
to_breakpoint_ptr               001314 automatic       pointer                  dcl 248 set ref 262* 263
tsdw                            000100 automatic       fixed bin(71,0)          dcl 61 set ref 133* 136 136 138 139 213* 220 223 223
                                                                                  239 240 240 242 242 301* 302 302
unpaged_page_tables$            000026 external static fixed bin(17,0)          dcl 104 set ref 123
unspec                                                 builtin function         dcl 120 ref 299
upt                                    based           structure                level 1 dcl 10-13
upt_entry                              based           structure                level 1 dcl 10-26
upt_ptr                         001272 automatic       pointer                  dcl 10-12 set ref 123* 163 163

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 9-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 9-7
BKPT_page_sentinel                     internal static char(4)                  initial packed unaligned dcl 2-30
FLAGBOX_SENTINEL                       internal static char(32)                 initial packed unaligned dcl 3-51
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 9-7
LOG                                    internal static fixed bin(17,0)          initial dcl 9-7
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 8-19
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 9-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 9-7
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 8-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 8-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 8-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 8-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 8-27
abx                                    internal static fixed bin(17,0)          initial dcl 4-42
aclp                                   automatic       pointer                  dcl 5-7
acls                                   based           structure                level 1 dcl 5-45
apx                                    internal static fixed bin(17,0)          initial dcl 4-42
asta                                   based           bit(432)                 array dcl 1-86
aste                                   based           structure                level 1 dcl 1-11
aste_part                              based           structure                level 1 dcl 1-89
bbx                                    internal static fixed bin(17,0)          initial dcl 4-42
bit                                                    builtin function         dcl 120
bkpt_page_ptr                          automatic       pointer                  dcl 2-19
bpx                                    internal static fixed bin(17,0)          initial dcl 4-42
breakpoint_ptr                         automatic       pointer                  dcl 2-28
fgbxp                                  automatic       pointer                  dcl 3-22
get_ptrs_$given_astep           000000 constant        entry                    external dcl 108
lbx                                    internal static fixed bin(17,0)          initial dcl 4-42
lpx                                    internal static fixed bin(17,0)          initial dcl 4-42
max                                                    builtin function         dcl 120
mcp                                    automatic       pointer                  dcl 4-10
name_seg                               based           structure                level 1 dcl 5-26
namep                                  automatic       pointer                  dcl 5-7
names_ptr                              automatic       pointer                  dcl 5-7
nm_astep                               automatic       pointer                  dcl 7-26
path                                   based           structure                level 1 dcl 5-40
pathp                                  automatic       pointer                  dcl 5-7
ptr                                                    builtin function         dcl 120
ptsi_a                                 automatic       fixed bin(17,0)          dcl 7-24
sbx                                    internal static fixed bin(17,0)          initial dcl 4-42
scu                                    based           structure                level 1 dcl 4-56
scup                                   automatic       pointer                  dcl 4-54
scux                                   based           structure                level 1 dcl 4-207
seg_aste                               based           structure                level 1 dcl 1-96
segnam                                 based           structure                level 1 dcl 5-31
sp                                     automatic       pointer                  dcl 8-31
spx                                    internal static fixed bin(17,0)          initial dcl 4-42
sstnmx                                 automatic       fixed bin(17,0)          dcl 7-24
stack_frame_flags                      based           structure                level 1 dcl 8-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 8-33
string                                                 builtin function         dcl 120
thread$out                      000000 constant        entry                    external dcl 118
upt_entry_ptr                          automatic       pointer                  dcl 10-25

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_NEXT_SEGMENT              000373 constant        label                    dcl 194 ref 156 166
LOOP_DOWN_SEGS                  000416 constant        label                    dcl 201
PMUT_RETURN_HERE                000705 constant        label                    dcl 279 ref 272
SKIP                            000756 constant        label                    dcl 293 ref 210 215 226
SLOT_FOUND                      000364 constant        label                    dcl 190 ref 181
make_segs_paged                 000027 constant        entry                    external dcl 15

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addrel                                                 builtin function         ref 258 259
codeptr                                                builtin function         ref 272
dimension                                              builtin function         ref 260
hbound                                                 builtin function         ref 173
stackframeptr                                          builtin function         ref 272

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1262        1344    1033        1272
Length      1750    1033        62         367     226           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
make_segs_paged                     750 external procedure  is an external procedure.  
begin block on line 244                 begin block         shares stack frame of external procedure make_segs_paged.  
begin block on line 273                 begin block         shares stack frame of external procedure make_segs_paged.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
make_segs_paged          000100 tsdw                        make_segs_paged
                         000102 page_size                   make_segs_paged
                         000103 sstnt_no                    make_segs_paged
                         000104 dseg_no                     make_segs_paged
                         000106 new_dbr                     make_segs_paged
                         000110 new_seg_sdw                 make_segs_paged
                         000112 abs_seg_ptr                 make_segs_paged
                         000114 seg_ptr                     make_segs_paged
                         000116 sorted_segs                 make_segs_paged
                         001250 k                           make_segs_paged
                         001251 idx                         make_segs_paged
                         001252 segnum                      make_segs_paged
                         001253 current_address             make_segs_paged
                         001254 current_page                make_segs_paged
                         001255 high_page_to_free           make_segs_paged
                         001256 seg_size                    make_segs_paged
                         001257 nsegs                       make_segs_paged
                         001260 new_address                 make_segs_paged
                         001262 astep                       make_segs_paged
                         001264 sltp                        make_segs_paged
                         001266 sltep                       make_segs_paged
                         001270 sstnp                       make_segs_paged
                         001272 upt_ptr                     make_segs_paged
                         001306 from_bkpt_page_ptr          begin block on line 244
                         001310 to_bkpt_page_ptr            begin block on line 244
                         001312 from_breakpoint_ptr         begin block on line 244
                         001314 to_breakpoint_ptr           begin block on line 244
                         001316 bkpt_num                    begin block on line 244

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        freecore                      make_sdw                      make_sdw$unthreaded
pc_wired$write                pmut$ldbr                     pmut$swap_sdw                 sdw_util_$get_address
sdw_util_$get_size            sdw_util_$set_access          syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
abs_seg$                      ds_seg$                       dseg$                         flagbox$
pds$dstep                     slt$                          sst$level                     sst_names_$
sys_info$page_size            unpaged_page_tables$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000026       123 000034       124 000036       125 000040       126 000042       127 000044       128 000050
    129 000055       133 000057       134 000076       136 000101       138 000115       139 000123       141 000125
    142 000132       143 000156       150 000174       151 000175       152 000207       153 000214       155 000222
    156 000230       159 000231       162 000241       163 000254       165 000262       166 000266       168 000267
    172 000307       173 000310       177 000333       178 000340       180 000342       181 000347       184 000354
    186 000360       188 000363       190 000364       192 000371       194 000373       200 000414       201 000416
    206 000423       207 000426       208 000432       210 000436       213 000440       215 000457       220 000463
    221 000471       223 000474       225 000506       226 000524       235 000525       236 000544       239 000560
    240 000562       242 000577       244 000614       252 000620       258 000622       259 000626       260 000631
    261 000637       262 000643       263 000646       265 000656       272 000660       276 000663       278 000672
    279 000705       284 000723       285 000725       288 000731       290 000736       291 000745       292 000754
    293 000756       298 000761       299 000770       301 000775       302 000777       304 001013       306 001032


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
