	COMPILATION LISTING OF SEGMENT volume_registration_cmds_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1016.4 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: ^inddcls,indattr,^indnoniterdo */
       13 
       14 volume_registration_cmds_: vrc_: proc;
       15 
       16 	comname = "volume_registration_cmds_"; ec = 0;
       17 	call FAIL ("This entry not used.");
       18 	return;
       19 
       20 /* Logical Volume Registration Functions.
       21*
       22*   add_volume_registration -pv name -lv name2 -model device_model ...
       23*   change_volume_registration -pv|-lv name ...
       24*   delete_volume_registration -pv|-lv name
       25*   list_volume_registration -pv|-lv name {-bf}
       26*
       27*   THVV
       28*   Modified 4/79 by Michael R. Jordan to require -model in avr and print correct model number in lvr.
       29*   Modified 84-08-21 by EJ Sharpe to move more of the database manipulation
       30*		into ring-1 to make these system administrator rather
       31*		than operator commands.
       32*		Change name to volume_registration_cmds_ from hvr_.
       33*                    Also added internal documentation.
       34*   Modified 84-10-30 by EJ Sharpe for some minor upgrades
       35**/
       36 
       37 /* AUTOMATIC */
       38 
       39 dcl  ap		ptr;			/* arg pointer */
       40 dcl  al   	fixed bin (21);		/* arg length */
       41 dcl  bchr		char (al) based (ap);	/* args */
       42 
       43 dcl  pvname 	char (32) init ("");	/* Physical volume name */
       44 dcl  location	char (32) init ("uninitialized");
       45 dcl  dt_str	char (24);
       46 dcl  pvid           bit (36) aligned init ("0"b);
       47 dcl  lvname 	char (32) init ("");	/* Logical volume name */
       48 dcl  lvid           bit (36) aligned init ("0"b);
       49 dcl  tcs 		char (32) init ("");	/* Control arg */
       50 dcl  tcs1 	char (256) init ("");	/* Value */
       51 dcl  temp_ptr       ptr init (null);
       52 dcl  comname	char (32) init ("add_vol_registration");
       53 dcl  aa_string	char (32) aligned;
       54 dcl  auth_mnemonics char (172);
       55 dcl  b36		bit (36) aligned init ("0"b);
       56 dcl  fb35           fixed bin (35);
       57 dcl  fb71           fixed bin (71);
       58 dcl  old_lvid	bit (36) init ("0"b);
       59 dcl  old_lvname	char (32) init ("");
       60 dcl  access_range   (2) bit (72) aligned init ("0"b, sys_info$access_class_ceiling);
       61 dcl  gave_access_low bit (1) init ("0"b);	/* TRUE if user specified */
       62 dcl  gave_access_high bit (1) init ("0"b);	/* TRUE if user specified */
       63 dcl  gave_public	bit (1) init ("0"b);	/* TRUE if user specified */
       64 dcl  lv_already_registered	bit (1) init ("0"b);
       65 dcl  new_lv	bit (1) init ("0"b);	/* TRUE if new seg */
       66 dcl  acs_dir        char (168) init ("");
       67 dcl  acs_ent        char (32) init ("");
       68 dcl  ans	          bit (1);
       69 dcl (i, j)	fixed bin;
       70 dcl  more_args	bit (1) init ("1"b);
       71 dcl  argno	fixed bin init (1);
       72 dcl  serial	char (32) init ("unspecified"); /* Medium manufacturer's serial */
       73 dcl  pubbit	bit (1) init ("1"b);	/* TRUE if public volume */
       74 dcl  owner	char (32) init ("");	/* Person.Project of vol owner */
       75 dcl  owneri	fixed bin;		/* .. index of dot in owner */
       76 dcl  model	fixed bin init (0);		/* internal model number */
       77 dcl  change_model   bit (1);
       78 dcl  change_name    bit (1);
       79 dcl  change_uid     bit (1);
       80 dcl  change_auth    bit (1);
       81 dcl  change_range   bit (1);
       82 dcl  ec		fixed bin (35) init (0);
       83 dcl  ec2		fixed bin (35) init (0);
       84 dcl  temp_str	char (256);		/* for building error msgfs, etc */
       85 dcl  str_len	fixed bin (21);		/* length of string passed to ioa_$rsnnl */
       86 
       87 
       88 /* CONSTANTS */
       89 
       90 dcl  YESNO (0:1) char (3) static init ("no", "yes");
       91 dcl  PVNAME_LEGAL char (37) static options (constant)
       92 		init ("0123456789abcdefghijklmnopqrstuvwxyz_");
       93 dcl  LVNAME_LEGAL char (76) static options (constant)
       94 		init (" `'_^~+-:{}!.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
       95 
       96 /* MISC */
       97 
       98 dcl (addr,
       99      clock,
      100      null,
      101      rtrim,
      102      fixed,
      103      hbound,
      104      index,
      105      length,
      106      substr,
      107      unspec,
      108      verify)	builtin;
      109 
      110 dcl  cleanup	condition;
      111 
      112 dcl  error_table_$ai_invalid_range fixed bin (35) ext;
      113 dcl  error_table_$badopt	fixed bin (35) ext;
      114 dcl  error_table_$bad_arg	fixed bin (35) ext;
      115 dcl  error_table_$noarg	fixed bin (35) ext;
      116 
      117 dcl  sys_info$access_class_ceiling	bit (72) aligned ext;
      118 
      119 /* ENTRIES */
      120 
      121 dcl  aim_check_$greater_or_equal entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
      122 dcl  com_err_		entry() options(variable);
      123 dcl  convert_access_class_$from_string	entry (bit(72) aligned, char(*), fixed bin(35));
      124 dcl  convert_access_class_$from_string_range entry ((2) bit(72) aligned, char(*), fixed bin(35));
      125 dcl  convert_access_class_$to_string_short entry (bit(72) aligned, char(*), fixed bin(35));
      126 dcl  convert_aim_attributes_	entry (bit(72) aligned) returns(char(32) aligned);
      127 dcl  convert_date_to_binary_  entry (char(*), fixed bin(71), fixed bin(35));
      128 dcl  cv_dec_check_		entry (char(*), fixed bin(35)) returns(fixed bin(35));
      129 dcl  cv_oct_check_		entry (char(*), fixed bin(35)) returns(fixed bin(35));
      130 dcl  cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
      131 dcl  date_time_$format	entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
      132 dcl  expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*), fixed bin(35));
      133 dcl  get_temp_segment_	entry (char(*), ptr, fixed bin(35));
      134 dcl  release_temp_segment_	entry (char(*), ptr, fixed bin(35));
      135 dcl  hcs_$truncate_seg	entry (ptr, fixed bin(19), fixed bin(35));
      136 dcl  command_query_$yes_no	entry() options(variable);
      137 dcl  mdc_priv_$change_lvr	entry (char(*), ptr, fixed bin(35));
      138 dcl  mdc_priv_$change_pvr	entry (char(*), ptr, fixed bin(35));
      139 dcl  mdc_priv_$delete_lvr	entry (char(*), fixed bin(35));
      140 dcl  mdc_priv_$delete_pvr	entry (char(*), fixed bin(35));
      141 dcl  mdc_priv_$read_lvr	entry (char(*), ptr, fixed bin(35));
      142 dcl  mdc_priv_$read_pvr	entry (char(*), ptr, fixed bin(35));
      143 dcl  mdc_priv_$add_lvr	entry (char(*), ptr, fixed bin(35));
      144 dcl  mdc_priv_$add_pvr	entry (char(*), ptr, fixed bin(35));
      145 dcl  mdc_$find_volname	entry (bit(36), char(*), char(*), fixed bin(35));
      146 dcl  pathname_		entry (char(*), char(*)) returns(char(168));
      147 dcl  unique_chars_		entry (bit(*)) returns(char(15));
      148 dcl  get_group_id_            entry() returns(char(32));
      149 dcl  ioa_			entry() options(variable);
      150 dcl  ioa_$rsnnl		entry() options(variable);
      151 
      152 
      153 add_volume_registration:
      154 add_vol_registration:	/* operator command name - pre MR11 */
      155 avr:	 entry;
      156 
      157 /******************************************************************************
      158*
      159*This is an administrative command used to register logical or physical volumes.
      160*It accepts arguments which specify attributes of the volume being registered.
      161*Its syntax is:
      162*
      163*     avr -pv NAME {PV ATTRIBUTE ARGS}...
      164*	... -lv NAME {LV ATTRIBUTE ARGS}
      165*
      166*The "PV ATTRIBUTE ARGS" must include at least the device model.
      167*The "LV ATTRIBUTE ARGS" are specified only when registering a new LV.
      168*All arguments are non-positional except for the first two (i.e. "pv NAME").
      169*
      170*The code is written like:
      171*
      172*	entry
      173*	setup
      174*	process args
      175*	check arg consistancy
      176*	if LV not already registered then
      177*	     fill in registration structure for new LV and new PV
      178*	     call inner ring
      179*	else
      180*	     fill in registration structure for new PV
      181*	     call inner ring
      182*	cleanup
      183*	exit
      184*
      185*******************************************************************************/
      186 
      187 	call set_up("add_volume_registration");
      188 	on cleanup call clean_up;
      189 
      190 	call getarg (tcs);				/* First arg must be "pv" */
      191 
      192 	ec = 0;
      193 
      194 	if ^(tcs = "pv"  /* retained for compatability */
      195 	     | tcs = "-physical_volume"  | tcs = "-pv")  then do;
      196 	     ec = error_table_$badopt;
      197 	     call FAIL ("First arg must be ""-pv"".");
      198 	end;
      199 
      200 	call getarg (pvname);			/* Get physical volume name */
      201 	if pvname = "" then call FAIL ("PV name not specified.");
      202 	if verify (rtrim (pvname), PVNAME_LEGAL) ^= 0 then call FAIL ("Invalid characters in name: " || pvname);
      203 
      204 	do while (more_args);
      205 	     call getarg (tcs);			/* Get control arg */
      206 	     call getarg (tcs1);			/* .. and value */
      207 
      208 	/* The control args -lv, -access_(high low), -owner, -public,
      209*	   -acs, and -lvid describe the Logical Volume */
      210 
      211 	     if tcs = "-logical_volume"  |  tcs = "-lv" then do;
      212 		lvname = tcs1;
      213 		if verify (rtrim(lvname), LVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in LV name.");
      214 	     end;
      215 	     else if tcs = "-access_class"  |  tcs = "-acc" then do;
      216 		call convert_access_class_$from_string_range (access_range, tcs1, ec);
      217 		if ec ^= 0 then call FAIL (tcs1);
      218 	     end;
      219 	     /* -access_low and -access_high retained for compatability
      220*		with the old operator avr command */
      221 	     else if tcs = "-access_low"  |  tcs = "-ac_low" then do;
      222 		call convert_access_class_$from_string (access_range(1), tcs1, ec);
      223 		if ec ^= 0 then call FAIL ("Illegal auth: " || tcs1);
      224 		gave_access_low = "1"b;
      225 	     end;
      226 	     else if tcs = "-access_high"  |  tcs = "-ac_high" then do;
      227 		call convert_access_class_$from_string (access_range(2), tcs1, ec);
      228 		if ec ^= 0 then call FAIL ("Illegal auth: " || tcs1);
      229 		gave_access_high = "1"b;
      230 	     end;
      231 	     else if tcs = "-owner"  |  tcs = "-ow" then do;
      232 		call check_owner;
      233 		if owneri = 0 then call FAIL ("Invalid owner: " || tcs1);
      234 	     end;
      235 	     else if tcs = "-public"  |  tcs = "-pub" then do;
      236 		if tcs1 ^= "yes"  &  tcs1 ^= "y"  &
      237 		   tcs1 ^= "no"   &  tcs1 ^= "n"  then do;
      238 		     ec = error_table_$bad_arg;
      239 		     call FAIL("Public argument must be ""yes"" or ""no"".");
      240 		end;
      241 		pubbit = ( (tcs1 = "yes") | (tcs1 = "y") );
      242 		gave_public = "1"b;
      243 	     end;
      244 	     else if tcs = "-acs_path"  |  tcs = "-acs" then do;
      245 		if tcs1 ^= "" then do;
      246 		     call expand_pathname_$add_suffix (tcs1, "acs", acs_dir, acs_ent, ec);
      247 		     if ec ^= 0 then call FAIL ("Bad ACS path: " || tcs1);
      248 		end;
      249 		else do;
      250 		     acs_dir = "";
      251 		     acs_ent = "";
      252 		end;
      253 	     end;
      254 	     else if tcs = "-logical_volume_uid"  |  tcs = "-lvid" then do;
      255 		fb35 = cv_oct_check_ (tcs1, ec2);
      256 		lvid = unspec(fb35);
      257 		if ec2 ^= 0 then call FAIL ("Invalid LVID: " || tcs1);
      258 	     end;
      259 
      260 	/* The rest of the control arguments (-pvid, -model, -location,
      261*	   and -serial) are PV specific	 */
      262 
      263 	     else if tcs = "-physical_volume_uid"  |  tcs = "-pvid" then do;
      264 		fb35 = cv_oct_check_ (tcs1, ec2);
      265 		pvid = unspec(fb35);
      266 		if ec2 ^= 0 then call FAIL ("Invalid PVID: " || tcs1);
      267 	     end;
      268 	     else if tcs = "-device_model"  |  tcs = "-model" then do;
      269 		i = cv_dec_check_ (tcs1, ec2);
      270 		if ec2 ^= 0 then call FAIL ("Invalid model: " || tcs1);
      271 		do model = 1 to hbound (MODEL, 1) while (i ^= MODEL (model)); end;
      272 		if model > hbound (MODEL, 1) then call FAIL ("Unknown model: " || tcs1);
      273 		model = MODELX (model);
      274 	     end;
      275 	     else if tcs = "-manufacturer_serial"  |  tcs = "-serial" then
      276 		     serial = tcs1;
      277 	     else if tcs = "-location"  |  tcs = "-loc" then
      278 		     location = tcs1;
      279 	     /* no control arg for "password" field */
      280 	     else do;
      281 		ec = error_table_$badopt;
      282 		call FAIL (tcs);
      283 	     end;
      284 	end;
      285 
      286 	if model = 0				/* Missing -model control arg */
      287 	then do;
      288 	     ec = error_table_$noarg;
      289 	     call FAIL ("-model must be specified");
      290 	end;
      291 
      292 	if lvname = "" 
      293 	then call FAIL ("""-lv"" must be specified."); /* Check given args */
      294 
      295 	call mdc_priv_$read_lvr (lvname, vrp, ec);
      296 	lv_already_registered = ( ec = 0 );
      297 
      298 	if lv_already_registered & (gave_access_low | gave_access_high |
      299 		gave_public | owner^="" | acs_dir^="" | lvid)
      300 	then call FAIL ("LV already registered, use change_volume_registration to modify its attributes.");
      301 
      302 	call mdc_priv_$read_pvr (pvname, vrp, ec);
      303 	if ec = 0 then call FAIL ("PV already registered: " || pvname);
      304 	ec = 0;
      305 
      306 	if gave_access_low | gave_access_high then
      307 	     if ^aim_check_$greater_or_equal (access_range(2), access_range(1))
      308 	     then do;
      309 		ec = error_table_$ai_invalid_range;
      310 		call FAIL ("");
      311 	     end;
      312 
      313 	call hcs_$truncate_seg (vrp, 0, ec); /* initialize registration */
      314 	if ec ^= 0 then call FAIL ("Trouble initializing structure.");
      315 
      316 	if ^lv_already_registered then do;  /* code to register new LV */
      317 
      318 	     if ^pubbit | acs_dir ^= "" then do;	/* Is ACS requested or needed? */
      319 		if acs_dir = "" then do;
      320 		     str_len = length (acs_dir);
      321 		     call ioa_$rsnnl (">udd>^a>^a", acs_dir, str_len, substr(owner, owneri+1), substr (owner, 1, owneri-1));
      322 		     acs_ent = rtrim(lvname)||".acs";
      323 		end;
      324 		else if acs_ent ^= rtrim(lvname)||".acs"
      325 		     then call FAIL ("Invalid ACS path.");
      326 	     end;
      327 
      328 	     /* first let's check with user */
      329 	     call command_query_$yes_no (ans, 0, comname, "",
      330 		"LV ""^a"" does not exist.  Do you wish to create it? ", lvname);
      331 	     if ^ans then do;  /* must've mis-typed LV name */
      332 		call clean_up;
      333 		return;
      334 	     end;
      335 
      336 	     if owner = "" then do;		/* if owner not specified, we'll make it the caller */
      337 		owner = get_group_id_ ();
      338 		i = length(rtrim(owner))-2;
      339 		owner = substr(owner, 1, i);  /* strip off tag */
      340 		owneri = index (owner, ".");
      341 	     end;
      342 
      343 	     /* fill in the registration structure... */
      344 	     volume_registration.version = Volume_Registration_Version_2;
      345 	     if lvid then volume_registration.lvid = lvid;
      346 	     else do;
      347 		fb71 = clock();
      348 		volume_registration.lvid = substr (unspec (fb71), 36, 36);
      349 	     end;
      350 	     volume_registration.lvname = lvname;
      351 	     volume_registration.volume_owner = owner;
      352 	     volume_registration.public = pubbit;
      353 	     volume_registration.access_class_range = access_range;
      354 	     if acs_dir = ""  &  acs_ent = ""
      355 	     then volume_registration.acs_path = "";
      356 	     else volume_registration.acs_path = pathname_ (acs_dir, acs_ent);
      357 	     volume_registration.npv = 1;  /* registering first right now */
      358 
      359 	     /* now, let's get the first PV into the registration */
      360 	     volume_registration.npv = 1;
      361 
      362 	     pvrp = addr (volume_registration.pv(1)); /* use first entry */
      363 	     if pvid then pv_registration.pvid = pvid;
      364 	     else do;
      365 		fb71 = clock();
      366 		pv_registration.pvid = substr (unspec (fb71), 36, 36);
      367 	     end;
      368 	     pv_registration.model = model;
      369 	     pv_registration.pvname = pvname;
      370 	     pv_registration.location = location;
      371 	     pv_registration.mfg_serial = serial;
      372 	     pv_registration.password = "0"b;
      373 	     pv_registration.date_registered = clock ();
      374 
      375 	     call mdc_priv_$add_lvr (lvname, vrp, ec);
      376 	     if ec ^= 0 then call FAIL ("Cannot register: " || lvname);
      377 
      378 	     call ioa_ ("^a: Registered PV ""^a"" (pvid ^w) on new LV ""^a"" lvid ^w).", comname,
      379 		pvname, volume_registration.pv(1).pvid, lvname, volume_registration.lvid);
      380 
      381 	end;
      382 	else do;   /* we'll just add a new PV to an existing LV */
      383 
      384 	     if pvid then pv_registration.pvid = pvid;
      385 	     else do;
      386 		fb71 = clock();
      387 		pv_registration.pvid = substr (unspec (fb71), 36, 36);
      388 	     end;
      389 
      390 	     pv_registration.model = model;	/* Fill in per-pak data */
      391 	     pv_registration.pvname = pvname;
      392 	     pv_registration.location = location;
      393 	     pv_registration.mfg_serial = serial;
      394 	     pv_registration.password = "0"b;
      395 	     pv_registration.date_registered = clock ();
      396 
      397 	     call mdc_priv_$add_pvr (lvname, pvrp, ec);
      398 	     if ec ^= 0 then call FAIL ("Cannot register: " || pvname);
      399 
      400 	     call ioa_ ("^a: Registered PV ""^a"" (pvid ^w) on LV ""^a"".",
      401 		comname, pvname, pvrp->pv_registration.pvid, lvname);
      402 	end;
      403 
      404 	call clean_up;
      405 
      406 	return;
      407 
      408 
      409 change_volume_registration:
      410 change_vol_registration:	/* operator command name - pre MR11 */
      411 cvr:	entry;
      412 
      413 /******************************************************************************
      414*
      415*This is an administrative command which facilitates the adjustment of
      416*volume attributes.  Its syntax is:
      417*
      418*     cvr [-pv | -lv] NAME {PV or LV ATTRIBUTE ARGS}
      419*
      420*Some volume attributes should not be changed when the physical disk medium
      421*has already been initialized.  This is because some attributes (e.g. name
      422*and unique identifier) are written onto the medium label at initialization
      423*and cannot be altered without re-initialization of the medium.
      424*
      425*The code is written like:
      426*
      427*	entry
      428*	setup
      429*	if first arg is "pv" then
      430*	     process args for PV
      431*	     check arg consistancy
      432*	     fill in PV registration structure with changes
      433*	     call inner ring
      434*	else if first arg is "lv" then
      435*	     process args for LV
      436*	     check arg consistancy
      437*	     fill in LV registration structure with changes
      438*	     call inner ring
      439*	else first arg is in error
      440*	cleanup
      441*	exit
      442*
      443*******************************************************************************/
      444 
      445 	call set_up("change_volume_registration");
      446 	on cleanup call clean_up;
      447 
      448 	call getarg (tcs);
      449 
      450 	ec = 0;
      451 
      452 	change_model, change_name, change_uid, change_auth, change_range = "0"b;
      453 
      454 	if tcs = "pv" /* retained for compatability */
      455 	     |  tcs = "-physical_volume"  |  tcs = "-pv" then do;
      456 	     pvrp = vrp;   /* use pv_registration instead of volume_registration */
      457 	     call getarg (pvname);			/* yes */
      458 	     call mdc_priv_$read_pvr (pvname, pvrp, ec);
      459 	     if ec ^= 0 then call FAIL ("PV not found: " || pvname);
      460 
      461 	     do while (more_args);
      462 		call getarg (tcs);			/* Get control arg */
      463 		call getarg (tcs1);			/* .. and value */
      464 		if tcs = "-device_model"  |  tcs = "-model" then do;
      465 		     j = cv_dec_check_ (tcs1, ec2);
      466 		     if ec2 ^= 0 then call FAIL("Invalid model: "||tcs1);
      467 		     else do;
      468 			do model = 1 to hbound (MODEL, 1) while (j ^= MODEL (model)); end;
      469 			if model > hbound (MODEL, 1) then call FAIL("Unknown model: "||tcs1);
      470 			else do;
      471 			     model = MODELX (model);
      472 			     pv_registration.model = model;
      473 			end;
      474 		     end;
      475 		     change_model = "1"b;
      476 		end;
      477 		else if tcs = "-manufacturer_serial"  |  tcs = "-serial"
      478 		     then pv_registration.mfg_serial = tcs1;
      479 		else if tcs = "-location"  |  tcs = "-loc"
      480 		     then pv_registration.location = tcs1;
      481 		else if tcs = "-date_registered"  |  tcs = "-dtr" then do;
      482 		     call convert_date_to_binary_ (tcs1, pv_registration.date_registered, ec);
      483 		     if ec ^= 0 then call FAIL("Bad date: "||tcs1);
      484 		end;
      485 		else if tcs = "-name"  |  tcs = "-nm" then do;
      486 		     if verify (rtrim (tcs1), PVNAME_LEGAL) ^= 0 then call FAIL ("Invalid characters in name: " || tcs1);
      487 		     else pv_registration.pvname = tcs1;
      488 		     change_name = "1"b;
      489 		end;
      490 		else if tcs = "-physical_volume_uid"  |  tcs = "-pvid" then do;
      491 		     fb35 = cv_oct_check_ (tcs1, ec2);
      492 		     b36 = unspec(fb35);
      493 		     if ec2 ^= 0 then call FAIL("Invalid PVID: "||tcs1);
      494 		     else pv_registration.pvid = b36;
      495 		     change_uid = "1"b;
      496 		end;
      497 		/* there is no control arg for changing "password" field */
      498 		else do;
      499 		     ec = error_table_$bad_arg;
      500 		     call FAIL("Bad control arg: "||tcs||" "||tcs1);
      501 		end;
      502 	     end;
      503 
      504 	     if change_model | change_name | change_uid then do;
      505 		call command_query_$yes_no (ans, 0, comname, "",
      506 		     "PV model, name, or uid should not be changed for initialized volumes.  Do you wish to continue? ");
      507 		if ^ans then do;
      508 		     call clean_up;
      509 		     return;
      510 		end;
      511 	     end;
      512 
      513 	     /* now tell ring-1 to do it! */
      514 	     call mdc_priv_$change_pvr (pvname, pvrp, ec);
      515 	     if ec ^= 0 then call FAIL ("Could not make changes.");
      516 
      517 	     call ioa_ ("^a: Changed attributes for PV ""^a"".", comname, pvname);
      518 	end;
      519 	else if tcs = "lv" /* retained for compatability */
      520 	     |  tcs = "-logical_volume"  |  tcs = "-lv"  then do;
      521 	     call getarg (lvname);
      522 	     call mdc_priv_$read_lvr (lvname, vrp, ec);
      523 	     if ec ^= 0 then call FAIL ("LV not registered: " || lvname);
      524 
      525 	     volume_registration.npv = 0;   /* don't care about the PV entries... */
      526 
      527 	     do while (more_args);
      528 		call getarg (tcs);
      529 		call getarg (tcs1);
      530 
      531 		if tcs = "-access_class"  |  tcs = "-acc" then do;
      532 		     call convert_access_class_$from_string_range (access_range, tcs1, ec);
      533 		     if ec ^= 0 then call FAIL (tcs1);
      534 		     change_range = "1"b;
      535 		     volume_registration.access_class_range = access_range;
      536 		end;
      537 		/* -access_low and -access_high retained for compatability
      538*		     with the old operator cvr command */
      539 		else if tcs = "-access_low"  |  tcs = "-ac_low" then do;
      540 		     call convert_access_class_$from_string (access_range(1), tcs1, ec);
      541 		     if ec ^= 0 then call FAIL("Illegal auth: "||tcs1);
      542 		     else volume_registration.access_class_range(1) = access_range(1);
      543 		     change_auth = "1"b;
      544 		end;
      545 		else if tcs = "-access_high"  |  tcs = "-ac_high" then do;
      546 		     call convert_access_class_$from_string (access_range(2), tcs1, ec);
      547 		     if ec ^= 0 then call FAIL("Illegal auth: "||tcs1);
      548 		     else volume_registration.access_class_range(2) = access_range(2);
      549 		     change_auth = "1"b;
      550 		end;
      551 		else if tcs = "-public"  |  tcs = "-pub" then do;
      552 			if tcs1 ^= "yes"  &  tcs1 ^= "y"  &
      553 			   tcs1 ^= "no"   &  tcs1 ^= "n"  then call FAIL("Public argument must be ""yes"" or ""no"".");
      554 			volume_registration.public = ( (tcs1 = "yes") | (tcs1 = "y") );
      555 		     end;
      556 		else if tcs = "-acs_path"  |  tcs = "-acs" then do;
      557 		     if tcs1 ^= "" then do;
      558 			call expand_pathname_$add_suffix (tcs1, "acs", acs_dir, acs_ent, ec);
      559 			if ec ^= 0 then call FAIL("Bad acs path: "||tcs1);
      560 			if acs_ent ^= rtrim(lvname)||".acs" then call FAIL ("Bad acs path: "||tcs1);
      561 			volume_registration.acs_path = pathname_ (acs_dir, acs_ent);
      562 		     end;
      563 		     else do;
      564 			acs_dir = "";
      565 			acs_ent = "";
      566 			volume_registration.acs_path = "";
      567 		     end;
      568 		end;
      569 		else if tcs = "-owner"  |  tcs = "-ow" then do;
      570 		     call check_owner;
      571 		     if owneri = 0 then do;
      572 			ec = error_table_$bad_arg;
      573 			call FAIL("Invalid owner: "||tcs1);
      574 		     end;
      575 		     else volume_registration.volume_owner = owner;
      576 		end;
      577 		else if tcs = "-name"  |  tcs = "-nm" then do;
      578 			if verify (rtrim(tcs1), LVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in LV name.");
      579 			volume_registration.lvname = tcs1;
      580 			change_name = "1"b;
      581 		     end;
      582 		else if tcs = "-logical_volume_uid"  |  tcs = "-lvid" then do;
      583 		     fb35 = cv_oct_check_ (tcs1, ec2);
      584 		     b36 = unspec(fb35);
      585 		     if ec2 ^= 0 then call FAIL("Invalid LVID: "||tcs1);
      586 		     else volume_registration.lvid = b36;
      587 		     change_uid = "1"b;
      588 		end;
      589 		else do;
      590 		     ec = error_table_$badopt;
      591 		     call FAIL(tcs);
      592 		end;
      593 	     end;
      594 
      595 	     if change_auth then
      596 		if ^aim_check_$greater_or_equal (volume_registration.access_class_range(2),
      597 						volume_registration.access_class_range(1))
      598 		then do;
      599 		     ec = error_table_$ai_invalid_range;
      600 		     call FAIL ("");
      601 		end;
      602 
      603 	     if change_range | change_auth | change_name | change_uid then do;
      604 		call command_query_$yes_no (ans, 0, comname, "",
      605 		     "LV access class, name, or uid should not be changed for initialized volumes.  Do you wish to continue? ");
      606 		if ^ans then do;
      607 		     call clean_up;
      608 		     return;
      609 		end;
      610 	     end;
      611 
      612 	     /* now get ring-1 to make the changes */
      613 	     call mdc_priv_$change_lvr (lvname, vrp, ec);
      614 	     if ec ^= 0 then call FAIL ("Unable to make changes.");
      615 
      616 	     call ioa_ ("^a: Changed attributes of LV ""^a"".", comname, lvname);
      617 	end;
      618 
      619 	else do;
      620 	     ec = error_table_$badopt;
      621 	     call FAIL ("First arg must be ""-pv"" or ""-lv"".");
      622 	end;
      623 
      624 	call clean_up;
      625 
      626 	return;
      627 
      628 
      629 delete_volume_registration:
      630 del_vol_registration:	/* operator command name - pre MR11 */
      631 dvr:      entry;
      632  
      633 /******************************************************************************
      634*
      635*This is an administrative command used to remove the registration of a logical
      636*or physical volume.  Its syntax is:
      637*
      638*     dvr [-lv | -pv] NAME
      639*
      640*Physical volumes should only be deregistered when their contents have been
      641*moved onto other physical volumes (within the same logical volume).
      642*Logical volumes should only be deregistered when their corresponding directory
      643*hierearchies have been removed from the system (thus leaving the whole LV
      644*empty).  Since a logical volume must always have at least one
      645*physical volume, the last PV in an LV may not be deleted from the LV, the
      646*LV itself must be deleted.
      647*
      648*The code is written like:
      649*
      650*	entry
      651*	setup
      652*	if first arg is "pv" then
      653*	     check existance of PV
      654*	     get name of PV's LV
      655*	     check LV for more than one PV
      656*	     call inner ring to delete PV
      657*	else if first arg is "lv" then
      658*	     check existance of LV
      659*	     list names of PVs being deleted with the LV
      660*	     call inner ring to delete LV
      661*	else first arg is invalid
      662*	cleanup
      663*	exit
      664*
      665*******************************************************************************/
      666 
      667 	call set_up("delete_volume_registration");
      668 	on cleanup call clean_up;
      669 
      670 	call getarg (tcs);
      671 
      672 	ec = 0;
      673 
      674 	if tcs = "pv"  /* retained for compatability */
      675 	     |  tcs = "-physical_volume"  |  tcs = "-pv"  then do;
      676 	     call getarg (pvname);
      677 	     if verify (rtrim(pvname), PVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in PV name.");
      678 
      679 	     call mdc_priv_$read_pvr (pvname, pvrp, ec);
      680 	     if ec ^= 0 then call FAIL ("PV not found: " || pvname);
      681 
      682 	     call mdc_$find_volname ((pv_registration.pvid), pvname, lvname, ec);
      683 	     if ec ^= 0 then call FAIL ("Unable to get LV name.");
      684 	     call mdc_priv_$read_lvr (lvname, vrp, ec);
      685 	     if ec ^= 0 then call FAIL ("Unable to get LV data.");
      686 
      687 	     if volume_registration.npv = 1 then do;
      688 		str_len = length (temp_str);
      689 		call ioa_$rsnnl ("PV ""^a"" is last in LV ""^a"".  User ""dvr lv ^a"".", temp_str, str_len, pvname, lvname, lvname);
      690 		call FAIL (temp_str);
      691 	     end;
      692 
      693 	     call mdc_priv_$delete_pvr (pvname, ec);
      694 	     if ec ^= 0 then call FAIL ("Cannot delete: " || pvname);
      695 
      696 	     call ioa_ ("^a: Deleted PV ""^a"" from LV ""^a"".", comname, pvname, lvname);
      697 	end;
      698 	else if tcs = "lv"  /* retained for compatability */
      699 	     |  tcs = "-logical_volume"  |  tcs = "-lv"  then do;
      700 	     call getarg (lvname);
      701 	     if verify(rtrim(lvname), LVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in LV name.");
      702 
      703 	     call mdc_priv_$read_lvr (lvname, vrp, ec);
      704 	     if ec ^= 0 then call FAIL ("LV not registered: " || lvname);
      705 
      706 	     do i = 1 to volume_registration.npv;
      707 		call ioa_ ("^a: Deleting PV ""^a"" from LV ""^a"".", comname, volume_registration.pv (i).pvname, lvname);
      708 	     end;
      709 
      710 	     call mdc_priv_$delete_lvr (lvname, ec);
      711 	     if ec ^= 0 then call FAIL ("Cannot modify: " || lvname);
      712 
      713 	     call ioa_ ("^a: Deleted LV ""^a"".", comname, lvname);
      714 	end;
      715 	else do;
      716 	     ec = error_table_$badopt;
      717 	     call FAIL ("First arg must be ""-pv"" or ""-lv"".");
      718 	end;
      719 
      720 	call clean_up;
      721 
      722 	return;
      723 
      724 
      725 list_volume_registration:
      726 list_vol_registration:	/* operator command name - pre MR11 */
      727 lvr:	entry;
      728 
      729 /******************************************************************************
      730*
      731*This is an administrative command which lists the attributes of the specified
      732*logical or physical volume.  Its syntax is:
      733*
      734*     lvr [-pv | -lv] NAME {-brief}
      735*
      736*When listing a logical volume, all physical volumes in that logical volume
      737*will be listed unless "-brief" is given.
      738*
      739*The code is written like:
      740*
      741*	entry
      742*	setup
      743*	if first arg is "pv" then
      744*	     call inner ring for PV registration structure
      745*	     format report of PV and print
      746*	else if first arg is "lv" then
      747*	     call inner ring for LV registration structure
      748*		(including all PVs in that LV)
      749*	     if brief arg not given then
      750*		format report of LV and print
      751*	     if brief arg given then
      752*		print only the PV names
      753*	     else format report of each PV and print
      754*	else first arg is invalid
      755*	cleanup
      756*	exit
      757*
      758*******************************************************************************/
      759 
      760 	call set_up("list_volume_registration");
      761 	on cleanup call clean_up;
      762 
      763 	call getarg (tcs);
      764 
      765 	if tcs = "pv"  /* retained for compatability */
      766 	     |  tcs = "-physical_volume"  |  tcs = "-pv"  then do;
      767 	     call getarg (pvname);
      768 	     if verify(rtrim(pvname), PVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in PV name.");
      769 
      770 	     call mdc_priv_$read_pvr (pvname, vrp, ec);
      771 	     if ec ^= 0 then call FAIL ("PV not found: " || pvname);
      772 
      773 	     call mdc_$find_volname ((pv_registration.pvid), pvname, lvname, ec);
      774 	     if ec ^= 0 then call FAIL ("Unable to get LV name.");
      775 
      776 	     call ioa_ ("^/pvname:^-^a", pv_registration.pvname);
      777 	     call ioa_ ("pvid:^-^-^w  (^a)", pv_registration.pvid, unique_chars_((pv_registration.pvid)));
      778 	     call ioa_ ("serial:^-^-^a", pv_registration.mfg_serial);
      779 	     call ioa_ ("model:^-^-^d", MODELN (pv_registration.model));
      780 	     call ioa_ ("location:^-^-^a", pv_registration.location);
      781 	     dt_str = date_time_$format ("date_time", pv_registration.date_registered, "", "");
      782 	     call ioa_ ("date registered:^-^a", dt_str);
      783 	     /* password field not printed */
      784 	     call ioa_ ("lvname:^-^-^a", lvname);
      785 	end;
      786 	else if tcs = "lv"  /* retained for compatability */
      787 	     |  tcs = "-logical_volume"  |  tcs = "-lv"  then do;
      788 	     call getarg (lvname);
      789 	     if verify(rtrim(lvname), LVNAME_LEGAL) ^= 0 then call FAIL("Illegal characters in LV name.");
      790 
      791 	     call mdc_priv_$read_lvr (lvname, vrp, ec);
      792 	     if ec ^= 0 then call FAIL ("LV not registered: " || lvname);
      793 	     call getarg (tcs);
      794 	     if tcs ^= "-bf" & tcs ^= "-brief" then do;
      795 		call ioa_ ("^/lvname:^-^a", lvname);
      796 		call ioa_ ("lvid:^-^-^w  (^a)", volume_registration.lvid, unique_chars_((volume_registration.lvid)));
      797 		call ioa_ ("public:^-^-^a", YESNO (fixed (volume_registration.public, 1)));
      798 		call ioa_ ("owner:^-^-^a", volume_registration.volume_owner);
      799 		aa_string = convert_aim_attributes_ (volume_registration.access_class_range(1));
      800 		call convert_access_class_$to_string_short (volume_registration.access_class_range(1), auth_mnemonics, ec);
      801 		if ec ^= 0 then do;
      802 		     call com_err_ (ec, comname, "Unable to convert min auth to name string.");
      803 		     auth_mnemonics = "system_low?";
      804 		end;
      805 		call ioa_ ("min_access_class:^-^a (^a)", aa_string, auth_mnemonics);
      806 		aa_string = convert_aim_attributes_ (volume_registration.access_class_range(2));
      807 		call convert_access_class_$to_string_short (volume_registration.access_class_range(2), auth_mnemonics, ec);
      808 		if ec ^= 0 then do;
      809 		     call com_err_ (ec, comname, "Unable to convert max auth to name string.");
      810 		     auth_mnemonics = "system_high?";
      811 		end;
      812 		call ioa_ ("max_access_class:^-^a (^a)", aa_string, auth_mnemonics);
      813 		call ioa_ ("acs_path:^-^-^a", volume_registration.acs_path);
      814 		call ioa_ ("^/npv:^-^-^d", volume_registration.npv);
      815 	     end;
      816 	     do i = 1 to volume_registration.npv;
      817 		pvrp = addr(volume_registration.pv(i));
      818 
      819 		if tcs = "-bf" | tcs = "-brief"
      820 		then call ioa_ ("^a", pv_registration.pvname);
      821 		else do;
      822 		     call ioa_ ("^/ pvname:^-^a", pv_registration.pvname);
      823 		     call ioa_ (" pvid:^-^-^w  (^a)", pv_registration.pvid, unique_chars_((pv_registration.pvid)));
      824 		     call ioa_ (" serial:^-^-^a", pv_registration.mfg_serial);
      825 		     call ioa_ (" model:^-^-^d", MODELN (pv_registration.model));
      826 		     call ioa_ (" location:^-^a", pv_registration.location);
      827 		     dt_str = date_time_$format ("date_time", pv_registration.date_registered, "", "");
      828 		     call ioa_ (" date registered:^-^a", dt_str);
      829 		     /* password field not printed */
      830 		end;
      831 	     end;
      832 	end;
      833 	else do;
      834 	     ec = error_table_$badopt;
      835 	     call FAIL ("First arg must be ""-pv"" or ""-lv"".");
      836 	end;
      837 
      838 	call ioa_ ("");
      839 
      840 	call clean_up;
      841 
      842 	return;
      843 
      844 
      845 /* -------------- UTILITY ROUTINES ---------------------- */
      846 /* ------------------------------------------------------ */
      847 
      848 set_up:   proc (name);	/* initializations for all entrypoints */
      849 
      850 dcl  name		char (*);
      851 
      852 	comname = name;
      853 	ec = 0;
      854 	temp_ptr, vrp, pvrp = null();
      855 	call get_temp_segment_ (comname, temp_ptr, ec);
      856 	if ec ^= 0 then call FAIL ("Trouble getting temporary segment.");
      857 	vrp, pvrp = temp_ptr;  /* we'll use temp for either structure */
      858 
      859 	return;
      860 
      861 end set_up;
      862 
      863 /* ------------------------------------------------------ */
      864 
      865 clean_up:	proc ();		/* clean up our external mess... */
      866 
      867 dcl  tptr     ptr;
      868 
      869 	if temp_ptr ^= null ()
      870 	then do;
      871 	     tptr = temp_ptr;
      872 	     temp_ptr = null ();   /* so we don't try this again */
      873 	     call release_temp_segment_ (comname, temp_ptr, ec);
      874 	end;
      875 
      876 	return;
      877 
      878 end clean_up;
      879 
      880 /* ------------------------------------------------------ */
      881 
      882 getarg:	proc (x);		/* get next argument on command line */
      883 
      884 dcl  x char (*);
      885 dcl  errc fixed bin (35);
      886 
      887 	call cu_$arg_ptr (argno, ap, al, errc);
      888 	if errc = 0 then do;
      889 	     if al > length(x) then call FAIL ("Argument too long");
      890 	     x = bchr;
      891 	end;
      892 	else x = "";
      893 	argno = argno + 1;
      894 	call cu_$arg_ptr (argno, ap, al, errc);
      895 	if errc ^= 0 | bchr = "" then more_args = "0"b;
      896 
      897 	return;
      898 
      899 end getarg;
      900 
      901 /* ------------------------------------------------------ */
      902 
      903 FAIL:     proc (x);		/* come here when something bad happens */
      904 
      905 dcl  x char (*);
      906 
      907 	call com_err_ (ec, comname, "^a", x);
      908 	call clean_up;
      909 	go to BUST;
      910 
      911 end FAIL;
      912 
      913 BUST:	return;		/* return from this module */
      914 
      915 /* ------------------------------------------------------ */
      916 
      917 check_owner: proc;		/* validates Person_ID.Project_ID */
      918 
      919 	owneri = index (tcs1, ".");
      920 	if owneri = 0 then return;
      921 	if index (substr (tcs1, owneri+1), ".") ^= 0 then owneri = 0;
      922 	else owner = tcs1;
      923 
      924 	return;
      925 
      926 end check_owner;
      927 
  1     1 /* BEGIN INCLUDE FILE  ...  volume_registration.incl.pl1 */
  1     2 
  1     3 /* Modified 07/27/84 by EJ Sharpe to make pv_registration a
  1     4*		separate structure.  Also renamed "hvid" to "lvid"
  1     5*		and "hvname" to "lvname".
  1     6*   Modified 84-11-06 by EJ Sharpe to combine (max min)_access_class into
  1     7*		access_class_range (2) bit (72) and add version constant
  1     8*		Also changed version constant from 1 to 2.
  1     9**/
  1    10 
  1    11 dcl  vrp ptr;
  1    12 dcl  pvrp ptr;
  1    13 
  1    14 dcl 1 volume_registration aligned based (vrp),
  1    15     2 version fixed bin,				/* Version number of this dcl */
  1    16     2 lvid bit (36),				/* Logical volume unique ID */
  1    17     2 lvname char (32),				/* Logical volume name */
  1    18     2 access_class_range (2) bit (72),			/* Range of authorizations that may use the vol */
  1    19     2 volume_owner char (32),				/* Person.Project */
  1    20     2 acs_path char (168),				/* Path name of ACS */
  1    21     2 flags,
  1    22       3 public bit (1) unal,				/* TRUE if public volume */
  1    23       3 pad bit (35) unal,
  1    24     2 npv fixed bin,				/* Number of physical volumes */
  1    25     2 pv (0 refer (volume_registration.npv)) like pv_registration;
  1    26 
  1    27 
  1    28 dcl 1 pv_registration aligned based (pvrp),
  1    29       2 pvid bit (36),				/* Physical volume unique ID */
  1    30       2 model fixed bin,				/* Model number */
  1    31       2 pvname char (32),				/* Physical volume name */
  1    32       2 location char (32),				/* Where to find volume */
  1    33       2 mfg_serial char (32),				/* Manufacturer's serial no, etc */
  1    34       2 date_registered fixed bin (71),			/* Date and time registered */
  1    35       2 password bit (2);
  1    36 
  1    37 dcl Volume_Registration_Version_2	fixed bin init (2) static options (constant);
  1    38 
  1    39 /* END INCLUDE FILE    ...  volume_registration.incl.pl1 */
      928 
      929 
  2     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  2     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  2     6*     Add support for FIPS
  2     7*     3380.
  2     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  2     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  2    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  2    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  2    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  2    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 /* Modified 5/19/76 by N. I. Morris */
  2    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  2    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  2    19 /* Modified '82 by BIM for needs_alt_part */
  2    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  2    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  2    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  2    23*   volmap and record stock can be expanded. */
  2    24 
  2    25 /*
  2    26********************************************************************************
  2    27**							        *
  2    28**                           WARNING:                                          *
  2    29**							        *
  2    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  2    31**   type is added.						        *
  2    32**							        *
  2    33**   There are other include files that contain arrays indexed by the device   *
  2    34**   index obtained by references to MODELX or MODELN in this include file.    *
  2    35**   These must be modified when a new device type is added:		        *
  2    36**   disk_pack.incl.pl1					        *
  2    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  2    38**							        *
  2    39********************************************************************************
  2    40**/
  2    41 
  2    42 
  2    43 dcl (maxdevt init (9),				/* maximum legal devt */
  2    44      bulkdevt init (1),				/* bulk store devt */
  2    45      msu0500devt init (2),				/* MSU0500 device type */
  2    46      msu0451devt init (3),				/* MSU0451 device type */
  2    47      msu0450devt init (3),				/* MSU0450 device type */
  2    48      msu0400devt init (4),				/* MSU0400 device type */
  2    49      dsu191devt init (4),				/* DSU191 device type */
  2    50      dsu190devt init (5),				/* DSU190 device type */
  2    51      dsu181devt init (6),				/* DSU181 device type */
  2    52      msu0501devt init (7),				/* MSU0501 device type */
  2    53      fips3380devt init (8),				/* 3380D FIPS device type */
  2    54      fips3381devt init (9)				/* 3380E FIPS device type */
  2    55      ) fixed bin (4) static options (constant);
  2    56 
  2    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  2    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  2    59 
  2    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  2    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  2    62 
  2    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  2    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  2    65 
  2    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  2    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  2    68 
  2    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  2    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  2    71 
  2    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  2    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  2    74 
  2    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  2    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  2    77 
  2    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  2    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  2    80 
  2    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  2    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  2    83 
  2    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  2    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  2    86 
  2    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  2    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  2    89 
  2    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  2    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  2    92 
  2    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  2    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  2    95 
  2    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  2    97      ("abc");
  2    98 
  2    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  2   100      init ("a","b","c");
  2   101 
  2   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  2   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  2   104 
  2   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  2   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  2   107 
  2   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  2   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  2   110 
  2   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  2   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  2   113 
  2   114 
  2   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  2   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  2   117 
  2   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  2   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  2   120 
  2   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  2   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  2   123 
  2   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  2   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  2   126 
  2   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  2   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  2   129 
  2   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  2   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  2   132 
  2   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  2   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  2   135 
  2   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  2   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  2   138 
  2   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  2   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  2   141 
  3     1 /* Begin fs_dev_types_sector.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  3     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  3     7*     Add the sector differance for devices that do 64 word IO and devices that
  3     8*     do 512 word IO.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  3    12*	 need all the data in fs_dev_types. This is also included in
  3    13*	 fs_dev_types.incl.pl1  */
  3    14 
  3    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  3    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  3    17 
  3    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  3    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  3    20 
  3    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  3    22  /* table of # of sectors per record on each device */
  3    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  3    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  3    25 
  3    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  3    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  3    28 	
  3    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  3    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  3    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  3    32 
  3    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  3    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  3    35 
  3    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  3    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  3    38 
  3    39 /* End fs_dev_types_sector.incl.pl1 */
  3    40 
  2   142 
  2   143 
  2   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      930 
      931 
      932 
      933 /* ------------------------------------------------------ */
      934 /* ------------------------------------------------------ */
      935 end volume_registration_cmds_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0803.3  volume_registration_cmds_.pl1     >spec>install>1111>volume_registration_cmds_.pl1
928          1    11/20/84  1944.9  volume_registration.incl.pl1      >ldd>include>volume_registration.incl.pl1
930          2    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
2-142        3    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LVNAME_LEGAL                    000041 constant        char(76)                 initial packed unaligned dcl 93 ref 213 578 701 789
MODEL                           000025 constant        fixed bin(17,0)          initial array dcl 2-57 ref 271 271 272 468 468 469
MODELN                          000000 constant        fixed bin(17,0)          initial array dcl 2-63 set ref 779* 825*
MODELX                          000011 constant        fixed bin(17,0)          initial array dcl 2-60 ref 273 471
PVNAME_LEGAL                    000064 constant        char(37)                 initial packed unaligned dcl 91 ref 202 486 677 768
Volume_Registration_Version_2          constant        fixed bin(17,0)          initial dcl 1-37 ref 344
YESNO                           000010 internal static char(3)                  initial array packed unaligned dcl 90 set ref 797*
aa_string                       000266 automatic       char(32)                 dcl 53 set ref 799* 805* 806* 812*
access_class_range       12            based           bit(72)                  array level 2 dcl 1-14 set ref 353* 535* 542* 548*
                                                                                  595* 595* 799* 800* 806* 807*
access_range                    000367 automatic       bit(72)                  initial array dcl 60 set ref 60* 60* 216* 222* 227*
                                                                                  306* 306* 353 532* 535 540* 542 546* 548
acs_dir                         000400 automatic       char(168)                initial packed unaligned dcl 66 set ref 66* 246*
                                                                                  250* 298 318 319 320 321* 354 356* 558* 561* 564*
acs_ent                         000452 automatic       char(32)                 initial packed unaligned dcl 67 set ref 67* 246*
                                                                                  251* 322* 324 354 356* 558* 560 561* 565*
acs_path                 26            based           char(168)                level 2 dcl 1-14 set ref 354* 356* 561* 566* 813*
addr                                                   builtin function         dcl 98 ref 362 817
aim_check_$greater_or_equal     000024 constant        entry                    external dcl 121 ref 306 595
al                              000102 automatic       fixed bin(21,0)          dcl 40 set ref 887* 889 890 894* 895
ans                             000462 automatic       bit(1)                   packed unaligned dcl 68 set ref 329* 331 505* 507
                                                                                  604* 606
ap                              000100 automatic       pointer                  dcl 39 set ref 887* 890 894* 895
argno                           000466 automatic       fixed bin(17,0)          initial dcl 71 set ref 71* 887* 893* 893 894*
auth_mnemonics                  000276 automatic       char(172)                packed unaligned dcl 54 set ref 800* 803* 805* 807*
                                                                                  810* 812*
b36                             000351 automatic       bit(36)                  initial dcl 55 set ref 55* 492* 494 584* 586
bchr                                   based           char                     packed unaligned dcl 41 ref 890 895
change_auth                     000515 automatic       bit(1)                   packed unaligned dcl 80 set ref 452* 543* 549* 595
                                                                                  603
change_model                    000512 automatic       bit(1)                   packed unaligned dcl 77 set ref 452* 475* 504
change_name                     000513 automatic       bit(1)                   packed unaligned dcl 78 set ref 452* 488* 504 580*
                                                                                  603
change_range                    000516 automatic       bit(1)                   packed unaligned dcl 81 set ref 452* 534* 603
change_uid                      000514 automatic       bit(1)                   packed unaligned dcl 79 set ref 452* 495* 504 587*
                                                                                  603
cleanup                         000622 stack reference condition                dcl 110 ref 188 446 668 761
clock                                                  builtin function         dcl 98 ref 347 365 373 386 395
com_err_                        000026 constant        entry                    external dcl 122 ref 802 809 907
command_query_$yes_no           000062 constant        entry                    external dcl 136 ref 329 505 604
comname                         000256 automatic       char(32)                 initial packed unaligned dcl 52 set ref 16* 52* 329*
                                                                                  378* 400* 505* 517* 604* 616* 696* 707* 713* 802*
                                                                                  809* 852* 855* 873* 907*
convert_access_class_$from_string
                                000030 constant        entry                    external dcl 123 ref 222 227 540 546
convert_access_class_$from_string_range
                                000032 constant        entry                    external dcl 124 ref 216 532
convert_access_class_$to_string_short
                                000034 constant        entry                    external dcl 125 ref 800 807
convert_aim_attributes_         000036 constant        entry                    external dcl 126 ref 799 806
convert_date_to_binary_         000040 constant        entry                    external dcl 127 ref 482
cu_$arg_ptr                     000046 constant        entry                    external dcl 130 ref 887 894
cv_dec_check_                   000042 constant        entry                    external dcl 128 ref 269 465
cv_oct_check_                   000044 constant        entry                    external dcl 129 ref 255 264 491 583
date_registered          32            based           fixed bin(71,0)          level 2 dcl 1-28 set ref 373* 395* 482* 781* 827*
date_time_$format               000050 constant        entry                    external dcl 131 ref 781 827
dt_str                          000123 automatic       char(24)                 packed unaligned dcl 45 set ref 781* 782* 827* 828*
ec                              000517 automatic       fixed bin(35,0)          initial dcl 82 set ref 16* 82* 192* 196* 216* 217
                                                                                  222* 223 227* 228 238* 246* 247 281* 288* 295* 296
                                                                                  302* 303 304* 309* 313* 314 375* 376 397* 398 450*
                                                                                  458* 459 482* 483 499* 514* 515 522* 523 532* 533
                                                                                  540* 541 546* 547 558* 559 572* 590* 599* 613* 614
                                                                                  620* 672* 679* 680 682* 683 684* 685 693* 694 703*
                                                                                  704 710* 711 716* 770* 771 773* 774 791* 792 800*
                                                                                  801 802* 807* 808 809* 834* 853* 855* 856 873*
                                                                                  907*
ec2                             000520 automatic       fixed bin(35,0)          initial dcl 83 set ref 83* 255* 257 264* 266 269*
                                                                                  270 465* 466 491* 493 583* 585
errc                            000656 automatic       fixed bin(35,0)          dcl 885 set ref 887* 888 894* 895
error_table_$ai_invalid_range   000012 external static fixed bin(35,0)          dcl 112 ref 309 599
error_table_$bad_arg            000016 external static fixed bin(35,0)          dcl 114 ref 238 499 572
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 113 ref 196 281 590 620 716 834
error_table_$noarg              000020 external static fixed bin(35,0)          dcl 115 ref 288
expand_pathname_$add_suffix     000052 constant        entry                    external dcl 132 ref 246 558
fb35                            000352 automatic       fixed bin(35,0)          dcl 56 set ref 255* 256 264* 265 491* 492 583* 584
fb71                            000354 automatic       fixed bin(71,0)          dcl 57 set ref 347* 348 365* 366 386* 387
fixed                                                  builtin function         dcl 98 ref 797
flags                   100            based           structure                level 2 dcl 1-14
gave_access_high                000374 automatic       bit(1)                   initial packed unaligned dcl 62 set ref 62* 229* 298
                                                                                  306
gave_access_low                 000373 automatic       bit(1)                   initial packed unaligned dcl 61 set ref 61* 224* 298
                                                                                  306
gave_public                     000375 automatic       bit(1)                   initial packed unaligned dcl 63 set ref 63* 242* 298
get_group_id_                   000112 constant        entry                    external dcl 148 ref 337
get_temp_segment_               000054 constant        entry                    external dcl 133 ref 855
hbound                                                 builtin function         dcl 98 ref 271 272 468 469
hcs_$truncate_seg               000060 constant        entry                    external dcl 135 ref 313
i                               000463 automatic       fixed bin(17,0)          dcl 69 set ref 269* 271 338* 339 706* 707* 816* 817*
index                                                  builtin function         dcl 98 ref 340 919 921
ioa_                            000114 constant        entry                    external dcl 149 ref 378 400 517 616 696 707 713 776
                                                                                  777 778 779 780 782 784 795 796 797 798 805 812
                                                                                  813 814 819 822 823 824 825 826 828 838
ioa_$rsnnl                      000116 constant        entry                    external dcl 150 ref 321 689
j                               000464 automatic       fixed bin(17,0)          dcl 69 set ref 465* 468
length                                                 builtin function         dcl 98 ref 320 338 688 889
location                        000113 automatic       char(32)                 initial packed unaligned dcl 44 in procedure "vrc_"
                                                                                  set ref 44* 277* 370 392
location                 12            based           char(32)                 level 2 in structure "pv_registration" dcl 1-28
                                                                                  in procedure "vrc_" set ref 370* 392* 479* 780*
                                                                                  826*
lv_already_registered           000376 automatic       bit(1)                   initial packed unaligned dcl 64 set ref 64* 296* 298
                                                                                  316
lvid                      1            based           bit(36)                  level 2 in structure "volume_registration" dcl 1-14
                                                                                  in procedure "vrc_" set ref 345* 348* 378* 586*
                                                                                  796* 796 796
lvid                            000142 automatic       bit(36)                  initial dcl 48 in procedure "vrc_" set ref 48* 256*
                                                                                  298 345 345
lvname                    2            based           char(32)                 level 2 in structure "volume_registration" dcl 1-14
                                                                                  in procedure "vrc_" set ref 350* 579*
lvname                          000132 automatic       char(32)                 initial packed unaligned dcl 47 in procedure "vrc_"
                                                                                  set ref 47* 212* 213 292 295* 322 324 329* 350
                                                                                  375* 376 378* 397* 400* 521* 522* 523 560 613*
                                                                                  616* 682* 684* 689* 689* 696* 700* 701 703* 704
                                                                                  707* 710* 711 713* 773* 784* 788* 789 791* 792
                                                                                  795*
mdc_$find_volname               000104 constant        entry                    external dcl 145 ref 682 773
mdc_priv_$add_lvr               000100 constant        entry                    external dcl 143 ref 375
mdc_priv_$add_pvr               000102 constant        entry                    external dcl 144 ref 397
mdc_priv_$change_lvr            000064 constant        entry                    external dcl 137 ref 613
mdc_priv_$change_pvr            000066 constant        entry                    external dcl 138 ref 514
mdc_priv_$delete_lvr            000070 constant        entry                    external dcl 139 ref 710
mdc_priv_$delete_pvr            000072 constant        entry                    external dcl 140 ref 693
mdc_priv_$read_lvr              000074 constant        entry                    external dcl 141 ref 295 522 684 703 791
mdc_priv_$read_pvr              000076 constant        entry                    external dcl 142 ref 302 458 679 770
mfg_serial               22            based           char(32)                 level 2 dcl 1-28 set ref 371* 393* 477* 778* 824*
model                     1            based           fixed bin(17,0)          level 2 in structure "pv_registration" dcl 1-28
                                                                                  in procedure "vrc_" set ref 368* 390* 472* 779 825
model                           000511 automatic       fixed bin(17,0)          initial dcl 76 in procedure "vrc_" set ref 76* 271*
                                                                                  271* 272 273* 273 286 368 390 468* 468* 469 471*
                                                                                  471 472
more_args                       000465 automatic       bit(1)                   initial packed unaligned dcl 70 set ref 70* 204 461
                                                                                  527 895*
name                                   parameter       char                     packed unaligned dcl 850 ref 848 852
new_lv                          000377 automatic       bit(1)                   initial packed unaligned dcl 65 set ref 65*
npv                     101            based           fixed bin(17,0)          level 2 dcl 1-14 set ref 357* 360* 525* 687 706 814*
                                                                                  816
null                                                   builtin function         dcl 98 ref 51 854 869 872
old_lvid                        000356 automatic       bit(36)                  initial packed unaligned dcl 58 set ref 58*
old_lvname                      000357 automatic       char(32)                 initial packed unaligned dcl 59 set ref 59*
owner                           000500 automatic       char(32)                 initial packed unaligned dcl 74 set ref 74* 298 321
                                                                                  321 321 321 336 337* 338 339* 339 340 351 575 922*
owneri                          000510 automatic       fixed bin(17,0)          dcl 75 set ref 233 321 321 321 321 340* 571 919* 920
                                                                                  921 921*
password                 34            based           bit(2)                   level 2 dcl 1-28 set ref 372* 394*
pathname_                       000106 constant        entry                    external dcl 146 ref 356 561
pubbit                          000477 automatic       bit(1)                   initial packed unaligned dcl 73 set ref 73* 241* 318
                                                                                  352
public                  100            based           bit(1)                   level 3 packed packed unaligned dcl 1-14 set ref
                                                                                  352* 554* 797
pv                      102            based           structure                array level 2 dcl 1-14 set ref 362 817
pv_registration                        based           structure                level 1 dcl 1-28
pvid                    102            based           bit(36)                  array level 3 in structure "volume_registration"
                                                                                  dcl 1-14 in procedure "vrc_" set ref 378*
pvid                                   based           bit(36)                  level 2 in structure "pv_registration" dcl 1-28
                                                                                  in procedure "vrc_" set ref 363* 366* 384* 387*
                                                                                  400* 494* 682 773 777* 777 777 823* 823 823
pvid                            000131 automatic       bit(36)                  initial dcl 46 in procedure "vrc_" set ref 46* 265*
                                                                                  363 363 384 384
pvname                  104            based           char(32)                 array level 3 in structure "volume_registration"
                                                                                  dcl 1-14 in procedure "vrc_" set ref 707*
pvname                    2            based           char(32)                 level 2 in structure "pv_registration" dcl 1-28
                                                                                  in procedure "vrc_" set ref 369* 391* 487* 776*
                                                                                  819* 822*
pvname                          000103 automatic       char(32)                 initial packed unaligned dcl 43 in procedure "vrc_"
                                                                                  set ref 43* 200* 201 202 202 302* 303 369 378* 391
                                                                                  398 400* 457* 458* 459 514* 517* 676* 677 679* 680
                                                                                  682* 689* 693* 694 696* 767* 768 770* 771 773*
pvrp                            000632 automatic       pointer                  dcl 1-12 set ref 362* 363 366 368 369 370 371 372
                                                                                  373 384 387 390 391 392 393 394 395 397* 400 456*
                                                                                  458* 472 477 479 482 487 494 514* 679* 682 773 776
                                                                                  777 777 777 778 779 780 781 817* 819 822 823 823
                                                                                  823 824 825 826 827 854* 857*
release_temp_segment_           000056 constant        entry                    external dcl 134 ref 873
rtrim                                                  builtin function         dcl 98 ref 202 213 322 324 338 486 560 578 677 701
                                                                                  768 789
seek_command                    000634 automatic       bit(6)                   initial array packed unaligned dcl 2-84 set ref
                                                                                  2-84* 2-84* 2-84* 2-84* 2-84* 2-84* 2-84* 2-84*
                                                                                  2-84*
serial                          000467 automatic       char(32)                 initial packed unaligned dcl 72 set ref 72* 275* 371
                                                                                  393
str_len                         000621 automatic       fixed bin(21,0)          dcl 85 set ref 320* 321* 688* 689*
substr                                                 builtin function         dcl 98 ref 321 321 321 321 339 348 366 387 921
sys_info$access_class_ceiling   000022 external static bit(72)                  dcl 117 ref 60
tcs                             000143 automatic       char(32)                 initial packed unaligned dcl 49 set ref 49* 190* 194
                                                                                  194 194 205* 211 211 215 215 221 221 226 226 231
                                                                                  231 235 235 244 244 254 254 263 263 268 268 275
                                                                                  275 277 277 282* 448* 454 454 454 462* 464 464 477
                                                                                  477 479 479 481 481 485 485 490 490 500 519 519
                                                                                  519 528* 531 531 539 539 545 545 551 551 556 556
                                                                                  569 569 577 577 582 582 591* 670* 674 674 674 698
                                                                                  698 698 763* 765 765 765 786 786 786 793* 794 794
                                                                                  819 819
tcs1                            000153 automatic       char(256)                initial packed unaligned dcl 50 set ref 50* 206* 212
                                                                                  216* 217* 222* 223 227* 228 233 236 236 236 236
                                                                                  241 241 245 246* 247 255* 257 264* 266 269* 270
                                                                                  272 275 277 463* 465* 466 469 477 479 482* 483 486
                                                                                  486 487 491* 493 500 529* 532* 533* 540* 541 546*
                                                                                  547 552 552 552 552 554 554 557 558* 559 560 573
                                                                                  578 579 583* 585 919 921 922
temp_ptr                        000254 automatic       pointer                  initial dcl 51 set ref 51* 854* 855* 857 869 871
                                                                                  872* 873*
temp_str                        000521 automatic       char(256)                packed unaligned dcl 84 set ref 688 689* 690*
tptr                            000100 automatic       pointer                  dcl 867 set ref 871*
unique_chars_                   000110 constant        entry                    external dcl 147 ref 777 777 796 796 823 823
unspec                                                 builtin function         dcl 98 ref 256 265 348 366 387 492 584
verify                                                 builtin function         dcl 98 ref 202 213 486 578 677 701 768 789
version                                based           fixed bin(17,0)          level 2 dcl 1-14 set ref 344*
volume_owner             16            based           char(32)                 level 2 dcl 1-14 set ref 351* 575* 798*
volume_registration                    based           structure                level 1 dcl 1-14
vrp                             000630 automatic       pointer                  dcl 1-11 set ref 295* 302* 313* 344 345 348 350 351
                                                                                  352 353 354 356 357 360 362 375* 378 378 456 522*
                                                                                  525 535 542 548 554 561 566 575 579 586 595 595
                                                                                  613* 684* 687 703* 706 707 770* 791* 796 796 796
                                                                                  797 798 799 800 806 807 813 814 816 817 854* 857*
x                                      parameter       char                     packed unaligned dcl 884 in procedure "getarg" set
                                                                                  ref 882 889 890* 892*
x                                      parameter       char                     packed unaligned dcl 905 in procedure "FAIL" set ref
                                                                                  903 907*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bulkdevt                               internal static fixed bin(4,0)           initial dcl 2-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 2-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 2-105
dev_time                               internal static float bin(27)            initial array dcl 2-139
device_names                           internal static char(4)                  initial array dcl 2-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 2-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 2-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 2-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 2-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 2-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 2-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 2-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 2-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 2-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 2-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 2-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 2-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 2-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 2-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 2-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 2-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 2-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 2-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 2-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 2-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 2-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 2-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 2-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 2-93
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 2-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 2-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 2-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 3-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 3-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 3-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 3-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 3-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 2-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 2-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 2-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 2-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 3-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 3-36

NAMES DECLARED BY EXPLICIT CONTEXT.
BUST                            010515 constant        label                    dcl 913 ref 909
FAIL                            010746 constant        entry                    internal dcl 903 ref 17 197 201 202 213 217 223 228
                                                                                  233 239 247 257 266 270 272 282 289 292 298 303
                                                                                  310 314 324 376 398 459 466 469 483 486 493 500
                                                                                  515 523 533 541 547 552 559 560 573 578 585 591
                                                                                  600 614 621 677 680 683 685 690 694 701 704 711
                                                                                  717 768 771 774 789 792 835 856 889
add_vol_registration            001600 constant        entry                    external dcl 153
add_volume_registration         001610 constant        entry                    external dcl 153
avr                             001570 constant        entry                    external dcl 153
change_vol_registration         003765 constant        entry                    external dcl 409
change_volume_registration      003775 constant        entry                    external dcl 409
check_owner                     011015 constant        entry                    internal dcl 917 ref 232 570
clean_up                        010577 constant        entry                    internal dcl 865 ref 188 332 404 446 508 607 624 668
                                                                                  720 761 840 908
cvr                             003755 constant        entry                    external dcl 409
del_vol_registration            006001 constant        entry                    external dcl 629
delete_volume_registration      006011 constant        entry                    external dcl 629
dvr                             005771 constant        entry                    external dcl 629
getarg                          010636 constant        entry                    internal dcl 882 ref 190 200 205 206 448 457 462 463
                                                                                  521 528 529 670 676 700 763 767 788 793
list_vol_registration           006656 constant        entry                    external dcl 725
list_volume_registration        006666 constant        entry                    external dcl 725
lvr                             006646 constant        entry                    external dcl 725
set_up                          010516 constant        entry                    internal dcl 848 ref 187 445 667 760
volume_registration_cmds_       001546 constant        entry                    external dcl 14
vrc_                            001536 constant        entry                    external dcl 14

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12614       12734   11756       12624
Length     13370   11756       120         420     635           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrc_                                746 external procedure  is an external procedure.  
on unit on line 188                  64 on unit               
on unit on line 446                  64 on unit               
on unit on line 668                  64 on unit               
on unit on line 761                  64 on unit               
set_up                                  internal procedure  shares stack frame of external procedure vrc_.  
clean_up                             80 internal procedure  is called by several nonquick procedures.  
getarg                                  internal procedure  shares stack frame of external procedure vrc_.  
FAIL                                    internal procedure  shares stack frame of external procedure vrc_.  
check_owner                             internal procedure  shares stack frame of external procedure vrc_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 YESNO                       vrc_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 tptr                        clean_up
vrc_                     000100 ap                          vrc_
                         000102 al                          vrc_
                         000103 pvname                      vrc_
                         000113 location                    vrc_
                         000123 dt_str                      vrc_
                         000131 pvid                        vrc_
                         000132 lvname                      vrc_
                         000142 lvid                        vrc_
                         000143 tcs                         vrc_
                         000153 tcs1                        vrc_
                         000254 temp_ptr                    vrc_
                         000256 comname                     vrc_
                         000266 aa_string                   vrc_
                         000276 auth_mnemonics              vrc_
                         000351 b36                         vrc_
                         000352 fb35                        vrc_
                         000354 fb71                        vrc_
                         000356 old_lvid                    vrc_
                         000357 old_lvname                  vrc_
                         000367 access_range                vrc_
                         000373 gave_access_low             vrc_
                         000374 gave_access_high            vrc_
                         000375 gave_public                 vrc_
                         000376 lv_already_registered       vrc_
                         000377 new_lv                      vrc_
                         000400 acs_dir                     vrc_
                         000452 acs_ent                     vrc_
                         000462 ans                         vrc_
                         000463 i                           vrc_
                         000464 j                           vrc_
                         000465 more_args                   vrc_
                         000466 argno                       vrc_
                         000467 serial                      vrc_
                         000477 pubbit                      vrc_
                         000500 owner                       vrc_
                         000510 owneri                      vrc_
                         000511 model                       vrc_
                         000512 change_model                vrc_
                         000513 change_name                 vrc_
                         000514 change_uid                  vrc_
                         000515 change_auth                 vrc_
                         000516 change_range                vrc_
                         000517 ec                          vrc_
                         000520 ec2                         vrc_
                         000521 temp_str                    vrc_
                         000621 str_len                     vrc_
                         000630 vrp                         vrc_
                         000632 pvrp                        vrc_
                         000634 seek_command                vrc_
                         000656 errc                        getarg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          enable_op           shorten_stack       ext_entry
int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater_or_equal   com_err_                      command_query_$yes_no
convert_access_class_$from_string                           convert_access_class_$from_string_range
convert_access_class_$to_string_short                       convert_aim_attributes_       convert_date_to_binary_
cu_$arg_ptr                   cv_dec_check_                 cv_oct_check_                 date_time_$format
expand_pathname_$add_suffix   get_group_id_                 get_temp_segment_             hcs_$truncate_seg
ioa_                          ioa_$rsnnl                    mdc_$find_volname             mdc_priv_$add_lvr
mdc_priv_$add_pvr             mdc_priv_$change_lvr          mdc_priv_$change_pvr          mdc_priv_$delete_lvr
mdc_priv_$delete_pvr          mdc_priv_$read_lvr            mdc_priv_$read_pvr            pathname_
release_temp_segment_         unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_invalid_range error_table_$bad_arg          error_table_$badopt           error_table_$noarg
sys_info$access_class_ceiling




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 001336        44 001341        46 001344        47 001345        48 001350        49 001351        50 001354
     51 001357        52 001361        55 001364        58 001365        59 001366        60 001371        61 001413
     62 001414        63 001415        64 001416        65 001417        66 001420        67 001423        70 001426
     71 001430        72 001432        73 001435        74 001436        76 001441        82 001442        83 001443
 2   84 001444        14 001535        16 001554        16 001557        17 001560        18 001566       153 001567
    187 001616       188 001627       190 001651       192 001654       194 001655       196 001671       197 001674
    200 001705       201 001710       202 001725       204 001761       205 001764       206 001767       211 001772
    212 002002       213 002005       214 002036       215 002037       216 002047       217 002070       218 002075
    221 002076       222 002106       223 002127       224 002142       225 002144       226 002145       227 002155
    228 002176       229 002211       230 002213       231 002214       232 002224       233 002225       234 002240
    235 002241       236 002251       238 002271       239 002274       241 002302       242 002315       243 002317
    244 002320       245 002330       246 002334       247 002367       248 002402       250 002403       251 002406
    253 002411       254 002412       255 002422       256 002442       257 002444       258 002457       263 002460
    264 002470       265 002510       266 002512       267 002525       268 002526       269 002536       270 002560
    271 002573       271 002605       272 002607       273 002623       274 002626       275 002627       277 002643
    281 002657       282 002662       284 002665       286 002666       288 002670       289 002673       292 002704
    295 002721       296 002742       298 002745       302 002775       303 003016       304 003031       306 003032
    309 003054       310 003057       313 003062       314 003076       316 003106       318 003110       319 003116
    320 003122       321 003124       322 003204       323 003233       324 003235       326 003272       329 003273
    331 003333       332 003336       333 003342       336 003343       337 003347       338 003356       339 003371
    340 003374       344 003405       345 003407       347 003414       348 003416       350 003422       351 003425
    352 003430       353 003434       354 003437       356 003453       357 003477       362 003501       363 003503
    365 003507       366 003511       368 003514       369 003516       370 003521       371 003524       372 003527
    373 003530       375 003532       376 003553       378 003566       381 003627       384 003630       386 003634
    387 003636       390 003641       391 003644       392 003647       393 003652       394 003655       395 003656
    397 003661       398 003702       400 003715       404 003747       406 003753       409 003754       445 004003
    446 004011       448 004033       450 004036       452 004037       454 004044       456 004060       457 004062
    458 004065       459 004106       461 004121       462 004124       463 004127       464 004132       465 004142
    466 004164       468 004200       468 004211       469 004213       471 004230       472 004232       475 004234
    476 004236       477 004237       479 004254       481 004271       482 004301       483 004323       484 004336
    485 004337       486 004347       487 004404       488 004410       489 004412       490 004413       491 004423
    492 004443       493 004445       494 004461       495 004462       496 004464       499 004465       500 004470
    501 004516       502 004517       504 004520       505 004526       507 004563       508 004566       509 004572
    514 004573       515 004614       517 004627       518 004652       519 004653       521 004667       522 004672
    523 004713       525 004726       527 004730       528 004732       529 004735       531 004740       532 004750
    533 004771       534 004776       535 005000       536 005004       539 005005       540 005015       541 005036
    542 005052       543 005057       544 005061       545 005062       546 005072       547 005113       548 005127
    549 005134       550 005136       551 005137       552 005147       554 005175       555 005213       556 005214
    557 005224       558 005230       559 005263       560 005276       561 005336       562 005363       564 005364
    565 005367       566 005372       568 005376       569 005377       570 005407       571 005410       572 005412
    573 005415       574 005426       575 005427       576 005433       577 005434       578 005444       579 005475
    580 005501       581 005503       582 005504       583 005514       584 005534       585 005536       586 005552
    587 005554       588 005556       590 005557       591 005562       593 005565       595 005566       599 005607
    600 005612       603 005615       604 005625       606 005662       607 005665       608 005671       613 005672
    614 005713       616 005726       617 005751       620 005752       621 005755       624 005763       626 005767
    629 005770       667 006017       668 006025       670 006047       672 006052       674 006053       676 006067
    677 006072       679 006123       680 006144       682 006157       683 006205       684 006220       685 006241
    687 006254       688 006260       689 006262       690 006317       693 006322       694 006337       696 006352
    697 006400       698 006401       700 006415       701 006420       703 006451       704 006472       706 006505
    707 006515       708 006551       710 006553       711 006570       713 006603       714 006626       716 006627
    717 006632       720 006640       722 006644       725 006645       760 006674       761 006705       763 006727
    765 006732       767 006746       768 006751       770 007002       771 007023       773 007036       774 007064
    776 007077       777 007123       778 007171       779 007215       780 007240       781 007264       782 007326
    784 007346       785 007371       786 007372       788 007406       789 007411       791 007442       792 007463
    793 007476       794 007501       795 007511       796 007534       797 007604       798 007634       799 007656
    800 007670       801 007712       802 007714       803 007740       805 007743       806 007767       807 010001
    808 010023       809 010025       810 010051       812 010054       813 010100       814 010124       816 010147
    817 010157       819 010163       822 010213       823 010236       824 010301       825 010325       826 010352
    827 010376       828 010440       831 010463       832 010465       834 010466       835 010471       838 010477
    840 010510       842 010514       913 010515       848 010516       852 010527       853 010534       854 010535
    855 010541       856 010562       857 010572       859 010575       865 010576       869 010604       871 010611
    872 010613       873 010615       876 010635       882 010636       887 010647       888 010664       889 010666
    890 010677       891 010707       892 010710       893 010716       894 010717       895 010734       897 010745
    903 010746       907 010757       908 011010       909 011014       917 011015       919 011016       920 011027
    921 011031       922 011047       924 011052


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
