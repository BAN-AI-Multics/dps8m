	COMPILATION LISTING OF SEGMENT rcp_preload_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0946.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       14 rcp_preload_:
       15      proc (arg_device_name, arg_volume_name, arg_group_id, arg_ecode);
       16 
       17 
       18 /*
       19*
       20*   This program implements the preload operator command support
       21*   in ring one.
       22*
       23*
       24*   Created on 04/20/78 by Michael R. Jordan
       25*   Modified on 08/17/78 by Michael R. Jordan
       26*   Modified 6/79 by Michael R. Jordan to fix misc bugs.
       27*   Modified 021585 by M. M. Pozzo to interface with rcp_access_kernel_ and
       28*   general cleanup for B2 effort.
       29*
       30**/
       31 
       32 dcl	addr		   builtin;
       33 dcl	admin_gate_$syserr	   options (variable);
       34 dcl	arg_device_name	   char (32);		/* name of the device */
       35 dcl	arg_ecode		   fixed bin (35);		/* status code returned */
       36 dcl	arg_group_id	   char (32);		/* name of the user */
       37 dcl	arg_volume_name	   char (32);		/* name of the volume */
       38 dcl	caller_level	   fixed bin;		/* callers validation level */
       39 dcl	cleanup		   condition;
       40 dcl	clock		   builtin;
       41 dcl	cu_$level_get	   entry (fixed bin);
       42 dcl	cu_$level_set	   entry (fixed bin);
       43 dcl	device_name	   char (8);		/* local copy of device name */
       44 dcl	device_off	   bit (18);		/* offset of rcpd.device entry */
       45 dcl	dtypex		   fixed bin;		/* device type table index */
       46 dcl	ecode		   fixed bin (35);		/* local status code */
       47 dcl	effmode		   bit (3);
       48 dcl	error_table_$device_busy
       49 			   fixed bin (35) ext;
       50 dcl	error_table_$incorrect_device_type
       51 			   fixed bin (35) ext;
       52 dcl	error_table_$incomplete_access_name
       53 			   fixed bin (35) ext;
       54 dcl	error_table_$noarg	   fixed bin (35) ext;
       55 dcl	error_table_$resource_unknown
       56 			   fixed bin (35) ext;
       57 dcl	error_table_$volume_busy
       58 			   fixed bin (35) ext;
       59 
       60 dcl	access_operations_$rcp_preload
       61 			   bit (36) aligned ext static;
       62 
       63 dcl	get_authorization_	   entry () returns (bit (72) aligned);
       64 dcl	get_ring_		   entry () returns (fixed bin);
       65 dcl	group_id		   char (32);		/* local copy of user name */
       66 dcl	i		   fixed bin;
       67 dcl	null		   builtin;
       68 dcl	operation		   bit (36) aligned;
       69 dcl	ptr		   builtin;
       70 dcl	rel		   builtin;
       71 dcl	reg_iocb_ptr	   ptr;
       72 dcl	1 res_info	   aligned automatic like resource_info;
       73 dcl	1 req_info	   aligned automatic like requestor_info;
       74 dcl	rcp_access_kernel_	   entry (bit (36) aligned, ptr, ptr, bit (3), fixed bin (35));
       75 dcl	rcp_lock_$lock	   entry (ptr, fixed bin (35));
       76 dcl	rcp_lock_$unlock	   entry (ptr);
       77 dcl	rcp_match_user_name_   entry (char (32), char (32)) returns (bit (1));
       78 dcl	rcp_pointers_$data	   entry () returns (ptr);
       79 dcl	rcp_unload_$unload_device
       80 			   entry (ptr, bit (1));
       81 dcl	record_ptr	   ptr;
       82 dcl	this_device_off	   bit (18);		/* device_off for the device being preloaded */
       83 dcl	trans_iocb_ptr	   ptr;
       84 dcl	volume_off	   bit (18);
       85 dcl	volume_name	   char (32);		/* local copy of volume name */
       86 
       87 /*                   CONSTANTS                          */
       88 
       89 dcl	DEFAULT_REGISTRY_DIR   char (64) internal static options (constant) init (">sc1>rcp");
       90 						/*
       91*
       92*						   Get the callers validation level and get him set to go.
       93*
       94*						*/
       95 
       96 
       97 	call cu_$level_get (caller_level);
       98 	on cleanup
       99 	     begin;
      100 	     call cu_$level_set (caller_level);
      101 	end;
      102 	call cu_$level_set (get_ring_ ());
      103 	reg_iocb_ptr, trans_iocb_ptr = null ();
      104 	ecode = 0;
      105 
      106 
      107 /*
      108*
      109*   Now copy all input arguments.
      110*
      111**/
      112 
      113 
      114 	device_name = arg_device_name;
      115 	volume_name = arg_volume_name;
      116 	group_id = arg_group_id;
      117 
      118 	rcpd_ptr = rcp_pointers_$data ();
      119 	if ^rcpd.modes.resource_mgmt_enabled then
      120 	     if group_id = "" then do;
      121 		arg_ecode = error_table_$noarg;
      122 		return;
      123 	     end;
      124 	if group_id ^= "" then
      125 	     if incomplete_name (group_id) then do;
      126 		arg_ecode = error_table_$incomplete_access_name;
      127 		return;
      128 	     end;
      129 
      130 /* See if the volume is available */
      131 
      132 	volume_off = "0"b;
      133 	do i = 1 to rcpd.last_volume while (volume_off = "0"b);
      134 	     volume_ptr = addr (rcpd.volume (i));
      135 	     if volume.volume_name = volume_name then
      136 		volume_off = rel (volume_ptr);
      137 	end;
      138 	if volume_off ^= "0"b then do;
      139 	     if volume.state = 2 | volume.state = 3 then do;
      140 		ecode = error_table_$volume_busy;
      141 		goto UNLOCK_AND_RETURN;
      142 	     end;
      143 	     if volume.state = 1 | volume.state = 4 then do;
      144 		if ((group_id ^= "") & (^rcp_match_user_name_ ((volume.group_id), group_id))) | (group_id = "")
      145 		then do;
      146 		     ecode = error_table_$volume_busy;
      147 		     goto UNLOCK_AND_RETURN;
      148 		end;
      149 	     end;
      150 	end;					/*
      151*
      152*						   Make sure this device type is known before we go any farther.
      153*
      154*						*/
      155 
      156 
      157 	do dtypex = 1 to rcpd.tot_dtypes;
      158 
      159 	     do device_off = rcpd.dtype (dtypex).first_off repeat device.next_off while (device_off ^= "0"b);
      160 		device_ptr = ptr (rcpd_ptr, device_off);
      161 		if device_name = device.device_name then
      162 		     goto FOUND_DEVICE;
      163 	     end;
      164 
      165 	end;
      166 
      167 	ecode = error_table_$resource_unknown;
      168 	goto RETURN;
      169 
      170 
      171 /*
      172*
      173*   Got the device, now is the volume in use?
      174*
      175**/
      176 
      177 
      178 FOUND_DEVICE:
      179 	if dtypex ^= TAPE_DRIVE_DTYPEX & dtypex ^= DISK_DRIVE_DTYPEX then do;
      180 						/* Not tape or disk. */
      181 	     ecode = error_table_$incorrect_device_type;
      182 	     goto RETURN;
      183 	end;
      184 
      185 	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
      186 	if ecode ^= 0 then
      187 	     goto RETURN;
      188 
      189 	if device.flags.attached then do;		/* Someone has this one attached! */
      190 	     ecode = error_table_$device_busy;
      191 	     goto UNLOCK_AND_RETURN;
      192 	end;
      193 
      194 	goto STATE (device.state);			/* Cross-check the device state */
      195 
      196 
      197 STATE (2):					/* DELETED - cannot allow this */
      198 STATE (3):					/* STORAGE SYSTEM - this should never happen */
      199 	ecode = error_table_$device_busy;
      200 	goto UNLOCK_AND_RETURN;
      201 
      202 
      203 STATE (1):					/* ASSIGNED - make sure this is the right user */
      204 STATE (4):					/* RESERVED - ditto */
      205 						/* If its not assigned or reserved to this user then it can't
      206*						   be preloaded and if the group_id is "" then we can't tell
      207*						   so deny preload */
      208 	if ((group_id ^= "") & (^rcp_match_user_name_ ((device.group_id), group_id))) | (group_id = "") then do;
      209 	     ecode = error_table_$device_busy;
      210 	     goto UNLOCK_AND_RETURN;
      211 	end;
      212 
      213 
      214 STATE (0):					/* FREE - no sweat */
      215 	this_device_off = device_off;
      216 
      217 /*           If the volume is free or not in rcp_data yet, see if we
      218*   have access to it - if we don't, then don't preload it
      219*   since we can't get it.  If the device is free, check it's
      220*   access as well for the same reason.   */
      221 
      222 	if volume_off = "0"b | volume.state = 0 then do;
      223 	     call setup_kernel_call ((VOLUME_TYPE (device.dtypex)), (volume_name), ecode);
      224 	     if ecode ^= 0 then
      225 		goto UNLOCK_AND_RETURN;
      226 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
      227 	     if ecode ^= 0 then do;
      228 		ecode = error_table_$volume_busy;
      229 		goto UNLOCK_AND_RETURN;
      230 	     end;
      231 	     call cleanup_kernel_call (ecode);
      232 	end;
      233 	if device.state = 0 then do;
      234 	     call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), (device_name), ecode);
      235 	     if ecode ^= 0 then
      236 		goto UNLOCK_AND_RETURN;
      237 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
      238 	     if ecode ^= 0 then do;
      239 		ecode = error_table_$device_busy;
      240 		goto UNLOCK_AND_RETURN;
      241 	     end;
      242 	     call cleanup_kernel_call (ecode);
      243 	end;
      244 
      245 /*
      246*
      247*   We have all we need.  Make the note of this volume on this device.
      248*
      249**/
      250 
      251 
      252 	device_ptr = ptr (rcpd_ptr, this_device_off);
      253 	if device.volume_name ^= "" then
      254 	     if device.volume_name ^= volume_name then
      255 		call rcp_unload_$unload_device (device_ptr, "1"b);
      256 	device.volume_name = volume_name;
      257 	if device.state = 0 then do;			/* only set if device is free */
      258 	     device.group_id = group_id;
      259 	     device.state_time = clock ();
      260 	end;
      261 
      262 	call admin_gate_$syserr (0, "RCP: Preload volume ^a on device ^a^[ for ^a^;^s^].", volume_name, device_name,
      263 	     (group_id ^= ""), group_id);
      264 
      265 
      266 /*
      267*
      268*   Now return to the caller in a proper manner.
      269*
      270**/
      271 
      272 
      273 UNLOCK_AND_RETURN:
      274 	call cleanup_kernel_call (ecode);
      275 	call rcp_lock_$unlock (addr (rcpd.lock_info));
      276 
      277 
      278 RETURN:
      279 	arg_ecode = ecode;
      280 	call cu_$level_set (caller_level);
      281 	return;
      282 
      283 setup_kernel_call:
      284      proc (a_resource_type, a_resource_name, a_code);
      285 
      286 dcl	(a_resource_type, a_resource_name)
      287 			   char (*) aligned;
      288 dcl	a_code		   fixed bin (35);
      289 dcl	local_code	   fixed bin (35);
      290 
      291 dcl	rcprm_registry_util_$grab_transaction_control_file
      292 			   entry (ptr, char (*) aligned, fixed bin (35));
      293 dcl	rcprm_registry_util_$grab_registry
      294 			   entry (ptr, char (*) aligned, char (*) aligned, fixed bin (35));
      295 dcl	rcprm_registry_util_$find_resource_record
      296 			   entry (ptr, char (*) aligned, ptr, fixed bin (35));
      297 
      298 	local_code = 0;
      299 	req_info.user_id = group_id;
      300 	req_info.current_authorization = get_authorization_ ();
      301 	req_info.validation_level = caller_level;
      302 	operation = access_operations_$rcp_preload;
      303 	if rcpd.modes.resource_mgmt_enabled then do;
      304 	     res_info.registry_dir = DEFAULT_REGISTRY_DIR;
      305 	     call rcprm_registry_util_$grab_transaction_control_file (trans_iocb_ptr, res_info.registry_dir, local_code)
      306 		;
      307 	     if local_code ^= 0 then
      308 		goto SETUP_RETURN;
      309 	     call rcprm_registry_util_$grab_registry (reg_iocb_ptr, res_info.registry_dir, a_resource_type, local_code);
      310 	     if local_code ^= 0 then
      311 		goto SETUP_RETURN;
      312 	     call rcprm_registry_util_$find_resource_record (reg_iocb_ptr, a_resource_name, record_ptr, local_code);
      313 	     if local_code ^= 0 then
      314 		goto SETUP_RETURN;
      315 	     res_info.registry_switch_ptr = reg_iocb_ptr;
      316 	     res_info.registry_record_ptr = record_ptr;
      317 	end;
      318 	else do;
      319 	     res_info.registry_dir = "";
      320 	     res_info.registry_switch_ptr, res_info.registry_record_ptr = null ();
      321 	end;
      322 	res_info.resource_type = a_resource_type;
      323 	res_info.resource_name = a_resource_name;
      324 
      325 SETUP_RETURN:
      326 	a_code = local_code;
      327      end setup_kernel_call;
      328 
      329 cleanup_kernel_call:
      330      proc (a_code);
      331 
      332 dcl	a_code		   fixed bin (35);
      333 dcl	local_code	   fixed bin (35);
      334 dcl	rcprm_registry_util_$release_transaction_control_file
      335 			   entry (ptr, fixed bin (35));
      336 dcl	rcprm_registry_util_$release_registry
      337 			   entry (ptr, fixed bin (35));
      338 
      339 	local_code = 0;
      340 	if reg_iocb_ptr ^= null () then
      341 	     call rcprm_registry_util_$release_registry (reg_iocb_ptr, local_code);
      342 	if trans_iocb_ptr ^= null () then
      343 	     call rcprm_registry_util_$release_transaction_control_file (trans_iocb_ptr, local_code);
      344 	if local_code ^= 0 then
      345 	     a_code = local_code;
      346 
      347      end cleanup_kernel_call;
      348 
      349 incomplete_name:
      350      proc (a_group_id) returns (bit (1));
      351 
      352 dcl	a_group_id	   char (*);
      353 dcl	after		   builtin;
      354 
      355 	if after ((after (a_group_id, ".")), ".") = "" then
      356 	     return ("1"b);
      357 	else return ("0"b);
      358      end incomplete_name;
      359 
  1     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1     2 /*       Begin include file rcp_resource_info.incl.pl1
  1     3*   *
  1     4*   *       This include file gives information about the object,
  1     5*   *       or resource for the RCP operation.  If RM is enabled this
  1     6*   *       information will provide the registry name and switch pointer
  1     7*   *       for the registry so additional resource information can be
  1     8*   *       determined.  If RM is disabled, this information will include
  1     9*   *       the resource name and/or type.
  1    10**/
  1    11 
  1    12 dcl	resource_info_ptr	   ptr;
  1    13 
  1    14 dcl	1 resource_info	   based (resource_info_ptr),
  1    15 	  2 registry_dir	   aligned char (64),	/*  Could be a different if it is reconstruct operation */
  1    16 	  2 registry_switch_ptr
  1    17 			   ptr,			/*  Switch to the registry */
  1    18 	  2 registry_record_ptr
  1    19 			   ptr,			/*  Pointer to the registry record */
  1    20 	  2 resource_type	   char (32),		/*  Resource type */
  1    21 	  2 resource_name	   char (32);		/*  Resource name */
  1    22 
  1    23 /*  end include file .. rcp_resource_info.incl.pl1 */
      360 
      361 
  2     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2     2 /*       Begin include file rcp_requestor_info.incl.pl1
  2     3* *       
  2     4* *       This include file gives information about the subject,
  2     5* *       or requestor of the RCP operation.  In one case, absentee
  2     6* *       requests, the user is the Initializer, so this piece of
  2     7* *       information tells us about the real requestor of the RCP
  2     8* *       operation.
  2     9**/
  2    10 
  2    11 dcl requestor_info_ptr ptr;
  2    12 
  2    13 dcl 1 requestor_info aligned based (requestor_info_ptr),
  2    14     2 user_id char (32),
  2    15     2 current_authorization bit (72) aligned,
  2    16     2 validation_level fixed bin (3);
  2    17 
  2    18 /*  end include file .. rcp_requestor_info.incl.pl1 */
      362 
      363 
  3     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  3     2*   *
  3     3*   *	Created on 11/20/74 by Bill Silver.
  3     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  3     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  3     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  3     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  3     8*   *	Modified 11/84 by Paul Farley to add fips flag.
  3     9*   *      Modified 1/3/85 by Fawcett to allow room for mca device type
  3    10*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  3    11*   *	This include file defines the Resource Control Package communication segment.
  3    12*   *	This segment is used to communicate requests between the various internal
  3    13*   *	parts of RCP.
  3    14**/
  3    15 
  3    16 /****^  HISTORY COMMENTS:
  3    17*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3    18*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  3    19*     Support MCA and FIPS.
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  3    23 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  3    24 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  3    25 
  3    26 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  3    27    (2 id_count fixed bin (17),			/* Unique count index. */
  3    28     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  3    29 
  3    30 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  3    31     2 lock_info like lock_info,			/* Data used to lock this segment. */
  3    32     2 ws_maxs (8) fixed bin (19),			/* Max IOI workspace size in words. */
  3    33     2 ws_pmaxs (8) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  3    34     2 to_maxs (8) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  3    35     2 sys_directory char (32),			/* Directory  used to define a system process. */
  3    36     2 sys_acs char (32),				/* Entry name used to define a system process. */
  3    37     2 acs_directory char (32),			/* Directory containing device ACSs. */
  3    38     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  3    39     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  3    40     2 num_entries fixed bin,				/* Total number of entries. */
  3    41     2 first_free_off bit (18),			/* Offset of first free entry. */
  3    42     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  3    43      like rcse,					/* See structure below. */
  3    44     2 end bit (36);					/* End of rcp_com_seg. */
  3    45 
  3    46 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  3    47     2 lock bit (36),				/* The lock itself. */
  3    48     2 num_locks fixed bin (35),			/* Number of times locked. */
  3    49     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  3    50     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  3    51     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  3    52     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  3    53     2 starting_time fixed bin (71);			/* Time metering started. */
  3    54 
  3    55 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  3    56     2 device_name char (8),				/* Name of device associated with this entry. */
  3    57     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  3    58     2 dtypex fixed bin,				/* Device type index. */
  3    59     2 model fixed bin,				/* Device model number. */
  3    60     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  3    61     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  3    62     2 state_time fixed bin (71),			/* Time device put into current state. */
  3    63     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  3    64 						/* 3 - attaching  4 - attached   5 - completed. */
  3    65 
  3    66 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  3    67     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  3    68     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  3    69     2 user_off bit (18),				/* Offset of next entry in user list. */
  3    70     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  3    71     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  3    72     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  3    73     2 caller_level fixed bin,				/* Caller's validation level. */
  3    74     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  3    75     2 flags,					/* Special info flags. */
  3    76      (3 device bit (1),				/* ON => assigning a specific device. */
  3    77       3 priv bit (1),				/* ON => attached with IOI privilege. */
  3    78       3 system bit (1),				/* ON => assigned to a system process. */
  3    79       3 t_and_d bit (1),				/* ON => T&D attachment. */
  3    80       3 volume bit (1),				/* ON => volume associated with this device. */
  3    81       3 writing bit (1),				/* ON => writing on volume. */
  3    82       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  3    83       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  3    84       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  3    85       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  3    86       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  3    87       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  3    88       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  3    89       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  3    90       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  3    91       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  3    92       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  3    93       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  3    94       3 fips bit (1),				/* ON => FIPS device. */
  3    95       3 no_protect bit (1),				/* ON => device has no protect sw. */
  3    96       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  3    97       3 unused bit (6),
  3    98       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  3    99       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  3   100     2 rcp_id bit (36),				/* ID of this entry. */
  3   101     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  3   102     2 process_id bit (36),				/* ID of calling process. */
  3   103     2 group_id char (32),				/* Group ID of calling process. */
  3   104     2 ecode fixed bin (35),				/* Assignment error code. */
  3   105     2 version_num fixed bin,				/* Device info version number. */
  3   106     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  3   107     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  3   108     2 ioi_index fixed bin,				/* IOI device index. */
  3   109     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  3   110     2 caller_comment char (64);			/* Caller's comment. */
  3   111 
  3   112 /*	End of include file ... rcp_com_seg.incl.pl1	*/
      364 
      365 
  4     1 /*	Begin  include file ... rcp_data.incl.pl1
  4     2*   *
  4     3*   *	Created on 09/06/74 by Bill Silver.
  4     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  4     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  4     6*   *	It contains information about all of the devices and volumes managed by RCP.
  4     7*   *	This include file references rcp_com_seg.incl.pl1.
  4     8*
  4     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  4    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  4    11*   *	Modified on 12/09/78 to add removable media bit.
  4    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  4    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  4    14*   *	Modified 11/84 by Paul Farley to add fips flag.
  4    15*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  4    16**/
  4    17 
  4    18 /****^  HISTORY COMMENTS:
  4    19*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4    20*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  4    21*     Support FIPS and IMU.
  4    22*                                                   END HISTORY COMMENTS */
  4    23 
  4    24 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  4    25 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  4    26 dcl  device_ptr ptr;				/* Points to a device entry. */
  4    27 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  4    28 
  4    29 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  4    30     2 lock_info like lock_info,			/* Data used to lock this segment. */
  4    31     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  4    32     2 modes like rcp_init_flags unaligned,
  4    33     2 tot_dtypes fixed bin,				/* Number of known device types. */
  4    34     2 tot_devices fixed bin,				/* Total number of devices configured. */
  4    35     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  4    36     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  4    37     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  4    38     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  4    39     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  4    40     2 accounting_pid bit (36),			/* ID of accounting process */
  4    41     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  4    42     2 pad (7) fixed bin,
  4    43     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  4    44      like dtype,					/* See structure below. */
  4    45     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  4    46      like device,					/* See structure below. */
  4    47     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  4    48      like volume,					/* See structure below. */
  4    49     2 end bit (36) aligned;				/* End of rcp_data. */
  4    50 
  4    51 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  4    52     2 device_type char (32),				/* Name of this device type. */
  4    53     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  4    54     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  4    55     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  4    56     2 first_off bit (18),				/* Offset of first device entry. */
  4    57     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  4    58 
  4    59 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  4    60     2 device_name char (8),				/* Name of device associated with this entry. */
  4    61     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  4    62     2 dtypex fixed bin,				/* Device type index. */
  4    63     2 model fixed bin,				/* Device model number. */
  4    64     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  4    65     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  4    66     2 state_time fixed bin (71),			/* Time device put into current state. */
  4    67     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  4    68*						   3 => storage system, 4 => reserved */
  4    69 
  4    70 /*	*	*	*	*	** Following fields are unique to device entry. */
  4    71 
  4    72     2 unassign_state fixed bin,			/* State to return when unassigning. */
  4    73     2 acs_name char (12),				/* Entry name of ACS for this device. */
  4    74     2 next_off bit (18),				/* Offset of next entry for this device type. */
  4    75     2 iom_num fixed bin,				/* IOM number for this device. */
  4    76     2 chan_num fixed bin,				/* Channel number for this device. */
  4    77     2 num_channels fixed bin,				/* Num channels that may address device. */
  4    78     2 flags,					/* Special info flags. */
  4    79      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  4    80       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  4    81       3 reservable bit (1),				/* ON => may be reserved for system process. */
  4    82       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  4    83       3 mounting bit (1),				/* ON => mount pending. */
  4    84       3 writing bit (1),				/* ON => mounting for writing. */
  4    85       3 attached bit (1) unal,			/* ON => device is attached. */
  4    86       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  4    87       3 fips bit (1),				/* ON => FIPS device. */
  4    88       3 no_protect bit (1),				/* ON => device has no protect sw. */
  4    89       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  4    90       3 unused bit (25)) unal,
  4    91     2 process_id bit (36),				/* ID of assigned process. */
  4    92     2 group_id char (32),				/* Process group ID. */
  4    93     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  4    94     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  4    95     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  4    96     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  4    97     2 reservation_id fixed bin (71),
  4    98     2 reserved_by char (32),				/* Who made this reservation. */
  4    99     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  4   100 
  4   101 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  4   102     2 process_id bit (36),				/* "0"b => unassigned. */
  4   103     2 volume_name char (32),				/* Volume name. */
  4   104     2 vtypex fixed bin,				/* Volume type index. */
  4   105     2 group_id char (32),				/* This is used for the reserved_for field. */
  4   106     2 reserved_by char (32),
  4   107     2 reservation_id fixed bin (71),
  4   108     2 state_time fixed bin (71),			/* Same as for a device. */
  4   109     2 state fixed bin,				/* Same as for a device. */
  4   110     2 unassign_state fixed bin,			/* State to return when unassigning. */
  4   111     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  4   112 
  5     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  5     2 
  5     3 /* Created on 04/24/78 by Michael R. Jordan */
  5     4 /* Modified 04/10/79 by C. D. Tavares */
  5     5 
  5     6 dcl  rifp ptr;
  5     7 
  5     8 dcl 1 rcp_init_flags based (rifp),
  5     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  5    10     2 pad1 bit (2) unaligned,				/* obsolete */
  5    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  5    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  5    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  5    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  5    15 
  5    16 dcl (No_authentication initial (0),
  5    17      Nominal_authentication initial (1),
  5    18      Automatic_authentication initial (2),
  5    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  5    20 
  5    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  5    22     ("none", "nominal", "automatic", "manual");
  5    23 
  5    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  4   113 
  4   114 
  4   115 /*	End of include file ... rcp_data.incl.pl1	*/
      366 
      367 
  6     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  6     2*   *
  6     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  6     4*   *
  6     5*   *	This include file defines the official RCP resource types.
  6     6*   *	The array of names is indexed by the corresponding device type.
  6     7*   *      MOD by RAF for MCA
  6     8**/
  6     9 
  6    10 
  6    11 
  6    12 /****^  HISTORY COMMENTS:
  6    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  6    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  6    15*     Support of MCA.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 dcl  DEVICE_TYPE (8) char (32)
  6    19 	internal static options (constant)
  6    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  6    21 
  6    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  6    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  6    24 
  6    25 dcl  VOLUME_TYPE (8) char (32)
  6    26 	internal static options (constant)
  6    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  6    28 
  6    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  6    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  6    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  6    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  6    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  6    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  6    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  6    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  6    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  6    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  6    39 
  6    40 
  6    41 /*	End include file ... rcp_resource_types.incl.pl1 */
      368 
      369 
      370 
      371 /* BEGIN MESSAGE DOCUMENTATION
      372*
      373*   Message:
      374*   RCP: Preload volume VOLUME on device DEVICE
      375*
      376*   S:	$info
      377*
      378*   T:	$run
      379*
      380*   M:	The operator request to preload has been accepted by RCP.
      381*
      382*   A:	Preload the volume in question on the specified device.
      383*
      384*
      385*   END MESSAGE DOCUMENTATION */
      386 
      387 
      388      end rcp_preload_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0805.5  rcp_preload_.pl1                  >spec>install>1111>rcp_preload_.pl1
360          1    03/15/85  0953.1  rcp_resource_info.incl.pl1        >ldd>include>rcp_resource_info.incl.pl1
362          2    03/15/85  0953.1  rcp_requestor_info.incl.pl1       >ldd>include>rcp_requestor_info.incl.pl1
364          3    03/27/86  1120.0  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
366          4    03/27/86  1120.0  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
4-113        5    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
368          6    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEFAULT_REGISTRY_DIR            000205 constant        char(64)                 initial packed unaligned dcl 89 ref 304
DEVICE_TYPE                     000105 constant        char(32)                 initial array packed unaligned dcl 6-18 ref 234
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-30 ref 178
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-29 ref 178
VOLUME_TYPE                     000005 constant        char(32)                 initial array packed unaligned dcl 6-25 ref 223
a_code                                 parameter       fixed bin(35,0)          dcl 288 in procedure "setup_kernel_call" set ref 283
                                                                                  325*
a_code                                 parameter       fixed bin(35,0)          dcl 332 in procedure "cleanup_kernel_call" set ref
                                                                                  329 344*
a_group_id                             parameter       char                     packed unaligned dcl 352 ref 349 355
a_resource_name                        parameter       char                     dcl 286 set ref 283 312* 323
a_resource_type                        parameter       char                     dcl 286 set ref 283 309* 322
access_operations_$rcp_preload  000032 external static bit(36)                  dcl 60 ref 302
addr                                                   builtin function         dcl 32 ref 134 185 185 226 226 226 226 237 237 237
                                                                                  237 275 275
admin_gate_$syserr              000010 constant        entry                    external dcl 33 ref 262
after                                                  builtin function         dcl 353 ref 355 355
arg_device_name                        parameter       char(32)                 packed unaligned dcl 34 ref 14 114
arg_ecode                              parameter       fixed bin(35,0)          dcl 35 set ref 14 121* 126* 278*
arg_group_id                           parameter       char(32)                 packed unaligned dcl 36 ref 14 116
arg_volume_name                        parameter       char(32)                 packed unaligned dcl 37 ref 14 115
attached                 35(06)        based           bit(1)                   level 3 packed packed unaligned dcl 4-59 ref 189
caller_level                    000100 automatic       fixed bin(17,0)          dcl 38 set ref 97* 100* 280* 301
cleanup                         000102 stack reference condition                dcl 39 ref 98
clock                                                  builtin function         dcl 40 ref 259
cu_$level_get                   000012 constant        entry                    external dcl 41 ref 97
cu_$level_set                   000014 constant        entry                    external dcl 42 ref 100 102 280
current_authorization
                         10     000176 automatic       bit(72)                  level 2 dcl 73 set ref 300*
device                                 based           structure                level 1 dcl 4-59
device_name                            based           char(8)                  level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_preload_" ref 161
device_name                     000110 automatic       char(8)                  packed unaligned dcl 43 in procedure "rcp_preload_"
                                                                                  set ref 114* 161 234 262*
device_off                      000112 automatic       bit(18)                  packed unaligned dcl 44 set ref 159* 159* 160* 214
device_ptr                      000234 automatic       pointer                  dcl 4-26 set ref 160* 161 163 189 194 203 223 233
                                                                                  234 252* 253 253 253* 256 257 258 259
dtype                                  based           structure                level 1 dcl 4-51 in procedure "rcp_preload_"
dtype                    43            based           structure                array level 2 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_preload_"
dtypex                          000113 automatic       fixed bin(17,0)          dcl 45 in procedure "rcp_preload_" set ref 157* 159*
                                                                                  178 178
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_preload_" ref 223 234
ecode                           000114 automatic       fixed bin(35,0)          dcl 46 set ref 104* 140* 146* 167* 181* 185* 186
                                                                                  190* 197* 209* 223* 224 226* 227 228* 231* 234*
                                                                                  235 237* 238 239* 242* 273* 278
effmode                         000115 automatic       bit(3)                   packed unaligned dcl 47 set ref 226* 237*
error_table_$device_busy        000016 external static fixed bin(35,0)          dcl 48 ref 190 197 209 239
error_table_$incomplete_access_name
                                000022 external static fixed bin(35,0)          dcl 52 ref 126
error_table_$incorrect_device_type
                                000020 external static fixed bin(35,0)          dcl 50 ref 181
error_table_$noarg              000024 external static fixed bin(35,0)          dcl 54 ref 121
error_table_$resource_unknown   000026 external static fixed bin(35,0)          dcl 55 ref 167
error_table_$volume_busy        000030 external static fixed bin(35,0)          dcl 57 ref 140 146 228
first_off                56            based           bit(18)                  array level 3 dcl 4-29 ref 159
flags                    35            based           structure                level 2 dcl 4-59
get_authorization_              000034 constant        entry                    external dcl 63 ref 300
get_ring_                       000036 constant        entry                    external dcl 64 ref 102 102
group_id                 12            based           char(32)                 level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_preload_" ref 144
group_id                 37            based           char(32)                 level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_preload_" set ref 203 258*
group_id                        000116 automatic       char(32)                 packed unaligned dcl 65 in procedure "rcp_preload_"
                                                                                  set ref 116* 119 124 124* 144 144* 144 203 203*
                                                                                  203 258 262 262* 299
i                               000126 automatic       fixed bin(17,0)          dcl 66 set ref 133* 134*
last_volume              20            based           fixed bin(17,0)          level 2 dcl 4-29 ref 133
local_code                      000260 automatic       fixed bin(35,0)          dcl 333 in procedure "cleanup_kernel_call" set ref
                                                                                  339* 340* 342* 344 344
local_code                      000250 automatic       fixed bin(35,0)          dcl 289 in procedure "setup_kernel_call" set ref
                                                                                  298* 305* 307 309* 310 312* 313 325
lock_info                              based           structure                level 2 in structure "rcpd" dcl 4-29 in procedure
                                                                                  "rcp_preload_" set ref 185 185 275 275
lock_info                              based           structure                level 1 dcl 3-46 in procedure "rcp_preload_"
modes                    14(01)        based           structure                level 2 packed packed unaligned dcl 4-29
next_off                 31            based           bit(18)                  level 2 dcl 4-59 ref 163
null                                                   builtin function         dcl 67 ref 103 320 340 342
operation                       000127 automatic       bit(36)                  dcl 68 set ref 226* 237* 302*
ptr                                                    builtin function         dcl 69 ref 160 252
rcp_access_kernel_              000040 constant        entry                    external dcl 74 ref 226 237
rcp_init_flags                         based           structure                level 1 packed packed unaligned dcl 5-8
rcp_lock_$lock                  000042 constant        entry                    external dcl 75 ref 185
rcp_lock_$unlock                000044 constant        entry                    external dcl 76 ref 275
rcp_match_user_name_            000046 constant        entry                    external dcl 77 ref 144 203
rcp_pointers_$data              000050 constant        entry                    external dcl 78 ref 118
rcp_unload_$unload_device       000052 constant        entry                    external dcl 79 ref 253
rcpd                                   based           structure                level 1 dcl 4-29
rcpd_ptr                        000232 automatic       pointer                  dcl 4-24 set ref 118* 119 133 134 157 159 160 185
                                                                                  185 252 275 275 303
rcprm_registry_util_$find_resource_record
                                000060 constant        entry                    external dcl 295 ref 312
rcprm_registry_util_$grab_registry
                                000056 constant        entry                    external dcl 293 ref 309
rcprm_registry_util_$grab_transaction_control_file
                                000054 constant        entry                    external dcl 291 ref 305
rcprm_registry_util_$release_registry
                                000064 constant        entry                    external dcl 336 ref 340
rcprm_registry_util_$release_transaction_control_file
                                000062 constant        entry                    external dcl 334 ref 342
rcse                                   based           structure                level 1 dcl 3-55
record_ptr                      000212 automatic       pointer                  dcl 81 set ref 312* 316
reg_iocb_ptr                    000130 automatic       pointer                  dcl 71 set ref 103* 309* 312* 315 340 340*
registry_dir                    000132 automatic       char(64)                 level 2 dcl 72 set ref 304* 305* 309* 319*
registry_record_ptr      22     000132 automatic       pointer                  level 2 dcl 72 set ref 316* 320*
registry_switch_ptr      20     000132 automatic       pointer                  level 2 dcl 72 set ref 315* 320*
rel                                                    builtin function         dcl 70 ref 135
req_info                        000176 automatic       structure                level 1 dcl 73 set ref 226 226 237 237
requestor_info                         based           structure                level 1 dcl 2-13
res_info                        000132 automatic       structure                level 1 dcl 72 set ref 226 226 237 237
resource_info                          based           structure                level 1 unaligned dcl 1-14
resource_mgmt_enabled
                         14(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-29 ref 119 303
resource_name            34     000132 automatic       char(32)                 level 2 dcl 72 set ref 323*
resource_type            24     000132 automatic       char(32)                 level 2 dcl 72 set ref 322*
state                    36            based           fixed bin(17,0)          level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_preload_" ref 139 139 143 143 222
state                    24            based           fixed bin(17,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_preload_" ref 194 233 257
state_time               22            based           fixed bin(71,0)          level 2 dcl 4-59 set ref 259*
this_device_off                 000214 automatic       bit(18)                  packed unaligned dcl 82 set ref 214* 252
tot_devices              16            based           fixed bin(17,0)          level 2 dcl 4-29 ref 134
tot_dtypes               15            based           fixed bin(17,0)          level 2 dcl 4-29 ref 134 157
trans_iocb_ptr                  000216 automatic       pointer                  dcl 83 set ref 103* 305* 342 342*
user_id                         000176 automatic       char(32)                 level 2 dcl 73 set ref 299*
validation_level         12     000176 automatic       fixed bin(3,0)           level 2 dcl 73 set ref 301*
volume                                 based           structure                level 1 dcl 4-101 in procedure "rcp_preload_"
volume                                 based           structure                array level 2 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_preload_" set ref 134
volume_name               2            based           char(32)                 level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_preload_" set ref 253 253 256*
volume_name               1            based           char(32)                 level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_preload_" ref 135
volume_name                     000221 automatic       char(32)                 packed unaligned dcl 85 in procedure "rcp_preload_"
                                                                                  set ref 115* 135 223 253 256 262*
volume_off                      000220 automatic       bit(18)                  packed unaligned dcl 84 set ref 132* 133 135* 138
                                                                                  222
volume_ptr                      000236 automatic       pointer                  dcl 4-27 set ref 134* 135 135 139 139 143 143 144
                                                                                  222

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 5-16
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-31
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-38
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 6-36
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 5-16
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 6-22
No_authentication                      internal static fixed bin(17,0)          initial dcl 5-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 5-16
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 6-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 6-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-35
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-37
authentication_level_names             internal static char(12)                 initial array packed unaligned dcl 5-21
based_rcp_id                           based           structure                level 1 dcl 3-26
dtype_ptr                              automatic       pointer                  dcl 4-25
lock_info_ptr                          automatic       pointer                  dcl 3-22
rcs                                    based           structure                level 1 dcl 3-30
rcs_ptr                                automatic       pointer                  dcl 3-23
rcse_ptr                               automatic       pointer                  dcl 3-24
requestor_info_ptr                     automatic       pointer                  dcl 2-11
resource_info_ptr                      automatic       pointer                  dcl 1-12
rifp                                   automatic       pointer                  dcl 5-6

NAMES DECLARED BY EXPLICIT CONTEXT.
FOUND_DEVICE                    000623 constant        label                    dcl 178 ref 161
RETURN                          001210 constant        label                    dcl 278 ref 168 182 186
SETUP_RETURN                    001421 constant        label                    dcl 325 ref 307 310 313
STATE                           000000 constant        label                    array(0:4) dcl 197 ref 194
UNLOCK_AND_RETURN               001175 constant        label                    dcl 273 ref 141 147 191 200 210 224 229 235 240
cleanup_kernel_call             001425 constant        entry                    internal dcl 329 ref 231 242 273
incomplete_name                 001467 constant        entry                    internal dcl 349 ref 124
rcp_preload_                    000272 constant        entry                    external dcl 14
setup_kernel_call               001223 constant        entry                    internal dcl 283 ref 223 234

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2166        2254    1630        2176
Length      2614    1630        66         324     336           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_preload_                        314 external procedure  is an external procedure.  
on unit on line 98                   68 on unit               
setup_kernel_call                       internal procedure  shares stack frame of external procedure rcp_preload_.  
cleanup_kernel_call                     internal procedure  shares stack frame of external procedure rcp_preload_.  
incomplete_name                         internal procedure  shares stack frame of external procedure rcp_preload_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_preload_             000100 caller_level                rcp_preload_
                         000110 device_name                 rcp_preload_
                         000112 device_off                  rcp_preload_
                         000113 dtypex                      rcp_preload_
                         000114 ecode                       rcp_preload_
                         000115 effmode                     rcp_preload_
                         000116 group_id                    rcp_preload_
                         000126 i                           rcp_preload_
                         000127 operation                   rcp_preload_
                         000130 reg_iocb_ptr                rcp_preload_
                         000132 res_info                    rcp_preload_
                         000176 req_info                    rcp_preload_
                         000212 record_ptr                  rcp_preload_
                         000214 this_device_off             rcp_preload_
                         000216 trans_iocb_ptr              rcp_preload_
                         000220 volume_off                  rcp_preload_
                         000221 volume_name                 rcp_preload_
                         000232 rcpd_ptr                    rcp_preload_
                         000234 device_ptr                  rcp_preload_
                         000236 volume_ptr                  rcp_preload_
                         000250 local_code                  setup_kernel_call
                         000260 local_code                  cleanup_kernel_call

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
enable_op           shorten_stack       ext_entry           int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$syserr            cu_$level_get                 cu_$level_set                 get_authorization_
get_ring_                     rcp_access_kernel_            rcp_lock_$lock                rcp_lock_$unlock
rcp_match_user_name_          rcp_pointers_$data            rcp_unload_$unload_device
rcprm_registry_util_$find_resource_record                   rcprm_registry_util_$grab_registry
rcprm_registry_util_$grab_transaction_control_file          rcprm_registry_util_$release_registry
rcprm_registry_util_$release_transaction_control_file

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$rcp_preload                              error_table_$device_busy
error_table_$incomplete_access_name                         error_table_$incorrect_device_type
error_table_$noarg            error_table_$resource_unknown error_table_$volume_busy




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000265        97 000277        98 000305       100 000321       101 000330       102 000331       103 000347
    104 000352       114 000353       115 000360       116 000364       118 000370       119 000377       121 000407
    122 000413       124 000414       126 000426       127 000432       132 000433       133 000434       134 000447
    135 000470       137 000476       138 000500       139 000502       140 000510       141 000513       143 000514
    144 000520       146 000556       147 000561       157 000562       159 000573       160 000602       161 000605
    163 000612       165 000615       167 000617       168 000622       178 000623       181 000630       182 000633
    185 000634       186 000647       189 000651       190 000655       191 000660       194 000661       197 000663
    200 000666       203 000667       209 000725       210 000730       214 000731       222 000733       223 000740
    224 000755       226 000757       227 001002       228 001004       229 001007       231 001010       233 001012
    234 001015       235 001030       237 001032       238 001055       239 001057       240 001062       242 001063
    252 001065       253 001071       256 001114       257 001120       258 001122       259 001125       262 001130
    273 001175       275 001177       278 001210       280 001213       281 001222       283 001223       298 001241
    299 001242       300 001245       301 001254       302 001256       303 001261       304 001265       305 001270
    307 001310       309 001312       310 001341       312 001343       313 001371       315 001373       316 001375
    317 001377       319 001400       320 001403       322 001406       323 001414       325 001421       327 001424
    329 001425       339 001427       340 001430       342 001445       344 001462       347 001466       349 001467
    355 001500       357 001551


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
