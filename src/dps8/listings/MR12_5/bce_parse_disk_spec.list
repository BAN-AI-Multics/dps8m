	COMPILATION LISTING OF SEGMENT bce_parse_disk_spec
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1022.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-01-17,Fawcett), approve(86-01-17,MCR7220),
       11*     audit(86-05-14,Farley), install(86-07-17,MR12.0-1097):
       12*     Extracted from bce_test_disk (Allen Ball) by Keith Loepere,
       13*     This is used by bce_copy_disk, and bce_test_disk.
       14*  2) change(86-01-17,Fawcett), approve(86-04-11,MCR7383),
       15*     audit(86-05-14,Farley), install(86-07-17,MR12.0-1097):
       16*     Changed to support subvolumes by using last_sv_rec_num (device_type)
       17*     instead of last_rec_num (device_type).
       18*                                                   END HISTORY COMMENTS */
       19 
       20 bce_parse_disk_spec: proc (caller, arg_list_ptr, arg_num, device_type, p_labelp, f_record, l_record, caller_arg_parser, info_ptr, code);
       21 
       22 /* Routine to parse a bce specification of a disk range, interspersed with
       23*other control arguments.
       24*Extracted from bce_test_disk (Allen Ball) by Keith Loepere, March 1985.
       25**/
       26 
       27 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       28 
       29 /* Parameters */
       30 
       31 dcl  arg_list_ptr			ptr parameter;	/* to arg list for calling program */
       32 dcl  arg_num			fixed bin parameter;/* arg pos in arg list to start with */
       33 dcl  caller			char (32) parameter;/* name for error messages */
       34 dcl  caller_arg_parser		entry (ptr, fixed bin, ptr, fixed bin (35)) parameter; /* routine to pass of to for a non disk spec arg */
       35 dcl  code				fixed bin (35) parameter;
       36 dcl  device_type			fixed bin parameter;/* as in fs_dev_types */
       37 dcl  f_record			fixed bin (18) parameter; /* first rec in range */
       38 dcl  info_ptr			ptr parameter;	/* passed to caller_arg_parser */
       39 dcl  l_record			fixed bin parameter;/* last rec in range */
       40 dcl  p_labelp			ptr parameter;	/* to label for disk */
       41 
       42 /* Constants */
       43 
       44 dcl  First			fixed bin (18) static options (constant) init (-1);
       45 dcl  Last				fixed bin (18) static options (constant) init (-2);
       46 dcl  Octal			fixed bin static options (constant) init (8);
       47 dcl  Unassigned			fixed bin (18) static options (constant) init (-3);
       48 
       49 /* Variables */
       50 
       51 dcl  arg_count			fixed bin;
       52 dcl  arg_len			fixed bin (21);
       53 dcl  arg_ptr			ptr;
       54 dcl  n_record			fixed bin (18);	/* number of records to be read or written after f_record or before l_record */
       55 dcl  number			fixed bin (35);
       56 dcl  partition			char (4);
       57 dcl  parts_index			fixed bin;	/* index of part in label list */
       58 
       59 /* Based */
       60 
       61 dcl  arg				char (arg_len) based (arg_ptr);
       62 
       63 /* Entries */
       64 
       65 dcl  com_err_			entry () options (variable);
       66 dcl  cu_$arg_count_rel		entry (fixed bin, ptr, fixed bin (35));
       67 dcl  cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
       68 dcl  cv_integer_string_check_		entry (char (*), fixed bin, fixed bin (35)) returns (fixed bin (35));
       69 
       70 /* External */
       71 
       72 dcl  error_table_$bad_arg		fixed bin (35) ext static;
       73 dcl  error_table_$dev_offset_out_of_bounds fixed bin (35) ext static;
       74 dcl  error_table_$fsdisk_not_storage	fixed bin (35) ext static;
       75 dcl  error_table_$noarg		fixed bin (35) ext static;
       76 dcl  error_table_$nopart		fixed bin (35) ext static;
       77 
       78 	f_record = Unassigned;
       79 	l_record = Unassigned;
       80 	n_record = Unassigned;
       81 	partition = "";
       82 	labelp = p_labelp;
       83 
       84 	call cu_$arg_count_rel (arg_count, arg_list_ptr, code);
       85 	do arg_num = arg_num to arg_count;
       86 	     call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, arg_list_ptr);
       87 	     if arg = "-partition" | arg = "-part" then do;
       88 		if label.Multics ^= Multics_ID_String then do;
       89 		     code = error_table_$fsdisk_not_storage;
       90 		     call com_err_ (code, caller, "partition");
       91 		     return;
       92 		end;
       93 		call get_next_arg ("partition");
       94 		partition = arg;
       95 	     end;
       96 	     else if arg = "-record" | arg = "-rec" then do;
       97 		if f_record ^= Unassigned | l_record ^= Unassigned then go to bad_rec_spec;
       98 		call get_next_arg ("record");
       99 		number = cv_integer_string_check_ (arg, Octal, code);
      100 		if code = 0 then do;
      101 		     if number < 0 then goto no_neg_rec_nums;
      102 		     else do;
      103 			f_record = number;
      104 			l_record = number;
      105 		     end;
      106 		end;
      107 		else do;
      108 		     if arg = "first" then do;
      109 			f_record = First;
      110 			l_record = First;
      111 		     end;
      112 		     else if arg = "last" then do;
      113 			f_record = Last;
      114 			l_record = Last;
      115 		     end;
      116 		     else goto bad_arg;
      117 		end;
      118 	     end;
      119 	     else if arg = "-first_record" | arg = "-frec" then do;
      120 		call get_next_arg ("first_record");
      121 		if f_record ^= Unassigned then goto bad_rec_spec;
      122 		number = cv_integer_string_check_ (arg, Octal, code);
      123 		if code = 0 then do;
      124 		     if number < 0 then goto no_neg_rec_nums;
      125 		     else f_record = number;
      126 		end;
      127 		else do;
      128 		     if arg = "first" then f_record = First;
      129 		     else if arg = "last" then f_record = Last;
      130 		     else goto bad_arg;
      131 		end;
      132 	     end;
      133 	     else if arg = "-n_records" | arg = "-nrec" then do;
      134 		if n_record ^= Unassigned then goto bad_rec_spec;
      135 		call get_next_arg ("n_records");
      136 		number = cv_integer_string_check_ (arg, Octal, code);
      137 		if code = 0 then do;
      138 		     if number <= 0 then goto no_neg_rec_nums;
      139 		     n_record = number;
      140 		end;
      141 		else goto bad_arg;
      142 	     end;
      143 	     else if arg = "-last_record" | arg = "-lrec" then do;
      144 		if l_record ^= Unassigned then goto bad_rec_spec;
      145 		call get_next_arg ("last_record");
      146 		number = cv_integer_string_check_ (arg, Octal, code);
      147 		if code = 0 then do;
      148 		     if number < 0 then do;
      149 no_neg_rec_nums:		code = error_table_$dev_offset_out_of_bounds;
      150 			call com_err_ (code, caller, "^d", number);
      151 			return;
      152 		     end;
      153 		     else l_record = number;
      154 		end;
      155 		else do;
      156 		     if arg = "first" then l_record = First;
      157 		     else if arg = "last" then l_record = Last;
      158 		     else goto bad_arg;
      159 		end;
      160 	     end;
      161 	     else do;
      162 		call caller_arg_parser (arg_list_ptr, arg_num, info_ptr, code);
      163 		if code ^= 0 then return;		/* routine printed error */
      164 	     end;
      165 next_arg: end;
      166 
      167 
      168 /* Now figure out what f_record and l_record  are. */
      169 
      170 	if f_record ^= Unassigned & l_record ^= Unassigned & n_record ^= Unassigned then goto bad_rec_spec; /* -frec, -lrec, and -nrec are (all three) incompatible */
      171 	if partition ^= "" then do;
      172 	     do parts_index = 1 to label.nparts while (label.parts (parts_index).part ^= partition);
      173 	     end;
      174 	     if parts_index > label.nparts then do;
      175 		code = error_table_$nopart;
      176 		call com_err_ (code, caller, "^a", partition);
      177 		return;
      178 	     end;
      179 	     if n_record = Unassigned then do;
      180 		if f_record = Unassigned | f_record = First then f_record = label.parts (parts_index).frec;
      181 		else if f_record = Last then f_record = label.parts (parts_index).frec + label.parts (parts_index).nrec - 1;
      182 		else f_record = f_record + label.parts (parts_index).frec;
      183 		if l_record = Unassigned | l_record = Last then l_record = label.parts (parts_index).frec + label.parts (parts_index).nrec - 1;
      184 		else if l_record = First then l_record = label.parts (parts_index).frec;
      185 		else l_record = l_record + label.parts (parts_index).frec;
      186 	     end;
      187 	     else do;
      188 		if f_record ^= Unassigned then do;
      189 		     if f_record = First then f_record = label.parts (parts_index).frec;
      190 		     else if f_record = Last then f_record = label.parts (parts_index).frec + label.parts (parts_index).nrec - 1;
      191 		     else f_record = f_record + label.parts (parts_index).frec;
      192 		     l_record = f_record + n_record - 1;
      193 		end;
      194 		else if l_record ^= Unassigned then do;
      195 		     if l_record = First then l_record = label.parts (parts_index).frec;
      196 		     else if l_record = Last then l_record = label.parts (parts_index).frec + label.parts (parts_index).nrec - 1;
      197 		     else l_record = l_record + label.parts (parts_index).frec;
      198 		     f_record = l_record - n_record + 1;
      199 		end;
      200 	     end;
      201 	end;
      202 
      203 	else do;
      204 	     if n_record = Unassigned then do;
      205 		if f_record = Unassigned | f_record = First then f_record = first_rec_num (device_type);
      206 		else if f_record = Last then f_record = last_sv_rec_num (device_type);
      207 		if l_record = Unassigned | l_record = Last then l_record = last_sv_rec_num (device_type);
      208 		else if l_record = First then l_record = first_rec_num (device_type);
      209 	     end;
      210 	     else do;
      211 		if f_record ^= Unassigned then do;
      212 		     if f_record = First then f_record = first_rec_num (device_type);
      213 		     else if f_record = Last then f_record = last_sv_rec_num (device_type);
      214 		     l_record = f_record + n_record - 1;
      215 		end;
      216 		else if l_record ^= Unassigned then do;
      217 		     if l_record = First then l_record = first_rec_num (device_type);
      218 		     else if l_record = Last then l_record = last_sv_rec_num (device_type);
      219 		     f_record = l_record - n_record + 1;
      220 		end;
      221 	     end;
      222 	end;
      223 
      224 
      225 /* Out of range checks */
      226 
      227 	if f_record < first_rec_num (device_type) | f_record > first_rec_num (device_type) + rec_per_dev (device_type) - 1 then do;
      228 	     code = error_table_$dev_offset_out_of_bounds;
      229 	     call com_err_ (code, caller, "^d", f_record);
      230 	     return;
      231 	end;
      232 	if l_record < first_rec_num (device_type) | l_record > first_rec_num (device_type) + rec_per_dev (device_type) - 1 then do;
      233 	     code = error_table_$dev_offset_out_of_bounds;
      234 	     call com_err_ (code, caller, "^d", l_record);
      235 	     return;
      236 	end;
      237 	if l_record < f_record then do;
      238 	     code = error_table_$dev_offset_out_of_bounds;
      239 	     call com_err_ (code, caller, "^d is less than ^d", l_record, f_record);
      240 	     return;
      241 	end;
      242 
      243 	code = 0;					/* passes all tests */
      244 RETURN:	return;
      245 
      246 get_next_arg: proc (arg_needed);
      247 
      248 dcl  arg_needed			char (32);
      249 
      250 	arg_num = arg_num + 1;
      251 	if arg_num > arg_count then do;
      252 	     code = error_table_$noarg;
      253 	     call com_err_ (code, caller, arg_needed);
      254 	     go to RETURN;
      255 	end;
      256 	call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, arg_list_ptr);
      257 	return;
      258      end get_next_arg;
      259 
      260 bad_rec_spec:
      261 	code = error_table_$dev_offset_out_of_bounds;
      262 	call com_err_ (0, caller, "Incompatible use of record specifiers.");
      263 	return;
      264 
      265 bad_arg:
      266 	code = error_table_$bad_arg;
      267 	call com_err_ (code, caller, "^a", arg);
      268 	return;
      269  /* Begin include file ...... fs_dev_types.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  1     6*     Add support for FIPS
  1     7*     3380.
  1     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  1     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  1    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  1    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  1    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  1    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 /* Modified 5/19/76 by N. I. Morris */
  1    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  1    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  1    19 /* Modified '82 by BIM for needs_alt_part */
  1    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  1    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  1    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  1    23*   volmap and record stock can be expanded. */
  1    24 
  1    25 /*
  1    26********************************************************************************
  1    27**							        *
  1    28**                           WARNING:                                          *
  1    29**							        *
  1    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  1    31**   type is added.						        *
  1    32**							        *
  1    33**   There are other include files that contain arrays indexed by the device   *
  1    34**   index obtained by references to MODELX or MODELN in this include file.    *
  1    35**   These must be modified when a new device type is added:		        *
  1    36**   disk_pack.incl.pl1					        *
  1    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  1    38**							        *
  1    39********************************************************************************
  1    40**/
  1    41 
  1    42 
  1    43 dcl (maxdevt init (9),				/* maximum legal devt */
  1    44      bulkdevt init (1),				/* bulk store devt */
  1    45      msu0500devt init (2),				/* MSU0500 device type */
  1    46      msu0451devt init (3),				/* MSU0451 device type */
  1    47      msu0450devt init (3),				/* MSU0450 device type */
  1    48      msu0400devt init (4),				/* MSU0400 device type */
  1    49      dsu191devt init (4),				/* DSU191 device type */
  1    50      dsu190devt init (5),				/* DSU190 device type */
  1    51      dsu181devt init (6),				/* DSU181 device type */
  1    52      msu0501devt init (7),				/* MSU0501 device type */
  1    53      fips3380devt init (8),				/* 3380D FIPS device type */
  1    54      fips3381devt init (9)				/* 3380E FIPS device type */
  1    55      ) fixed bin (4) static options (constant);
  1    56 
  1    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  1    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  1    59 
  1    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  1    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  1    62 
  1    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  1    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  1    65 
  1    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  1    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  1    68 
  1    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  1    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  1    71 
  1    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  1    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  1    74 
  1    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  1    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  1    77 
  1    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  1    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  1    80 
  1    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  1    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  1    83 
  1    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  1    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  1    86 
  1    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  1    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  1    89 
  1    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  1    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  1    92 
  1    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  1    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  1    95 
  1    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  1    97      ("abc");
  1    98 
  1    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  1   100      init ("a","b","c");
  1   101 
  1   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  1   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  1   104 
  1   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  1   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  1   107 
  1   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  1   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  1   110 
  1   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  1   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  1   113 
  1   114 
  1   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  1   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  1   117 
  1   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  1   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  1   120 
  1   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  1   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  1   123 
  1   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  1   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  1   126 
  1   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  1   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  1   129 
  1   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  1   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  1   132 
  1   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  1   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  1   135 
  1   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  1   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  1   138 
  1   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  1   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  1   141 
  2     1 /* Begin fs_dev_types_sector.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  2     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  2     7*     Add the sector differance for devices that do 64 word IO and devices that
  2     8*     do 512 word IO.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  2    12*	 need all the data in fs_dev_types. This is also included in
  2    13*	 fs_dev_types.incl.pl1  */
  2    14 
  2    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  2    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  2    17 
  2    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  2    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  2    20 
  2    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  2    22  /* table of # of sectors per record on each device */
  2    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  2    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    25 
  2    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  2    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    28 	
  2    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  2    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  2    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    32 
  2    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  2    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  2    35 
  2    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  2    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  2    38 
  2    39 /* End fs_dev_types_sector.incl.pl1 */
  2    40 
  1   142 
  1   143 
  1   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      269 
      270  /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  3     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  3     6*     Add the subvolume info.
  3     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3     9*     Added inconsistent_dbm bit used to determine consistency of volume
  3    10*     dumper bit maps.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  3    14 /* Note: fsout_vol clears pad fields before writing the label */
  3    15 
  3    16 dcl  labelp ptr;
  3    17 
  3    18 dcl 1 label based (labelp) aligned,
  3    19 
  3    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  3    21 
  3    22     2 gcos (5*64) fixed bin,
  3    23 
  3    24 /* Now we have the Multics label */
  3    25 
  3    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  3    27     2 version fixed bin,				/* Version 1 */
  3    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  3    29     2 pv_name char (32),				/* Physical volume name. */
  3    30     2 lv_name char (32),				/* Name of logical volume for pack */
  3    31     2 pvid bit (36),				/* Unique ID of this pack */
  3    32     2 lvid bit (36),				/* unique ID of its logical vol */
  3    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  3    34     2 time_registered fixed bin (71),			/* time imported to system */
  3    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  3    36     2 vol_size fixed bin,				/* total size of volume, in records */
  3    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  3    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  3    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  3    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  3    41     2 flagpad bit (33) unal,
  3    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  3    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  3    44     2 password bit (72),				/* not yet used */
  3    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  3    46     2 this_sv fixed bin,				/* what subvolume number it is */
  3    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  3    48     2 pad1 (13) fixed bin,
  3    49     2 time_mounted fixed bin (71),			/* time mounted */
  3    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  3    51 
  3    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  3    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  3    54* */
  3    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  3    56     2 pad6 fixed bin,				
  3    57 
  3    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  3    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  3    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  3    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  3    62     2 pad1a (2) fixed bin,
  3    63     2 err_hist_size fixed bin,			/* size of pack error history */
  3    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  3    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  3    66     2 pad2 (40) fixed bin,
  3    67     2 root,
  3    68       3 here bit (1),				/* TRUE if the root is on this pack */
  3    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  3    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  3    71       3 pad7 bit (1) aligned,				
  3    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  3    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  3    74       3 esd_state fixed bin,				/* State of esd */
  3    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  3    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  3    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  3    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  3    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  3    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  3    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  3    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  3    83     2 pad3 (52) fixed bin,
  3    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  3    85     2 parts (47),
  3    86       3 part char (4),				/* Name of partition */
  3    87       3 frec fixed bin,				/* First record */
  3    88       3 nrec fixed bin,				/* Number of records */
  3    89       3 pad5 fixed bin,
  3    90     2 pad4 (5*64) fixed bin;
  3    91 
  3    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  3    93 
  3    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      270 
      271      end bce_parse_disk_spec;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.3  bce_parse_disk_spec.pl1           >special_ldd>install>MR12.3-1114>bce_parse_disk_spec.pl1
269          1    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
1-142        2    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
270          3    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
First                           001756 constant        fixed bin(18,0)          initial dcl 44 ref 109 110 128 156 180 184 189 195
                                                                                  205 208 212 217
Last                            001755 constant        fixed bin(18,0)          initial dcl 45 ref 113 114 129 157 181 183 190 196
                                                                                  206 207 213 218
Multics                 500            based           char(32)                 initial level 2 dcl 3-18 ref 88
Multics_ID_String               000000 constant        char(32)                 initial packed unaligned dcl 3-92 ref 88
Octal                           000056 constant        fixed bin(17,0)          initial dcl 46 set ref 99* 122* 136* 146*
Unassigned                      001754 constant        fixed bin(18,0)          initial dcl 47 ref 78 79 80 97 97 121 134 144 170
                                                                                  170 170 179 180 183 188 194 204 205 207 211 216
arg                                    based           char                     packed unaligned dcl 61 set ref 87 87 94 96 96 99*
                                                                                  108 112 119 119 122* 128 129 133 133 136* 143 143
                                                                                  146* 156 157 267*
arg_count                       000100 automatic       fixed bin(17,0)          dcl 51 set ref 84* 85 251
arg_len                         000101 automatic       fixed bin(21,0)          dcl 52 set ref 86* 87 87 94 96 96 99 99 108 112 119
                                                                                  119 122 122 128 129 133 133 136 136 143 143 146
                                                                                  146 156 157 256* 267 267
arg_list_ptr                           parameter       pointer                  dcl 31 set ref 20 84* 86* 162* 256*
arg_needed                             parameter       char(32)                 packed unaligned dcl 248 set ref 246 253*
arg_num                                parameter       fixed bin(17,0)          dcl 32 set ref 20 85* 85* 86* 162* 250* 250 251 256*
arg_ptr                         000102 automatic       pointer                  dcl 53 set ref 86* 87 87 94 96 96 99 108 112 119 119
                                                                                  122 128 129 133 133 136 143 143 146 156 157 256*
                                                                                  267
caller                                 parameter       char(32)                 packed unaligned dcl 33 set ref 20 90* 150* 176*
                                                                                  229* 234* 239* 253* 262* 267*
caller_arg_parser                      parameter       entry variable           dcl 34 ref 20 162
code                                   parameter       fixed bin(35,0)          dcl 35 set ref 20 84* 86* 89* 90* 99* 100 122* 123
                                                                                  136* 137 146* 147 149* 150* 162* 163 175* 176*
                                                                                  228* 229* 233* 234* 238* 239* 243* 252* 253* 256*
                                                                                  260* 265* 267*
com_err_                        000010 constant        entry                    external dcl 65 ref 90 150 176 229 234 239 253 262
                                                                                  267
cu_$arg_count_rel               000012 constant        entry                    external dcl 66 ref 84
cu_$arg_ptr_rel                 000014 constant        entry                    external dcl 67 ref 86 256
cv_integer_string_check_        000016 constant        entry                    external dcl 68 ref 99 122 136 146
device_type                            parameter       fixed bin(17,0)          dcl 36 ref 20 205 206 207 208 212 213 217 218 227
                                                                                  227 227 232 232 232
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 72 ref 265
error_table_$dev_offset_out_of_bounds
                                000022 external static fixed bin(35,0)          dcl 73 ref 149 228 233 238 260
error_table_$fsdisk_not_storage 000024 external static fixed bin(35,0)          dcl 74 ref 89
error_table_$noarg              000026 external static fixed bin(35,0)          dcl 75 ref 252
error_table_$nopart             000030 external static fixed bin(35,0)          dcl 76 ref 175
f_record                               parameter       fixed bin(18,0)          dcl 37 set ref 20 78* 97 103* 109* 113* 121 125*
                                                                                  128* 129* 170 180 180 180* 181 181* 182* 182 188
                                                                                  189 189* 190 190* 191* 191 192 198* 205 205 205*
                                                                                  206 206* 211 212 212* 213 213* 214 219* 227 227
                                                                                  229* 237 239*
first_rec_num                   000021 constant        fixed bin(17,0)          initial array dcl 1-115 ref 205 208 212 217 227 227
                                                                                  232 232
frec                   1005            based           fixed bin(17,0)          array level 3 dcl 3-18 ref 180 181 182 183 184 185
                                                                                  189 190 191 195 196 197
info_ptr                               parameter       pointer                  dcl 38 set ref 20 162*
l_record                               parameter       fixed bin(17,0)          dcl 39 set ref 20 79* 97 104* 110* 114* 144 153*
                                                                                  156* 157* 170 183 183 183* 184 184* 185* 185 192*
                                                                                  194 195 195* 196 196* 197* 197 198 207 207 207*
                                                                                  208 208* 214* 216 217 217* 218 218* 219 232 232
                                                                                  234* 237 239*
label                                  based           structure                level 1 dcl 3-18
labelp                          000112 automatic       pointer                  dcl 3-16 set ref 82* 88 172 172 174 180 181 181 182
                                                                                  183 183 184 185 189 190 190 191 195 196 196 197
last_sv_rec_num                 000010 constant        fixed bin(18,0)          initial array dcl 1-121 ref 206 207 213 218
n_record                        000104 automatic       fixed bin(18,0)          dcl 54 set ref 80* 134 139* 170 179 192 198 204 214
                                                                                  219
nparts                 1003            based           fixed bin(17,0)          level 2 dcl 3-18 ref 172 174
nrec                   1006            based           fixed bin(17,0)          array level 3 dcl 3-18 ref 181 183 190 196
number                          000105 automatic       fixed bin(35,0)          dcl 55 set ref 99* 101 103 104 122* 124 125 136* 138
                                                                                  139 146* 148 150* 153
p_labelp                               parameter       pointer                  dcl 40 ref 20 82
part                   1004            based           char(4)                  array level 3 dcl 3-18 ref 172
partition                       000106 automatic       char(4)                  packed unaligned dcl 56 set ref 81* 94* 171 172 176*
parts                  1004            based           structure                array level 2 dcl 3-18
parts_index                     000107 automatic       fixed bin(17,0)          dcl 57 set ref 172* 172* 174 180 181 181 182 183 183
                                                                                  184 185 189 190 190 191 195 196 196 197
rec_per_dev                     000032 constant        fixed bin(21,0)          initial array dcl 1-87 ref 227 232
seek_command                    000110 automatic       bit(6)                   initial array packed unaligned dcl 1-84 set ref
                                                                                  1-84* 1-84* 1-84* 1-84* 1-84* 1-84* 1-84* 1-84*
                                                                                  1-84*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MODEL                                  internal static fixed bin(17,0)          initial array dcl 1-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 1-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 1-60
bulkdevt                               internal static fixed bin(4,0)           initial dcl 1-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 1-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 1-105
dev_time                               internal static float bin(27)            initial array dcl 1-139
device_names                           internal static char(4)                  initial array dcl 1-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 1-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 1-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 1-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 1-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 1-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 1-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 1-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 1-69
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 1-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 1-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 1-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 1-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 1-127
maxdevt                                internal static fixed bin(4,0)           initial dcl 1-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 1-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 1-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 1-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 1-93
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 1-108
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 1-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 2-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 2-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 2-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 2-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 2-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 1-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 1-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 1-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 1-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 2-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 2-36

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN                          001606 constant        label                    dcl 244 ref 254
bad_arg                         001640 constant        label                    dcl 265 ref 112 129 137 157
bad_rec_spec                    001607 constant        label                    dcl 260 ref 97 121 134 144 170
bce_parse_disk_spec             000162 constant        entry                    external dcl 20
get_next_arg                    001675 constant        entry                    internal dcl 246 ref 93 98 120 135 145
next_arg                        001054 constant        label                    dcl 165
no_neg_rec_nums                 000761 constant        label                    dcl 149 ref 101 124 138

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2112        2144    1761        2122
Length      2422    1761        32         241     131           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bce_parse_disk_spec                 176 external procedure  is an external procedure.  
get_next_arg                            internal procedure  shares stack frame of external procedure bce_parse_disk_spec.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bce_parse_disk_spec      000100 arg_count                   bce_parse_disk_spec
                         000101 arg_len                     bce_parse_disk_spec
                         000102 arg_ptr                     bce_parse_disk_spec
                         000104 n_record                    bce_parse_disk_spec
                         000105 number                      bce_parse_disk_spec
                         000106 partition                   bce_parse_disk_spec
                         000107 parts_index                 bce_parse_disk_spec
                         000110 seek_command                bce_parse_disk_spec
                         000112 labelp                      bce_parse_disk_spec

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count_rel             cu_$arg_ptr_rel               cv_integer_string_check_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$dev_offset_out_of_bounds
error_table_$fsdisk_not_storage                             error_table_$noarg            error_table_$nopart




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000152    1   84 000167        78 000256        79 000261        80 000262        81 000263        82 000265
     84 000270        85 000302        86 000314        87 000333        88 000345        89 000352        90 000356
     91 000403        93 000404        94 000411        95 000416        96 000417        97 000427        98 000436
     99 000443       100 000473       101 000476       103 000500       104 000501       106 000502       108 000503
    109 000511       110 000513       111 000514       112 000515       113 000521       114 000523       118 000524
    119 000525       120 000535       121 000542       122 000546       123 000575       124 000600       125 000602
    126 000603       128 000604       129 000615       132 000623       133 000624       134 000634       135 000637
    136 000644       137 000674       138 000677       139 000701       142 000702       143 000703       144 000713
    145 000717       146 000724       147 000754       148 000757       149 000761       150 000764       151 001011
    153 001012       154 001013       156 001014       157 001025       160 001033       162 001034       163 001051
    165 001054       170 001057       171 001070       172 001075       173 001112       174 001114       175 001120
    176 001124       177 001152       179 001153       180 001156       181 001171       182 001203       183 001207
    184 001224       185 001233       186 001237       188 001240       189 001244       190 001253       191 001265
    192 001271       193 001275       194 001276       195 001301       196 001310       197 001322       198 001326
    201 001332       204 001333       205 001336       206 001347       207 001354       208 001365       209 001372
    211 001373       212 001376       213 001404       214 001411       215 001415       216 001416       217 001421
    218 001427       219 001434       227 001440       228 001453       229 001456       230 001504       232 001505
    233 001512       234 001515       235 001543       237 001544       238 001546       239 001551       240 001604
    243 001605       244 001606       260 001607       262 001613       263 001637       265 001640       267 001643
    268 001674       246 001675       250 001677       251 001701       252 001704       253 001707       254 001727
    256 001730       257 001747


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
