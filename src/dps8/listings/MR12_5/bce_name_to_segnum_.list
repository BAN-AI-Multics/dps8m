	COMPILATION LISTING OF SEGMENT bce_name_to_segnum_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1018.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 bce_name_to_segnum_: proc (p_name, p_segnum, p_code);
        9 
       10 /* Look up the segnum for a hardcore seg in the image.
       11*Keith Loepere, December 1983. */
       12 
       13 /* Changed June 1984 for the riddance of bce_probe_data - Allen Ball. */
       14 /* Also changed to give more information in bce_segptr_to_name_ - ADB */
       15 /* Added segnum check to segptr entry, Keith Loepere, November 1984. */
       16 
       17 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       18 
       19 dcl  addr				builtin;
       20 dcl  addrel			builtin;
       21 dcl  bin				builtin;
       22 dcl  1 closest_hi_def		aligned like definition based (closest_hi_def_ptr);
       23 dcl  closest_hi_def_ptr		ptr;
       24 dcl  1 closest_lo_def		aligned like definition based (closest_lo_def_ptr);
       25 dcl  closest_lo_def_ptr		ptr;
       26 dcl  1 closest_hi_segname_def		aligned like segname_definition based (closest_hi_segname_def_ptr);
       27 dcl  closest_hi_segname_def_ptr	ptr;
       28 dcl  1 closest_lo_segname_def		aligned like segname_definition based (closest_lo_segname_def_ptr);
       29 dcl  closest_lo_segname_def_ptr	ptr;
       30 dcl  component			char (32);
       31 dcl  counter			fixed bin;
       32 dcl  crash_definitions_$		external;
       33 dcl  crash_name_table$		external;
       34 dcl  crash_slt$			external;
       35 dcl  dimension			builtin;
       36 dcl  error_table_$name_not_found	fixed bin (35) ext static;
       37 dcl  hash_index_			entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35)) returns (fixed bin (35));
       38 dcl  hash_value			fixed bin (35);	/* what name hashes to for hash threaded list scan */
       39 dcl  hi_offset			fixed bin (26);
       40 dcl  ioa_$rsnnl			entry () options (variable);
       41 dcl  length			builtin;
       42 dcl  lo_offset			fixed bin (26);
       43 dcl  my_name			char (256);
       44 dcl  my_name_len			fixed bin;
       45 dcl  name				char (32);
       46 dcl  1 name_entry			aligned like segnam.names based (name_entry_ptr); /* an entry in the hash threaded list of names */
       47 dcl  name_entry_ptr			ptr;
       48 dcl  name_entry_rel			bit (18);		/* rel ptr to name_entry */
       49 dcl  name_tries			fixed bin;	/* counter of tries to walk hash threads looking for a name before giving up */
       50 dcl  null				builtin;
       51 dcl  out_of_bounds			condition;
       52 dcl  p_code			fixed bin (35) parameter;
       53 dcl  p_name			char (*) parameter;
       54 dcl  p_segnum			fixed bin (15) parameter;
       55 dcl  return_string			char (256) varying;
       56 dcl  rtrim			builtin;
       57 dcl  seg_name			char (32);
       58 dcl  segno			builtin;
       59 dcl  segnum			fixed bin (15);
       60 dcl  segptr			ptr parameter;
       61 dcl  substr			builtin;
       62 dcl  word				fixed bin (36) unsigned unaligned based;
       63 dcl  wordno			builtin;
       64 dcl  wordnum			fixed bin (26);
       65 
       66 	p_code = 0;
       67 	name = p_name;
       68 	on out_of_bounds goto no_name;
       69 	names_ptr = addr (crash_name_table$);
       70 	hash_value = hash_index_ (addr (name), length (name), 0, dimension (name_seg.ht, 1));
       71 	name_tries = 0;
       72 	do name_entry_rel = name_seg.ht (hash_value)
       73 	     repeat (name_entry.hp)
       74 	     while (name_entry_rel);			/* scan down names that hash alike */
       75 	     name_entry_ptr = addrel (names_ptr, name_entry_rel);
       76 	     if name_entry.name = name then do;
       77 		p_segnum = bin (name_entry.segno, 12);
       78 		return;
       79 	     end;
       80 	     name_tries = name_tries + 1;
       81 	     if name_tries > 100 then go to no_name;
       82 	end;
       83 no_name:
       84 	p_code = error_table_$name_not_found;
       85 	return;
       86 
       87 bce_segnum_to_name_: entry (p_segnum) returns (char (*));
       88 
       89 /* Find the hcname for a segment. */
       90 
       91 	segnum = p_segnum;
       92 	if segnum = 32767 | segnum = 32766 then return ("bad pointer");
       93 	on out_of_bounds goto no_num;
       94 	sltp = addr (crash_slt$);
       95 	if segnum < 0 | segnum < slt.first_sup_seg then go to no_num;
       96 	if slt.last_sup_seg < segnum & segnum < slt.first_init_seg then go to no_num;
       97 	if slt.last_init_seg < segnum then go to no_num;
       98 	sltep = addr (slt.seg (segnum));
       99 	if slte_uns.segno ^= segnum then go to no_num;
      100 	name_entry_ptr = addrel (addr (crash_name_table$), slte.names_ptr);
      101 	name_entry_ptr = addrel (name_entry_ptr, 1);
      102 	return (rtrim (name_entry.name));
      103 
      104 no_num:	call ioa_$rsnnl ("^o", my_name, my_name_len, segnum);
      105 	return (substr (my_name, 1, my_name_len));
      106 
      107 bce_segptr_to_name_: entry (segptr) returns (char (*));
      108 
      109 	return_string = "";
      110 	counter = 1;
      111 	segnum = segno (segptr);
      112 	wordnum = wordno (segptr);
      113 	call ioa_$rsnnl ("^o", my_name, my_name_len, segnum);
      114 	return_string = return_string || substr (my_name, 1, my_name_len) || "|";
      115 	call ioa_$rsnnl ("^o", my_name, my_name_len, wordnum);
      116 	return_string = return_string || substr (my_name, 1, my_name_len);
      117 
      118 	sltp = addr (crash_slt$);
      119 	if segnum < 0 | segnum < slt.first_sup_seg then go to return_simple_ptr;
      120 	if slt.last_sup_seg < segnum & segnum < slt.first_init_seg then go to return_simple_ptr;
      121 	if slt.last_init_seg < segnum then go to return_simple_ptr;
      122 
      123 	on out_of_bounds goto return_simple_ptr;
      124 
      125 	definitions_ptr = addr (crash_definitions_$);
      126 	def_header_ptr = addrel (definitions_ptr, definitions.dot (segnum).offset);
      127 	closest_hi_def_ptr = null;
      128 	closest_lo_def_ptr = null;
      129 
      130 	do def_ptr = addrel (def_header_ptr, definition_header.def_list_relp) repeat addrel (def_header_ptr, definition.forward_relp) while (def_ptr -> word ^= 0 & counter < 1000);
      131 						/* If def_ptr -> zero word then we found the end of the string or if we see a thousand definitions the string must be bad. */
      132 	     counter = counter + 1;
      133 	     if definition.class = CLASS_TEXT then do;	/* We care only about class text definitions. */
      134 		if closest_lo_def_ptr = null then	/*  Find def pointing to closest address below our ptr. */
      135 		     if definition.thing_relp <= wordnum then closest_lo_def_ptr = def_ptr;
      136 		     else ;
      137 		else if closest_lo_def.thing_relp < definition.thing_relp & definition.thing_relp <= wordnum then closest_lo_def_ptr = def_ptr;
      138 		     else ;
      139 		if closest_hi_def_ptr = null then	/* Find def pointing to closest address above our ptr. */
      140 		     if wordnum <= definition.thing_relp then closest_hi_def_ptr = def_ptr;
      141 		     else ;
      142 		else if wordnum <= definition.thing_relp & definition.thing_relp < closest_hi_def.thing_relp then closest_hi_def_ptr = def_ptr;
      143 		     else ;
      144 	     end;
      145 	end;
      146 
      147 	seg_name = bce_segnum_to_name_ (segnum);
      148 	if closest_lo_def_ptr = null then do;
      149 	     call ioa_$rsnnl ("^o", my_name, my_name_len, wordnum);
      150 	     return_string = return_string || " [" || rtrim (bce_segnum_to_name_ (segnum)) || "|" || substr (my_name, 1, my_name_len) || "]";
      151 	end;
      152 	else do;
      153 	     return_string = return_string || " [";
      154 	     closest_lo_segname_def_ptr = addrel (def_header_ptr, closest_lo_def.segname_relp);
      155 	     if closest_hi_def_ptr = null then do;
      156 		acc_string_ptr = addrel (def_header_ptr, closest_lo_segname_def.name_relp);
      157 		return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "$";
      158 		acc_string_ptr = addrel (def_header_ptr, closest_lo_def.name_relp);
      159 		return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "+";
      160 		lo_offset = wordnum - closest_lo_def.thing_relp;
      161 		call ioa_$rsnnl ("^o", my_name, my_name_len, lo_offset);
      162 		return_string = return_string || substr (my_name, 1, my_name_len) || "]";
      163 	     end;
      164 	     else do;
      165 		closest_hi_segname_def_ptr = addrel (def_header_ptr, closest_hi_def.segname_relp);
      166 		if closest_hi_segname_def_ptr = closest_lo_segname_def_ptr then do;
      167 		     acc_string_ptr = addrel (def_header_ptr, closest_lo_segname_def.name_relp);
      168 		     if closest_hi_def_ptr = closest_lo_def_ptr & wordnum - closest_lo_def.thing_relp = 0 then do;
      169 			return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "$";
      170 			acc_string_ptr = addrel (def_header_ptr, closest_lo_def.name_relp);
      171 			return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "+0]";
      172 		     end;
      173 		     else do;
      174 			return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "$(";
      175 			acc_string_ptr = addrel (def_header_ptr, closest_lo_def.name_relp);
      176 			return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "+";
      177 			lo_offset = wordnum - closest_lo_def.thing_relp;
      178 			call ioa_$rsnnl ("^o", my_name, my_name_len, lo_offset);
      179 			return_string = return_string || substr (my_name, 1, my_name_len);
      180 			acc_string_ptr = addrel (def_header_ptr, closest_hi_def.name_relp);
      181 			return_string = return_string || " " || substr (acc_string.string, 1, acc_string.count) || "-";
      182 			hi_offset = closest_hi_def.thing_relp - wordnum;
      183 			call ioa_$rsnnl ("^o", my_name, my_name_len, hi_offset);
      184 			return_string = return_string || substr (my_name, 1, my_name_len) || ")]";
      185 		     end;
      186 		end;
      187 		else do;
      188 		     acc_string_ptr = addrel (def_header_ptr, closest_lo_segname_def.name_relp);
      189 		     return_string = return_string || "(" || substr (acc_string.string, 1, acc_string.count) || "$";
      190 		     acc_string_ptr = addrel (def_header_ptr, closest_lo_def.name_relp);
      191 		     return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "+";
      192 		     lo_offset = wordnum - closest_lo_def.thing_relp;
      193 		     call ioa_$rsnnl ("^o", my_name, my_name_len, lo_offset);
      194 		     return_string = return_string || substr (my_name, 1, my_name_len);
      195 		     acc_string_ptr = addrel (def_header_ptr, closest_hi_segname_def.name_relp);
      196 		     return_string = return_string || " " || substr (acc_string.string, 1, acc_string.count) || "$";
      197 		     acc_string_ptr = addrel (def_header_ptr, closest_hi_def.name_relp);
      198 		     return_string = return_string || substr (acc_string.string, 1, acc_string.count) || "-";
      199 		     hi_offset = closest_hi_def.thing_relp - wordnum;
      200 		     call ioa_$rsnnl ("^o", my_name, my_name_len, hi_offset);
      201 		     return_string = return_string || substr (my_name, 1, my_name_len) || ")]";
      202 		end;
      203 	     end;
      204 	end;
      205 
      206 return_simple_ptr:
      207 	return (return_string);
      208 
      209  /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  1     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  1     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  1     8*     definition header, declare the msf_map, and add structures and constants
  1     9*     for deferred initialization.
  1    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  1    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  1    12*     added the structures for pointer initialization. pointer_init_template.
  1    13*     changed list_template_entry
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 
  1    17 /* Modified:  */
  1    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  1    19 /*	after unused half-word instead of before it. */
  1    20 /*   1 March 1983 by M. Weaver to add list template init type */
  1    21 
  1    22 /* format: style3,idind25 */
  1    23 /* everything for the definition section */
  1    24 
  1    25 declare	(
  1    26 	CLASS_TEXT	     init (0),		/* text section definition */
  1    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  1    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  1    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  1    30 	CLASS_STATIC	     init (4),		/* static section definition */
  1    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  1    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  1    33 	)		     fixed bin (3) unsigned internal static options (constant);
  1    34 
  1    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  1    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  1    37 
  1    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  1    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  1    40 			     options (constant);
  1    41 
  1    42 declare	1 definition_flags	     unaligned based,
  1    43 	  2 new		     bit (1),		/* should be "1"b */
  1    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  1    45 	  2 entry		     bit (1),		/* can tra here */
  1    46 	  2 retain	     bit (1),		/* binder respects this */
  1    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  1    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  1    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  1    50 	  2 unused	     bit (8);		/* Must be zero */
  1    51 
  1    52 
  1    53 
  1    54 
  1    55 /* Header of the definition section */
  1    56 
  1    57 declare	def_header_ptr	     pointer;
  1    58 declare	1 definition_header	     aligned based (def_header_ptr),
  1    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  1    60 						/* first definition, reloc def18 */
  1    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  1    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  1    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  1    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  1    65 	  2 flags		     unaligned like definition_flags;
  1    66 						/* both new and ignore must be "1"b here */
  1    67 
  1    68 /* A non class=3 definition. See segname_definition below for class=3 */
  1    69 
  1    70 
  1    71 declare	def_ptr		     pointer;
  1    72 declare	1 definition	     aligned based (def_ptr),
  1    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  1    74 						/* offset of next def */
  1    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  1    76 						/* offset of previous def */
  1    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  1    78 						/* offset in section specified by class of thing this defines */
  1    79 	  2 flags		     unaligned like definition_flags,
  1    80 	  2 class		     unal fixed bin (3) unsigned,
  1    81 						/* Type of definition */
  1    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  1    83 						/* offset of ACC for symbol */
  1    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  1    85 						/* offset of segname def to which this belongs */
  1    86 
  1    87 /* Class=3, segname definition */
  1    88 
  1    89 declare	segname_ptr	     pointer;
  1    90 declare	1 segname_definition     aligned based (segname_ptr),
  1    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  1    92 						/* offset of next def */
  1    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  1    94 						/* offset of previous def */
  1    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  1    96 						/* offset of next segname def */
  1    97 	  2 flags		     unaligned like definition_flags,
  1    98 	  2 class		     unal fixed bin (3) unsigned,
  1    99 						/* 3 for segname */
  1   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  1   101 						/* offset of ACC for symbol */
  1   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  1   103 						/* see following : */
  1   104 
  1   105 /* Definition blocks are chained off of segname definitions.
  1   106*   segname_definition.first_relp is one of three things:
  1   107*    (1) the def section offset of the first ordinary (class^=3) definition
  1   108*      belonging to this segname block. In the case where there are more than
  1   109*      one segname's on a block, all their first_relp will point
  1   110*      to the same place.
  1   111*
  1   112*    (2) if there are no ordinary definitions associated with this segname,
  1   113*      then it is the def section offset of the next segname. 
  1   114*
  1   115*    (3) if there are no ordinary definitions in the block, and it
  1   116*      is the last block, then it points to a word containing 0.
  1   117*
  1   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  1   119*   pointing to a class=3 definition whose first_relp is not the same as
  1   120*   the current definitions first_relp.
  1   121**/
  1   122 
  1   123 /* All the definitions are linked through the forward and
  1   124*   backward thread variables. The end of the chain can is indicated
  1   125*   by forward pointing to a zero word. */
  1   126 
  1   127 
  1   128 declare	exp_ptr		     pointer;
  1   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  1   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  1   131 						/* pointer (rel to defs) of type pair structure */
  1   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  1   133 
  1   134 declare	(
  1   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  1   136 						/* which section determined by segname_relp */
  1   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  1   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  1   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  1   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  1   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  1   142 	SECTION_TEXT	     init (0),		/* *text */
  1   143 	SECTION_LINK	     init (1),		/* *link */
  1   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  1   145 	SECTION_UNUSED	     init (3),		/* reserved */
  1   146 	SECTION_STATIC	     init (4),		/* *static */
  1   147 	SECTION_SYSTEM	     init (5),		/* *system */
  1   148 	SECTION_HEAP	     init (6)		/* *heap */
  1   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  1   150 
  1   151 /* use CLASS_NAMES for section names */
  1   152 
  1   153 declare	LINK_TYPE_NAMES	     (1:6)
  1   154 			     init ("absolute in section", "unused", "absolute off of refname",
  1   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  1   156 			     character (32) varying internal static options (constant);
  1   157 
  1   158 
  1   159 declare	type_ptr		     pointer;
  1   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  1   161 	  2 type		     fixed bin (18) unsigned unal,
  1   162 						/* see above */
  1   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  1   164 						/* pointer (rel to defs) to the trap word */
  1   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  1   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  1   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  1   168* /*or section code for SELF links */
  1   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  1   170 						/* for OFFSETNAME links, ACC string of name of location. */
  1   171 						/* for others, must be ZERO */
  1   172 
  1   173 
  1   174 /* Link Trap Pair */
  1   175 
  1   176 declare	link_trap_ptr	     pointer;
  1   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  1   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  1   179 						/* LINK18, link to thing to call */
  1   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  1   181 						/* LINK18, link to argument list */
  1   182 
  1   183 
  1   184 /* initialization info for *system or *heap link */
  1   185 
  1   186 
  1   187 /* NOTE --------------------------------------------------
  1   188*   the following structures defining initialization information are also
  1   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  1   190*   and should be kept equivalent
  1   191*   -------------------------------------------------------
  1   192**/
  1   193 
  1   194 declare	(
  1   195 	INIT_NO_INIT	     init (0),
  1   196 	INIT_COPY_INFO	     init (3),
  1   197 	INIT_DEFINE_AREA	     init (4),
  1   198 	INIT_LIST_TEMPLATE	     init (5),
  1   199 	INIT_DEFERRED	     init (6)
  1   200 	)		     fixed bin internal static options (constant);
  1   201 
  1   202 /* for type = 0 or 4 */
  1   203 
  1   204 declare	link_init_ptr	     pointer;
  1   205 declare	1 link_init	     aligned based (link_init_ptr),
  1   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  1   207 	  2 type		     fixed bin;		/* see types above */
  1   208 
  1   209 /* for type=3, there is data to copy */
  1   210 
  1   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  1   212 	  2 header	     aligned like link_init,
  1   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  1   214 
  1   215 declare	link_init_n_words	     fixed bin;
  1   216 
  1   217 /* for type = 5, there is a list template to copy */
  1   218 
  1   219 declare	1 link_init_list_template
  1   220 			     aligned based (link_init_ptr),
  1   221 	  2 header	     aligned like link_init,
  1   222 	  2 pad		     bit (18) unaligned,
  1   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  1   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  1   225 
  1   226 declare	link_init_n_words_in_list
  1   227 			     fixed bin;
  1   228 
  1   229 /* A list template consists of a series of entries with the following
  1   230*   description, concatenated together.  n_bits and datum are bit items,
  1   231*   to permit a wide range of inputs.
  1   232*
  1   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  1   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  1   235*
  1   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  1   237*   of their particular storage section. */
  1   238 
  1   239 declare	1 list_template_entry    aligned based,
  1   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  1   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  1   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  1   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  1   244 						/* number of times to repeat datum */
  1   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  1   246 
  1   247 
  1   248 /* the pointer_init_template represents the initialization information
  1   249*   for ITS and packed pointers.  Both pointer types require the entire
  1   250*   72 bit structure.
  1   251**/
  1   252 
  1   253 dcl       1 pointer_init_template  based,
  1   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  1   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  1   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  1   257 	  2 mbz		     bit (12) unaligned,
  1   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  1   259 
  1   260 
  1   261 declare	link_init_n_bits_in_datum
  1   262 			     fixed bin (35);
  1   263 
  1   264 /* for type = 6, the init_info resides in another MSF component */
  1   265 /* target_relp is a linkage section offset to a partial link to */
  1   266 /* the base of the linkage section of the component containing  */
  1   267 /* the actual init_info. link_relp is the offset of the actual  */
  1   268 /* link within that linkage section.			    */
  1   269 
  1   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  1   271 	  2 header	     aligned like link_init,
  1   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  1   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  1   274 
  1   275 /* Definition section hash table */
  1   276 
  1   277 declare	def_ht_ptr	     pointer;
  1   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  1   279 	  2 n_entries	     fixed bin,
  1   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  1   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  1   282 	    3 unused	     bit (18) unaligned;
  1   283 
  1   284 declare	def_ht_n_entries	     fixed bin;
  1   285 
  1   286 
  1   287 /* Component name ht */
  1   288 declare	comp_ht_ptr	     pointer;
  1   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  1   290 	  2 n_entries	     fixed bin,
  1   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  1   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  1   293 						/* hashed segname */
  1   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  1   295 						/* first segname def of block containing def_relp */
  1   296 
  1   297 declare	comp_ht_n_entries	     fixed bin;
  1   298 
  1   299 /* Duplicate name table */
  1   300 
  1   301 declare	dup_table_ptr	     pointer;
  1   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  1   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  1   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  1   305 						/* n in table */
  1   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  1   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  1   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  1   309 
  1   310 declare	dup_table_n_names	     fixed bin;
  1   311 
  1   312 /* The msf_map is found in the definition section of an	*/
  1   313 /* object MSF component.  It is used by the linker to	*/
  1   314 /* determine whether a segment is a component of an object	*/
  1   315 /* MSF or a standard single-segment object.		*/
  1   316   
  1   317   dcl msf_map_ptr		ptr;
  1   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  1   319        02 version		char (8),
  1   320        02 component_count	fixed bin (15) unsigned,
  1   321        02 my_component	fixed bin (15) unsigned;
  1   322   
  1   323   dcl msf_map_version_1	char (8) static options (constant)
  1   324 			     init ("msfmp1.0");
  1   325   
  1   326 declare	acc_string_ptr	     pointer;
  1   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  1   328 	  2 count		     fixed bin (9) unsigned unaligned,
  1   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  1   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  1   331 						/* unspec (acc_string) = ""b to zero out */
  1   332 						/* the last word, if the string is not of length 0mod4 */
  1   333 
  1   334 declare	acc_string_length	     fixed bin (21);
  1   335 
  1   336 
  1   337 /* end include file definitions_dcls.incl.pl1 */
      209 
      210  /* Begin include file hc_definitions_seg.incl.pl1 BIM 7/82 */
  2     2 /* format: style3 */
  2     3 
  2     4 declare	definitions_ptr	ptr;
  2     5 
  2     6 declare	1 definitions	aligned based (definitions_ptr),
  2     7 	  2 next_free_ptr	pointer,			/* next section, starts after table */
  2     8 	  2 dot		(2:511) aligned,		/* definitions_offset_table */
  2     9 	    3 offset	fixed bin (18) uns unal,	/* in this segment */
  2    10 	    3 length	fixed bin unal,
  2    11 	  2 first_free	bit (0) aligned;
  2    12 
  2    13 /* End include file hc_definitions_seg.incl.pl1 */
      210 
      211  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  3     2 
  3     3 /* Declarations for Segment Loading Table header and array.
  3     4*
  3     5*   Used by Initialization and MST Checker subroutines */
  3     6 
  3     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  3     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  3     9     namep ptr,					/* pointer to segment name list block */
  3    10     pathp ptr,					/* pointer to segment's directory path name */
  3    11     aclp ptr;					/* pointer to acl structure */
  3    12 
  3    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  3    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  3    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  3    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  3    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  3    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  3    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  3    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  3    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  3    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  3    23 
  3    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  3    25 
  3    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  3    27 	2 pad bit (18) unal,
  3    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  3    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  3    30 
  3    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  3    32 	2 count fixed bin (17),			/* number of segment names in this block */
  3    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  3    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  3    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  3    36 	  3 pad bit (5) unal,
  3    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  3    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  3    39 
  3    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  3    41 	2 size fixed bin (17),			/* length of pathname */
  3    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  3    43 	2 acls fixed bin;				/* ACL list starts here */
  3    44 
  3    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  3    46 	2 count fixed bin,				/* number of entries in acl list */
  3    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  3    48 	  3 userid char (32),			/* user specification */
  3    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  3    50 	  3 pad bit (36) aligned,
  3    51 	  3 code fixed bin;
  3    52 
  3    53 
  3    54 /* END INCLUDE FILE slt.incl.pl1 */
      211 
      212  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  4     2 /* Declaration for Segment Loading Table Entry structure.
  4     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  4     4 /* modified 5/4/76 by Noel I. Morris	*/
  4     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  4     6 /* format: style3 */
  4     7 
  4     8 dcl	sltep		ptr;
  4     9 
  4    10 dcl	1 slte_uns	based (sltep) aligned,
  4    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  4    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  4    13 /**** End of word 1 */
  4    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  4    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  4    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  4    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  4    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  4    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  4    20 	  2 pad1		bit (3),			/* unused */
  4    21 	  2 wired		bit (1),			/* segment is wired if ON */
  4    22 	  2 paged		bit (1),			/* segment is paged if ON */
  4    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  4    24 	  2 pad3		bit (2),
  4    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  4    26 /**** End of 1st half of word 2 */
  4    27 	  2 pad4		bit (3),
  4    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  4    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  4    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  4    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  4    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  4    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  4    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  4    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  4    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  4    37 /***** End of word 2 */
  4    38 	  2 pad5		bit (6),
  4    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  4    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  4    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  4    42 /***** End of word 3 */
  4    43 	  2 pad7		bit (3),
  4    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  4    45 	  2 bit_count	fixed bin (24) uns
  4    46 	  )		unaligned;		/* bitcount of segment */
  4    47 
  4    48 dcl	1 slte		based (sltep) aligned,
  4    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  4    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  4    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  4    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  4    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  4    54 	  2 firmware_seg    bit (1),
  4    55 	  2 layout_seg      bit (1),
  4    56 	  2 breakpointable  bit (1),
  4    57 	  2 pad2		bit (3),
  4    58 	  2 wired		bit (1),			/* segment is wired if ON */
  4    59 	  2 paged		bit (1),			/* segment is paged if ON */
  4    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  4    61 	  2 pad3		bit (2),
  4    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  4    63 	  2 pad4		bit (3),
  4    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  4    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  4    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  4    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  4    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  4    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  4    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  4    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  4    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  4    73 	  2 pad5		bit (6),
  4    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  4    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  4    76 	  2 segno		bit (18),			/* text/link segment number */
  4    77 	  2 pad6		bit (3),
  4    78 	  2 max_length	bit (9),			/* maximum length for segment */
  4    79 	  2 bit_count	bit (24)
  4    80 	  )		unaligned;		/* bitcount of segment */
  4    81 
  4    82 /* END INCLUDE FILE slte.incl.pl1 */
      212 
      213      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.6  bce_name_to_segnum_.pl1           >special_ldd>install>MR12.3-1114>bce_name_to_segnum_.pl1
209          1    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
210          2    10/20/82  0938.5  hc_definitions_seg.incl.pl1       >ldd>include>hc_definitions_seg.incl.pl1
211          3    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
212          4    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CLASS_TEXT                             constant        fixed bin(3,0)           initial unsigned dcl 1-25 ref 133
acc_string                             based           structure                level 1 dcl 1-327
acc_string_ptr                  000360 automatic       pointer                  dcl 1-326 set ref 156* 157 157 158* 159 159 167* 169
                                                                                  169 170* 171 171 174 174 175* 176 176 180* 181 181
                                                                                  188* 189 189 190* 191 191 195* 196 196 197* 198
                                                                                  198
addr                                                   builtin function         dcl 19 ref 69 70 70 94 98 100 118 125
addrel                                                 builtin function         dcl 20 ref 75 100 101 126 130 145 154 156 158 165
                                                                                  167 170 175 180 188 190 195 197
bin                                                    builtin function         dcl 21 ref 77
class                     1(33)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 1-72
                                                                                  ref 133
closest_hi_def                         based           structure                level 1 dcl 22
closest_hi_def_ptr              000100 automatic       pointer                  dcl 23 set ref 127* 139 139* 142 142* 155 165 168
                                                                                  180 182 197 199
closest_hi_segname_def                 based           structure                level 1 dcl 26
closest_hi_segname_def_ptr      000104 automatic       pointer                  dcl 27 set ref 165* 166 195
closest_lo_def                         based           structure                level 1 dcl 24
closest_lo_def_ptr              000102 automatic       pointer                  dcl 25 set ref 128* 134 134* 137 137* 148 154 158
                                                                                  160 168 168 170 175 177 190 192
closest_lo_segname_def                 based           structure                level 1 dcl 28
closest_lo_segname_def_ptr      000106 automatic       pointer                  dcl 29 set ref 154* 156 166 167 188
count                                  based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 1-327
                                                                                  ref 157 157 159 159 169 169 171 171 174 174 176
                                                                                  176 181 181 189 189 191 191 196 196 198 198
counter                         000110 automatic       fixed bin(17,0)          dcl 31 set ref 110* 130 132* 132
crash_definitions_$             000010 external static fixed bin(17,0)          dcl 32 set ref 125
crash_name_table$               000012 external static fixed bin(17,0)          dcl 33 set ref 69 100
crash_slt$                      000014 external static fixed bin(17,0)          dcl 34 set ref 94 118
def_header_ptr                  000354 automatic       pointer                  dcl 1-57 set ref 126* 130 130 145 154 156 158 165
                                                                                  167 170 175 180 188 190 195 197
def_list_relp                          based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-58
                                                                                  ref 130
def_ptr                         000356 automatic       pointer                  dcl 1-71 set ref 130* 130* 133 134 134 137 137 137
                                                                                  139 139 142 142 142* 145
definition                             based           structure                level 1 dcl 1-72
definition_flags                       based           structure                level 1 packed packed unaligned dcl 1-42
definition_header                      based           structure                level 1 dcl 1-58
definitions                            based           structure                level 1 dcl 2-6
definitions_ptr                 000362 automatic       pointer                  dcl 2-4 set ref 125* 126 126
dimension                                              builtin function         dcl 35 ref 70 70
dot                       2            based           structure                array level 2 dcl 2-6
error_table_$name_not_found     000016 external static fixed bin(35,0)          dcl 36 ref 83
first_init_seg            5            based           fixed bin(18,0)          level 2 dcl 3-13 ref 96 120
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 3-13 ref 95 119
forward_relp                           based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-72
                                                                                  ref 145
hash_index_                     000020 constant        entry                    external dcl 37 ref 70
hash_value                      000111 automatic       fixed bin(35,0)          dcl 38 set ref 70* 72
hi_offset                       000112 automatic       fixed bin(26,0)          dcl 39 set ref 182* 183* 199* 200*
hp                                     based           bit(18)                  level 2 packed packed unaligned dcl 46 ref 82
ht                        1            based           bit(18)                  array level 2 dcl 3-26 ref 70 70 72
ioa_$rsnnl                      000022 constant        entry                    external dcl 40 ref 104 113 115 149 161 178 183 193
                                                                                  200
last_init_seg             6            based           fixed bin(18,0)          level 2 dcl 3-13 ref 97 121
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 3-13 ref 96 120
length                                                 builtin function         dcl 41 ref 70 70
link_init                              based           structure                level 1 dcl 1-205
lo_offset                       000113 automatic       fixed bin(26,0)          dcl 42 set ref 160* 161* 177* 178* 192* 193*
my_name                         000114 automatic       char(256)                packed unaligned dcl 43 set ref 104* 105 113* 114
                                                                                  115* 116 149* 150 161* 162 178* 179 183* 184 193*
                                                                                  194 200* 201
my_name_len                     000214 automatic       fixed bin(17,0)          dcl 44 set ref 104* 105 113* 114 115* 116 149* 150
                                                                                  161* 162 178* 179 183* 184 193* 194 200* 201
name                            000215 automatic       char(32)                 packed unaligned dcl 45 in procedure
                                                                                  "bce_name_to_segnum_" set ref 67* 70 70 70 70 76
name                      1            based           char(32)                 level 2 in structure "name_entry" packed packed
                                                                                  unaligned dcl 46 in procedure
                                                                                  "bce_name_to_segnum_" ref 76 102
name_entry                             based           structure                level 1 dcl 46
name_entry_ptr                  000226 automatic       pointer                  dcl 47 set ref 75* 76 77 82 100* 101* 101 102
name_entry_rel                  000230 automatic       bit(18)                  packed unaligned dcl 48 set ref 72* 72* 75*
name_relp                 2            based           fixed bin(18,0)          level 2 in structure "closest_hi_segname_def" packed
                                                                                  packed unsigned unaligned dcl 26 in procedure
                                                                                  "bce_name_to_segnum_" ref 195
name_relp                 2            based           fixed bin(18,0)          level 2 in structure "closest_lo_segname_def" packed
                                                                                  packed unsigned unaligned dcl 28 in procedure
                                                                                  "bce_name_to_segnum_" ref 156 167 188
name_relp                 2            based           fixed bin(18,0)          level 2 in structure "closest_hi_def" packed packed
                                                                                  unsigned unaligned dcl 22 in procedure
                                                                                  "bce_name_to_segnum_" ref 180 197
name_relp                 2            based           fixed bin(18,0)          level 2 in structure "closest_lo_def" packed packed
                                                                                  unsigned unaligned dcl 24 in procedure
                                                                                  "bce_name_to_segnum_" ref 158 170 175 190
name_seg                               based           structure                level 1 dcl 3-26
name_tries                      000231 automatic       fixed bin(17,0)          dcl 49 set ref 71* 80* 80 81
names                     1            based           structure                array level 2 dcl 3-31
names_ptr                       000366 automatic       pointer                  dcl 3-7 in procedure "bce_name_to_segnum_" set ref
                                                                                  69* 70 70 72 75
names_ptr                              based           bit(18)                  level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 4-48 in procedure "bce_name_to_segnum_" ref
                                                                                  100
null                                                   builtin function         dcl 50 ref 127 128 134 139 148 155
offset                    2            based           fixed bin(18,0)          array level 3 packed packed unsigned unaligned
                                                                                  dcl 2-6 ref 126
out_of_bounds                   000232 stack reference condition                dcl 51 ref 68 93 123
p_code                                 parameter       fixed bin(35,0)          dcl 52 set ref 8 66* 83*
p_name                                 parameter       char                     packed unaligned dcl 53 ref 8 67
p_segnum                               parameter       fixed bin(15,0)          dcl 54 set ref 8 77* 87 91
return_string                   000240 automatic       varying char(256)        dcl 55 set ref 109* 114* 114 116* 116 150* 150 153*
                                                                                  153 157* 157 159* 159 162* 162 169* 169 171* 171
                                                                                  174* 174 176* 176 179* 179 181* 181 184* 184 189*
                                                                                  189 191* 191 194* 194 196* 196 198* 198 201* 201
                                                                                  206
rtrim                                                  builtin function         dcl 56 ref 102 150
seg                      10            based           structure                array level 2 dcl 3-13 set ref 98
seg_name                        000341 automatic       char(32)                 packed unaligned dcl 57 set ref 147*
segnam                                 based           structure                level 1 dcl 3-31
segname_definition                     based           structure                level 1 dcl 1-90
segname_relp              2(18)        based           fixed bin(18,0)          level 2 in structure "closest_hi_def" packed packed
                                                                                  unsigned unaligned dcl 22 in procedure
                                                                                  "bce_name_to_segnum_" ref 165
segname_relp              2(18)        based           fixed bin(18,0)          level 2 in structure "closest_lo_def" packed packed
                                                                                  unsigned unaligned dcl 24 in procedure
                                                                                  "bce_name_to_segnum_" ref 154
segno                     2(18)        based           fixed bin(18,0)          level 2 in structure "slte_uns" packed packed
                                                                                  unsigned unaligned dcl 4-10 in procedure
                                                                                  "bce_name_to_segnum_" ref 99
segno                     0(24)        based           bit(12)                  level 2 in structure "name_entry" packed packed
                                                                                  unaligned dcl 46 in procedure
                                                                                  "bce_name_to_segnum_" ref 77
segno                                                  builtin function         dcl 58 in procedure "bce_name_to_segnum_" ref 111
segnum                          000351 automatic       fixed bin(15,0)          dcl 59 set ref 91* 92 92 95 95 96 96 97 98 99 104*
                                                                                  111* 113* 119 119 120 120 121 126 147* 150*
segptr                                 parameter       pointer                  dcl 60 ref 107 111 112
slt                                    based           structure                level 1 dcl 3-13
slte                                   based           structure                level 1 dcl 4-48
slte_uns                               based           structure                level 1 dcl 4-10
sltep                           000370 automatic       pointer                  dcl 4-8 set ref 98* 99 100
sltp                            000364 automatic       pointer                  dcl 3-7 set ref 94* 95 96 96 97 98 118* 119 120 120
                                                                                  121
string                    0(09)        based           char                     level 2 packed packed unaligned dcl 1-327 ref 157
                                                                                  159 169 171 174 176 181 189 191 196 198
substr                                                 builtin function         dcl 61 ref 105 114 116 150 157 159 162 169 171 174
                                                                                  176 179 181 184 189 191 194 196 198 201
thing_relp                1            based           fixed bin(18,0)          level 2 in structure "closest_hi_def" packed packed
                                                                                  unsigned unaligned dcl 22 in procedure
                                                                                  "bce_name_to_segnum_" ref 142 182 199
thing_relp                1            based           fixed bin(18,0)          level 2 in structure "closest_lo_def" packed packed
                                                                                  unsigned unaligned dcl 24 in procedure
                                                                                  "bce_name_to_segnum_" ref 137 160 168 177 192
thing_relp                1            based           fixed bin(18,0)          level 2 in structure "definition" packed packed
                                                                                  unsigned unaligned dcl 1-72 in procedure
                                                                                  "bce_name_to_segnum_" ref 134 137 137 139 142 142
word                                   based           fixed bin(36,0)          packed unsigned unaligned dcl 62 ref 130
wordno                                                 builtin function         dcl 63 ref 112
wordnum                         000352 automatic       fixed bin(26,0)          dcl 64 set ref 112* 115* 134 137 139 142 149* 160
                                                                                  168 177 182 192 199

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 1-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 1-25
CLASS_NAMES                            internal static char(12)                 initial array packed unaligned dcl 1-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 1-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 1-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 1-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 1-25
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 1-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 1-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 1-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 1-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 1-194
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 1-153
SECTION_HEAP                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_LINK                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array packed unaligned dcl 1-38
acc_string_length                      automatic       fixed bin(21,0)          dcl 1-334
aclp                                   automatic       pointer                  dcl 3-7
acls                                   based           structure                level 1 dcl 3-45
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 1-297
comp_ht_ptr                            automatic       pointer                  dcl 1-288
component                              automatic       char(32)                 packed unaligned dcl 30
component_ht                           based           structure                level 1 dcl 1-289
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 1-284
def_ht_ptr                             automatic       pointer                  dcl 1-277
definition_ht                          based           structure                level 1 dcl 1-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 1-310
dup_table_ptr                          automatic       pointer                  dcl 1-301
duplicate_table                        based           structure                level 1 dcl 1-302
exp_ptr                                automatic       pointer                  dcl 1-128
exp_word                               based           structure                level 1 dcl 1-129
link_init_copy_info                    based           structure                level 1 dcl 1-211
link_init_deferred                     based           structure                level 1 dcl 1-270
link_init_list_template                based           structure                level 1 dcl 1-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 1-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 1-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 1-226
link_init_ptr                          automatic       pointer                  dcl 1-204
link_trap_pair                         based           structure                level 1 dcl 1-177
link_trap_ptr                          automatic       pointer                  dcl 1-176
list_template_entry                    based           structure                level 1 dcl 1-239
msf_map                                based           structure                level 1 dcl 1-318
msf_map_ptr                            automatic       pointer                  dcl 1-317
msf_map_version_1                      internal static char(8)                  initial packed unaligned dcl 1-323
namep                                  automatic       pointer                  dcl 3-7
path                                   based           structure                level 1 dcl 3-40
pathp                                  automatic       pointer                  dcl 3-7
pointer_init_template                  based           structure                level 1 packed packed unaligned dcl 1-253
segname_ptr                            automatic       pointer                  dcl 1-89
type_pair                              based           structure                level 1 dcl 1-160
type_ptr                               automatic       pointer                  dcl 1-159

NAMES DECLARED BY EXPLICIT CONTEXT.
bce_name_to_segnum_             000035 constant        entry                    external dcl 8
bce_segnum_to_name_             000212 constant        entry                    external dcl 87 ref 147 150
bce_segptr_to_name_             000424 constant        entry                    external dcl 107
no_name                         000173 constant        label                    dcl 83 ref 68 81
no_num                          000353 constant        label                    dcl 104 ref 93 95 96 97 99
return_simple_ptr               002460 constant        label                    dcl 206 ref 119 120 121 123

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2662        2706    2510        2672
Length      3170    2510        24         245     151           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bce_name_to_segnum_                 294 external procedure  is an external procedure.  
on unit on line 68                   64 on unit               
on unit on line 93                   64 on unit               
on unit on line 123                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bce_name_to_segnum_      000100 closest_hi_def_ptr          bce_name_to_segnum_
                         000102 closest_lo_def_ptr          bce_name_to_segnum_
                         000104 closest_hi_segname_def_ptr  bce_name_to_segnum_
                         000106 closest_lo_segname_def_ptr  bce_name_to_segnum_
                         000110 counter                     bce_name_to_segnum_
                         000111 hash_value                  bce_name_to_segnum_
                         000112 hi_offset                   bce_name_to_segnum_
                         000113 lo_offset                   bce_name_to_segnum_
                         000114 my_name                     bce_name_to_segnum_
                         000214 my_name_len                 bce_name_to_segnum_
                         000215 name                        bce_name_to_segnum_
                         000226 name_entry_ptr              bce_name_to_segnum_
                         000230 name_entry_rel              bce_name_to_segnum_
                         000231 name_tries                  bce_name_to_segnum_
                         000240 return_string               bce_name_to_segnum_
                         000341 seg_name                    bce_name_to_segnum_
                         000351 segnum                      bce_name_to_segnum_
                         000352 wordnum                     bce_name_to_segnum_
                         000354 def_header_ptr              bce_name_to_segnum_
                         000356 def_ptr                     bce_name_to_segnum_
                         000360 acc_string_ptr              bce_name_to_segnum_
                         000362 definitions_ptr             bce_name_to_segnum_
                         000364 sltp                        bce_name_to_segnum_
                         000366 names_ptr                   bce_name_to_segnum_
                         000370 sltep                       bce_name_to_segnum_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_in_desc    call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           signal_op           enable_op           shorten_stack       ext_entry_desc      int_entry
return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hash_index_                   ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
crash_definitions_$           crash_name_table$             crash_slt$                    error_table_$name_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      8 000031        66 000055        67 000056        68 000063        69 000102        70 000105        71 000132
     72 000133        75 000142        76 000145        77 000151        78 000154        80 000163        81 000164
     82 000167        83 000173        85 000177        87 000206        91 000223        92 000225        93 000247
     94 000266        95 000271        96 000275        97 000301        98 000303        99 000306       100 000312
    101 000320       102 000322       104 000353       105 000402       107 000420       109 000432       110 000433
    111 000435       112 000444       113 000447       114 000476       115 000532       116 000562       118 000574
    119 000577       120 000603       121 000607       123 000611       125 000630       126 000633       127 000641
    128 000643       130 000644       132 000664       133 000665       134 000670       136 000701       137 000702
    139 000716       141 000727       142 000730       145 000743       147 000751       148 000775       149 001002
    150 001031       151 001152       153 001154       154 001166       155 001174       156 001200       157 001205
    158 001242       159 001250       160 001306       161 001315       162 001344       163 001400       165 001402
    166 001410       167 001414       168 001421       169 001433       170 001470       171 001476       172 001534
    174 001536       175 001573       176 001601       177 001637       178 001643       179 001672       180 001704
    181 001712       182 001762       183 001767       184 002016       185 002052       186 002053       188 002054
    189 002061       190 002130       191 002136       192 002174       193 002203       194 002232       195 002244
    196 002252       197 002322       198 002331       199 002367       200 002374       201 002423       202 002457
    206 002460


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
