 //
//  dps8_faults.c
//  dps8
//
//  Created by Harry Reed on 6/11/13.
//  Copyright (c) 2013 Harry Reed. All rights reserved.
//

#include <stdio.h>

#include "dps8.h"

#ifndef QUIET_UNUSED
static t_uint64 FR;
#endif

/*
 FAULT RECOGNITION
 For the discussion following, the term "function" is defined as a major processor functional cycle. Examples are: APPEND CYCLE, CA CYCLE, INSTRUCTION FETCH CYCLE, OPERAND STORE CYCLE, DIVIDE EXECUTION CYCLE. Some of these cycles are discussed in various sections of this manual.
 Faults in groups 1 and 2 cause the processor to abort all functions immediately by entering a FAULT CYCLE.
 Faults in group 3 cause the processor to "close out" current functions without taking any irrevocable action (such as setting PTW.U in an APPEND CYCLE or modifying an indirect word in a CA CYCLE), then to discard any pending functions (such as an APPEND CYCLE needed during a CA CYCLE), and to enter a FAULT CYCLE.
 Faults in group 4 cause the processor to suspend overlapped operation, to complete current and pending functions for the current instruction, and then to enter a FAULT CYCLE.
 Faults in groups 5 or 6 are normally detected during virtual address formation and instruction decode. These faults cause the processor to suspend overlapped operation, to complete the current and pending instructions, and to enter a FAULT CYCLE. If a fault in a higher priority group is generated by the execution of the current or pending instructions, that higher priority fault will take precedence and the group 5 or 6 fault will be lost. If a group 5 or 6 fault is detected during execution of the current instruction (e.g., an access violation, out of segment bounds, fault
 ￼￼
 during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault.
 Faults in group 7 are held and processed (with interrupts) at the completion of the current instruction pair. Group 7 faults are inhibitable by setting bit 28 of the instruction word.
 Faults in groups 3 through 6 must wait for the system controller to acknowledge the last access request before entering the FAULT CYCLE.
 */

/*
 
                                Table 7-1. List of Faults
 
 Decimal fault     Octal (1)      Fault   Fault name            Priority    Group
     number      fault address   mnemonic
        0      ;         0     ;      sdf  ;   Shutdown             ;   27     ;     7
        1      ;         2     ;      str  ;   Store                ;   10     ;     4
        2      ;         4     ;      mme  ;   Master mode entry 1  ;   11     ;     5
        3      ;         6     ;      f1   ;   Fault tag 1          ;   17     ;     5
        4      ;        10     ;      tro  ;   Timer runout         ;   26     ;     7
        5      ;        12     ;      cmd  ;   Command              ;   9      ;     4
        6      ;        14     ;      drl  ;   Derail               ;   15     ;     5
        7      ;        16     ;      luf  ;   Lockup               ;   5      ;     4
        8      ;        20     ;      con  ;   Connect              ;   25     ;     7
        9      ;        22     ;      par  ;   Parity               ;   8      ;     4
        10     ;        24     ;      ipr  ;   Illegal procedure    ;   16     ;     5
        11     ;        26     ;      onc  ;   Operation not complete ; 4      ;     2
        12     ;        30     ;      suf  ;   Startup              ;   1      ;     1
        13     ;        32     ;      ofl  ;   Overflow             ;   7      ;     3
        14     ;        34     ;      div  ;   Divide check         ;   6      ;     3
        15     ;        36     ;      exf  ;   Execute              ;   2      ;     1
        16     ;        40     ;      df0  ;   Directed fault 0     ;   20     ;     6
        17     ;        42     ;      df1  ;   Directed fault 1     ;   21     ;     6
        18     ;        44     ;      df2  ;   Directed fault 2     ;   22     ;     6
        19     ;        46     ;      df3  ;   Directed fault 3     ;   23     ;     6
        20     ;        50     ;      acv  ;   Access violation     ;   24     ;     6
        21     ;        52     ;      mme2 ;   Master mode entry 2  ;   12     ;     5
        22     ;        54     ;      mme3 ;   Master mode entry 3  ;   13     ;     5
        23     ;        56     ;      mme4 ;   Master mode entry 4  ;   14     ;     5
        24     ;        60     ;      f2   ;   Fault tag 2          ;   18     ;     5
        25     ;        62     ;      f3   ;   Fault tag 3          ;   19     ;     5
        26     ;        64     ;           ;   Unassigned           ;          ;
        27     ;        66     ;           ;   Unassigned           ;          ;
 
*/

#ifndef QUIET_UNUSED
static dps8faults _faultsP[] = { // sorted by priority
//  number  address  mnemonic   name                 Priority    Group
    {   12,     030,    "suf",  "Startup",                  1,	     1,     false },
    {   15,     036,    "exf",  "Execute",                  2,	     1,     false },
    {   31,     076,    "trb",  "Trouble",                  3,       2,     false },
    {   11,     026,    "onc",  "Operation not complete", 	4,	     2,     false },
    {   7,      016,    "luf",  "Lockup",               	5,	     4,     false },
    {   14,     034,    "div",  "Divide check",         	6,	     3,     false },
    {   13,     032,    "ofl",  "Overflow",             	7,	     3,     false },
    {   9,      022,    "par",  "Parity",               	8,	     4,     false },
    {   5,      012,    "cmd",  "Command",              	9,	     4,     false },
    {   1,       2 ,    "str",  "Store",                	10,	     4,     false },
    {   2,       4 ,    "mme",  "Master mode entry 1",  	11,	     5,     false },
    {   21,     052,    "mme2", "Master mode entry 2",  	12,	     5,     false },
    {   22,     054,    "mme3", "Master mode entry 3",  	13,	     5,     false },
    {   23,     056,    "mme4", "Master mode entry 4",  	14,	     5,     false },
    {   6,      014,    "drl",  "Derail",               	15,	     5,     false },
    {   10,     024,    "ipr",  "Illegal procedure",    	16,	     5,     false },
    {   3,       06,    "f1",   "Fault tag 1",          	17,	     5,     false },
    {   24,     060,    "f2",   "Fault tag 2",          	18,	     5,     false },
    {   25,     062,    "f3",   "Fault tag 3",          	19,	     5,     false },
    {   16,     040,    "df0",  "Directed fault 0",     	20,	     6,     false },
    {   17,     042,    "df1",  "Directed fault 1",     	21,	     6,     false },
    {   18,     044,    "df2",  "Directed fault 2",     	22,	     6,     false },
    {   19,     046,    "df3",  "Directed fault 3",     	23,	     6,     false },
    {   20,     050,    "acv",  "Access violation",     	24,	     6,     false },
    {   8,      020,    "con",  "Connect",              	25,	     7,     false },
    {   4,      010,    "tro",  "Timer runout",         	26,	     7,     false },
    {   0,       0 ,    "sdf",  "Shutdown",             	27,	     7,     false },
    {   26,     064,    "???",  "Unassigned",               -1,     -1,     false },
    {   27,     066,    "???",  "Unassigned",               -1,     -1,     false },
    {   -1,     -1,     NULL,   NULL,                       -1,     -1,     false }
};
#endif
dps8faults _faults[] = {    // sorted by number
    //  number  address  mnemonic   name                 Priority    Group
    {   0,       0 ,    "sdf",  "Shutdown",             	27,	     7,     false },
    {   1,       2 ,    "str",  "Store",                	10,	     4,     false },
    {   2,       4 ,    "mme",  "Master mode entry 1",  	11,	     5,     false },
    {   3,       06,    "f1",   "Fault tag 1",          	17,	     5,     false },
    {   4,      010,    "tro",  "Timer runout",         	26,	     7,     false },
    {   5,      012,    "cmd",  "Command",              	9,	     4,     false },
    {   6,      014,    "drl",  "Derail",               	15,	     5,     false },
    {   7,      016,    "luf",  "Lockup",               	5,	     4,     false },
    {   8,      020,    "con",  "Connect",              	25,	     7,     false },
    {   9,      022,    "par",  "Parity",               	8,	     4,     false },
    {   10,     024,    "ipr",  "Illegal procedure",    	16,	     5,     false },
    {   11,     026,    "onc",  "Operation not complete", 	4,	     2,     false },
    {   12,     030,    "suf",  "Startup",                  1,	     1,     false },
    {   13,     032,    "ofl",  "Overflow",             	7,	     3,     false },
    {   14,     034,    "div",  "Divide check",         	6,	     3,     false },
    {   15,     036,    "exf",  "Execute",                  2,	     1,     false },
    {   16,     040,    "df0",  "Directed fault 0",     	20,	     6,     false },
    {   17,     042,    "df1",  "Directed fault 1",     	21,	     6,     false },
    {   18,     044,    "df2",  "Directed fault 2",     	22,	     6,     false },
    {   19,     046,    "df3",  "Directed fault 3",     	23,	     6,     false },
    {   20,     050,    "acv",  "Access violation",     	24,	     6,     false },
    {   21,     052,    "mme2", "Master mode entry 2",  	12,	     5,     false },
    {   22,     054,    "mme3", "Master mode entry 3",  	13,	     5,     false },
    {   23,     056,    "mme4", "Master mode entry 4",  	14,	     5,     false },
    {   24,     060,    "f2",   "Fault tag 2",          	18,	     5,     false },
    {   25,     062,    "f3",   "Fault tag 3",          	19,	     5,     false },
    {   26,     064,    "???",  "Unassigned",               -1,     -1,     false },
    {   27,     066,    "???",  "Unassigned",               -1,     -1,     false },
    {   28,     070,    "???",  "Unassigned",               -1,     -1,     false },
    {   29,     072,    "???",  "Unassigned",               -1,     -1,     false },
    {   30,     074,    "???",  "Unassigned",               -1,     -1,     false },
    {   31,     076,    "trb",  "Trouble",                  3,       2,     false },

    {   -1,     -1,     NULL,   NULL,                       -1,     -1,     false }
};

//bool pending_fault = false;     // true when a fault has been signalled, but not processed


#ifndef QUIET_UNUSED
static bool port_interrupts[8] = {false, false, false, false, false, false, false, false };
#endif

//-----------------------------------------------------------------------------
// ***  Constants, unchanging lookup tables, etc

#ifndef QUIET_UNUSED
static int fault2group[32] = {
    // from AL39, page 7-3
    7, 4, 5, 5, 7, 4, 5, 4,
    7, 4, 5, 2, 1, 3, 3, 1,
    6, 6, 6, 6, 6, 5, 5, 5,
    5, 5, 0, 0, 0, 0, 0, 2
};

static int fault2prio[32] = {
    // from AL39, page 7-3
    27, 10, 11, 17, 26,  9, 15,  5,
    25,  8, 16,  4,  1,  7,  6,  2,
    20, 21, 22, 23, 24, 12, 13, 14,
    18, 19,  0,  0,  0,  0,  0,  3
};
#endif
// Fault conditions as stored in the "FR" Fault Register
// C99 and C++ would allow 64bit enums, but bits past 32 are related to (unimplemented) parity faults.
typedef enum {
    // Values are bit masks
    fr_ill_op = 1, // illegal opcode
    fr_ill_mod = 1 << 1, // illegal address modifier
    // fr_ill_slv = 1 << 2, // illegal BAR mode procedure
    fr_ill_proc = 1 << 3 // illegal procedure other than the above three
    // fr_ill_dig = 1 << 6 // illegal decimal digit
} fault_cond_t;

#if 0 // DPS8M
// "MR" Mode Register, L68
typedef struct {
    // See member "word" for the raw bits, other member values are derivations
    bool mr_enable; // bit 35 "n"
    bool strobe; // bit 30 "l"
    bool fault_reset; // bit 31 "m"
    t_uint64 word;
} mode_reg_t;
static mode_reg_t MR;
#endif 

#ifdef NOT_USED
/*
 *  check_events()
 *
 *  Called after executing an instruction pair for xed.   The instruction pair
 *  may have included a rpt, rpd, or transfer.   The instruction pair may even
 *  have faulted, but if so, it was saved and restarted.
 */

void check_events (void)
{
    events.any = events.int_pending || events.low_group || events.group7;
    if (events.any)
      {
        sim_debug(DBG_NOTIFY, & cpu_dev, "CU: check_events: event(s) found (%d,%d,%d).\n", events.int_pending, events.low_group, events.group7);
      }
    return;
}

#if 0
/*
 *  fault_gen()
 *
 *  Called by instructions or the addressing code to record the
 *  existance of a fault condition.
 */

void fault_gen(int f)
{
    int group;
    
#if 0
    if (f == oob_fault) {
        sim_debug(DBG_ERR, & cpu_dev, "CU fault: Faulting for internal bug\n");
        f = trouble_fault;
        (void) cancel_run(STOP_BUG);
    }
#endif
    
    if (f < 1 || f > 32) {
        //sim_debug(DBG_ERR, & cpu_dev, "CU fault: Bad fault # %d\n", f);
        cancel_run(STOP_BUG);
        return;
    }
    group = fault2group[f];
    if (group < 1 || group > 7) {
        //sim_debug(DBG_ERR, & cpu_dev, "CU fault: Internal error.\n");
        cancel_run(STOP_BUG);
        return;
    }
    
    if (fault_gen_no_fault) {
        //sim_debug(DBG_DEBUG, & cpu_dev, "CU fault: Ignoring fault # %d in group %d\n", f, group);
        return;
    }
    
    if (f == FAULT_IPR)
        FR |= fr_ill_proc;
    
    events.any = 1;
    //sim_debug(DBG_DEBUG, & cpu_dev, "CU fault: Recording fault # %d in group %d\n", f, group);
    
#if 0 // This is DPS8, not DPS8M
    // Note that we never simulate a (hardware) op_not_complete_fault
    if (MR.mr_enable && (f == FAULT_ONC || MR.fault_reset)) {
        if (MR.strobe) {
            sim_debug(DBG_INFO, & cpu_dev, "CU fault: Clearing MR.strobe.\n");
            MR.strobe = 0;
        } else
            sim_debug(DBG_INFO, & cpu_dev, "CU fault: MR.strobe was already unset.\n");
    }
#endif
    
    if (group == 7) {
        // Recognition of group 7 faults is delayed and we can have
        // multiple group 7 faults pending.
        events.group7 |= (1 << f);
    } else {
        // Groups 1-6 are handled more immediately and there can only be
        // one fault pending within each group
        //if (cpu.cycle == FAULT_cycle)
        if (cpu.cycle == FAULT_cycle || cpu.cycle == FAULT_EXEC_cycle) {
            // FIXME: || events.xed AND/OR || cpu.cycle == FAULT_EXEC_cycle
            f = FAULT_TRB;
            group = fault2group[f];
            sim_debug(DBG_WARN, & cpu_dev, "CU fault: Double fault:  Recording current fault as a trouble fault (fault # %d in group %d).\n", f, group);
            cpu.cycle = FAULT_cycle;
            //cancel_run(STOP_DIS); // BUG: not really
        } else {
            if (events.fault[group]) {
                // todo: error, unhandled fault
                sim_debug(DBG_WARN, & cpu_dev, "CU fault: Found unhandled prior fault #%d in group %d.\n", events.fault[group], group);
            }
            if (cpu.cycle == EXEC_cycle) {
                // don't execute any pending odd half of an instruction pair
                cpu.cycle = FAULT_cycle;
            }
        }
        events.fault[group] = f;
    }
    if (events.low_group == 0 || group < events.low_group)
        events.low_group = group;   // new highest priority fault group
}
#endif

/*
 * fault_check_group
 *
 * Returns true if faults exist for the specifed group or for a higher
 * priority group.
 *
 */

#ifndef QUIET_UNUSED
static int fault_check_group(int group)
{
    
    if (group < 1 || group > 7) {
        sim_debug(DBG_ERR, & cpu_dev, "CU fault-check-group: Bad group # %d\n", group);
        cancel_run(STOP_BUG);
        return 1;
    }
    
    if (! events.any)
        return 0;
    return events.low_group <= group;
}
#endif

#endif  // NOT_USED

/*
 * fault handler(s).
 */

#ifdef NOT_USED
t_stat doFaultInstructionPair(DCDstruct *i, word24 fltAddress)
{
    // XXX stolen from xed instruction
    
    DCDstruct _xip;   // our decoded instruction struct
    EISstruct _eis;

    word36 insPair[2];
    Read2(i, fltAddress, &insPair[0], &insPair[1], InstructionFetch, 0);
    
    _xip.IWB = insPair[0];
    _xip.e = &_eis;
    
    DCDstruct *xec = decodeInstruction(insPair[0], &_xip);    // fetch instruction into current instruction
    
    t_stat ret = executeInstruction(xec);
    
    if (ret)
        return (ret);
    
    _xip.IWB = insPair[1];
    _xip.e = &_eis;
    
    xec = decodeInstruction(insPair[1], &_xip);               // fetch instruction into current instruction
    
    ret = executeInstruction(xec);
    
    //if (ret)
    //    return (ret);
    //
    //return SCPE_OK;
    return ret;
}
#endif

static bool bTroubleFaultCycle = false;       // when true then in TROUBLE FAULT CYCLE
#ifndef QUIET_UNUSED
static int nFaultNumber = -1;
static int nFaultGroup = -1;
static int nFaultPriority = -1;
#endif
static int g7Faults = 0;

// We stash a few things for debugging; they are accessed by emCall.
static word18 fault_ic; 
static word15 fault_psr;
static char fault_msg [1024];


void emCallReportFault (void)
  {
           sim_printf ("fault report:\n");
           sim_printf ("  fault number %d (%o)\n", cpu . faultNumber, cpu . faultNumber);
           sim_printf ("  subfault number %d (%o)\n", cpu . subFault, cpu . subFault);
           sim_printf ("  faulting address %05o:%06o\n", fault_psr, fault_ic);
           sim_printf ("  msg %s\n", fault_msg);
  }

void clearFaultCycle (void)
  {
    bTroubleFaultCycle = false;
  }

/*

 Faults in groups 1 and 2 cause the processor to abort all functions immediately by entering a FAULT CYCLE.
 
 Faults in group 3 cause the processor to "close out" current functions without taking any irrevocable action (such as setting PTW.U in an APPEND CYCLE or modifying an indirect word in a CA CYCLE), then to discard any pending functions (such as an APPEND CYCLE needed during a CA CYCLE), and to enter a FAULT CYCLE.
 
 Faults in group 4 cause the processor to suspend overlapped operation, to complete current and pending functions for the current instruction, and then to enter a FAULT CYCLE.
 
 Faults in groups 5 or 6 are normally detected during virtual address formation and instruction decode. These faults cause the processor to suspend overlapped operation, to complete the current and pending instructions, and to enter a FAULT CYCLE. If a fault in a higher priority group is generated by the execution of the current or pending instructions, that higher priority fault will take precedence and the group 5 or 6 fault will be lost. If a group 5 or 6 fault is detected during execution of the current instruction (e.g., an access violation, out of segment bounds, fault during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault.
 
 Faults in group 7 are held and processed (with interrupts) at the completion of the current instruction pair.
 
 Group 7 faults are inhibitable by setting bit 28 of the instruction word.
 
 Faults in groups 3 through 6 must wait for the system controller to acknowledge the last access request before entering the FAULT CYCLE.
 

After much rumination here are my thoughts for fault processing .....

For now, at least, we must remember a few things:

1) We only have 1 cpu so we have few & limited async faults - shutdown, TRO, etc.
2) We have no overlapping instruction execution
3) Becuase of 2) we have no pending instructions
4) We have no system controller to wait for
 
 Group 1 & 2 faults can be processed immediately and then proceed to next instruction as long as no transfer prevents us from returing from the XED pair.
 
 Group 3 faults will probably also execute immediately since a G3 fault causes "the processor to "close out" current functions without taking any irrevocable action (such as setting PTW.U in an APPEND CYCLE or modifying an indirect word in a CA CYCLE), then to discard any pending functions (such as an APPEND CYCLE needed during a CA CYCLE), and to enter a FAULT CYCLE."
 
 Group 4 faults will probably also execute immediately since a G4 fault causes "the processor to suspend overlapped operation, to complete current and pending functions for the current instruction, and then to enter a FAULT CYCLE."

 Group 5 & 6 faults will probably also execute immediately because "if a group 5 or 6 fault is detected during execution of the current instruction (e.g., an access violation, out of segment bounds, fault during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault." However, remember "If a fault in a higher priority group is generated by the execution of the current or pending instructions, that higher priority fault will take precedence and the group 5 or 6 fault will be lost. If a group 5 or 6 fault is detected during execution of the current instruction (e.g., an access violation, out of segment bounds, fault during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault."
 ￼￼
 during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault.

 For furter justification of immediate execution since "Faults in groups 3 through 6 must wait for the system controller to acknowledge the last access request before entering the FAULT CYCLE."
 
 Group 7 faults will be processed after next even instruction decode instruction decode, but before instruction execution. In this way we can actually use bit-28 tp inhibit interrupts
 
*/

void doFault(DCDstruct *i, _fault faultNumber, _fault_subtype subFault, char *faultMsg)
{
    sim_debug (DBG_FAULT, & cpu_dev, "Fault %d(0%0o), sub %d(0%o), dfc %c, '%s'\n", faultNumber, faultNumber, subFault, subFault, bTroubleFaultCycle ? 'Y' : 'N', faultMsg);

    // some debugging support stuff
    fault_psr = PPR.PSR;
    fault_ic = PPR.IC;
    strcpy (fault_msg, faultMsg);

    //if (faultNumber < 0 || faultNumber > 31)
    if (faultNumber & ~037)  // quicker?
    {
        sim_printf("fault(out-of-range): %d %d '%s'\r\n", faultNumber, subFault, faultMsg ? faultMsg : "?");
        /* return;*/ /* doFault Never returns */
        cpu . faultNumber = FAULT_TRB;
        cpu . subFault = 0; // XXX ???
    }

    cpu . faultNumber = faultNumber;
    cpu . subFault = subFault;

//--    dps8faults *f = &_faults[faultNumber];
    
//--    nFaultGroup = fault2group[faultNumber];
//--    nFaultPriority = fault2prio[faultNumber];
    
    if (cpu . cycle == FAULT_EXEC_cycle ||
        cpu . cycle == FAULT_EXEC2_cycle)  // if already in a FAULT CYCLE then signal trouble fault
      {
        cpu . faultNumber = FAULT_TRB;
        cpu . subFault = 0; // XXX ???
        if (bTroubleFaultCycle)
          {
            if (events . int_pending == 0 &&
                sim_qcount () == 0)  // XXX If clk_svc is implemented it will 
                                     // break this logic
              {
                sim_printf ("Fault cascade @0%06o with no interrupts pending and no events in queue\n", PPR.IC);
                sim_printf("\r\ncpuCycles = %lld\n", cpuCycles);
                stop_reason = STOP_FLT_CASCADE;
                longjmp (jmpMain, JMP_STOP);
              }
            // return;
#ifdef CHASING_BOOT
            // If we have faulted in a trouble fault, then there is no reason
            // to return;
            // RETRY doesn't help; it keeps trying to execute [0]
            // longjmp(jmpMain, JMP_RETRY);    // retry instruction
#else
            // Double fault with interrupts pending
            //return;
#endif
          }
        else
          {
//--            f = &_faults[FAULT_TRB];
            bTroubleFaultCycle = true;
          }
      }
    else
      {
        bTroubleFaultCycle = false;
        // safe-store the Control Unit Data (see Section 3) into program-invisible holding registers in preparation for a Store Control Unit (scu) instruction,
        // this in done in FAULT_cycle
        // cu_safe_store ();
      }
    
    cpu . cycle = FAULT_cycle;
    longjmp (jmpMain, JMP_ENTRY);
#if 0
    if (nFaultGroup == 7) {
        // Recognition of group 7 faults is delayed and we can have
        // multiple group 7 faults pending.
        g7Faults |= (1 << faultNumber);
        return;
    }
#endif
    
#if 0
    int fltAddress = (switches.FLT_BASE << 5) & 07740;            // (12-bits of which the top-most 7-bits are used)
    word24 addr = fltAddress + f->fault_address;    // absolute address of fault YPair
  
    bFaultCycle = true;                 // enter FAULT CYCLE
    
    sim_debug (DBG_FAULT, & cpu_dev, "Fault pair address %08o\n", addr);

    word36 faultPair[2];
    core_read2(addr, faultPair, faultPair+1);
    // In the FAULT CYCLE, the processor safe-stores the Control Unit Data (see Section 3) into program-invisible holding registers in preparation for a Store Control Unit (scu) instruction, then enters temporary absolute mode, forces the current ring of execution C(PPR.PRR) to 0, and generates a computed address for the fault trap pair by concatenating the setting of the FAULT BASE switches on the processor configuration panel with twice the fault number (see Table 7-1). This computed address and the operation code for the Execute Double (xed) instruction are forced into the instruction register and executed as an instruction. Note that the execution of the instruction is not done in a normal EXECUTE CYCLE but in the FAULT CYCLE with the processor in temporary absolute mode.
    
    // addr_modes_t am = get_addr_mode();  // save address mode
    
    PPR.PRR = 0;
    
    set_TEMPORARY_ABSOLUTE_mode ();
    
    // MME expects the IC to point to the code being XEDed
    //if (f == &_faults[FAULT_MME] ||
        //f == &_faults[FAULT_MME2] ||
        //f == &_faults[FAULT_MME3] ||
        //f == &_faults[FAULT_MME4])
        //PPR.IC = addr;
    
     // Don't! T4D says the IC remains pointing at the faulting
     // instruction
     // PPR.IC = addr;

    t_stat xrv = doXED(faultPair);
    
    bFaultCycle = false;                // exit FAULT CYCLE
    bTroubleFaultCycle = false;

    if (xrv == CONT_TRA)
    {
        // set_addr_mode(ABSOLUTE_mode);
// The tricky case: We entered the fault in appending mode, and the fault
// pair transfered in absolute mode. According to AL39 and T&D, we should
// stay in absolute mode, not return to appending mode.
        if (!clear_TEMPORARY_ABSOLUTE_mode ())
          set_addr_mode (ABSOLUTE_mode);
        sim_debug (DBG_FAULT, & cpu_dev, "Fault pair transfers\n");
        longjmp(jmpMain, JMP_TRA);      // execute transfer instruction
    }
    
    // XXX more better to do the safe_restore, and get the saved mode from the restored data; but remember that the SECRET_TEMPORARY has to be cleared
    clear_TEMPORARY_ABSOLUTE_mode ();
    //set_addr_mode(am);      // If no transfer of control takes place, the processor returns to the mode in effect at the time of the fault and resumes normal sequential execution with the instruction following the faulting instruction (C(PPR.IC) + 1).
    cu_safe_restore ();
    
    sim_debug (DBG_FAULT, & cpu_dev, "Fault pair resumes\n");
    if (xrv == 0)
        longjmp(jmpMain, JMP_NEXT);     // execute next instruction
    else if (xrv == CONT_INTR)
        longjmp(jmpMain, JMP_INTR);     // execute next instruction
    else if (0)                         // TODO: need to put test in to retry instruction (i.e. when executing restartable MW EIS?)
        longjmp(jmpMain, JMP_RETRY);    // retry instruction
#endif
    
//    printf("fault(): %d %d %s (%s) '%s'\r\n", f->fault_number, f->fault_group,  f->fault_name, f->fault_mnemonic, faultMsg ? faultMsg : "?");
//
//    if (f->fault_group == 7 && i && i->a)
//        return;
//
//    return;
//    longjmp(jmpMain, JMP_NEXT); // causes cpuCycles to not count the current instruction
//
//    pending_fault = true;
//    bool retry = false;
//    
//    int fltAddress = rFAULTBASE & 07740; // (12-bits of which the top-most 7-bits are used)
//    fltAddress += 2 * f->fault_number;
//    
//    f->fault_pending = true;        // this particular fault is pending, waiting for processing
//    
//    _processor_addressing_mode modeTemp = processorAddressingMode;
//    
//    processorAddressingMode = ABSOLUTE_MODE;
//    word24 rIC_temp = PPR.IC;
//    
//    t_stat ret = doFaultInstructionPair(i, fltAddress);
//    
//    f->fault_pending = false;        
//    pending_fault = false;
//    
//    processorAddressingMode = modeTemp;
//    
//    // XXX we really only want to do this in extreme conditions since faults can be returned from *more-or-less*
//    // XXX do it properly - later..
//    
//    if (retry)
//        longjmp(jmpMain, JMP_RETRY);    // this will retry the faulted instruction
//    
//    if (ret == CONT_TRA)
//        longjmp(jmpMain, JMP_TRA);
}

/*
 * return true if group 7 faules are pending ...
 */
bool bG7Pending()
{
    return g7Faults;
}

void doG7Faults()
{
    
}
