//
//  dps8_faults.c
//  dps8
//
//  Created by Harry Reed on 6/11/13.
//  Copyright (c) 2013 Harry Reed. All rights reserved.
//

#include <stdio.h>

#include "dps8.h"

/*
 FAULT RECOGNITION
 For the discussion following, the term "function" is defined as a major processor functional cycle. Examples are: APPEND CYCLE, CA CYCLE, INSTRUCTION FETCH CYCLE, OPERAND STORE CYCLE, DIVIDE EXECUTION CYCLE. Some of these cycles are discussed in various sections of this manual.
 Faults in groups 1 and 2 cause the processor to abort all functions immediately by entering a FAULT CYCLE.
 Faults in group 3 cause the processor to "close out" current functions without taking any irrevocable action (such as setting PTW.U in an APPEND CYCLE or modifying an indirect word in a CA CYCLE), then to discard any pending functions (such as an APPEND CYCLE needed during a CA CYCLE), and to enter a FAULT CYCLE.
 Faults in group 4 cause the processor to suspend overlapped operation, to complete current and pending functions for the current instruction, and then to enter a FAULT CYCLE.
 Faults in groups 5 or 6 are normally detected during virtual address formation and instruction decode. These faults cause the processor to suspend overlapped operation, to complete the current and pending instructions, and to enter a FAULT CYCLE. If a fault in a higher priority group is generated by the execution of the current or pending instructions, that higher priority fault will take precedence and the group 5 or 6 fault will be lost. If a group 5 or 6 fault is detected during execution of the current instruction (e.g., an access violation, out of segment bounds, fault
 ￼￼
 during certain interruptible EIS instructions), the instruction is considered "complete" upon detection of the fault.
 Faults in group 7 are held and processed (with interrupts) at the completion of the current instruction pair. Group 7 faults are inhibitable by setting bit 28 of the instruction word.
 Faults in groups 3 through 6 must wait for the system controller to acknowledge the last access request before entering the FAULT CYCLE.
 */

/*
 
                                Table 7-1. List of Faults
 
 Decimal fault     Octal (1)      Fault   Fault name            Priority    Group
     number      fault address   mnemonic
        0      ;         0     ;      sdf  ;   Shutdown             ;   27     ;     7
        1      ;         2     ;      str  ;   Store                ;   10     ;     4
        2      ;         4     ;      mme  ;   Master mode entry 1  ;   11     ;     5
        3      ;         6     ;      f1   ;   Fault tag 1          ;   17     ;     5
        4      ;        10     ;      tro  ;   Timer runout         ;   26     ;     7
        5      ;        12     ;      cmd  ;   Command              ;   9      ;     4
        6      ;        14     ;      drl  ;   Derail               ;   15     ;     5
        7      ;        16     ;      luf  ;   Lockup               ;   5      ;     4
        8      ;        20     ;      con  ;   Connect              ;   25     ;     7
        9      ;        22     ;      par  ;   Parity               ;   8      ;     4
        10     ;        24     ;      ipr  ;   Illegal procedure    ;   16     ;     5
        11     ;        26     ;      onc  ;   Operation not complete ; 4      ;     2
        12     ;        30     ;      suf  ;   Startup              ;   1      ;     1
        13     ;        32     ;      ofl  ;   Overflow             ;   7      ;     3
        14     ;        34     ;      div  ;   Divide check         ;   6      ;     3
        15     ;        36     ;      exf  ;   Execute              ;   2      ;     1
        16     ;        40     ;      df0  ;   Directed fault 0     ;   20     ;     6
        17     ;        42     ;      df1  ;   Directed fault 1     ;   21     ;     6
        18     ;        44     ;      df2  ;   Directed fault 2     ;   22     ;     6
        19     ;        46     ;      df3  ;   Directed fault 3     ;   23     ;     6
        20     ;        50     ;      acv  ;   Access violation     ;   24     ;     6
        21     ;        52     ;      mme2 ;   Master mode entry 2  ;   12     ;     5
        22     ;        54     ;      mme3 ;   Master mode entry 3  ;   13     ;     5
        23     ;        56     ;      mme4 ;   Master mode entry 4  ;   14     ;     5
        24     ;        60     ;      f2   ;   Fault tag 2          ;   18     ;     5
        25     ;        62     ;      f3   ;   Fault tag 3          ;   19     ;     5
        26     ;        64     ;           ;   Unassigned           ;          ;
        27     ;        66     ;           ;   Unassigned           ;          ;
 
*/
struct faults
{
    int         fault_number;
    int         fault_address;
    const char *fault_mnemonic;
    const char *fault_name;
    int         fault_priority;
    int         fault_group;
    bool        fault_pending;        // when true fault is pending and waiting to be processed
};

typedef struct faults faults;

faults _faultsP[] = { // sorted by priority
//  number  address  mnemonic   name                 Priority    Group
    {   12,     030,    "suf",  "Startup",                  1,	     1,     false },
    {   15,     036,    "exf",  "Execute",                  2,	     1,     false },
    {   31,     076,    "trb",  "Trouble",                  3,       2,     false },
    {   11,     026,    "onc",  "Operation not complete", 	4,	     2,     false },
    {   7,      016,    "luf",  "Lockup",               	5,	     4,     false },
    {   14,     034,    "div",  "Divide check",         	6,	     3,     false },
    {   13,     032,    "ofl",  "Overflow",             	7,	     3,     false },
    {   9,      022,    "par",  "Parity",               	8,	     4,     false },
    {   5,      012,    "cmd",  "Command",              	9,	     4,     false },
    {   1,       2 ,    "str",  "Store",                	10,	     4,     false },
    {   2,       4 ,    "mme",  "Master mode entry 1",  	11,	     5,     false },
    {   21,     052,    "mme2", "Master mode entry 2",  	12,	     5,     false },
    {   22,     054,    "mme3", "Master mode entry 3",  	13,	     5,     false },
    {   23,     056,    "mme4", "Master mode entry 4",  	14,	     5,     false },
    {   6,      014,    "drl",  "Derail",               	15,	     5,     false },
    {   10,     024,    "ipr",  "Illegal procedure",    	16,	     5,     false },
    {   3,       06,    "f1",   "Fault tag 1",          	17,	     5,     false },
    {   24,     060,    "f2",   "Fault tag 2",          	18,	     5,     false },
    {   25,     062,    "f3",   "Fault tag 3",          	19,	     5,     false },
    {   16,     040,    "df0",  "Directed fault 0",     	20,	     6,     false },
    {   17,     042,    "df1",  "Directed fault 1",     	21,	     6,     false },
    {   18,     044,    "df2",  "Directed fault 2",     	22,	     6,     false },
    {   19,     046,    "df3",  "Directed fault 3",     	23,	     6,     false },
    {   20,     050,    "acv",  "Access violation",     	24,	     6,     false },
    {   8,      020,    "con",  "Connect",              	25,	     7,     false },
    {   4,      010,    "tro",  "Timer runout",         	26,	     7,     false },
    {   0,       0 ,    "sdf",  "Shutdown",             	27,	     7,     false },
    {   26,     064,    "???",  "Unassigned",               -1,     -1,     false },
    {   27,     066,    "???",  "Unassigned",               -1,     -1,     false },
    {   -1,     -1,     NULL,   NULL,                       -1,     -1,     false }
};
faults _faults[] = {    // sorted by number
    //  number  address  mnemonic   name                 Priority    Group
    {   0,       0 ,    "sdf",  "Shutdown",             	27,	     7,     false },
    {   1,       2 ,    "str",  "Store",                	10,	     4,     false },
    {   2,       4 ,    "mme",  "Master mode entry 1",  	11,	     5,     false },
    {   3,       06,    "f1",   "Fault tag 1",          	17,	     5,     false },
    {   4,      010,    "tro",  "Timer runout",         	26,	     7,     false },
    {   5,      012,    "cmd",  "Command",              	9,	     4,     false },
    {   6,      014,    "drl",  "Derail",               	15,	     5,     false },
    {   7,      016,    "luf",  "Lockup",               	5,	     4,     false },
    {   8,      020,    "con",  "Connect",              	25,	     7,     false },
    {   9,      022,    "par",  "Parity",               	8,	     4,     false },
    {   10,     024,    "ipr",  "Illegal procedure",    	16,	     5,     false },
    {   11,     026,    "onc",  "Operation not complete", 	4,	     2,     false },
    {   12,     030,    "suf",  "Startup",                  1,	     1,     false },
    {   13,     032,    "ofl",  "Overflow",             	7,	     3,     false },
    {   14,     034,    "div",  "Divide check",         	6,	     3,     false },
    {   15,     036,    "exf",  "Execute",                  2,	     1,     false },
    {   16,     040,    "df0",  "Directed fault 0",     	20,	     6,     false },
    {   17,     042,    "df1",  "Directed fault 1",     	21,	     6,     false },
    {   18,     044,    "df2",  "Directed fault 2",     	22,	     6,     false },
    {   19,     046,    "df3",  "Directed fault 3",     	23,	     6,     false },
    {   20,     050,    "acv",  "Access violation",     	24,	     6,     false },
    {   21,     052,    "mme2", "Master mode entry 2",  	12,	     5,     false },
    {   22,     054,    "mme3", "Master mode entry 3",  	13,	     5,     false },
    {   23,     056,    "mme4", "Master mode entry 4",  	14,	     5,     false },
    {   24,     060,    "f2",   "Fault tag 2",          	18,	     5,     false },
    {   25,     062,    "f3",   "Fault tag 3",          	19,	     5,     false },
    {   26,     064,    "???",  "Unassigned",               -1,     -1,     false },
    {   27,     066,    "???",  "Unassigned",               -1,     -1,     false },
    {   28,     070,    "???",  "Unassigned",               -1,     -1,     false },
    {   29,     072,    "???",  "Unassigned",               -1,     -1,     false },
    {   30,     074,    "???",  "Unassigned",               -1,     -1,     false },
    {   31,     076,    "trb",  "Trouble",                  3,       2,     false },

    {   -1,     -1,     NULL,   NULL,                       -1,     -1,     false }
};

bool pending_fault = false;     // true when a fault has been signalled, but not processed


bool port_interrupts[8] = {false, false, false, false, false, false, false, false };

/*
 * fault handler(s).
 */
DCDstruct *decodeInstruction(word36 inst, DCDstruct *dst);     // decode instruction into structure
t_stat executeInstruction(DCDstruct *ci);

t_stat doFaultInstructionPair(DCDstruct *i, word24 fltAddress)
{
    // XXX stolen from xed instruction
    
    DCDstruct _xip;   // our decoded instruction struct
    EISstruct _eis;

    word36 insPair[2];
    Read2(i, fltAddress, &insPair[0], &insPair[1], InstructionFetch, 0);
    
    _xip.IWB = insPair[0];
    _xip.e = &_eis;
    
    DCDstruct *xec = decodeInstruction(insPair[0], &_xip);    // fetch instruction into current instruction
    
    t_stat ret = executeInstruction(xec);
    
    if (ret)
        return (ret);
    
    _xip.IWB = insPair[1];
    _xip.e = &_eis;
    
    xec = decodeInstruction(insPair[1], &_xip);               // fetch instruction into current instruction
    
    ret = executeInstruction(xec);
    
    //if (ret)
    //    return (ret);
    //
    //return SCPE_OK;
    return ret;
}

void doFault(DCDstruct *i, int faultNumber, int subfault, char *faultMsg)
{
    if (faultNumber < 0 || faultNumber > 31)
    //if (faultNumber & ~037)  // quicker?
    {
        printf("fault(out-of-range): %d %d '%s'\r\n", faultNumber, subfault, faultMsg ? faultMsg : "?");
        return;
    }

    //return;
    
    faults *f = &_faults[faultNumber];

    printf("fault(): %d %d %s (%s) '%s'\r\n", f->fault_number, f->fault_group,  f->fault_name, f->fault_mnemonic, faultMsg ? faultMsg : "?");

    if (f->fault_group == 7 && i && i->a)
        return;

    return;
    longjmp(jmpMain, JMP_NEXT); // causes cpuCycles to not count the current instruction

    pending_fault = true;
    bool retry = false;
    
    int fltAddress = rFAULTBASE & 07740; // (12-bits of which the top-most 7-bits are used)
    fltAddress += 2 * f->fault_number;
    
    f->fault_pending = true;        // this particular fault is pending, waiting for processing
    
    _processor_addressing_mode modeTemp = processorAddressingMode;
    
    processorAddressingMode = ABSOLUTE_MODE;
    word24 rIC_temp = rIC;
    
    t_stat ret = doFaultInstructionPair(i, fltAddress);
    
    f->fault_pending = false;        
    pending_fault = false;
    
    processorAddressingMode = modeTemp;
    
    // XXX we really only want to do this in extreme conditions since faults can be returned from *more-or-less*
    // XXX do it properly - later..
    
    if (retry)
        longjmp(jmpMain, JMP_RETRY);    // this will retry the faulted instruction
    
    if (ret == CONT_TRA)
        longjmp(jmpMain, JMP_TRA);
}


