
"
"  EIS test code ...
"
       tsx2	rd_clock
       staq	Date        "MM/DD HH:MM

       call    ioa(msgHello, Date, Date+1)
        

        tra BTD0

msgHello:  acc         "This is TestEIS ...^g^g\r\n"
msg1:      acc         "Date: ^g^g \r\n"

Ten:    dec 10
TENmsg: acc     /This is ^d ... \r\n/

        even
Date:   bss     2


"
" BTD Tests ...
"
BTDmsg:    acc         "BTD Tests ...\r\n"

BTD0:
        call    ioa(BTDmsg)

BTD1:
        BTD     (),()
        NDSC9   FLD1a,2,2        " binary operand descriptor
        NDSC9   FLD2a,0,4,1      " decimal operand descriptor
        call    ioa(msg2, FLD2a, FLD2a)

        tra     BTD2

FLD1a:  dec     -512    " 7 7 7 7 7 7 7 7 7 0 0 0
FLD2a:  bss     1       " 0 5 5 0 6 5 0 6 1 0 6 2
                        " any indicators set? negative
msg2:   acc         "Result: ^n (^a) (Should be 055065061062 (-512))\r\n"


BTD2:
        BTD     (),()
        NDSC9   FLD1b,3,1
        NDSC9   FLD2b,1,3,2

        call    ioa(msg2b, FLD2b, FLD2b)
        tov     *+1         " reset OVR
        
        tra     BTD3


N12345: dec     -12345

errnum:     bss	,2
errtemp:	bss	,16
ertally:	bss	,1
errarg:     bss	,1
"errin:      desc9a	*,1
erlen:      bss	,1
eredit_d:	vfd	9/lte+1,o9/20,9/lte+3,o9/20,9/lte+4,o9/52,9/mfls+10,9/enf
            vfd	9/mvc+1
            
msg2_b:     acc /Result: ^n ^n (Should be 320000000001 043105000000)\r\n/
msg2_c:     acc /Result: '^g^g' (Should be '      -12345')\r\n/

BTD3:
        lda     N12345
        sta     errarg
        

        btd     (),()       "convert decimal number
        desc9a	errarg,4
        desc4ls	errnum,12
        call    ioa(msg2_b, errnum, errnum+1)

        mvne	(),(),()	"edit the output
        desc4ls	errnum,12
        desc9a	eredit_d,9
        desc6a	errtemp,12
        call    ioa(msg2_c, errtemp, errtemp+1)

" 000000000301 043105000000
" 0   0   0   0   0   0   0   0   0   3   0   1    0   4   3   1   0   5   0   0   0   0   0   0
" 000 000 000 000 000 000 000 000 000 011 000 001  000 100 011 001 000 101 000 000 000 000 000 000
" 0 0000 0000 0000 0000 0 0000 0000 0 1100 0001  0 0010 0011 0 0100 0101 0 0000 0000 0 0000 0000
"                                       +  1       2    3      4    5   
"
" 202020202020 140102030405
" 20 20 20 20 20 20 14 01 02 03 04 05
" 

        tra     DTB0
                        
FLD1b:  dec     255     " 0 0 0 0 0 0 0 0 0 3 7 7
FLD2b:  bss     1       " 0 0 0 0 6 5 0 6 5 0 5 3
                        " any indicators set? overflow
                        
msg2b:  acc         "Result: ^n (^a) (Should be 000065065053 (55+))\r\n"

"
" DTB Tests ...
"
DTBmsg:    acc         "DTB Tests ...\r\n"

DTB0:   call    ioa(DTBmsg)

        DTB     (), ()
        NDSC4   FLD1c,3,5,2
        NDSC9   FLD2c,0,4
        call    ioa(msg3, FLD2c)

        DTB     (), ()
        NDSC4   FLD1d,3,3,3
        NDSC9   FLD2d,2,2
        call    ioa(msg4, FLD2d)

        DTB     (), ()
        NDSC9   FLD1e,0,4,3
        NDSC9   FLD2e,3,1
        call    ioa(msg5, FLD2e)

"
" MVNE Tests ...
"
        call    ioa(MVNEmsg)

        MVNE    (),(),()
        NDSC9   FLD1f,0,10,2
        desc9a  FLD2f, 5
        desc9a  FLD3f, 12
        call    ioa(msg6, FLD3f, FLD3f+1, FLD3f+2)

        MVNE    (),(),()
        desc9ts FLD1f, 10
        desc9a  FLD2f1, 14
        desc6a  FLD3f1, 12      " 6-bit gebcd receiving string
        call    ioa(msg7, FLD3f1, FLD3f1+1)

        MVNE    (),(),()
        desc9ts FLD1f, 10
        desc9a  FLD2f2, 14      " play around with $ and -
        desc9a  FLD3f2, 12
        call    ioa(msg8, FLD3f2, FLD3f2+1, FLD3f2+2)

        MVNE    (), (), ()      " with (*) protection & (.) insertion
        NDSC4   FLD1g,0,8,2
        desc9a  FLD2g, 6
        desc9a  FLD3g,12
        call    ioa(msg9, FLD3g, FLD3g+1, FLD3g+2)
  
"
" MVE Tests ... 
"
        call    ioa(MVEmsg)

        MVE    (), (), ()       " move alphanumeric edited
        desc6a   FLD1h(2),20
        desc9a   FLD2h,25       " example in DH02 had 35 - don't think so
        desc6a   FLD3h,30
        call    ioa(msg10, FLD3h, FLD3h+1, FLD3h+2, FLD3h+3, FLD3h+4) 


        MVE     (), (), ()      " move alphanumeric edited
        desc9a   FLD1i,7        " sending field operand descriptor
        desc9a   FLD2i,6        " micro-op string operand descriptor
        desc9a   FLD3i+1(1),7   " receiving field operand descriptor
        call    ioa(msg11, FLD3i, FLD3i+1, FLD3i+2) 
       
"
" MLR Tests ...
"
        call    ioa(MLRmsg)

        MLR     (),(),fill(20)     " move with blank fill
        desc6a  FLD1j,12           " sending descriptor
        desc6a  FLD2j(4),14         " receiving descriptor
        
        call    ioa(msg12, FLD2j, FLD2j+1, FLD2j+2)


        MLR     (),(),fill(400)
        desc6a  FLD1k(3),9
        desc4a  FLD2k(6),10

        call    ioa(msg13, FLD2k, FLD2k+1)


        "This code moves the string "SOURCE T" to the first six
        "characters of "TO'.  The contents of X3 act as an
        "offset into the source text. (Bull RJ78 R2, pg 5-57)

        LDX3    =11, DU     " Original had DL which is wrong......
        MLR     (x3), (), fill(040)
        desc9a  FLD1l(1), 8
        desc9a  FLD2l, 8

        call    ioa(msg14, FLD2l, FLD2l+1)
        
        "
        "The string "LE " is moved to XB, starting at the third
        "character of XB.  The Q register can be used in the
        "same way.
        LDA     =4,DL
        LDQ     =3,DL
        MLR     (al),(ql), fill(040)
        desc9A  FLD1m, 3
        desc9a  FLD2m(2),3

        call    ioa(msg15, FLD2m, FLD2m+1, FLD2m+2)

        "The string "HIS IS" is moved to Y, beginning with the first character. (BULL RJ78 pg 5-58)
        LAR2    =0              " SET AR2 TO ALL 0'S
        EAX3    FLD2n
        AWDX    pr2|0,3         " AR2=address of Y
        MLR     (IC),(pr),fill(040)
        desc9a  FLD1n-*+1(1),6      " was desc9a  5(1),6 ("call" takes up many words....)
        desc9a  pr2|0, 6

        call    ioa(msg16, FLD2n, FLD2n+1)

"
" MRL Tests ....
"
        call    ioa(MRLmsg)

        MRL     (),(),fill(20)
        desc6a  FLD1o, 12            "ADSC6   FLD1,,12
        desc6a  FLD2o(4), 14         "ADSC6   FLD2,4,14

        call    ioa(msg17, FLD2o, FLD2o+1, FLD2o+2)

        MRL     (),(),fill(400)
        desc6a  FLD1p(3),9
        desc4a  FLD2p(4),12
        
        call    ioa(msg18, FLD2p, FLD2p+1)

        tra     MVT0
"
" MVT Tests ...
"
MVTmsg: acc     /MVT Tests ...\r\n/ 

msg19:  acc     /Result: '^n' (Should be '001043105155')\r\n/

FLD1q:  bci     /     123456/
FLD2q:  bss     1       " 0123456-      (Result)

TABLE1: OCT     000001002003,004005006007  " 0X
        OCT     010011017017,017017017017  " 1X
        OCT     000017017017,017017017017  " 2X
        OCT     017017017017,017017017017  " 3X
        OCT     017017017017,017017017017  " 4X
        OCT     017017015017,017017017017  " 5X
        OCT     014017017017,017017017017  " 6X
        OCT     017017017017,017017017017  " 7X

msg20:  acc     /Result: '^n' (Should be '022064126314')\r\n/

FLD3q:  OCT     022064126317    " 123456++
FLD4q:  BSS     1               " 022064126314  (Result)
TAB:    OCT     000001002003,004005006007
        OCT     010011014014,014015014014

msg21:  acc     "Result: '^a^a^a^a^a' (Should be 'TTYMESSAGE201     !!')\r\n"

FLD1r:  BCI     /TTYMESSAGE201      /
FLD2r:  BSS     5
TABLE9: aci     '01234567'  " 0X
        aci     '89[#@:>?'  " 1X
        aci     ' ABCDEFG'  " 2X
        aci     'HI&.](<\'  " 3X
        aci     '^JKLMNOP'  " 4X
        aci     "QR-$*);'"  " 5X
        aci     ',/STUVWX'  " 6X 
        aci     'YZ_,%="!'  " 7X 


msg22a: acc     /Result: '^a' (Should be '123M')\r\n/
msg22b: acc     /Result: '^a' (Should be '1234')\r\n/

P6a:    ac4     /   -1234/        "-1234 ——> 123M   (Yes, that's what it's supposed to be)
P6b:    ac4     /   +1234/        "+1234 ——> 1234

MOPS:   vfd     9/mvc+3,9/lte+3, o9/0, 9/lte+4  " MICROP  (MVC,3),(LTE,3)m1O000,(LTE,4),1O040,(MORS,1)
        vfd     o9/040, 9/mors+1

TABLE22:aci     /01234567/        " 0X
        VFD     A2/89,18/0,36/0  " 1X
        OCT     0,0               " 2X
        OCT     0,0               " 3X
        ACI     / JKLMNOP/        " 4X
        VFD     A2/QR,18/0,36/0  " 5X
        OCT     0,0               " 6X
        OCT     0,0               " 7X

PRTOUT: BSS     5
APRINT: BSS     5

DECTAB: aci     '0123456789+++-+F'  " decimal --> ascii

msg23:  acc     /Result: '^a^a' (Should be '-1234FFF')\r\n/



MVT0:
        call    ioa(MVTmsg)

        MVT     (),(), fill(52)
        desc6a  FLD1q(4),7
        desc4a  FLD2q,8
        ARG     TABLE1

        call    ioa(msg19, FLD2q)

        MVT (), ()
        desc4a  FLD3q, 8     " ADSC4   FLD3,,8
        desc4a  FLD4q, 8     " ADSC4   FLD4,,8
        ARG     TAB

        call    ioa(msg20, FLD4q)

        MVT     (), (),  fill(77)    " ! fill
        desc6a  FLD1r, 18           " ADSC6   FLD1,0,18
        desc9a  FLD2r, 20           " ADSC9   FLD2,0,20
        ARG     TABLE9              " pointer to translation table

        call     ioa(msg21, FLD2r, FLD2r+1, FLD2r+2, FLD2r+3, FLD2r+4)

        "-1234 ——> 123M (a)
        "+1234 ——> 1234 (b)
        MVNE     (), (), ()
        desc4ls  P6a(3),5    " NDSC4   6PACK,3,5,1
        desc9a   MOPS, 6     " ADSC9   MOPS,0,6
        desc6a   PRTOUT, 4   " ADSC6   PRTOUT,0,4

        MVT      (), ()
        desc6a   PRTOUT, 4   " ADSC6   PRTOUT,0,4
        desc9a   APRINT, 4   " ADSC9   APRINT,0,4
        ARG      TABLE22

        call    ioa(msg22a, APRINT)

        MVNE     (), (), ()
        desc4ls  P6b(3),5      " NDSC4   6PACK,3,5,1
        desc9a   MOPS, 6       " ADSC9   MOPS,0,6
        desc6a   PRTOUT, 4     " ADSC6   PRTOUT,0,4

        MVT      (), ()
        desc6a   PRTOUT, 4     " ADSC6   PRTOUT,0,4
        desc9a   APRINT+1, 4   " ADSC9   APRINT,0,4
        ARG      TABLE22

        call    ioa(msg22b, APRINT+1)


        " dec xlate test ...
        MVT      (), (),  fill(017)
        desc4a   P6a(3), 5
        desc9a   APRINT, 8
        ARG      DECTAB

        call    ioa(msg23, APRINT, APRINT+1)

        tra     SCM0

"
" SCM Tests ....
"
SCMmsg: acc     /SCM Tests ... (Results 3, 0 & 7)\r\n/

BADmsg: acc     /You should not see this....\r\n/

msg24:  acc     /Result: ^d\r\n/

FLD1s:  aci      /ABCD/     "141 142 143 144 (before mask)
                            "001 002 003 004 (after mask)
                            "octal representation of compare character
FLD2s:  aci      /0004/     "064 (before mask)
FLD3s:  BSS      1          "004 (after mask)

FLD1t:   ac4     /   -1234/         "EDEC     8P-1234   "0,1,2,3,4      -- which one do we believe?
FLD3t:   BSS     1

                            "   character compared
FLD1u:  ac4  /4321    /     " EDEC  8PL4321  " 2 1
FLD2u:  ac4  /    0987/     " EDEC  4P0987   " 1
FLD3u:  BSS  1              " unmatched compare count - 1

INDSC1u: desc4a  pr4|0, x2      "ADSC4 0,,X2,4    " FLD1 operand desc (FLD1,2,2)
INDSC2u: desc9a  FLD2u(2),1       "ADSC9 FLD2,0     " FLD2 operand desc (FLD2,1)

foundA: acc "Found an 'A' ...\r\n"
foundG: acc "Found a 'G' ...\r\n"
foundw: acc "Found a 'w' ...\r\n"
foundo: acc "Found an 'o' ...\r\n"
foundn: acc "Found a 'n' ...\r\n"
foundd: acc "Found a 'd' ...\r\n"
founda: acc "Found an 'a' ...\r\n"
foundg: acc "Found a 'g' ...\r\n"

SCM4in: aci     "XXgX"
SCM4tally:  bss 1
erkey:  aci     "AGwondag"
ertable:tra     err_A
        tra     err_G
        tra     err_w
        tra     err_o
        tra     err_n
        tra     err_d
        tra     err_a
        tra     err_g

err_A:  call    ioa(foundA)
        tra     SCM4
err_G:  call    ioa(foundG)
        tra     SCM4
err_w:  call    ioa(foundw)
        tra     SCM4
err_o:  call    ioa(foundo)
        tra     SCM4
err_n:  call    ioa(foundn)
        tra     SCM4
err_d:  call    ioa(foundd)
        tra     SCM4
err_a:  call    ioa(founda)
        tra     SCM4
err_g:  call    ioa(foundg)
        tra     SCM4


SCM0:
        call    ioa(SCMmsg)

        SCM     (),(), mask(760) "mask to eliminate zone bits
        desc9a  FLD1s,4         "character string operand desc
        desc9a  FLD2s(3),0      "compare character operand desc
        ARG     FLD3s           "pointer to unmatched count word
        TTF     GOT.IT          "match found - on 4th character

NO.GOT: call    ioa(BADmsg)     "no match -  tally runout ON
        dis

GOT.IT: call    ioa(msg24, FLD3s)

SCM1:   
        SCM      (),(DU)
        desc4a   FLD1t(3),5      "ADSC4    FLD1,3,5
        ac4      /-1      /      "EDEC     8PL-1
        ARG      FLD3t
        TTN      NO.GOT

        call    ioa(msg24, FLD3t)


SCM2:
        " this is a *really* messed up example from DH02. It's probably shouldn't even work as TN1 != TN2, etc. + arg2 is not PR
        " so, let's not mess with it.

        "EAX1    1           " load FLD2 character mod into X1
        "EAX2    2           " load FLD1 character mod into X2
        "EAX4    FLD1u       " load FLD1 address into X4
        "AWDX    pr4|0, 4    " put FLD1 address into AR4
        "
        ""SCM  (1,1,1,2),(1,,1,1),(), mask(010)   with all options
        "SCM   (pr,rl,id,x2), (pr,id,x1), (), mask(010)
        "ARG INDSC1u      " pointer to FLD1 indirect desc
        "ARG INDSC2u      " pointer to FLD2 indirect desc (NB no pr is specified in FLD2 descriptor)
        "ARG FLD3u        " pointer to unmatched count word
        "                 "   Result - match found on 2nd character
        "TTN NO.GOT       " no match - tally runout ON
        "
        "call    ioa (msg24, FLD3u)

SCM3:
        scm     (),()           "search table of keys
        desc9a	erkey,8
        desc9a  SCM4in(2),1
        arg     SCM4tally
        ttn     NO.GOT          "tra if not legal key

        call    ioa (msg24, SCM4tally)

        ldq     SCM4tally		" get character key index
        tra     ertable,ql* " dispatch on key

SCM4:

        tra     SCMR0

"
" SCMR Tests ....
"

SCMRmsg: acc     /SCMR Tests (Results 3 & 4)...\r\n/

FLD1v:   ac4     /654321- /       " EDEC      8PL654321-   6, 5, 4, 3, 2, 1
FLD3v:   DEC     0                " result - match found on 4th character
        

FLD1w:  ac4      /0123456-/         " 2,3,4,5,6,-
FLD3w:  DEC      0                  " unmatched compare count - 4
        desc4a   pr4|0,x6           " FLD1 operand desc(FLD 1,2,6)
FLD2w:  ac4      /3       /         " FLD2 compare character 3

                                    " Result - match found on 5th compare

SCMR0:
        call    ioa(SCMRmsg)

        SCMR    (),(DU), mask(760)     " DU type register mod with mask
        desc4a  FLD1v, 6               " character string operand desc
        ac4     /4       /             " 1P4 FLD2's compare character - 4
        ARG     FLD3v                  " pointer to unmatched count word
        "TTF      *+2 match found
        TTN     NO.GOT
        call    ioa (msg24, FLD3v)


        EAX6     6                  " load FLD1 length (-2) into x6
        EAX2     2                  " load character modifier into x2
        EAX4     FLD1w              " load FLD1 address into x4
        AWDX     pr4|0,4            " put FLD1 address into AR4
        SCMR     (pr,rl,id,x2),(), mask(760)        " with all options
        ARG      FLD3w+1            " pointer to FLD1 indirect desc
        desc4a   FLD2w              " pointer to compare character
        ARG      FLD3w              " pointer to unmatched count word
        TTN      NO.GOT             " no match - tally runout ON
        "TRA      WHEW              " match found

        call    ioa (msg24, FLD3w)

        
"
" TCT Tests ....
"
        call    ioa(TCTmsg)

        TCT      ()         "     no modification
        desc6a   FLD1x,12   " indexing string operand descr.
        ARG      TABLEx     " pointer to table
        ARG      FLD3x      " pointer to char. & count word
        "TTF      FOUND     " nonzero character found
        TTN     NO.GOT

        call    ioa (msg24o, FLD3x)


        EAX2     2           " put 2 into X2
        EAX3     FLD1y       " put FLD1 address into X3
        EAX6     6           " put 6 into X6
        AWDX     pr7|0,3     " put FLD1 address into AR7
        TCT      (pr,rl,id,x2)   " with all modification options
        ARG      INDSCRy     " ptr. indirect operand descr.
        ARG      TABLEy
        ARG      FLD3y       " pointer to FLD3

        TTN     NO.GOT

        call    ioa (msg24o, FLD3y)


"
" TCTR  Tests ....
"
        call    ioa(TCTRmsg)

        TCTR                " no modification
        desc4a  FLD1z(6),10 " indexing string operand descr
        ARG     TABLEz      " pointer to table
        ARG     FLD3z       " pointer to char. & count word
        TTF     NO.GOT      " nonzero found
                            " zero found - tally runout ON

        call    ioa (msg24o, FLD3z)

"
" CMPC Tests ...
"
        call    ioa (CMPCmsg)


        CMPC    (), (), fill(020)       " compare with blank fill
        desc6a  FLD1aa,6    " field 1 operand descriptor
        desc6a  FLD2aa(4),4 " field 2 operand descriptor
        TZE     EQUALaa     " both fields equal
        TRC     NO.GOT      " field 1 greater
        TRA     NO.GOT      " field 1 less
EQUALaa:call    ioa(msg25)

        TRA     SCD0
        
"
" SCD Tests ...
"
SCDmsg:    acc     "SCD Tests ... 5, 16, & 3\r\n"

SCD0:
        call    ioa (SCDmsg)

        SCD
        desc6a   FLD1ab,6
        desc6a   FLD2ab(3)
        ZERO     FLD3ab
        TTF      NO.GOT     " If we get a match
        
        call    ioa (msg24o, FLD3ab)
        
        TRA     NEXT

FLD1ab:  BCI      /123456/    " 123456
FLD2ab:  BCI      /654321/    " 32
FLD3ab:  BSS      1           " unmatched count - 5

NEXT:

       SCD                 "with no options
       desc6a  DATA,24     "24 characters fetched from lower
       desc6a  COMP,2      "DATA in units of 2 chars. and
       ARG     COUNT       "compared with HH when HH found in
                           "DATA, count stored as binary
                           "number before HH detection and
                           "instruction terminated
       TTN     NO.GOT      " no match found
        
       call    ioa (msg24o, COUNT)


       EAX5     5        " load 5 into X5
       EAX7     7        " load 7 into X7
       EAX4     FLD1ad   " load FLD1 address into X4
       AWDX     pr4|0,4  " put FLD1 address into AR4
       SCD      (pr,rl,x5),(DU)
       desc9a   pr4|0,X7 " FLD1 operand pointer (FLD1+1,1,7)
FLD2ad:VFD      A2/45    " FLD2 operand  " ahould be A18
       ARG      FLD3ad   " pointer to count FLD3
       TTN      NO.GOT

       call    ioa (msg24o, FLD3ad)

        tra     SCDR0
"
" SCDR Tests ...
"

SCDRmsg:    acc     "SCDR Tests ... 6 & 3\r\n"

SCDR0:
       call    ioa(SCDRmsg)

SCDR1:
       SCDR     (),(DU)       " DU modification of FLD2 operand descriptor
       desc9a   FLD1ae,8      " scanned string operand descriptor
       VFD      A2/AB         " FLD2 character pair - A B
       ARG      FLD3ae        " pointer count word
       TTN      NO.GOT        " match not found - tally runout ON
    
       call    ioa (msg24o, FLD3ae)
    
        tra    SCDR2

FLD1ae:aci      /ABCDE/       " A,B,C,D,E,
FLD3ae:BSS      1             " unmatched count - 6
                              " Result - match found on 7th pair
￼

SCDR2:

       EAX2     1           " load 1 into x2
       EAX3     FLD1af      " load FLD1 address into X3
       AWDX     PR4|0,3     " put FLD1 address into AR4
       SCDR     (pr,x2),(DU) " with address modification
       desc4a   pr4|0,7     " FLD1 operand descriptor - (FLD 1,1,7) (7 is length not x7)
       ac4      /23/        " FLD2 operand descriptor pointer
       ARG      FLD3af      " pointer to count word
       TTN      NO.GOT      " no match - tally runout ON
                            " match found
                            " characters compared

       call    ioa (msg24o, FLD3af)

       tra     CMPB0

FLD1af:ac4      /  123456/    " 0123456 VS 23
FLD3af:BSS      1             " unmatched count - 3
                              " Result - match found on 4th pair

"
" CMPB Tests ...
"
CMPB0:  call    ioa(CMPBmsg)
        
CMPB1:  CMPB    (),(),fill(1)       " fill bit 1 option
        "BDSC    FLD1ag,45,0,0       " FLD1 operand descriptor
        descb   FLD1ag, 45
        "BDSC    FLD2ag,48           " FLD2 operand descriptor
        descb   FLD2ag,48
        TRC     EQU.GR              " FLD1 equal/greater than FLD2
        TRA     NO.GOT
FLD1ag: OCT     0,777700000000      " 0000000000007777
FLD2ag: OCT     0,777000000000      " 0000000000007770
                                    " Result - FLD1  >  FLD2
                                    
EQU.GR: call ioa(msg26)

CMPB2:  CMPB                        " no options
        "BDSC    FLD1ah,36,0,0       " FLD1 operand descriptor
        descb   FLD1ah, 36
        "BDSC    FLD2ah,19,1,3       " FLD2 operand descriptor
        descb   FLD2ah(12), 19
        TZE     NO.GOT              " FLD1 = FLD2
        TRC     NO.GOT              " FLD1 > FLD2
        TRA     FLD1LS              " FLD1 < FLD2
                                    " compared (oct. representation)
FLD1ah: VFD     18/-1               " 777777000000
FLD2ah: VFD     12/0,19/-1          " 777777400000
                                    " Result - FLD1  <  FLD2
FLD1LS: call ioa(msg27)

"        EAX2    12  " load FLD1 bit modifier into X2
"        EAX6    6   " load FLD1 length into X6
"        EAX4    FLD1 " load FLD1 address into X4
"        AWDX    0,4,4 " put FLD1 address into AR4
"        CMPB    (1,1,,X2),(,,1)
"        BDSC    0,X6,0,0,4 FLD1 operand descriptor
"        ARG     INDSCR FLD2 indirect descriptor ptr.
"        TZE     EQUAL FLD1 = FLD2
"        USE     CONST.      " compared memory contents
"FLD1 VFD 12/0,6/1   " 770 000077000000
"FLD2 VFD 24/0,6/1   " 770 000000007700
"INDSCR BDSC FLD2,9,2,6

        "EQU     X6, 14      " for x6 in BDSC length
        EAX2    12          " load FLD1 bit modifier into X2
        EAX6    6           " load FLD1 length into X6
        EAX4    FLD1ai      " load FLD1 address into X4
        AWDX    4|0,4       " put FLD1 address into AR4
        CMPB    (pr,rl,x2),(id)
        descb   pr4|0,x6  " FLD1 operand descriptor
        ARG     INDSCR      " FLD2 indirect descriptor ptr.
        TZE     EQUAL       " FLD1 = FLD2
        TRA     NO.GOT
FLD1ai: VFD     12/0,6/1   " 770 000077000000 [sic]
FLD2ai: VFD     24/0,6/1   " 770 000000007700 [sic]
INDSCR: BDSC    FLD2ai,9,2,6

EQUAL:  call     ioa(msg28)

        tra     CSL0
        
"
" CSL Tests ...
"
CSLmsg:    acc     "CSL Tests ...\r\n"

CSL0:
         call    ioa(CSLmsg)

"
"BDSC    BDSC LOCSYM,N,c,b,AM
"descb   address(offset), length
"   

"" REM BITS 0-17 OF FLD2 FORCED ON
"        CSL      ,,07,,1            " OR - truncation enable option
"        BDSC     FLD1,24,1,3        " FLD1 operand descriptor
"        BDSC     FLD2,18,0,0        " FLD2 operand descriptor
"        USE      CONST              " memory contents in octal
"FLD1    VFD      12/0,18/-1,6/0     " 000077777700
"FLD2    LDA      0,2                " 000000235012
"        USE                         " 777777235012  (Result)

        " REM BITS 0-17 OF FLD2 FORCED ON
        CSL     (),(),bool(07),enablefault " OR - truncation enable option
        descb   FLD1aj(12), 24      " FLD1 operand descriptor
        descb   FLD2aj, 18          " FLD2 operand descriptor
                                    
        call    ioa (msg24o, FLD2aj)
        
        tra     CSL2
                                    " memory contents in octal
FLD1aj: VFD      12/0,18/-1,6/0     " 000077777700
FLD2aj: LDA      0,2                " 000000235012
                                    " 777777235012  (Result)

CSL2:                                           

"      BITS 18-35 OF FLD2 INVERTED
"       CSL      ,,06,1      " exclusive OR, fill bit 1 opt
"       BDSC     ,0          " FLD1 operand descriptor
"       BDSC     FLD2,18,2,0 " FLD2 operand descriptor
"       USE      CONST.      " memory contents in octal
"FLD2:  DEC      0           " 000000000000
"       USE                  " 000000777777  (Result)

        " BITS 18-35 OF FLD2 INVERTED
        CSL     (),(),bool(06),fill(1)      " exclusive OR, fill bit 1 opt
        descb   0, 0         " FLD1 operand descriptor (0-length field)
        descb   FLD2ak(18),18  " FLD2 operand descriptor

        call    ioa (msg24o, FLD2ak)
        
        tra     CSL3
                            " memory contents in octal
FLD2ak: DEC     0           " 000000000000
                            " 000000777777  (Result)

CSL3:

" ar,rl,id,reg

"        EAX6    12              char/bit address mod to X6
"        EAX7    54              load FLD2 length into X7
"        EAX4    FLD2            load FLD2 address into X4
"        AWDX    0,4,4           put FLD2 address into AR4
"        CSL     (,,1),(1,1,,6),00,00   clear operation with
"        ARG     2,4             pointer to FLD1 indirect operand descriptor
"        BDSC 0,X7,,,4           FLD2 operand descriptor (FLD2,54,1,3)
"
"
"FLD2    VFD      36/-1,36/-1    " 777777777777
"        BDSC    ,0              "FLD1 operand descriptor (control field zeros)


        "EQU     X7,15
        EAX6    12              " char/bit address mod to X6
        EAX7    54              " load FLD2 length into X7
        EAX4    FLD2al          " load FLD2 address into X4
        AWDX    pr4|0,4         " put FLD2 address into AR4
        CSL     (id),(ar,rl,x6) " clear operation with address modifications
        ARG     2,4             " pointer to FLD1 indirect operand descriptor
        "BDSC    0,X7,,,4        " FLD2 operand descriptor (FLD2,54,1,3)
        descb   pr4|0, x7       " FLD2 operand descriptor (FLD2,54,1,3)

        call    ioa (msg24o, FLD2al)
        call    ioa (msg24o, FLD2al+1)

        tra     CSR0

FLD2al: VFD      36/-1,36/-1    " 777777777777
        BDSC    0,0             " FLD1 operand descriptor (control field zeros)
                                " 777700000000 000000000077 (Result)
                                
CSRmsg: acc     "CSR Tests ...\r\n"

CSR0:                                
        call    ioa(CSRmsg)
  
CSR1:

"        CSR ,,14,,1             " invert with truncation fault enable option
"        BDSC     FLD1,18,2,0    " FLD1 operand descriptor
"        BDSC     FLD2,12,0,0    " FLD2 operand descriptor
"        USE      CONST.         " memory contents in octal
"
"FLD1   OCT      444444          " 000000444444
"FLD2   DEC          0           " 333300000000  (Result)

        CSR     (),(),bool(14),enablefault  " invert with truncation fault enable option
        descb   FLD1am(18),18   " FLD1 operand descriptor
        descb   FLD2am,12       " FLD2 operand descriptor
                                " memory contents in octal
        call    ioa(msg24o, FLD2am)
        
        tra     CSR2

FLD1am: OCT     444444          " 000000444444
FLD2am: DEC     0               " 333300000000  (Result)
     
CSR2:

"        CSR     ,,17            " force ones operation
"        BDSC    ,0              " FLD1 operand descriptor
"        BDSC    FLD2,36,0,0     " FLD2 operand descriptor
"        USE     CONST.          " memory contents in octal
"FLD2:   BSS     1               " 777777777777   (Result)
"        USE
"        dis

        CSR     (),(),bool(17)  " force ones operation
        BDSC    0,0             " FLD1 operand descriptor
        BDSC    FLD2an,36,0,0   " FLD2 operand descriptor
        
        call    ioa(msg24o, FLD2an)

        tra     SZTL0
                                " memory contents in octal
FLD2an: BSS     1               " 777777777777   (Result)
        

SZTLmsg:   acc  "SZTL Tests ...\r\n"
msg29:     acc  "1. Passed\r\n"
msg30:     acc  "2. Passed\r\n"

SZTL0:
       call     ioa(SZTLmsg)
       
SZTL1:
       
"       SZTL     ,,6             exclusive OR operation
"       BDSC     FLD1,36,0,0     FLD1 operand descriptor
"       BDSC     FLD2,35,0,1     FLD2 operand descriptor
"       TZE      ALLOFF          zero indicator ON
"       TRTN     TRUNC           truncation indicator ON
"       USE      CONST.          memory contents in octal
"FLD1   DEC      -1              777777777777
"FLD2   DEC      -1              777777777777
                                "indicators set? - zero/trunc

        SZTL     (),(),bool(6)   " exclusive OR operation
        BDSC     FLD1ao,36,0,0   " FLD1 operand descriptor
        BDSC     FLD2ao,35,0,1   " FLD2 operand descriptor
        "TZE      SZTL1b         " zero indicator ON
        TNZ      NO.GOT          " zero should be ON
        TRTN     SZTL1b          " truncation indicator ON
        TRA      NO.GOT          " memory contents in octal

FLD1ao: DEC      -1              " 777777777777
FLD2ao: DEC      -1              " 777777777777
                                 " indicators set? - zero/trunc
                                 
SZTL1b:

        call    ioa(msg29)

SZTL2:

"       LDI      0,DL
"       LDX7     -1,DU       " load negative value into X7
"       STI      FLD1        "  store processor indicators
"       SZTL     ,,1         "  AND operation
"       BDSC     FLD1,1,2,1  " FLD1 operand descriptor
"       BDSC     FLD2,1,2,1  "  FLD2 operand descriptor
"       TNZ      19ON        "  not zero - neg indicator ON
"       USE      CONST.      " memory contents in octal
"FLD1   BSS      1           " x x x x x x 2 0 0 0 0 0
"FLD2   DEC      1B19        " 0 0 0 0 0 0 2 0 0 0 0 0
"       USE                  " indicators set? - none
    
       LDI      0,DL        
       LDX7     -1,DU           " load negative value into X7
       STI      FLD1ap          " store processor indicators
       SZTL     (),(),bool(1)   " AND operation
       descb    FLD1ap(19),1    " FLD1 operand descriptor
       descb    FLD2ap(19),1    " FLD2 operand descriptor
       TZE      NO.GOT          " If ZERO is ON then this is an error. not zero - neg indicator ON
       TRA      SZTL2b          " memory contents in octal
       
FLD1ap:BSS      1               " x x x x x x 2 0 0 0 0 0
FLD2ap:oct      200000          " 0 0 0 0 0 0 2 0 0 0 0 0
                                " indicators set? - none
SZTL2b:  
  
        call    ioa(msg30)

        tra     SZTR0
        
"
" SCTR Tests ...
"
SCTRmsg: acc    "SZTR Tests ....\r\n"
msg31:   acc    "1. Passed\r\n"
msg32:   acc    "2. Passed\r\n"

SZTR0:
        call    ioa(SCTRmsg)

"       SZTR     ,,3,1       " evaluate FLD1 as is (move)
"       BDSC     FLD1,1,2,1  " FLD1 operand descr. (bit 19)
"       BDSC     0,1         " FLD2 operand descriptor
"       TNZ      19ON
"       USE      CONST.      " memory contents in octal
"FLD1   DEC      1B19        " 000000200000
"       USE                  " indicators set? - zero

SZTR1:
       SZTR     (),(),bool(3),enablefault       " evaluate FLD1 as is (move)
       descb    FLD1aq(19),1    " FLD1 operand descr. (bit 19)
       descb    0,1             " FLD2 operand descriptor
       TZE      NO.GOT          " if ZERO it's an error
                                " memory contents in octal
       TRA      SZTR1b

FLD1aq:  oct      200000     " 0 0 0 0 0 0 2 0 0 0 0 0
                            " indicators set? - zero

SZTR1b: call    ioa(msg31)
        call    ioa(msg24o, FLD1aq)

"        LDI      0,DL       " clear processor indicators
"        LDX7     0,DU       " load zeros into X7
"        STI      FLD1       " store processor indicators
"        SZTR     ,,14       " invert
"        BDSC     FLD1,1,2,0 " FLD1 operand descr. (bit 18)
"        BDSC     0,1        " FLD2 operand descriptor
"        TZE      18ON       "   zero indicator ON
"        USE      CONST.     " memory contents in octal
"FLD1:   BSS      1          " x x x x x x 4 0 0 0 0 0
                            " indicators set? zero


        LDI     0,DL       " clear processor indicators
        LDX7    0,DU       " load zeros into X7
        STI     FLD1ar     " store processor indicators
        SZTR    (),(),bool(14) " invert
        descb   FLD1ar(18),1 " FLD1 operand descr. (bit 18)
        BDSC    0,1        " FLD2 operand descriptor
        TNZ     NO.GOT     " zero indicator ON
        
        call     ioa(msg32)
        call    ioa(msg24o, FLD1ar)
        
        
        tra     EISdec0

                            " memory contents in octal
FLD1ar: dec     0           " x x x x x x 4 0 0 0 0 0 (Hey what about NBAR & ABS?)
                            " indicators set? zero


"
" EIS decimal instruction tests .....
"
AD2Dmsg:    acc     "AD2D Tests ....\r\n"

msg33:      acc     /1. Result: ^n ^n (Should be 053071070066 063066066000)\r\n/
msg34:      acc     /2. Result: ^n ^n (Should be 053061063063 064000000000)\r\n/
msg35:      acc     /3. Result: ^n (Should be 001023105153)\r\n/

EISdec0:
            call    ioa (AD2Dmsg)

AD2D1:
            ad2d    (), (), round
            ndsc9   FLD1as,1,7,2,-2
            ndsc9   FLD2as,0,8
            
            call    ioa(msg33, FLD2as, FLD2as+1)
            
            tra     AD2D2
            
FLD1as:     aci     / 123450-/      " -1234.50
FLD2as:     aci     /+009/
            vfd     a3/876,9/2
"FLD2as:    aci     /+0098762/      " 987600
                                    " result: +986366 0

            

AD2D2:
"            AD2D    ,,,,1           with truncation enable option
"            NDSC4   FLD1,0,8,2,-2   FLD1 addend operand descriptor
"            NDSC9   FLD2,0,6        FLD2 addend operand descriptor memory contents
"            USE     CONST.
"FLD1        EDEC    8P123456+       0123456+
"FLD2        EDEC    6A+1E+2         +00012
"            USE                     +13340 (Sum) (truncation fault)

            AD2D    (), (), enablefault "with truncation enable option
            NDSC4   FLD1at,0,8,2,-2     "FLD1 addend operand descriptor
            NDSC9   FLD2at,0,6          "FLD2 addend operand descriptor memory contents

            call    ioa(msg34, FLD2at, FLD2at+1)

            tra     AD2D3
            
FLD1at:     ac4     /0123456+/      "0123456+
FLD2at:     vfd     a4/+000,a1/1, 9/2   "+00012
                                    " +13340 (Sum) (truncation fault)




"            AD2D    ,,,1            with plus sign octal 13 option
"            NDSC9   FLD1,0,4        FLD1 addend operand descriptor
"            NDSC4   FLD2,1,7,2,-4   FLD2 addend operand descriptor
"            USE     CONST.
"FLD1        EDEC    4A+99.          +990
"FLD2        EDEC    8P123456+       0123456+
"            USE     memory contents 0113456+ (Sum)

AD2D3:
            AD2D    (),(),ascii     "   with plus sign octal 13 option
            NDSC9   FLD1au,0,4      "FLD1 addend operand descriptor
            NDSC4   FLD2au,1,7,2,-4 "FLD2 addend operand descriptor
                                    " (overflow fault)
￼
            call    ioa(msg35, FLD2au)
            
            TRA     AD3D0

"FLD1au:     aci     /+990/      this will cause formatDecimal() to raise SIGFPE cause exponent in too big to fit in number
FLD1au:     vfd     a3/+99, 9/0     "+990
FLD2au:     ac4     /0123456+/      "0123456+
            "USE     memory contents 0113456+ (Sum)


AD3Dmsg:    acc     /AD3D Tests ... \r\n/
msg36:      acc     /1. Result ^n (Should be 000260145126)\r\n/
msg37:      acc     /2. Result ^n (Should be 000013003106)\r\n/

AD3D0:
            call    ioa(AD3Dmsg)


"        AD3D     ,,,1,1         " w/ rounding, plus sign options
"        NDSC9   FLD1,0,4,3,-2   " FLD1 addend operand descriptor
"        NDSC9   FLD2,0,8,2,-2   " FLD2 addend operand descriptor
"        NDSC4   FLD3,2,6,1      " operand descriptor, sum field
"        USE     CONST.          " memory contents
"FLD1    EDEC    4A1234          "  1234
"FLD2    EDEC    8A654321+       " 0654321+
"FLD3    BSS      1              " xx+06556   (Sum)
"        USE instruction fault?   no
"
AD3D1:
        AD3D    (),(),(),ROUND,ascii " w/ rounding, plus sign options
        desc9ns FLD1av,4,-2     " FLD1 addend operand descriptor
        desc9ts FLD2av,8,-2     " FLD2 addend operand descriptor
        desc4ls FLD3av(2),6     " operand descriptor, sum field

        call    ioa(msg36, FLD3av)

        tra     AD3D2
                                " memory contents
FLD1av: aci     /1234/          "  1234
FLD2av: aci     /0654321+/      " 0654321+
FLD3av: BSS     2              " xx+06556   (Sum)
                                " instruction fault?   no
        
AD3D2:

"        EQU      X6,14
"        EAX2     2      load character modifier into X2
"        EAX6     6      load FLD1 length into X6
"        EAX4     FLD1   load FLD1 address into X4
"        AWDX     0,4,4  put FLD1 address into AR4
"        AD3D     (1),(,1,,X2),(,,1),1,1
"        NDSC9    0,0,4,0,0,4  FLD1 operand descriptor (FLD1,0,4,0)
"        NDSC4    FLD2,,X6,3,-2 FLD2 operand descriptor (FLD2,2,6,3,-2)
"
"        ARG DFLD3   pointer,FLD3 operand descriptor
"        USE CONST.  memory contents
"FLD1    EDEC 4A-12E+2   -122
"FLD2    EDEC 8P123456   00123456
"FLD3    BSS      1   xxx+0346   (Sum)
"DFLD3   NDSC4    FLD3,3,5,1,-1 FLD3 sum operand descriptor
"        USE                    instruction fault?   no

        EAX2     2          " load character modifier into X2
        EAX6     6          " load FLD2 length into X6
        EAX4     FLD1aw       " load FLD1 address into X4
        AWDX     pr4|0,4    " put FLD1 address into AR4
        AD3D     (ar),(rl,x2),(id),round,ascii
        desc9fl  pr4|0,4    " FLD1 operand descriptor (FLD1,0,4,0)
        desc4ns  FLD2aw,x6,-2 " FLD2 operand descriptor (FLD2,2,6,3,-2)
        ARG      DFLD3aw      " pointer,FLD3 operand descriptor
                            " memory contents

        "ad3d    (), (), (), round, ascii
        "ndsc9   FLD1,0,4,0
        "ndsc4   FLD2,2,6,3,-2
        "NDSC4   FLD3,3,5,1,-1
        
        call    ioa(msg37, FLD3aw)

        tra     SB2D0
                            
FLD1aw: vfd     a3/-12, 9/2     " -12 2
FLD2aw: ac4     /00123456/      " 00123456
FLD3aw: BSS     1               " xxx+0346   (Sum)
DFLD3aw:desc4ls FLD3aw(3),5,-1  " FLD3 sum operand descriptor
                                " instruction fault?   no

SB2Dmsg:    acc /SB2D Tests...\r\n/
msg38:  acc /1. result ^n ^n (Should be 055066065064 063060071376) \r\n/
msg39:  acc /2. result ^a ^a (Should be 8753 0864)\r\n/

SB2D0:
        call    ioa(SB2Dmsg)
        
SB2D1:        

"        SB2D     ,,1            " with rounding option
"        NDSC4    FLD1,0,4,2,-3  " subtrahend operand descriptor
"        NDSC9    FLD2,0,8       " minuend operand descriptor
"        USE      CONST.         " memory contents
"FLD1    EDEC     4P125+         " 125+
"FLD2    EDEC     8A+6543.21     " + 6 5 4 3 2 1 -2
                                " +654309-2 (Result)


        SB2D     (),(),round      " with rounding option
        NDSC4    FLD1ax,0,4,2,-3  " minuend operand descriptor
        NDSC9    FLD2ax,0,8       " subtrahend operand descriptor
        
        call    ioa(msg38, FLD2ax, FLD2ax+1)

        tra     SB2D2

                                " memory contents
FLD1ax: ac4      /125+/         " 125+
FLD2ax: vfd     a4/+654, a3/321, 9/-2
        "EDEC     8A+6543.21     " + 6 5 4 3 2 1 -2
                                " +654309-2 (Result)



SB2D2:  

"        SB2D    ,,,1          with truncation enable option
"        NDSC4   FLD1,0,8,3,-4 subtrahend operand descriptor
"        NDSC9   FLD2,0,8,3,-2 minuend operand descriptor
"        USE     CONST. memory contents
"FLD1    EDEC    8P12345678 12345678
"FLD2    EDEC    8A87654321 87654321
"        USE     87530864             (Result)
"
"*INSTRUCTION FAULT? YES

        SB2D    (),(),enablefault   " with truncation enable option
        NDSC4   FLD1ay,0,8,3,-4       " minuend operand descriptor
        NDSC9   FLD2ay,0,8,3,-2       " subtrahend operand descriptor

        call    ioa(msg39, FLD2ay, FLD2ay+1)

        tra     SB3D0
                                    " memory contents
FLD1ay: ac4     /12345678/          " 12345678
FLD2ay: aci     /87654321/          " 87654321
                                    " 87530864             (Result)

SB3Dmsg:    acc "SB3D Tests ... \r\n"
msg40:  acc     /1. Result ^n ^n (Should be 000000000053 060060060177)\r\n/
msg41:  acc     /2. Result ^n (Should be 320010144031)\r\n/

SB3D0:
        call    ioa(SB3Dmsg)
        
        
"        SB3D    ,,,1  with rounding option
"        NDSC4    FLD1,0,4,2     "subtrahend operand descriptor
"        NDSC4    FLD2,0,4,1     "minuend operand descriptor
"        NDSC9    FLD3,3,5       "operand desc for result field
"                                "memory contents
"
"FLD1  EDEC  4P123-      123-
"FLD2  EDEC  4P-123      -123
"FLD3   BSS      2               " XXX+000+127 (Result) zero indicator ON

SB3D1:
        SB3D    (),(),(),round  "with rounding option
        desc4ts FLD1az,4        "subtrahend operand descriptor
        desc4ls FLD2az,4        "minuend operand descriptor
        desc9fl FLD3az(3),5     "operand desc for result field
        tnz     NO.GOT
                                "memory contents
                                
        call    ioa(msg40, FLD3az, FLD3az+1)
        
        tra     SB3D2

        
FLD1az: ac4     /123-/         " 123-
FLD2az: ac4     /-123/         " -123
FLD3az: BSS     2              " XXX+000+127 (Result) zero indicator ON

SB3D2:

"       SB3D   (),(),(),enablefault  " with truncation enable option
"       NDSC9  FLD1,0,8              " subtrahend operand descriptor
"       NDSC9  FLD2,0,8              " minuend operand descriptor
"       NDSC4  FLD3,0,8,1,-2         " esult operand descriptor
"
"       USE          indicators on? -  negative and truncation
"                memory contents
"
"FLD1  EDEC  8A-123456E-3   - 1 2 3 4 5 6 -3
"FLD2  EDEC  8A-987654E-3   - 9 8 7 6 5 4 -3
"FLD3   BSS      1   -0086419   (Result)

        SB3D    (),(),(),enablefault   " with truncation enable option
        desc9fl FLD1ba, 8              " minuend operand descriptor
        desc9fl FLD2ba, 8              " subtrahend operand descriptor
        desc4ls FLD3ba, 8, -2          " result operand descriptor

        tpl     NO.GOT                 "indicators on? -  negative and truncation
        trtf    NO.GOT
        
       call     ioa(msg41, FLD3ba)
       
        tra     MP2D0
                                     " memory contents
FLD1ba: vfd  a4/-987, a3/654, 9/-3   " - 9 8 7 6 5 4 -3
FLD2ba: vfd  a4/-123, a3/456, 9/-3   " - 1 2 3 4 5 6 -3
FLD3ba: BSS      1                   " -0086419   (Result)
"
" 320010144031    
" 3   2   0   0   1   0   1   4   4   0   3   1
" 011 010 000 000 001 000 001 100 100 000 011 001
" 0 1101 0000 0 0000 1000 0 0110 0100 0 0001 1001
"   -    0      0    8      6    4      1    9


MP2Dmsg:    acc     ?MP2D Tests ...\r\n?
msg42:      acc     ?1. Result ^n (Should be 260000044151)\r\n?
msg43:      acc     ?2. Result ^n (Should be 301043105375)\r\n?

MP2D0:
            call    ioa(MP2Dmsg)

MP2D1:

"        MP2D    ,,1,1          rounding and plus sign options
"        NDSC9   FLD1,0,4,2,-3  multiplier operand descriptor
"        NDSC4   FLD2,0,8,1,-2  multiplicand operand descriptor
"        USE     CONST.         memory contents (Product)
"
"FLD1    EDEC     4A2+          002+
"FLD2    EDEC     8P+1234567    +1234567
"        USE                    result +0002469
"*                              indicators on?    none

        MP2D    (),(),round,ascii   "rounding and plus sign options
        desc9ts FLD1bb, 4, -3       "multiplier operand descriptor
        desc4ls FLD2bb, 8, -2       "multiplicand operand descriptor
        
        call    ioa(msg42, FLD2bb)
        
        tra MP2D2

                                " memory contents (Product)
FLD1bb: aci     /002+/          " 002+
FLD2bb: ac4     /+1234567/      " +1234567
                                " result +0002469
                                " indicators on?    none
" 260000044151
" 2   6   0   0   0   0   0   4   4   1   5   1
" 010 110 000 000 000 000 000 100 100 001 101 001
" 0 1011 0000 0 0000 0000 0 0010 0100 0 0110 1001
"   +    0      0    0      2    4      6    9

MP2D2:

"       MP2D     ,,1             rounding option
"       NDSC4    FLD1,0,8,3,-2   multiplier operand descriptor
"       NDSC4    FLD2,0,8        multiplicand operand descriptor
"       USE      CONST.          memory contents
"FLD1  EDEC      8P10            00000010
"FLD2  EDEC      8P+123.45       +12345-2
"
"       USE                      +12345-3 (Product)
"* indicators on?    none

       MP2D     (),(),round     "rounding option
       desc4ns  FLD1bc, 8, -2   "multiplier operand descriptor
       desc4fl  FLD2bc, 8       "multiplicand operand descriptor
                                "memory contents
                                
       call     ioa(msg43, FLD2bc)
      
       tra      MP3D0

FLD1bc:  ac4    /00000010/      " 00000010
FLD2bc:  ac4    /+12345ON/      " +12345-2

                                " +12345-3 (Product)
* indicators on?    none

" 2   6   1   0   4   3   1   0   5   3   7   6
" 010 110 001 000 100 011 001 000 101 011 111 110
" 0 1011 0001 0 0010 0011 0 0100 0101 0 1111 1110
"   +    1      2    3      4    5       -2(0376)

" 301043105375
" 3   0   1   0   4   3   1   0   5   3   7   5
" 011 000 001 000 100 011 001 000 101 011 111 101
" 0 1100 0001 0 0010 0011 0 0100 0101 0 1111 1101
"   +    1      2    3      4    5       -3(0375)


MP3Dmsg:    acc /MP3D Tests ... \r\n/
msg44:      acc /1. Result ^a ^a (Should be +61 7284)\r\n/
msg45:      acc /2. Result ^n (Should be 275060206377)\r\n/

MP3D0:

        call    ioa(MP3Dmsg)
        
MP3D1:

"        MP3D     ,,,1           with rounding option
"        NDSC4   FLD1,6,2,2     multiplier operand descriptor
"        NDSC4   FLD2,0,8,1,-3  multiplicand op descriptor
"        NDSC9   FLD3,1,7,1,-2  product operand descriptor
"        USE     CONST.          memory contents
"
"FLD1  EDEC  8P5+        " 0000005+
"FLD2  EDEC  8P+1234567  " +1234567
"FLD3   BSS      2       " +617284    (Product)
"
"        USE indicators on?    none



        MP3D    (),(),(),round   "with rounding option
        desc4ts FLD1bd(6),2      "multiplier operand descriptor
        desc4ls FLD2bd,8,-3      "multiplicand op descriptor
        desc9ls FLD3bd(1),7,-2   " product operand descriptor
        call    ioa(msg44, FLD3bd, FLD3bd+1)
        
        tra     MP3D2

                                " memory contents
FLD1bd:  ac4      /0000005+/      " 0000005+
FLD2bd:  ac4      /+1234567/      " +1234567
FLD3bd:  BSS      2               " +617284    (Product)
                                " indicators on?    none

MP3D2:

"        MP3D     ,,,,1
"        NDSC4   FLD1,0,2,3,-2  multiplier operand descriptor
"        NDSC4   FLD2,0,8,1,-3  multiplicand op descriptor
"        NDSC4   FLD3,1,7        product operand descriptor
"        USE     CONST.          memory contents
"FLD1   EDEC     2PL25           25000000
"FLD2   EDEC     8P-1234567      -1234567
"FLD3   EDEC     8P+0            +-3086-1    (Product)
"
"        USE  instruction fault?    no
"* indicators on? truncation and negative

        MP3D    (),(),(), enablefault
        desc4ns FLD1be, 2, -2   " multiplier operand descriptor
        desc4ls FLD2be, 8, -3   " multiplicand op descriptor
        desc4fl FLD3be(1), 7    " product operand descriptor
        
        tpl     NO.GOT          " indicators on? -  negative and truncation
        trtf    NO.GOT

        call    ioa(msg45, FLD3be)
        
        tra     DV2D0
        
        
                                "memory contents
FLD1be:   ac4     /25000000/      " 25000000
FLD2be:   ac4     /-1234567/      "-1234567
FLD3be:   ac4     /+/             "+-3086-1    (Product)
                                " instruction fault?    no
* indicators on? truncation and negative

" 275060206377
" 2   7   5   0   6   0   2   0   6   3   7   7
" 010 111 101 000 110 000 010 000 110 011 111 111
" 0 1011 1101 0 0011 0000 0 1000 0110 0 1111 1111
"   +    -      3    0      8    6      -1 (0377)


DV2Dmsg:    acc     /DV2D Tests ... \r\n/
msg46:      acc     /1. Result ^n (Should be 304062020003)\r\n/
msg47:      acc     /2. Result ^n (Should be 300044150000)\r\n/

DV2D0:
            call    ioa(DV2Dmsg)
            
DV2D1:

"            DV2D
"            NDSC4   FLD1,4,4,2,-4   divisor operand descriptor
"            NDSC4   FLD2,0,8,0      dividend operand descriptor
"            USE     CONST.          memory contents
"FLD1        EDEC    8P2+            0002+
"FLD2        EDEC    8P+8642E0       +08642 +0
"            USE                     +43210 +3   (Quotient)

            DV2D    (), ()
            DESC4TS FLD1bf(4), 4, -4 "divisor operand descriptor
            DESC4FL FLD2bf,8         "dividend operand descriptor
                                     "memory contents
                                     
            call    ioa(msg46, FLD2bf)
                            
            tra     DV2D2
                                    
FLD1bf:     ac4     /   0002+/      "0002+
FLD2bf:     ac4     /+0864200/      "+08642 +0
                                    "+43210 +3   (Quotient)
" 304062020003
" 3   0   4   0   6   2   0   2   0   0   0   3
" 011 000 100 000 110 010 000 010 000 000 000 011
" 0 1100 0100 0 0011 0010 0 0001 0000 0 0000 0011
"   +    4      3    2      1    0        +3
"

DV2D2:

"        DV2D    ,,1             with rounding option
"        NDSC9   FLD1,0,4,1,-3   divisor operand descriptor
"        NDSC4   FLD2,0,8,1,-2   dividend operand descriptor
"        USE     CONST.          memory contents
"
"FLD1   EDEC    4A+5             " +005
"FLD2   EDEC    8P+1234          " +0001234
"        USE +0246800            " (Quotient)
"                                " indicators on?   none

        DV2D    (),(),round     " with rounding option
        DESC9LS FLD1bg,4,-3     " divisor operand descriptor
        DESC4LS FLD2bg,8,-2     " dividend operand descriptor
                                " memory contents
        call    ioa(msg47, FLD2bg)
        
        tra     DV3D0
        
FLD1bg: aci     /+005/          " +005
FLD2bg: ac4     /+0001234/      " +0001234
                                " +0246800 (Quotient)
                                " indicators on?   none
"
" 300044150000
" 3   0   0   0   4   4   1   5   0   0   0   0
" 011 000 000 000 100 100 001 101 000 000 000 000
" 0 1100 0000 0 0010 0100 0 0110 1000 0 0000 0000
"   +    0      2    4      6    8      0    0 

DVD3msg:    acc     /DV3D Tests ... \r\n/
msg48:      acc     /1. Result ^n (Should be 000263202162)\r\n/
msg49:      acc     /2. Result ^n (Should be 013103202162)\r\n/

DV3D0:
        call    ioa(DVD3msg)
        
DV3D1:

"        DV3D     ,,,1,1         rounding, plus sign options
"        NDSC9    FLD1,1,3,2,-2  divisor operand descriptor
"        NDSC4    FLD2,0,9,0     dividend operand descriptor
"        NDSC4    FLD3,2,6,1,-1  quotient operand descriptor
"        USE      CONST.         memory contents
"FLD1   EDEC     4A2-            002-
"FLD2   EDEC     9P-876543E-3    -876543-3
"FLD3   BSS      1    xx+38272   (Quotient)
"       USE                      instruction fault?   overflow
￼
        DV3D    (),(),(),round,ascii    " rounding, plus sign options
        desc9ts FLD1bh(1),3,-2          " divisor operand descriptor
        desc4fl FLD2bh,9                " dividend operand descriptor
        desc4ls FLD3bh(2),6,-1          " quotient operand descriptor

        call    ioa(msg48, FLD3bh)

        tra     DV3D2
                                        " memory contents
FLD1bh: aci      /002-/                 " 002-
FLD2bh: ac4      /-876543OM/            " -876543-3
FLD3bh: BSS      1                      " xx+38272   (Quotient)
                                        " instruction fault?   overflow
￼"
" 000263202162
" 0   0   0   2   6   3   2   0   2   1   6   2
" 000 000 000 010 110 011 010 000 010 001 110 010
" 0 0000 0000 0 1011 0011 0 1000 0010 0 0111 0010
"   x    x      +    3      8    2      7    2


DV3D2:
"        EQU     X7, 15
"        EAX2    2               load character mod into X2
"        EAX7    8               load FLD2 length into X7
"        EAX4    FLD1            load FLD1 address into X4
"        AWDX    0,4,4           put FLD1 address into AR4
"
"        DV3D (1,,,2),(,1),(,,1),1,1  with addr mod options
"        NDSC9   0,0,2,3,-2,4    divisor operand descriptor (FLD1,2,2,3,-2)
"        NDSC9   FLD2,0,X7,0     dividend operand descriptor (FLD2,0,8,0)
"        ARG     2,2,4           ptr quotient operand desc
"        USE     CONST.          memory contents
"
"
"FLD1   EDEC     4A2             0002
"FLD2   EDEC     8A+876543E-3    +876543-3
"FLD3   BSS      1               x+438272
"       NDSC4    FLD3,1,7,1,-1
"        USE  quotient operand descriptor
"        instruction fault?     none

" ar,rl,id,reg

        EAX2    2               " load character mod into X2
        EAX7    8               " load FLD2 length into X7
        EAX4    FLD1bi          " load FLD1 address into X4
        AWDX    pr4|0, 4        " put FLD1 address into AR4
        DV3D    (pr,x2),(rl),(id),round,ascii  " with addr mod options
        desc9ns pr4|0, 2, -2    " divisor operand descriptor (FLD1,2,2,3,-2)
        desc9fl FLD2bi, x7      " dividend operand descriptor (FLD2,0,8,0)
        ARG     pr4|2, 2        " ptr quotient operand desc

        call    ioa(msg49, FLD3bi)
        
        tra     CMPN0
                                " memory contents
FLD1bi: aci     /0002/          " 0002
FLD2bi: vfd     a4/+876, a3/543, 9/-3    " +876543-3
FLD3bi: BSS     1               " x+438272
        desc4ls FLD3bi(1),7,-1  " quotient operand descriptor
                                " instruction fault?     none



"        DV3D    (),(),(),round,ascii  "with addr mod options
"        NDSC9   FLD1,2,2,3,-2    "divisor operand descriptor (FLD1,2,2,3,-2)
"        NDSC9   FLD2,0,8,0     "dividend operand descriptor (FLD2,0,8,0)
"        NDSC4   FLD3,1,7,1,-1   " quotient operand descriptor
"                                "memory contents
"        call    ioa(msg49, FLD3)
"        dis
"
"FLD1:   aci     /0002/          " 0002
"FLD2:   vfd     a4/+876, a3/543, 9/-3    " +876543-3
"FLD3:   BSS     1               " x+438272

" 013103202162
" 0   1   3   1   0   3   2   0   2   1   6   2
" 000 001 011 001 000 011 010 000 010 001 110 010
" 0 0000 1011 0 0100 0011 0 1000 0010 0 0111 0010
"     x   +     4    3      8    2      7    2      
"

CMPNmsg:    acc     "CMPN Tests ... \r\n"
msg50:      acc     "1. Result FLD2 = FLD1\r\n"
msg51:      acc     "2. Result FLD2 = FLD1\r\n"
msg52:      acc     "3. Result FLD2 > FLD1\r\n"

CMPN0:
        call    ioa(CMPNmsg)

CMPN1:

"        CMPN                    no modification
"        NDSC4    FLD1,0,8,1,-2  FLD1 operand descriptor
"        NDSC4    FLD2,0,8,0     FLD2 operand descriptor
"        TZE      EQUAL          FLD2 = FLD1
"        TMI      LESS           FLD2 < FLD1
"        TNC      ABS.LT         |FLD2| < |FLD1|
"
"        USE      CONST.         numbers compared
"FLD1   EDEC     8P-12345        -0012345
"FLD2   EDEC     8P-123.45       -0012345
"                               Result - FLD2 =  FLD1



        CMPN     (),()           "no modification
        NDSC4    FLD1bj,0,8,1,-2 "FLD1 operand descriptor
        NDSC4    FLD2bj,0,8,0    "FLD2 operand descriptor
        TZE      EQUAL2          "FLD2 = FLD1 (Result - FLD2 =  FLD1)
        TMI      NO.GOT          "FLD2 < FLD1
        TNC      NO.GOT          "|FLD2| < |FLD1|
        TRA      NO.GOT

EQUAL2: call    ioa(msg50)
        
        tra     CMPN2
                                " numbers compared
FLD1bj: ac4     /-0012345/      " -0012345
FLD2bj: ac4     /-12345ON/      " -12345 -2

CMPN2:

"        CMPN                    no modification
"       NDSC9    FLD1,2,2,3      FLD1 operand descriptor
"       NDSC4    FLD2,0,8,2,-3   FLD2 operand descriptor
"       TZE      EQUAL           FLD2 = FLD1
"       TMI      LESS            FLD2 < FLD1
"       TRA      GREATER         FLD2 > FLD1
"       USE      CONST.          numbers compared
"FLD1   EDEC     4A0012          +0012000
"FLD2   EDEC     8P12000+        +0012000
"        USE     Result - FLD2 =  FLD1

        CMPN     (),()           " no modification
        desc9ns FLD1bk(2),2      " FLD1 operand descriptor
        desc4ts FLD2bk, 8, -3    " FLD2 operand descriptor
        TZE      EQUAL3          " FLD2 = FLD1
        TMI      NO.GOT          " FLD2 < FLD1
        TRA      NO.GOT          " FLD2 > FLD1
                                 " numbers compared
FLD1bk: aci     /0012/           " +0012000
FLD2bk: ac4     /0012000+/       " +0012000
        "USE     Result - FLD2 =  FLD1

EQUAL3: call    ioa(msg51)

"        EQU     X6,14
"        EAX2    2           load character mod into X2
"        EAX6    6           load FLD1 length into X6
"        EAX4    FLD1        load FLD1 address into X4
"        AWDX    0,4,4       put FLD1 address into AR4
"        CMPN    (1,1,,X2), (,,1)    with address modification
"        NDSC4    0,0,X6,3,-3,4      FLD1 operand descriptor (FLD1,2,6,3,-3)
"        ARG      FLD2.I pointer to operand descriptor
"        TZE      EQUAL      FLD2 = FLD1
"        TPL      MORE       FLD2 > FLD1
"        TRA      LESS       FLD2 < FLD1
"        USE      CONST.
"FLD1    EDEC     8P123456       +01234560
"FLD2    EDEC     8P123456+      +01234560
"FLD2.I  NDSC4    FLD2,0,8,2,-2
"        Result - FLD2 > FLD1

        EAX2    2           " load character mod into X2
        EAX6    6           " load FLD1 length into X6
        EAX4    FLD1bl      " load FLD1 address into X4
        AWDX    0,4,4       " put FLD1 address into AR4
        CMPN    (ar,rl,x2),(id)    " with address modification
        desc4ns pr4|0,x6,-3 " FLD1 operand descriptor (FLD1,2,6,3,-3)
        ARG     FLD2bl.I    " pointer to operand descriptor
        TZE     NO.GOT      " FLD2 = FLD1
        TPL     MORE        " FLD2 > FLD1 Result - FLD2 > FLD1
        TRA     NO.GOT      " FLD2 < FLD1

MORE:   
        call    ioa(msg52)
        dis

FLD1bl: ac4     /00123456/      " +00123456
FLD2bl: ac4     /0123456+/      " +01234560
FLD2bl.I: desc4ts FLD2bl,8,-2


        

        dis
        
msg3:      acc         "Result: ^n (Should be 777777775456)\r\n"
msg4:      acc         "Result: ^n (Should be 777777001000)\r\n"
msg5:      acc         "Result: ^n (Should be 000000000777)\r\n"


MVNEmsg:   acc         "MVNE Tests ...\r\n"


FLD1c:  oct     000001043115    " 8P1234-
        ac4     "0001234-"
        
FLD2c:  bss     1               " 777777775456  (Result)

FLD1d:  oct     000005022000    " 8P51200
FLD2d:  dec     -1

FLD1e:  oct     061060062063    " 4A1023
FLD2e:  dec     0

msg6:   acc     "Result: '^a^a^a' (Should be '   $3004.05-')\r\n"
msg7:   acc     "Result: '^g^g' (Should be '   $3004.05-')\r\n"
msg8:   acc     "Result: '^a^a^a' (Should be '   ?3004.05@')\r\n"

FLD1f:  aci     /000300405-/

"FLD2f:  vfd     9/cht,a8/ *+-$,.0,9/mflc+7,9/enf+8,9/insb+7 "MICROP (CHT,0),8H *+-$,.0,(MFLC,7),(ENF,8),(INSB,7)
FLD2f:  vfd     9/mflc+7,9/enf+8,9/insb+7,9/mvc+2   "MICROP (CHT,0),8H *+-$,.0,(MFLC,7),(ENF,8),(INSB,7)
        vfd     9/insn+4                           "MICROP  (MVC,2),(INSN,4) memory contents in BCD char.
FLD2f1: vfd     9/cht, h3/ *+       "need to be able to combine these 1st two -- h2 + h3 = h5 == 45-bits!!!
        vfd     h2/-$, o9/020, h1/.
        vfd     h1/0,9/mflc+7, 9/enf+8, 9/insb+7,9/mvc+2, 9/insn+4

FLD2f2: vfd     9/cht, a3/ *+
        vfd     a2/@?, o9/054, a1/.
        vfd     a1/0, 9/mflc+7, 9/enf+8, 9/insb+7  "MICROP (CHT,0),8H *+-$,.0,(MFLC,7),(ENF,8),(INSB,7)
        vfd     9/mvc+2, 9/insn+4                  "MICROP  (MVC,2),(INSN,4) memory contents in BCD char.

FLD3f:  bss     3
FLD3f1: bss     2
FLD3f2: bss     3

msg9:   acc     "Result '^a^a^a' (Should be '*2505,09-   ')\r\n"

FLD1g:  ac4     /0250509-/  "8P250509-
FLD2g:  vfd     9/mvza+5, 9/ses+8, 9/insa+6, 9/mvc+2        "MICROP  (MVZA,5),(SES,8),(INSA,6),(MVC,2)
        vfd     9/insn+4, 9/insm+3                          "MICROP  (INSN,4),(INSM,3)
FLD3g:  BSS     3


MVEmsg: acc     "MVE Tests ...\r\n" 

msg10:  acc     "Result: '^g^g^g^g^g' (Should be '* SMITHROGER, WILLIAM S. - #25')\r\n"

FLD1h:  BCI     "12SMITHROGERWILLIAMS25AB"
FLD2h:  vfd     9/cht, h1/*, o9/073, h1/.               "MICROP  (CHT,0),8H*,.-    
        vfd     h1/-, o9/020, o9/020, o9/020, 
        vfd     o9/020, 9/ses+8, 9/insb+1, 9/insb+5     "MICROP  (SES,8),(INSB,1),(INSB,5)
        vfd     9/mvc+10, 9/insb+2, 9/insb+5, 9/mvc+7   "MICROP  (MVC,10),(INSB,2)(INSB,5),(MVC,7)
        vfd     9/insb+5, 9/mvc+1, 9/insb+3, 9/insb+5   "MICROP  (INSB,5),(MVC,1),(INSB,3),(INSB,5)
        vfd     9/insb+4, 9/insb+5, 9/insb+0, h1/#      "MICROP  (INSB,4),(INSB,5),(INSB,0),1H#
        vfd     9/mvc+2                                 "MICROP  (MCV,2)
FLD3h:  bss     5

msg11:  acc     "Result: '^a^a^a' (Should be 'code error#2')\r\n"

FLD1i:  ACI     "error-2"
FLD2i:  vfd     9/lte+1, A1/#, 9/mvc+5, 9/insm+1    "MICROP  (LTE,1),1A#,(MVC,5),(INSM,1),(IGN,1),(MVC,1)
        vfd     9/ign+1, 9/mvc+1
FLD3i:  ACI     "code ", 12

MLRmsg:    acc         "MLR Tests .....\r\n"

msg12:  acc     /Result: '^g^g^g' (Should be 'xxxxABCDEFGHIJKL  ')\r\n/
FLD1j:  BCI     /ABCDEFGHIJKL/ " memory contents
FLD2j:  bss     3              "xxxxABCDEFGHIJKL  " (Result)

msg13:  acc     /Result: ^n ^n (Should be 000000000022 064126170235)\r\n/
FLD1k:  BCI     /   12345678R/
FLD2k:  bss     2               "xxxxxx123456789-  (Result)

msg14:  acc     /Result: '^a^a' (Should be 'SOURCE T')\r\n/
FLD1l:  Aci     /THIS IS THE SOURCE TEXT/
FLD2l:  BSS     2

msg15:  acc     /Result: '^a^a^a' (Should be '.....LE ....')\r\n/
FLD1m:  ACi     /SAMPLE TEXT TO MOVE/
FLD2m:  aci     /............/

msg16:  acc     /Result: "^a^a" (Should be "HIS IS")\r\n/
FLD1n:  ACI     /THIS IS THE TEXT/
FLD2n:  BSS     2

MRLmsg:    acc         "MRL Tests .....\r\n"

msg17:  acc     /Result: '^g^g^g' (Should be 'xxxx  ABCDEFGHIJKL')\r\n/
FLD1o:  BCI     /ABCDEFGHIJKL/
FLD2o:  BSS     3

msg18:  acc     /Result: '^n ^n' (Should be '000000320001 043105147211')\r\n/
FLD1p:  BCI     /   12345678R/
FLD2p:  bss     2               "xxxx-00123456789  (Result)

                                    
TCTmsg: acc     /TCT Tests ... (Results 020000000013 & 040000000004)\r\n/

msg24o: acc     /Result: ^n\r\n/

FLD1x:  bci     / 1234567890#/  " 200102030405060710110013 (oct)
FLD3x:  BSS 1                   " char. & count - 020000000013
            "                               Octal
            " 0  1  2  3   4  5  6  7       Index
TABLEx: OCT 000000000000,000000000000        "0X
        OCT 000000020020,020020020020        "1X
        OCT 000000000000                     "2X
            " Result - nonzero char. found
￼
                             " memory contents
FLD1y:  aci      /  1234;5/  " 040040061062063064073065  (oct)
FLD3y:  BSS     1            " char. and count 040000000004
INDSCRy:desc9a   pr7|0, x6   " indexing FLD1 operand descr.
TABLEy: BSS 12               " generate 60 (oct) table chars.
        OCt 000000000000,000000000000  " (060-067)
        OCT 000000000040               " (070-073)


TCTRmsg:    acc        /TCTR Tests (Result 000000000012) ...\r\n/


FLD1z:  ac4     /0000001234567890/  " 0000001234567890
FLD3z:  BSS     1           " char/count 000000000012 (oct)
TABLEz: OCT            0,           0
        OCT 000000014014,000000014014


CMPCmsg:    acc     "CMPC Tests ...\r\n"

msg25:  acc     "They are equal\r\n"

FLD1aa: BCI     /ABCD/          "     'ABCD  '
FLD2aa: BCI     /XXXXABCDXXXX/  " 'XXXXABCDXXXX'
￼

DATA:  BCI      /AABBCCDDEEFF/
       BCI      /GGHHIIJJKKLL/
COUNT: BSS      1           "COUNT contains decimal 14 (octal 16)
COMP:  BCI      /HH/
￼

FLD1ad:  aci      /000001234567/
FLD3ad:  DEC      0           "unmatched count - 3
 


CMPBmsg:    acc     "CMPB Tests ...\r\n"
msg26:      acc     "1. FLD1 > FLD2\r\n"
msg27:      acc     "2. FLD1 < FLD2\r\n"
msg28:      acc     "3. FLD1 = FLD2\r\n"



        include     rdclock.as8
        include     Utils.as8
        

