!SIZE 000625
000000 xxxx 000072702000     tsx2    rd_clock
000001 xxxx 000064757000     staq    Date        "MM/DD HH:MM
000002 xxxx 000277701000     call    ioa(msgHello, Date, Date+1)
000003 xxxx 000010710000 
000004 xxxx 000000000000 
000005 xxxx 000034000000 
000006 xxxx 000064000000 
000007 xxxx 000065000000 
000010 xxxx 000615235000     lda     =42
000011 xxxx 000066755000     sta     result1
000012 xxxx 000616236000     ldq     =-42
000013 xxxx 000067756000     stq     result2
000014 xxxx 000277701000     call    ioa(msg2a, result1, result2)
000015 xxxx 000022710000 
000016 xxxx 000000000000 
000017 xxxx 000043000000 
000020 xxxx 000066000000 
000021 xxxx 000067000000 
000022 xxxx 000070717000     xed     i1
000023 xxxx 000066755000     sta     result1
000024 xxxx 000067756000     stq     result2
000025 xxxx 000277701000     call    ioa(msg2b, result1, result2)
000026 xxxx 000033710000 
000027 xxxx 000000000000 
000030 xxxx 000053000000 
000031 xxxx 000066000000 
000032 xxxx 000067000000 
000033 xxxx 000000616000     dis
000034 xxxx 032124150151 msgHello:  acc         "This is TestXED ... ^g^g\r\n"
000035 xxxx 163040151163 
000036 xxxx 040124145163 
000037 xxxx 164130105104 
000040 xxxx 040056056056 
000041 xxxx 040136147136 
000042 xxxx 147015012040 
000043 xxxx 034122145163 msg2a:     acc         "Result (before): A=^d Q=^d\r\n"
000044 xxxx 165154164040 
000045 xxxx 050142145146 
000046 xxxx 157162145051 
000047 xxxx 072040101075 
000050 xxxx 136144040121 
000051 xxxx 075136144015 
000052 xxxx 012040040040 
000053 xxxx 034122145163 msg2b:     acc         "Result  (after): A=^d Q=^d\r\n"
000054 xxxx 165154164040 
000055 xxxx 040050141146 
000056 xxxx 164145162051 
000057 xxxx 072040101075 
000060 xxxx 136144040121 
000061 xxxx 075136144015 
000062 xxxx 012040040040 
000063 xxxx 000000011000             even "(allocating 1 nop)
000064 xxxx 000000000000 Date:       bss     2
000066 xxxx 000000000000 result1:    bss 1
000067 xxxx 000000000000 result2:    bss 1
000070 xxxx 000617235000 i1:     lda     =123456
000071 xxxx 000620236000 i2:     ldq     =7891011
000072 xxxx 000000633000 rd_clock:	rccl                " read the clock
000073 xxxx 000216757000 cv_clock:	staq	rdctime     " save clock reading
000074 xxxx 000166742000 	stx2	datx2               " save XR's
000075 xxxx 000167740000 	stx0	datx2+1             " ..
000076 xxxx 000034235007 	lda     28,dl               " Initialize montab
000077 xxxx 000221755000 	sta     montab+1			" to prime Feb
000100 xxxx 000216237000 	ldaq	rdctime             " Get clock reading
000101 xxxx 000001737000 	lls     1                   " Set for dvf
000102 xxxx 000621507000 	dvf     =1000000			" Get seconds since 1900.
000103 xxxx 000044777000 	llr     36                  " Into Q.
000104 xxxx 000074506007 	div     60,dl               " Seconds since min to A, mins to Q.
000105 xxxx 000201755000 	sta     rdclock.sec         " Save for inspection.
000106 xxxx 000074506007 	div     60,dl               " Min since hr to A, hrs to Q.
000107 xxxx 000200755000 	sta     rdclock.min
000110 xxxx 000006627000 	eax7	6
000111 xxxx 000171702000 	tsx2	datecv              " Convert the minutes.
000112 xxxx 000211176000 	sbq     rdclock.zone_temp	" Adjust for GMT.
000113 xxxx 000030506007 	div     24,dl               " Days since 1900 in q.
000114 xxxx 000210756000 	stq     rdclock.day_of_century	" save for  later.
000115 xxxx 000177755000 	sta     rdclock.hr          " Hours since daybreak.
000116 xxxx 000171702000 	tsx2	datecv              " Convert the hours
000117 xxxx 002665506007 	div     365*4+1,dl          " get leap year cycle
000120 xxxx 002110115007 	cmpa	365*3+1,dl          " if in last year of cycle (the leap year)
000121 xxxx 000123604000 	tmi     *+2                 " no
000122 xxxx 000221054000 	aos     montab+1			" allow for feb 29
000123 xxxx 000002736000 	qls     2                   " 4*# leap year cycles
000124 xxxx 003555036007 	adlq	1901,dl
000125 xxxx 000207756000 	stq     rdclock.year		" Save
000126 xxxx 000044777000 	llr     36
000127 xxxx 000555506007 	div     365,dl              " Years complete since l.y.c. =>Q
000130 xxxx 000004116007 	cmpq	4,dl                " Dec 31st of leap year?
000131 xxxx 000134601000 	tnz     *+3                 " No.
000132 xxxx 000001176007 	sbq     1,dl                " Adjust year and
000133 xxxx 000555235007 	lda     365,dl              " day numbers.
000134 xxxx 000207056000 	asq     rdclock.year		" Add in years complete.
000135 xxxx 000000626000 	eax6	0                   " search for correct month
000136 xxxx 030220520201 	rpt     12,1,tmi			" ..
000137 xxxx 000220175016 	sba     montab,6			" subtract off days for each month
000140 xxxx 777777075016 	ada     -1,6                " put back last entry
000141 xxxx 000001075007 	ada     1,dl                " plus one more
000142 xxxx 000204755000 	sta     rdclock.day_of_month	" Day of month
000143 xxxx 000171702000 	tsx2	datecv              " convert day
000144 xxxx 000000635016 	eaa     0,6
000145 xxxx 000220135003 	sbla	montab,du			" get index into month table
000146 xxxx 000022771000 	arl     18                  "..
000147 xxxx 000202755000 	sta     rdclock.month		" Save month number
000150 xxxx 000245236005 	ldq     rdc.months-1,al		" Get name of month.
000151 xxxx 000203756000 	stq     rdclock.month_name
000152 xxxx 000171702000 	tsx2	datecv              " convert month
000153 xxxx 000000024400 	mvne	(),(),()			" edit the date and time
000154 xxxx 000214070010 	desc4ns	date,8
000155 xxxx 000234000014 	desc9a	datedit,12
000156 xxxx 000216020014 	desc6a	rdctime,12
000157 xxxx 000210236000 	ldq     rdclock.day_of_century
000160 xxxx 000002076007 	adq     2,dl                " Bump Tuesday into place.
000161 xxxx 000007506007 	div     7,dl
000162 xxxx 000205755000 	sta     rdclock.day_of_week
000163 xxxx 000237236005 	ldq     rdc.days,al         " Get name of day.
000164 xxxx 000206756000 	stq     rdclock.day_name
000165 xxxx 000216237000 	ldaq	rdctime             " get conversion in AQ
000166 xxxx 000166622000 datx2:	eax2	*			" restore XR's
000167 xxxx 000167620000 	eax0    *               " ..
000170 xxxx 000000710012 	tra     0,2             " return to caller
000171 xxxx 000213755000 datecv:	sta	datenum			" save number
000172 xxxx 000017301400 	btd     (),(x7)         " convert into proper place
000173 xxxx 000213000004 	desc9a	datenum,4
000174 xxxx 000214070002 	desc4ns	date,2
000175 xxxx 777776627017 	eax7	-2,7			" move offset index
000176 xxxx 000000710012 	tra     0,2             " and return
000177 xxxx 000000000000 	bss	,1
000200 xxxx 000000000000 	bss	,1
000201 xxxx 000000000000 	bss	,1
000202 xxxx 000000000000 	bss	,1
000203 xxxx 000000000000 	bss	,1
000204 xxxx 000000000000 	bss	,1
000205 xxxx 000000000000 	bss	,1
000206 xxxx 000000000000 	bss	,1
000207 xxxx 000000000000 	bss	,1
000210 xxxx 000000000000 	bss	,1
000211 xxxx 000000000007     dec     7   "8
000212 xxxx 160163164040     aci     'pst '
000213 xxxx 000000000000 datenum:	bss	,1
000214 xxxx 000000000000 date:	bss	,1
000215 xxxx 000000011000 	even "(allocating 1 nop)
000216 xxxx 000000000000 rdctime:	bss	,2
000220 xxxx 000000000037 montab:	dec	31,28,31,30,31,30,31,31,30,31,30,31
000221 xxxx 000000000034 
000222 xxxx 000000000037 
000223 xxxx 000000000036 
000224 xxxx 000000000037 
000225 xxxx 000000000036 
000226 xxxx 000000000037 
000227 xxxx 000000000037 
000230 xxxx 000000000036 
000231 xxxx 000000000037 
000232 xxxx 000000000036 
000233 xxxx 000000000037 
000234 xxxx 401020102260 datedit:	vfd	9/lte+1,o9/20,9/mvzb+2,9/insp,o9/61,9/mvc+2,9/insm+1,9/mvc+2
000235 xxxx 061322021322 
000236 xxxx 260015322021 	vfd	9/insp,o9/15,9/mvc+2,9/insm+1
000237 xxxx 163165156040 rdc.days: aci	'sun mon tue wed thurfri sat '
000240 xxxx 155157156040 
000241 xxxx 164165145040 
000242 xxxx 167145144040 
000243 xxxx 164150165162 
000244 xxxx 146162151040 
000245 xxxx 163141164040 
000246 xxxx 152141156040 	aci	'jan feb mar apr may jun jul aug septoct nov dec '
000247 xxxx 146145142040 
000250 xxxx 155141162040 
000251 xxxx 141160162040 
000252 xxxx 155141171040 
000253 xxxx 152165156040 
000254 xxxx 152165154040 
000255 xxxx 141165147040 
000256 xxxx 163145160164 
000257 xxxx 157143164040 
000260 xxxx 156157166040 
000261 xxxx 144145143040 
000262 xxxx 000265710000 crlf:	save
000263 xxxx 000000000000 
000264 xxxx 000263630000 
000265 xxxx 000263754000 
000266 xxxx 000263741000 
000267 xxxx 000276755000         sta     saveA
000270 xxxx 000622235000         lda     =012
000271 xxxx 000001420400         emCall  1
000272 xxxx 000623235000         lda     =015
000273 xxxx 000001420400         emcall  1
000274 xxxx 000276235000         lda     saveA
000275 xxxx 000264710000         return  crlf
000276 xxxx 000000000000 saveA:  bss     1
000277 xxxx 000306710000 ioa:    save    2, 4, 5, 6
000300 xxxx 000000000000 
000301 xxxx 000000222003 
000302 xxxx 000001224003 
000303 xxxx 000002225003 
000304 xxxx 000003226003 
000305 xxxx 000300630000 
000306 xxxx 000300754000 
000307 xxxx 000300741000 
000310 xxxx 000301742000 
000311 xxxx 000302744000 
000312 xxxx 000303745000 
000313 xxxx 000304746000 
000314 xxxx 000002624031 ioa1:   eax4    2, 1*   " 1st arg is control string
000315 xxxx 000003625011         eax5    3, 1    " next arg is the 1st of the numeric args. x5 points to next argument
000316 xxxx 000000626015         eax6    0, x5
000317 xxxx 000041235007         lda     041, dl " make a blank tallyb word .....
000320 xxxx 000335755000         sta     i29
000321 xxxx 000000235014     	lda     0, x4   " get 1st data word into A
000322 xxxx 000033731000         ars     27      " determine word count
000323 xxxx 000006735000     	als     6       " count to upper word of tally
000324 xxxx 000335255000     	orsa    i29
000325 xxxx 000000626014     	eax6    0, x4   " address of string into X6
000326 xxxx 000335746000     	stx6    i29     " address to upper word of tally
000327 xxxx 000335235052 inext:  lda     i29, sc
000330 xxxx 000136115007         cmpa    =o000136,dl		" ^
000331 xxxx 000336600000         tze     iernot      " if so, go process it
000332 xxxx 000001420400 out1:  	emCall  1
000333 xxxx 000327607000     	ttf     inext
000334 xxxx 000301710000         return  ioa
000335 xxxx 000000000041 i29:	tallyb  0, 0, 1
000336 xxxx 000335235052 iernot: lda     i29, sc         " get next char ...
000337 xxxx 000136115007         cmpa    =o000136,dl     " is it another "^"?
000340 xxxx 000356600000         tze     i21             " No, just print it ...
000341 xxxx 000167115007         cmpa    =o000167,dl     " is it a "w"?
000342 xxxx 000360600000         tze     idoW            " do full word octal
000343 xxxx 000157115007         cmpa    =o000157,dl     " is it an "o"?
000344 xxxx 000406600000         tze     idoO            " print zero suppressed octal
000345 xxxx 000156115007         cmpa    =o000156,dl     " is it a "n"?
000346 xxxx 000431600000         tze     idoN            " octal w/ no spaces inserted
000347 xxxx 000144115007         cmpa    =o000144,dl     " is it a "d"?
000350 xxxx 000460600000         tze     idoD            " decimal
000351 xxxx 000141115007         cmpa    =o000141,dl     " is it a ^a?
000352 xxxx 000466600000         tze     idoA            " 4 char ascii display
000353 xxxx 000147115007         cmpa    =o000147,dl     " is it a ^g?
000354 xxxx 000477600000         tze     idoG            " 6 char GE BCD display
000355 xxxx 000332710000         tra     out1        " unknown just print it....
000356 xxxx 000001420400 i21:    emCall  1           " output A to console
000357 xxxx 000327710000         tra     inext
000360 xxxx 000000235035 idoW:   lda     0, 5*       " ^w - full-word octal xxxxxx xxxxxx
000361 xxxx 000555702000         tsx2    octwd
000362 xxxx 000456757000         staq    ioaSafe     " bcd in AQ
000363 xxxx 000044773000         lrl     36          " A => Q
000364 xxxx 000006622000         eax2    6
000365 xxxx 000000235007 idoW2:  lda     =0, dl
000366 xxxx 000006737000         lls     6
000367 xxxx 000002420400         emCall  2           " output GE code char to console
000370 xxxx 777777622012         eax2    -1, 2
000371 xxxx 000365601000         tnz     idoW2
000372 xxxx 000456237000         ldaq    ioaSafe
000373 xxxx 000000235007         lda     =0, dl      " 0 => A
000374 xxxx 000020235007         lda     =020 ,dl     " bcd ' ' => A
000375 xxxx 000002420400         emcall  2
000376 xxxx 000006622000         eax2    6
000377 xxxx 000000235007 idoW3:  lda     =0,dl
000400 xxxx 000006737000         lls     6
000401 xxxx 000002420400         emCall  2
000402 xxxx 777777622012         eax2    -1, 2
000403 xxxx 000377601000         tnz     idoW3
000404 xxxx 000001065003         adx5    1,du
000405 xxxx 000327710000         tra     inext
000406 xxxx 000000235035 idoO:   lda     0, 5*           " ^o - Zero-suppressed octal
000407 xxxx 000555702000         tsx2    octwd
000410 xxxx 000456757000         staq    ioaSafe         " bcd in AQ
000411 xxxx 000427235000         lda     idOTly
000412 xxxx 000430755000         sta     idOT
000413 xxxx 000430235052 idO1:   lda     idOT, sc        " get char into A
000414 xxxx 000000115007         cmpa    =0, dl          " a zero?
000415 xxxx 000423601000         tnz     idONZ + 1       " nope
000416 xxxx 000413607000         ttf     idO1            " Yes, a Zero. Go for more
000417 xxxx 000002420400         emCall  2               " output a single 0
000420 xxxx 000001065003         adx5    1,du
000421 xxxx 000327710000         tra     inext
000422 xxxx 000430235052 idONZ:  lda     idOT, sc        " get char into A
000423 xxxx 000002420400         emCall  2
000424 xxxx 000422607000         ttf     idONZ           " Yes, a Zero. Go for more
000425 xxxx 000001065003         adx5    1,du
000426 xxxx 000327710000         tra     inext
000427 xxxx 000456001400 idOTly: tally   ioaSafe, 12, 0
000430 xxxx 000000000000 idOT:   bss     1
000431 xxxx 000000235035 idoN:   lda     0, 5*       " ^n - octal w/ no spaces inserted
000432 xxxx 000555702000         tsx2    octwd
000433 xxxx 000456757000         staq    ioaSafe     " bcd in AQ
000434 xxxx 000044773000         lrl     36          " A => Q
000435 xxxx 000006622000         eax2    6
000436 xxxx 000000235007 idoN2:  lda     =0,dl
000437 xxxx 000006737000         lls     6
000440 xxxx 000002420400         emCall  2           " output GE code char to console
000441 xxxx 777777622012         eax2    -1, 2
000442 xxxx 000436601000         tnz     idoN2
000443 xxxx 000456237000         ldaq    ioaSafe
000444 xxxx 000000235007         lda     =0, dl      " 0 => A
000445 xxxx 000006622000         eax2    6
000446 xxxx 000000235007 idoN3:  lda     =0, dl
000447 xxxx 000006737000         lls     6
000450 xxxx 000002420400         emCall  2
000451 xxxx 777777622012         eax2    -1, 2
000452 xxxx 000446601000         tnz     idoN3
000453 xxxx 000001065003         adx5    1,du
000454 xxxx 000327710000         tra     inext
000455 xxxx 000000011000         even "(allocating 1 nop)
000456 xxxx 000000000000 ioaSafe:  bss 2
000460 xxxx 000000236035 idoD:   ldq     0, 5*       " ^d
000461 xxxx 000510701000         call    toDec
000462 xxxx 000464710000 
000463 xxxx 000000000000 
000464 xxxx 000001065003         adx5    1,du
000465 xxxx 000327710000         tra     inext
000466 xxxx 000000236035 idoA:   ldq     0, 5*      " ^a (4 ascii chars into Q)
000467 xxxx 000004622000         eax2    4
000470 xxxx 000000235007 idoA2:  lda     =0,dl
000471 xxxx 000011737000         lls     9
000472 xxxx 000001420400         emCall  1
000473 xxxx 777777622012         eax2    -1, 2
000474 xxxx 000470601000         tnz     idoA2
000475 xxxx 000001065003         adx5    1,du        " into next argument
000476 xxxx 000327710000         tra     inext
000477 xxxx 000000236035 idoG:   ldq     0, 5*        " ^g (6 GE BCD chars into Q)
000500 xxxx 000006622000         eax2    6
000501 xxxx 000000235007 idoG2:  lda     =0,dl
000502 xxxx 000006737000         lls     6
000503 xxxx 000002420400         emCall  2
000504 xxxx 777777622012         eax2    -1, 2
000505 xxxx 000501601000         tnz     idoG2
000506 xxxx 000001065003         adx5    1,du        " into next argument
000507 xxxx 000327710000         tra     inext
000510 xxxx 000513710000 toDec:  save    "2,3,4,5,6,7
000511 xxxx 000000000000 
000512 xxxx 000511630000 
000513 xxxx 000511754000 
000514 xxxx 000511741000 
000515 xxxx 000624116000         cmpq    =-34359738368       " the weird one?
000516 xxxx 000522601000         tnz     toDec2
000517 xxxx 000554235000         lda     decMTly             " just print it and be done with it
000520 xxxx 000550755000         sta     decTly
000521 xxxx 000540710000         tra     toDec1
000522 xxxx 000544756000 toDec2: stq     decNo
000523 xxxx 000000116007         cmpq    =0,dl       " Q < 0?
000524 xxxx 000526605000         tpl     toDec0      " No
000525 xxxx 000544336000         lcq     decNo       " -decNo => Q
000526 xxxx 000012506007 toDec0: div     =10,dl      " divide Q by 10, remainder in A
000527 xxxx 000060075007         ada     =o060,dl    " add ascii '0' (=1A0) to A
000530 xxxx 000550755045         sta     decTly, scr " start writing characters backwards
000531 xxxx 000000076007         adq     =0,dl       " set flags to test if Q == 0
000532 xxxx 000526601000         tnz     toDec0      " if Q == 0 then we're essentially done with conversion
000533 xxxx 000544235000         lda     decNo
000534 xxxx 000000115007         cmpa    =0,dl
000535 xxxx 000540605000         tpl     toDec1
000536 xxxx 000055235007         lda     =o055,dl    " (-) => A
000537 xxxx 000550755045         sta     decTly, scr " write (-) sign
000540 xxxx 000550235052 toDec1: lda     decTly, sc
000541 xxxx 000001420400         emCall  1
000542 xxxx 000540607000         ttf     toDec1
000543 xxxx 000512710000         return  toDec
000544 xxxx 000000000000 decNo:  dec     0
000545 xxxx 000000000000 decBuf: bss     3
000550 xxxx 000547000040 decTly: tallyb  decBuf+2, , 0
000551 xxxx 055063064063 decMM:  aci     "-34359738368"  " -2^^35
000552 xxxx 065071067063 
000553 xxxx 070063066070 
000554 xxxx 000551001440 decMTly:tallyb  decMM, 12, 0
000555 xxxx 000572742000 octwd:	stx2	octx2
000556 xxxx 000006622000 	eax2	6
000557 xxxx 000003736000 	qls     3
000560 xxxx 000003777000 	llr     3
000561 xxxx 777777622012 	eax2	-1,2
000562 xxxx 000557605400 	tpnz	*-3
000563 xxxx 000614756000 	stq     octtemp
000564 xxxx 000006622000 	eax2	6
000565 xxxx 000003736000 	qls     3
000566 xxxx 000003777000 	llr     3
000567 xxxx 777777622012 	eax2	-1,2
000570 xxxx 000565605400 	tpnz	*-3
000571 xxxx 000614235000 	lda     octtemp
000572 xxxx 000572622000 octx2:	eax2	*
000573 xxxx 000000710012 	tra     0,2
000574 xxxx 000612742000 hexwd:	stx2	hexx2
000575 xxxx 000044773000 	lrl     36          "shift to Q
000576 xxxx 000006622000 	eax2	6           "	process 6 characters
000577 xxxx 000000235007 hexloop:	lda	=0,dl	"	clear A
000600 xxxx 000004737000 	lls     4           "shift in 4 bits
000601 xxxx 000011115007 	cmpa	=9,dl		"greater than 9?
000602 xxxx 000604604400 	tmoz	*+2
000603 xxxx 000007035007 	adla	=7,dl       "if so, change to letter
000604 xxxx 000006773000 	lrl     6
000605 xxxx 000614235000 	lda     octtemp		"get temporary
000606 xxxx 000006737000 	lls     6           "insert new character
000607 xxxx 000614755000 	sta     octtemp		"and store
000610 xxxx 777777622012 	eax2	-1,2		"decrement index
000611 xxxx 000577605400 	tpnz	hexloop
000612 xxxx 000612622000 hexx2:	eax2	*
000613 xxxx 000000710012 	tra     0,2		"return to caller
000614 xxxx 000000000000 octtemp:	oct	0
000615 xxxx 000000000052 decimal literal (=42)
000616 xxxx 777777777726 decimal literal (=-42)
000617 xxxx 000000361100 decimal literal (=123456)
000620 xxxx 000036064103 decimal literal (=7891011)
000621 xxxx 000003641100 decimal literal (=1000000)
000622 xxxx 000000000012 octal literal (=o12)
000623 xxxx 000000000015 octal literal (=o15)
000624 xxxx 400000000000 decimal literal (=-34359738368)
