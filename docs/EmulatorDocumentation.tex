\documentclass[notitlepage]{report}
\usepackage {listings}
\usepackage{ulem}
\renewcommand{\thesection}{\arabic{part}.\arabic{section}}
\makeatletter
\@addtoreset{section}{part}
\makeatother 

\begin{document}
\title{Emulation Implementation Notes}
%\author{}
%\date{}
\maketitle

\part{Source Code Layout}

\section{dps8\_sys} 

This module handles the abstract "entire system." The bulk of the code is 
initialization and simh command processing hooks.

\subsection{dps8\_cable}

Hardware device cabling emulation

\section{dps8\_cpu} 

The CPU emulator

\subsection{dsp8\_iefp}

CPU Memory access

\subsection{dps8\_addrmods}

CPU Address Modifcation

\subsection{dps8\_append}

CPU Append Unit

\subsection{dps8\_bar}

CPU BAR address computation

\subsection{dps8\_ins}

CPU instructions

\subsection{dps8\_eis}

CPU EIS instructions

\subsection{dps8\_math}

CPU math support routines

\subsection{dps8\_opcode}

CPU opcode table; drives address preparation and mode checking

\subsection{dps8\_faults}

CPU fault handling code

\subsection{dps8\_decimal}

CPU Decimal math support routines

\section{dps8\_scu}

The SCU emulator

\section{dps8\_iom}

The IOM emulator

\subsection{dps8\_console}

Operator console device

\subsection{dps8\_disk}

Disk device

\subsection{dps8\_mt}

Tape device

\subsection{dps8\_fnp, fnp\_ipc}

FNP device

\subsection{dps8\_lp}

Printer device

\subsection{dps8\_crdrdr}

Card reader device

\section{dps8\_utils}

Common utility routines

\subsection{shm}

Host shared memory management

\section{Other}

dps8\_utils Common support code \\
dps8\_clk  Unused simh clock hooks \\
dps8\_loader Segment loader for unit tests \\
dps8\_stddev Vestigial \\
dps8\_fxe Faux Multics Execution module

%+ Variations between the hardware and the emulator ("as built" drawings).
%
%DPS8 memory is managed by the CPU code, not the SCU code.
%
%The history registers are not implemented.
%
%The RPL instruction is not implemented.
%
%The MPCs have been abstracted into the device code.
%
\part{CPU operation}

\section{simh}

When simh is running the CPU it calls sim\_instr(), which is the CPU emulator entry point.

sim\_instr() loops, executing emulated instructions until some emulation halting condition is met, or some simh component signals for a pause due to an external
event.

\section{CPU emulation organization}

sim\_instr first establishes a setjmp context; this is used primarily by RCU 
mechanism to restart instruction processing after restoring a saved system
state due to a fault or an interrupt.

The cpu emulation is written as a state machine. The longjmp parameter is 
used to setup the desired state; at initial entry, setjmp returns a zero, 
and the appropriate setup is done.

\begin{verbatim}
#define JMP\_ENTRY       0

    int val = setjmp(jmpMain);

    switch (val)
      {
        case JMP\_ENTRY:
        case JMP\_REENTRY:
            reason = 0;
            break;
        case JMP\_NEXT:
            goto nextInstruction;
        case JMP\_STOP:
            reason = STOP\_HALT;
            goto leave;
        case JMP\_SYNC\_FAULT\_RETURN:
            goto syncFaultReturn;
        case JMP\_REFETCH:
            cpu . wasXfer = false;
            setCpuCycle (FETCH\_cycle);
            break;
        case JMP\_RESTART:
            setCpuCycle (EXEC\_cycle);
            break;
        default:
          sim\_printf ("longjmp value of %d unhandled\n", val);
          goto leave;
      }

\end{verbatim}

The cpu emulation then enters a "do {...} while (reason == 0)" loop,
which cycles the CPU through its states.

The top of the loop checks the simh components for events that need
to be handled (simh\_hooks()), polls various subsystems for service requests
(emulator console commands to be processed, incoming FNP messages and 
operator console input).

\begin{verbatim}
        reason = 0;

        // Process deferred events and breakpoints
        reason = simh\_hooks ();
        if (reason)
          {
            //sim\_printf ("reason: %d\n", reason);
            break;
          }

        static uint queueSubsample = 0;
        if (queueSubsample ++ > 10240) // ~ 100Hz
          {
            queueSubsample = 0;
            scpProcessEvent ();
            fnpProcessEvent ();
            consoleProcess ();
          }
        if (check\_attn\_key ())
          console\_attn (NULL);
\end{verbatim}

It then checks for Timer Register runout, setting the group 7 fault flag
if needed. (Group 7 faults are distinguished as not resulting from
instruction execution, but external events; and has such are handled
synchronously between instruction execution steps, rather then 
interrupting mid-instruction. 

\begin{verbatim}
    bool overrun;
    UNUSED word27 rTR = getTR (& overrun);
    if (overrun)
      {
        ackTR ();
        if (switches . tro\_enable)
          setG7fault (FAULT\_TRO, 0);
      }
\end{verbatim}

Next, it then checks for lockup (the operating system has not enabled 
interrupts for more then 32 ms.), and faults if needed.

\begin{verbatim}
        lufCounter ++;
        // Assume CPU clock ~ 1Mhz. lockup time is 32 ms
        if (lufCounter > 32000)
          {
            lufCounter = 0;
            doFault (FAULT\_LUF, 0, "instruction cycle lockup");
          }
\end{verbatim}

Lastly, it checks the CPU state and branches to the appropriate code.

\begin{verbatim}
    switch (cpu . cycle)
      {
        case INTERRUPT\_cycle:
          ....
      }
\end{verbatim}

The states are:

\begin{description}
\item [FETCH\_cycle] Fetch the next instruction
\item [EXEC\_cycle] Execute an instruction
\item [INTERRUPT\_cycle] Fetch an Interrupt instruction pair
\item [INTERRUPT\_EXEC\_cycle] Execute the even instruction of an interrupt pair
\item [INTERRUPT\_EXEC2\_cycle] Execute the odd instruction of an interrupt pair
\item [FAULT\_cycle]Fetch an Fault instruction pair
\item [FAULT\_EXEC\_cycle] Execute the even instruction of a fault pair
\item [FAULT\_EXEC2\_cycle] Execute the odd instruction of a fault pair
\end{description}

The normal instruction flow is alternating FETCH and EXEC cycles.

\section{FETCH\_cycle}

The fetch cycle first checks for pending interrupts and group 7 faults, 
according to complex eligibility rules (AL39, pg 327, "Interrupt Sampling.")

\begin{verbatim}
    if ((! cpu . wasInhibited) &&
        (PPR . IC % 2) == 0 &&
        (! cpu . wasXfer) &&
        (! (cu . xde | cu . xdo | cu . rpt | cu . rd)))
      {
        cpu . interrupt\_flag = sample\_interrupts ();
        cpu . g7\_flag = bG7Pending ();
      }
    // The cpu . wasInhibited accumulates across the even and 
    // odd intruction. If the IC is even, reset it for
    // the next pair.

    if ((PPR . IC % 2) == 0)
      cpu . wasInhibited = false;
\end{verbatim}

If a eligible interrupt is pending, the CPU state is switched to 
INTERRUPT\_cycle.

\begin{verbatim}
    if (cpu . interrupt\_flag)
      {
        setCpuCycle (INTERRUPT\_cycle);
        break;
      }
\end{verbatim} 

Likewise, if a Group 7 faults is pending, cause a fault.

\begin{verbatim}
    if (cpu . g7\_flag)
      {
        cpu . g7\_flag = false;
        doG7Fault ();
      }
\end{verbatim}

There is now code to process the XEC and XED instructions; the idea here is
that the processing of the XEC and XED instructions loads the target 
instructions into the Control Unit IWB and IODD words, and that the 
fetch cycle is a no-op, as the instructions have already been 
fetched.

If not the XEC or XED the case, the instruction is fetched into the
CU IWB word.

\begin{verbatim}
    else
      {
        processorCycle = INSTRUCTION\_FETCH;
        clr\_went\_appending ();
        fetchInstruction (PPR . IC);
      }
\end{verbatim}

Now that the instruction is in the IWB, switch to EXEC state.

\begin{verbatim}
    setCpuCycle (EXEC\_cycle);
    break;
\end{verbatim}

\end{document}
